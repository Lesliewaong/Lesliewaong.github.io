<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MQ | Leslie Waong</title><meta name="keywords" content="前端 Java 空间光通信"><meta name="author" content="Leslie Waong"><meta name="copyright" content="Leslie Waong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基于Android的电子词典设计离线情况和有网络的情况。 单词数据的爬取 借助Python的Requests库和lxml库   Requests构建HTTP的请求头伪装成浏览器与词典网站进行通信，发起请求和获取响应内容，对应的方法为get方法。主要是获得相应url对应的html。  XPath，全称 XML Path Language，即XML路径语言,以XML树结构为基础，能够在数据的结构树中查"><meta property="og:type" content="article"><meta property="og:title" content="MQ"><meta property="og:url" content="https://lesliewaong.top/posts/186242d5.html"><meta property="og:site_name" content="Leslie Waong"><meta property="og:description" content="基于Android的电子词典设计离线情况和有网络的情况。 单词数据的爬取 借助Python的Requests库和lxml库   Requests构建HTTP的请求头伪装成浏览器与词典网站进行通信，发起请求和获取响应内容，对应的方法为get方法。主要是获得相应url对应的html。  XPath，全称 XML Path Language，即XML路径语言,以XML树结构为基础，能够在数据的结构树中查"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/5.jpg"><meta property="article:published_time" content="2021-07-11T05:14:52.000Z"><meta property="article:modified_time" content="2022-04-19T03:31:03.324Z"><meta property="article:author" content="Leslie Waong"><meta property="article:tag" content="前端 Java 空间光通信"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/5.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg"><link rel="canonical" href="https://lesliewaong.top/posts/186242d5"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"一年之内的产物",messageNext:"技术可能存在过期"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Leslie Waong",link:"链接: ",source:"来源: Leslie Waong",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"MQ",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-04-19 11:31:03"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px");const a=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};a(),document.addEventListener("pjax:complete",a)})(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Leslie Waong" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/5.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leslie Waong</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MQ</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-11T05:14:52.000Z" title="发表于 2021-07-11 13:14:52">2021-07-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-19T03:31:03.324Z" title="更新于 2022-04-19 11:31:03">2022-04-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">73.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>253分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="MQ"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基于Android的电子词典设计"><a href="#基于Android的电子词典设计" class="headerlink" title="基于Android的电子词典设计"></a>基于Android的电子词典设计</h1><p>离线情况和有网络的情况。</p><h2 id="单词数据的爬取"><a href="#单词数据的爬取" class="headerlink" title="单词数据的爬取"></a>单词数据的爬取</h2><blockquote><p>借助Python的Requests库和lxml库</p></blockquote><ul><li><p>Requests构建HTTP的请求头<strong>伪装成浏览器与词典网站进行通信</strong>，<strong>发起请求</strong>和<strong>获取响应内容</strong>，对应的方法为<strong>get</strong>方法。主要是获得相应url对应的html。</p></li><li><p>XPath，全称 XML Path Language，即<strong>XML路径语言</strong>,以<strong>XML树结构</strong>为基础，能够在数据的结构树中查找各类节点，比如属性节点、文本节点和元素节点等等。在检查元素中右键即可复制它的XPath路径，分析规律并且结合XPath的表达式语法，就可获取相关文本内容。</p></li><li><p>本项目使用<code>Multiprocessing</code>的<code>Pool</code>方法设置一定进程数量的进程池，将所有需要爬虫的单词异步执行，也就是非阻塞的方式。</p></li><li><p>当时遇到的问题<strong>多进程爬取的数据无法同时向SQLite数据库中保存</strong>，因此先爬取内容到<code>TXT</code>，再保存到数据库中。</p></li></ul><h2 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h2><p>使用<strong>布局编辑器</strong>构建界面。</p><ul><li><p>根布局就是<code>DrawerLayout</code>，在根布局之后又主要分为两大部分，第一部分就是我们主界面的内容，第二部分是左边滑出的布局，这里用NavitationView来代替。</p></li><li><p>线性布局（<code>LinearLayout</code>）和相对布局（<code>RelativeLayout</code>）实现。</p><ul><li>线性布局是将界面中的全部控件按照<strong>水平</strong>或<strong>竖直</strong>方向进行排列，同时它也是最基本的布局方式。</li><li>相对布局则是通过控件之间的<strong>相对位置</strong>关系实现控件的摆放，有利于适配不同屏幕大小的手机，因此使用更为普遍。</li></ul></li><li><p>一般布局都是用<code>dp</code>，字体用<code>sp</code>（手机字体调大了，APP的字体会随之变大）来布局的，用来<strong>适配移动端分辨率</strong>。</p></li></ul><h2 id="API或SDK"><a href="#API或SDK" class="headerlink" title="API或SDK"></a>API或SDK</h2><p>调用百度API实现句子翻译的功能。调用讯飞开放平台的SDK实现语音输入的功能。</p><ul><li><p>API 全称 Application Programming Interface，即<strong>「应用程序接口」</strong>。一般是指一些预先定义的<strong>函数</strong>，目的是供应用程序与开发人员基于某软件或硬件得以访问一组程序的能力，而又无需访问源码，或理解内部工作机制的细节。</p></li><li><p>SDK 全称 Software Development Kit，<strong>软件开发工具包</strong>。通俗来讲就是<strong>第三方服务商提供的实现产品软件某项功能的工具包</strong>。例如 JDK 就是一种 SDK。</p></li><li><p><strong>API 在更多场合下更像是 SDK 的一个子集</strong>，他们的区别如下：</p><ul><li><p>API 通常是一个<strong>函数</strong>，有特定的功能；而 SDK 是一个很多功能函数的<strong>集合体</strong>，更像是一个<strong>工具包</strong>。</p></li><li><p>API 通常扮演<strong>数据接口</strong>的形象，SDK 相当于一个<strong>工具环境</strong>，通常是需要在 SDK 的环境下调用 APl。</p></li><li><p><strong>SDK 相较于 API 封装层次更高</strong>。</p></li></ul></li></ul><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过<strong>分离关注点</strong>的方式来组织代码结构，优化我们的开发效率。</p><h3 id="Android-MVC"><a href="#Android-MVC" class="headerlink" title="Android MVC"></a>Android MVC</h3><ul><li><p><strong>View：</strong>XML布局文件。</p></li><li><p><strong>Model：</strong>实体模型（数据的获取、存储、数据状态变化）。</p></li><li><p><strong>Controller：</strong>对应于Activity，处理数据、业务和UI。</p></li></ul><p>从上面这个结构来看，Android本身的设计还是符合MVC架构的，但是<strong>Android中纯粹作为View的XML视图功能太弱，我们大量处理View的逻辑只能写在Activity中，这样Activity就充当了View和Controller两个角色</strong>，直接导致Activity中的代码大爆炸。相信大多数Android开发者都遇到过一个Acitivty数以千行的代码情况吧！所以，更贴切的说法是，这个MVC结构最终其实只是一个<strong>Model-View（Activity:View&amp;Controller）</strong>的结构。</p><h3 id="Android-MVVM"><a href="#Android-MVVM" class="headerlink" title="Android MVVM"></a>Android MVVM</h3><p>**View: **对应于Activity和XML，负责View的绘制以及与用户交互。</p><p>**Model: **实体模型。</p><p><strong>ViewModel: <strong>负责完成View与Model间的交互，负责</strong>业务逻辑</strong>。</p><p>Android为此提供了一套<strong>架构组件</strong>，主要有LiveData、ViewModel 和Room。</p><ul><li>LiveData是用来构建数据对象，当基础数据库改变时会通知视图；</li><li>ViewModel是用来<strong>存储和管理与界面相关的数据</strong>，这些数据在应用跳转时不会被销毁；</li><li>Room是一个SQLite对象映射库，它可以轻松地将SQLite表数据转换为Java对象，主要负责底层数据库的处理，本文调用其中的Dao接口来执行数据库增删改查等操作，利用 Database创建和管理数据库。同时，Room可以为SQLite语句提供编译时检查，并能够返回RxJava、Flowable和LiveData可观察对象。</li><li>Repository是一个仓库类，介于视图层与数据映射层（数据访问层）之间。它的作用是让视图层感觉不到数据访问层的存在，提供了一个类似集合的接口给视图层进行访问。</li></ul><p>采用MVVM模式最大的优点就是编写代码是思路明确，<strong>视图层与模型层完全解耦</strong>，方便后期的管理与维护，数据库相关的操作非常方便。</p><p>MVVM 模式中的VM，通过双向的数据绑定，<strong>将 View 和 Model 的同步更新给自动化了</strong>。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如vue是通过使用数据劫持和发布订阅者模式来实现的这一功能。</p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p><strong>Hexo</strong>：一个快速、简洁且高效的<strong>博客框架</strong>。Hexo 使用 <code>Markdown</code>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p><strong>Butterfly</strong>：主题。</p><p><strong>Github Pages</strong>：简单点来说，就是它为你的项目提供一个<strong>访问站点</strong>，并且<strong>直接指向你的仓库</strong>，你仓库更新，站点网站自动更新。</p><p>Github Pages可以被认为是<strong>用户编写的、托管在Github上的静态网页</strong>。使用Github Pages可以为你提供一个免费的服务器，<strong>免去了自己搭建服务器和写数据库</strong>的麻烦。此外还可以<strong>绑定自己的域名</strong>。</p><p><code>npm</code>：安装各种依赖。</p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>因为页面自身还是在 GitHub Pages 托管，有时候首个请求还是会挺久才返回。</p><h2 id="性能检测"><a href="#性能检测" class="headerlink" title="性能检测"></a>性能检测</h2><ul><li><p><code>Network</code>面板是一个常被用到的工具，通过它可以<strong>获取到网站所有资源的请求情况</strong>，包括<strong>加载时间</strong>，<strong>资源大小</strong>，优先级设置、<strong>瀑布图</strong>以及<code>HTTP</code>缓存等信息。可以帮助开发者发现可能由于未进行有效压缩而导致资源尺寸过大的问题，未配置缓存策略导致二次请求加载时间过长的问题。</p></li><li><p><code>Lighthouse</code>是谷歌开发并开源的<code>web</code>性能测试工具，用于改进网络应用的质量，可以将其作为一个<code>Chrome</code>扩展程序运行，或从命令行运行。在浏览器的调试工具中默认就存在<code>lighthouse</code>选项，只需要切换至<code>lighthouse</code>，在右侧的选项区选中需要的选项。点击生成报告。</p></li><li><p>使用<code>Performance</code>面板主要对网站应用的运行时性能表现进行检测和分析，包括页面的每秒帧数，<code>CPU</code>的消耗和各种请求花费的时间。</p></li></ul><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><blockquote><p><strong>样式表放在顶部</strong>，<strong>将脚本放在底部</strong>，<strong>减少重绘回流</strong>，<strong>按需加载</strong>，<strong>模块化</strong></p><p>并不是所有的业务场景都适合使用工程化框架，<strong>react/vue 并不轻量</strong>。</p></blockquote><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>服务端配置<code>gzip</code>压缩后可大大缩减资源大小。图片压缩。</p><h3 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h3><p>主要用在博客的图片上面。但图片存在了Github仓库，所以性能还是有影响。</p><p>CDN是“去中心化的”。</p><p><strong>CDN加速的本质是缓存加速</strong>。</p><p><strong>将服务器上存储的静态内容缓存在CDN节点上</strong>，当访问这些静态内容时，无需访问服务器源站，<strong>就近访问CDN节点</strong>即可获取相同内容，从而达到<strong>加速</strong>的效果，同时<strong>减轻服务器源站的压力</strong>。</p><p>静态资源是指在不同请求中访问到的数据都相同的静态文件。例如：图片、视频、网站中的文件（html、css、js）、软件安装包、apk文件、压缩包文件等。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>性能优化的第一定律就是：优先考虑使用缓存。</p><p>缓存的主要手段有：浏览器缓存、CDN。</p><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>使用<code>link</code>的<code>preload</code>属性预加载一个资源。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>as属性可以指定预加载的类型，除了style还支持很多类型，常用的一般是<code>style</code>和<code>script</code>，<code>css</code>和<code>js</code>。</p><h3 id="组件渲染"><a href="#组件渲染" class="headerlink" title="组件渲染"></a>组件渲染</h3><p>拿react举例，组件分割方面不要太深。需要控制组件的渲染，尤其是深层组件的render。</p><h3 id="加载动画"><a href="#加载动画" class="headerlink" title="加载动画"></a>加载动画</h3><p>首屏加载时常用，虽然没有提高性能，但能提高用户体验。</p><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种非常好的优化网页性能的方式。</p><p><strong>当可视区域没有滚到资源需要加载的地方时候，可视区域外的资源就不会加载。</strong></p><p>可以减少服务器负载，常适用于图片很多，页面较长的业务场景中。</p><p>在HTML中，图片是由 <code>&lt;img&gt;</code> 标签引入的，是由其中的<code>src</code>属性去请求的。所以实现懒加载的关键就是，在图片没有进入可视区的时候，不给<code>src</code>属性赋值，等图片进入到了可视区，再给<code>src</code>属性赋值，去请求图片。</p><p><code>img</code>的<code>loading</code>属性。</p><p><code>&lt;img src=&quot;./example.jpg&quot; loading=&quot;lazy&quot;&gt;</code></p><p><strong>js实现原理</strong></p><p>我们通过js监听页面的滚动也能实现。</p><p>使用js实现的原理主要是判断当前图片是否到了可视区域：</p><ul><li>拿到所有的图片 dom 。</li><li>遍历每个图片判断当前图片是否到了可视区范围内。</li><li>如果到了就设置图片的 src 属性。</li><li>绑定 window 的 scroll 事件，对其进行事件监听。</li></ul><p>在页面初始化的时候，<code>&lt;img&gt;</code>图片的src实际上是放在data-src属性上的，当元素处于可视范围内的时候，就把data-src赋值给src属性，完成图片加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> viewHeight = <span class="built_in">document</span>.body.clientHeight <span class="comment">//获取可视区高度</span></span><br><span class="line">  <span class="keyword">let</span> imgs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;img[data-src]&#x27;</span>)</span><br><span class="line">  imgs.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.dataset.src === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置</span></span><br><span class="line">    <span class="keyword">let</span> rect = item.getBoundingClientRect()</span><br><span class="line">    <span class="keyword">if</span> (rect.bottom &gt;= <span class="number">0</span> &amp;&amp; rect.top &lt; viewHeight) &#123;</span><br><span class="line">      item.src = item.dataset.src</span><br><span class="line">      item.removeAttribute(<span class="string">&#x27;data-src&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, lazyload)</span><br></pre></td></tr></table></figure><p>但是这样存在较大的性能问题，因为 scroll 事件会在很短的时间内触发很多次，严重影响页面性能，为了提高网页性能，我们需要一个节流函数来控制函数的多次触发，在一段时间内（如 200ms）只执行一次回调。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttle(lazyload, <span class="number">200</span>))</span><br></pre></td></tr></table></figure><h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><blockquote><p>浏览器缓存(Brower Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力。</p><p>http缓存机制主要在<strong>http响应头</strong>中设定，响应头中相关字段为<code>Expires</code>、<code>Cache-Control</code>、<code>Last-Modified</code>、<code>Etag</code>。</p></blockquote><h3 id="基本流程（强缓存、协商缓存）"><a href="#基本流程（强缓存、协商缓存）" class="headerlink" title="基本流程（强缓存、协商缓存）"></a>基本流程（强缓存、协商缓存）</h3><p>在第一次请求时，没有缓存，直接向服务器发送请求，服务器可能会将一些关于缓存的字段放入响应头。</p><p>第二次浏览器请求某一资源时：</p><ul><li>强缓存 <code>Cache-Control</code>（max-age,优先级高）、<code>Expires</code>(GMT）=&gt; 判断<strong>是否过期</strong></li></ul><p>​ <strong>没过期则直接从缓存中获取资源信息</strong>，<strong>不会与服务器进行通信</strong>。</p><ul><li><p>协商缓存 <strong>由服务器来确定缓存资源是否可用</strong></p><ul><li><p>客户端：<code>If-None-Match</code>头将先前服务器端发送过来的<code>Etag</code>发送给服务器；</p><p>服务会对比这个客户端发过来的<code>Etag</code>是否与服务器的相同。</p><ul><li>若<strong>相同</strong>，返回状态<code>304</code>，客户端<strong>继续使用本地缓存</strong>。</li><li>若<strong>不相同</strong>，返回状态为<code>200</code>，客户端重新解析服务器端返回的数据。</li></ul></li></ul><ul><li>如果没有<code>Etag</code>，客户端还会通过<code>If-Modified-Since</code>头将先前服务器端发过来的<strong>最后修改时间戳</strong><code>Last-Modified</code>发送给服务器<ul><li>如果不是最新的，则返回最新的内容，<code>200</code>。</li><li>如果是最新的，则返回<code>304</code>，客户端继续使用本地缓存。</li></ul></li></ul></li></ul><h3 id="缓存发展历程"><a href="#缓存发展历程" class="headerlink" title="缓存发展历程"></a>缓存发展历程</h3><p>强缓存有缺点，比如说，设置了<code>expires</code>，<code>GMT</code>格式，但是浏览器的时间可以改变，因此就通过<code>cache-control</code>返回一个<strong>相对时间</strong>来。</p><p>但是假如说<strong>资源并没有更新</strong>，但是强缓存时间过期了，那就需要重新拉去资源，因此就有了<code>Last-Modified</code>。</p><p>但是<code>last-modified</code>的时间单位是<code>s</code>，当1s内有资源修改，那浏览器返回的最后修改时间和上次的修改时间相同，那就不会重新拉取资源，还有可能**内容并不改变(仅仅改变的修改时间)**。</p><p>因此推出了<code>Etag</code>，通过<strong>比对资源内容</strong>来判断是否修改。</p><h3 id="不同刷新的请求执行过程"><a href="#不同刷新的请求执行过程" class="headerlink" title="不同刷新的请求执行过程"></a>不同刷新的请求执行过程</h3><ul><li><p><strong>浏览器地址栏中写入URL，回车 / 普通刷新F5</strong></p><p>不同浏览器和不同类型资源缓存方式不同，个人理解：</p><ul><li>返回200，并显示从缓存中获取，则为强缓存（虽然没有发出真实的 http 请求）。</li><li>返回304，说明是协商缓存命中走<strong>缓存</strong>。</li></ul></li><li><p><strong>强制刷新Ctrl+F5</strong> 删除缓存，重新请求。</p></li></ul><h2 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/LuRQC4"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/04/13/LuRQC4.jpg" alt="LuRQC4.jpg"></a></p><p>浏览器解析渲染页面分为一下五个步骤：</p><ul><li><p>根据 HTML 解析出 DOM 树</p><ul><li><strong>图片/CSS不会影响解析</strong></li><li><code>&lt;script&gt;</code><strong>阻塞渲染并停止HTML的解析</strong></li><li><strong>预加载</strong>在后台检索资源，减少了阻塞</li></ul></li><li><p>根据 CSS 解析生成 CSS 规则树（<strong>CSSOM</strong>）</p></li><li><p>结合 DOM 树和 CSS 规则树，生成渲染树</p><ul><li><code>&lt;head&gt;</code>和它的<strong>子节点</strong>以及任何具有<code>display: none</code>样式的结点，不会出现在Render树上</li><li><code>visibility: hidden</code>的节点会出现在Render树上</li></ul></li><li><p>根据渲染树计算每一个节点的信息</p></li><li><p>根据计算好的信息绘制页面</p><ul><li>第一次确定节点的大小和位置称为布局。</li><li>随后对节点大小和位置的重新计算称为<strong>回流</strong>，不改变大小位置的样式改变为<strong>重绘</strong>。</li><li>将内容提升到GPU上的层（而不是CPU上的主线程）可以提高绘制和重新绘制性能。<ul><li>有一些特定的属性和元素可以<strong>实例化一个层</strong>，包括<code>&lt;video&gt;</code>和<code>&lt;canvas&gt;</code>，任何CSS属性为<code>opacity</code>、3D <code>transform</code>等</li><li>分层确实可以提高重绘速度，但是它以<strong>内存管理</strong>为代价。</li></ul></li><li>如果加载包含JavaScript（并且延迟到<code>onload</code>事件激发后执行），则<strong>主线程可能很忙</strong>，无法用于滚动、触摸和其他交互。</li></ul></li></ul><h2 id="浏览器的重绘与回流（Repaint、Reflow）"><a href="#浏览器的重绘与回流（Repaint、Reflow）" class="headerlink" title="浏览器的重绘与回流（Repaint、Reflow）"></a>浏览器的重绘与回流（Repaint、Reflow）</h2><h3 id="回流-重排reflow"><a href="#回流-重排reflow" class="headerlink" title="回流/重排reflow"></a>回流/重排reflow</h3><p><strong>对节点大小和位置的重新计算</strong></p><h3 id="重绘Repaint"><a href="#重绘Repaint" class="headerlink" title="重绘Repaint"></a>重绘Repaint</h3><p><strong>不改变大小位置的样式改变</strong>（color、background-color、visibility）。</p><p>元素的回流会导致所有子元素和祖先元素以及 DOM 中跟随它的任何元素的后续<strong>回流</strong>。</p><p>在很多情况下，它们相当于<strong>重新布局整个页面</strong>。</p><p>回流一定会导致重绘，重绘成本也很高，<strong>因为浏览器必须验证 DOM 树中所有其他节点的可见性</strong>。</p><p>不幸的是，很多事情都会引发回流。其中一些在编写 CSS 时特别相关：</p><ul><li><strong>调整窗口大小</strong></li><li><strong>添加或删除样式表</strong></li><li><strong>内容更改</strong>，例如用户在输入框中键入文本</li><li><strong>激活 CSS 伪类</strong>，例如 :hover（在 IE 中激活兄弟的伪类）</li><li><strong>操作 DOM 的脚本</strong></li></ul><h3 id="如何避免回流-重绘至少最小化它们对性能的影响？"><a href="#如何避免回流-重绘至少最小化它们对性能的影响？" class="headerlink" title="如何避免回流/重绘至少最小化它们对性能的影响？"></a>如何避免回流/重绘至少最小化它们对性能的影响？</h3><ul><li>将回流的范围限制在尽可能少的节点上</li><li>避免设置多个内联样式，<strong>每个样式都会导致回流</strong>，样式应该组合在一个外部类中，当操作元素的类属性时，只会导致一个重排。</li><li>应用动画到<code>fixed</code>或<code>absolute</code>的定位。它们<strong>不会影响其他元素的布局</strong>，因此它们<strong>只会导致重绘而不是完全回流</strong>。这成本要低得多。</li><li><strong>避免使用表格进行布局</strong>（或设置表格布局固定）表格通常需要多次传递才能完全建立布局，即使是很小的更改也会导致表中所有其他节点的回流。</li><li><strong>避免频繁操作DOM</strong><ul><li>React的虚拟DOM的作用是将真实 DOM 的副本存储在内存中。当您修改 DOM 时，它首先将这些更改应用到内存中的 DOM。然后，使用它的差异算法，找出真正发生了什么变化。最后，它对更改进行批处理，并调用一次将它们应用到real-dom 上。因此，<strong>最大限度地减少了回流和重绘。</strong></li></ul></li></ul><h1 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML&amp;CSS"></a>HTML&amp;CSS</h1><h2 id="语义化的理解⭐"><a href="#语义化的理解⭐" class="headerlink" title="语义化的理解⭐"></a>语义化的理解⭐</h2><p><strong>语义化</strong>，指选择合乎语义的标签，使<strong>文本内容的结构化</strong>，便于<strong>开发者阅读</strong>、<strong>维护和写出更优雅的代码，同时让浏览器的爬虫和辅助技术更好的解析。</strong></p><h3 id="常用的一些语义化标签"><a href="#常用的一些语义化标签" class="headerlink" title="常用的一些语义化标签"></a>常用的一些语义化标签</h3><ul><li><code>&lt;h1&gt;~&lt;h6&gt;</code> ，标题</li><li><code>&lt;p&gt;</code> 段落</li><li><code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>，无序、有序列表</li><li><code>&lt;table&gt;</code>、<code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;td&gt;</code>、<code>&lt;th&gt;</code>、<code>&lt;caption&gt;</code>， 表格</li></ul><h3 id="HTML5新增"><a href="#HTML5新增" class="headerlink" title="HTML5新增"></a>HTML5新增</h3><p><code>header</code>：头部,包裹目录部分、搜索框、一个nav或者任何相关的logo</p><p><code>main</code>：主体,唯一的，其后代元素常常包括<code>&lt;article&gt;</code></p><p><code>nav</code>：导航,一般和<code>ul</code>、<code>li</code>配合做导航栏</p><p><code>footer</code>：底部,通常包含作者、版权信息或者相关链接等</p><p><code>aside</code>：侧边栏,作为主要内容的附属信息，如索引，词条列表</p><p><code>article</code>：独立文章,通常带有标题，当article内嵌article时，里外层的内容应该是相关的</p><p><code>section</code>：独立区块,它是整体的一部分，或者是文章的一节，一般来说section也会带有标题</p><p><code>div</code>：作为一个没有任何语义，仅仅是用来构建结构的元素，是<strong>最适合做容器的标签。</strong></p><h3 id="被滥用的语义化标签"><a href="#被滥用的语义化标签" class="headerlink" title="被滥用的语义化标签"></a>被滥用的语义化标签</h3><ul><li><p><code>p</code>：不要用来增加额外的空白段落，应使用<code>CSS</code>的<code>margin/padding</code>来实现；</p></li><li><p><code>&lt;h1&gt;~&lt;h6&gt;</code>：该标签可以使文本字体变大，变粗，但如果文本<strong>并非是标题</strong>，应该使用<code>CSS font-weight font-size</code>；</p></li><li><p>不要将<code>&lt;b&gt;</code>元素与 <code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>或<code>&lt;mark&gt;</code>元素混淆。</p><ul><li><code>&lt;strong&gt;</code>用来对一个句子的部分增加<strong>重要性</strong>。（粗体）</li><li><code>&lt;em&gt;</code>用于改变一个句子的意思，<strong>强调</strong>某些文本。（斜体）</li><li><code>&lt;mark&gt;</code>表示上下文的<strong>关联性</strong>。（高亮）</li><li><code>&lt;b&gt;</code>用于吸引读者的注意到该元素的内容上，仅在没有其他合适的元素时使用它，如摘要中的关键字（粗体）</li></ul><p>如果不是出于语义目的而使用 <code>&lt;b&gt;</code> 元素，那么让文本显示粗体更好的方式是使用将 CSS 的 <code>font-weight</code> 属性设置为 <code>&quot;bold&quot;</code>。</p></li></ul><h2 id="H5的新特性有哪些⭐"><a href="#H5的新特性有哪些⭐" class="headerlink" title="H5的新特性有哪些⭐"></a>H5的新特性有哪些⭐</h2><ul><li><p>新增语义化标签。</p></li><li><p>H5提供了<code>sessionStorage</code>、<code>localStorage</code>和<code>indexedDB</code>加强本地存储。</p></li><li><p>input标签新增属性:</p><ul><li><p>placeholder属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>autofocus属性，页面只能有一个,自动获得焦点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">autofocus</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>canvas</code> 是 HTML5 新定义的标签，通过使用脚本（通常是 JavaScript）绘制图形。<code>&lt;canvas&gt;</code> 标签只是图形容器，相当于一个画布，<code>canvas</code> 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成，相当于使用画笔在画布上画画。</p><p>默认情况下，<code>&lt;canvas&gt;</code> 没有边框和内容。默认是一个 300*150 的画布，所以我们创建了 <code>&lt;canvas&gt;</code> 之后要对其设置宽高。</p><p>我们可以通过html属性‘width’，‘height’来设置canvas的宽高，不可以通过 css 属性来设置宽高。因为通过 css 属性设置的宽高会使 canvas 内的图像按照 300*150 时的比例放大或缩小。</p></li><li><p>地理(<code>Geolocation</code>) API</p></li><li><p>音频、视频API(<code>audio</code>,<code>video</code>)</p></li><li><p><code>webworker</code>, <code>websocket</code></p><ul><li><p><code>webworker</code>是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过<code>postMessage</code>传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。</p><p>双方都使用<code>postMessage()</code>方法发送各自的消息，使用<code>onmessage</code>事件处理函数来响应消息（消息被包含在<code>Message</code>事件的data属性中）。这个过程中数据并不是被共享而是被复制。</p><p><strong>但不能访问 DOM</strong>— 不能让一个worker直接更新UI</p></li><li><p><code>WebSocket</code>是HTML5的一个持久化的协议，它实现了<strong>浏览器与服务器的全双工通信</strong>，同时也是跨域的一种解决方案。</p><p><code>WebSocket</code>和<code>HTTP</code>都是<strong>应用层协议</strong>，都基于 <code>TCP</code> 协议。</p><p>但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。</p><p>同时，<code>WebSocket</code> 在建立连接时需要借助 <code>HTTP</code> 协议，连接建立好了之后 <code>client</code> 与 <code>server</code> 之间的双向通信就与 <code>HTTP</code> 无关了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建WebSocket连接</span></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:8080&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接打开，发送数据</span></span><br><span class="line">socket.addEventListener(<span class="string">&#x27;open&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    socket.send(<span class="string">&#x27;Hello Server!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听数据</span></span><br><span class="line">socket.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Message from server &#x27;</span>, event.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="CSS中，有哪些方式可以隐藏页面元素？有什么区别-⭐"><a href="#CSS中，有哪些方式可以隐藏页面元素？有什么区别-⭐" class="headerlink" title="CSS中，有哪些方式可以隐藏页面元素？有什么区别?⭐"></a>CSS中，有哪些方式可以隐藏页面元素？有什么区别?⭐</h2><p>通过<code>css</code>实现隐藏元素方法有如下：</p><ul><li><code>display:none</code> 元素不可见，不占据空间（<strong>不会出现在Render树上</strong>），无法响应点击事件</li><li><code>visibility:hidden</code> 元素不可见，占据页面空间，无法响应点击事件</li><li><code>opacity:0</code> 改变元素透明度，元素不可见，占据页面空间，可以响应点击事件</li><li>设置<code>height、width</code>模型属性为<strong>0</strong> 如果元素内有子元素或内容，还应该设置其<code>overflow:hidden</code>来隐藏其子元素</li><li><code>position:absolute</code> 将元素移出可视区域</li><li><code>clip-path</code> 通过裁剪的形式</li></ul><p>最常用的还是<code>display:none</code>和<code>visibility:hidden</code>，其他的方式只能认为是奇招，它们的真正用途并不是用于隐藏元素，所以并不推荐使用它们。</p><h2 id="对CSS盒模型的认识⭐"><a href="#对CSS盒模型的认识⭐" class="headerlink" title="对CSS盒模型的认识⭐"></a>对CSS盒模型的认识⭐</h2><h3 id="块级盒子（Block-box）-和-内联盒子（Inline-box）"><a href="#块级盒子（Block-box）-和-内联盒子（Inline-box）" class="headerlink" title="块级盒子（Block box） 和 内联盒子（Inline box）"></a>块级盒子（Block box） 和 内联盒子（Inline box）</h3><p>在 CSS 中我们广泛地使用两种“盒子” —— <strong>块级盒子</strong> (<strong>block box</strong>) 和 <strong>内联盒子</strong> (<strong>inline box</strong>)。这两种盒子会在<strong>页面流</strong>（page flow）和<strong>元素之间的关系</strong>方面表现出不同的行为:</p><p>一个被定义成块级的（block）盒子会表现出以下行为:</p><ul><li>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，<strong>在绝大数情况下意味着盒子会和父容器一样宽</strong></li><li>每个盒子都会<strong>换行</strong></li><li><code>width</code>和 <code>height</code> 属性可以发挥作用</li><li>内边距（<code>padding</code>）, 外边距（<code>margin</code>） 和 边框（<code>border</code>） 会将其他元素从当前盒子周围“推开”</li></ul><p>除非特殊指定，诸如标题(<code>&lt;h1&gt;</code>等)、段落(<code>&lt;p&gt;</code>)和<code>div</code>默认情况下都是块级的盒子。</p><p>如果一个盒子对外显示为 <code>inline</code>，那么他的行为如下:</p><ul><li><p>盒子<strong>不会产生换行</strong>。</p></li><li><p><code>width</code>和 <code>height</code> 属性将不起作用。</p></li><li><p><strong>垂直方向的内边距、外边距以及边框</strong>会被应用但是<strong>不会</strong>把其他处于 <code>inline</code> 状态的盒子推开。</p><ul><li>无内容，垂直<code>padding</code>和<code>border</code>单独设置不会生效。</li><li>无内容，水平垂直<code>padding</code>和<code>border</code>同时设置，垂直<code>padding</code>和<code>border</code>会覆盖其他元素。</li><li>有内容，垂直<code>padding</code>和<code>border</code>会覆盖其他元素。</li><li>有无内容，垂直<code>margin</code>不生效</li></ul></li><li><p><strong>水平方向的内边距、外边距以及边框</strong>会被应用且<strong>会</strong>把其他处于 <code>inline</code> 状态的盒子推开。</p></li></ul><p>用做链接的 <code>&lt;a&gt;</code> 元素、 <code>&lt;span&gt;</code>、 <code>&lt;em&gt;</code> 以及 <code>&lt;strong&gt;</code> 都是默认处于 <code>inline</code> 状态的。</p><p>我们通过对盒子<code>display</code> 属性的设置，比如 <code>inline</code> 或者 <code>block</code> ，来控制盒子的外部显示类型。</p><h3 id="inline，block，inline-block的区别⭐"><a href="#inline，block，inline-block的区别⭐" class="headerlink" title="inline，block，inline-block的区别⭐"></a>inline，block，inline-block的区别⭐</h3><blockquote><p>HTML 标准中块级元素和行内元素的区别至高出现在 4.01 标准中。在 HTML5，这种区别被一个更复杂的内容类别代替。</p><p>”块级“类别大致相当于 HTML5 中的<code>Flow content(流内容)</code>类别，而”行内“类别相当于 HTML5 中的<code>Phrasing content(短语内容)</code>类别，不过除了这两个还有其他类别。</p></blockquote><p>同块级盒子（块级元素）和内联盒子（行内元素）。</p><p>行内元素：</p><ul><li>一般情况下<strong>只能包含数据和其他行内元素</strong>。</li><li>一般是<strong>内容的容器</strong>。</li></ul><p>块级元素：</p><ul><li><strong>包含行内元素和其他块级元素</strong>。</li><li>适合做<strong>布局</strong>。</li></ul><h4 id="行内块元素-inline-block"><a href="#行内块元素-inline-block" class="headerlink" title="行内块元素(inline-block)"></a>行内块元素(inline-block)</h4><ul><li><strong>既可以设置宽高，又可以和其他行内元素并排</strong>。</li><li><code>inline-block</code>的`margin、paddin会生效，而且<strong>不会发生外边距重叠</strong>。</li><li><code>inline</code>和<code>inline-block</code>会引起<strong>间距</strong>。这个间距是有<strong>空格</strong>或<strong>换行</strong>导致的。解决方法一：<strong>将空格直接删除，放到一行</strong></li></ul><h4 id="行内元素与块状元素之间的转换"><a href="#行内元素与块状元素之间的转换" class="headerlink" title="行内元素与块状元素之间的转换"></a>行内元素与块状元素之间的转换</h4><ul><li><strong>float:</strong> 行内=&gt;块。</li><li><strong>position:</strong> <code>position:absolute/fixed</code>，行内=&gt;块。</li><li><strong>display:</strong><ul><li><code>display:inline;</code></li><li><code>display:block;</code></li><li><code>display:inline-block;</code></li></ul></li></ul><h3 id="什么是CSS-盒模型"><a href="#什么是CSS-盒模型" class="headerlink" title="什么是CSS 盒模型?"></a>什么是CSS 盒模型?</h3><p>完整的 CSS 盒模型应用于<strong>块级盒子</strong>，<strong>内联盒子只使用盒模型中定义的部分内容</strong>。</p><p>模型定义了盒的每个部分 —— <code>margin外边距</code>, <code>border边框</code>, <code>padding内边距</code>和 <code>content内容区</code> —— 合在一起就可以创建我们在页面上看到的内容。</p><h3 id="标准盒模型和IE盒子模型"><a href="#标准盒模型和IE盒子模型" class="headerlink" title="标准盒模型和IE盒子模型"></a>标准盒模型和IE盒子模型</h3><p>CSS标准盒模型和IE盒模型的区别：</p><ul><li><p>在 <strong>标准盒子模型</strong>中，<strong>width 和 height 指的是内容区域</strong>的宽度和高度。</p></li><li><p><strong>IE盒子模型</strong>中，<strong>width 和 height 指的是内容区域+padding+border</strong>的宽度和高度。</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置当前盒子为 标准盒模型（默认） */</span></span><br><span class="line"><span class="attribute">box-sizing</span>: content-box;</span><br><span class="line"><span class="comment">/* 设置当前盒子为 IE盒模型 */</span></span><br><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br></pre></td></tr></table></figure><h2 id="BFC⭐"><a href="#BFC⭐" class="headerlink" title="BFC⭐"></a>BFC⭐</h2><h3 id="BFC的概念"><a href="#BFC的概念" class="headerlink" title="BFC的概念"></a>BFC的概念</h3><p><strong>块级格式化上下文（Block Formatting Context，BFC）</strong> 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p><p><code>BFC</code>是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。</p><h3 id="如何生成BFC"><a href="#如何生成BFC" class="headerlink" title="如何生成BFC"></a>如何生成BFC</h3><ul><li><p><code>overflow: 不为visible，可以让属性是 hidden、auto</code>。【最常用】</p></li><li><p>浮动中：<code>float</code>的属性值不为none。意思是，<code>只要设置了浮动，当前元素就创建了BFC</code>。</p></li><li><p>绝对定位：<code>posiiton</code>是<code>absolute</code>或<code>fixed</code>。</p></li><li><p><code>display</code>为<code>inline-block</code>, <code>table-cell</code>, <code>table-caption</code>, <code>flex</code>, <code>inline-flex</code>、<code>grid</code>等</p></li></ul><h3 id="BFC-的应用"><a href="#BFC-的应用" class="headerlink" title="BFC 的应用"></a>BFC 的应用</h3><h4 id="解决margin重叠"><a href="#解决margin重叠" class="headerlink" title="解决margin重叠"></a>解决margin重叠</h4><p><strong>标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin</strong>(水平方向的margin是可以叠加的）。</p><p>且只会发生在块级元素，<strong>行内元素和行内块元素不会出现</strong>。</p><p><strong>儿子和父亲在竖直方向上为一个margin</strong>。</p><p>当父元素和子元素（兄弟元素）发生 margin 重叠时，解决办法：<strong>给子元素或父元素（兄弟元素）创建BFC</strong>。</p><h4 id="清除浮动影响（高度塌陷）"><a href="#清除浮动影响（高度塌陷）" class="headerlink" title="清除浮动影响（高度塌陷）"></a>清除浮动影响（高度塌陷）</h4><p><strong>父元素不设置高度默认是被子元素撑开的</strong>，当<strong>子元素浮动</strong>后，其会完全<strong>脱离文档流</strong>。</p><p>子元素从文档流中脱离，将会无法撑起父元素的高度，<strong>导致父元素的高度丢失</strong>。</p><p>父元素高度丢失以后，其下的元素会自动上移，导致<strong>页面的布局混乱</strong>。</p><p><strong>解决方案</strong></p><ul><li><p>给父亲增加 <code>overflow=hidden</code>属性即可，因为计算BFC的高度时，浮动元素也参与计算。</p></li><li><p>给父亲设置高度。正所谓<strong>有高度的盒子，才能关住浮动</strong>。</p></li><li><p><strong>伪元素+clear</strong></p><ul><li><p><code>clear</code> 属性指定一个元素是否必须移动(清除浮动后)到<strong>在它之前的浮动元素下面</strong>。</p></li><li><p><strong>要被清除的相关浮动元素</strong>指的是在相同<strong>块级格式化上下文</strong>中的<strong>前置浮动</strong>。</p></li><li><p>具体方法：</p><ul><li><p>给<strong>浮动元素的容器</strong>添加一个<code>clearfix</code>的class。</p></li><li><p>然后给这个class添加一个<code>::after</code>(用来创建一个伪元素，作为已选中元素的最后一个子元素)，</p></li><li><p>内容为空即没有高度看不到，但<code>display: block;</code>宽度仍然占满父元素，方便判断之前的左右浮动以清理。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block; <span class="comment">/* 确保该元素是一个块级元素 */</span></span><br><span class="line">    <span class="attribute">clear</span>: both;<span class="comment">/*清除浮动*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="Flex⭐"><a href="#Flex⭐" class="headerlink" title="Flex⭐"></a>Flex⭐</h2><p>Flex是Flexible Box的缩写，翻译成中文就是“<strong>弹性盒子</strong>”，用来为盒模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。</p><p>采用Flex布局的元素，被称为**Flex容器(flex container)**，简称“容器”。</p><p>其所有子元素自动成为容器成员，成为**Flex项目(Flex item)**，简称“项目”。</p><p>容器默认存在两根轴：<strong>水平方向</strong>主轴(main axis)和垂直方向交叉轴(cross axis)，<strong>默认项目按主轴排列</strong>。</p><h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><h4 id="1-flex-flow"><a href="#1-flex-flow" class="headerlink" title="1. flex-flow"></a>1. flex-flow</h4><p><strong>flex-direction（主轴的方向）和flex-wrap（换行）的简写，默认row（水平） nowrap（不换行）</strong></p><h4 id="2-justify-content"><a href="#2-justify-content" class="headerlink" title="2. justify-content"></a>2. justify-content</h4><p><strong>定义项目在主轴上的对齐方式。</strong></p><p><code>justify-content:center</code> 默认用作水平居中</p><h4 id="3-align-items"><a href="#3-align-items" class="headerlink" title="3. align-items"></a>3. align-items</h4><p><strong>定义在交叉轴上的对齐方式</strong></p><p><code>align-items:center</code> 默认用作垂直居中</p><h4 id="4-align-content"><a href="#4-align-content" class="headerlink" title="4. align-content"></a>4. align-content</h4><p><strong>定义多根轴线的对齐方式</strong> 必须通过<code>flex-wrap</code>先有多根轴线</p><h3 id="元素属性"><a href="#元素属性" class="headerlink" title="元素属性"></a>元素属性</h3><h4 id="1-align-self"><a href="#1-align-self" class="headerlink" title="1. align-self"></a>1. align-self</h4><p>定义单个项目的对齐方式，常用于<strong>居中布局</strong>。</p><h4 id="2-flex"><a href="#2-flex" class="headerlink" title="2. flex"></a>2. flex</h4><p><strong>==flex-grow，flex-shrink和flex-basis的简写==</strong></p><blockquote><p>默认值为0 1 auto，<strong>第一个属性必须</strong>，后两个属性可选。</p></blockquote><ul><li><p>flex-grow定义项目的放大比例</p><ul><li><strong>容器宽度&gt;元素总宽度</strong>时如何伸展，按比例分配<strong>剩余空间</strong>增加给各元素</li></ul></li><li><p>flex-shrink定义了项目的缩小比例</p><ul><li><strong>容器宽度&lt;元素总宽度</strong>时如何收缩</li><li>默认为1，即如果空间不足，该项目将缩小。</li><li>赋予<strong>更大的数值</strong>可以比赋予小数值的同级元素<strong>收缩程度更大</strong></li><li>在分配<strong>负空间</strong>时，<strong>收缩系数乘以元素尺寸</strong>。这将<strong>按项目能够收缩的大小比例分配负空间</strong>，因此，例如，一个小项目不会在一个较大的项目显著减少之前收缩为零。</li></ul></li><li><p>flex-basis定义了该元素的<strong>空间大小（</strong>the size of that item in terms of the space<strong>）</strong>。</p><ul><li>flex容器里除了元素所占的空间以外的富余空间就是<strong>可用空间</strong> 。</li><li>该属性的默认值是 <code>auto</code> 。此时，浏览器会检测这个元素是否具有确定的尺寸。</li><li>如果没有给元素设定尺寸，<code>flex-basis</code> 的值采用元素<strong>内容的尺寸</strong>。</li><li>所以我们给只要给Flex元素的父元素声明 <code>display: flex</code> ，所有子元素就会排成一行，且自动分配小大以充分展示元素的内容。</li></ul></li></ul><p>常见一些属性有：</p><ul><li><code>flex: 1</code> = <code>flex: 1 1 0</code>，常用作<strong>自适应布局</strong>。</li><li><code>flex: 2</code> = <code>flex: 2 1 0</code></li><li><code>flex: auto</code> = <code>flex: 1 1 auto</code></li><li><code>flex: none</code> = <code>flex: 0 0 auto</code>，常用于<strong>固定尺寸不伸缩</strong></li></ul><p><code>flex:1</code> 和 <code>flex:auto</code> 的区别，可以归结于<code>flex-basis:0</code>和<code>flex-basis:auto</code>的区别。</p><ul><li><p>当设置为<code>0</code>时（绝对弹性元素），元素可以在<code>flex-basis</code>为0的基础上伸缩。。</p></li><li><p>当设置为<code>auto</code>时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑。</p></li></ul><h4 id="3-order"><a href="#3-order" class="headerlink" title="3. order"></a>3. order</h4><p><strong>定义项目的排列顺序。</strong></p><p>数值越小，排列越靠前，默认为0，可以是负值。</p><h2 id="居中布局⭐"><a href="#居中布局⭐" class="headerlink" title="居中布局⭐"></a>居中布局⭐</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ul><li><p><code>text-align: center</code></p><ul><li>设置<strong>块元素或表格单元格</strong>中<strong>内容</strong>的水平对齐方式。</li><li><strong>不能直接用于行内元素</strong> 。</li><li>另外，这个内容不一定是行内元素，块元素中有h1(块元素)一样可以实现效果。</li></ul></li><li><p><code>margin: 0 auto</code></p><ul><li>计算元素对应方向上应该获得的<strong>剩余空间</strong>大小。</li><li>因为块级元素设置宽度后仍占据一行空间，<code>margin: 0 auto</code>会将这一行的剩余空间平均分配给左右外边距。</li><li><code>margin:auto</code> 能使<strong>块级元素</strong>水平居中，但是不能垂直居中，因为<strong>垂直方向上默认没有剩余的空间</strong>。</li><li><code>margin:auto</code> <strong>行内元素</strong>既不能水平居中也不能垂直居中，因为行内元素<strong>水平垂直方向上默认都没有剩余的空间</strong>。</li></ul></li></ul><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ul><li><code>line-height: 父元素高度</code> 适合文本。</li></ul><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><ul><li><code>flex + justify-content + align-items</code><ul><li>但对<strong>子元素图片、文字</strong>都有时，<strong>竖直方向</strong>的对齐会有差异</li><li><strong>父元素开启Flex布局</strong>。</li><li>图片子元素设置<code>align-self: center;</code></li><li>文字子元素使用<code>line-height: 父元素高度</code>。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">align-self</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>absolute + transform</code><ul><li>``top,left<code>跟根据**父元素的宽和高**偏移的。</code>top: 50%;left: 50%;` 元素左上角居中。</li><li><code>transform: translate(-50%, -50%);</code>是根据<strong>自身的宽高</strong>偏移的。</li><li>这个计算的元素自身不包含margin，用此方法要注意设置<code>margin: 0;</code></li><li>也可以<code>margin</code>和<code>absolute</code>结合实现居中布局<ul><li><code>absolute(top:50%;left:50%;) + 负margin</code></li><li><code>absolute(top:0;left:0;right:0;bottom:0;)+margin:auto</code></li></ul></li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wp</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;  </span><br><span class="line">&#125;     </span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li><strong>网格布局（Grid）</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    justify-items: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.small</span> &#123;</span><br><span class="line">    justify-self: center;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三栏布局⭐"><a href="#三栏布局⭐" class="headerlink" title="三栏布局⭐"></a>三栏布局⭐</h2><blockquote><p>问题：假设容器的高度默认100px，请写出<strong>三栏布局</strong>，其中左栏、右栏的宽度各为300px，中间的宽度自适应。</p></blockquote><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>左侧设置<strong>左浮动</strong>，右侧设置<strong>右浮动</strong>，中间设置<code>margin</code>或<code>overflow:hidden</code>。</p><ul><li>需要将中间的内容放在<code>html</code>结构最后，主体内容是最后加载的。</li><li>脱离文档流，需要解决浮动带来影响。</li></ul><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>左侧设置为绝对定位， <code>left：0px</code>。右侧设置为绝对定位， <code>right：0px</code>。</p><p>中间设置为绝对定位，<code>left 和right 都为300px</code>，即可。中间的宽度会自适应。</p><p>脱离文档流。</p><h3 id="Flexbox布局"><a href="#Flexbox布局" class="headerlink" title="Flexbox布局"></a>Flexbox布局</h3><p>将父容器设置<code>display：flex</code>，侧边栏大小固定后，将内容区<code>flex：1</code>，内容区则会自动放大占满剩余空间。</p><p>比较完美的解决了浮动和绝对定位的问题。在移动端比较常用。</p><h3 id="表格布局table"><a href="#表格布局table" class="headerlink" title="表格布局table"></a>表格布局table</h3><p>设置整个容器的宽度为<code>100%</code>，<code>display: table;</code>，设置三个部分均为表格单元<code>display: table-cell;</code>，然后左边的单元格为 <code>300px</code>，右边的单元格为 <code>300px</code>，即可。中间的单元格会自适应。</p><p>兼容性非常好；三个部分都当成了<strong>单元格</strong>来对待，此时，如果中间的部分变高了，其会部分也会被迫调整高度。</p><h3 id="网格布局-grid"><a href="#网格布局-grid" class="headerlink" title="网格布局 grid"></a>网格布局 grid</h3><p>设置容器为网格布局<code>display: grid</code>，宽度为<code>100%</code>，并设置<code>grid-template-columns: 300px auto 300px</code>。</p><p>CSS3中引入的布局，功能强大。</p><h2 id="CSS选择器优先级⭐"><a href="#CSS选择器优先级⭐" class="headerlink" title="CSS选择器优先级⭐"></a>CSS选择器优先级⭐</h2><p>CSS 中的权重，指的是<strong>选择器的优先级</strong>。</p><p>对同一HTML元素设置样式时，不同选择器的优先级不同，<strong>优先级低的样式将被高优先级的样式层叠掉</strong>。</p><p>CSS 权重优先级顺序简单表示为：</p><p><code>!important &gt; 内联样式(style=&quot;&quot;) &gt; ID (#id属性值) &gt; 类(.class属性值)、伪类(:nth-child())、属性([属性名]) &gt; 标签名(p&#123;&#125;)、伪元素(::after) &gt; 通配符(*)</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.red</span> <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: red;&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.green</span> <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: green;&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;green&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>p: 颜色<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>.red p</code>和<code>.green p</code>的选择器权重相同，那么谁在后面，最后就应用谁。所以最后是绿色。</p><p>如果<code>red</code>换成id选择器或者添加<code>!important</code>，就会变成红色。</p><p>对于同一个元素设置z-index不会对选择器权重产生影响，另外<code>z-index</code> 属性设定了一个<strong>定位元素及其后代元素</strong>或 <strong>flex 项目</strong>的 z-order。 当元素之间重叠的时候， z-index 较大的元素会覆盖较小的元素在上层进行显示。</p><p><strong>继承样式</strong></p><ul><li><strong>继承得到的样式的优先级是最低的</strong>，在任何时候，只要元素本身有同属性的样式定义，就可以覆盖掉继承值。</li><li>在存在多个继承样式时，层级关系距离当前元素最近的父级元素的继承样式，具有相对最高的优先级。</li></ul><h2 id="less⭐"><a href="#less⭐" class="headerlink" title="less⭐"></a>less⭐</h2><p>less是一门css的预处理语言</p><ul><li>less是一个css的增强版，通过less可以<strong>编写更少的代码实现更强大的样式</strong>，添加了许多的新特性：像对<strong>变量</strong>的支持、对<strong>mixin</strong>的支持… …</li><li>less的语法大体上和css语法一致，但是less中增添了许多对css的扩展，所以浏览器无法直接执行less代码，要执行必须向将<strong>less转换为css</strong>，然后再由浏览器执行。</li></ul><p>特点</p><ul><li><strong>结构写的更加清晰</strong> 使用嵌套（nesting）代替层叠或与层叠结合使用</li><li>变量 <code>@变量名</code></li><li><code>&amp;</code> 表示外层的父元素 <code>&amp;::after</code> <code>&amp;:hover</code></li><li><code>:extend()</code> 对当前选择器扩展指定选择器的样式（选择器分组）</li></ul><h2 id="script标签的defer和async属性有什么区别⭐"><a href="#script标签的defer和async属性有什么区别⭐" class="headerlink" title="script标签的defer和async属性有什么区别⭐"></a>script标签的defer和async属性有什么区别⭐</h2><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>async标记告诉浏览器在等待js下载期间可以去干其他事，当js下载完成后会<strong>立即(尽快)执行</strong>，<strong>多条js可以并行下载</strong>。</p><p>async的好处是让多条js不会互相等待，<strong>下载期间浏览器会去干其他事(继续解析HTML等)<strong>，</strong>异步下载，异步执行</strong>。</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>与async一样，defer标记告诉浏览器在等待js下载期间可以去干其他事，<strong>多条js可以并行下载</strong>，不过当js下载完成之后<strong>不会立即执行</strong>，而是会等待解析完整个HTML之后在开始执行，而且多条defer标记的js会<strong>按照顺序执行</strong>。</p><h3 id="到底该用哪个标记"><a href="#到底该用哪个标记" class="headerlink" title="到底该用哪个标记"></a>到底该用哪个标记</h3><p>如果两个script之间<strong>没有依赖关系</strong>并且<strong>无需等待页面解析</strong>的更加适合使用<code>async</code>，反之如果两个script之间<strong>有依赖关系</strong>，或者希望<strong>优先解析HTML</strong>，则<code>defer</code>更加适合。</p><p>defer脚本会在文档渲染完毕后，<code>DOMContentLoaded</code>事件调用前执行。</p><h2 id="自适应布局⭐"><a href="#自适应布局⭐" class="headerlink" title="自适应布局⭐"></a>自适应布局⭐</h2><p>网页在各终端上的展示效果就像缩放设计稿图片一样，在不同屏幕上等比缩放，每一个元素与整体比例保持不变，真实还原设计稿。</p><h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><p>视口(viewport)代表当前可见的计算机图形区域。</p><p>在Web浏览器术语中，通常与<strong>浏览器窗口相同</strong>，但不包括浏览器的UI， 菜单栏等——即指你正在浏览的文档的那一部分。</p><p>而移动端则较为复杂，它涉及到三个视口：<strong>布局视口（Layout Viewport）</strong>、<strong>视觉视口（Visual Viewport）</strong>和<strong>理想视口（Ideal Viewport）</strong>。</p><ul><li>布局视口使视口与移动端浏览器屏幕宽度完全独立开。<strong>CSS 布局将会根据它来进行计算，并被它约束</strong>。</li><li>视觉视口是用户当前看到的区域，<strong>用户可以通过缩放操作视觉视口，同时不会影响布局视口</strong>。</li><li><strong>理想视口对设备而言是最理想的布局视口尺寸</strong>。显示在理想视口中的网站具有最理想的宽度，用户无需进行缩放。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="解决适配方法"><a href="#解决适配方法" class="headerlink" title="解决适配方法"></a>解决适配方法</h3><h4 id="rem适配"><a href="#rem适配" class="headerlink" title="rem适配"></a>rem适配</h4><ul><li><p><code>em</code>：在 <code>font-size</code> 中使用是相对于<strong>父元素的字体大小</strong>，在<strong>其他属性</strong>中使用是相对于<strong>自身的字体大小</strong>，如 width。</p></li><li><p>使用<code>rem</code>为元素设定字体大小时，仍然是相对大小，但<strong>相对的只是HTML根元素</strong>。</p></li><li><p>通过它既可以做到<strong>只修改根元素就成比例地调整所有字体大小</strong>，又可以避免字体大小逐层复合的连锁反应。</p></li></ul><h4 id="vw，vh布局"><a href="#vw，vh布局" class="headerlink" title="vw，vh布局"></a>vw，vh布局</h4><p>vh、vw方案即将视觉视口宽度和视觉视口高度等分为100份。</p><p>像<code>vw</code>、<code>vh</code>，比较容易混淆的一个单位是<code>%</code>，不过百分比宽泛的讲是相对于<strong>父元素</strong>。</p><p>视口单位主要包括以下4个：</p><ul><li><strong>vw</strong>：1vw等于视口宽度的1%。</li><li><strong>vh</strong>：1vh等于视口高度的1%。</li><li><strong>vmin</strong>：选取vw和vh中最小的那个。</li><li><strong>vmax</strong>：选取vw和vh中最大的那个。</li></ul><p><strong>缺点</strong>：</p><ul><li>用户失去了放缩任何使用<code>vw</code>单位的元素的能力。</li><li>vh和vw方案和rem类似也是相当麻烦需要做单位转化，而且px转换成vw不一定能完全整除，因此有一定的像素差。</li><li>不过在工程化的今天，webpack解析css 的时候用postcss-loader 有个postcss-px-to-viewport能自动实现px到vw的转化</li></ul><h4 id="媒体查询-响应式布局"><a href="#媒体查询-响应式布局" class="headerlink" title="媒体查询 响应式布局"></a>媒体查询 响应式布局</h4><p><code>@media 查询规则&#123;&#125;</code>通过媒体查询，可以为不同的设备，或设备不同状态来分别设置样式</p><h4 id="px为主，vx和vxxx（vw-vh-vmax-vmin）为辅，搭配一些flex（推荐）"><a href="#px为主，vx和vxxx（vw-vh-vmax-vmin）为辅，搭配一些flex（推荐）" class="headerlink" title="px为主，vx和vxxx（vw/vh/vmax/vmin）为辅，搭配一些flex（推荐）"></a>px为主，vx和vxxx（vw/vh/vmax/vmin）为辅，搭配一些flex（推荐）</h4><h3 id="1px边框问题"><a href="#1px边框问题" class="headerlink" title="1px边框问题"></a>1px边框问题</h3><p><strong>dpr(物理像素和设备独立像素（逻辑像素）的比值）可以用来解释不同分辨率手机呈现页面的精细度的差异</strong>，但并不能解释1px问题。</p><p><strong>多（2，3）倍的设计图设计了1px的边框，在手机上缩小呈现时，由于css最低只支持显示1px大小，导致边框太粗的效果。（ps：ios较新版已支持0.5px，安卓不支持，这里暂且忽略）。</strong></p><h4 id="通过设置meta标签viewport"><a href="#通过设置meta标签viewport" class="headerlink" title="通过设置meta标签viewport"></a>通过设置meta标签viewport</h4><p>如果设置<strong>content的width就等于设计图大小750px</strong>，然后通过<strong>动态设置initial-scale值让网页整体缩放</strong>，就能实现效果了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=750,initial-scale=0.5,user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="通过transform-scale-缩放（推荐）"><a href="#通过transform-scale-缩放（推荐）" class="headerlink" title="通过transform: scale()缩放（推荐）"></a>通过transform: scale()缩放（推荐）</h4><p>具体的scale缩放比例取决于你是<strong>几倍设计图尺寸下的1px</strong>。</p><h2 id="边框⭐"><a href="#边框⭐" class="headerlink" title="边框⭐"></a>边框⭐</h2><h3 id="利用border画三角形"><a href="#利用border画三角形" class="headerlink" title="利用border画三角形"></a>利用border画三角形</h3><p><code>border</code>可以用于设置一个或多个以下属性的值: <code>border-width</code>, <code>border-style</code>, <code>border-color</code></p><p>本质还是利用了盒模型，<strong>每个边框都是梯形</strong>，当<strong>内容区宽高为0</strong>时就成三角形。</p><p>最简单：内容区宽高为0，border设置大小但颜色透明，单独给一个边框颜色。四个边框分别设置会得到更多不同形状的三角形。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">125px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left-color</span>: aqua;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日常用的更多可能是利用<strong>伪元素</strong>，<code>content: &#39;&#39;;</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div5</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-top-color</span>:  white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h3><p><code>border-radius</code>允许你设置元素的外边框圆角当使用<strong>一个半径时确定一个圆形</strong>,当使用<strong>两个半径时确定一个椭圆</strong></p><p>这个(椭)圆与边框的交集形成圆角效果。</p><p>该属性是一个简写属性,是为了将这四个属性 <code>border-top-left-radius</code> 、<code>border-top-right-radius</code> 、<code>border-bottom-right-radius</code>和 <code>border-bottom-left-radius</code> 简写为一个属性。</p><p>即使元素<strong>没有边框</strong>,圆角也可以用到 <code>background</code> 上面。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 右上和左下设置圆角*/</span></span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">12vmin</span> <span class="number">0</span> <span class="number">12vmin</span>;</span><br><span class="line"><span class="comment">/* 圆形*/</span></span><br><span class="line"><span class="attribute">width</span>: <span class="number">60vmin</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">60vmin</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br></pre></td></tr></table></figure><h3 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h3><p>用于在元素的框架上添加阴影效果。</p><p>该属性可设置的值包括<code>阴影的X轴偏移量</code>、<code>Y轴偏移量</code>、<code>模糊半径</code>、<code>扩散半径</code>和<code>颜色</code>。</p><p>如果元素同时设置了 <code>border-radius</code>属性 ，那么<strong>阴影也会有圆角效果</strong>。</p><p>使用 <code>inset</code> 关键字会使得阴影落在盒子内部，此时阴影会在<strong>边框之内 (即使是透明边框）、背景之上、内容之下</strong>。</p><p>ios中<code>box-shadow</code>容易出现bug，一种方式是设置<code>border: none;</code>，使用<code>box-shadow</code>和<code>border-radius</code>可以获得类似<strong>边框</strong>的效果。</p><h2 id="position⭐"><a href="#position⭐" class="headerlink" title="position⭐"></a>position⭐</h2><p><code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>这四个属性要生效的话,必须得设置<code>相对定位/绝对定位</code>。</p><p>即<code>position：relative;</code>或者<code>position：absolute;</code>，也就是说<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>是为<code>相对定位/绝对定位</code>而生的。</p><p>子绝父相就是：子元素为绝对定位(<code>position：absolute;</code>)，父元素为相对定位<code>position：relative;</code>。</p><p><strong>absolute</strong>元素会<strong>被移出正常文档流</strong>，并<strong>不为元素预留空间</strong>，通过指定元素相对于<strong>最近的非 static 定位祖先元素的偏移</strong>，来确定元素位置。</p><p><strong>fixed</strong>元素会<strong>被移出正常文档流</strong>，并不为元素预留空间，而是通过指定元素相对于<strong>屏幕视口（viewport）</strong>的位置来指定元素位置。</p><h2 id="层叠上下文⭐"><a href="#层叠上下文⭐" class="headerlink" title="层叠上下文⭐"></a>层叠上下文⭐</h2><p>元素提升为一个比较特殊的图层，在三维空间中 <strong>(z轴)</strong> 高出普通元素一等。</p><ul><li>触发条件<ul><li>根层叠上下文(<code>html</code>)</li><li><code>position</code></li><li>css3属性</li></ul></li><li>层叠等级：层叠上下文在z轴上的排序<ul><li><strong>在同一层叠上下文中，层叠等级才有意义</strong> 先处理子元素，作为整体传递，父元素再与其兄弟元素层叠。</li><li><code>z-index</code>的优先级最高&gt;<strong>行内</strong>&gt;<strong>浮动</strong>&gt;<strong>块</strong>&gt;<code>z-index</code>为负&gt;<strong>背景/边框</strong></li></ul></li></ul><h2 id="CSS动画⭐"><a href="#CSS动画⭐" class="headerlink" title="CSS动画⭐"></a>CSS动画⭐</h2><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>**<code>transform</code>**属性允许你旋转<code>rotate()</code>，缩放<code>scale()</code>，倾斜或平移<code>translate()</code>给定元素。</p><p><strong><code>transform-origin</code></strong> 属性让你更改一个元素变形的原点。（默认的转换原点是 <code>center</code>)</p><blockquote><p>transform对定位元素的影响</p></blockquote><p>当给一个元素加上<code>transform</code>属性的时候，这个元素就会具有<code>relative</code>的特性。</p><p>所以<strong>若一个元素的父元素拥有tranform属性，那么子元素在使用定位属性的时候要注意。</strong></p><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">animation</span>: <span class="number">3s</span> ease-in <span class="number">1s</span> <span class="number">2</span> reverse both paused slidein;</span><br></pre></td></tr></table></figure><h4 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h4><p>后边指定动画名称<code>animation-name</code></p><p>关键帧 <strong><code>@keyframes</code></strong> 通过在动画序列中定义关键帧的样式来<strong>控制CSS动画序列中的中间步骤</strong>。</p><p><code>0%</code>/<code>from</code> 和<code>100%</code>/<code>to</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> slidein &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0%</span>); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="animation-duration"><a href="#animation-duration" class="headerlink" title="animation-duration"></a>animation-duration</h4><p>指定一个<strong>动画周期的时长</strong>。</p><h4 id="animation-timing-function"><a href="#animation-timing-function" class="headerlink" title="animation-timing-function"></a>animation-timing-function</h4><p><code>ease/ease-in/ease-out/ease-in-out/linear</code></p><p>定义CSS动画在每一动画周期中<strong>执行的节奏</strong> 可能值为一或多个 <code>&lt;timing-function&gt;</code> 。</p><p>对于关键帧动画来说,<code>timing function</code>作用于<strong>一个关键帧周期</strong>。</p><h4 id="animation-delay"><a href="#animation-delay" class="headerlink" title="animation-delay"></a>animation-delay</h4><p>定义动画于何时开始，即<strong>从动画应用在元素上到动画开始的这段时间的长度</strong>。</p><h4 id="animation-iteration-count"><a href="#animation-iteration-count" class="headerlink" title="animation-iteration-count"></a>animation-iteration-count</h4><p>定义动画在结束前运行的<strong>次数</strong> 。可以是n次/无限循环<code>infinite</code>.</p><h4 id="animation-direction"><a href="#animation-direction" class="headerlink" title="animation-direction"></a>animation-direction</h4><p><code>normal/alternate/reverse/alternate-reverse</code></p><p>指示动画是否<strong>反向播放</strong>。</p><h4 id="animation-fill-mode"><a href="#animation-fill-mode" class="headerlink" title="animation-fill-mode"></a>animation-fill-mode</h4><p><code>none/forwards/backwards/both</code></p><p>设置CSS动画在<strong>执行之前和之后如何将样式应用于其目标</strong>。</p><h2 id="伪类-伪元素⭐"><a href="#伪类-伪元素⭐" class="headerlink" title="伪类/伪元素⭐"></a>伪类/伪元素⭐</h2><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p><strong>伪类</strong>是选择器的一种，它用于选择处于<strong>特定状态</strong>的元素。</p><p><code>:first-child</code> 第一个子元素，<code>:last-child</code>，最后一个子元素 <code>:nth-child()</code> 选中第n个子元素。</p><p><code>:hover</code>- 这仅适用于用户在元素上<strong>移动鼠标</strong>，通常是<strong>链接</strong>。</p><p><code>:focus</code> - 仅在用户通过<strong>单击或使用键盘控件</strong>来适用元素。</p><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p><strong><code>::before</code></strong>/<code>::after</code>用来创建一个伪元素，作为已选中元素的<strong>第一个</strong>/<strong>最后一个子元素</strong>。通常会配合<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content"><code>content</code></a>属性来为该元素添加装饰内容。这个虚拟元素<strong>默认是行内元素</strong>。</p><p><strong><code>::before</code></strong>/<code>::after</code>表示法是在<strong>CSS 3</strong>中引入的，<code>::</code>符号是用来区分<strong>伪类</strong>和伪元素的。支持CSS3的浏览器同时也都支持CSS2中引入的表示法<code>:before</code>/<code>:after</code>。</p><h1 id="纯CSS3实现卡通人物眼睛的动画特效⭐"><a href="#纯CSS3实现卡通人物眼睛的动画特效⭐" class="headerlink" title="纯CSS3实现卡通人物眼睛的动画特效⭐"></a>纯CSS3实现卡通人物眼睛的动画特效⭐</h1><p>整体主要是利用<strong>边框</strong>和<strong>圆角</strong>进行绘制。</p><ul><li><p>左眼勾玉：span设置圆角，它伪元素设置边框实现</p></li><li><p>右眼轮回圈：边框+圆角+层叠等级</p></li><li><p>木叶标志：边框+圆角</p></li><li><p>胡须：边框三角形</p></li><li><p>眼睛效果：<code>box-shadow</code>+<code>border-radius</code>获得眼睛轮廓和内眼影，外眼影<code>filter: drop-shadow</code></p></li></ul><p>具体设置数值参考他人，自己主要是换成了vw，vh进行自适应适配。</p><p>动画：</p><ul><li>眼睛：<code>animation</code>+<code>transform</code>（旋转、缩放）+<code>opacity</code>（不透明度）+<strong>定位</strong></li><li>hover鼠标移入，写轮眼 <strong>无限旋转</strong> 轮回眼 <strong>缩放 反向交替执行</strong></li></ul><h1 id="JacaScript"><a href="#JacaScript" class="headerlink" title="JacaScript"></a>JacaScript</h1><h2 id="语言⭐"><a href="#语言⭐" class="headerlink" title="语言⭐"></a>语言⭐</h2><h3 id="解释代码-vs-编译代码"><a href="#解释代码-vs-编译代码" class="headerlink" title="解释代码 vs 编译代码"></a>解释代码 vs 编译代码</h3><p>在<strong>解释型</strong>语言中，代码<strong>自上而下</strong>运行，且<strong>实时返回运行结果</strong>。</p><p>代码在由浏览器执行前，<strong>不需要将其转化为其他形式</strong>。代码将直接以<strong>文本格式（text form）</strong>被接收和处理。</p><p>相对的，<strong>编译型</strong>语言需要先将代码<strong>转化（编译）</strong>成另一种形式才能运行。</p><p>比如 C/C++ 先被<strong>编译成汇编语言</strong>，然后才能由计算机运行。程序将以<strong>二进制</strong>的格式运行，这些二进制内容是由程序源代码产生的。</p><p><strong>JavaScript 是轻量级解释型语言</strong>。</p><p>浏览器接受到JavaScript代码，并以代码自身的文本格式运行它。</p><p>技术上，几乎所有 JavaScript 转换器都运用了一种叫做<strong>即时编译（just-in-time compiling）</strong>的技术；</p><p>当 JavaScript 源代码被执行时，它会被编译成<strong>二进制</strong>的格式，使代码<strong>运行速度更快</strong>。</p><p>尽管如此，JavaScript 仍然是一门解释型语言，因为<strong>编译过程发生在代码运行中，而非之前</strong>。</p><h3 id="服务器端代码-vs-客户端代码"><a href="#服务器端代码-vs-客户端代码" class="headerlink" title="服务器端代码 vs 客户端代码"></a>服务器端代码 vs 客户端代码</h3><p>客户端代码是在用户的电脑上运行的代码，在浏览一个网页时，它的客户端代码就会被下载，然后由浏览器来运行并展示。</p><p>这就是<strong>客户端JavaScript</strong>。</p><p>而服务器端代码在服务器上运行，接着运行结果才由浏览器下载并展示出来。</p><p>流行的服务器端 web 语言包括：PHP、Python、Ruby、ASP.NET 以及…… JavaScript！</p><p><strong>JavaScript 也可用作服务器端语言</strong>，比如现在流行的 Node.js 环境。</p><h3 id="基于类-vs-基于原型的语言"><a href="#基于类-vs-基于原型的语言" class="headerlink" title="基于类 vs 基于原型的语言"></a>基于类 vs 基于原型的语言</h3><p><strong>基于类的面向对象语言</strong>，比如 Java 和 C++，是构建在两个不同实体之上的：类和实例。</p><ul><li>一个<strong>类(class)<strong>定义了</strong>某一对象集合所具有的特征性属性</strong>（可以将 Java 中的方法和域以及 C++ 中的成员都视作属性）。<strong>类是抽象的，而不是其所描述的对象集合中的任何特定的个体。</strong></li><li>另一方面，<strong>一个实例(instance)是一个类的实例化</strong>。<strong>实例具有和其父类完全一致的属性</strong>，不多也不少。</li></ul><p><strong>基于原型的语言（如 JavaScript）</strong>并不存在这种区别：它<strong>只有对象</strong>。</p><p>基于原型的语言具有所谓**原型对象(prototypical object)**的概念。</p><p><strong>原型对象可以作为一个模板，新对象可以从中获得原始的属性。</strong></p><p>任何对象都可以指定其自身的属性，既可以是创建时也可以在运行时创建。</p><p>而且，<strong>任何对象都可以作为另一个对象的原型(prototype)，从而允许后者共享前者的属性</strong>。</p><table><thead><tr><th align="left">基于类的（Java）</th><th align="left">基于原型的（JavaScript）</th></tr></thead><tbody><tr><td align="left">类和实例是不同的事物。</td><td align="left">所有对象均为实例。</td></tr><tr><td align="left">通过类定义来定义类；通过构造器方法来实例化类。</td><td align="left">通过构造器函数来定义和创建一组对象。</td></tr><tr><td align="left">通过 <code>new</code> 操作符创建单个对象。</td><td align="left">相同。</td></tr><tr><td align="left">通过类定义来定义现存类的子类，从而构建对象的层级结构。</td><td align="left">指定一个对象作为原型并且与构造函数一起构建对象的层级结构</td></tr><tr><td align="left">遵循类链继承属性。</td><td align="left">遵循原型链继承属性。</td></tr><tr><td align="left">类定义指定类的所有实例的<strong>所有</strong>属性。无法在运行时动态添加属性。</td><td align="left">构造器函数或原型指定实例的<strong>初始</strong>属性集。允许动态地向单个的对象或者整个对象集中添加或移除属性。</td></tr></tbody></table><h2 id="Js中的堆栈⭐"><a href="#Js中的堆栈⭐" class="headerlink" title="Js中的堆栈⭐"></a>Js中的堆栈⭐</h2><p>堆<code>heap</code>是<strong>动态分配</strong>的内存，<strong>大小不定</strong>也<strong>不会自动释放</strong>，栈<code>stack</code>为<strong>自动分配</strong>的内存空间，在代码执行过程中<strong>自动释放</strong>。</p><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>在栈内存中提供一个供<code>Js</code>代码执行的环境，关于<strong>作用域</strong>以及<strong>函数的调用</strong>都是栈内存中执行的。</p><p><code>Js</code>中基本数据类型<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Null</code>、<code>Undefined</code>、<code>Symbol</code>、<code>BigInt</code>，</p><ul><li><strong>占用空间小且大小固定</strong>，<strong>值直接保存在栈内存中，是按值访问</strong>，</li><li>对于<code>Object</code>引用类型，其<strong>指针放置于栈内存中</strong>，<strong>指向堆内存的实际地址</strong>，是通过<strong>引用</strong>访问。</li></ul><p>关于调用栈，每调用一个函数，解释器就会把该函数添加进调用栈并开始执行；</p><p>正在调用栈中执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行；</p><p>当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码；</p><p>当分配的调用栈空间被占满时，会引发<strong>堆栈溢出</strong>错误。</p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>引用类型<code>Object</code>的变量<strong>占据空间大且大小不固定</strong>，堆内存中存储<strong>实际对象</strong>，在栈内存中存储对象的指针。</p><p>对于对象的访问是按引用访问的，在堆区的内存不会随着程序的运行而自动释放，这就需要实现<strong>垃圾回收机制</strong><code>GC</code>。</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>需要注意的是在<code>Js</code>中没有类似于<code>C</code>中的<code>free()</code>函数去手动释放内存，对于堆区内存回收全部需要通过<code>Js</code>的垃圾回收机制去实现。<br>在<strong>栈</strong>区中执行的变量等是通过值访问，当其<strong>作用域销毁后变量也就随之销毁</strong>，</p><p>而使用引用访问的堆区变量，在一个作用域消失后还可能在外层作用域或者其他作用域仍然<strong>存在引用</strong>，不能直接销毁，</p><p>此时就需要通过算法计算该堆区变量是否属于不再需要的变量，从而决定是否需要进行内存回收，</p><p>在<code>Js</code>中主要有<strong>引用计数</strong>与<strong>标记清除</strong>两种垃圾回收算法。</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>对于引用计数垃圾回收算法，把对象是否不再需要简化定义为<strong>该对象有没有其他变量或对象引用到它</strong>，如果没有引用指向该对象，该对象将被垃圾回收机制回收。</p><p>在这里，对象的概念不仅特指<code>JavaScript</code>对象，还包括函数作用域或者全局词法作用域。</p><p>引用计数垃圾回收算法使用比较少，主要是在<code>IE6</code>与<code>IE7</code>等低版本<code>IE</code>浏览器中使用。</p><p>但是对于引用计数垃圾回收算法有个限制，当对象<strong>循环引用</strong>时，就会造成<strong>内存泄漏</strong>，也就是引用计数垃圾回收算法无法处理循环引用的对象。</p><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>对于标记清除垃圾回收算法，把对象是否不再需要简化定义为<strong>该对象是否可以获得</strong>。</p><p>该算法设置一个叫做根<code>root</code>的对象，在<code>Javascript</code>里根是全局对象，垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象，以此不断向下查找。</p><p><strong>从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象</strong>，这样便解决了循环引用的问题。</p><p>所有现代浏览器都使用了标记清除垃圾回收算法，所有对<code>JavaScript</code>垃圾回收算法的改进都是基于标记清除算法的改进。</p><ul><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都<strong>加上标记</strong>。</li><li>然后，它会<strong>去掉</strong>运行环境中的变量以及被环境中变量所引用的变量的标记。</li><li>此后，<strong>依然有标记</strong>的变量就被视为准备删除的变量，原因是<strong>在运行环境中已经无法访问到这些变量了</strong>。</li><li>最后，垃圾收集器完成内存清除工作，<strong>销毁那些带标记的值并回收它们所占用的内存空间</strong>。</li></ul><h2 id="数据类型⭐"><a href="#数据类型⭐" class="headerlink" title="数据类型⭐"></a>数据类型⭐</h2><blockquote><p>JavaScript 是一种<strong>弱类型</strong>或者说<strong>动态</strong>语言。</p><p><strong>不用提前声明变量的类型</strong>，在程序<strong>运行</strong>过程中，<strong>类型会被自动确定</strong>。</p><p>可以使用<strong>同一个变量保存不同类型的数据</strong>。</p></blockquote><h3 id="8种数据类型-7-1"><a href="#8种数据类型-7-1" class="headerlink" title="8种数据类型: 7+1"></a>8种数据类型: 7+1</h3><ul><li>原始类型(值不可变，栈)：<code>Undefined</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>BigInt</code>、<code>Symbol</code>、<code>Null</code></li><li>引用数据类型（堆，地址：栈）：<code>Object</code>（几乎所有通过 <code>new</code> 创建的东西：Array、Set、Date）</li></ul><h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><h4 id="typeof（操作符，非函数）"><a href="#typeof（操作符，非函数）" class="headerlink" title="typeof（操作符，非函数）"></a>typeof（操作符，非函数）</h4><p>对于<strong>原始类型</strong>，除 <code>null</code> （遗留已久的 bug）都可以正确判断；</p><p>对于引用类型，除 <code>function</code> 外，都会返回 <code>&#39;object&#39;</code>。</p><p>返回值为 <code>string</code> （小写）。</p><p><code>typeof</code> 未定义的变量返回 <code>&#39;undefined&#39;</code>。</p><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>用于检测构造函数的 <code>prototype</code> 属性是否出现在<strong>某个实例对象的原型链上</strong>。只能判断<strong>引用类型</strong>。</p><p>常用来判断 <code>A</code> 是否为 <code>B</code> 的实例。返回布尔值。</p><p><code>instanceof</code> 在多全局对象(例如：多个 frame 或多个 window 之间的交互)下不能正确判断。</p><p><strong>多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。</strong></p><h4 id="Object-prototype-toString-call-toString-call"><a href="#Object-prototype-toString-call-toString-call" class="headerlink" title="Object.prototype.toString.call()/toString.call()"></a>Object.prototype.toString.call()/toString.call()</h4><p>精准判断数据类型 。</p><p>统一返回格式<code>&#39;[object Xxx]&#39;</code> 的字符串</p><h3 id="判断数组"><a href="#判断数组" class="headerlink" title="判断数组"></a>判断数组</h3><ul><li><p><code>Array.isArray()</code></p></li><li><p><code>Object.prototype.toString.call()</code> 进行判断，此方式兼容性最好</p></li><li><p><code>instanceof</code></p><p>多个 frame 或多个 window 之间的交互不适用。</p></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><blockquote><p>隐式（自动）/显式强转（开发人员）</p></blockquote><p><strong>在 JS 中只会转换为以下 3 种类型</strong></p><ul><li><p><code>Number</code> 类型：</p><ul><li><p>强转：</p><ul><li><p><code>Number()</code></p><ul><li>字符串：<strong>空字符串变为0</strong>，如果出现<strong>任何一个非有效数字字符</strong>，结果都是<code>NaN</code></li><li>布尔： <code>true-&gt;1</code> <code>false-&gt;0</code></li><li><code>null-&gt;0</code> <code>undefined-&gt;NaN</code></li><li>Symbol<strong>无法</strong>转换为数字，<code>BigInt去除“n”</code></li><li><strong>对象</strong>：<ul><li><code>&#123;&#125;</code>：先转字符串<code>&#39;[object Object]&#39;</code>再转数字<code>NaN</code></li><li><code>[]</code>：先转字符串<code>&#39;&#39;</code>再转数字<code>0</code></li><li><code>[1]</code>：先转字符串<code>&#39;1&#39;</code>再转数字<code>1</code></li><li><code>[1,2]</code>：先转字符串<code>&#39;1,2&#39;</code>再转数字<code>NaN</code></li></ul></li></ul></li><li><p><code>parseInt(string, radix)</code>：</p><p><strong>逐个</strong>解析字符，并返回一个<strong>整数</strong>。</p><p>当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p></li><li><p><code>parseFloat(string)</code>：</p><p>指定字符串中的首个字符是否是数字。是，解析，直到到达数字的末端为止返回该数字。</p></li></ul></li><li><p>隐式：</p><ul><li>比较操作（<code>&gt;, &lt;, &lt;=, &gt;=</code>）</li><li>按位操作（<code>| &amp; ^ ~</code>）</li><li>算数操作（<code>- + * / %</code>） <strong>注意</strong>：当 <code>+</code> 操作存在任意的操作数是 <code>string</code> 类型时，不会触发number 类型的隐式转换</li></ul></li></ul></li><li><p><code>String</code> 类型：</p><ul><li>强转：<code>String()</code> / <code>toString()</code>(数组方法)</li><li>隐式：有 <code>+</code> 运算符并且有一个操作数是 <code>string/object</code> 类型</li></ul></li><li><p><code>Boolean</code> 类型:</p><ul><li>强转：<code>Boolean()</code></li><li>隐式：<strong>逻辑判断</strong>或者有逻辑运算符（<code>|| &amp;&amp; !</code>），<strong>逻辑运算符内部转换和比较，实际返回原始操作数值</strong><ul><li><strong>false</strong>：<code>0</code> <code>NaN</code> <code>&quot;&quot;</code> <code>null</code> <code>undefined</code>，其余都是true</li></ul></li></ul></li></ul><h3 id="amp"><a href="#amp" class="headerlink" title="=== &amp; =="></a><code>=== &amp; ==</code></h3><ul><li><code>===</code> 是严格相等，要求数据类型和值都要相等；<code>==</code> 只需要值相等。</li><li><code>==</code> 会发生隐式类型转换，<code>===</code> 不会发生隐式类型转换。</li></ul><p><code>==</code>类型转换规则</p><ul><li>两个<strong>对象</strong>，比较引用 <code>&#123;&#125;==&#123;&#125; //false</code></li><li><code>null/undefined</code>和其他任何值都不相等，但<code>null==undefined //true</code></li><li><code>NaN==NaN //false</code></li><li>一个<strong>对象</strong>，另一个是<strong>数字或字符串</strong>，会尝试使用<strong>对象方法转换为原始值</strong> <code>[] == 0 // true</code></li><li>当<strong>数字</strong>与<strong>字符串</strong>进行比较时，会尝试<strong>将字符串转换为数字值</strong>。<code>&#39;1222&#39;==1222 // true</code></li><li>操作数之一是<strong>Boolean</strong>，则将<strong>布尔操作数转换为1或0</strong> <code>true == 2 // false</code></li></ul><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a><code>Object.is()</code></h3><p>判断两个值是否为同一个值。如果满足以下条件则两个值相等:</p><ul><li>都是 <code>undefined</code></li><li>都是 <code>null</code></li><li>都是 <code>true</code> 或 <code>false</code></li><li>都是相同长度的字符串且相同字符按相同顺序排列</li><li>都是相同对象（意味着每个对象有同一个引用）</li><li>都是数字且<ul><li>都是 <code>+0</code></li><li>都是 <code>-0</code></li><li>都是 <code>NaN</code></li><li>或都是非零而且非 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a> 且为同一个值</li></ul></li></ul><p>与<code>==</code>运算<em>不同。</em> <code>==</code> 运算符在判断相等前对两边的变量(如果它们不是同一类型) 进行强制转换, 而 <code>Object.is</code>不会强制转换两边的值。</p><p>与<code>===</code>运算也不相同。 <code>===</code> 运算符 (也包括 <code>==</code> 运算符) 将数字 <code>-0</code> 和 <code>+0</code> 视为相等 ，而将<code>Number.NaN</code>与<code>NaN</code>视为不相等。</p><h2 id="“1”-”2”-”3”-map-parseInt-的输出结果是多少-⭐"><a href="#“1”-”2”-”3”-map-parseInt-的输出结果是多少-⭐" class="headerlink" title="[“1”,”2”,”3”].map(parseInt)的输出结果是多少?⭐"></a>[“1”,”2”,”3”].map(parseInt)的输出结果是多少?⭐</h2><p>这个网红题考察的就是 <code>parseInt</code> 有两个参数。 <code>map</code> 传入的函数可执行三个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ele   遍历的元素</span></span><br><span class="line"><span class="comment">// index 遍历的元素索引</span></span><br><span class="line"><span class="comment">// arr   数组</span></span><br><span class="line">arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">ele, index, arr</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>[‘1’,’2’,’3’].map(parseInt)相当于执行了以下三次过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;2&#x27;</span>, <span class="number">1</span>, [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;3&#x27;</span>, <span class="number">2</span>, [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br></pre></td></tr></table></figure><ul><li><code>parseInt(&#39;1&#39;, 0, [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;])</code>: radix为0时，默认取10，最后返回<code>1</code></li><li><code>parseInt(&#39;2&#39;, 1, [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;])</code>: radix取值为2~36，如果该参数小于 2 或者大于 36，返回<code>NaN</code></li><li><code>parseInt(&#39;3&#39;, 2, [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;])</code>: radix取值为2，二进制只包括0，1，返回<code>NaN</code></li></ul><p>如果想返回[1,2,3]，<code>[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;].map(n=&gt;parseInt(n))</code></p><p><strong>最简单的方案</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>].map(<span class="built_in">Number</span>)</span><br></pre></td></tr></table></figure><h2 id="Number⭐"><a href="#Number⭐" class="headerlink" title="Number⭐"></a>Number⭐</h2><p>基于 IEEE 754 标准的<strong>双精度 64 位</strong>二进制格式的值（<code>-(2^53 -1) 到 2^53 -1</code>）。<strong>它并没有为整数给出一种特定的类型</strong>。</p><p>除了能够表示浮点数外，还有一些带符号的值：<code>+Infinity</code>，<code>-Infinity</code> 和 <code>NaN</code> (非数值，Not-a-Number)。</p><p>要检查值是否大于或小于 <code>+/-Infinity</code>，你可以使用常量<code>Number.MAX_VALUE</code> 和 <code>Number.MIN_VALUE</code>。</p><p>另外在 ECMAScript 6 中，你也可以通过 <code>Number.isSafeInteger()</code>方法还有 <code>Number.MAX_SAFE_INTEGER</code>和 <code>Number.MIN_SAFE_INTEGER</code>来检查值是否在双精度浮点数的取值范围内。</p><p><strong>超出这个范围，JavaScript 中的数字不再安全了。</strong></p><h3 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1 + 0.2 !== 0.3?"></a>0.1 + 0.2 !== 0.3?</h3><p>导致这样的问题是因为 <code>JavaScript</code> 中使用基于<strong>IEEE 754标准</strong>的<strong>浮点数</strong>运算，所以会产生<strong>舍入误差</strong>。</p><p>双精度浮点数使用<strong>64 bit</strong>来进行存储。</p><p><strong>计算机中用二进制来存储小数，而大部分小数转成二进制之后都是无限循环的值，因此存在取舍问题，也就是精度丢失。</strong></p><p><strong>不管是浮点数计算的计算结果错误和大整数的计算结果错误，最终都可以归结到JS的精度只有53位（尾数只能存储53位的有效数字）。</strong></p><blockquote><p>解决方案</p></blockquote><ol><li>使用 <code>JavaScript</code> 提供的<strong>最小精度值</strong>判断误差是否在该值范围内<br><code>Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON</code></li><li>使用别人的轮子,例如：<code>math.js</code></li></ol><h2 id="作用域与闭包⭐"><a href="#作用域与闭包⭐" class="headerlink" title="作用域与闭包⭐"></a>作用域与闭包⭐</h2><blockquote><p>个人总结：（对内保护，对外引用）闭包是函数执行形成私有作用域，对内，对于私有作用域内的私有变量，起到保护作用，外界无法直接对其进行访问和操作；对外，私有作用域可以通过作用域链查找，对外部作用域进行访问查找。如果形成对外部作用域引用，则会阻止引擎的垃圾回收器释放当前被引用的内存空间。因此，可能会导致内存泄漏，需要特别关注。</p></blockquote><p><strong>一个函数</strong>和对其周围状态（<strong>lexical environment，词法环境</strong>）的<strong>引用</strong>捆绑在一起，这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）。</p><p><strong>每当创建一个函数，闭包就会在函数创建的同时被创建出来。</strong>闭包让你可以在一个<strong>内层函数</strong>中<strong>访问到其外层函数的作用域</strong>。</p><p>内部函数对外部函数中定义的<strong>所有变量和函数</strong>有完全访问权，以及<strong>外部函数可以访问的所有其他变量和函数</strong>，这样就形成了<strong>作用域链</strong>。</p><p><strong>当内部函数以某种方式于外部函数之外的任何作用域执行时</strong>，就会看到一个可观察的闭包。</p><p>由于内部函数可以通过闭包访问外部函数的作用域，所以<strong>外部函数中定义的变量和函数的存活时间就可以长于外部函数的执行时间</strong>。</p><p>本质就是<strong>上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放</strong>。</p><p>就导致上级作用域内的变量，<strong>等到下级作用域执行完以后才正常得到释放</strong>。</p><p><strong>优点</strong></p><ul><li>可以<strong>从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用</strong>。</li><li><strong>避免使用全局变量</strong>。</li><li>把变量存到独立的作用域，作为<strong>私有成员</strong>存在。</li></ul><p><strong>缺点</strong></p><ul><li>对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以<strong>使用不当会导致内存泄漏</strong>。</li><li>对处理速度具有负面影响。<strong>闭包的层级决定了引用的外部变量在查找时经过的作用域链长度</strong>。</li></ul><p><strong>应用</strong></p><ul><li><p><strong>用闭包模拟私有方法</strong> 模块模式：将共享环境创建于一个立即执行的匿名函数体内。这个环境中包含私有项无法在这个匿名函数外部直接访问，必须通过匿名函数返回的公共函数通过闭包机制访问。</p></li><li><p><strong>在循环中创建闭包</strong>：在<code>for</code>循环并未具备局部作用域，因此内层函数中的循环变量i都是外层函数的一个局部变量，循环结束后该变量是一个唯一值，可以使用<strong>立即执行匿名函数</strong>再创建一个闭包，将循环变量保存；或者使用<strong>let</strong>形成块作用域来保存每次的循环变量。</p></li><li><p><strong>高阶函数与柯里化</strong></p><p>简单来说，高阶函数是一个接收函数作为参数或将函数作为输出返回的函数。</p><p>柯里化是指一个函数，它接收函数 A，并且能返回一个新的函数，这个新的函数能够处理函数 A 的剩余参数。函数传入的参数相当于在函数内声明一个变量并赋值，所以这里也是利用了闭包机制。</p></li><li><p><strong>节流与防抖</strong></p></li></ul><h2 id="原型与原型链⭐"><a href="#原型与原型链⭐" class="headerlink" title="原型与原型链⭐"></a>原型与原型链⭐</h2><p><code>JS</code>中所有对象都具有一个<code>__proto__</code>隐式原型属性，指向该对象的原型对象。</p><p>每个函数都有一个<code>prototype</code>属性，也指向原型对象，原型对象有个<code>constructor</code>属性，指向该函数。</p><p>所有的对象（除了Object原型对象）本质上都是通过<code>new 函数</code>创建的。</p><p><strong>所有的函数（Object、Array、Function）都是对象</strong>，本质上都是通过<code>new Function</code>创建的。</p><p>实例对象的隐式原型属性<code>__proto__</code>指向其构造函数的显式原型属性<code>prototype</code>。</p><p>所有函数(包括<code>Function</code>)的隐式原型<code>__proto__</code>指向<code>Function</code>的显式原型（<code>Function.prototype</code>）。</p><p>所有函数（包括Function）的<strong>原型对象</strong>(默认是<strong>Object实例对象</strong>)都指向（<code>__proto__</code>）<strong>Object的原型对象</strong>。</p><p>Object的原型对象指向<code>null</code>。</p><p>实例对象在查找属性时，如果查找不到，就会沿着<code>__proto__</code>隐式原型去与对象关联的原型上查找，如果还查找不到，就去找原型的原型，直至查到最顶层null，这也就是<strong>原型链</strong>的概念。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/46q4cF"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/09/26/46q4cF.png" alt="46q4cF.png"></a></p><h2 id="DOM事件总结⭐"><a href="#DOM事件总结⭐" class="headerlink" title="DOM事件总结⭐"></a>DOM事件总结⭐</h2><h3 id="DOM事件的级别"><a href="#DOM事件的级别" class="headerlink" title="DOM事件的级别"></a>DOM事件的级别</h3><p><strong>DOM0的写法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种事件绑定的方式，如果绑定多个，则后面的会覆盖掉前面的</span></span><br><span class="line">element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是在 js 中的写法；如果要在html中写，写法是：在onclick属性中，加 js 语句。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;hello&#x27;);&quot;</span>&gt;</span>我是按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p><strong>DOM2的写法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高版本浏览器</span></span><br><span class="line">element.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// IE8及以下版本浏览器。IE11和谷歌浏览器等不支持</span></span><br><span class="line">element.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的第三参数中，<strong>true</strong>表示事件在<strong>捕获阶段</strong>触发，<strong>false</strong>表示事件在<strong>冒泡阶段</strong>触发（默认）。</p><p><code>addEventListener()</code>中的<code>this</code>，是<strong>绑定事件的对象</strong>；如果写箭头函数是<strong>window</strong>。</p><p>绑定多个响应函数执行顺序是：<strong>先绑定先执行</strong>。</p><p><strong>DOM3的写法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>DOM3中，增加了很多事件类型，比如<strong>鼠标事件</strong>、<strong>键盘事件</strong>等。</p><h3 id="DOM事件模型"><a href="#DOM事件模型" class="headerlink" title="DOM事件模型"></a>DOM事件模型</h3><p><strong>DOM事件模型</strong>讲的就是<strong>捕获和冒泡</strong>。</p><p><strong>DOM事件流</strong>讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。</p><p>完整的事件流，分三个阶段：</p><ul><li><p><strong>捕获</strong>：从 <code>window</code> 对象传到 <strong>目标元素</strong>。</p></li><li><p><strong>目标阶段</strong>：事件通过捕获，到达目标元素，这个阶段就是目标阶段。</p></li><li><p><strong>冒泡</strong>：从<strong>目标元素</strong>传到 <code>Window</code> 对象。</p></li></ul><p>捕获阶段，事件依次传递的顺序是：<code>window</code> –&gt; <code>document</code> –&gt; <code>html</code>–&gt; <code>body</code> –&gt; 父元素、子元素、目标元素。</p><p>冒泡的流程与捕获的流程相反。</p><p><strong>事件捕获优先于事件冒泡</strong>。</p><h3 id="Event对象的常见-api-方法"><a href="#Event对象的常见-api-方法" class="headerlink" title="Event对象的常见 api 方法"></a>Event对象的常见 api 方法</h3><p><strong>Event 对象代表事件的状态</strong>，当dom tree中某个事件被触发的时候，会同时自动产生一个<strong>用来描述事件所有的相关信息</strong>（比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态）的对象。</p><p>阻止默认事件<code>event.preventDefault();</code> 如阻止了链接的默认跳转</p><p>阻止冒泡 <code>event.stopPropagation();</code></p><h3 id="事件委托（代理）"><a href="#事件委托（代理）" class="headerlink" title="事件委托（代理）"></a>事件委托（代理）</h3><p>事件委派指将事件统一绑定给元素的<strong>共同的祖先元素</strong>，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。事件委派是利用了<strong>冒泡</strong>，通过委派可以减少事件绑定的次数，提高程序的性能。</p><p><code>event.currentTarget</code> 返回<strong>绑定事件的元素</strong>。在事件委托中，一般是【祖先元素】。<br><code>event.target</code> 返回<strong>触发事件的元素</strong>。在事件委托中，一般是【子元素】。</p><p><strong>应用场景</strong></p><p>例如我们有<code>10</code>个<code>&lt;li&gt;</code>标签，每个标签有一个<code>uid</code>作为判断用户点击的区别，使用冒泡就不需要为每个<code>&lt;li&gt;</code>绑定点击事件，可以把点击事件绑定到<code>&lt;ul&gt;</code>上，通过<code>event.target</code>获得触发事件的元素，称为事件委托。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;u1&quot;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    alert(e.target.getAttribute(<span class="string">&#x27;uid&#x27;</span>));<span class="comment">//返回元素上一个指定的属性值。</span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><h2 id="this指向⭐"><a href="#this指向⭐" class="headerlink" title="this指向⭐"></a>this指向⭐</h2><p>目的就是指向<strong>函数</strong>运行时（箭头函数除外）所在的环境。</p><p>总结了<code>this</code>的绑定规则总共是有下面5种：请记住一点：==谁调用这个函数或方法,this关键字就指向谁。==</p><ul><li>默认绑定（严格/非严格模式）<ul><li>无论是否在严格模式下，在全局执行环境中（在任何函数体外部）<code>this</code> 都指向全局对象。</li><li>非严格模式，函数中 <code>this</code> 的值默认指向全局对象，浏览器中就是<code>window</code>。</li><li>严格模式下，<code>this</code> 会保持为 <code>undefined</code>。</li></ul></li><li>隐式绑定<ul><li>当<strong>函数作为对象的属性</strong>存在，通过<strong>对象属性执行函数</strong>时，此时隐式绑定规则会将<code>this</code>绑定到对象上。</li><li>赋值或函数传参（隐式赋值），会丢失该this绑定。</li></ul></li><li>显式绑定<ul><li><strong>通过 <code>call</code> <code>apply</code> <code>bind</code>绑定</strong></li></ul></li><li>new绑定<ul><li>当一个函数用作<strong>构造函数</strong>时（使用<code>new</code>关键字），它的<code>this</code>被绑定到<strong>正在构造的新对象</strong>。</li><li>当构造函数<strong>返回值为对象</strong>时，直接返回这个对象；否则返回<strong>new创建的对象</strong>。</li><li><code>this</code> 在类中的表现与在函数中类似，在类的构造函数中，<code>this</code> 是一个常规对象。类中所有非静态的方法都会被添加到 <code>this</code> 的原型。静态方法不是 this 的属性，它们只是类自身的属性。</li><li>派生类的构造函数没有初始的 <code>this</code> 绑定。在构造函数中调用 <code>super()</code>会生成一个 <code>this</code> 绑定，并相当于获得基类的this。</li></ul></li><li>ES6箭头函数绑定<ul><li>通过<strong>作用域链</strong>查到<strong>外层作用域的 this</strong> ，且指向<strong>函数定义时的 this</strong> 而非执行时</li></ul></li></ul><p>判断this指向顺序：new、call/apply/bind、隐式绑定、默认绑定</p><h2 id="JS数组常用方法总结⭐"><a href="#JS数组常用方法总结⭐" class="headerlink" title="JS数组常用方法总结⭐"></a>JS数组常用方法总结⭐</h2><p>常见的数组定义：<strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p><p>==JavaScript 数组的长度和元素类型都是非固定的。==</p><p>因为数组的<strong>长度可随时改变</strong>，并且其数据<strong>在内存中也可以不连续</strong>（存储相同类型元素内存连续）。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><code>Array.from()</code> 从一个<strong>类数组</strong>或<strong>可迭代对象</strong>创建一个<strong>新的</strong>、<strong>浅拷贝</strong>的Array实例。</p><p><code>Array.isArray()</code>判断数组</p><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><p><code>Array.prototype.length</code></p><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p><strong>改变原数组</strong>的方法(9个):</p><ul><li><code>push(element1, ...)</code>：<strong>末尾</strong>+1/多，并返回<code>length</code></li><li><code>pop()</code>：<strong>删除最后一个元素</strong>，并<strong>返回该元素的值</strong>。</li><li><code>unshift(element1, ...)</code>：<strong>开头</strong>+1/多，并返回<code>length</code></li><li><code>shift()</code>：<strong>删除第一个元素</strong>，并<strong>返回该元素的值</strong>。</li><li><code>splice(开始,删除个数,新元素1...)</code>：<strong>删除</strong>或<strong>替换</strong>现有元素或者<strong>原地添加</strong>新的元素来修改数组,并<strong>以数组形式返回被删除的元素</strong></li><li><code>sort([比较函数])</code>：<strong>原地算法</strong>对数组的元素进行排序，并返回数组。比较函数返回值&gt;0,交换a、b。升序排列：<code>arr.sort((a,b)=&gt;a - b)</code></li><li><code>reverse()</code>：翻转数组</li><li><code>fill(1,0,this.length)</code>：用一个<strong>固定值</strong>填充一个数组中从<strong>起始索引</strong>到<strong>终止索引</strong>内的全部元素。<strong>不包括终止索引</strong>。返回<strong>修改后的数组</strong>。</li></ul><p><strong>不改变原数组</strong>的方法(8个):</p><ul><li><code>slice(begin,end)</code>：返回一个新的数组对象(一个<code>[begin,end)</code>决定的原数组的<strong>浅拷贝</strong>）</li><li><code>join(&#39;&#39;)</code>：将一个数组（或一个<strong>类数组对象</strong>）的所有元素连接成一个<strong>字符串</strong>并返回这个字符串。默认<code>,</code>分隔。</li><li><code>concat(arr1,...)</code>：合并数组，<strong>浅拷贝</strong></li><li><code>indexOf(searchElement, fromIndex)</code>：返回在数组中可以找到一个<strong>给定元素的第一个索引</strong>，如果不存在，则返回<code>-1</code>。严格相等<code>===</code>搜索元素。不能识别<code>NaN</code>。</li><li><code>includes</code>：判断一个数组是否包含一个指定的值，返回<strong>布尔值</strong>。</li></ul><p><strong>遍历</strong>方法(12个):</p><ul><li><p><code>forEach</code>：对数组的每个元素执行一次给定的函数。<code>array.forEach(function(currentValue, index, arr), thisArg)</code></p><ul><li>无法中途退出循环，只能用<code>return</code>退出本次回调，进行下一次回调。</li><li>它总是返回 <code>undefined</code>值,即使你return了一个值。</li></ul></li><li><p><code>map</code>：创建一个<strong>新数组</strong>，其结果是<strong>该数组中的每个元素都调用一个提供的函数后返回的结果</strong>。</p><ul><li><code>let new_array = arr.map(function(currentValue, index, arr), thisArg)</code></li></ul></li><li><p><code>filter</code>：返回一个<strong>新数组</strong>, 其包含<strong>通过所提供函数实现的测试的所有元素</strong>。</p><ul><li><code>let new_array = arr.filter(function(currentValue, index, arr), thisArg)</code></li></ul></li><li><p><code>reduce</code>：对累加器和数组中的每个元素（<strong>从左到右</strong>）应用一个函数，最终合并为一个值。</p><ul><li><code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code></li><li>如果 <code>initialValue</code> 在调用 reduce 时被提供，那么<strong>第一个</strong> <code>total</code> 将等于 <code>initialValue</code>，此时 <code>currentValue</code> 等于数组中的<strong>第一个值</strong>；</li><li>如果 <code>initialValue</code> 未被提供，那么 <code>total</code> 等于数组中的<strong>第一个值</strong>，<code>currentValue</code> 等于数组中的<strong>第二个值</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组求和 </span></span><br><span class="line"><span class="keyword">let</span> sum = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 将二维数组转化为一维 将数组元素展开</span></span><br><span class="line"><span class="keyword">let</span> flattened = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.concat(b),[]);</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p><code>find</code>:用于找出<strong>第一个符合条件</strong>的数组成员，并<strong>返回该成员</strong>，如果没有符合条件的成员，则返回<code>undefined</code>。</p><ul><li><code>let new_array = arr.find(function(currentValue, index, arr), thisArg)</code></li></ul></li><li><p><code>keys/values/entries</code></p><ul><li><code>arr.keys()/arr.values()/arr.entries()</code></li><li>返回一个新的<strong>Array Iterator</strong>对象，遍历<strong>索引键</strong>、遍历<strong>键值</strong>、遍历<strong>索引键+键值</strong></li><li>在<code>for..of</code>中如果遍历中途要退出，可以使用<code>break</code>退出循环。</li></ul></li></ul><h2 id="浅拷贝和深拷贝⭐"><a href="#浅拷贝和深拷贝⭐" class="headerlink" title="浅拷贝和深拷贝⭐"></a>浅拷贝和深拷贝⭐</h2><p>对象直接赋值的情况，不涉及任何拷贝。此时为<strong>同一个引用</strong>。</p><p>浅拷贝只能拷贝<strong>一层对象</strong>。如果有对象的<strong>嵌套</strong>，那么浅拷贝将无能为力。</p><p><strong>浅拷贝：</strong></p><ul><li><strong>concat()</strong></li><li><strong>slice()</strong></li><li><strong>…展开运算符</strong></li><li><strong>Array.from</strong></li><li><strong>Object.assign(target, …sources)</strong> 拷贝的是<strong>（可枚举）属性值</strong>。假如源值是一个对象的引用，它仅仅会复制其<strong>引用值</strong>。</li></ul><p><strong>深拷贝:</strong></p><p><code>JSON.parse(JSON.stringify(object))</code></p><ol><li>无法解决<code>循环引用</code>的问题。举个例子：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">val</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a.target = a;</span><br></pre></td></tr></table></figure><p>拷贝a会出现系统栈溢出，因为出现了<code>无限递归</code>的情况。</p><ol start="2"><li>无法拷贝一些<code>特殊的对象</code>，诸如 RegExp, Date, Set, Map等。</li><li>无法拷贝<code>函数</code>。</li><li>会忽略 <code>undefined</code>、<code>symbol</code>等</li></ol><p>第三方最完善的深拷贝方法是<code>Lodash</code>库的 <code>_.cloneDeep()</code>方法。</p><h2 id="Js中Date对象⭐"><a href="#Js中Date对象⭐" class="headerlink" title="Js中Date对象⭐"></a>Js中Date对象⭐</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sun Oct 18 2020 10:46:54 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(value); <span class="comment">// new Date(1602989155183)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(dateString);<span class="comment">// new Date(&quot;2020-10-18 10:15:30&quot;)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);<span class="comment">// new Date(2020, 9, 18, 10, 15, 30)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">Date</span>())); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p><code>Date.now()</code>方法返回自<code>1970</code>年<code>1</code>月<code>1</code>日<code>00:00:00 (UTC)</code>到当前时间的毫秒数。</p><p><code>dateObj.getFullYear()</code>方法根据本地时间返回指定日期的年份。</p><p><code>dateObj.getMonth()</code>根据本地时间，返回一个指定的日期对象的月份，为基于<code>0</code>的值，<code>0</code>表示一年中的<strong>第一月</strong>。</p><p><code>dateObj.getDate()</code>根据本地时间，返回一个指定的日期对象为一个月中的哪一日，范围为从<code>1-31</code>。</p><p><code>dateObj.getDay()</code>方法根据本地时间，返回一个具体日期中一周的第几天，<code>0</code>表示星期天。</p><p><code>dateObj.getHours()</code>方法根据本地时间，返回一个指定的日期对象的小时。</p><p><code>dateObj.getMinutes()</code>方法根据本地时间，返回一个指定的日期对象的分钟数。</p><p><code>dateObj.getSeconds()</code>方法根据本地时间，返回一个指定的日期对象的秒数。</p><p><code>dateObj.toLocaleString([locales [, options]])</code>方法返回该日期对象的字符串，该字符串格式因不同语言而不同。新增的参数<code>locales</code>和<code>options</code>使程序能够指定使用哪种语言格式化规则，允许定制该方法的表现<code>behavior</code>。在旧版本浏览器中，<code>locales</code>和<code>options</code>参数被忽略，使用的语言环境和返回的字符串格式是各自独立实现的。</p><p>每隔1s显示当前时间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formateCurrentDate= <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> date.getFullYear() + <span class="string">&#x27;-&#x27;</span></span><br><span class="line">        + (date.getMonth() + <span class="number">1</span>) + <span class="string">&#x27;-&#x27;</span></span><br><span class="line">        + date.getDate() + <span class="string">&#x27; &#x27;</span></span><br><span class="line">        + date.getHours() + <span class="string">&#x27;:&#x27;</span></span><br><span class="line">        + date.getMinutes() + <span class="string">&#x27;:&#x27;</span></span><br><span class="line">        + date.getSeconds();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// document.querySelectorAll(&#x27;span&#x27;)[0].textContent=formateCurrentDate();</span></span><br><span class="line">    <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;span&#x27;</span>)[<span class="number">0</span>].textContent=<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString();</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// react</span></span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        setTime(formateCurrentDate())</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6+"></a>ES6+</h1><h2 id="let、const和var的区别⭐"><a href="#let、const和var的区别⭐" class="headerlink" title="let、const和var的区别⭐"></a>let、const和var的区别⭐</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul><li><p>存在<strong>变量提升</strong>，即变量可以在声明之前调用，值为<code>undefined</code>。</p></li><li><p>可以<strong>重复声明</strong>，第一次用来声明，后面只是重新赋值。</p></li><li><p>在<strong>函数</strong>中使用var声明变量的时候，该变量是<strong>局部</strong>的；对于声明在任何函数外（<strong>特别注意if和for中</strong>）的变量来说是<strong>全局</strong>的。</p></li></ul><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li><p>不存在变量提升，let声明变量前，该变量不能使用（<strong>暂时性死区</strong>）。</p></li><li><p>在<strong>块级作用域</strong>内有效。</p></li><li><p>let不允许在<strong>相同作用域</strong>中重复声明，注意是相同作用域，不同作用域有重复声明不会报错。</p></li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul><li><p><strong>不存在变量提升</strong>。</p></li><li><p><strong>存在块级作用域</strong>。</p></li><li><p><strong>同一作用域不允许重复声明变量</strong>。</p></li><li><p>const声明创建对值的<strong>只读引用</strong>。这并不意味着它持有的值是不可变的，只是变量标识符不能被重新分配。例如，在内容是<strong>对象</strong>的情况下，这意味着可以更改对象的内容（例如，其属性）</p></li></ul><blockquote><p>全局中用<strong>let</strong>和<strong>const</strong>声明的变量存在<strong>Script</strong>上，用<strong>var</strong>声明的存在<strong>Global</strong>上（浏览器一般用<strong>Window</strong>表示）</p></blockquote><h3 id="变量提升和函数提升"><a href="#变量提升和函数提升" class="headerlink" title="变量提升和函数提升"></a>变量提升和函数提升</h3><ul><li><p><strong>所有的声明都会提升到作用域的最顶上去</strong>。</p></li><li><p>同一个变量只会<strong>声明一次</strong>，其他的会被忽略掉。</p></li><li><p><strong>函数声明的优先级高于变量声明的优先级</strong>，并且函数声明和函数定义的部分一起被提升。</p></li><li><p><strong>函数表达式声明的函数</strong>，相当于<strong>变量提升</strong>，如果使用<strong>const</strong>或<strong>let</strong>，则无法提升。</p></li></ul><h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><p>当函数中隐式声明一个变量时：</p><ul><li><p><strong>该变量和参数同名</strong>，该变量为<strong>局部变量</strong>。</p><p>函数传参相当于在内部声明了一个局部变量（<code>var param = param;</code>）</p><ul><li>实参如果是<strong>对象</strong>，就把该对象的<strong>地址</strong>赋给这个局部变量，可以通过地址<strong>修改外层对象的属性</strong>，但如果重新赋给该变量一个<strong>新的对象</strong>，不会覆盖外层对象</li><li>实参如果是<strong>原始类型</strong>就把值赋给该变量，<strong>修改该变量不会影响外层变量</strong>。</li></ul></li><li><p>函数<strong>没有参数</strong>，通过<strong>作用域链</strong>向外一直找到<strong>全局作用域</strong>。</p><ul><li>如果有该变量，说明该变量只是在其他地方进行了声明。</li><li>若没有找到，此时<strong>隐式声明了一个全局变量（window上）</strong>，且不会进行变量提升。</li></ul></li></ul><h2 id="Class与继承⭐"><a href="#Class与继承⭐" class="headerlink" title="Class与继承⭐"></a>Class与继承⭐</h2><p><strong>类是用于创建对象的模板。</strong>JS中的类建立在<strong>原型</strong>上，但也具有某些语法和语义未与ES5类相似语义共享。</p><h3 id="类定义与调用"><a href="#类定义与调用" class="headerlink" title="类定义与调用"></a>类定义与调用</h3><p><strong>类表达式</strong>和<strong>类声明</strong>。<strong>两者都不会提升</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Rectangle(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;&#125; <span class="comment">//类声明</span></span><br><span class="line"><span class="keyword">let</span> Rectangle = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;<span class="comment">//类表达式</span></span><br></pre></td></tr></table></figure><p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>类的主体都执行在<strong>严格模式</strong>下，与普通构造函数不同。</p><p>当调用静态或原型方法时<strong>没有指定 this的值</strong>，那么方法内的 this值将被置为 **<code>undefined</code>**。</p><h3 id="构造函数与方法"><a href="#构造函数与方法" class="headerlink" title="构造函数与方法"></a>构造函数与方法</h3><p><code>constructor</code>（<strong>构造函数</strong>）方法是一个特殊的方法，这种方法用于<strong>创建和初始化</strong>一个由<code>class</code>创建的对象。</p><p>一个构造函数可以使用 <code>super</code> 关键字来<strong>调用一个父类的构造函数</strong>，从而获得父类的this。</p><p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。</p><p>事实上，<strong>类的所有非静态方法</strong>都定义在类的<code>prototype</code>属性上面。</p><p>因此，<strong>在类的实例上面调用方法，其实就是调用原型上的方法</strong>。</p><p>另外，类的内部所有定义的方法，都是<strong>不可枚举的（non-enumerable）</strong>。这一点与 ES5 的行为不一致。</p><p><code>static</code> 关键字用来定义一个类的一个静态方法。调用静态方法不需要<strong>实例化</strong>该类，但<strong>不能通过一个类实例调用静态方法</strong>。静态方法通常用于<strong>为一个应用程序创建工具函数</strong>。</p><h3 id="属性-字段"><a href="#属性-字段" class="headerlink" title="属性/字段"></a>属性/字段</h3><p><strong>实例的属性</strong>必须定义在<strong>类的方法里</strong>，静态的或原型的数据属性必须定义在<strong>类定义的外面</strong>。</p><p><strong>字段声明</strong>（实验性功能）</p><ul><li><p>公有字段：预先声明字段，类定义变得更加自我记录，并且字段始终存在。这个字段<strong>可以用也可以不用默认值来声明</strong>。</p></li><li><p>私有字段（<code>#</code>） 它们只能在类里面中读取或写入。</p></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><code>extends</code> 关键字在类声明或类表达式中用于创建一个类作为另一个类的一个子类。</p><p>如果子类中定义了构造函数，那么它必须先调用 <code>super()</code> 才能使用 <code>this</code> 。</p><p><code>super</code> 关键字也用于<strong>调用对象的父对象上的方法。</strong><code>super.fn();</code></p><p>也可以继承传统的基于函数的“类”，但不能继承<strong>常规对象（不可构造的）</strong>。</p><p>如果要继承常规对象，可以改用<code>Object.setPrototypeOf()</code>：</p><p><code>Object.setPrototypeOf(obj, proto);</code>直接修改已有对象的原型。</p><h2 id="箭头函数与普通函数区别⭐"><a href="#箭头函数与普通函数区别⭐" class="headerlink" title="箭头函数与普通函数区别⭐"></a>箭头函数与普通函数区别⭐</h2><p><strong>箭头函数表达式</strong>的语法比<strong>函数表达式</strong>更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。</p><p>箭头函数表达式<strong>更适用于那些本来需要匿名函数的地方</strong>，并且它<strong>不能用作构造函数</strong>。</p><ol><li>箭头函数<strong>没有自己的this</strong>，它是<strong>通过作用域链查到外层作用域的this</strong>，且指向函数<strong>定义时</strong>的this而<strong>非执行时</strong>。</li><li><strong>不可以用作构造函数</strong>，<strong>不能使用new命令</strong>，否则会报错。同时，箭头函数<strong>没有prototype属性</strong>。</li><li>箭头函数<strong>没有arguments对象</strong>，如果要用，使用<strong>rest参数</strong>（<code>...args</code>）代替。</li><li><strong>不可以使用yield命令</strong>，因此箭头函数<strong>不能用作Generator函数</strong>。</li><li><strong>不能用call/apply/bind修改this指向</strong>，但<strong>可以通过修改外层作用域的this来间接修改</strong>。</li></ol><h2 id="Set，WeakSet，Map和WeakMap⭐"><a href="#Set，WeakSet，Map和WeakMap⭐" class="headerlink" title="Set，WeakSet，Map和WeakMap⭐"></a>Set，WeakSet，Map和WeakMap⭐</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>值的集合（键和值相同，且唯一）</p><p><strong>方法</strong>：</p><ul><li><code>set.add(v)</code></li><li><code>set.delete(v)</code></li><li><code>set.has(v)</code>（返回布尔值）</li><li><code>set.clear()</code></li></ul><p><strong>属性</strong>：<code>set.size</code></p><p><strong>实现了iterator接口</strong></p><ul><li><p>可以使用<code>for…of…</code>进行遍历 <code>set.keys()</code>，<code>set.values()</code>(默认)，<code>set.entries()</code></p></li><li><p>遍历顺序就是<strong>插入顺序</strong></p></li><li><p><code>forEach</code>（键值、键名、集合本身），用于对每个成员执行某种操作，没有返回值</p></li><li><p>扩展运算符（<code>...</code>）</p></li><li><p>数组的<code>map</code>和<code>filter</code>方法也可以<strong>间接</strong>用于 Set 了 <code>new Set([...set].map(x =&gt; x * 2))</code></p></li></ul><p><strong>应用</strong></p><ul><li><p><strong>去重</strong></p><ul><li><code>Set</code>函数可以接受一个数组（或者具有 <code>iterable</code> 接口的其他数据结构）作为参数，用来初始化。</li><li>数组去重：<code>Array.from(new Set(array))</code>或<code>[...new Set(array)]</code></li><li>字符串去重：<code>[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)</code></li><li>set中所有<code>NaN</code>值都是相等的。</li></ul></li><li><p><strong>交并差</strong> <code>let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);</code></p><ul><li>交：<code>new Set([...a].filter(x =&gt; b.has(x)))</code></li><li>并：<code>new Set([...a, ...b])</code></li><li>差：<code>new Set([...a].filter(x =&gt; !b.has(x)))</code></li></ul></li></ul><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>值只能是<strong>对象</strong></p><p><strong>弱引用：</strong>如果其他对象都不再引用该对象，那么<strong>垃圾回收机制会自动回收该对象所占用的内存</strong>，不考虑该对象还存在于 WeakSet 之中。</p><p>由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，所以<strong>不可遍历</strong> 。</p><p>方法：<code>ws.add(v)</code> <code>ws.delete(v)</code> <code>ws.has(v)</code></p><p>使用场景：<strong>储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏</strong>。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><strong>键值对</strong>的<strong>有序</strong>列表，而键和值都可以是<strong>任意类型</strong></p><p>方法：</p><ul><li><code>map.set(k, v)</code></li><li>``map.get(k)`（返回键对应的值）</li><li><code>map.has(k)</code>（返回布尔值）</li><li><code>map.delete(k)</code></li><li><code>map.clear()</code></li></ul><p>属性：<code>map.size</code></p><p>遍历大致同Set，只是set的键值相同。Map初始化传入的应该至少是一个<strong>二维数组</strong>。<code>entries()</code>（默认，[键，值]）</p><p><strong>Object 和 map 的比较</strong></p><ul><li><p>map 只包含<strong>显式插入的键</strong>；Object <strong>原型链</strong>上的键名有可能和你自己在对象上的设置的键名产生冲突。</p></li><li><p>map 键可以是<strong>任意值</strong>；Object 的键必须是一个 <code>String</code> （其他类型键会转换为字符串，如对象=&gt;<code>&#39;[object Object]&#39;</code>）或是<code>Symbol</code>。<strong>不是有效的JavaScript标识符的属性名</strong>(如，具有空格或连字符的属性名，或以数字开头的属性名)<strong>只能使用方括号</strong>符号访问。</p></li><li><p>map 键 有序（插入）；Object 的键是<strong>无序</strong>的。自ECMAScript 2015规范以来，对象确实保留了字符串和Symbol键的创建顺序； 因此，在<strong>只有字符串键的对象</strong>上进行迭代将按插入顺序产生键。</p></li><li><p>键值对个数 map size；Object无。</p></li><li><p>map 本身可迭代； Object 需要以某种方式获得键。</p></li><li><p>map在<strong>频繁增删键值对</strong>的场景下表现更好。</p></li></ul><p><strong>对象和map互换</strong></p><ul><li><p>对象转为 Map 。 <code>new Map(Object.entries(obj))</code></p></li><li><p>map 转为对象。如果所有Map的键都是字符串，它可以无损地转为对象。如果有<strong>非字符串</strong>的键名，那么这个键名会被<strong>转成字符串</strong>，再作为对象的键名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>数组和map互换</strong></p><ul><li><p>Map 转为数组 <code>[...myMap]</code></p></li><li><p>数组 转为 Map</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="literal">true</span>, <span class="number">7</span>],</span><br><span class="line">  [&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]]</span><br><span class="line">])</span><br></pre></td></tr></table></figure></li></ul><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p><strong>键名</strong>只能<strong>对象</strong> ，<strong>弱引用的只是键名</strong>，<strong>无法遍历</strong></p><p>方法：<code>wm.get(k)</code>、<code>wm.set(k,v)</code>、<code>wm.has(k)</code>、<code>wm.delete(k)</code></p><p>应用：<strong>DOM 节点作为键名</strong>，防止内存泄漏；部署私有属性；<strong>深拷贝循环引用</strong></p><h2 id="事件循环机制⭐"><a href="#事件循环机制⭐" class="headerlink" title="事件循环机制⭐"></a>事件循环机制⭐</h2><blockquote><p>事件循环负责收集事件（包括用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。</p><p>循环执行等待中的宏任务和微任务，并开始下一次循环之前执行一些必要的渲染和绘制操作。</p></blockquote><p>任务的执行模式</p><ul><li>同步：连续性、阻塞</li><li>异步<ul><li>宏任务（Macrotask，Task，宿主（浏览器、Node）发起）：<code>script</code>（整体代码块）、<code>setTimeout</code>、<code>setInterval</code></li><li>微任务（Microtask，Jobs， JS 自身发起）：<code>Promise.[ then/catch/finally ]</code>、<code>queueMicrotask</code></li></ul></li></ul><p>一个完整的 <strong>Event Loop</strong> 过程，可以概括为以下阶段：</p><ul><li><p>一开始<strong>执行栈空,<strong>我们可以把</strong>执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</strong>。<strong>微任务队列空</strong>，<strong>宏任务队列</strong>里有且只有一个 <strong>script 脚本（整体代码）</strong>。</p></li><li><p><strong>全局上下文（script 标签）被推入执行栈</strong>，<strong>同步代码执行</strong>。</p><ul><li>在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生<strong>新的宏任务与微任务</strong>，它们会分别被<strong>推入各自的任务队列</strong>里。</li><li>同步代码执行完了，script脚本会被<strong>移出宏任务队列</strong>。</li><li>这个过程本质上是<strong>队列的宏任务的执行和出队</strong>的过程。</li></ul></li><li><p>上一步我们出队的是一个<strong>宏任务</strong>，这一步我们处理的是微任务。</p><ul><li>当<strong>宏任务出队</strong>时，任务是<strong>一个一个</strong>执行的；</li><li>而<strong>微任务出队</strong>时，任务是<strong>一队一队</strong>执行的。</li><li>因此，我们处理微任务队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</li></ul></li><li><p><strong>执行渲染操作，更新界面</strong></p></li><li><p>检查是否存在<code>Web worker</code>任务，如果有，则对其进行处理</p></li><li><p>上述过程循环往复，直到两个队列都清空。</p></li></ul><p><strong>如何理解 script（整体代码块）是个宏任务呢</strong></p><p>同时存在两个script代码块，会首先在执行<strong>第一个 script 代码块中的同步代码</strong>，如果这个过程中创建了微任务并进入了微任务队列，第一个 script 同步代码执行完之后，会首先去<strong>清空微任务队列</strong>，再去开启<strong>第二个 script 代码块</strong>的执行。</p><p>首次执行<strong>宏队列中会有 script（整体代码块）任务</strong>，所以实际上就是 Js 解析完成后，在异步任务中，会<strong>先执行完所有的微任务</strong>。需要注意的是，<strong>新创建的微任务会立即进入微任务队列排队执行，不需要等待下一次轮回</strong>。</p><p>所谓任务，浅显来说就是<strong>代码块开始执行的入口</strong>(确切地说，是函数栈的入口)。</p><p>而在 <code>JS</code> 里，除了“<code>script</code>整体代码块”之外，<strong>所有代码块的入口都是“回调函数”</strong>，回调函数被注册到事件后不会马上被执行，而是保存在一个神秘的的地方，保存起来待执行的才能算“任务”，然后才有宏/微任务之分。</p><p>“<code>script</code>整体代码块”的特殊之处，在于<strong>它的入口不是回调函数</strong>，但是我们可以想象它被装在一个隐形的函数里，作为回调函数被注册到某个事件里（大概是它解析完成之后会触发的一个事件），这时候这个隐形的函数就成为了一个任务。</p><p>浏览器<code>UI</code>是多线程的，异步任务借助浏览器的线程和<code>JavaScript</code>的执行机制实现。</p><p><strong>queueMicrotask</strong></p><p><strong>可以安全的引入微任务而避免使用额外的技巧</strong>。由晦涩地使用 promise 去创建微任务而带来的风险就可以被避免了。举例来说，当使用 promise 创建微任务时，由回调抛出的异常被报告为 rejected promises 而不是标准异常。同时，创建和销毁 promise 带来了事件和内存方面的额外开销，这是正确入列微任务的函数应该避免的。</p><h2 id="异步编程⭐"><a href="#异步编程⭐" class="headerlink" title="异步编程⭐"></a>异步编程⭐</h2><p><strong>JavaScript是一种同步的、阻塞的、单线程的语言</strong>，在这种语言中，一次只能执行一个操作。</p><p>但web浏览器定义了函数和API，允许我们当某些事件发生时不是按照同步方式，而是<strong>异步地调用函数</strong>(比如，时间的推移，用户通过鼠标的交互，或者获取网络数据)。这意味着您的代码可以同时做几件事情，而不需要停止或阻塞主线程。</p><p>通过 <code>Web workers</code>可以把一些任务交给一个名为<code>worker</code>的单独的线程，这样就可以同时运行多个JavaScript代码块。</p><p>web workers有用但也有局限。如<strong>不能访问 DOM— 不能让一个worker直接更新UI</strong>。</p><h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><p>异步callbacks 其实就是<strong>函数</strong>，只不过是作为<strong>参数</strong>传递给那些在后台执行的其他函数。</p><p>如：异步callback 就是<code>addEventListener()</code>第二个参数。</p><p>当我们把<strong>回调函数作为一个参数传递给另一个函数时，仅仅是把回调函数定义作为参数传递过去</strong> — <strong>回调函数并没有立刻执行，回调函数会在包含它的函数的某个地方异步执行，包含函数负责在合适的时候执行回调函数</strong>。</p><p>不是所有的回调函数都是异步的 — <strong>有一些是同步的</strong>。一个例子就是使用 <code>Array.prototype.forEach()</code>来遍历数组。</p><h3 id="setTimeout-amp-setInterval"><a href="#setTimeout-amp-setInterval" class="headerlink" title="setTimeout() &amp; setInterval()"></a>setTimeout() &amp; setInterval()</h3><ul><li><p><code>setTimeout()</code>在<strong>指定的时间后</strong>执行一段代码。</p></li><li><p><code>setInterval()</code>以<strong>固定的时间间隔</strong>，重复运行一段代码。</p></li><li><p><code>requestAnimationFrame()</code>setInterval()的现代版本;在浏览器下一次重新绘制显示之前执行指定的代码块，从而允许动画在<strong>适当的帧率</strong>下运行，而不管它在什么环境中运行。</p></li></ul><p>这些函数设置的异步代码实际上在<strong>主线程</strong>上运行（在其指定的计时器过去之后）。</p><p><strong>指定的时间（或延迟）不能保证在指定的确切时间之后执行，而是最短的延迟执行时间</strong>。<strong>在主线程上的堆栈为空之前，传递给这些函数的回调将无法运行。</strong></p><p>可以通过调用<code>clearTimeout()</code>，将<code>setTimeout()</code>调用的<strong>标识符</strong>作为参数传递给它，从而在超时运行之前取消。</p><p>通过将<code>setInterval()</code>调用返回的标识符传递给<code>clearInterval()</code>函数可以清除intervals。</p><p><strong>递归setTimeout()和setInterval()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">setTimeout</span>(run, <span class="number">100</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>上述代码的两个版本之间的差异是微妙的。</p><ul><li>递归 <code>setTimeout()</code> 保证<strong>执行之间的延迟相同</strong>，例如在上述情况下为100ms。 代码将运行，然后在它再次运行之前等待100ms，因此无论代码运行多长时间，间隔都是相同的。</li><li>使用 <code>setInterval()</code> 的示例有些不同。 <strong>我们选择的间隔包括执行我们想要运行的代码所花费的时间</strong>。假设代码需要40毫秒才能运行 - 然后间隔最终只有60毫秒。</li><li>当递归使用 <code>setTimeout()</code> 时，每次迭代都可以在运行下一次迭代之前计算不同的延迟。 换句话说，第二个参数的值可以指定在再次运行代码之前等待的不同时间（以毫秒为单位）。</li></ul><p>当<strong>你的代码有可能比你分配的时间间隔，花费更长时间运行时</strong>，最好使用递归的 <code>setTimeout()</code> - 这将使执行之间的时间间隔保持不变，无论代码执行多长时间，你不会得到错误。</p><p><code>requestAnimationFrame()</code>是一种<strong>允许您以给定当前浏览器/系统的最佳帧速率重复且高效地运行函数</strong>的方法。除非您需要特定的速率帧，否则您应该尽可能使用它而不要去使用<code>setInterval()/recursive setTimeout()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// Drawing code goes here</span></span><br><span class="line">   requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><h3 id="Promise⭐"><a href="#Promise⭐" class="headerlink" title="Promise⭐"></a>Promise⭐</h3><p>本质上，Promise 是一个<strong>对象</strong>，代表<strong>操作的中间状态</strong> —— 正如它的单词含义 ‘<strong>承诺</strong>‘ ，它<strong>保证在未来可能返回某种结果</strong>。</p><p>虽然 Promise 并不保证操作在何时完成并返回结果，但是它保证当结果可用时，你的代码能正确处理结果，当结果不可用时，你的代码同样会被执行，来优雅的处理错误。</p><h4 id="与旧式回调相比"><a href="#与旧式回调相比" class="headerlink" title="与旧式回调相比"></a>与旧式回调相比</h4><p><code>Promise</code>是专门为异步操作而设计的，与旧式回调相比具有许多优点:</p><ul><li>您可以<strong>使用多个then()操作将多个异步操作链接在一起，并将其中一个操作的结果作为输入传递给下一个操作</strong>。避免<strong>回调地狱</strong>（如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差）。</li><li><code>Promise</code>总是严格按照它们放置在事件队列中的<strong>顺序调用</strong>。</li><li>错误处理要好得多——所有的错误都由块末尾的一个<code>.catch()</code>块处理，而不是在“金字塔”的每一层单独处理。</li></ul><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p><strong>创建promise时</strong>，它既不是成功也不是失败状态。这个状态叫作<strong>pending</strong>（待定）。</p><p>当<strong>promise返回</strong>时，称为 <strong>resolved</strong>（已解决）。</p><ul><li>一个成功<strong>resolved</strong>的promise称为<strong>fullfilled</strong>（<strong>实现</strong>）。它返回一个值，可以通过将<code>.then()</code>块链接到promise链的末尾来访问该值。<code>.then()</code>块中的执行程序函数将包含promise的返回值。</li><li>一个不成功<strong>resolved</strong>的promise被称为<strong>rejected</strong>（<strong>拒绝</strong>）了。它返回一个原因（<strong>reason</strong>），一条错误消息，说明为什么拒绝promise。可以通过将<code>.catch()</code>块链接到promise链的末尾来访问此原因。</li></ul><p>状态只能由 <code>Pending --&gt; Fulfilled</code> 或者 <code>Pending --&gt; Rejected</code>，且<strong>一旦发生改变不可二次修改</strong>。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123; <span class="comment">/* executor */</span></span><br><span class="line">    <span class="comment">// 执行代码 需要指明resolve与reject的回调位置</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>executor</code>是带有<code>resolve</code>和<code>reject</code>两个参数的函数。</p><p><code>Promise</code>构造函数执行时立即调用<code>executor</code>函数，<code>resolve</code>和<code>reject</code>两个函数作为参数传递给<code>executor</code>。</p><p><code>resolve</code>和<code>reject</code>函数被调用时，分别将<code>promise</code>的状态改为完成<code>fulfilled</code>或失败<code>rejected</code>。</p><p><code>executor</code>内部通常会执行一些异步操作，一旦异步操作执行完毕，要么调用<code>resolve</code>函数来将<code>promise</code>状态改成<code>fulfilled</code>，要么调用<code>reject</code>函数将<code>promise</code>的状态改为<code>rejected</code>。</p><p>如果在<code>executor</code>函数中抛出一个错误，那么该<code>promise</code>状态为<code>rejected</code>，<code>executor</code>函数的返回值被忽略。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h5 id="Promise-all-iterable"><a href="#Promise-all-iterable" class="headerlink" title="Promise.all(iterable)"></a>Promise.all(iterable)</h5><p>这个方法返回一个新的<code>promise</code>对象</p><ul><li>该<code>promise</code>对象在<code>iterable</code>参数对象里所有的<code>promise</code>对象<strong>都成功</strong>的时候才会触发成功</li><li>一旦有任何一个<code>iterable</code>里面的<code>promise</code>对象失败则立即触发该<code>promise</code>对象的失败。</li><li>这个新的<code>promise</code>对象在触发成功状态以后，会把一个包含<code>iterable</code>里所有<code>promise</code>返回值的数组作为成功回调的返回值，顺序跟<code>iterable</code>的顺序保持一致。</li><li>如果这个新的<code>promise</code>对象触发了失败状态，它会把<code>iterable</code>里第一个触发失败的<code>promise</code>对象的错误信息作为它的失败错误信息。</li><li><code>Promise.all</code>方法常被用于处理多个<code>promise</code>对象的状态集合。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&quot;success1&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&quot;success2&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);      <span class="comment">// 成功状态 //[&quot;success1&quot;, &quot;success2&quot;]</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1,p3,p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);      <span class="comment">// 失败状态 // fail</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="Promise-race-iterable"><a href="#Promise-race-iterable" class="headerlink" title="Promise.race(iterable)"></a>Promise.race(iterable)</h5><p>当<code>iterable</code>参数里的任意一个子<code>promise</code>被成功或失败后，父<code>promise</code>马上也会用子<code>promise</code>的成功返回值或失败详情作为参数调用父<code>promise</code>绑定的相应句柄，并返回该<code>promise</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">  &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// p1先获得结果，那么就执行p1的回调</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="Promise.resolve(value)"></a>Promise.resolve(value)</h5><p>返回一个状态由给定<code>value</code>决定的<code>Promise</code>对象。</p><ul><li>如果该值是<code>thenable</code>(即，带有<code>then</code>方法的对象)，返回的<code>Promise</code>对象的最终状态由<code>then</code>方法执行决定；</li><li>否则的话(该<code>value</code>为空，基本类型或者不带<code>then</code>方法的对象),返回的<code>Promise</code>对象状态为<code>fulfilled</code>，并且将该<code>value</code>传递给对应的<code>then</code>方法。</li><li>通常而言，如果你不知道一个值是否是<code>Promise</code>对象，使用<code>Promise.resolve(value)</code>来返回一个<code>Promise</code>对象,这样就能将该<code>value</code>以<code>Promise</code>对象形式使用。不要在解析为自身的<code>thenable</code>上调用<code>Promise.resolve</code>，这将导致无限递归，因为它试图展平无限嵌套的<code>promise</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该值为空或基本类型，直接返回一个fulfilled状态的Promise对象</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">promise.then(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num); <span class="comment">// 1</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve(p1);</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2); <span class="comment">// true</span></span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果该值带有then方法的对象，返回的Promise对象的最终状态由then方法执行决定</span></span><br><span class="line"><span class="keyword">var</span> thenable = &#123;<span class="attr">then</span>: <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="number">1</span>)&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 1</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="Promise-reject-reason"><a href="#Promise-reject-reason" class="headerlink" title="Promise.reject(reason)"></a>Promise.reject(reason)</h5><p>返回一个状态为失败的<code>Promise</code>对象，并将给定的失败信息传递给对应的处理方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.reject(<span class="string">&quot;err&quot;</span>);</span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// err</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h4><h5 id="Promise-prototype-then-onFulfilled-onRejected"><a href="#Promise-prototype-then-onFulfilled-onRejected" class="headerlink" title="Promise.prototype.then(onFulfilled, onRejected)"></a>Promise.prototype.then(onFulfilled, onRejected)</h5><p>添加解决<code>fulfillment</code>和拒绝<code>rejection</code>回调到当前<code>promise</code>,返回一个新的<code>promise</code>,将以回调的返回值来<code>resolve</code>。</p><h5 id="Promise-prototype-catch-onRejected"><a href="#Promise-prototype-catch-onRejected" class="headerlink" title="Promise.prototype.catch(onRejected)"></a>Promise.prototype.catch(onRejected)</h5><p>添加一个拒绝<code>rejection</code>回调到当前<code>promise</code>,返回一个新的<code>promise</code>。当这个回调函数被调用，新<code>promise</code>将以它的返回值来<code>resolve</code>，否则如果当前<code>promise</code>进入<code>fulfilled</code>状态，则以当前<code>promise</code>的完成结果作为新<code>promise</code>的完成结果。</p><h5 id="Promise-prototype-finally-onFinally"><a href="#Promise-prototype-finally-onFinally" class="headerlink" title="Promise.prototype.finally(onFinally)"></a>Promise.prototype.finally(onFinally)</h5><p>添加一个事件处理回调于当前<code>promise</code>对象，并且在原<code>promise</code>对象解析完毕后，返回一个新的<code>promise</code>对象。回调会在当前<code>promise</code>运行完毕后被调用，无论当前<code>promise</code>的状态是完成<code>fulfilled</code>还是失败<code>rejected</code>。</p><h3 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h3><p>es2017的新语法，async/await就是<code>generator</code> + <code>promise</code>的语法糖</p><p><code>async</code> 函数可以看作<strong>自带启动器</strong>的 generator 函数的语法糖，将 Generator 函数的星号（<code>*</code>）替换成 <code>async</code>，将 <code>yield</code> 替换成 <code>await</code>。</p><p>相对于 Generator 的改进主要集中集中在：</p><ul><li><strong>内置执行器</strong></li><li><strong>更好的语义化</strong></li><li><strong>Promise 的返回值</strong></li></ul><p>到这里大家会发现，Async/Await 本质也是 Promise 的语法糖：Async 函数返回了 Promise 对象。</p><p>async/await 和 Promise 的关系非常的巧妙，<strong>await必须在async内使用</strong>，<strong>并装饰一个Promise对象</strong>，<strong>async返回的也是一个Promise对象</strong>。</p><p>await 关键字使JavaScript运行时暂停于此行，允许其他代码在此期间执行，直到异步函数调用返回其结果。</p><p><code>await</code> 关键字<strong>会阻塞其后的代码</strong>，直到promise完成，就像执行同步操作一样。<strong>它确实可以允许其他任务在此期间继续运行，但您自己的代码被阻塞。</strong></p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p><strong>将 JavaScript 程序拆分为可按需导入的单独模块的机制</strong>。</p><ul><li><strong>避免命名冲突(减少命名空间污染)</strong></li><li><strong>更好的分离, 按需加载</strong></li><li><strong>更高复用性</strong></li><li><strong>高可维护性</strong></li></ul><p>早期 全局函数 对象 IIFE(闭包) 缺点：引入多个<code>&lt;script&gt;</code>，请求过多、依赖模糊、难以维护</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myModule.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//私有数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">&#x27;My atguigu&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doSomething() &#x27;</span>+msg.toUpperCase())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doOtherthing</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doOtherthing() &#x27;</span>+msg.toLowerCase())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向外暴露对象(给外部使用的方法)</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">    <span class="attr">doOtherthing</span>: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------  模块调用<span class="number">1</span> --------------------------------------------</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;myModule.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">var</span> <span class="built_in">module</span> = myModule()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="built_in">module</span>.doSomething()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="built_in">module</span>.doOtherthing()</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment">// myModule2.js   </span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//私有数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">&#x27;My atguigu&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doSomething() &#x27;</span>+msg.toUpperCase())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doOtherthing</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doOtherthing() &#x27;</span>+msg.toLowerCase())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向外暴露对象(给外部使用的方法)</span></span><br><span class="line">  <span class="built_in">window</span>.myModule2 = &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">    <span class="attr">doOtherthing</span>: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">------------  模块调用<span class="number">2</span> --------------------------------------------</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;myModule2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  myModule2.doSomething()</span></span><br><span class="line"><span class="xml">  myModule2.doOtherthing()</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>通过<strong>模块化规范</strong>解决</p><ul><li><p>CommonJS 适合<strong>服务端</strong> <strong>同步</strong>加载</p></li><li><p>AMD 异步加载 开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</p></li><li><p>CMD与AMD规范很相似 依赖就近，延迟执行，可以很容易在Node.js中运行 依赖SPM 打包，模块的加载逻辑偏重。</p></li></ul><p><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</strong>。</p><p><strong>CommonJS</strong></p><ul><li><p>CommonJS 用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用<code>exports</code>），用<code>require</code>加载模块。</p></li><li><p>CommonJS 模块输出的是<strong>一个值的拷贝</strong>，ES6 模块输出的是<strong>值的引用</strong>。</p></li><li><p>CommonJS 模块是<strong>运行时加载（对象）</strong>，ES6 模块是<strong>编译时输出接口</strong>。</p></li></ul><p><strong>ES6模块化</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;main.mjs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>export 导出：<strong>函数</strong>，<code>var</code>，<code>let</code>，<code>const</code>, 和<strong>类</strong>。</p></li><li><p><code>import</code> <code>from</code></p></li><li><p>模块自动使用<strong>严格模式</strong>和<strong>自动延迟加载</strong>。</p></li><li><p><code>export default</code> 默认导出 <strong>不用大括号</strong></p></li><li><p>在你的 <code>import</code> 和 <code>export</code> 语句的大括号中，可以使用 <code>as</code> 关键字重命名</p></li><li><p><code>import * as Module</code> 创建模块对象</p></li><li><p><code>export &#123; name &#125; from &#39;x.mjs&#39;</code> 合并模块 <strong>导入后跟导出的简写</strong></p></li><li><p>动态加载模块 将<code>import()</code>作为函数调用，将其传递给模块的路径作为参数。 它返回一个 <code>promise</code>，它用一个<strong>模块对象</strong>来实现，让你可以访问该对象的导出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;/modules/myModule.mjs&#x27;</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Do something with the module.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h1 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h1><h2 id="数组去重⭐"><a href="#数组去重⭐" class="headerlink" title="数组去重⭐"></a>数组去重⭐</h2><h3 id="最简单Set"><a href="#最简单Set" class="headerlink" title="最简单Set"></a>最简单Set</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line">    <span class="comment">// return Array.from(new Set(arr));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="indexOf-includes-for-forEach-for…of"><a href="#indexOf-includes-for-forEach-for…of" class="headerlink" title="indexOf/includes+for/forEach/for…of"></a>indexOf/includes+for/forEach/for…of</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newArr = [];</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// if(newArr.indexOf(v) === -1)  newArr.push(v);</span></span><br><span class="line">        <span class="keyword">if</span>(!newArr.includes(v)) newArr.push(v);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="filter配合indexOf"><a href="#filter配合indexOf" class="headerlink" title="filter配合indexOf"></a>filter配合indexOf</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 将原数组中每一个首次出现的元素存入新数组</span></span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">cur,index,arr</span>) =&gt;</span> arr.indexOf(c===index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reduce配合includes"><a href="#reduce配合includes" class="headerlink" title="reduce配合includes"></a>reduce配合includes</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// res最初是[],遍历每一个元素，如果不在res中就放入，最后返回res</span></span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">res,cur</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!res.includes(cur))res.push(cur);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,[])  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原数组直接去重"><a href="#原数组直接去重" class="headerlink" title="原数组直接去重"></a>原数组直接去重</h3><p><code>sort</code> 排序后，使用快慢指针的思想</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);<span class="comment">//升序排序</span></span><br><span class="line">    <span class="keyword">let</span> slow = <span class="number">1</span>,fast =<span class="number">1</span>;<span class="comment">//快慢指针起始点都是第二个</span></span><br><span class="line">    <span class="keyword">while</span>(fast&lt;arr.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[fast] !== arr[fast-<span class="number">1</span>])&#123;</span><br><span class="line">            arr[slow++] = arr[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.length = slow;<span class="comment">// 去重后数组长度,原数组多余部分会被删除</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="call、apply、bind区别⭐"><a href="#call、apply、bind区别⭐" class="headerlink" title="call、apply、bind区别⭐"></a>call、apply、bind区别⭐</h2><ul><li>三者都可以改变函数的<code>this</code>对象指向</li><li>三者第一个参数都是<code>this</code>要指向的对象，如果如果没有这个参数或参数为<code>undefined</code>或<code>null</code>，则默认指向全局<code>window</code></li><li>三者都可以传参，但是<code>apply</code>是数组，而<code>call</code>是参数列表，且<code>apply</code>和<code>call</code>是一次性传入参数，而<code>bind</code>可以分为多次传入</li><li><code>bind</code>是返回绑定this之后的函数，<code>apply</code>、<code>call</code> 则是立即执行</li></ul><h3 id="模拟实现-call"><a href="#模拟实现-call" class="headerlink" title="模拟实现 call"></a>模拟实现 call</h3><ul><li><strong>将函数设置为绑定对象的属性</strong></li><li>执行函数</li><li>删除对象的这个属性</li><li>将返回值返回</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓展Function原型，使用Rest操作符接收剩余参数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype._call = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg,...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 非严格模式下, 没有参数或为 null 和 undefined，自动指向全局对象</span></span><br><span class="line">    <span class="comment">// 值为原始值的会指向该原始值的自动包装对象(用 Object() 转换）</span></span><br><span class="line">    thisArg = thisArg ? <span class="built_in">Object</span>(thisArg) : <span class="built_in">window</span>; </span><br><span class="line">    <span class="comment">// _call由函数调用，此时的this指向函数，是一种隐式绑定</span></span><br><span class="line">    <span class="comment">// 将调用函数this设为绑定对象的属性fn</span></span><br><span class="line">    thisArg.fn = <span class="built_in">this</span>; </span><br><span class="line">    <span class="comment">// 执行该函数</span></span><br><span class="line">    <span class="keyword">const</span> res = thisArg.fn(...args); </span><br><span class="line">    <span class="comment">// 删除对象的这个属性</span></span><br><span class="line">    <span class="keyword">delete</span> thisArg.fn</span><br><span class="line">    <span class="comment">// 将返回值返回</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟实现-apply"><a href="#模拟实现-apply" class="headerlink" title="模拟实现 apply"></a>模拟实现 apply</h3><p>跟call思路类似，主要是第二个参数是一个数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._apply = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg, arr</span>) </span>&#123;</span><br><span class="line">    thisArg = thisArg ? <span class="built_in">Object</span>(thisArg) : <span class="built_in">window</span>; </span><br><span class="line">    <span class="comment">// 将函数设为对象的属性</span></span><br><span class="line">    thisArg.fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 执行该函数</span></span><br><span class="line">    <span class="keyword">const</span> res = thisArg.fn(...arr);</span><br><span class="line">    <span class="comment">// 删除该函数  </span></span><br><span class="line">    <span class="keyword">delete</span> thisArg.fn</span><br><span class="line">    <span class="comment">// 将返回值返回</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟实现bind"><a href="#模拟实现bind" class="headerlink" title="模拟实现bind"></a>模拟实现bind</h3><p>利用了闭包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._bind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args1</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 箭头函数不会生成自身作用域下的this，会从自己的作用域链的上一层继承this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args2</span>) =&gt;</span> &#123; </span><br><span class="line">        thisArg = thisArg ? <span class="built_in">Object</span>(thisArg) : <span class="built_in">window</span>;  </span><br><span class="line">        thisArg.fn = <span class="built_in">this</span>; <span class="comment">// 调用箭头函数时的this指向的是调用者也就是函数对象，将函数对象赋值给thisArg对象的一个属性</span></span><br><span class="line">        <span class="keyword">const</span> res = thisArg.fn(...args1, ...args2); <span class="comment">// 调用thisArg.fn时，fn中的this指针指向的是thisArg，并使用Spread操作符展开参数传参</span></span><br><span class="line">        <span class="keyword">delete</span> thisArg.fn; <span class="comment">// 删除thisArg对象的fn属性</span></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 将返回值返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a= <span class="number">1</span>; <span class="comment">// 定义一个全局变量</span></span><br><span class="line"><span class="keyword">const</span> obj =&#123;<span class="attr">a</span>:<span class="number">2</span>&#125;<span class="comment">// 定义一个对象用来绑定</span></span><br><span class="line"><span class="comment">// 定义一个函数用来执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">b,c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a,b,c)</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">// 直接执行，相当于window.fn(1, 2)，this绑定于window</span></span><br><span class="line">fn._call();<span class="comment">//无参this仍绑定于window</span></span><br><span class="line">fn._call(obj,<span class="number">5</span>,<span class="number">7</span>);<span class="comment">// 使用call将this绑定到obj对象</span></span><br><span class="line">fn._apply(obj,[<span class="number">7</span>,<span class="number">6</span>]);<span class="comment">// 使用apply将this绑定到obj对象</span></span><br><span class="line"><span class="keyword">const</span> func = fn._bind(obj,<span class="number">9</span>);<span class="comment">// 使用bind将this绑定到obj对象，bind方法返回一个原函数的拷贝，并拥有指定的this值和初始参数。</span></span><br><span class="line">func(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="防抖-节流⭐"><a href="#防抖-节流⭐" class="headerlink" title="防抖/节流⭐"></a>防抖/节流⭐</h2><p>作用都是为了<strong>防止函数被高频调用。</strong></p><p>当函数会进行<code>DOM</code>操作或者具有<strong>请求服务器</strong>等行为并且作为高频事件，就需要进行<strong>事件处理函数执行频率的控制</strong>，否则会造成大量的<strong>资源浪费</strong>致使<strong>性能下降</strong>，当然无论是防抖与节流实质上并没有减少事件触发次数，而是通过<strong>减少事件处理函数的执行次数</strong>从而提高性能。</p><p><strong>应用场景</strong></p><ul><li><p>防抖</p><ul><li><p>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。</p></li><li><p>window触发<code>resize</code>的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次。</p><p><code>resize</code> CSS 属性允许你控制一个元素的可调整大小性。</p></li></ul></li><li><p>节流</p><ul><li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li><li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li></ul></li></ul><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><h4 id="非立即防抖"><a href="#非立即防抖" class="headerlink" title="非立即防抖"></a>非立即防抖</h4><p>当持续触发事件的时候，事件处理函数是完全不执行的，等<strong>最后一次触发结束的一段时间之后，再去执行</strong>。</p><p>最常见的例子就是<strong>搜索</strong>建议功能，当用户进行持续输入时，并不会请求服务器进行搜索建议的计算，直至用户输入完成后的<code>N</code>毫秒后才会将数据传输至后端并返回搜索建议。<br>实现思路：<strong>每次触发事件时都取消之前的延时调用方法并重设定时器</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce1</span>(<span class="params">wait,fn,...args</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 闭包里存变量timer</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 这里不要用箭头函数，因为debounce1不是由好h1调用，而是其返回函数由h1调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 每次触发事件时都取消之前的延时调用方法并重设定时器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        <span class="comment">// 定时器使用箭头函数和外层函数this一致，但h1只是调用了外层函数，fn的this需要自行绑定</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">            fn.call(<span class="built_in">this</span>,...args)</span><br><span class="line">        &#125;,wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> h1 =<span class="built_in">document</span>.querySelector(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line"><span class="comment">// 此处如果使用箭头函数，this将永远指向window</span></span><br><span class="line"><span class="keyword">const</span> fn =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">h1.addEventListener(<span class="string">&#x27;click&#x27;</span>,debounce1(<span class="number">300</span>,fn,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h4 id="立即防抖"><a href="#立即防抖" class="headerlink" title="立即防抖"></a>立即防抖</h4><p>当持续触发事件的时候，事件处理函数会<strong>立即执行</strong>，然后不再执行事件处理函数，直至<strong>最后一次事件触发之后的一段时间后才允许再次执行事件处理函数</strong>。<br>实现思路：<strong>判断是否存在定时器，没有则执行事件处理函数，然后无论是否已经存在定时器都需要重设定时器</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce2</span>(<span class="params">wait,fn,...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(!timer)fn.call(<span class="built_in">this</span>,...args);  </span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">            timer=<span class="literal">null</span>;</span><br><span class="line">        &#125;,wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> h1 =<span class="built_in">document</span>.querySelector(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fn =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">h1.addEventListener(<span class="string">&#x27;click&#x27;</span>,debounce2(<span class="number">300</span>,fn,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>当事件持续触发时，节流操作可以稀释事件处理函数执行频率，假设在<code>1s</code>内<code>onmousemove</code>事件触发了<code>100</code>次，通过节流就可以使得<code>onmousemove</code>事件的事件处理函数每<code>100ms</code>触发一次，也就是在<code>1s</code>内<code>onmousemove</code>事件的事件处理函数只执行<code>10</code>次。</p><h4 id="时间戳实现"><a href="#时间戳实现" class="headerlink" title="时间戳实现"></a>时间戳实现</h4><p>实现思路：通过<strong>时间戳</strong>记录上次事件处理函数执行时间，事件触发时若时间差大于执行周期则执行事件处理函数并赋值执行时间为当前时间戳。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle1</span>(<span class="params">wait,fn,...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">if</span>(now - prev &gt; wait)&#123;</span><br><span class="line">            fn.call(<span class="built_in">this</span>,...args);</span><br><span class="line">            prev=now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h1 =<span class="built_in">document</span>.querySelector(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fn =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">h1.addEventListener(<span class="string">&#x27;click&#x27;</span>,throttle1(<span class="number">300</span>,fn,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h4 id="定时器实现"><a href="#定时器实现" class="headerlink" title="定时器实现"></a>定时器实现</h4><p>实现思路：判断是否存在定时器，没有则执行事件处理函数并重设定时器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle2</span>(<span class="params">wait,fn,...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">            fn.call(<span class="built_in">this</span>,...args);</span><br><span class="line">            timer=<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>timer=<span class="literal">null</span>,wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h1 =<span class="built_in">document</span>.querySelector(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fn =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">h1.addEventListener(<span class="string">&#x27;click&#x27;</span>,throttle2(<span class="number">300</span>,fn,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h2 id="new⭐"><a href="#new⭐" class="headerlink" title="new⭐"></a>new⭐</h2><p><strong>new是一个运算符</strong>，用于创建一个给定构造函数的实例对象。</p><p><strong>new</strong> 关键字会进行如下的操作：</p><ol><li>创建一个空对象并将该对象的<code>__proto__</code>指向构造函数原型<code>prototype</code>；</li><li>将步骤1新创建的对象作为<code>this</code>的上下文执行构造函数 ；</li><li><strong>优先构造函数返回的对象</strong>，否则返回<strong>新创建的对象</strong>。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1、通过call，this指向了arguments，shift删除并返回arguments中第一个参数——构造函数</span></span><br><span class="line">    Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 2、创建一个空的对象并将该对象的__proto__指向构造函数原型，obj.__proto__ 影响性能，不建议用</span></span><br><span class="line">    <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(Con.prototype);</span><br><span class="line">    <span class="comment">// let obj =&#123;&#125;;</span></span><br><span class="line">    <span class="comment">// obj.__proto__=Con.prototype;</span></span><br><span class="line">    <span class="comment">// 3、绑定 this 执行构造函数</span></span><br><span class="line">    <span class="keyword">let</span> res = Con.apply(obj,<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 4、优先返回构造函数返回的对象</span></span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? res : obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">color</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color=color</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> car = _new(Car,<span class="string">&#x27;black&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(car)</span><br></pre></td></tr></table></figure><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><p>**<code>Object.create()</code>**方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</p><table><thead><tr><th>比较</th><th>new</th><th>Object.create</th></tr></thead><tbody><tr><td>构造函数</td><td>保留原构造函数属性</td><td>丢失原构造函数属性</td></tr><tr><td>原型链</td><td>原构造函数prototype属性</td><td>原构造函数/（对象）本身</td></tr><tr><td>作用对象</td><td>function</td><td>function和object</td></tr></tbody></table><p>利用一个<strong>空对象</strong>作为中介，将<strong>某个对象直接赋值给空对象构造函数的原型</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype=obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">    <span class="comment">// let o=&#123;&#125;;</span></span><br><span class="line">    <span class="comment">// o.__proto__=obj;</span></span><br><span class="line">    <span class="comment">// return o;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a=&#123;<span class="attr">b</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> c=create(a);</span><br><span class="line"><span class="built_in">console</span>.log(c.b)</span><br></pre></td></tr></table></figure><p>object()对传入其中的对象执行了一次<code>浅复制</code>，<strong>将构造函数F的原型直接指向传入的对象</strong>。</p><h2 id="instanceof⭐"><a href="#instanceof⭐" class="headerlink" title="instanceof⭐"></a>instanceof⭐</h2><ol><li><strong><code>instanceof</code></strong> <strong>是一个运算符</strong></li><li><code>instanceof</code> 判断<strong>对象的原型链上是否存在构造函数的原型</strong>。只能判断引用类型。</li><li><code>instanceof</code> 常用来判断 <code>A</code> 是否为 <code>B</code> 的实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance_of</span>(<span class="params">Case,Con</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 基本数据类型返回false，兼容一下函数</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">typeof</span> Case !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> Case !== <span class="string">&#x27;function&#x27;</span>) || Case ===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> CaseProto = <span class="built_in">Object</span>.getPrototypeOf(Case);<span class="comment">//返回指定对象的原型</span></span><br><span class="line">    <span class="comment">// let CaseProto = Case.__proto__;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(CaseProto === <span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 查到原型链顶端，仍未查到，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(CaseProto === Con.prototype)<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到相同的原型</span></span><br><span class="line">        CaseProto=<span class="built_in">Object</span>.getPrototypeOf(CaseProto);</span><br><span class="line">        <span class="comment">// CaseProto = CaseProto.__proto__;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a=&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(instance_of(<span class="built_in">Object</span>,<span class="built_in">Function</span>));<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance_of(<span class="built_in">Function</span>,<span class="built_in">Object</span>));<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance_of(a,<span class="built_in">Object</span>));<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance_of(<span class="literal">null</span>,<span class="built_in">Object</span>));<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如何获取到一个实例对象的原型对象？</p><ul><li>从 <code>构造函数</code> 获得原型对象：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造函数.prototype</span><br></pre></td></tr></table></figure><ul><li>从 <code>对象实例</code> 获得 <code>父级原型对象</code>：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法一：对象实例.__proto__        【 有兼容性问题，不建议使用】</span><br><span class="line">方法二：<span class="built_in">Object</span>.getPrototypeOf( 对象实例 )</span><br></pre></td></tr></table></figure><h2 id="Ajax⭐"><a href="#Ajax⭐" class="headerlink" title="Ajax⭐"></a>Ajax⭐</h2><p>一种异步请求数据的web开发技术，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。</p><h3 id="原生Ajax"><a href="#原生Ajax" class="headerlink" title="原生Ajax"></a>原生Ajax</h3><blockquote><p>XMLHttpRequest（XHR）对象用于与服务器交互。</p></blockquote><ul><li><p>创建<code>XMLHttpRequest</code> 对象。<code>const xhr = new XMLHttpRequest()</code></p></li><li><p>使用<code>open</code>方法设置请求的参数。<code>xhr.open(method, url, 是否异步)</code>。</p><ul><li><p><code>get</code>可以把请求参数拼接在<code>url</code></p></li><li><p>默认异步</p></li><li><p>如果想要使用<code>post</code>提交数据,必须添加此行。</p><p><code>xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</code></p></li></ul></li><li><p>注册<code>onreadystatechange</code>事件，<strong>状态改变时就会调用</strong>。</p><ul><li><code>xhr.readyState===4</code> 请求已完成，且响应已就绪。存有 <code>XMLHttpRequest</code> 的状态。从 0 到 4 发生变化。</li><li><code>(xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300) || xhr.status === 304</code> 304：服务器端资源未改变，可直接使用客户端未过期的缓存。</li></ul></li><li><p>发送请求。</p><ul><li><code>get</code>请求：<code>xhr.send()</code></li><li><code>post</code>请求：将数据通过<code>send</code>方法传递 <code>xhr.send(&#39;name=fox&amp;age=18&#39;);</code></li></ul></li><li><p>获取返回的数据，更新UI。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ajax = <span class="function">(<span class="params">method=<span class="string">&#x27;GET&#x27;</span>,url,data=&#123;&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(method,url);</span><br><span class="line">        <span class="keyword">if</span> (method.toUpperCase() === <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">            xhr.setRequestHeader(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onreadystatechange = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((xhr.status&gt;=<span class="number">200</span> &amp;&amp; xhr.status&lt;<span class="number">300</span>) || xhr.status === <span class="number">304</span>)&#123;</span><br><span class="line">                    resolve(xhr.response);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    reject(xhr.status);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">ajax(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;https://devapi.qweather.com/v7/weather/now?location=101010100&amp;key=d6d54c0f8bb54160b97507ce068abda8&#x27;</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(res).now.text);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p>fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。</p><h3 id="Promise封装axios"><a href="#Promise封装axios" class="headerlink" title="Promise封装axios"></a>Promise封装axios</h3><p>axios是一个基于<code>promise</code>的<code>HTTP</code>库，可以用在<code>浏览器</code>或者<code>node.js</code>中。</p><p>axios是通过promise实现对ajax技术的一种封装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; message &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url,data=&#123;&#125;,type=<span class="string">&#x27;GET&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> promise;</span><br><span class="line">        <span class="comment">// 执行异步ajax请求</span></span><br><span class="line">        <span class="keyword">if</span>(type===<span class="string">&#x27;GET&#x27;</span>)&#123;<span class="comment">//发GET请求</span></span><br><span class="line">            promise=axios.get(url,&#123;</span><br><span class="line">                <span class="attr">params</span>:data</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//发POST请求</span></span><br><span class="line">            promise=axios.post(url,data)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果请求成功了，调用resolve(value)</span></span><br><span class="line">        <span class="comment">// 该方法返回一个以response.data值解析后的Promise对象</span></span><br><span class="line">        promise.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(response.data)</span><br><span class="line">            <span class="comment">// console.log(response.data)</span></span><br><span class="line">        <span class="comment">// 如果请求失败了，不调用reject(reason)，而是提示异常信息（统一处理异常）   </span></span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            message.error(<span class="string">&#x27;请求出错了：&#x27;</span>+error.message)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深拷贝⭐"><a href="#深拷贝⭐" class="headerlink" title="深拷贝⭐"></a>深拷贝⭐</h2><p><strong>递归</strong>的思路去实现一个深拷贝方法。WeakMap解决<strong>循环引用</strong>。</p><p>假设我们使用的 Map，那么 <code>foo</code> 对象和我们深拷贝内部的 <code>const map = new Map()</code> 创建的 <code>map</code> 对象一直都是强引用关系，那么在程序结束之前，<code>foo</code> 不会被回收，其占用的内存空间一直不会被释放。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝简易版本</span></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function"><span class="params">source</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> weakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();<span class="comment">// 创建一个 WeakMap 对象，记录已拷贝过的对象</span></span><br><span class="line">    <span class="keyword">const</span> isArray = <span class="function"><span class="params">arr</span> =&gt;</span> toString.call(arr) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">    <span class="comment">// const isObject = obj =&gt; toString.call(obj) === &#x27;[object Object]&#x27;;</span></span><br><span class="line">    <span class="keyword">const</span> isObject = <span class="function"><span class="params">obj</span> =&gt;</span> obj !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> ;<span class="comment">// 判断是否为object(不包括array、function等)</span></span><br><span class="line">    <span class="keyword">const</span> copy = <span class="function"><span class="params">input</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isObject(input))<span class="keyword">return</span> input;<span class="comment">// 当输入为函数或基本数据类型时，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(weakmap.has(input)) <span class="keyword">return</span> weakmap.get(input);<span class="comment">// 针对已拷贝过的对象，直接返回</span></span><br><span class="line">        <span class="keyword">const</span> output = isArray(input) ? [] : &#123;&#125;;<span class="comment">// 判断是数组还是对象</span></span><br><span class="line">        weakmap.set(input,output); <span class="comment">// 记录每次拷贝的对象(需要放在递归引用的前面)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> input)&#123;<span class="comment">// 如果k是对象的自有属性,递归调用深拷贝方法</span></span><br><span class="line">            <span class="keyword">if</span>(input.hasOwnProperty(k)) output[k]=copy(input[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj.b = obj;</span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, obj,[<span class="number">1</span>,<span class="number">2</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="keyword">let</span> newArr1 = deepClone(arr1);</span><br><span class="line">newArr1[<span class="number">2</span>].a = <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newArr1);</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义三个常量表示状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = PENDING;</span><br><span class="line">        <span class="built_in">this</span>.result = <span class="literal">null</span>;<span class="comment">// 成功之后的值</span></span><br><span class="line">        <span class="built_in">this</span>.reason = <span class="literal">null</span>; <span class="comment">// 失败之后的原因</span></span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallbacks = []; <span class="comment">// 成功回调函数的队列</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks = [];<span class="comment">// 失败回调函数的队列</span></span><br><span class="line">        <span class="comment">// 普通函数内部this指向的是undefined，用箭头函数指向当前实例对象</span></span><br><span class="line">        <span class="comment">// 更改成功后的状态</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123; <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">                <span class="built_in">this</span>.status = FULFILLED;</span><br><span class="line">                <span class="built_in">this</span>.result = result;</span><br><span class="line">                queueMicrotask(<span class="function">() =&gt;</span> &#123;<span class="comment">// resolve里面将所有成功的回调拿出来执行</span></span><br><span class="line">                    <span class="built_in">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                        callback(result)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更改失败后的状态</span></span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = REJECTED;</span><br><span class="line">                <span class="built_in">this</span>.reason = reason;</span><br><span class="line">                queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                        callback(reason)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// executor 是一个执行器，进入会立即执行</span></span><br><span class="line">        <span class="comment">// 并传入resolve和reject方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)<span class="comment">// 如果有错误，就直接执行reject</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// then 原型方法</span></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否为函数，不是的话使用默认函数</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function">() =&gt;</span> &#123; &#125;;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function">() =&gt;</span> &#123; &#125;;</span><br><span class="line">        <span class="comment">// 为了链式调用return一个promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">                <span class="comment">// 创建一个微任务等待 promise 完成初始化</span></span><br><span class="line">                queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.result); <span class="comment">//获取成功回调函数的执行结果</span></span><br><span class="line">                    resolvePromise(result, resolve, reject); <span class="comment">// 传入resolvePromise集中处理</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">                queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                    resolvePromise(result, resolve, reject);</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">                <span class="built_in">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 封装一个函数统一处理回调函数的执行结果 </span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">result, resolve, reject</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 判断result是不是 MyPromise 实例对象</span></span><br><span class="line">                <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                    result.then(resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resolve(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// catch 原型方法 其实就是执行一下then的第二个回调</span></span><br><span class="line">    <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// resolve 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果这个值是一个promise ，那么将返回这个promise </span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;<span class="comment">// 否则返回的promise将以此值完成。</span></span><br><span class="line">            resolve(result);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reject 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//all 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;<span class="comment">//记录resolve次数</span></span><br><span class="line">        <span class="keyword">let</span> result = [];<span class="comment">// resolve回调的结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 用于处理传入值不为Promise的情况</span></span><br><span class="line">                MyPromise.resolve(p).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                    result[i] = val;</span><br><span class="line">                    <span class="comment">//所有then执行后, resolve结果,结果为一个数组</span></span><br><span class="line">                    <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">                        resolve(result); </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="comment">//有一个Promise被reject时，MyPromise的状态变为reject</span></span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// race 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">                MyPromise.resolve(p).then(resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     resolve(&quot;a&quot;);</span></span><br><span class="line">    <span class="comment">//     reject(&#x27;b&#x27;)</span></span><br><span class="line">    <span class="comment">//     console.log(4)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    reject(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">    <span class="comment">// throw new Error(&#x27;a&#x27;)</span></span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;other&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// console.log(3)</span></span><br><span class="line"><span class="keyword">var</span> p11 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p12 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">MyPromise.race([p11, p12]).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// all</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;success1&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;success2&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">MyPromise.all([p1, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);      <span class="comment">// 成功状态 //[&quot;success1&quot;, &quot;success2&quot;]</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">MyPromise.all([p1, p3, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);      <span class="comment">// 失败状态 // fail</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="继承⭐"><a href="#继承⭐" class="headerlink" title="继承⭐"></a>继承⭐</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>通过将<strong>子类的原型对象指向父类的实例</strong>，实现继承访问父类属性方法等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line">SubType.prototype.constructor = SubType; <span class="comment">// 修复constructor使符合原型链规定</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>原型链方案存在的缺点：</p><ul><li>由于所有SubType实例原型都指向同一个SuperType实例, 因此<strong>对某个SubType实例的来自父类的引用类型变量修改会影响所有的SubType实例</strong>。</li><li>在创建子类实例时无法向父类构造传参, 即没有实现super()的功能。</li></ul><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>构造函数继承，即在<strong>子类的构造函数中执行父类的构造函数，并为其绑定子类的this</strong>，让父类的构造函数把成员属性和方法都挂到子类的this上去，这样既<strong>能避免实例之间共享一个原型实例，又能向父类构造方法传参</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color=[<span class="string">&quot;red&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;blue&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承自SuperType</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.color.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">alert(instance1.color);<span class="comment">//&quot;red,green,blue,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.color);<span class="comment">//&quot;red,green,blue&quot;</span></span><br></pre></td></tr></table></figure><p>核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用<code>SuperType</code>构造函数，于是<code>SubType</code>的每个实例都会将<code>SuperType</code>中的属性复制一份。</p><p>缺点：</p><ul><li>只能继承父类的<strong>实例</strong>属性和方法，不能继承<strong>原型</strong>属性/方法</li><li>无法实现复用，每个子类实际上是调用父类来生成的实例</li></ul><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合上述两种方法就是组合继承。用原型链实现对<strong>原型</strong>属性和方法的继承，用借用构造函数技术来实现<strong>实例</strong>属性的继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="comment">// 第二次调用SuperType()</span></span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="comment">// 构建原型链</span></span><br><span class="line"><span class="comment">// 第一次调用SuperType()</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line"><span class="comment">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span></span><br><span class="line">SubType.prototype.constructor = SubType; </span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line">instance1.sayName(); <span class="comment">//&quot;Nicholas&quot;;</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//&quot;red,blue,green&quot;</span></span><br><span class="line">instance2.sayName(); <span class="comment">//&quot;Greg&quot;;</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性<code>name</code>，<code>color</code>。</li><li>第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性<code>name</code>，<code>color</code>。</li></ul><p>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象<code>SubType.prototype</code>的两个同名属性。所以，组合模式的缺点就是在<strong>使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</strong></p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p><strong>解决构造函数被执行两次</strong>的问题, 我们将<strong>指向父类实例改为指向父类原型</strong>, 减去一次构造函数的执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(superType.prototype); <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">  prototype.constructor = subType;                    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">  subType.prototype = prototype;                      <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类初始化实例属性和原型属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将子类的原型对象指向父类原型</span></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类原型属性</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;xyc&quot;</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;lxy&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">instance1.colors.push(<span class="string">&quot;2&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]</span></span><br><span class="line">instance1.colors.push(<span class="string">&quot;3&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;]</span></span><br></pre></td></tr></table></figure><p>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code> 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code> 和<code>isPrototypeOf()</code></p><p><strong>这是最成熟的方法，也是现在库实现的方法</strong>。</p><h3 id="ES6类继承extends"><a href="#ES6类继承extends" class="headerlink" title="ES6类继承extends"></a>ES6类继承extends</h3><p><code>extends</code>关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中<code>constructor</code>表示构造函数，一个类中只能有一个构造函数，有多个会报出<code>SyntaxError</code>错误,如果没有显式指定构造方法，则会添加默认的 <code>constructor</code>方法，使用例子如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getter</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.calcArea()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Method</span></span><br><span class="line">    <span class="function"><span class="title">calcArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rectangle.area);</span><br><span class="line"><span class="comment">// 输出 200</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(length, length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Square&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> Square(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(square.area);</span><br><span class="line"><span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure><h2 id="拷贝数组"><a href="#拷贝数组" class="headerlink" title="拷贝数组"></a>拷贝数组</h2><p>浅拷贝（只能拷贝一层对象（数组）。）</p><ul><li><strong>concat()</strong> <code>let newArr = arr.concat();</code></li><li><strong>slice()</strong> <code>let newArr = arr.slice();</code></li><li><strong>…展开运算符</strong> <code>let newArr = [...arr];</code></li><li><strong>Array.from</strong> <code>let newArr3 = Array.from(arr);</code></li></ul><h2 id="如何实现数组扁平化"><a href="#如何实现数组扁平化" class="headerlink" title="如何实现数组扁平化"></a>如何实现数组扁平化</h2><p>数组扁平化就是把多维数组转化成一维数组。</p><h3 id="ES6提供的新方法-flat-depth"><a href="#ES6提供的新方法-flat-depth" class="headerlink" title="ES6提供的新方法 flat(depth)"></a>ES6提供的新方法 flat(depth)</h3><p>不会改变原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,[<span class="number">5</span>]]]];  </span><br><span class="line">a.flat(<span class="number">4</span>-<span class="number">1</span>); <span class="comment">// [1,2,3,4,5]  a是4维数组</span></span><br><span class="line">a.flat(<span class="literal">Infinity</span>); <span class="comment">// [1,2,3,4,5]  a是4维数组</span></span><br></pre></td></tr></table></figure><h3 id="reduce方法-递归"><a href="#reduce方法-递归" class="headerlink" title="reduce方法 递归"></a>reduce方法 递归</h3><p>这里使用的是数组的reduce方法，需要注意的是reduce方法，我们传递了两个参数，<br>第一个参数就是就是处理扁平化的箭头函数<br>第二个参数是一个空数组，也是作为遍历的开始。（res）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flatten = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">res,next</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res.concat(<span class="built_in">Array</span>.isArray(next)?flatten(next):next);</span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平铺数组转树形结构"><a href="#平铺数组转树形结构" class="headerlink" title="平铺数组转树形结构"></a>平铺数组转树形结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">	&#123; <span class="attr">id</span>: <span class="string">&#x27;001&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;节点1&#x27;</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">id</span>: <span class="string">&#x27;0011&#x27;</span>, <span class="attr">parentId</span>: <span class="string">&#x27;001&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;节点1-1&#x27;</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">id</span>: <span class="string">&#x27;00111&#x27;</span>, <span class="attr">parentId</span>: <span class="string">&#x27;0011&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;节点1-1-1&#x27;</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">id</span>: <span class="string">&#x27;002&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;节点2&#x27;</span> &#125;,</span><br><span class="line">  ]</span><br><span class="line"><span class="keyword">const</span> generateTree = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">		item.chidren = arr.filter(<span class="function"><span class="params">item1</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> item.id === item1.parentId</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span> item.parentId === <span class="literal">undefined</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(generateTree(arr))</span><br></pre></td></tr></table></figure><h2 id="随机打乱数组shuffle"><a href="#随机打乱数组shuffle" class="headerlink" title="随机打乱数组shuffle"></a>随机打乱数组shuffle</h2><p>Fisher–Yates shuffle 洗牌算法可以做到理论上的完全乱序</p><p>lodash.js 中的 shuffle 函数也使用此算法实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shuffle = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> point =arr.length-<span class="number">1</span>;point&gt;=<span class="number">0</span>;point--)&#123;</span><br><span class="line">        <span class="comment">// Math.random() [0,1)</span></span><br><span class="line">        index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*point);</span><br><span class="line">        [arr[index],arr[point]]=[arr[point],arr[index]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算机网络和浏览器"><a href="#计算机网络和浏览器" class="headerlink" title="计算机网络和浏览器"></a>计算机网络和浏览器</h1><h2 id="从URL输入到页面展现到底发生什么？⭐"><a href="#从URL输入到页面展现到底发生什么？⭐" class="headerlink" title="从URL输入到页面展现到底发生什么？⭐"></a>从URL输入到页面展现到底发生什么？⭐</h2><p>总体来说分为以下几个过程:</p><ul><li><strong>解析URL并生成HTTP请求报文</strong></li><li><strong>DNS 解析</strong>：将<strong>域名</strong>解析成<strong>IP地址</strong></li><li><strong>TCP 三次握手</strong>建立连接、<strong>TLS三次握手</strong> =》在<strong>HTTPS</strong>上建立安全连接</li><li>将HTTP报文添加TCP头部（源、目标端口、序号、窗口大小和状态位）生成<strong>TCP报文</strong></li><li>添加<strong>IP包头</strong>（源、目标IP）和<strong>MAC包头</strong>（收发MAC地址）将数据封装成<strong>网络包</strong></li><li><strong>网卡驱动</strong>从IP模块获取到包之后，再次封装。</li><li><strong>网卡</strong>会将包转为<strong>电信号</strong>（光纤传输的话可能还有电光转换）。</li><li>网络包经过<strong>交换机</strong>和<strong>路由器</strong>转发到达<strong>服务器</strong></li><li>服务器将<strong>MAC、IP、TCP、HTTP头部一层层解析处理</strong>，<strong>将网页放入HTTP响应报文中</strong>，<strong>穿上TCP、IP、MAC头部返回</strong></li><li>浏览器拿到HTTP响应报文后，将<strong>HTML和CSS解析出DOM 树和 CSS 规则树</strong>（<strong>CSSOM</strong>），两者生成<strong>渲染树</strong>进行<strong>页面绘制</strong></li><li>断开TCP连接 ：<strong>TCP四次挥手</strong></li></ul><h3 id="URL是什么？"><a href="#URL是什么？" class="headerlink" title="URL是什么？"></a>URL是什么？</h3><p>统一资源定位符，URI是统一资源标志符</p><p><strong>URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</strong></p><p>URL遵守以下的语法规则：<code>scheme://host.domain:port/path/filename</code></p><ul><li><strong>scheme</strong> - 定义因特网服务的类型。常见的协议有 <strong>http、https、ftp、file</strong>，其中最常见的类型是 http，而 <strong>https 则是进行加密的网络传输</strong>。</li><li><strong>host</strong> - 定义域主机（http 的默认主机是 <strong>www</strong>）</li><li><strong>domain</strong> - 定义因特网<strong>域名</strong>，比如 <code>w3school.com.cn</code></li><li><strong>port</strong> - 定义主机上的<strong>端口号</strong>（http 的默认端口号是 80）</li><li><strong>path</strong> - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</li><li><strong>filename</strong> - 定义文档/资源的名称</li></ul><p>当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是<code>/index.html</code>或者<code>/default.html</code>这些文件，这样就不会发生混乱了。</p><h3 id="域名解析（DNS）"><a href="#域名解析（DNS）" class="headerlink" title="域名解析（DNS）"></a>域名解析（DNS）</h3><p>委托操作系统将消息发送给Web服务器，<strong>需要查询服务器域名对应的IP地址。</strong></p><p>DNS服务器就<strong>专门保存了Web服务器域名与IP的对应关系</strong>。</p><p><strong>查询过程</strong></p><ul><li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li><li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器<strong>缓存</strong>中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li><li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li><li>本地DNS服务器向<strong>顶级域名服务器（.com）</strong>发送请求，返回相关的下一级的权威域名服务器的地址</li><li>本地DNS服务器向**权威域名服务器(.baidu.com)**发送请求，域名服务器返回对应的结果(<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>)</li><li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li><li>本地DNS服务器将返回结果返回给浏览器</li></ul><p>DNS解析是一个包含<strong>迭代</strong>查询和<strong>递归</strong>查询的过程。</p><ul><li>一般<strong>我们向本地 DNS 服务器</strong>发送请求的方式就是<strong>递归查询</strong>，因为我们只需要发出<strong>一次请求</strong>，然后<strong>本地 DNS 服务器返回给我们最终的请求结果</strong>。</li><li>而<strong>本地 DNS 服务器向其他域名服务器</strong>请求的过程是<strong>迭代查询</strong>的过程，因为<strong>每一次域名服务器只返回单次查询的结果，下一级的查询由本地 DNS 服务器自己进行</strong>。</li></ul><p><strong>DNS负载均衡</strong></p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>TCP连接的建立，通常称为三次握手。</p><p>这个所谓的「连接」，只是双方计算机里<strong>维护一个状态机</strong>。</p><p><strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小，称为连接。</strong></p><ul><li><strong>Socket</strong>:由<strong>IP地址</strong>和<strong>端口号</strong>组成</li><li><strong>序列号</strong>:用来解决乱序问题等</li><li><strong>窗口大小</strong>:用来做流量控制</li></ul><p><strong>三次握手</strong></p><ul><li>一开始，客户端和服务端都处于关闭状态。先是服务端<strong>主动监听某个端口</strong>。</li><li>客户端把第一个发送报文（包含<strong>客户端序列号</strong>（client_isn ），<code>SYN</code> 标志位置为<code>1</code>）发送给服务端，表示向服务端发起连接，该报文不包含应用层数据。</li><li>服务端收到客户端的<code>SYN</code>报文后，发送应答报文（包含<strong>服务端序列号</strong>（server_isn）、<strong>确认序列</strong>（client_isn +1）、<code>SYN</code>和<code>ACK</code>置1）给客户端，该报文也不包含应用层数据。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文（<strong>确认序列</strong>（server_isn +1），<code>ACK</code>置1），这次报文<strong>可以携带客户到服务器的数据</strong>，之后客户端处于建立连接状态。</li><li>服务器收到客户端的应答报文后，也进入建立连接状态。</li></ul><p><strong>为什么三次？</strong></p><p><strong>因为三次握手才能保证双方具有接收和发送的能力</strong>。</p><p><strong>序列号能够保证数据包不重复、不丢弃和按序传输。</strong></p><p><strong>通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。</strong></p><p>不使用<strong>两次握手</strong>和<strong>四次握手</strong>的原因:</p><ul><li>两次握手︰<strong>无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号</strong>;</li><li>四次握手︰三次握手就已经<strong>理论上最少可靠连接建立</strong>，所以不需要使用更多的通信次数。</li></ul><h3 id="断开TCP连接-四次挥手"><a href="#断开TCP连接-四次挥手" class="headerlink" title="断开TCP连接 四次挥手"></a>断开TCP连接 四次挥手</h3><p><strong>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</strong></p><ul><li>客户端打算关闭连接，此时会发送<code>FIN</code>报文（<code>FIN</code>置1），之后客户端进入<code>FIN_WAIT_1</code>状态。</li><li>服务端收到该报文后，就向客户端发送<code>ACK</code>应答报文，接着服务端进入<code>CLOSED_WAIT</code>状态；客户端收到服务端的<code>ACK</code>应答报文后，之后进入<code>FIN_WAIT_2</code>状态。</li><li>等待<strong>服务端处理完数据后</strong>，也向客户端发送<code>FIN</code> 报文，之后服务端进入<code>LAST_ACK</code>状态。</li><li>客户端收到服务端的<code>FIN</code> 报文后，回一个<code>ACK</code>应答报文，之后进入<code>TIME_WAIT</code>状态。</li><li>服务器收到了<code>ACK</code>应答报文后，就完成连接的关闭。</li><li>客户端在经过<code>2MSL</code>一段时间后，自动进入关闭状态。</li></ul><p><strong>主动关闭连接的，才有TIME_WAIT状态</strong>。</p><p><strong>为什么挥手需要四次</strong>?</p><p>再来回顾下四次挥手双方发FIN 包的过程，就能理解为什么需要四次了。</p><ul><li>关闭连接时，客户端向服务端发送<code>FIN</code> 时，仅仅表示<strong>客户端不再发送数据了但是还能接收数据</strong>。</li><li>服务器收到客户端的<code>FIN</code>报文时，先回一个<code>ACK</code>应答报文，而服务端可能还有数据需要处理和发送，等<br>服务端不再发送数据时，才发送<code>FIN</code>报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，<strong>服务端通常需要等待完成数据的发送和处理</strong>，所以服务端的<code>ACK</code>和 <code>FIN</code>一般都会分开发送，从而比三次握手导致多了一次。</p><p><code>MSL</code>是<code>Maximum Segment Lifetime</code>，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><p>经过<code>2MSL</code>这个时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><p><code>TIME-WAIT</code>更重要的作用是<strong>等待足够的时间以确保最后的ACK能让被动关闭方接收，从而帮助其正常关闭</strong>。</p><h2 id="HTTP⭐"><a href="#HTTP⭐" class="headerlink" title="HTTP⭐"></a>HTTP⭐</h2><p>HTTP：<strong>超文本传输协议</strong>。</p><p><strong>HTTP是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><p><strong>请求报文包括：</strong></p><ul><li><strong>请求行</strong>：包括<strong>请求方法</strong>、<strong>请求的URL</strong>、<strong>HTTP协议及版本</strong>。</li><li><strong>请求头</strong>：一大堆的键值对。</li><li><strong>空行</strong>指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。</li><li><strong>请求体</strong>：数据部分。</li></ul><p>响应报文包括：</p><ul><li><strong>状态行</strong>：<strong>HTTP协议及版本</strong>、<strong>状态码</strong>及<strong>状态描述</strong>。</li><li><strong>响应头</strong></li><li><strong>空行</strong></li><li><strong>响应体</strong></li></ul><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p><strong>1xx</strong>类状态码属于<strong>提示信息</strong>，是协议处理中的一种<strong>中间状态</strong>，实际用到的比较少。</p><p><strong>2xx</strong>类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li><strong>200 OK</strong> 是最常见的成功状态码，表示一切正常。</li></ul><p><strong>3xx</strong>类状态码表示客户端请求的资源发送了变动，需要客户端用新的URL重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li><p><strong>301 Moved Permanently</strong> 表示<strong>永久重定向</strong>，说明请求的资源已经不存在了，需改用新的URL再次访问。</p></li><li><p><strong>302 Found</strong> 表示<strong>临时重定向</strong>，说明请求的资源还在，但暂时需要用另一个URL来访问。</p><ul><li><strong>301</strong>和<strong>302</strong>都会在响应头里使用字段<strong>Location</strong>，指明后续要跳转的URL，浏览器会自动重定向新的URL。</li></ul></li><li><p><strong>304 Not Modified</strong> 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称<strong>缓存重定向</strong>，用于缓存控制。</p></li></ul><p><strong>4xx</strong>类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是<strong>错误码</strong>的含义。</p><ul><li><strong>400 Bad Request</strong> 表示客户端请求的报文有错误，但只是个笼统的错误</li><li><strong>403 Forbidden</strong> 表示<strong>服务器禁止访问资源</strong>，并不是客户端的请求出错。</li><li><strong>404 Not Found</strong> 表<strong>示请求的资源在服务器上不存在或未找到</strong>，所以无法提供给客户端。</li></ul><p><strong>5xx</strong>类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于<strong>服务器端的错误码</strong>。</p><p>项目静态网页状态码 <code>404 &amp; 405</code></p><p><strong>405 Method Not Allowed</strong>表明服务器禁止了使用当前 HTTP 方法的请求。绝大多数web服务器，都不允许静态文件响应POST请求。</p><h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><p><strong>根据场景合理使用各个方法，可以起到优化性能、增加网络安全的效果。</strong></p><h4 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h4><p><code>GET</code>方法的含义是<strong>请求从服务器获取资源</strong>，这个资源可以是静态的文本、页面、图片视频等。</p><p>而<code>POST</code>方法则是相反操作，它向<code>URI</code>指定的资源提交数据，数据就放在报文的<code>body</code>里。</p><h5 id="参数传递方式"><a href="#参数传递方式" class="headerlink" title="参数传递方式"></a>参数传递方式</h5><ul><li>GET 的参数一般是通过 <code>?</code> 跟在 URL 后面的，多个参数通过 <code>&amp;</code> 连接</li><li>POST 的参数一般是包含在请求体中。</li></ul><h5 id="参数长度限制不同"><a href="#参数长度限制不同" class="headerlink" title="参数长度限制不同"></a>参数长度限制不同</h5><p>GET 和 POST 传递参数的长度不同：</p><ul><li>get传送的数据量较小，不能大于2KB。</li><li>post传送的数据量较大，一般被默认为不受限制。</li></ul><p>在这里我们要明确一点：<strong>HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。</strong></p><p>服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。</p><h5 id="安全和幂等"><a href="#安全和幂等" class="headerlink" title="安全和幂等"></a>安全和幂等</h5><ul><li>在HTTP 协议里，<strong>所谓的「安全」是指请求方法不会「破坏」服务器上的资源</strong>。</li><li><strong>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</strong></li></ul><p>那么很明显<strong>GET方法就是安全且幂等</strong>的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</p><p><strong>POST</strong>因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等的</strong>。</p><h5 id="安全性不同（传输的角度）"><a href="#安全性不同（传输的角度）" class="headerlink" title="安全性不同（传输的角度）"></a>安全性不同（传输的角度）</h5><p>因为参数传递方式的不同，所以 GET 和 POST 的安全性不同：GET 比 POST 更不安全，因为参数直接暴露在URL上，所以 GET 不能用来传递敏感信息。</p><blockquote><p>从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上抓包，就能完整地获取数据报文，要想安全传输，就只有加密，也就是 HTTPS。</p></blockquote><h5 id="缓存机制不同"><a href="#缓存机制不同" class="headerlink" title="缓存机制不同"></a>缓存机制不同</h5><p>这个需要从以下几点来说明：</p><ul><li>GET 请求会<strong>被浏览器主动cache</strong>，而 POST 不会，除非手动设置。</li><li>GET 请求参数<strong>会被完整保留在浏览器历史记录里</strong>，而 POST 中的参数不会被保留。</li><li>GET 在<strong>浏览器回退时是无害的</strong>，而 POST 会再次提交请求。</li></ul><h5 id="时间消耗不同"><a href="#时间消耗不同" class="headerlink" title="时间消耗不同"></a>时间消耗不同</h5><p>GET 和 POST 请求时间的不同主要是因为：</p><ul><li>GET 产生<strong>一个</strong> TCP 数据包；</li><li>POST 产生<strong>两个</strong> TCP 数据包。</li></ul><p>对于 GET 方式的请求，浏览器会把 <strong>header 和 data</strong> 一并发送出去，服务器响应 200（返回数据）；而对于 POST，浏览器先发送 <strong>header</strong>，服务器响应 <strong>100 continue</strong>，浏览器再发送 <strong>data</strong>，服务器响应 200 ok（返回数据）。</p><p>在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，<strong>两次包的TCP在验证数据包完整性上，有非常大的优点</strong>。</p><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将不传回资源的本文部分，只返回<strong>头部消息</strong>。</p><p>HEAD 方法的使用场景</p><ul><li>在不获取资源的情况下，了解资源的一些信息，比如资源类型；</li><li>通过查看响应中的状态码，可以确定资源是否存在；</li><li>通过查看首部，测试资源是否被修改。</li></ul><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>PUT 方法用于将数据发送到服务器来创建/更新资源。</p><p>PUT 与 POST 方法的区别在于，<strong>PUT 方法是幂等的</strong>：<strong>调用一次与连续调用多次是等价的（即没有副作用）</strong>。</p><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>DELETE 方法就是请求服务器删除指定 URL 所对应的资源。</p><h3 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h3><p><strong>简单<code>header（key-value） + body</code>、灵活和易于扩展（应用层(OSI第七层)，下层可随意变化）、应用广泛和跨平台</strong>。</p><p><strong>无状态</strong></p><ul><li><strong>不需要额外的资源来记录状态信息</strong></li><li>完成<strong>有关联性的操作</strong>时会非常麻烦</li></ul><p><strong>明文传输</strong></p><ul><li><strong>调试</strong>工作带了极大的便利性</li><li>毫<strong>无隐私</strong>可言，很容易就能被<strong>窃取</strong></li></ul><p>HTTP比较严重的缺点就是<strong>不安全:</strong></p><ul><li>**通信使用明文（不加密)**，内容可能会被窃听。</li><li><strong>不验证通信方的身份</strong>，因此有可能遭遇伪装。</li><li><strong>无法证明报文的完整性</strong>，所以有可能已遭篡改。</li></ul><p>HTTP的安全问题，可以用<strong>HTTPS</strong>的方式解决，也就是通过引入<strong>SSL/TLS</strong>层，使得在安全上达到了极致。</p><h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><ul><li>HTTP是<strong>超文本传输协议</strong>，信息是<strong>明文传输</strong>，存在安全风险的问题。HTTPS则解决HTTP不安全的缺陷，<strong>在TCP和HTTP之间加入了SSL/TLS安全协议</strong>，使得报文能够<strong>加密</strong>传输。</li><li>HTTP 连接建立相对简单，<strong>TCP三次握手</strong>之后便可进行HTTP的报文传输。而 HTTPS在<strong>TCP三次握手</strong>之后，还需进行<strong>SSL/TLS的握手</strong>过程，才可进入加密报文传输。</li><li>HTTP的端口号是<strong>80</strong>，HTTPS的端口号是<strong>443</strong>。</li><li>HTTPS 协议需要<strong>向CA(证书权威机构）申请数字证书</strong>，来保证服务器的身份是可信的。</li></ul><blockquote><p>SSL和TLS？</p></blockquote><p>这两实际上是一个东西。很多相关的文章都把这两者并列称呼(SSL/TLS)，因为这两者可以视作<strong>同一个东西的不同阶段</strong>。</p><h4 id="HTTPS优点"><a href="#HTTPS优点" class="headerlink" title="HTTPS优点"></a>HTTPS优点</h4><h5 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h5><p>HTTPS采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的<strong>混合加密</strong>方式，保证信息的<strong>机密性</strong>，解决了窃听的风险:</p><ul><li>在<strong>通信建立前</strong>采用<strong>非对称加密</strong>的方式<strong>交换</strong>「会话秘钥」，后续就不再使用非对称加密。</li><li>在<strong>通信过程中</strong>全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul><p>采用「混合加密」的方式的原因:</p><blockquote><p>对称加密：加密和解密使用的是同一个密钥。</p><p>RSA（非对称加密算法）：双方必须协商一对密钥，一个私钥一个公钥。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。</p></blockquote><p>对称加密运算速度快，但最开始仍可能被拦截，发送信息依然不安全，非对称加密足够安全，但运算速度慢。</p><p><strong>使用非对称加密的方法将加密算法的对称密钥发送过去</strong>，之后就可以使用使用这个密钥，利用<strong>对称密钥</strong>来通信了。</p><h5 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h5><p><strong>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</strong></p><p><strong>如何保证公钥不被篡改和信任度?</strong></p><p>所以这里就需要借助第三方权威机构<code>CA</code>(数字证书认证机构)﹐将<strong>服务器公钥放在数字证书</strong>（由数字证书认证机构颁发)中，只要证书是可信的，公钥就是可信的。</p><h5 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h5><p><strong>摘要算法</strong>用来实现<strong>完整性</strong>，能够为数据生成独一无二的<strong>指纹</strong>﹐用于校验数据的完整性，解决了<strong>篡改</strong>的风险。</p><p>客户端在发送明文之前会通过<strong>摘要算法</strong>算出明文的<strong>指纹</strong>，发送的时候把<strong>指纹＋明文</strong>一同加密成密文后，发送给服务器，服务器解密后，用<strong>相同的摘要算法</strong>算出发送过来的明文，通过比较客户端携带的<strong>指纹</strong>和当前算出的<strong>指纹</strong>做比较，若<strong>指纹</strong>相同，说明数据是完整的。</p><h4 id="HTTPS连接"><a href="#HTTPS连接" class="headerlink" title="HTTPS连接"></a>HTTPS连接</h4><p>SSL/TLS协议基本流程∶</p><ul><li><strong>客户端向服务器索要并验证服务器的公钥</strong>。</li><li>双方协商生产<strong>会话秘钥</strong>。</li><li>双方采用<strong>会话秘钥</strong>进行加密通信。</li></ul><p>前两步也就是SSL/TLS的建立过程，也就是握手阶段。</p><p>整个SSL/TLS的握手阶段全部结束后，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用<strong>会话秘钥加密内容。</strong></p><p>SSL/TLS 1.2需要4次握手，SSL/TLS 1.3优化了过程，<strong>只需要3次握手</strong>。</p><h3 id="HTTP-1-1、HTTP-2、HTTP-3演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3演变" class="headerlink" title="HTTP/1.1、HTTP/2、HTTP/3演变"></a>HTTP/1.1、HTTP/2、HTTP/3演变</h3><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><p>HTTP/1.1相比HTTP/1.0性能上的改进︰</p><ul><li>使用TCP<strong>长连接</strong>的方式改善了<strong>HTTP/1.0短连接</strong>造成的性能开销。<ul><li><strong>减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载</strong>。</li><li><strong>只要任意一端没有明确提出断开连接，则保持TCP连接状态。</strong></li></ul></li><li>支持<strong>管道（pipeline)网络传输</strong>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li><li>缓存<code>Etag</code></li></ul><p>但HTTP/1.1还是有性能瓶颈︰</p><ul><li><strong>请求/响应头部(Header)未经压缩就发送</strong>，首部信息越多延迟越大。只能压缩<code>Body</code>的部分;</li><li><strong>服务器是按请求的顺序响应的</strong>，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>;</li><li><strong>没有请求优先级控制</strong>;</li><li>请求只能从客户端开始，<strong>服务器只能被动响应</strong>。</li></ul><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p><strong>HTTP/2协议是大多基于HTTPS的，所以HTTP/2的安全性也是有保障的。</strong></p><p>那HTTP/2相比HTTP/1.1 性能上的改进︰</p><ul><li><strong>头部压缩</strong>（HPACK算法）</li><li><strong>二进制格式</strong> 增加了数据传输的效率</li><li><strong>数据流</strong><ul><li>HTTP/2的数据包<strong>不是按顺序发送的</strong>，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</li><li>每个请求或回应的所有数据包，称为一个数据流（<strong>Stream</strong> )。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。</li><li>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</li></ul></li><li><strong>多路复用</strong><ul><li>HTTP/2是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。</li><li>移除了HTTP/1.1中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。</li></ul></li><li><strong>服务器推送</strong><ul><li>HTTP/2还在一定程度上改善了传统的「请求-应答」工作模式，服务不再是被动地响应，<strong>也可以主动向客户端发送消息</strong>。</li><li>举例来说，在浏览器刚请求HTML的时候，就提前把可能会用到的JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送(<strong>Server Push</strong>，也叫<strong>Cache Push</strong>)。</li></ul></li></ul><h4 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h4><p>HTTP/2主要的问题在于，<strong>多个HTTP请求在复用一个TCP连接</strong>，下层的TCP协议是不知道有多少个HTTP请求的。</p><p>所以<strong>一旦发生了丢包现象，就会触发TCP的重传机制</strong>，这样在一个TCP连接中的<strong>所有的HTTP请求都必须等待这个丢了的包被重传回来</strong>。</p><ul><li>HTTP/1.1中的管道（pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了。</li><li>HTTP/2多个请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的HTTP请求。</li></ul><p>这都是<strong>基于TCP传输层</strong>的问题，所以<strong>HTTP/3把HTTP下层的TCP协议改成了UDP</strong>!</p><p>UDP是<strong>不管顺序，也不管丢包的</strong>，所以<strong>不会出现HTTP/1.1的队头阻塞和HTTP/2的一个丢包全部重传问题</strong>。</p><p>大家都知道UDP是不可靠传输的，但<strong>基于UDP的QUIC协议可以实现类似TCP的可靠性传输</strong>。</p><ul><li>QUIC有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，<strong>其他流不会受到影响</strong>。</li><li>TLS3升级成了最新的<strong>1.3</strong>版本，头部压缩算法也升级成了<strong>QPack</strong> 。</li><li>HTTPS要建立一个连接，要花费6次交互，先是建立三次握手，然后是TLS/1.3的三次握手。QUIC直接把以往的TCP和 TLS/1.3的6次交互<strong>合并成了3次，减少了交互次数</strong>。</li></ul><p>所以，QUIC是一个在UDP之上的<strong>伪</strong>TCP+ TLS+ HTTP/2的多路复用的协议。</p><p>QUIC是新协议，对于很多网络设备，根本不知道什么是QUIC，只会当做UDP，这样会出现新的问题。所以HTTP/3现在普及的进度非常的缓慢，不知道未来UDP是否能够逆袭TCP。</p><h2 id="跨域通信⭐"><a href="#跨域通信⭐" class="headerlink" title="跨域通信⭐"></a>跨域通信⭐</h2><p><strong>同源策略</strong>：用于隔离潜在恶意文件的安全机制。</p><p>同源是指”<strong>协议</strong>+<strong>域名</strong>+<strong>端口</strong>“三者相同，<strong>即便两个不同的域名指向同一个ip地址，也非同源</strong>。</p><p><strong>同源策略限制内容有：</strong></p><ul><li><code>Cookie</code>、<code>LocalStorage</code>、<code>IndexedDB</code> 等存储性内容</li><li><code>DOM</code> 节点</li><li><code>AJAX</code> 请求</li></ul><p>但是有的标签是允许跨域加载资源：</p><ul><li><code>&lt;img src=XXX&gt;</code></li><li><code>&lt;link href=XXX&gt;</code></li><li><code>&lt;script src=XXX&gt;</code></li></ul><p><strong>当协议、域名、端口号中任意一个不相同时，都算作不同域</strong>。不同域之间相互请求资源，就算作“跨域”。</p><p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong>。</p><h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h3><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p><code>JSON with Padding</code> JS函数包裹JSON数据。</p><p><strong>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</strong></p><p><code>&lt;script&gt;</code> 标签中type的默认属性是<code>text/javascript</code>,<strong>会把收到的文本内容当成JS代码进行执行</strong>。</p><p>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。</p><p><strong>缺点是仅支持get方法；不安全，可能会遭受XSS攻击。</strong></p><p><strong>JSONP的实现流程</strong></p><ul><li>声明一个回调函数，将函数名(如<code>jsonpCallback</code>)当做参数值传递给跨域请求数据的服务器，函数形参为要获取的目标数据(服务器返回的data)。</li><li>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给<code>&lt;script&gt;</code>的<code>src</code>，还要在这个地址中向服务器传递该函数名（可以通过问号传参:<code>?callback=jsonpCallback</code>）。</li><li>服务器接收到请求后，需要进行特殊的处理：把<strong>传递进来的函数名</strong>和它需要给你的<strong>数据</strong>拼接成一个<strong>字符串</strong>（模板字符串）。</li><li>最后服务器把该字符串返回给客户端，客户端接收到后相当于执行之前声明的回调函数（<code>jsonpCallback</code>），对返回的数据进行操作。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过定义函数名去接收后台返回数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonpCallback</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//注意  jsonp返回的数据是json对象可以直接使用</span></span><br><span class="line">    <span class="comment">// 例如服务器的json字符串为 &#x27;&#123;&quot;msg&quot;:&quot;用户名设置成功&quot;&#125;&#x27;</span></span><br><span class="line">    <span class="comment">// 实际返回的字符串 &#x27;callback(&#123;&quot;msg&quot;:&quot;用户名设置成功&quot;&#125;)&#x27;</span></span><br><span class="line">    <span class="comment">// 浏览器接收后，执行callback(&#123;&quot;msg&quot;:&quot;用户名设置成功&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 此时的参数就是一个json对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//去创建一个script标签</span></span><br><span class="line"><span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">//script的src属性设置接口地址 并带一个callback回调函数名称</span></span><br><span class="line">script.src = <span class="string">&quot;http://127.0.0.1:8888/index.php?callback=jsonpCallback&quot;</span>;</span><br><span class="line"><span class="comment">//插入到页面</span></span><br><span class="line"><span class="built_in">document</span>.head.appendChild(script);</span><br></pre></td></tr></table></figure><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS（Cross-Origin Resource Sharing），跨域资源共享。</p><p>CORS是官方的跨域解决方案，需要浏览器和后端同时支持。</p><p>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 CORS。 <strong>该属性表示哪些域名可以访问资源，如果设置通配符<code>*</code>则表示所有网站都可以访问资源。</strong></p><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><p><strong>简单请求</strong></p><ul><li>请求方法是 <code>HEAD</code>、<code>GET</code>、<code>POST</code> 三种之一；</li><li>HTTP 头信息不超过右边着几个字段：<ul><li><code>Accept</code>、</li><li><code>Accept-Language</code>、</li><li><code>Content-Language</code>、</li><li><code>Last-Event-ID</code></li><li><code>Content-Type</code> 只限于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>；</li></ul></li></ul><p>需要这些条件是为了<strong>兼容表单</strong>，因为历史上表单一直可以跨域。</p><p>浏览器直接发出<strong>CORS请求</strong>，具体来说就是在头信息中增加<code>Origin</code>字段，表示请求来源来自哪个域(协议+域名+端口)，服务器根据这个值决定是否同意请求。如果同意，返回的响应会多出以下响应头信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//juejin.com // 和 Orign 一致  这个字段是必须的</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span> <span class="comment">// 表示是否允许发送 Cookie  这个字段是可选的</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar <span class="comment">// 指定返回其他字段的值   这个字段是可选的</span></span><br></pre></td></tr></table></figure><p>在简单请求中服务器至少需要设置：<code>Access-Control-Allow-Origin</code> 字段。</p><p><strong>复杂请求</strong></p><ul><li><p>不符合以上条件的请求，比如请求方法是 <code>PUT</code> 或 <code>DELETE</code>，或 <code>Content-Type</code> 值为 <code>application/json</code>。</p></li><li><p>浏览器会在正式通信之前，发送一次 <strong>HTTP 预检</strong> <code>OPTIONS</code> 请求，先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 请求方法和头信息字段（服务器返回的响应头会包含允许的域名、方法等）。只有得到肯定答复，浏览器才会发出正式的 <code>XHR</code> 请求，否则报错。</p></li><li><p>预检请求的方法是<code>OPTIONS</code>，它的头信息中有几个字段</p><ul><li><code>Origin</code>: 表示请求来自哪个域，这个字段是必须的</li><li><code>Access-Control-Request-Method</code>：列出CORS请求会用到哪些HTTP方法，这个字段是必须的</li><li><code>Access-Control-Request-Headers</code>： 指定CORS请求会额外发送的头信息字段，用逗号隔开</li></ul></li><li><p>OPTIONS请求次数过多也会损耗性能，所以要尽量减少OPTIONS请求，可以让服务器在请求返回头部添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Max-Age: <span class="built_in">Number</span> <span class="comment">// 数字 单位是秒</span></span><br></pre></td></tr></table></figure><p>表示<strong>预检请求的返回结果可以被缓存多久</strong>，在这个时间范围内再请求就不需要预检了。不过这个缓存只对完全一样的URL才会生效。</p></li></ul><h5 id="关于CORS的-cookie-问题"><a href="#关于CORS的-cookie-问题" class="headerlink" title="关于CORS的 cookie 问题"></a>关于CORS的 cookie 问题</h5><p>想要传递 <code>cookie</code> 需要满足 3 个条件</p><ul><li>web 请求设置<code>withCredentials</code></li></ul><p>这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 <code>withCredentials</code> 来进行传递 <code>cookie</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 xml 的设置方式</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// axios 设置方式</span></span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>2.<code>Access-Control-Allow-Credentials</code> 为 <code>true</code></p><p>3.<code>Access-Control-Allow-Origin</code>为<strong>非</strong> <code>*</code></p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>简单的说，一般给客户端做代理的都是正向代理，给服务器做代理的就是反向代理。</p><h5 id="Node中间件代理"><a href="#Node中间件代理" class="headerlink" title="Node中间件代理"></a>Node中间件代理</h5><p><strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong></p><p>代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点同域。</p><h5 id="React中配置代理"><a href="#React中配置代理" class="headerlink" title="React中配置代理"></a>React中配置代理</h5><p>在<code>package.json</code>中追加如下配置 :<code>&quot;proxy&quot;:http://localhost:5000</code></p><h5 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h5><p>配置一个代理服务器向服务器请求，再将数据返回给客户端，实质和CORS跨域原理一样，也需要配置请求响应头Access-Control-Allow-Origin等字段，只不过是在代理服务器配置。</p><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p><code>WebSocket</code>是<code>HTML5</code>的一个持久化的协议，它实现了<strong>浏览器与服务器的全双工通信</strong>，同时也是跨域的一种解决方案。</p><p><code>WebSocket</code>和<code>HTTP</code>都是<strong>应用层协议</strong>，都基于 <code>TCP</code> 协议。</p><p>但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。</p><p>同时，<code>WebSocket</code> 在建立连接时需要借助 <code>HTTP</code> 协议，连接建立好了之后 <code>client</code> 与 <code>server</code> 之间的双向通信就与 <code>HTTP</code> 无关了。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>postMessage（H5支持跨域的window属性）、location.hash + iframe</p><h2 id="Cookie、sessionStorage、localStorage-详解及应用场景⭐"><a href="#Cookie、sessionStorage、localStorage-详解及应用场景⭐" class="headerlink" title="Cookie、sessionStorage、localStorage 详解及应用场景⭐"></a>Cookie、sessionStorage、localStorage 详解及应用场景⭐</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是<strong>服务器发送到用户浏览器</strong>并<strong>保存在本地的一小块数据</strong>，它会在<strong>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</strong>。</p><p>通常，它用于告知服务端两个请求是否来自同一浏览器，如<strong>保持用户的登录状态</strong>。Cookie 使基于<strong>无状态</strong>的HTTP协议记录稳定的状态信息成为了可能。<strong>HTTP本质是无状态的，使用Cookies可以创建有状态的会话。</strong></p><h3 id="localStorage-amp-amp-sessionStorage"><a href="#localStorage-amp-amp-sessionStorage" class="headerlink" title="localStorage &amp;&amp; sessionStorage"></a>localStorage &amp;&amp; sessionStorage</h3><blockquote><p>Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在，而Web Storage仅仅是为了在本地“存储”数据而生。</p><p>即<code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p></blockquote><h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><p>IndexedDB 是一种底层 API，用于在客户端<strong>存储大量的结构化数据</strong>（也包括文件/二进制大型对象（blobs））。该 API 使用索引实现对数据的高性能搜索。虽然Web Storage在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th align="center">特性</th><th align="center">cookie</th><th align="center">localStorage</th><th align="center">sessionStorage</th><th align="center">indexDB</th></tr></thead><tbody><tr><td align="center">数据生命周期</td><td align="center">一般由服务器生成，会话期 Cookie/持久性 Cookie可以设置过期时间</td><td align="center">除非被清理，否则一直存在</td><td align="center">页面关闭就清理</td><td align="center">除非被清理，否则一直存在</td></tr><tr><td align="center">数据存储大小</td><td align="center">4K(数量20+，取决于浏览器)</td><td align="center">5M</td><td align="center">5M</td><td align="center">无限</td></tr><tr><td align="center">与服务端通信</td><td align="center">每次都会携带在header中，对于请求性能影响</td><td align="center">不参与</td><td align="center">不参与</td><td align="center">不参与</td></tr></tbody></table><p>Cookie <strong>曾一度用于客户端数据的存储</strong>，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。</p><h2 id="Cookie、Session、Token、JWT⭐"><a href="#Cookie、Session、Token、JWT⭐" class="headerlink" title="Cookie、Session、Token、JWT⭐"></a>Cookie、Session、Token、JWT⭐</h2><p>Cookie是<strong>服务器发送到用户浏览器</strong>并<strong>保存在本地的一小块数据</strong>，它会在<strong>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</strong>。</p><p>通常，它用于告知服务端两个请求是否来自同一浏览器，如<strong>保持用户的登录状态</strong>。Cookie 使基于<strong>无状态</strong>的HTTP协议记录稳定的状态信息成为了可能。</p><p>Cookie 主要用于以下三个方面：</p><ul><li><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li><strong>个性化设置</strong>（如用户自定义设置、主题等）</li><li><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</li></ul><p><strong>Session 是另一种记录服务器和客户端会话状态的机制</strong>，<strong>使服务端有状态化，可以记录会话信息</strong>。</p><p><strong>Session</strong> 是基于<code>cookie</code> 实现的<strong>，session 存储在服务器端</strong>，<code>sessionId</code> 会被<strong>存储到客户端的cookie 中</strong>。</p><p>第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个<code>Session ID</code>，以后每次请求把这个<code>Session ID</code>发送到服务器，服务器就知道你是谁了。</p><p>Token 是<strong>令牌</strong>，<strong>访问资源接口（API）时所需要的资源凭证</strong>。Token <strong>使服务端无状态化，不会存储会话信息。</strong></p><p><strong>JWT</strong> （JSON Web Token）</p><p>结构：<code>头部（Header）</code>、<code>载荷（Payload）</code>、<code>签名（Signature）</code>，并以<code>.</code>进行拼接。</p><p>其中头部和载荷都是以<code>JSON</code>格式存放数据，只是进行了编码。</p><p>签名是对头部和载荷内容进行签名，加密后存储于客户端，服务端只需要使用密钥解密进行校验即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</p><h2 id="XSS和CSRF"><a href="#XSS和CSRF" class="headerlink" title="XSS和CSRF"></a>XSS和CSRF</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p><code>Cross-Site Scripting</code>（跨站脚本攻击）简称 XSS，是一种<strong>代码注入攻击</strong>。</p><p>攻击者通过在<strong>目标网站</strong>上注入<strong>恶意脚本</strong>，使之在用户的<strong>浏览器</strong>上运行。</p><p>利用这些恶意脚本，攻击者可获取用户的敏感信息如<code>Cookie</code>、<code>SessionID</code> 等，进而危害数据安全。</p><p>简单来说,任何可以输入的地方都有可能引起,包括<strong>URL</strong>!</p><p>根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。</p><h3 id="常用防范方法"><a href="#常用防范方法" class="headerlink" title="常用防范方法"></a>常用防范方法</h3><ul><li><strong>httpOnly:</strong> 在 <code>cookie</code> 中设置 <code>HttpOnly</code> 属性后，js脚本将无法读取到 cookie 信息。</li><li><strong>输入过滤:</strong> 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。不仅仅是<strong>前端</strong>负责，<strong>后端</strong>也要做相同的过滤检查。因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。</li><li><strong>转义 HTML:</strong> 如果拼接 HTML 是必要的，就需要对于<strong>引号</strong>，<strong>尖括号</strong>，斜杠进行转义,但这还不是很完善。</li><li><strong>白名单:</strong> 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</li></ul><ul><li><strong>预防 DOM 型 XSS 攻击</strong><ul><li>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript代码本身不够严谨，把不可信的数据当作代码执行了。</li><li>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>（<strong>文本不会被解析为HTML</strong>）、<code>.setAttribute()</code> 等。</li><li>如果用 Vue/React 技术栈，尽量不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患。</li><li>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能<strong>把字符串作为代码运行</strong>。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</li></ul></li></ul><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>跨站请求伪造（Cross-site request forgery），通常缩写为 CSRF 或者 XSRF， 是一种<strong>挟制用户在当前已登录的 Web 应用程序上执行非本意的操作</strong>的攻击方法。</p><h4 id="CSRF与-XSS-区别"><a href="#CSRF与-XSS-区别" class="headerlink" title="CSRF与 XSS 区别"></a>CSRF与 XSS 区别</h4><ul><li><strong>通常来说 CSRF 是由 XSS 实现的。</strong></li><li>本质上讲，XSS 是代码注入问题，<strong>CSRF 是 HTTP 问题。</strong> XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。<strong>CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(Token验证可以避免)。</strong></li></ul><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><ul><li><strong>验证码</strong>；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 CSRF，但是用户体验比较差。</li><li><strong>token 验证的 CSRF 防御机制是公认最合适的方案。</strong>若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。</li></ul><h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP UDP"></a>TCP UDP</h2><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li>在传送数据之前<strong>不需要先建立连接</strong>，远地主机在收到 UDP 报文后，<strong>不需要给出任何确认</strong>。</li><li>一般用于<strong>即时通信</strong>，比如： QQ 语音、 QQ 视频 、直播等等</li><li>基于<strong>UDP的QUIC</strong>协议可以实现类似TCP的可靠性传输</li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul><li>提供<strong>面向连接</strong>的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li>TCP 在传递数据之前，会有<strong>三次握手</strong>来建立连接，而且在数据传递时，有<strong>确认</strong>、<strong>窗口</strong>、<strong>重传</strong>、<strong>拥塞控制</strong>机制，在数据传完后，还会<strong>断开连接</strong>用来节约系统资源</li><li>由于 TCP 要提供可靠的，面向连接的传输服务，这难以避免增加了许多开销。</li><li>TCP 一般用于<strong>文件传输、发送和接收邮件、远程登录</strong>等场景。</li></ul><h3 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h3><ul><li>三次握手建立可靠连接。</li><li><strong>流量控制：</strong>TCP 连接的每一方都有固定大小的缓冲空间，TCP 的<strong>接收端只允许发送端发送接收端缓冲区能接纳的数据</strong>。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。<strong>TCP 利用滑动窗口实现流量控制</strong>。</li><li><strong>拥塞控制：</strong> <strong>当网络拥塞时，减少数据的发送</strong>。<ul><li>第一个响应包是<strong>14kb</strong>大小。这是<strong>慢开始</strong>的一部分，慢开始是一种均衡网络连接速度的算法。慢开始逐渐增加发送数据的数量直到达到网络的最大带宽。</li><li>拥塞控制算法使用<strong>发送包</strong>和<strong>确认帧流</strong>（客户端返回）来确定发送速率。</li></ul></li><li><strong>ARQ 协议：</strong> <strong>每发完一个分组就停止发送，等待对方确认</strong>。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ul><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><strong>TCP/IP</strong>体系结构相当于将<strong>OSI</strong>体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p><p>教学时经常把TCP/IP体系结构的<strong>网络接口层</strong>分成了<strong>物理层</strong>和<strong>数据链路层</strong>。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong> 只需要专注于为用户提供应用功能，不用去关心数据是如何传输的。</p><p>协议：DNS、HTTP等</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p><strong>负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。</p><p><strong>运输层主要使用以下两种协议：</strong> TCP、UDP</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p><strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong></p><p>IP协议</p><ul><li><strong>寻址</strong>：告诉我们去往下一个目的地该朝哪个方向走。配合<strong>子网掩码</strong>才能算出IP地址的<strong>网络号</strong>和<strong>主机号</strong>。在寻址的过程中，先匹配到相同的网络号，才会去找对应的主机。</li><li><strong>路由</strong>：是根据「下一个目的地」选择路径。</li></ul><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><ul><li>主要为网络层提供链路级别传输的服务</li><li><strong>作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）</strong></li></ul><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><ul><li><p><strong>实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong>。</p></li><li><p>当数据准备要从设备发送到网络时，需要把数据包转换成光/电信号，让其可以在物理介质中传输，</p></li><li><p>它主要是为数据链路层提供二进制传输的职务。</p></li></ul><h3 id="为什么网络要分层？"><a href="#为什么网络要分层？" class="headerlink" title="为什么网络要分层？"></a>为什么网络要分层？</h3><ul><li><strong>各层之间相互独立</strong></li><li><strong>提高了整体灵活性</strong> 高内聚，低耦合</li><li><strong>大问题化小</strong></li></ul><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><ul><li>两台电脑可以通过一根<strong>网线</strong>直接连接，进行通信。</li><li>机器一多，可以把网线都接到<strong>集线器</strong>（<strong>物理层</strong>）上，但是集线器会不管三七二十一进行<strong>广播</strong>。</li><li>不想广播，可以用（二层）<strong>交换机</strong>（<strong>数据链路层</strong>），又叫多端口网桥，它比较聪明，会自我学习生产<strong>MAC地址表</strong>，知道消息发到哪，那就<strong>不需要广播</strong>啦。</li><li><strong>互联网</strong>电脑这么多，交换机MAC地址表总不能全放下吧。改用<strong>路由器</strong>（<strong>网络层</strong>），也叫<strong>三层交换机</strong>，通过网段的方式定位要把消息转发到哪，就不需要像交换机那样苦哈哈一条条记录MAC地址啦（具有<strong>MAC地址</strong>和<strong>IP地址</strong>）。</li><li>路由器和光猫之间是好搭档，<strong>光猫</strong>负责把光纤里的光信号转换成电信号给路由器。</li><li>现在一般情况下，家里已经不用集线器和交换机了，<strong>大部分路由器也支持交换机的功能</strong>。所以可以看到，家里的台式机电脑一般就连到一个路由器，再连个光猫就够能快乐上网了。</li></ul><h1 id="One-Piece-商城后台管理系统"><a href="#One-Piece-商城后台管理系统" class="headerlink" title="One Piece 商城后台管理系统"></a>One Piece 商城后台管理系统</h1><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><ol><li>此项目为一个<strong>前后台分离</strong>的<strong>后台管理的 SPA</strong>（单页面应用）, 包括前端 PC 应用和后端应用</li><li>包括<strong>用户管理</strong> / <strong>商品管理</strong> / <strong>权限管理</strong>等功能模块</li><li>前端: 使用 <strong>React 全家桶（函数式组件、react-router V6）</strong> + <strong>Antd（v4）</strong> + <strong>Axios</strong> + <strong>ES6</strong> + <strong>Webpack</strong> 等技术</li><li>后端: 使用 <strong>Node</strong> + <strong>Express</strong> + <strong>Mongodb</strong> 等技术</li><li>采用<strong>模块化</strong>、<strong>组件化</strong>、<strong>工程化</strong>的模式开发</li></ol><p>使用<code>create-react-app</code>(脚手架)搭建项目。</p><p><code>create-react-app</code> 是react 官方提供的用于搭建基于<code>react</code>+<code>webpack</code>+<code>es6</code> 的脚手架</p><p><code>antd</code> 是基于 Ant Design 设计体系的 <strong>React UI 组件库</strong>，主要用于研发企业级中后台产品。</p><p><code>craco</code>一个对 create-react-app 进行<strong>自定义配置</strong>的社区解决方案</p><h2 id="后端数据"><a href="#后端数据" class="headerlink" title="后端数据"></a>后端数据</h2><p>Node + Express + Mongodb等技术。</p><p>Node.js 使用 JavaScript 语言开发服务器端应用；</p><p>Express是基于 Node.js平台，快速、开放、极简的 Web 开发框架；</p><p>MongoDB 是一个基于分布式文件存储的数据库。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p><h2 id="模块化、组件化、工程化"><a href="#模块化、组件化、工程化" class="headerlink" title="模块化、组件化、工程化"></a>模块化、组件化、工程化</h2><h3 id="模块化-1"><a href="#模块化-1" class="headerlink" title="模块化"></a>模块化</h3><p>后端：<strong>CommonJS</strong> :<code>module.exports</code>、<code>require</code>方法用于加载模块。</p><p>前端：<strong>ES6</strong> 模块化语法：export 和 import；</p><h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><p><code>webpack</code>最热门的前端资源模块化管理和打包工具、</p><p><code>create-react-app</code> 脚手架初始化react 项目开发、</p><p><code>ESLint</code> 插件化的 JavaScript 代码检测工具</p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>其中以React的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。</p><p>理解:<strong>用来实现局部功能效果的代码和资源的集合(html/css/js/img等等)</strong></p><p>为什么要用组件:一个界面的功能复杂</p><p>作用:<strong>复用编码,简化项目编码,提高运行效率</strong></p><p>当应用是以多组件的方式实现,这个应用就是组件化的应用。</p><h2 id="天气API"><a href="#天气API" class="headerlink" title="天气API"></a>天气API</h2><p>和风天气（不需要跨域处理） get请求 天气图标使用图标字体。</p><h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><h3 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h3><h4 id="Flex-margin-line-height"><a href="#Flex-margin-line-height" class="headerlink" title="Flex margin line-height"></a>Flex margin line-height</h4><h3 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h3><blockquote><p>气泡背景原理：</p></blockquote><p><strong>background</strong>可以设置多个，默认地，每个背景图像在水平和垂直方向上<strong>重复</strong>。因此，通过设置多个背景图像的<strong>位置</strong>和<strong>大小</strong>产生重叠效果。</p><p>气泡：<code>radial-gradient</code>+<code>rgba</code></p><p>开始和结束的透明度都设为0。通过两个确定位置的固定色值（有一定透明度的白色），实现渐变效果。</p><p><code>radial-gradient(rgba(255,255,255,0) 0, rgba(255,255,255,.15) 30%, rgba(255,255,255,.3) 32%, rgba(255,255,255,0) 33%)</code></p><blockquote><p>边框</p></blockquote><p><code>box-shadow</code> 内外阴影效果。</p><blockquote><p>背景毛玻璃</p></blockquote><p><code>backdrop-filter: blur(5px);</code></p><p>该属性可以让你为一个元素后面区域添加图形效果（如模糊或颜色偏移）。 因为它适用于元素背后的所有元素，为了看到效果，必须使元素或其背景至少部分透明。</p><blockquote><p>头像旋转</p></blockquote><p><code>animation</code>+<code>transform: rotate</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">animation</span>: spin <span class="number">0.5s</span> linear <span class="number">0s</span> forwards;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">        <span class="attribute">animation</span>: spin <span class="number">1s</span> linear forwards infinite;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> spin &#123;</span><br><span class="line">    <span class="selector-tag">100%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotate(<span class="number">360deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预加载动画"><a href="#预加载动画" class="headerlink" title="预加载动画"></a>预加载动画</h3><p>在index.html中的<code>div root</code>中先填充加载元素，通过css设置样式</p><p>多个<code>span</code> <code>animation</code> <code>animation-delay</code> <code>opacity</code> <code>background</code> 无限循环</p><p><strong>等react组件加载完成后就会覆盖</strong>。</p><h2 id="类式组件与函数式组件"><a href="#类式组件与函数式组件" class="headerlink" title="类式组件与函数式组件"></a>类式组件与函数式组件</h2><blockquote><p>因为React-Router v6正式版的更新，类式路由组件很多功能不易完成，比如无法直接操作history。</p><p>另外React-Router官方推荐使用函数式组件。</p></blockquote><h2 id="React-Router-v6-新特性"><a href="#React-Router-v6-新特性" class="headerlink" title="React-Router v6 新特性"></a>React-Router v6 新特性</h2><h3 id="SPA的理解"><a href="#SPA的理解" class="headerlink" title="SPA的理解"></a>SPA的理解</h3><ul><li>单页Web应用（single page web application，SPA）。</li><li>整个应用只有<strong>一个完整的页面</strong>，点击页面中的链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部更新。</strong></li><li>数据都需要通过ajax请求获取, 并在前端异步展现。</li></ul><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>React Router v6 大量使用<code>React hooks</code>。官方明确推荐<strong>函数式组件</strong>了。</p><p><code>Routes</code>是以前 <code>Switch</code> 组件的升级版，它包括相对路由和链接、自动路由排名、嵌套路由和布局等功能。</p><p><code>component</code>重命名为<code>element</code>。</p><p>v6的<code>&lt;Routes&gt;</code>元素下的所有<code>&lt;Route path</code>&gt;和<code>&lt;Link to&gt;</code>值都是<strong>自动相对于它们的父路由渲染的</strong>，而且忽略当前URL中的尾部斜杠。头部斜杠代变绝对路径。</p><p>中小型项目<strong>嵌套路由可集中显示</strong>，在需要显示的地方使用<code>&lt;Outlet /&gt;</code>作为占位符。</p><p>若<strong>分别显示</strong>，具有后代路由（在其他组件中定义）的路由在其路径中使用尾随<code>*</code> 。</p><p>“默认子路由”：<code>index</code>（不写path）表示索引路由共享父路径。这就是重点——它没有路径。</p><p>“未找到”路由：<code>path=&#39;*&#39;</code>表示路径都不匹配时。具有最弱的优先级。</p><p>v6 提供了 <strong>Navigate</strong> 组件，以前版本中的<code>Redirect</code>组件也消失了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  根组件(函数式)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;login&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Login</span> /&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Admin</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">index</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;category&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Category</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;product&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Product</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">index</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ProductHome</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;detail&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ProductDetail</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;addupdate&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ProductAddUpdate</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;user&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">User</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;role&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Role</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;charts-bar&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Bar</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;charts-pie&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Pie</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;charts-line&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Line</span> /&gt;</span>&#125; /&gt;    </span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;/* 以上路径都不匹配时 */&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;*&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">NotFound</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后台管理的路由组件</span></span><br><span class="line"><span class="comment"> *  */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Admin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> user = memoryUtils.user</span><br><span class="line">    <span class="comment">// 如果内存没有存储user ==&gt; 当前没有登陆</span></span><br><span class="line">    <span class="keyword">if</span> (!user || !user._id) &#123;</span><br><span class="line">        <span class="comment">// 自动跳转到登陆(在render()中) Navigate替代Redirect</span></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&#x27;/login&#x27;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        ...     </span><br><span class="line">        &lt;Outlet /&gt;&#123;<span class="comment">/* 占位符 */</span>&#125;</span><br><span class="line">    	...</span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v6 <strong>无法直接访问history实例</strong>，将useHistory更改为 <strong>useNavigate</strong>（兼容性和体验）。</p><p>useNavigate返回一个函数用来实现编程式导航。<code>navigate(&#39;/&#39;, &#123; replace: true &#125;)</code></p><p>传入数值进行前进或后退，类似于5.x中的 history.go()方法 <code>navigate(-1)</code></p><p>v5:<strong>withRouter</strong>高阶组件:包装非路由组件, 返回一个新的组件，新的组件向非路由组件传递3个属性: <code>history/location/match</code></p><p>v6:<strong>非路由组件</strong>使用<code>useLocation</code>也可得到<code>location</code>对象，<code>withRouter</code>不再使用。<code>useLocation().pathname</code>得到当前路径名。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> location =useLocation();</span><br><span class="line"><span class="keyword">const</span> path = location.pathname;</span><br><span class="line"></span><br><span class="line"><span class="comment">// location对象</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">hash</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;hvfbi1fy&quot;</span></span><br><span class="line">    <span class="attr">pathname</span>: <span class="string">&quot;/role&quot;</span></span><br><span class="line">    <span class="attr">search</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">state</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>useRoutes</code>钩子是一个路由API，它允许你使用<strong>JavaScript对象</strong>而不是React元素来声明和组合路由。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> element = useRoutes([</span><br><span class="line">    <span class="comment">// 这些与您提供给 &lt;Route&gt; 的props相同</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;dashboard&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Dashboard</span> /&gt;</span></span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;invoices&quot;</span>,</span><br><span class="line">      <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Invoices</span> /&gt;</span></span>,</span><br><span class="line">      <span class="comment">// 嵌套路由使用 children 属性，这也与 &lt;Route&gt; 相同</span></span><br><span class="line">      children: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;:id&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Invoice</span> /&gt;</span></span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;sent&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">SentInvoices</span> /&gt;</span></span> &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Not found routes work as you&#x27;d expect</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;*&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">NotFound</span> /&gt;</span></span> &#125;,</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回的元素将呈现整个元素层次结构及其所需的所有适当上下文</span></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Link</strong></p><p>标签体内容也是一种特殊的标签属性。</p><p>在 v5 中，不以 / 开头的 <code>&lt;Link to&gt;</code> 值是不明确的； 这取决于当前的 URL 是什么。 例如，如果当前 URL 是 /users，则 v5 <code>&lt;Link to=&quot;me&quot;&gt;</code> 将呈现 <code>&lt;a href=&quot;/me&quot;&gt;</code>。 但是，如果当前 URL 有一个结尾斜杠，例如 /users/，则相同的 <code>&lt;Link to=&quot;me&quot;&gt;</code> 将呈现 <code>&lt;a href=&quot;/users/me&quot;&gt;</code>。 这使得很难预测链接的行为方式，因此在 v5 中，我们建议您从根 URL（使用 match.url）构建链接，而不是使用相对的 <code>&lt;Link to&gt;</code> 值。</p><p>React Router v6 修复了这种歧义。 在 v6 中，<code>&lt;Link to=&quot;me&quot;&gt;</code> 将始终呈现相同的 <code>&lt;a href&gt;</code>，而不管当前的 URL。</p><p>例如，在 <code>&lt;Route path=&quot;users&quot;&gt;</code> 中呈现的 <code>&lt;Link to=&quot;me&quot;&gt;</code> 将始终呈现指向 /users/me 的链接，无论当前 URL 是否具有尾部斜杠。</p><p>当您想“向上”链接回父路由时，请在 <code>&lt;Link to&gt;</code> 值中使用前导 <code>..</code> 段，类似于您在 <code>&lt;a href&gt;</code> 中所做的。</p><h3 id="路由参数传递"><a href="#路由参数传递" class="headerlink" title="路由参数传递"></a>路由参数传递</h3><h4 id="param参数"><a href="#param参数" class="headerlink" title="param参数"></a>param参数</h4><ul><li>在<code>Route组件</code>中的<code>path属性</code>中定义路径参数</li><li>在组件内通过<code>useParams</code> hook访问路径参数</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义参数</span></span><br><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/foo/:id&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;Foo&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line">&lt;/BrowserRouter&gt;</span><br><span class="line"><span class="comment">// 传递参数</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">LinkButton</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> navigate(`foo/$&#123;product.id&#125;`)&#125; &gt;</span></span><br><span class="line"><span class="xml">    修改</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">LinkButton</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 提取参数</span></span><br><span class="line"><span class="keyword">import</span> &#123; useParams &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> params = useParams();</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;params.id&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>个人理解：param参数适合传递一个参数时使用。</strong></p><p><strong>useMatch</strong>()</p><ol><li><p>作用：返回当前匹配信息，对标5.x中的路由组件的<code>match</code>属性。</p></li><li><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/login/:page/:pageSize&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Login</span> /&gt;</span></span>&#125;/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;/login/1/10&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Login</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> match = useMatch(<span class="string">&#x27;/login/:x/:y&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(match) <span class="comment">//输出match对象</span></span><br><span class="line">  <span class="comment">//match对象内容如下：</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  	&#123;</span></span><br><span class="line"><span class="comment">      params: &#123;x: &#x27;1&#x27;, y: &#x27;10&#x27;&#125;</span></span><br><span class="line"><span class="comment">      pathname: &quot;/LoGin/1/10&quot;  </span></span><br><span class="line"><span class="comment">      pathnameBase: &quot;/LoGin/1/10&quot;</span></span><br><span class="line"><span class="comment">      pattern: &#123;</span></span><br><span class="line"><span class="comment">      	path: &#x27;/login/:x/:y&#x27;, </span></span><br><span class="line"><span class="comment">      	caseSensitive: false, </span></span><br><span class="line"><span class="comment">      	end: false</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  	<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="search参数-amp-sate参数"><a href="#search参数-amp-sate参数" class="headerlink" title="search参数&amp;sate参数"></a>search参数&amp;sate参数</h4><p>Location：这是一个 React Router 特定的对象，它基于内置浏览器的 window.location 对象。</p><p>您可以设置<code>location state</code>在<code>&lt;Link&gt;</code>上或<code>navigate</code>上，在下一路由组件中你可以用<code>useLocation</code>来访问它。</p><p><code>useLocation()</code>既可以获得<code>state</code>参数，也可以获得<code>search</code>参数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinkButton onClick=&#123;<span class="function">() =&gt;</span> navigate(<span class="string">&#x27;addupdate?name=tom&amp;age=18&#x27;</span>, &#123; <span class="attr">state</span>: product &#125;)&#125; &gt;</span><br><span class="line">    修改</span><br><span class="line">&lt;/LinkButton&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isUpdate = location.state</span><br><span class="line"><span class="keyword">const</span> search = location.search</span><br><span class="line"><span class="built_in">console</span>.log(search) <span class="comment">// ?name=tom&amp;age=18</span></span><br><span class="line"><span class="built_in">console</span>.log(isUpdate) <span class="comment">// &#123;status: 1, imgs: Array(2), _id: &#x27;5e12b97de31bb727e4b0e349&#x27;, name: &#x27;联想ThinkPad 翼4809&#x27;, desc: &#x27;年度重量级新品，X390、T490全新登场 更加轻薄机身设计9&#x27;, …&#125;</span></span><br></pre></td></tr></table></figure><p><strong>个人理解：state参数适合传js对象。</strong></p><p><code>search</code>参数一般使用<code>useSearchParams()</code>进行获取和修改。</p><ol><li>作用：用于读取和修改当前位置的 URL 中的查询字符串。</li><li>返回一个包含两个值的数组，内容分别为：当前的seaech参数、更新search的函数。</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [search,setSearch] = useSearchParams()</span><br><span class="line"><span class="keyword">const</span> age = search.get(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> name = search.get(<span class="string">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>个人理解：search参数适合传可能会被修改的参数。</strong></p><h2 id="Antd-v3升级成v4"><a href="#Antd-v3升级成v4" class="headerlink" title="Antd v3升级成v4"></a>Antd v3升级成v4</h2><h4 id="去除-Form-create"><a href="#去除-Form-create" class="headerlink" title="去除 Form.create"></a>去除 Form.create</h4><p>v4 的 Form 不再需要通过 <code>Form.create()</code> 创建上下文。Form 组件现在自带数据域，因而 <code>getFieldDecorator</code> 也不再需要，直接写入 Form.Item 即可。</p><p>由于移除了 <code>Form.create()</code>，原本的 <code>onFieldsChange</code> 等方法移入 Form 中，通过 <code>fields</code> 对 Form 进行控制。</p><h4 id="表单控制调整"><a href="#表单控制调整" class="headerlink" title="表单控制调整"></a>表单控制调整</h4><p>Form 自带表单控制实体，如需要调用 form 方法，可以通过 <code>Form.useForm()</code> 创建 <strong>Form 实体</strong>进行操作。</p><h4 id="onFinish-替代-onSubmit"><a href="#onFinish-替代-onSubmit" class="headerlink" title="onFinish 替代 onSubmit"></a>onFinish 替代 onSubmit</h4><p>对于表单校验，过去版本需要通过监听 <code>onSubmit</code> 事件手工触发 <code>validateFields</code>。新版直接使用 <code>onFinish</code> 事件，该事件仅当校验通过后才会执行：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// antd v4</span></span><br><span class="line"><span class="keyword">const</span> Demo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> onFinish = <span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Received values of form: &#x27;</span>, values);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Form</span> <span class="attr">onFinish</span>=<span class="string">&#123;onFinish&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Form.Item</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">rules</span>=<span class="string">&#123;[&#123;</span> <span class="attr">required:</span> <span class="attr">true</span> &#125;]&#125;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Input</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><ul><li>echarts echarts-for-react</li><li>bizcharts</li></ul><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="登录数据持久化"><a href="#登录数据持久化" class="headerlink" title="登录数据持久化"></a>登录数据持久化</h3><p>默认使用最高级管理员登录，该管理员名称和密码为默认值，且拥有最高权限。</p><p>通过向后端发送用户名和密码，后端返回用户信息，其中密码在后端使用<strong>md5</strong>加密格式返回，然后将用户信息保存在内存和<code>localStorage</code>中（store.js），每次打开该网站时就从localStorage中读取数据到内存，实现登录数据持久化。</p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>根据首次登录后端传回的权限信息，前端渲染前先进行检查，对左侧导航栏展示的内容<strong>递归（map）</strong>遍历检查是否拥有展示权限。</p><p>后端其实并没有保存登录状态。不同权限的用户只能操作自己可见的内容，所以后端不需要记录用户。</p><p>由于是管理系统，在自己的权限内，所有用户都可以对数据库进行相应的操作。</p><h3 id="输入校验"><a href="#输入校验" class="headerlink" title="输入校验"></a>输入校验</h3><p><strong>正则</strong></p><p><code>/^[a-zA-Z0-9_]+$/</code>用户名必须是英文,数字和下划线组成</p><p><code>/^[a-zA-Z0-9_]+$/.test(value)</code></p><h3 id="跨域和Ajax"><a href="#跨域和Ajax" class="headerlink" title="跨域和Ajax"></a>跨域和Ajax</h3><p>React中配置代理</p><p>在<code>package.json</code>中追加如下配置 :<code>&quot;proxy&quot;:http://localhost:5000</code></p><p>Promise封装axios</p><h3 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h3><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><ul><li><p>【父组件】给【子组件】传递数据：通过<code>props</code>传递</p></li><li><p>【子组件】给【父组件】传递数据：通过<code>props</code>传递，<strong>要求父提前给子传递一个函数</strong></p><p>该项目中将<code>useState</code>的更新函数传给子组件，将数据作为函数参数传回父组件用来更新状态</p></li><li><p>【子组件】给【父组件】传递函数/方法</p><ul><li><code>useRef</code>: 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 ref 对象在组件的整个生命周期内持续存在。一个常见的用例便是命令式地访问子组件。</li><li><code>useImperativeHandle</code>:可以让你在使用 <code>ref</code> 时<strong>自定义暴露给父组件的实例值</strong>。比如暴露子组件的某个方法。<code>useImperativeHandle</code> 应当与<code>React.forwardRef</code> 一起使用：</li></ul></li></ul><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>因为是静态站点，所以完全是<strong>客户端部分</strong>，使用<strong>Hash</strong>路由跳转会没有任何问题。因为<strong>BrowserRouter依赖于服务端支持</strong>，使用它的话访问会出现404 not Found/405.</p><h3 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h3><blockquote><p>这一种很自然，比如 <code>/</code> 对应 <code>Home页</code> ，<code>/about</code> 对应 <code>About 页</code>，但是<code>这样的设计需要服务器端渲染</code>，因为<code>用户可能直接访问任何一个 URL，服务器端必须能对 /的访问返回 HTML，也要对 /about的访问返回 HTML</code>。BrowserRouter支持这种URL。</p></blockquote><p>①基于<code>history</code>模式：页面跳转原理是使用了HTML5为浏览器全局的history对象新增了两个API，包括 history.pushState、history.replaceState；和vue router的history模式实现一致<br>②更加优雅： 直接拼接路径；如：<code>www.abc.com/xx</code><br>③<strong>后端需做请求处理</strong>： 切换路由后，请求接口路径会发生变化，后端需要配合，做处理</p><h3 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h3><blockquote><p>这一种看起来不自然，但是实现更简单。</p><p><code>只有一个路径 /，通过 URL 后面的 # 部分来决定路由</code>，<code>/#/</code> 对应 Home 页，<code>/#/about</code> 对应 About 页。</p><p>因为URL中<code>#</code>之后的部分是不会发送给服务器的，所以，<code>无论哪个 URL，最后都是访问服务器的 / 路径，服务器也只需要返回同样一份 HTML</code>就可以，<code>然后由浏览器端解析#后的部分，完成浏览器端渲染</code>。HashRouter支持这种URL。</p></blockquote><p>①<strong>基于hash模式</strong>：页面跳转原理是使用了location.hash、location.replace；和vue router的hash模式实现一致。<br>②<strong>比较丑</strong>：在域名后，先拼接<code>/#</code>，再拼接路径；也就是利用锚点，实现路由的跳转；如：<code>www.abc.com/#/xx</code></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><strong>HashRouter</strong>：<strong>项目部署在内网</strong>：如To B的项目、本公司业务人员用的项目等等。</p><p><strong>BrowserRouter</strong>：<strong>项目部署在公网</strong>：如To C的项目、面向大众的项目，url路径美观点当然更好，但后端需要做处理。</p><h3 id="GitHub-Pages发布静态页面"><a href="#GitHub-Pages发布静态页面" class="headerlink" title="GitHub Pages发布静态页面"></a>GitHub Pages发布静态页面</h3><p><code>package.json</code> 打包好的build文件夹上传gh-pages分支</p><h2 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h2><h3 id="自定义hook实现搜索防抖"><a href="#自定义hook实现搜索防抖" class="headerlink" title="自定义hook实现搜索防抖"></a>自定义hook实现搜索防抖</h3><p><strong>Input</strong> <code>event.target.value</code> 获取输入值 ，<strong>useState</strong> 更新此时的搜索状态 。</p><p>自定义 hook <strong>useDebounce</strong></p><p>debounce一般使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lodash</span></span><br><span class="line"><span class="keyword">import</span> debounce <span class="keyword">from</span> <span class="string">&#x27;lodash/debounce&#x27;</span></span><br><span class="line">debounce(<span class="function">()=&gt;</span>search(value), <span class="number">500</span>)</span><br><span class="line"><span class="comment">// 自定义</span></span><br><span class="line"><span class="keyword">const</span> debounceFn =<span class="function">(<span class="params">fn, wait=<span class="number">1000</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(fn, wait);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [value, setValue] = useState(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&lt;!--搜索函数--&gt;</span><br><span class="line"><span class="keyword">const</span> search = <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">    &lt;!--调用接口--&gt;</span><br><span class="line">&#125;</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    debounceFn(<span class="function">()=&gt;</span>search(value),<span class="number">500</span>)</span><br><span class="line">&#125;, [value])</span><br></pre></td></tr></table></figure><p>测试发现这一套在useEffect里是行不通的，<strong>每次组件重新渲染，都会创建新的定时器，定时器无法按规定清除</strong>，这样debounce高阶函数里面的timer就不能起到缓存的作用。timer不可靠，debounce的核心就被破坏了。</p><p>使用useCallback返回回调函数的 memoized 版本，<strong>该回调函数仅在某个依赖项改变时才会更新</strong>，通过设置空数组，使debounce高阶函数里面的timer唯一。</p><p>也可以借助useEffect自定义useDebounce ，关键<strong>React 会在执行当前 effect 之前对上一个effect进行清除</strong>。</p><p>当首次渲染时，执行effect延时后执行一次搜索操作，可以通过给value赋初值跳过这次搜索请求，之后每当输入时，value就会变化，每次变化先清除上一次effect的timer，然后建立新的timer等待执行，当输入停止后搜索函数在延时后就会发送请求，实现防抖。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理方案四 useEffect自定义hooks</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDebounce</span>(<span class="params">fn, delay, dep=[]</span>) </span>&#123;</span><br><span class="line">   useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> timer;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(fn, delay);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">()=&gt;</span><span class="built_in">clearTimeout</span>(timer); <span class="comment">// 这里用到useEffect清除的能力 类似于componentWillUnmount</span></span><br><span class="line">   &#125;, [...dep]</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useDebounce</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">useDebounce(<span class="function">()=&gt;</span>search(value), <span class="number">500</span>, [value])</span><br></pre></td></tr></table></figure><p>使用useRef保证<strong>多次渲染之间保证唯一值的纽带</strong>。将timer通过<code>useRef</code>创建。</p><p>useRef 会在所有的 render 中保持对返回值的唯一引用。因为所有对<code>ref</code>的赋值和取值拿到的都是最终的状态，并不会因为不同的 render 中存在不同的隔离。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理方案五 useRef自定义hooks</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDebounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = useRef(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer.current);</span><br><span class="line">        timer.current = <span class="built_in">setTimeout</span>(fn, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useDebounce</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">const</span> debounceSearch = useDebounce(<span class="function">() =&gt;</span> handleParams(params), <span class="number">500</span>)</span><br><span class="line">useEffect(<span class="function">()=&gt;</span>debounceSearch(),[value]</span><br></pre></td></tr></table></figure><h3 id="刷新后父级菜单的展开问题"><a href="#刷新后父级菜单的展开问题" class="headerlink" title="刷新后父级菜单的展开问题"></a>刷新后父级菜单的展开问题</h3><p>Menu可以通过<code>defaultOpenKeys</code>设置当前的菜单是否展开。</p><p>需求：如果点击了一个子菜单后，再刷新时该子菜单对应的上一级菜单是展开的。</p><p>方法：</p><ul><li><p>拿到当前路径（location属性中的<code>pathname</code>）</p><ul><li>withRouter高阶组件包装非路由组件, 返回一个新的组件。新的组件向非路由组件传递3个属性: <code>history/location/match</code></li><li>v6:使用<code>useLocation</code>即可得到location属性，withRouter不再使用。</li></ul></li><li><p>当存在子Item时，通过find和indexOf判断是否有与当前请求路径匹配的子Item，如果匹配就将父item设置展开。</p></li><li><p>由于需要将所有菜单遍历判断与当前路径是否匹配，而且OpenKeys的属性需要在组件渲染完成前得到，但我们仅希望刷新时调用一次，得到初始openKey，而不希望<strong>路由跳转</strong>等操作也执行该函数。</p></li><li><p>所以使用useMemo和useRef进行优化。使用useRef是因为pathname是个随路由跳转变化的值，放到useMemo中，如果不加入依赖数组会有警告。使用useRef也可以存储最新的pathname，而且不用加入依赖。</p><p><code>const pathRef = useRef(path);</code></p><p><code>pathRef.current=path;</code></p></li></ul><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="为什么选择使用框架而不是原生"><a href="#为什么选择使用框架而不是原生" class="headerlink" title="为什么选择使用框架而不是原生?"></a>为什么选择使用框架而不是原生?</h2><ol><li><strong>组件化</strong>: 其中以 React 的组件化最为彻底,甚至可以到<strong>函数级</strong>别的原子组件,高度的组件化可以是我们的工程<strong>易于维护、易于组合拓展</strong>。</li><li><strong>天然分层</strong>: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。</li><li><strong>生态</strong>: 现在主流前端框架都<strong>自带生态</strong>,不管是<strong>数据流管理架构</strong>还是 <strong>UI 库</strong>都有成熟的解决方案。</li><li><strong>开发效率</strong>: 现代前端框架都默认<strong>自动更新DOM</strong>,而非我们手动操作,解放了开发者的手动DOM成本,提高开发效率,从根本上解决了UI 与状态同步问题。</li></ol><p>常见框架：<strong>Angular React Vue Svelte</strong></p><h2 id="React-vs-Vue"><a href="#React-vs-Vue" class="headerlink" title="React vs Vue"></a>React vs Vue</h2><p>React 与 Vue 存在很多共同点，例如他们都是 JavaScript 的 <strong>UI 框架</strong>，专注于创造前端的富应用。</p><p>不同于早期的 JavaScript 框架“功能齐全”，Reat 与 Vue 只有<strong>框架的骨架</strong>，其他的功能如<strong>路由、状态管理</strong>等是框架分离的组件。</p><ul><li><p>React组件倾向于使用<code>jsx</code>语法，all in js，<strong>将html与css全都融入javaScript</strong>，jsx语法相对来说更加灵活。</p></li><li><p>vue仍然是拥抱经典的**html(结构)+css(表现)+js(行为)**的形式，vue鼓励开发者使用<code>template</code>模板，并提供指令供开发者使用如v-if、v-show、v-for等指令，因此在开发vue应用的时候会有一种在写经典web应用（结构、表现、行为分离）的感觉。</p></li><li><p>React 整体是<strong>函数式</strong>的思想，在 React 中是<strong>单向数据流</strong>，推崇结合 immutable 来实现<strong>数据不可变</strong>。</p></li><li><p>而 Vue 的思想是<strong>响应式</strong>的，也就是基于是<strong>数据可变</strong>的，通过对每一个属性建立 <strong>Watcher</strong> 来监听，当属性变化的时候，响应式的更新对应的虚拟 DOM。</p></li><li><p>如上，所以 React 的性能优化需要手动去做。</p></li></ul><p><strong>React优势</strong></p><ul><li><strong>灵活的结构和可扩展性</strong>。</li><li><strong>丰富的JavaScript库</strong>。</li><li>发展： React得到了<code>Facebook</code>专业开发人员的支持，他们不断寻找改进方法。</li><li>Web或移动平台： React提供<code>React Native</code>平台，可通过相同的React组件模型为<code>iOS</code>和<code>Android</code>开发本机呈现的应用程序。</li></ul><p><code>react</code>在中后台项目中由于在<strong>处理复杂的业务逻辑或组件的复用问题</strong>比<code>vue</code>优雅而被人认可，但这种优雅是要有成本代价的，它更需要团队技术整体比较给力，领头大佬的设计与把关能力要更优秀，因此开发成本更大。</p><p><code>vue</code><strong>更友好更易上手</strong>的写法著称，渐进式的框架、更友好的api、更亲民的设计让开发成本大大下降而效率大大提升。</p><p><code>vue</code>与<code>react</code>在发展长河中越发成熟，深思熟虑后觉得<strong>两者不管在移动端或大型中后台都是非常可行的</strong>，其实框架本无好坏之分，我们更应该思考的是团队想要用什么技术栈、自己喜欢与擅长什么技术栈。</p><h2 id="什么是JSX？"><a href="#什么是JSX？" class="headerlink" title="什么是JSX？"></a>什么是JSX？</h2><p>JSX 是<strong>JavaScript XML</strong> 的简写。是 React 使用的一种文件，它利用 JavaScript 的表现力和类似 HTML 的模板语法。这使得 HTML 文件非常容易理解。此文件能使应用非常可靠，并能够提高其性能。</p><p><strong>React不强制要求使用 JSX</strong>，但是大多数人发现，<strong>在 JavaScript 代码中将 JSX 和 UI 放在一起时，会在视觉上有辅助作用</strong>。它还可以使 React <strong>显示更多有用的错误和警告消息</strong>。</p><p>实际上，JSX 仅仅只是 <code>React.createElement(component, props, ...children)</code> 函数的语法糖。</p><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><blockquote><p>操作DOM会引起页面的回流或者重绘。相比起来，通过多一些预先计算来减少DOM的操作要划算的多。</p><p>但是，“使用虚拟DOM会更快”这句话并不一定适用于所有场景。例如：一个页面就有一个按钮，点击一下，数字加一，那肯定是直接操作DOM更快。使用虚拟DOM无非白白增加了计算量和代码量。即使是复杂情况，浏览器也会对我们的DOM操作进行优化，大部分浏览器会根据我们操作的时间和次数进行批量处理，所以直接操作DOM也未必很慢。</p><p>使用虚拟DOM可以提高代码的性能下限，并极大的优化大量操作DOM时产生的性能损耗。同时这些框架也保证了，即使在少数虚拟DOM不太给力的场景下，性能也在我们接受的范围内。</p></blockquote><p>UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫做<strong>协调</strong>。</p><p>这种方式赋予了 React 声明式的 API：您告诉 React 希望让 UI 是什么状态，React 就确保 DOM 匹配该状态。这使您可以从属性操作、事件处理和手动 DOM 更新这些在构建应用程序时必要的操作中解放出来。</p><h3 id="虚拟DOM实现原理"><a href="#虚拟DOM实现原理" class="headerlink" title="虚拟DOM实现原理?"></a>虚拟DOM实现原理?</h3><p>Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。</p><ul><li>每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。</li><li>然后计算之前 DOM 表示与新表示的之间的差异。</li><li>完成计算后，将只用实际更改的内容更新 real DOM。</li></ul><h3 id="什么是-“React-Fiber”？"><a href="#什么是-“React-Fiber”？" class="headerlink" title="什么是 “React Fiber”？"></a>什么是 “React Fiber”？</h3><p>Fiber 是 React 16 中新的协调引擎。它的主要目的是使 Virtual DOM 可以进行<strong>增量式渲染</strong>。</p><p>React Fiber的思想: <strong>React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染</strong>。</p><h2 id="diff-算法-协调"><a href="#diff-算法-协调" class="headerlink" title="diff 算法/协调"></a>diff 算法/协调</h2><p>在某一时间节点调用 React 的 <code>render()</code> 方法，会创建一棵由 React 元素组成的树。在下一次 <code>state</code> 或 <code>props</code> 更新时，相同的 <code>render()</code> 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何高效的更新 UI，以保证当前 UI 与最新的树保持同步。</p><p>此算法有一些通用的解决方案，即<strong>将一棵树转换成另一棵树的最小操作次数</strong>。然而，即使使用最优的算法，该算法的复杂程度仍为 <code>O(n^3 )</code>，其中 n 是树中元素的数量。</p><p>于是 React 在以下两个假设的基础之上提出了一套 <code>O(n)</code> 的启发式算法：</p><ol><li><strong>两个不同类型的元素会产生出不同的树</strong>；</li><li>开发者可以通过设置 <code>key</code> 属性，来告知<strong>渲染哪些子元素在不同的渲染下可以保存不变</strong>；</li></ol><h4 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h4><p>当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素，从而减少不必要的元素重新渲染。</p><p><strong>虚拟DOM中key的作用：</strong></p><ul><li><p>简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。</p></li><li><p>详细的说: 当状态中的数据发生变化时，react会根据<strong>新数据</strong>生成<strong>新的虚拟DOM,</strong> 随后React进行<strong>新虚拟DOM</strong>与<strong>旧虚拟DOM</strong>的diff比较，比较规则如下：</p><ul><li><p>旧虚拟DOM中找到了与新虚拟DOM相同的key：</p><ul><li>若虚拟DOM中内容没变, 直接使用之前的真实DOM</li><li>若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM</li></ul></li><li><p>旧虚拟DOM中未找到与新虚拟DOM相同的key</p><ul><li>根据数据创建新的真实DOM，随后渲染到到页面</li></ul></li></ul></li></ul><p><strong>用index作为key可能会引发的问题：</strong></p><ul><li><p>若对数据进行：<strong>逆序添加、逆序删除</strong>等破坏顺序操作：会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但<strong>效率低</strong>。</p></li><li><p>如果结构中还包含<strong>输入类的DOM</strong>：会产生错误DOM更新 ==&gt; <strong>界面有问题</strong>。</p></li><li><p>注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</p></li></ul><p><strong>开发中如何选择key?:</strong></p><ul><li><p><strong>最好使用每条数据的唯一标识作为key</strong>, 比如id、手机号、身份证号、学号等唯一值。</p></li><li><p><strong>如果确定只是简单的展示数据，用index也是可以的</strong>。</p></li></ul><h2 id="两种组件定义区别"><a href="#两种组件定义区别" class="headerlink" title="两种组件定义区别"></a>两种组件定义区别</h2><p><strong>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</strong></p><p>在不违反上述规则的情况下，state 允许 React 组件随用户操作、网络响应或者其他变化而动态更改输出内容。</p><h3 id="函数式声明组件"><a href="#函数式声明组件" class="headerlink" title="函数式声明组件"></a>函数式声明组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1.创建函数式组件</span><br><span class="line">function MyComponent()&#123;</span><br><span class="line">    console.log(this); //此处的this是undefined，因为babel编译后开启了严格模式</span><br><span class="line">    return &lt;h2&gt;我是用函数定义的组件(适用于【简单组件】的定义)&lt;/h2&gt;</span><br><span class="line">&#125;</span><br><span class="line">//2.渲染组件到页面</span><br><span class="line">ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#x27;test&#x27;))</span><br></pre></td></tr></table></figure><p>执行了<code>ReactDOM.render(&lt;MyComponent/&gt;.......)</code>之后，发生了什么？</p><ul><li>React解析组件标签，找到了MyComponent组件。</li><li>发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。</li></ul><h3 id="类式组件-有状态-state"><a href="#类式组件-有状态-state" class="headerlink" title="类式组件(有状态 state)"></a>类式组件(有状态 state)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//1.创建类式组件</span><br><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        //render是放在哪里的？—— MyComponent的原型对象上，供实例使用。</span><br><span class="line">        //render中的this是谁？—— MyComponent的实例对象 &lt;=&gt; MyComponent组件实例对象。</span><br><span class="line">        console.log(&#x27;render中的this:&#x27;,this);</span><br><span class="line">        return &lt;h2&gt;我是用类定义的组件&lt;/h2&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//2.渲染组件到页面</span><br><span class="line">ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#x27;test&#x27;))</span><br></pre></td></tr></table></figure><p>执行了<code>ReactDOM.render(&lt;MyComponent/&gt;.......)</code>之后，发生了什么？</p><ul><li><p>React解析组件标签，找到了MyComponent组件。</p></li><li><p>发现组件是使用类定义的，随后<strong>new出来该类的实例</strong>，并<strong>通过该实例调用到原型上的render方法</strong>。</p></li><li><p>将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。</p></li></ul><blockquote><p>类的方法默认开启了局部严格模式</p></blockquote><p>组件中的<strong>render方法中的this为组件实例对象</strong></p><p>但组件自定义方法中this为<code>undefined</code>,如何解决?</p><p>a) 强制绑定this:通过函数对象的<code>bind()</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造器调用几次？ ———— 1次</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;constructor&#x27;</span>);</span><br><span class="line">        <span class="built_in">super</span>(props)</span><br><span class="line">        <span class="comment">//初始化状态</span></span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">isHot</span>:<span class="literal">false</span>,<span class="attr">wind</span>:<span class="string">&#x27;微风&#x27;</span>&#125;</span><br><span class="line">        <span class="comment">//解决changeWeather中this指向问题,也可以在调用处直接使用</span></span><br><span class="line">        <span class="built_in">this</span>.changeWeather = <span class="built_in">this</span>.changeWeather.bind(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//render调用几次？ ———— 1+n次 1是初始化的那次 n是状态更新的次数</span></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;render&#x27;</span>);</span><br><span class="line">        <span class="comment">//读取状态</span></span><br><span class="line">        <span class="keyword">const</span> &#123;isHot,wind&#125; = <span class="built_in">this</span>.state</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span>今天天气很&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;，&#123;wind&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//changeWeather调用几次？ ———— 点几次调几次</span></span><br><span class="line">    <span class="function"><span class="title">changeWeather</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//changeWeather放在哪里？ ———— Weather的原型对象上，供实例使用</span></span><br><span class="line">        <span class="comment">//由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用</span></span><br><span class="line">        <span class="comment">//类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;changeWeather&#x27;</span>);</span><br><span class="line">        <span class="comment">//获取原来的isHot值</span></span><br><span class="line">        <span class="keyword">const</span> isHot = <span class="built_in">this</span>.state.isHot</span><br><span class="line">        <span class="comment">//严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换。</span></span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">isHot</span>:!isHot&#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！</span></span><br><span class="line">        <span class="comment">//this.state.isHot = !isHot //这是错误的写法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.渲染组件到页面</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Weather</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>))</span><br></pre></td></tr></table></figure><p>b) 箭头函数<code>推荐</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">	<span class="comment">//初始化状态</span></span><br><span class="line">   <span class="comment">//类中可以直接写赋值语句,如下代码的含义是：给Weather的实例对象添加一个属性 state</span></span><br><span class="line">	state = &#123;<span class="attr">isHot</span>:<span class="literal">false</span>,<span class="attr">wind</span>:<span class="string">&#x27;微风&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> &#123;isHot,wind&#125; = <span class="built_in">this</span>.state</span><br><span class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span>今天天气很&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;，&#123;wind&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自定义方法————要用赋值语句的形式+箭头函数</span></span><br><span class="line">	changeWeather = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> isHot = <span class="built_in">this</span>.state.isHot</span><br><span class="line">		<span class="built_in">this</span>.setState(&#123;<span class="attr">isHot</span>:!isHot&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.渲染组件到页面</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Weather</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul><li>通过<code>onXxx</code>属性指定事件处理函数(注意大小写)<ul><li>React使用的是<strong>自定义(合成)事件,而不是使用的原生DOM事件</strong>—-为了更好的<strong>兼容性</strong></li><li>React中的事件是通过<strong>事件委托</strong>的方式处理的(委托给组件最外层的元素)—-为了更<strong>高效</strong></li></ul></li><li>通过<code>event.target</code>得到发生事件的DOM元素对象 —–<strong>不要过度使用ref</strong></li></ul><ul><li>React的所有事件都挂载在<code>document</code>中，当真实dom触发后冒泡到document后才会对react事件进行处理</li><li><strong>所以原生的事件会先执行，然后执行react合成事件，最后执行真正在document上挂载的事件</strong>。</li></ul><h2 id="正确地使用-State"><a href="#正确地使用-State" class="headerlink" title="正确地使用 State"></a>正确地使用 State</h2><p>关于 <code>setState()</code> 你应该了解三件事：</p><h3 id="不要直接修改-State"><a href="#不要直接修改-State" class="headerlink" title="不要直接修改 State"></a>不要直接修改 State</h3><p>而是应该使用 <code>setState()</code>:</p><h3 id="State-的更新可能是异步的"><a href="#State-的更新可能是异步的" class="headerlink" title="State 的更新可能是异步的"></a>State 的更新可能是异步的</h3><p>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用。</p><p>因为 <code>this.props</code> 和 <code>this.state</code> 可能会<strong>异步更新</strong>，所以你<strong>不要依赖他们的值来更新下一个状态</strong>。</p><p>要解决这个问题，可以让 <code>setState()</code> 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">counter</span>: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>上面使用了箭头函数，不过使用普通的函数也同样可以：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function"><span class="keyword">function</span>(<span class="params">state, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">counter</span>: state.counter + props.increment</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>setState更新状态的2种写法</strong></p><ul><li><p><code>setState(stateChange, [callback])</code>——对象式的setState</p><ul><li>stateChange为<strong>状态改变对象</strong>(该对象可以体现出状态的更改)</li><li>callback是可选的回调函数, 它在状态更新完毕（状态更新是异步的）、界面也更新后(render调用后)才被调用</li></ul></li><li><p><code>setState(updater, [callback])</code>——函数式的setState</p><ul><li>updater为<strong>返回stateChange对象的函数</strong>。</li><li>updater可以接收到state和props。</li><li>callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。</li></ul></li></ul><p>总结:</p><ul><li>对象式的setState是函数式的setState的简写方式(<code>语法糖</code>)</li><li>使用原则：<ul><li>如果<strong>新状态不依赖于原状态</strong> =&gt; 使用<strong>对象</strong>方式</li><li>如果<strong>新状态依赖于原状态</strong> =&gt; 使用<strong>函数</strong>方式</li><li>如果<strong>需要在setState()执行后获取最新的状态数据, 要在第二个callback函数中读取</strong></li></ul></li></ul><p>setState 只在<strong>合成事件和 hook()</strong> 中是“异步”的，在 <strong>原生事件和 setTimeout</strong> 中都是同步的。</p><h3 id="State-的更新会被合并"><a href="#State-的更新会被合并" class="headerlink" title="State 的更新会被合并"></a>State 的更新会被合并</h3><p>当你调用 <code>setState()</code> 的时候，React 会把你提供的对象合并到当前的 state。</p><p>这里的合并是<strong>浅合并</strong>。</p><h2 id="React-Refs-and-the-DOM揭秘"><a href="#React-Refs-and-the-DOM揭秘" class="headerlink" title="React Refs and the DOM揭秘"></a>React Refs and the DOM揭秘</h2><h3 id="什么是Ref"><a href="#什么是Ref" class="headerlink" title="什么是Ref"></a>什么是Ref</h3><p>在典型的React数据流理念中，父组件跟子组件的交互都是通过传递<code>props</code>实现的。</p><p>如果父组件需要修改子组件，只需要将新的属性传递给子组件，由子组件来实现具体的绘制逻辑。</p><p>在特殊的情况下，如果你需要<strong>命令式(imperatively)的修改子组件</strong>，React也提供了应急的处理办法–Ref。</p><p>Ref 既支持修改<strong>DOM元素</strong>，也支持修改<strong>自定义的组件</strong>。</p><h3 id="什么是声明式编程-Declarative-Programming"><a href="#什么是声明式编程-Declarative-Programming" class="headerlink" title="什么是声明式编程(Declarative Programming)"></a>什么是声明式编程(Declarative Programming)</h3><p>React有2个基石设计理念：一个是声明式编程，一个是函数式编程。</p><p>声明式编程的特点体现在2方面：</p><ul><li>组件定义的时候，<strong>所有的实现逻辑都封装在组件的内部，通过state管理，对外只暴露属性</strong>。</li><li>组件使用的时候，组件调用者通<strong>过传入不同属性的值来达到展现不同内容的效果</strong>。一切效果都是事先定义好的，至于效果是怎么实现的，组件调用者不需要关心。</li></ul><p>因此，在使用React的时候，<strong>一般很少需要用到Ref</strong>。</p><h3 id="Ref使用场景"><a href="#Ref使用场景" class="headerlink" title="Ref使用场景"></a>Ref使用场景</h3><p>简单理解就是，<strong>控制一些DOM原生的效果，如输入框的聚焦效果和选中效果等；触发一些命令式的动画；集成第三方的DOM库</strong>。最后还补了一句：如果要实现的功能可以通过声明式的方式实现，就不要借助Ref。</p><p>refs是React组件中非常特殊的props， 可以附加到任何一个组件上，从字面意思上看，<strong>ref即reference，组件被调用时会创建一个该组件的实例，而ref就会指向这个实例</strong>。</p><h3 id="Ref用法"><a href="#Ref用法" class="headerlink" title="Ref用法"></a>Ref用法</h3><blockquote><p>如果<strong>作用在原生的DOM元素上，通过Ref获取的是DOM元素，可以直接操作DOM的API</strong>。</p><p>如果<strong>作用在自定义组件，Ref获取的是组件的实例，可以直接操作组件内的任意方法</strong>。</p></blockquote><h4 id="创建-Refs"><a href="#创建-Refs" class="headerlink" title="创建 Refs"></a>创建 Refs</h4><p>Refs 是使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素。</p><p>在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.myRef = React.createRef();  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span>;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问-Refs"><a href="#访问-Refs" class="headerlink" title="访问 Refs"></a>访问 Refs</h4><p>当 ref 被传递给 <code>render</code> 中的元素时，对该节点的引用可以在 ref 的 <code>current</code> 属性中被访问。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="built_in">this</span>.myRef.current;</span><br></pre></td></tr></table></figure><p>ref 的值根据节点的类型而有所不同：</p><ul><li>当 <code>ref</code> 属性用于 <strong>HTML 元素</strong>时，构造函数中使用 <code>React.createRef()</code> 创建的 <code>ref</code> 接收底层 DOM 元素作为其 <code>current</code> 属性。</li><li>当 <code>ref</code> 属性用于<strong>自定义 class 组件</strong>时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性。</li><li><strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为他们<strong>没有实例</strong>。</li></ul><h5 id="Refs-与函数组件"><a href="#Refs-与函数组件" class="headerlink" title="Refs 与函数组件"></a>Refs 与函数组件</h5><p>默认情况下，<strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为它们没有实例。</p><p>如果要在函数组件中使用 <code>ref</code>，你可以使用 <code>forwardRef</code>（可与 <code>useImperativeHandle</code>结合使用）。</p><p>但你可以<strong>在函数组件内部使用 <code>ref</code> 属性</strong>，只要它<strong>指向一个 DOM 元素或 class 组件</strong>。</p><h2 id="React组件通信如何实现"><a href="#React组件通信如何实现" class="headerlink" title="React组件通信如何实现?"></a>React组件通信如何实现?</h2><blockquote><p>由于<code>React</code>是单向数据流，主要思想是组件不会改变接收的数据，只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值。因此，可以看到通信过程中，数据的存储位置都是存放在上级位置中。</p></blockquote><p>React组件间通信方式:</p><ul><li><strong>父组件</strong>向<strong>子组件</strong>通讯: 父组件可以向子组件通过传 <strong>props</strong> 的方式，向子组件进行通讯</li><li><strong>子组件</strong>向<strong>父组件</strong>通讯: <strong>props+回调</strong>的方式,父组件向子组件传递props进行通讯，此props为<strong>作用域为父组件自身的函数</strong>，子组件调用该函数，将子组件想要传递的信息，作为参数，<strong>传递到父组件的作用域中</strong>。</li><li>兄弟组件通信: <strong>找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信息进行通信</strong></li><li>跨层级通信: <code>Context</code>设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言,对于<strong>跨越多层的全局数据</strong>通过<code>Context</code>通信再适合不过。</li><li>发布订阅模式: <strong>发布者发布事件，订阅者监听事件并做出反应</strong>,我们可以通过引入event模块进行通信。</li><li>全局状态管理工具: 借助<code>Redux</code>或者<code>Mobx</code>等全局状态管理工具进行通信,这种工具会<strong>维护一个全局状态中心Store,并根据不同的事件产生新的状态</strong>。</li></ul><p>比较好的搭配方式</p><ul><li>父子组件：props</li><li>兄弟组件：消息订阅-发布、集中式管理</li><li>祖孙组件(跨级组件)：消息订阅-发布、集中式管理、Context(开发用的少，封装插件用的多)</li></ul><h2 id="你真的了解-React-生命周期吗？"><a href="#你真的了解-React-生命周期吗？" class="headerlink" title="你真的了解 React 生命周期吗？"></a>你真的了解 React 生命周期吗？</h2><h3 id="Hooks-组件"><a href="#Hooks-组件" class="headerlink" title="Hooks 组件"></a>Hooks 组件</h3><p><strong>函数组件</strong> 的本质是函数，没有 state 的概念的，因此<strong>不存在生命周期</strong>一说，仅仅是一个 <strong>render 函数</strong>而已。</p><p>但是引入 <strong>Hooks</strong> 之后就变得不同了，它能让组件在不使用 class 的情况下使用 state 以及其他的 React特性，相比与 class 的生命周期概念来说，它更接近于实现状态同步，而不是响应生命周期事件。但我们可以利用 <code>useState</code>、 <code>useEffect()</code> 和 <code>useLayoutEffect()</code> 来模拟实现生命周期。</p><p>即：<strong>Hooks 组件更接近于实现状态同步，而不是响应生命周期事件</strong>。</p><p>下面，是具体的 生命周期 与 Hooks 的<strong>对应关系</strong>：</p><table><thead><tr><th>class 组件</th><th>Hooks /函数式组件</th></tr></thead><tbody><tr><td>constructor</td><td>useState</td></tr><tr><td>getDerivedStateFromProps</td><td>useState 里面 update 函数</td></tr><tr><td>shouldComponentUpdate</td><td>useMemo</td></tr><tr><td>render</td><td>函数本身</td></tr><tr><td>componentDidMount</td><td>useEffect</td></tr><tr><td>componentDidUpdate</td><td>useEffect</td></tr><tr><td>componentWillUnmount</td><td>useEffect 里面返回的函数</td></tr></tbody></table><h3 id="单个组件的生命周期"><a href="#单个组件的生命周期" class="headerlink" title="单个组件的生命周期"></a>单个组件的生命周期</h3><h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>当<strong>组件实例被创建并插入 DOM 中</strong>时，其生命周期调用顺序如下：</p><ul><li><strong><code>constructor()</code></strong></li><li><strong><code>render()</code></strong></li><li><strong><code>componentDidMount()</code></strong></li></ul><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>当<strong>组件的 props 或 state 发生变化时会触发更新</strong>。组件更新的生命周期调用顺序如下：</p><ul><li><code>shouldComponentUpdate()</code></li><li><strong><code>render()</code></strong></li><li><strong><code>componentDidUpdate()</code></strong></li></ul><h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><p>当<strong>组件从 DOM 中移除时</strong>会调用如下方法：</p><ul><li><strong><code>componentWillUnmount()</code></strong></li></ul><h4 id="常用的生命周期方法"><a href="#常用的生命周期方法" class="headerlink" title="常用的生命周期方法"></a>常用的生命周期方法</h4><h5 id="constructor-props"><a href="#constructor-props" class="headerlink" title="constructor(props)"></a>constructor(props)</h5><p><strong>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。</strong></p><p>在 React 组件挂载之前，会调用它的构造函数。在为 React.Component 子类实现构造函数时，应在其他语句之前调用 <code>super(props)</code>。否则，<code>this.props</code> 在构造函数中可能会出现未定义的 bug。</p><p>通常，在 React 中，构造函数仅用于以下两种情况：</p><ul><li>通过给 <code>this.state</code> 赋值对象来<strong>初始化内部 state</strong>。</li><li><strong>为事件处理函数绑定实例</strong>。</li></ul><h5 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h5><p><code>componentDidMount()</code> 会在<strong>组件挂载后（插入 DOM 树中）立即调用</strong>。</p><p><strong>依赖于 DOM 节点的初始化</strong>应该放在这里。如需<strong>通过网络请求获取数据</strong>，此处是实例化请求的好地方。</p><p>这个方法是<strong>比较适合添加订阅</strong>的地方。如果添加了订阅，请不要忘记在 <code>componentWillUnmount()</code> 里<strong>取消订阅</strong>。</p><p>你可以在 <code>componentDidMount()</code> 里**直接调用 <code>setState()</code>**。</p><p>它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。</p><p>如此保证了即使在 <code>render()</code> 两次调用的情况下，用户也不会看到中间状态。</p><h5 id="componentDidUpdate-prevProps-prevState-snapshot"><a href="#componentDidUpdate-prevProps-prevState-snapshot" class="headerlink" title="componentDidUpdate(prevProps, prevState, snapshot)"></a>componentDidUpdate(prevProps, prevState, snapshot)</h5><p><code>componentDidUpdate()</code> 会在<strong>更新后会被立即调用</strong>。首次渲染不会执行此方法。</p><p>当组件更新后，可以在此处对 DOM 进行操作。</p><p>如果你<strong>对更新前后的 props 进行了比较，也可以选择在此处进行网络请求</strong>。（例如，当 props 未发生变化时，则不会执行网络请求）。</p><p>你也可以在 <code>componentDidUpdate()</code> 中<strong>直接调用 <code>setState()</code><strong>，但请注意</strong>它必须被包裹在一个条件语句里</strong>，正如上述的例子那样进行处理，否则会导致死循环。</p><p>它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。</p><h5 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h5><p><code>componentWillUnmount()</code> 会在<strong>组件卸载及销毁之前直接调用</strong>。</p><p>在此方法中执行必要的清理操作，例如，<strong>清除 timer</strong>，<strong>取消网络请求</strong>或<strong>清除</strong>在 <code>componentDidMount()</code> 中创建的<strong>订阅</strong>等。</p><p><code>componentWillUnmount()</code> 中<strong>不应调用 <code>setState()</code><strong>，因为</strong>该组件将永远不会重新渲染</strong>。</p><p>组件实例卸载后，将永远不会再挂载它。</p><h4 id="不常用的生命周期方法"><a href="#不常用的生命周期方法" class="headerlink" title="不常用的生命周期方法"></a>不常用的生命周期方法</h4><p>本节中的生命周期方法并不太常用。它们偶尔会很方便，但是大部分情况下组件可能都不需要它们。</p><h5 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h5><p>根据 <code>shouldComponentUpdate()</code> 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。</p><p>默认行为是 <strong>state 每次发生变化组件都会重新渲染</strong>。大部分情况下，你应该遵循默认行为。</p><p><strong>当 props 或 state 发生变化时</strong>，<code>shouldComponentUpdate()</code> 会在渲染执行之前被调用。返回值默认为 true。</p><p>首次渲染或使用 <code>forceUpdate()</code> 时不会调用该方法。</p><p>此方法仅作为<strong>性能优化的方式</strong>而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。</p><p>你应该<strong>考虑使用内置的 <code>PureComponent</code> 组件</strong>，而不是手动编写 <code>shouldComponentUpdate()</code>。</p><p><code>PureComponent</code> 会<strong>对 props 和 state 进行浅层比较</strong>，并减少了跳过必要更新的可能性。</p><h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><blockquote><p>一系列以 <code>“use”</code> 作为开头的方法，它们提供了让你可以完全避开 <code>class式写法</code>，在函数式组件中完成生命周期、状态管理、逻辑复用等几乎全部组件开发工作的能力。</p></blockquote><p><strong>好处:</strong></p><ul><li><strong>跨组件复用</strong>: 其实render props / <strong>HOC</strong> 也是为了复用，相比于它们，Hooks 作为官方的底层 API，最为轻量，而且改造成本小，不会影响原来的组件层次结构和传说中的<strong>嵌套地狱</strong>；</li><li>相比而言，<strong>类组件的实现更为复杂</strong><ul><li><strong>不同的生命周期会使逻辑变得分散且混乱，不易维护和管理</strong>；</li><li><strong>时刻需要关注this的指向问题</strong>；</li><li><strong>代码复用代价高</strong>，<strong>高阶组件</strong>的使用经常会使整个组件树变得臃肿；</li></ul></li><li><strong>状态与 UI 隔离</strong>: 正是由于 Hooks 的特性，状态逻辑会变成更小的粒度，并且极容易被抽象成一个<strong>自定义 Hooks</strong>，组件中的状态和 UI 变得更为清晰和隔离。</li></ul><h3 id="Hook-规则"><a href="#Hook-规则" class="headerlink" title="Hook 规则"></a>Hook 规则</h3><h4 id="只在最顶层使用-Hook"><a href="#只在最顶层使用-Hook" class="headerlink" title="只在最顶层使用 Hook"></a>只在最顶层使用 Hook</h4><p><strong>不要在循环，条件或嵌套函数中调用 Hook，</strong> 确保总是在你的 <strong>React 函数的最顶层以及任何 return 之前调用他们</strong>。</p><p>遵守这条规则，你就能<strong>确保 Hook 在每一次渲染中都按照同样的顺序被调用</strong>。</p><p>这让 React 能够在多次的 <code>useState</code> 和 <code>useEffect</code> 调用之间保持 hook 状态的正确。</p><h4 id="只在-React-函数中调用-Hook"><a href="#只在-React-函数中调用-Hook" class="headerlink" title="只在 React 函数中调用 Hook"></a>只在 React 函数中调用 Hook</h4><p><strong>不要在普通的 JavaScript 函数中调用 Hook。</strong>你可以：</p><ul><li>在 <strong>React 的函数组件</strong>中调用 Hook</li><li>在<strong>自定义 Hook</strong> 中调用其他 Hook</li></ul><p>遵循此规则，<strong>确保组件的状态逻辑在代码中清晰可见</strong>。</p><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><h4 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h4><blockquote><p>用于定义组件的 State，类似类定义中 <code>this.state</code> 的功能。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(initialState);</span><br></pre></td></tr></table></figure><ul><li><p><code>useState()</code> 方法里面唯一的参数<code>initialState</code>就是<strong>初始 state</strong>。</p><p>不同于 class 的是，我们可以按照需要使用数字或字符串对其进行赋值，而<strong>不一定是对象</strong>。</p></li><li><p>返回值为：<strong>当前 state</strong> 以及<strong>更新 state 的函数</strong>。</p><p>这与 class 里面 <code>this.state.count</code> 和 <code>this.setState</code> 类似，唯一区别就是你需要成对的获取它们。</p></li></ul><p><code>setState</code> 函数用于更新 state。它接收一个<strong>新的 state 值</strong>并将<strong>组件的一次重新渲染加入队列</strong>。</p><p>在后续的重新渲染中，<code>useState</code> 返回的第一个值将始终是<strong>更新后最新的 state</strong>。</p><blockquote><p>React 会确保 <code>setState</code> 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>setState</code>。</p></blockquote><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><h5 id="能用其他状态计算出来就不用单独声明状态。"><a href="#能用其他状态计算出来就不用单独声明状态。" class="headerlink" title="能用其他状态计算出来就不用单独声明状态。"></a>能用其他状态计算出来就不用单独声明状态。</h5><p>一个 state 必须不能通过其它 state/props 直接计算出来，否则就不用定义 state。</p><h5 id="保证数据源唯一"><a href="#保证数据源唯一" class="headerlink" title="保证数据源唯一"></a>保证数据源唯一</h5><p>在项目中同一个数据，保证只存储在一个地方。</p><p>不要既存在 redux 中，又在组件中定义了一个 state 存储。</p><p>不要既存在父级组件中，又在当前组件中定义了一个 state 存储。</p><p>不要既存在 url query 中，又在组件中定义了一个 state 存储。</p><h5 id="useState-适当合并"><a href="#useState-适当合并" class="headerlink" title="useState 适当合并"></a>useState 适当合并</h5><p>如果我们想使用多个 state 变量，它允许我们<strong>给不同的 state 变量取不同的名称</strong>。</p><p>State 变量可以很好地存储<strong>对象和数组</strong>，因此，你仍然可以将<strong>相关数据</strong>分为一组。</p><p>然而，不像 class 中的 <code>this.setState</code>，<strong>更新 state 变量总是替换它而不是合并它</strong>。</p><p>同样含义的变量可以合并成一个 state，代码可读性会提升很多：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [userInfo, setUserInfo] = useState(&#123;</span><br><span class="line">  firstName,</span><br><span class="line">  lastName,</span><br><span class="line">  school,</span><br><span class="line">  age,</span><br><span class="line">  address</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [weather, setWeather] = useState();</span><br><span class="line"><span class="keyword">const</span> [room, setRoom] = useState();</span><br></pre></td></tr></table></figure><p>当然这种方式我们在变更变量时，一定不要忘记带上老的字段，比如我们只想修改 <code>firstName</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setUserInfo(<span class="function"><span class="params">s</span>=&gt;</span> (&#123;</span><br><span class="line">  ...s,</span><br><span class="line">  fristName,</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>其实如果是 React Class 组件，state 是会自动合并的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  firstName</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="函数式更新"><a href="#函数式更新" class="headerlink" title="函数式更新"></a>函数式更新</h5><p>如果新的 state 需要通过使用<strong>先前的 state</strong> 计算得出，那么可以将函数传递给 <code>setState</code>。</p><p>该函数将接收先前的 state，并返回一个更新后的值。下面的计数器组件示例展示了 <code>setState</code> 的两种用法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(initialCount);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      Count: &#123;count&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(initialCount)&#125;&gt;Reset<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“+” 和 “-” 按钮采用函数式形式，因为被更新的 state 需要基于之前的 state。</p><p>但是“重置”按钮则采用普通形式，因为它总是把 count 设置回初始值。</p><p>如果你的<strong>更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过</strong>。</p><p>与 class 组件中的 <code>setState</code> 方法不同，<code>useState</code> 不会自动合并更新对象。你可以用函数式的 <code>setState</code> 结合<strong>展开运算符</strong>来达到合并更新对象的效果。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(&#123;&#125;);</span><br><span class="line">setState(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 也可以使用 Object.assign</span></span><br><span class="line">  <span class="keyword">return</span> &#123;...prevState, ...updatedValues&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>useReducer</code> 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。</p><h5 id="惰性初始-state"><a href="#惰性初始-state" class="headerlink" title="惰性初始 state"></a>惰性初始 state</h5><p><code>initialState</code> 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。</p><p>如果初始 state 需要通过<strong>复杂计算</strong>获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> initialState = someExpensiveComputation(props);</span><br><span class="line">  <span class="keyword">return</span> initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="跳过-state-更新"><a href="#跳过-state-更新" class="headerlink" title="跳过 state 更新"></a>跳过 state 更新</h5><p>调用 State Hook 的更新函数并传入当前的 state 时，React 将跳过子组件的渲染及 effect 的执行。</p><p>（React 使用 <code>Object.is</code> 比较算法来比较 state。）</p><p>需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code> 来进行优化。</p><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><blockquote><p>数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。不管你知不知道这些操作，或是“副作用”这个名字，应该都在组件中使用过它们。</p><p>如果你熟悉 React class 的生命周期函数，你可以把 <code>useEffect</code> Hook 看做 <code>componentDidMount</code>，<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 这三个函数的组合。</p><p>在 React 组件中有两种常见副作用操作：需要清除的和不需要清除的。我们来更仔细地看一下他们之间的区别。</p></blockquote><h4 id="无需清除的-effect"><a href="#无需清除的-effect" class="headerlink" title="无需清除的 effect"></a>无需清除的 effect</h4><p>有时候，我们只想<strong>在 React 更新 DOM 之后运行一些额外的代码。</strong>比如<strong>发送网络请求</strong>，<strong>手动变更 DOM</strong>，<strong>记录日志</strong>，这些都是常见的无需清除的操作。</p><p><strong><code>useEffect</code> 做了什么？</strong></p><p>通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行某些操作。</p><p>React 会<strong>保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它</strong>。</p><p><strong>为什么在组件内部调用 <code>useEffect</code>？</strong></p><p>将 <code>useEffect</code> 放在组件内部让我们可以在 effect 中直接访问 <code>state</code> 变量（或其他 <code>props</code>）。</p><p>我们不需要特殊的 API 来读取它 —— 它已经保存在函数作用域中。</p><p><strong>Hook使用了 JavaScript 的闭包机制</strong>，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。</p><p><strong><code>useEffect</code> 会在每次渲染后都执行吗？</strong></p><p>是的，默认情况下，它在<strong>第一次渲染之后</strong>和<strong>每次更新之后</strong>都会执行。</p><p>你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。</p><p>React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。</p><blockquote><p>与 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 不同，使用 <code>useEffect</code> 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 <code>useLayoutEffect</code> Hook 供你使用，其 API 与 <code>useEffect</code> 相同。</p></blockquote><h4 id="需要清除的-effect"><a href="#需要清除的-effect" class="headerlink" title="需要清除的 effect"></a>需要清除的 effect</h4><p>之前，我们研究了如何使用不需要清除的副作用，还有一些副作用是需要清除的。例如<strong>订阅外部数据源</strong>。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！</p><p><strong>为什么要在 effect 中返回一个函数？</strong></p><p>这是 effect 可选的清除机制。每个 effect 都可以返回一个<strong>清除函数</strong>。</p><p>如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</p><p><strong>React 何时清除 effect？</strong></p><p>React 会在<strong>组件卸载</strong>的时候执行清除操作。</p><p>正如之前学到的，effect 在每次渲染的时候都会执行。</p><p>这就是为什么 <strong>React 会在执行当前 effect 之前对上一个 effect 进行清除</strong>。</p><blockquote><p>并不是必须为 effect 中返回的函数命名。这里我们将其命名为 <code>cleanup</code> 是为了表明此函数的目的，但其实也可以返回一个箭头函数或者给起一个别的名字。</p></blockquote><h4 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h4><h5 id="使用多个-Effect-实现关注点分离"><a href="#使用多个-Effect-实现关注点分离" class="headerlink" title="使用多个 Effect 实现关注点分离"></a>使用多个 Effect 实现关注点分离</h5><p>使用 Hook 其中一个目的就是要<strong>解决 class 中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题</strong>。</p><p><strong>Hook 允许我们按照代码的用途分离他们，</strong> 而不是像生命周期函数那样。</p><p>React 将按照 effect 声明的顺序依次调用组件中的每一个 effect。</p><h5 id="通过跳过-Effect-进行性能优化"><a href="#通过跳过-Effect-进行性能优化" class="headerlink" title="通过跳过 Effect 进行性能优化"></a>通过跳过 Effect 进行性能优化</h5><p>在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题。</p><p>在 class 组件中，我们可以通过在 <code>componentDidUpdate</code> 中添加对 <code>prevProps</code> 或 <code>prevState</code> 的比较逻辑解决：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevState.count !== <span class="built_in">this</span>.state.count) &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;<span class="built_in">this</span>.state.count&#125;</span> times`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是很常见的需求，所以它被内置到了 <code>useEffect</code> 的 Hook API 中。</p><p>如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React <strong>跳过</strong>对 effect 的调用，只要传递数组作为 <code>useEffect</code> 的第二个可选参数即可：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// 仅在 count 更改时更新</span></span><br></pre></td></tr></table></figure><p>如果你要使用此优化方式，请确保数组中包含了<strong>所有外部作用域中会随时间变化并且在 effect 中使用的变量</strong>，否则你的代码会引用到<strong>先前渲染中的旧变量</strong>。</p><p>要记住 effect 外部的函数使用了哪些 props 和 state 很难。</p><p>这也是为什么 <strong>通常你会想要在 effect 内部去声明它所需要的函数。</strong></p><p><strong>只有</strong> 当函数（以及它所调用的函数）<strong>不引用 props、state 以及由它们衍生而来的值时</strong>，你才能放心地把它们从依赖列表中省略。</p><p><strong>如果出于某些原因你无法 把一个函数移动到 effect 内部，还有一些其他办法：</strong></p><ul><li><strong>你可以尝试把那个函数移动到你的组件之外</strong>。那样一来，这个函数就肯定不会依赖任何 props 或 state，并且也不用出现在依赖列表中了。</li><li>如果你所调用的方法是一个纯计算，并且可以在渲染时调用，你可以 <strong>转而在 effect 之外调用它，</strong> 并让 effect 依赖于它的返回值。</li><li>万不得已的情况下，你可以 <strong>把函数加入 effect 的依赖但把它的定义包裹</strong> 进 <code>useCallback</code>Hook。这就<strong>确保了它不随渲染而改变</strong>，除非它自身的依赖发生了改变。</li></ul><h5 id="如果我的-effect-的依赖频繁变化，我该怎么办？"><a href="#如果我的-effect-的依赖频繁变化，我该怎么办？" class="headerlink" title="如果我的 effect 的依赖频繁变化，我该怎么办？"></a>如果我的 effect 的依赖频繁变化，我该怎么办？</h5><p>可以使用 <code>setState</code> 的函数式更新形式。它允许我们<strong>指定 state 该如何改变而不用引用当前 state</strong>：</p><p>在一些更加复杂的场景中（比如<strong>一个 state 依赖于另一个 state</strong>），尝试用 <code>useReducer</code> Hook把 state 更新逻辑移到 effect 之外。</p><p><strong><code>useReducer</code> 的 <code>dispatch</code> 的身份永远是稳定的</strong> —— 即使 reducer 函数是定义在组件内部并且依赖 props。</p><p>万不得已的情况下，如果你想要类似 class 中的 <code>this</code> 的功能，你可以<strong>使用一个 ref</strong> 来保存一个<strong>可变的变量</strong>。</p><h5 id="自己理解"><a href="#自己理解" class="headerlink" title="自己理解"></a>自己理解</h5><p>依赖的值可以设置多个，只要有一个更新，就会执行effect。</p><p><strong>放到 deps 数组中的变量变化时，就会触发 useEffect 函数执行。</strong></p><ul><li>一种方法是在依赖中只放入需要触发函数执行的变量，选择性忽略 <code>eslint-plugin-react-hooks</code> 插件的警告。<code>// eslint-disable-next-line</code></li><li>另一种方法是在依赖中写全所有外部作用域中会随时间变化并且在 effect 中使用的变量，如果effect有条件触发，自己写if判断，而不是靠依赖数组。<strong>即具体逻辑是否执行应该在内部自己判断，而不是交给react。</strong></li></ul><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><ul><li><p><strong>多次渲染之间保证唯一值的纽带</strong>。</p><p>useRef 会在所有的 render 中保持对返回值的唯一引用。因为所有对<code>ref</code>的赋值和取值拿到的都是最终的状态，并不会因为不同的 render 中存在不同的隔离。</p></li><li><p><strong>获取 Dom 元素</strong>，在 Function Component 中我们可以通过 useRef 来获取对应的 Dom 元素。</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = useRef(initialValue);</span><br></pre></td></tr></table></figure><p><code>useRef</code> 返回一个<strong>可变的 ref 对象</strong>，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。</p><p>返回的 ref 对象在组件的<strong>整个生命周期内</strong>持续存在。</p><p>一个常见的用例便是命令式地访问子组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span></span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputEl&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上，<code>useRef</code> 就像是可以在其 <code>.current</code> 属性中保存一个可变值的“盒子”。</p><p>你应该熟悉 ref 这一种访问 DOM的主要方式。</p><p>如果你将 ref 对象以 <code>&lt;div ref=&#123;myRef&#125; /&gt;</code> 形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 <code>.current</code> 属性设置为相应的 DOM 节点。</p><p>然而，<code>useRef()</code> 比 <code>ref</code> 属性更有用。它可以很方便地<strong>保存任何可变值</strong>，其类似于在 class 中使用实例字段的方式。</p><p>这是因为它创建的是一个<strong>普通Javascript 对象</strong>。</p><p>而 <code>useRef()</code> 和自建一个 <code>&#123;current: ...&#125;</code> 对象的唯一区别是，<code>useRef</code> 会在<strong>每次渲染时返回同一个 ref 对象</strong>。</p><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>返回一个<code>memoized</code>回调函数。</p><p>把内联回调函数及依赖项数组作为参数传入 <code>useCallback</code>，它将返回该回调函数的 memoized 版本，<strong>该回调函数仅在某个依赖项改变时才会更新</strong>。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 <code>shouldComponentUpdate</code>）的子组件时，它将非常有用。</p><p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p><h4 id="关于使用"><a href="#关于使用" class="headerlink" title="关于使用"></a>关于使用</h4><p>在项目中不要随意useCallback，一些场景下，不仅没有提升性能，反而让代码可读性变的很差。</p><p>useCallback 可以记住函数，避免函数重复生成，这样函数在传递给子组件时，可以避免子组件重复渲染，提高性能。</p><p>但我们要注意，提高性能还必须有另外一个条件，子组件必须使用了 <code>shouldComponentUpdate</code> 或者 <code>React.memo</code> 来忽略同样的参数重复渲染。</p><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p>返回一个memoized 值。</p><p>把“创建”函数和依赖项数组作为参数传入 <code>useMemo</code>，它仅会在某个依赖项改变时才重新计算 memoized 值。</p><p>这种优化有助于避免在每次渲染时都进行高开销的计算。</p><p>记住，传入 <code>useMemo</code> 的函数会在<strong>渲染期间</strong>执行。</p><p>请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴，而不是 <code>useMemo</code>。</p><p>如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值。</p><p><strong>你可以把 <code>useMemo</code> 作为性能优化的手段，但不要把它当成语义上的保证。</strong></p><p><code>useMemo</code> Hook 使得控制具体子节点何时更新变得更容易，减少了对纯组件的需要。</p><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure><ul><li>ref 表示需要<strong>被赋值的 ref 对象</strong>。</li><li>createHandle 函数的<strong>返回值</strong>作为 <code>ref.current</code> 的值。</li><li>deps 依赖数组，依赖发生变化会重新执行 createHandle 函数。</li></ul><blockquote><p>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用。</p></blockquote><p>当然，在日常 React 开发中可能会存在这样一种情况。<strong>我们希望在父组件中调用子组件的方法</strong>，虽然 React 官方并不推荐这样声明式的写法，但是有时候我们不得不这样做。</p><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure><p><code>useState</code>的替代方案。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。）</p><p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 <strong>state 逻辑较复杂且包含多个子值</strong>，或者<strong>下一个 state 依赖于之前的 state</strong> 等。并且，使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数 。</p><h3 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h3><p>通过自定义 Hook，可以将<strong>组件逻辑</strong>提取到<strong>可重用的函数</strong>中。</p><p><strong>自定义 Hook 是一个函数，其名称以 “<code>use</code>” 开头，函数内部可以调用其他的 Hook。</strong></p><p><strong>自定义 Hook 必须以 “<code>use</code>” 开头吗？</strong></p><p>必须如此。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了<strong>Hook的规则</strong>。</p><p><strong>在两个组件中使用相同的 Hook 会共享 state 吗？</strong></p><p>不会。自定义 Hook 是一种<strong>重用状态逻辑</strong>的机制(例如设置为订阅并存储当前值)，所以<strong>每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的</strong>。</p><p>我们可以在一个组件中多次调用 <code>useState</code> 和 <code>useEffect</code>，它们是完全独立的。</p><h2 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h2><h3 id="React-PureComponent"><a href="#React-PureComponent" class="headerlink" title="React.PureComponent"></a>React.PureComponent</h3><p><code>React.Component</code> 是使用ES6 classes方式定义 React 组件的基类。</p><p><code>React.PureComponent</code> 与 <code>React.Component</code>很相似。</p><p>两者的区别在于 <code>React.Component</code>并未实现 <code>shouldComponentUpdate()</code>，而 <code>React.PureComponent</code> 中以<strong>浅层对比</strong> <code>prop</code> 和 <code>state</code> 的方式来实现了该函数。</p><p>如果赋予 React 组件相同的 props 和 state，<code>render()</code> 函数会渲染相同的内容，那么在某些情况下使用 <code>React.PureComponent</code> 可提高性能。</p><h3 id="React-memo-1"><a href="#React-memo-1" class="headerlink" title="React.memo"></a>React.memo</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = React.memo(<span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>React.memo</code> 为高阶组件。</p><p>如果你的组件在相同 <code>props</code> 的情况下渲染相同的结果，那么你可以通过将其包装在 <code>React.memo</code> 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。</p><p>这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p><p><code>React.memo</code> <strong>仅检查 props 变更</strong>。</p><p>如果函数组件被 <code>React.memo</code> 包裹，且其实现中拥有 <code>useState</code>，<code>useReducer</code>或 <code>useContext</code> 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。</p><p>默认情况下其只会对复杂对象做<strong>浅层对比</strong>，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="redux理解"><a href="#redux理解" class="headerlink" title="redux理解"></a>redux理解</h2><ol><li>redux是一个专门用于做<strong>状态管理的JS库</strong>(不是react插件库)。</li><li>它可以用在react, angular, vue等项目中, 但基本与react配合使用。</li><li>作用: 集中式管理react应用中多个组件<strong>共享</strong>的状态。</li></ol><h3 id="什么情况下需要使用redux"><a href="#什么情况下需要使用redux" class="headerlink" title="什么情况下需要使用redux"></a>什么情况下需要使用redux</h3><ol><li>某个组件的状态，需要让其他组件可以随时拿到（共享）。</li><li>一个组件需要改变另一个组件的状态（通信）。</li><li>总体原则：能不用就不用, 如果不用比较吃力才考虑使用。</li></ol><h3 id="redux工作流程"><a href="#redux工作流程" class="headerlink" title="redux工作流程"></a>redux工作流程</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5W48UO"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/24/5W48UO.png" alt="5W48UO.png"></a></p><h2 id="redux的三个核心概念"><a href="#redux的三个核心概念" class="headerlink" title="redux的三个核心概念"></a>redux的三个核心概念</h2><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><ul><li><p><strong>动作的对象</strong></p></li><li><p>包含2个属性</p><p>type：标识属性, 值为字符串, 唯一, 必要属性</p><p>data：数据属性, 值类型任意, 可选属性</p></li><li><p>例子：<code>&#123; type: &#39;ADD_STUDENT&#39;,data:&#123;name: &#39;tom&#39;,age:18&#125; &#125;</code></p></li></ul><h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><ul><li><p><strong>用于初始化状态、加工状态</strong>。</p></li><li><p>加工时，根据旧的state和action， 产生新的state的<strong>纯函数</strong></p><ul><li>纯函数:一类特别的函数: 只要是同样的输入(实参)，必定得到同样的输出(返回)</li><li>必须遵守以下一些约束<ul><li><strong>不得改写参数数据</strong> <code>preState.unshift(data)</code></li><li>不会产生任何副作用，例如网络请求，输入和输出设备</li><li>不能调用<code>Date.now()</code>或者<code>Math.random()</code>等不纯的方法</li></ul></li></ul></li><li><p>redux的<strong>reducer函数必须是一个纯函数</strong></p></li></ul><h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><ul><li><p><strong>将state、action、reducer联系在一起的对象</strong></p></li><li><p>如何得到此对象?</p><ul><li><code>import &#123;createStore&#125; from &#39;redux&#39;</code></li><li><code>import reducer from &#39;./reducers&#39;</code></li><li><code>const store = createStore(reducer)</code></li></ul></li><li><p>此对象的功能?</p><ul><li><p><code>getState()</code>: 得到state</p></li><li><p><code>dispatch(action)</code>: 分发action, 触发reducer调用, 产生新的state</p></li><li><p><code>subscribe(listener)</code>: 注册监听, 当产生了新的state时, 自动调用</p></li></ul></li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指hash table就可以了）。</p><blockquote><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p></blockquote><p>其实直白来讲其实<strong>数组就是一张哈希表</strong>。</p><p>哈希表中关键码就是数组的索引下表，然后通过下表直接访问数组中的元素。</p><p>那么哈希表能解决什么问题呢，<strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li><strong>数组</strong></li><li><strong>set（集合）</strong></li><li><strong>map（映射）</strong></li></ul><p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈（stack）是一种运算受限的线性表：</p><p>栈的特点：<strong>先进后出</strong>。</p><blockquote><p>程序中的栈结构</p></blockquote><ul><li>函数调用栈：A(B(C(D())))：<br>即 A 函数中调用 B，B 调用 C，C 调用 D；在 A 执行的过程中会将 A 压入栈，随后 B 执行时 B 也被压入栈，函数 C 和 D 执行时也会被压入栈。所以当前栈的顺序为：A-&gt;B-&gt;C-&gt;D（栈顶）；函数 D 执行完之后，会弹出栈被释放，弹出栈的顺序为 D-&gt;C-&gt;B-&gt;A;</li><li>递归：<br>==为什么没有停止条件的递归会造成栈溢出？比如函数 A 为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数 A 压入栈，最后造成栈溢出（Queue Overfloat）==。</li></ul><blockquote><p>栈常见的操作</p></blockquote><ul><li><code>push()</code> 添加一个新元素到栈顶位置。</li><li><code>pop()</code> 移除栈顶的元素，同时返回被移除的元素。</li><li><code>peek()</code> 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）。</li><li><code>isEmpty()</code> 如果栈里没有任何元素就返回 <code>true</code>，否则返回 <code>false</code>。</li><li><code>size()</code> 返回栈里的元素个数。这个方法和数组的 <code>length</code> 属性类似。</li><li><code>toString()</code> 将栈结构的内容以字符串的形式返回。</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列（Queue）是一种运算受限的线性表，特点：先进先出。(FIFO：First In First Out)</p><p>事件循环中的宏任务和微任务队列。</p><p><strong>优先队列</strong></p><ul><li>每个元素不再只是一个数据，还包含优先级。</li><li>在添加元素过程中，根据优先级放入到正确位置。</li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一种通过<strong>指针</strong>串联在一起的线性结构，每一个节点由两部分组成，一个是<strong>数据域</strong>一个是<strong>指针域</strong>（存放指向下一个节点的指针），<strong>最后一个节点的指针域指向null</strong>（空指针的意思）。</p><p>链接的入口节点称为链表的头结点也就是<code>head</code>。</p><p>上面说的就是<strong>单链表</strong>。</p><p>单链表中的节点只能指向节点的下一个节点。</p><p><strong>双链表</strong>：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p><p><strong>双链表既可以向前查询也可以向后查询</strong>。</p><p><strong>循环链表</strong>，顾名思义，就是链表首尾相连。</p><p>链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><p>链表的增添和删除都是O(1)操作，也不会影响到其他节点。</p><p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p><p>链表的长度可以是不固定的，并且可以动态增删， <strong>适合数据量不固定，频繁增删，较少查询的场景</strong>。</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h4><ul><li><p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p><p>也可以说深度为k，有2^k-1个节点的二叉树。</p></li><li><p>完全二叉树：除了最<strong>底层节点可能没填满外</strong>，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层<strong>最左边的若干位置</strong>。若最底层为第 h 层，则该层包含 1~ 2^h -1 个节点。</p></li></ul><p><strong>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</strong></p><p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵<strong>空树</strong>或它的<strong>左右两个子树的高度差的绝对值不超过1</strong>，并且<strong>左右两个子树都是一棵平衡二叉树</strong>。</p><h4 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h4><p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p><p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p><p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在散落在各个地址的节点串联一起。</p><h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><p>关于二叉树的遍历方式，要知道二叉树遍历的基本方式都有哪些。</p><p>二叉树主要有两种遍历方式：</p><ol><li><strong>深度优先遍历</strong>：先往深走，遇到叶子节点再往回走。</li><li><strong>广度优先遍历</strong>：一层一层的去遍历。</li></ol><p><strong>这两种遍历是图论中最基本的两种遍历方式</strong>，后面在介绍图论的时候 还会介绍到。</p><p>那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p><ul><li>深度优先遍历<ul><li><strong>前序遍历（递归法，迭代法）</strong></li><li><strong>中序遍历（递归法，迭代法）</strong></li><li><strong>后序遍历（递归法，迭代法）</strong></li></ul></li><li>广度优先遍历<ul><li><strong>层次遍历（迭代法）</strong></li></ul></li></ul><p>在深度优先遍历中：有三个顺序，前中后序遍历， <strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，只要大家记住 前中后序指的就是中间节点的位置就可以了。</p><p><strong>之前我们讲栈与队列的时候，就说过栈其实就是递归的一种是实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助<strong>栈</strong>使用非递归的方式来实现的。</p><p>而广度优先遍历的实现一般使用<strong>队列</strong>来实现，这也是队列<strong>先进先出</strong>的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><h3 id="JS自带排序"><a href="#JS自带排序" class="headerlink" title="JS自带排序"></a>JS自带排序</h3><p><code>sort()</code> 方法对数组的元素进行<strong>就地排序</strong>并返回排序后的数组。</p><p>默认排序顺序是<strong>升序</strong>，将元素转换为<strong>字符串</strong>，然后比较它们的 <strong>UTF-16</strong> 代码单元值序列（根据每个字符的 Unicode 代码点值进行排序）。</p><p>排序的时间和空间复杂度不能保证，因为它取决于实现。</p><p>ASCII是计算机中最常用的编码方式，用于<strong>将字母，数字，标点符号和控制字符转换为计算机可以理解的数字形式</strong>。</p><p>UTF-8 (UCS Transformation Format 8)是<strong>万维网上最常用的字符编码</strong>。</p><p><strong>前 128 个 UTF-8 字符与前 128 个 ASCII 字符(编号为 0-127) 精确匹配</strong>。</p><p>在JavaScript中，所有的string类型都是使用<code>UTF-16</code>编码的。</p><p><code>str.charCodeAt()</code> 方法返回 <code>0</code> 到 <code>65535</code> 之间的整数，表示给定索引处的<strong>UTF-16代码单元</strong>。</p><h4 id="排序数组（仅数字）"><a href="#排序数组（仅数字）" class="headerlink" title="排序数组（仅数字）"></a>排序数组（仅数字）</h4><table><thead><tr><th align="left"><code>compareFunction(a, b)</code> return value</th><th align="left">sort order</th></tr></thead><tbody><tr><td align="left">&gt; 0</td><td align="left">sort <code>b</code> before <code>a</code></td></tr><tr><td align="left">&lt; 0</td><td align="left">sort <code>a</code> before <code>b</code></td></tr><tr><td align="left">=== 0</td><td align="left">keep original order of <code>a</code> and <code>b</code></td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b);<span class="comment">// 升序排序</span></span><br><span class="line">    <span class="comment">// nums.sort((a,b) =&gt; b-a);// 降序排序</span></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="数字和字符串联合排序"><a href="#数字和字符串联合排序" class="headerlink" title="数字和字符串联合排序"></a>数字和字符串联合排序</h4><p>n个人，先按身高排序，再按姓名排序，姓名只有小写英文字母，且各不相同。</p><p><strong>方法一</strong>：将身高字母放入map，{身高字母:字母}，对身高字母排序，最后返回所对应的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortSoldier = <span class="function">(<span class="params">n,h,s</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(),k=[];</span><br><span class="line">  <span class="keyword">let</span> res=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    k[i]=h[i]+s[i];</span><br><span class="line">    map.set(k[i],s[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  k.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 先按数字排序</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">parseInt</span>(a)!==<span class="built_in">parseInt</span>(b))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">parseInt</span>(a)-<span class="built_in">parseInt</span>(b);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 再按字母 +转数字 TRUE-&gt;1 FALSE-&gt;0</span></span><br><span class="line">      <span class="keyword">return</span> +(a&gt;b) || +(a&gt;b)-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 按排好的顺序从map中取值</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    res = res + map.get(k[i])+<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.trim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sortSoldier(<span class="number">4</span>,[<span class="number">123</span>,<span class="number">12</span>,<span class="number">196</span>,<span class="number">196</span>],[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;abcv&#x27;</span>,<span class="string">&#x27;abcd&#x27;</span>]))<span class="comment">//b a abcd abcv</span></span><br></pre></td></tr></table></figure><p><strong>方法二</strong>：也可创建一个二维数组，<code>[[身高1,字母1],[身高2,字母2]...]</code></p><p>将该数组用身高和字母排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortSoldier = <span class="function">(<span class="params">n,h,s</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">  <span class="keyword">let</span> res=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    arr[i]=[h[i],s[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]!==b[<span class="number">0</span>])&#123;</span><br><span class="line">      <span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> +(a[<span class="number">1</span>]&gt;b[<span class="number">1</span>]) || +(a[<span class="number">1</span>]&gt;b[<span class="number">1</span>])-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    res = res + arr[i][<span class="number">1</span>]+<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.trim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sortSoldier(<span class="number">4</span>,[<span class="number">123</span>,<span class="number">12</span>,<span class="number">196</span>,<span class="number">196</span>],[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;abcv&#x27;</span>,<span class="string">&#x27;abcd&#x27;</span>]))<span class="comment">//b a abcd abcv</span></span><br></pre></td></tr></table></figure><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><ul><li>冒泡排序只会操作<strong>相邻的两个数据</strong>。</li><li>每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。</li><li>一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 冒泡</span></span><br><span class="line">    <span class="keyword">let</span> hasChange;<span class="comment">// 提前停止标志位</span></span><br><span class="line">    <span class="comment">// 外层只需要length-1次就排好了，第length次比较是多余的，所以i&gt;0</span></span><br><span class="line">    <span class="comment">// 之所以从后向前是为了方便写内层循环的终止条件</span></span><br><span class="line">    <span class="comment">// i到length-1已经排好</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        hasChange = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                [nums[j], nums[j + <span class="number">1</span>]] = [nums[j + <span class="number">1</span>], nums[j]];<span class="comment">// 两两比较交换</span></span><br><span class="line">                hasChange = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hasChange) <span class="keyword">break</span>;<span class="comment">// 本轮没有数据交换，说明已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个<code>原地</code>排序算法。</p><p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。 为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序。 所以冒泡排序是<code>稳定</code>的排序算法。</p><p>最佳情况：<code>T(n) = O(n)</code>，当数据已经是正序时。 最差情况：<code>T(n) = O(n^2)</code>，当数据是反序时。 平均情况：<code>T(n) = O(n^2)</code>。</p><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>我们通常说的插入排序是指直接插入排序。</p><p>插入排序的工作原理：<strong>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</strong>。</p><p><strong>步骤</strong></p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤 2 ~ 5。</li></ul><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    <span class="keyword">let</span> preIndex,current;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        preIndex=i-<span class="number">1</span>;<span class="comment">// 待比较元素下标</span></span><br><span class="line">        current=nums[i];<span class="comment">// 当前元素</span></span><br><span class="line">        <span class="keyword">while</span>(preIndex&gt;=<span class="number">0</span> &amp;&amp; nums[preIndex]&gt;current)&#123;</span><br><span class="line">            <span class="comment">// 待比较元素比当前元素大，后移</span></span><br><span class="line">            nums[preIndex+<span class="number">1</span>]=nums[preIndex];</span><br><span class="line">            preIndex--;<span class="comment">//下标左移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束，preIndex + 1即为当前元素应该插入的位置，但避免同一个元素赋值给自身</span></span><br><span class="line">        <span class="keyword">if</span> (preIndex + <span class="number">1</span> != i) nums[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，所以，这是一个<code>原地</code>排序算法。</p><p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是<code>稳定</code>的排序算法。</p><p>最佳情况：<code>T(n) = O(n)</code>，当数据已经是正序时。 最差情况：<code>T(n) = O(n^2)</code>，当数据是反序时。 平均情况：<code>T(n) = O(n^2)</code>。</p><h3 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h3><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序<strong>每次会从未排序区间中找到最大（小）的元素，将其放到已排序区间的末尾。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 选择</span></span><br><span class="line">    <span class="keyword">let</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        minIndex=i;</span><br><span class="line">        <span class="comment">// 寻找未排序中最小数的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j= i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;nums[minIndex]) minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将未排序中最小的数放到已排序好数组的最后</span></span><br><span class="line">        [nums[i],nums[minIndex]]=[nums[minIndex],nums[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>选择排序空间复杂度为 O(1)，是一种<code>原地</code>排序算法。</p><p>选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。所以，选择排序是一种<code>不稳定</code>的排序算法。</p><p>无论是正序还是逆序，选择排序都会遍历 <code>T = （n-1)）+ （n -2）+（n - 3）.... + 1; ===&gt;&gt; T = [n*(n-1) ] / 2；</code> 次来排序，所以，最佳、最差和平均的复杂度是一样的。 最佳情况：<code>T(n) = O(n^2)</code>。 最差情况：<code>T(n) = O(n^2)</code>。 平均情况：<code>T(n) = O(n^2)</code>。</p><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><ul><li>先找到一个基准点（一般指数组的中部<code>midIndex</code>），然后数组被该基准点分为两部分，依次与该基准点数据<code>mid</code>比较，如果比它小，放左边；反之，放右边。</li><li>左右分别用一个空数组去存储比较后的数据。</li><li>最后递归执行上述操作，直到数组长度 &lt;= 1;</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 快排</span></span><br><span class="line">    <span class="keyword">const</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">1</span>) <span class="keyword">return</span> nums;<span class="comment">// 同时是递归终止条件</span></span><br><span class="line">    <span class="comment">// 基准点</span></span><br><span class="line">    <span class="keyword">let</span> midIndex=<span class="built_in">Math</span>.floor(len/<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// splice会从原数组中删除基准点数据，并返回一个数组</span></span><br><span class="line">    <span class="keyword">let</span> midNum = nums.splice(midIndex,<span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 依次与该基准点数据mid比较，如果比它小，放左边；反之，放右边</span></span><br><span class="line">    <span class="keyword">let</span> left=[],right=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        num&lt;midNum ? left.push(num) : right.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归执行上述操作</span></span><br><span class="line">    <span class="keyword">return</span> [...sortArray(left),midNum,...sortArray(right)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>缺点：需要另外声明两个数组，浪费了内存空间资源。</p><p>优化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 快排（优化空间复杂度）</span></span><br><span class="line">    <span class="comment">// 该方法并不需要基准值左边都比它小，右边都比它大</span></span><br><span class="line">    <span class="comment">// 而是左区间内都小于等于基准值，右区间都大于等于基准值</span></span><br><span class="line">    <span class="keyword">const</span> quickSort = <span class="function">(<span class="params">nums, left, right</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;<span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="comment">// 基准点及其对应数据</span></span><br><span class="line">        <span class="keyword">const</span> midNum = nums[<span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>)];</span><br><span class="line">        <span class="comment">//记录本次递归的左右边界</span></span><br><span class="line">        <span class="keyword">const</span> l=left,r=right;</span><br><span class="line">        <span class="comment">// 每一次递归结束后，[l,left-1]都是小于等于基准值的，[left,r]都大于等于基准值</span></span><br><span class="line">        <span class="comment">// 取等号的原因：left=right!=midIndex时,</span></span><br><span class="line">        <span class="comment">// 仍要判断nums[left]与midNum关系，来确定nums[left]属于哪个区间</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123; </span><br><span class="line">            <span class="keyword">while</span>(nums[left]&lt;midNum) left++;</span><br><span class="line">            <span class="keyword">while</span>(nums[right]&gt;midNum) right--;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;=right)&#123;</span><br><span class="line">                [nums[left],nums[right]]=[nums[right],nums[left]];</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归执行上述操作</span></span><br><span class="line">        quickSort(nums,l,left-<span class="number">1</span>);</span><br><span class="line">        quickSort(nums,left,r)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化的算法进行分区时，不需要很多额外的内存空间，所以快排是<code>原地排序</code>算法。</p><p>快速排序每次交换的元素都有可能不是相邻的，因此它有可能打破原来值为相同的元素之间的顺序。因此，快速排序并<code>不稳定</code>。</p><p>极端的例子：如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为基准点，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n / 2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n^2)。快排时间复杂度与基准点的选取有关，一般取中部最优。</p><p>最佳情况：<code>T(n) = O(nlog n)</code>。 最差情况：<code>T(n) = O(n^2)</code>。 平均情况：<code>T(n) = O(nlogn)</code>。</p><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p><strong>思想</strong></p><p>排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><p>归并排序采用的是<code>分治思想</code>。</p><p>分治，顾名思义，就是分而治之，将<strong>一个大问题分解成小的子问题来解决</strong>。小的子问题解决了，大问题也就解决了。</p><p>这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。所以，归并排序<code>不是</code>原地排序算法。</p><p>归并排序<code>是稳定</code>的排序方法。</p><p>最佳情况：<code>T(n) = O(n log n)</code>。 最差情况：<code>T(n) = O(n log n)</code>。 平均情况：<code>T(n) = O(n log n)</code>。</p><p><strong>归并排序与快速排序：</strong></p><ul><li>归并排序的处理过程是<code>由下而上</code>的，先处理子问题，然后再合并。</li><li>而快排正好相反，它的处理过程是<code>由上而下</code>的，先分区，然后再处理子问题。</li><li>归并排序虽然是<strong>稳定的</strong>、时间复杂度为<code>O(nlogn)</code> 的排序算法，但是它是<strong>非原地</strong>排序算法。</li><li>快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，它是一种<strong>选择排序</strong>，最坏 、最好、平均时间复杂度均为 <code>O(nlogn)</code>，它是<strong>不稳定排序</strong>。</p><p>注意因为完全二叉树的性质，可以用数组表示对应的树结构（所以，堆排序过程中，你是看不到树这数据结构的，用数组进行映射了），这叫顺序存储。</p><p>堆是具有以下性质的完全二叉树：</p><ul><li><p>大顶堆：每个节点的值都<strong>大于或等于</strong>其左右孩子节点的值</p><p>注：<strong>没有要求左右值的大小关系</strong></p></li><li><p>小顶堆：每个节点的值都<strong>小于或等于</strong>其左右孩子节点的值</p></li></ul><p><strong>排序说明</strong></p><p>升序：一般采用大顶堆</p><p>降序：一般采用小顶堆</p><p><strong>基本思想</strong></p><ul><li><p>将待排序序列构造成一个<strong>大顶堆</strong></p><p>注意：这里使用的是<strong>数组</strong>，而不是一颗二叉树</p></li><li><p>此时：整个序列的最大值就是<strong>堆顶的根节点</strong></p></li><li><p>将其<strong>与末尾元素进行交换</strong>，此时末尾就是最大值</p></li><li><p>然后将剩余 n-1 个元素<strong>重新构造成一个堆</strong>，这样 就会得到 n 个元素的次小值。如此反复，便能的得到一个有序序列。</p></li></ul><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><ul><li>先将整个待排序的记录序列分割成为<strong>若干子序列</strong>。</li><li>分别进行<strong>直接插入排序</strong>。</li><li>待整个序列中的记录基本有序时，再对全体记录进行<strong>依次直接插入排序</strong>。</li></ul><p>希尔排序过程中，只涉及相邻数据的交换操作，只需要常量级的临时空间，空间复杂度为 O(1) 。所以，希尔排序是<code>原地排序</code>算法。</p><p>单次直接插入排序是稳定的，它不会改变相同元素之间的相对顺序，但在多次不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，可能导致相同元素相对顺序发生变化。 因此，希尔排序<code>不稳定</code>。</p><p>最佳情况：<code>T(n) = O(nlogn)</code>。 最差情况：<code>T(n) = O(n(logn)^2)</code>。 平均情况：<code>T(n) = O(n(logn)^2)</code>。</p><h2 id="有效的括号（栈-哈希表Map）"><a href="#有效的括号（栈-哈希表Map）" class="headerlink" title="有效的括号（栈+哈希表Map）"></a>有效的括号（栈+哈希表Map）</h2><p>我们遍历给定的字符串 s。</p><p>当我们遇到一个<strong>左括号</strong>时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。</p><p>由于<strong>后遇到的左括号要先闭合</strong>，因此我们可以将这个<strong>左括号放入栈顶</strong>。</p><p>当我们遇到一个<strong>右括号</strong>时，我们需要将一个相同类型的左括号闭合。</p><p>此时，我们可以<strong>取出栈顶的左括号</strong>并判断它们是否是相同类型的括号。</p><p>如果<strong>不是相同的类型</strong>，或者栈中并<strong>没有左括号</strong>，那么字符串 s 无效，返回 <code>False</code>。</p><p>为了快速判断括号的类型，我们可以使用<strong>哈希表</strong>存储每一种括号。</p><p>哈希表的<strong>键为右括号</strong>，<strong>值为相同类型的左括号</strong>。</p><p>在遍历结束后，如果<strong>栈中没有左括号</strong>，说明我们将字符串 s 中的所有左括号闭合，返回 <code>True</code>，否则返回 False。</p><p>注意到有效字符串的长度一定为<strong>偶数</strong>，因此如果字符串的长度为<strong>奇数</strong>，我们可以直接返回<code>False</code>，省去后续的遍历判断过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isValid = <span class="function"><span class="params">s</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = s.length;</span><br><span class="line">    <span class="comment">// 如果字符数为奇数一定无效</span></span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>===<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// map存储括号</span></span><br><span class="line">    <span class="comment">// 将数组传入Map构造函数，就可以转为 Map</span></span><br><span class="line">    <span class="keyword">const</span> pairs = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">        [<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;(&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;[&#x27;</span>]</span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">const</span> stack =[];<span class="comment">// 栈 存放左括号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s)&#123;      </span><br><span class="line">        <span class="keyword">if</span>(pairs.has(ch))&#123;</span><br><span class="line">            <span class="comment">// 如果遇到右括号，但栈里没有左括号或最后一个左括号不能与之对应</span></span><br><span class="line">            <span class="comment">// 返回false</span></span><br><span class="line">            <span class="keyword">if</span>( !stack.length || stack[stack.length-<span class="number">1</span>] !== pairs.get(ch))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则从栈里取出对应的左括号</span></span><br><span class="line">            stack.pop();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 左括号入栈</span></span><br><span class="line">            stack.push(ch);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结束后，栈为空说明所有的括号都能闭合</span></span><br><span class="line">    <span class="keyword">return</span> !stack.length;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)，其中 n是字符串 s 的长度。</p><p>空间复杂度：O(n+∣Σ∣)，其中 Σ 表示字符集，本题中字符串只包含 6种括号，∣Σ∣=6。栈中的字符数量为 O(n)，而哈希表使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度。</p><h2 id="合并两个有序数组（逆向双指针）"><a href="#合并两个有序数组（逆向双指针）" class="headerlink" title="合并两个有序数组（逆向双指针）"></a>合并两个有序数组（逆向双指针）</h2><p>考查<strong>原地修改</strong> ，将空间复杂度降低到 <code>O(1)</code>。</p><p>不需要使用额外的数组空间了，我们完全可以把nums2也放入nums1 中。</p><p>原地修改时，为了避免从前往后遍历导致原有数组元素被破坏掉，我们要选择<strong>从后往前遍历</strong>！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">nums1, m, nums2, n</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 逆向双指针 原地修改</span></span><br><span class="line">    <span class="keyword">let</span> i=m-<span class="number">1</span>,j=n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[i+j+<span class="number">1</span>]=nums2[j--];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[i+j+<span class="number">1</span>]=nums1[i--];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i]&lt;nums2[j])&#123;</span><br><span class="line">            nums1[i+j+<span class="number">1</span>]=nums2[j--];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nums1[i+j+<span class="number">1</span>]=nums1[i--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<code>O(m+n)</code>。指针移动单调递减，最多移动m+n 次，因此时间复杂度为O(m+n)。</p><p>空间复杂度：<code>O(1)</code>。直接对数组nums1原地修改，不需要额外空间。</p><h2 id="爬楼梯-动态规划"><a href="#爬楼梯-动态规划" class="headerlink" title="爬楼梯(动态规划)"></a>爬楼梯(动态规划)</h2><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> climbStairs = <span class="function"><span class="params">n</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// dp</span></span><br><span class="line">    <span class="comment">// 爬到第i阶台阶,需要先爬到i-1或i-2阶</span></span><br><span class="line">    <span class="comment">// dp[i] = dp[i-1]+dp[i-2]</span></span><br><span class="line">    <span class="comment">// dp[0]=1,dp[1]=1</span></span><br><span class="line">    <span class="comment">// 不需要保存所有dp，用变量代替</span></span><br><span class="line">    <span class="keyword">let</span> pre=<span class="number">1</span>,cur=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 题目规定n&gt;=1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        [cur,pre] = [cur+pre,cur];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="斐波那契数列-动态规划-递归会超时"><a href="#斐波那契数列-动态规划-递归会超时" class="headerlink" title="斐波那契数列(动态规划) 递归会超时"></a>斐波那契数列(动态规划) 递归会超时</h2><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p>外层循环：指针 i 遍历数组。</p><p>内层循环：用双指针，去寻找满足三数之和 == 0 的元素</p><p><strong>先排序的意义</strong></p><p>便于跳过重复元素，如果当前元素和前一个元素相同，跳过。</p><p><strong>双指针的移动时，避免出现重复解</strong></p><p>找到一个解后，左右指针同时向内收缩，为了避免指向重复的元素，需要：</p><ul><li>左指针在保证left &lt; right的前提下，一直右移，直到指向不重复的元素</li><li>右指针在保证left &lt; right的前提下，一直左移，直到指向不重复的元素</li></ul><p><strong>小优化</strong></p><p>排序后，如果外层遍历的数已经大于0，则另外两个数一定大于0，sum不会等于0，直接break。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> threeSum = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);<span class="comment">// 排序便于跳过重复元素</span></span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> n1 = nums[i];</span><br><span class="line">        <span class="keyword">if</span> (n1 &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 升序排序，n1是三数中最小的</span></span><br><span class="line">        <span class="comment">// 遍历到重复的数，跳过,因为排序的原因，其结果以全部存入res</span></span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; n1 == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">let</span> left = i + <span class="number">1</span>;<span class="comment">// 左指针</span></span><br><span class="line">        <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;<span class="comment">// 右指针</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">let</span> n2 = nums[left], n3 = nums[right];</span><br><span class="line">            <span class="keyword">if</span> (n1 + n2 + n3 === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 三数和=0，加入解集res</span></span><br><span class="line">                res.push([n1, n2, n3]);</span><br><span class="line">                <span class="comment">// 直到指向不一样的数</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == n2) left++;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == n3) right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n1 + n2 + n3 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 三数和小于0，则左指针右移</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 三数和大于0，则左指针右移</span></span><br><span class="line">                right--;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="反转链表（迭代-、递归）"><a href="#反转链表（迭代-、递归）" class="headerlink" title="反转链表（迭代 、递归）"></a>反转链表（迭代 、递归）</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>反转</p><ul><li><p>当前节点<code>head</code>，下一个节点 <code>head.next</code></p></li><li><p><code>head.next.next = head</code></p><ul><li>此处将下一个节点指向当前节点，即是反转</li></ul></li><li><p><code>head.next = null</code></p><ul><li>此处将当前节点指向下一个节点的指针断开</li></ul></li></ul><p><strong>最先调用的函数会在递归过程中最后被执行，而最后调用的会最先执行</strong></p><ul><li><strong>最先返回最后两个节点开始反转操作</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListNode</span>(<span class="params">val, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = (val===<span class="literal">undefined</span> ? <span class="number">0</span> : val)</span><br><span class="line">    <span class="built_in">this</span>.next = (next===<span class="literal">undefined</span> ? <span class="literal">null</span> : next)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> reverseList = <span class="function"><span class="params">head</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">const</span> reverseHead = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> reverseHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代-双指针"><a href="#迭代-双指针" class="headerlink" title="迭代 双指针"></a>迭代 双指针</h3><p>初始化：设置pre指针指向 null，将当前节点cur指向head。</p><p>将当前节点cur的next指针指向上一个节点pre。</p><p>然后当前节点和下一个节点更新为pre和cur。</p><p>重复以上动作直到当前节点cur指向null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseList = <span class="function"><span class="params">head</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 双指针</span></span><br><span class="line">    <span class="comment">// 定义一个cur指针，指向头节点，再定义一个pre指针，初始化为null</span></span><br><span class="line">    <span class="keyword">let</span> cur=head,pre=<span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 直到当前节点指向null结束</span></span><br><span class="line">    <span class="keyword">while</span>(cur !==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 简化版本 解构赋值</span></span><br><span class="line">        [cur.next,pre,cur] = [pre,cur,cur.next];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><h2 id="环形链表（哈希表map、快慢指针）"><a href="#环形链表（哈希表map、快慢指针）" class="headerlink" title="环形链表（哈希表map、快慢指针）"></a>环形链表（哈希表map、快慢指针）</h2><h3 id="借助哈希表"><a href="#借助哈希表" class="headerlink" title="借助哈希表"></a>借助哈希表</h3><p>哈希表存遍历过的节点，每遍历一个节点，都查看哈希表是否存在当前节点，如果存在，则说明链表有环</p><p>如果不存在，则存入哈希表，继续遍历</p><p>时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(n)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasCycle = <span class="function"><span class="params">head</span>  =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();<span class="comment">//哈希表存遍历过的节点</span></span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(head)) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 如果存在，则说明链表有环</span></span><br><span class="line">        map.set(head,<span class="literal">true</span>);<span class="comment">// 存的是节点的地址引用，而不是节点值</span></span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h3><p>快、慢指针，从头节点出发。</p><p>慢指针每次走一步，快指针每次走两步，不断比较它们指向的节点的值。</p><p>如果节点值相同，说明有环。如果不同，继续循环。</p><blockquote><p>类似 “追及问题”</p></blockquote><p>两个人在环形跑道上赛跑，同一个起点出发，一个跑得快一个跑得慢，在某一时刻，跑得快的必定会追上跑得慢的，只要是跑道是环形的，不是环形就肯定追不上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasCycle = <span class="function"><span class="params">head</span>  =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="keyword">let</span> fast =head,slow=head;</span><br><span class="line">    <span class="comment">// fast 防止链表为空的情况</span></span><br><span class="line">    <span class="comment">// fast.next 快指针每次移动两格，</span></span><br><span class="line">    <span class="comment">// 如果fast.next已经指向null，fast.next.next就不存在，且此时一定没有环</span></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.next )&#123;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">// 相对速度是1，快的只能一格一格追，有环的话一定会相遇</span></span><br><span class="line">        <span class="keyword">if</span>(slow===fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：<code>O(N)</code>，其中 N 是链表中的节点数。</p><p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p><p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。</p><p>空间复杂度：<code>O(1)</code>。我们只使用了两个指针的额外空间。</p><h2 id="二叉树的最大深度（BFS）"><a href="#二叉树的最大深度（BFS）" class="headerlink" title="二叉树的最大深度（BFS）"></a>二叉树的最大深度（BFS）</h2><h4 id="BFS-典型的BFS模板写法"><a href="#BFS-典型的BFS模板写法" class="headerlink" title="BFS (典型的BFS模板写法)"></a>BFS (典型的BFS模板写法)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxDepth = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> queue = [root];</span><br><span class="line">    <span class="keyword">let</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="comment">// 当前层的节点个数</span></span><br><span class="line">        <span class="keyword">const</span> levelSize = queue.length;          </span><br><span class="line">        <span class="comment">// 逐个让当前层的节点出列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;    </span><br><span class="line">            <span class="comment">// 当前出列的节点</span></span><br><span class="line">            <span class="keyword">const</span> cur = queue.shift();            </span><br><span class="line">            <span class="comment">// 左右子节点入列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left) queue.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right) queue.push(cur.right); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前层所有节点已经出列，如果队列不为空，说明有下一层节点，depth+1</span></span><br><span class="line">        <span class="keyword">if</span> (queue.length) depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="两数之和-哈希表map"><a href="#两数之和-哈希表map" class="headerlink" title="两数之和(哈希表map)"></a>两数之和(哈希表map)</h2><blockquote><p>哈希表</p></blockquote><p>我们遍历到数字 a时，用 target 减去 a，就会得到 b，若 b 存在于哈希表中，我们就可以直接返回结果了。若 b 不存在，那么我们需要将 a 存入哈希表，好让后续遍历的数字使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> twoSum = <span class="function">(<span class="params">nums, target</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 哈希表map</span></span><br><span class="line">    <span class="keyword">const</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">// map存在一个键名=target-nums[i]，取出对应的键值</span></span><br><span class="line">        <span class="keyword">if</span>(map.has(target-nums[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> [map.get(target-nums[i]),i];<span class="comment">// 题目要求返回下标</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.set(nums[i],i);<span class="comment">// 键名：数nums[i]；键值：下标i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：<code>O(N)</code>，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以O(1)地寻找 target - x。</p><p>空间复杂度：<code>O(N)</code>，其中 N 是数组中的元素数量。主要为哈希表的开销。</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><blockquote><p>二分法</p></blockquote><p>我们定义 target 是在一个在左闭右闭的区间里，也就是<code>[left, right]</code> （这个很重要非常重要）。</p><p>区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点：</p><p><code>while (left &lt;= right)</code> 要使用 <code>&lt;=</code> ，因为left == right是有意义的，所以使用 &lt;=</p><p><code>if (nums[middle] &gt; target)</code> right 要赋值为 <code>middle - 1</code>，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> search = <span class="function">(<span class="params">nums, target</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="comment">// [l,r]</span></span><br><span class="line">    <span class="keyword">let</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((l+r)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]===target)<span class="keyword">return</span> mid;</span><br><span class="line">        <span class="comment">// 中心值&lt;目标，取右区间，否则左区间</span></span><br><span class="line">        nums[mid]&lt;target ? l=mid+<span class="number">1</span> : r= mid-<span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h2><h3 id="逐个比较"><a href="#逐个比较" class="headerlink" title="逐个比较"></a>逐个比较</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">strs</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> longestCommonPrefix =<span class="function"><span class="params">strs</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = strs.length;</span><br><span class="line">    <span class="comment">// 字符串数组为空</span></span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 初始化最长公共前缀为第一个字符串</span></span><br><span class="line">    <span class="keyword">let</span> ans = strs[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 与其他字符串两两相比，不断截取以得到最长公共前缀</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> j=<span class="number">0</span>;<span class="comment">// 放在for循环外面是因为字符串长度不一致</span></span><br><span class="line">        <span class="keyword">for</span>(;j&lt;ans.length &amp;&amp; j &lt; strs[i].length;j++) &#123;</span><br><span class="line">            <span class="comment">// 字符串也可以用[]进行字符访问</span></span><br><span class="line">            <span class="keyword">if</span>(ans[j] !== strs[i][j])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从0索引开始截取j个 </span></span><br><span class="line">        ans = ans.substr(<span class="number">0</span>, j); </span><br><span class="line">        <span class="comment">// 最长公共前缀变为&quot;&quot;就提前返回</span></span><br><span class="line">        <span class="keyword">if</span>(ans===<span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>这道题可以使用递归实现，新链表也不需要构造新节点，我们下面列举递归三个要素</p><ul><li>终止条件：两条链表分别名为 <code>l1</code> 和 <code>l2</code>，当 <code>l1</code> 为空或 <code>l2</code> 为空时结束</li><li>返回值：每一层调用都返回排序好的链表头</li><li>本级递归内容：如果 <code>l1</code> 的 val 值更小，则将 <code>l1.next</code> 与排序好的链表头相接，<code>l2</code> 同理</li></ul><p><strong>复杂度分析</strong></p><p>时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)。</p><p>空间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m次，因此空间复杂度为 O(n+m)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">list1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">list2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">list1, list2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// list1&lt;list2,list1.next=null,此时令list1.next=list2</span></span><br><span class="line">    <span class="keyword">if</span>(list1 === <span class="literal">null</span>)<span class="keyword">return</span> list2</span><br><span class="line">    <span class="keyword">if</span>(list2 === <span class="literal">null</span>)<span class="keyword">return</span> list1</span><br><span class="line">    <span class="comment">// 每一层调用都返回排序好的链表头</span></span><br><span class="line">    <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">        list1.next = mergeTwoLists(list1.next,list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        list2.next = mergeTwoLists(list1,list2.next);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树的层序遍历（BFS-队列）"><a href="#二叉树的层序遍历（BFS-队列）" class="headerlink" title="二叉树的层序遍历（BFS 队列）"></a>二叉树的层序遍历（BFS 队列）</h2><p><strong>DFS（Deep First Search）深度优先搜索。</strong></p><p><strong>BFS（Breath First Search）广度优先搜索。</strong></p><p><strong>队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><blockquote><p>思路</p></blockquote><p>遍历每一层的节点，将节点值推入 subRes 数组中</p><p>将 subRes 数组推入 res 数组中</p><p><strong>怎么获取每一层的节点</strong></p><ul><li>我们已知的是根节点，就一个</li><li>通过它可以 “找出” 第 2 层的所有节点</li><li>通过第 2 层的节点可以 “找出” 所有第 3 层的节点</li><li>…………</li></ul><p><strong>怎么存储每一层的节点</strong></p><ul><li>我们需要用一个数据结构存储每一层的节点</li><li>且我们希望<strong>某一刻新层节点全进来了，旧层节点全出去了</strong></li><li>队列的先进先出符合要求</li><li>于是维护一个 <strong>queue 队列</strong>，是层序遍历的特征</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> levelOrder = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 广度优先遍历 BFS</span></span><br><span class="line">    <span class="comment">// 队列 先进先出</span></span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> [];<span class="comment">// 树空</span></span><br><span class="line">    <span class="keyword">let</span> res=[];<span class="comment">// 初始化结果</span></span><br><span class="line">    <span class="keyword">let</span> queue = [root];<span class="comment">// 根节点入列</span></span><br><span class="line">    <span class="comment">// 队列中没有节点时，遍历完毕</span></span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> subRes = [];<span class="comment">// 储存每一层的节点</span></span><br><span class="line">        <span class="keyword">const</span> len =queue.length;<span class="comment">//当前层的节点数目</span></span><br><span class="line">        <span class="comment">//遍历当前层的节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> cur = queue.shift();<span class="comment">// 当前层的节点出列</span></span><br><span class="line">            subRes.push(cur.val);<span class="comment">// 同时存入subRes</span></span><br><span class="line">            <span class="comment">// 下层左右节点入列</span></span><br><span class="line">            <span class="keyword">if</span>(cur.left) queue.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right) queue.push(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(subRes);<span class="comment">// 将当前层的结果放入res</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>“携家带子”，queue “更新换代”</strong></p><ul><li>queue 初始时为 [root] ，代表第 1 层</li><li>开启 while 循环，对当前层的节点进行遍历</li><li>当前层的节点逐个出列，节点值推入 subRes 数组</li><li>判断如果当前出列节点有子节点，让子节点入列</li><li>本层的节点出列，下层的进来，下次循环时，queue 中全是新层的节点，没有旧层的节点while 循环终止的条件是 queue 队列空了，节点遍历完了</li></ul><p><strong>易错点</strong></p><ul><li><code>const len = queue.length</code> <strong>必须先保存当前层的节点数</strong>，再做遍历</li><li>不能 <code>for (let i = 0; i &lt; queue.length; i++) &#123;...&#125;</code></li><li>因为在 for 循环时，queue有出列和入列，长度是动态变化的</li></ul><p><strong>复杂度</strong></p><p>记树上所有节点的个数为 n。</p><p>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 <code>O(n)</code>。<br>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 <code>O(n)</code>。</p><h2 id="字符串相加（双指针）"><a href="#字符串相加（双指针）" class="headerlink" title="字符串相加（双指针）"></a>字符串相加（双指针）</h2><p>因为本题不能使用任何 BigInteger 库，所以我们可以使用双指针来模拟人工计算，步骤如下：</p><ul><li>创建指针 i 指向 nums1 末位数字，j 指向 nums2末位数字。</li><li>i, j 数字相加，用进位就用 carry 来记录进位值，无则为0。</li><li>若产生进位，则当前数字为 (i+j+carry)%10 的值。</li><li>若遍历过程中，nums1 或 nums2 当前已无数字，则用0 补位来计算。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">num1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">num2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> addStrings = <span class="function">(<span class="params">num1, num2</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 双指针来模拟人工计算</span></span><br><span class="line">    <span class="comment">// carry模拟进位</span></span><br><span class="line">    <span class="keyword">let</span> i=num1.length-<span class="number">1</span>,j=num2.length-<span class="number">1</span>,carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> ans = [] ; <span class="comment">// 保存结果的数组</span></span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span> || carry&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> n1 = i&gt;=<span class="number">0</span> ? num1[i]-<span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>,</span><br><span class="line">            n2 = j&gt;=<span class="number">0</span> ? num2.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;<span class="comment">// - &#x27;0&#x27;字符串转数字</span></span><br><span class="line">        <span class="keyword">let</span> sum = n1 + n2 + carry;</span><br><span class="line">        ans.unshift(sum % <span class="number">10</span>);</span><br><span class="line">        carry = <span class="built_in">Math</span>.floor(sum/<span class="number">10</span>); <span class="comment">// 向下取整</span></span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.join(<span class="string">&#x27;&#x27;</span>);<span class="comment">//数组元素拼接成字符串</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="颠倒字符串中的单词"><a href="#颠倒字符串中的单词" class="headerlink" title="颠倒字符串中的单词"></a>颠倒字符串中的单词</h2><p><strong>正则 + JS API</strong></p><p><code>\s</code> 匹配一个<strong>空白字符</strong>，包括空格、制表符、换页符和换行符。</p><p><code>\S</code> 匹配一个<strong>非空白字符</strong>。</p><p><code>+</code> 至少一个，相当于{1,}</p><p><code>match</code> 一个在字符串中执行查找匹配的String方法，它返回一个<strong>数组</strong>，在未匹配到时会返回 null。</p><p><code>i</code> 忽略大小写</p><p><code>g</code> 全局匹配模式</p><p>两种思路</p><ul><li>一种匹配非空字符，翻转，拼接</li><li>另一种去除首尾空字符后匹配空字符，按空字符分割，翻转，拼接</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s.match(<span class="regexp">/\S+/g</span>).reverse().join(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="comment">// return s.trim().replace(/\s+/g,&#x27; &#x27;).split(&#x27; &#x27;).reverse().join(&#x27; &#x27;);</span></span><br><span class="line">    <span class="comment">// return s.trim().split(/\s+/).reverse().join(&#x27; &#x27;);</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>双指针</strong></p><p>使用双指针的方法，<strong>从后向前</strong>遍历字符</p><ul><li>右端的指针遇到空格跳过，直到单词的末尾</li><li>没有到头就将左端的指针指向右端</li><li>左指针继续向前，直到遇到空格或小于0才停下（此时左右指针之间就是单词）</li><li>遍历单词将其添加到结果字符串中</li><li>把右指针指向左指针，开始下一轮遍历</li></ul><p>下一轮遍历开始后，<strong>如果还有新单词</strong>，就给上一个单词后面添加一个空格。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> r=s.length-<span class="number">1</span>, l=r,res=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//先找到单词的尾部</span></span><br><span class="line">        <span class="keyword">while</span>(s[r]===<span class="string">&#x27; &#x27;</span>)r--;</span><br><span class="line">        <span class="comment">// 如果找到头了就退出，否则l=r</span></span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l=r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给上次单词后加空格，排除第一次</span></span><br><span class="line">        <span class="keyword">if</span>(res) res += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="comment">// 找到单词的头部</span></span><br><span class="line">        <span class="keyword">while</span>(s[l] &amp;&amp; s[l]!== <span class="string">&#x27; &#x27;</span>)l--;</span><br><span class="line">        <span class="comment">// 遍历单词并添加  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = l + <span class="number">1</span>; i &lt;= r; i++)res += s[i];</span><br><span class="line">        <span class="comment">// 右指针跳过当前单词</span></span><br><span class="line">        r = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h2><h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><p>前序遍历的定义：对每个节点，都是先处理当前节点，对它执行我们的处理逻辑，再递归它的左子树，再递归它的右子树，对子树中的节点执行相同的逻辑。(<strong>中左右</strong>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> preorderTraversal = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 递归 中左右</span></span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> preOrder = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span>;<span class="comment">// 递归终止条件</span></span><br><span class="line">        res.push(root.val);<span class="comment">// 中</span></span><br><span class="line">        preOrder(root.left);<span class="comment">// 左</span></span><br><span class="line">        preOrder(root.right);<span class="comment">// 右</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root);<span class="comment">//递归入口</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：<code>O(n)</code>，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</p><p>空间复杂度：<code>O(n)</code>，为递归过程中栈的开销，平均情况下为 <code>O(logn)</code>，最坏情况下树呈现链状，为 <code>O(n)</code>。</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>为什么可以用迭代法（非递归的方式）来实现二叉树的前后中序遍历呢？</p><p>递归的实现就是：<strong>每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因</strong>。</p><p>此时大家应该知道我们用<strong>栈</strong>也可以是实现二叉树的前后中序遍历了。</p><h5 id="方法一-非统一格式"><a href="#方法一-非统一格式" class="headerlink" title="方法一 非统一格式"></a>方法一 非统一格式</h5><p>前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要先加入右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">let</span> stack=[];</span><br><span class="line">    <span class="comment">// 当根节点不为空的时候，将根节点入栈</span></span><br><span class="line">    <span class="keyword">if</span>(root) stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(stack.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 将根节点出栈，将根节点值放入结果数组中</span></span><br><span class="line">        <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">        res.push(node.val);</span><br><span class="line">        <span class="comment">// 然后遍历左子树、右子树，</span></span><br><span class="line">        <span class="comment">// 因为栈是先入后出，所以，我们先右子树入栈，然后左子树入栈</span></span><br><span class="line">        <span class="keyword">if</span>(node.right) stack.push(node.right);</span><br><span class="line">        <span class="keyword">if</span>(node.left) stack.push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="方法二-统一格式"><a href="#方法二-统一格式" class="headerlink" title="方法二 统一格式"></a>方法二 统一格式</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">let</span> stack=[];</span><br><span class="line">    <span class="keyword">let</span> node =root;</span><br><span class="line">    <span class="comment">// 和递归思想类似</span></span><br><span class="line">    <span class="keyword">while</span>(node || stack.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            res.push(node.val);</span><br><span class="line">            node=node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;    </span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：<code>O(n)</code>，其中 nn 是二叉树的节点数。每一个节点恰好被遍历一次。</p><p>空间复杂度：<code>O(n)</code>，为迭代过程中显式栈的开销，平均情况下为 <code>O(logn)</code>，最坏情况下树呈现链状，为 <code>O(n)</code>。</p><h2 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h2><p>维护一个栈。</p><p>因为扫描过的字符还不知道要不要删，要保留对它的记忆，入栈暂存</p><p>遍历字符串，如果当前字符和栈顶字符相同，则栈顶出栈（删字符），否则入栈</p><p>最后将栈中剩下的字符转成字符串即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> removeDuplicates = <span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.length &gt; <span class="number">0</span> &amp;&amp; stack[stack.length - <span class="number">1</span>] === s[i]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="千位分隔数"><a href="#千位分隔数" class="headerlink" title="千位分隔数"></a>千位分隔数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thousandSeparator = <span class="function"><span class="params">n</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> num=n.toString().split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i= num.length-<span class="number">3</span>;i&gt;<span class="number">0</span>;i-=<span class="number">3</span>)&#123;</span><br><span class="line">        num.splice(i,<span class="number">0</span>,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isPalindrome = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = x.toString();</span><br><span class="line">    <span class="keyword">let</span> n = s.length, l, r;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    r = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    l= (n % <span class="number">2</span>) ? r : r-<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(l&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[l]!==s[r])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        l--;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h2><p>某个元素只出现 1 次，其余元素都出现 2 次</p><p>时间复杂度O(n)，空间复杂度O(1)</p><p>只操作 nums 数组本身，不使用额外空间</p><p>异或：同为0，异为1 <code>n ^ n === 0 且 n ^ 0 === n</code></p><ul><li>异或遵循<strong>交换律</strong></li><li>[4,1,2,1,2] 将数字全部异或运算一遍：</li><li><code>4 ^ 1 ^ 2 ^ 1 ^ 2 =&gt; 1 ^ 1 ^ 2 ^ 2 ^ 4 =&gt; 0 ^ 2 ^ 2 ^ 4 =&gt; 2 ^ 2 ^ 4 =&gt; 0 ^ 4 =&gt; 4</code></li><li>出现 2 次的数字在异或中都抵消了，最后得出只出现 1 次的数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> singleNumber = <span class="function"><span class="params">nums</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        res= res ^ nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/LdZzod"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/04/18/LdZzod.png" alt="LdZzod.png"></a></p><h2 id="x-的平方根（二分法）"><a href="#x-的平方根（二分法）" class="headerlink" title="x 的平方根（二分法）"></a>x 的平方根（二分法）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySqrt = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">1</span>,right = x;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 中间值  下面这样写是防止溢出</span></span><br><span class="line">        <span class="keyword">let</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 判断mid的平方是否小于或等于x，如果mid的平方小于x</span></span><br><span class="line">        <span class="keyword">if</span> (mid &lt;= x / mid) &#123;</span><br><span class="line">            <span class="comment">// 判断(mid+1)的平方是否大于x，如果(mid+1)的平方大于x，那么mid就是x的平方根</span></span><br><span class="line">            <span class="keyword">if</span> (mid + <span class="number">1</span> &gt; x / (mid + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果mid的平方小于x并且(mid+1)的平方小于x，那么x的平方根比mid大，接下来搜索从mid+1到x的范围</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果mid的平方大于x，则x的平方根小于mid，接下来搜索1到mid-1的范围</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果输入参数是0，left等于1而right等于0，就直接返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>面试官好，我叫王吉晨，现在就读于北京邮电大学，是一名研二的学生。今天我想应聘的是前端开发的暑期实习岗位。</p><p>下面我来介绍下我的学习和项目经历。</p><p>最早是本科做了一个Android电子词典APP，通过这个项目对前端（HTML）后端（JAVA和Python）都有了一定的了解，体会到了逻辑，视图，模型分离的开发理念。</p><p>后来研究生阶段利用空闲时间开始学习前端，先是系统学习了HTML，CSS和JS前端三件套，还通过Hexo搭建了个人博客网站记录一些学习内容。后面进一步学习了ES6+的部分内容、以及Ajax和跨域相关知识，对前后端分离技术的基础有了一些了解。</p><p>关于框架主要是学习了React，做了一个后台管理系统，这是一个前后端分离的单页面应用，后端使用别人用node搭建的服务器，前端界面则是基于react和antd等技术完成，当时做这个项目时react router v6正式版刚发布，官方更推荐使用react hooks，因此就用函数组件和它配合使用，完成相应的功能。</p><p>我的经历大概就是这样。</p><h1 id="渠道"><a href="#渠道" class="headerlink" title="渠道"></a>渠道</h1><p>B站、MDN（建议英文，中译有误）和官网（React、React Router）、掘金/知乎、阮一峰博客</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leslie Waong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesliewaong.top/posts/186242d5.html">https://lesliewaong.top/posts/186242d5.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lesliewaong.top" target="_blank">Leslie Waong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/a9ba4134.html"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/4.webp" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaScript基础</div></div></a></div><div class="next-post pull-right"><a href="/posts/8fbd8643.html"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/1.webp" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">手写源码系列</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Leslie Waong</div><div class="author-info__description">BUPT</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">104</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lesliewaong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lesliewaong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1138964397&amp;website=www.qtxml.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">红雨漂泊泛起了回忆怎么潜</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EAndroid%E7%9A%84%E7%94%B5%E5%AD%90%E8%AF%8D%E5%85%B8%E8%AE%BE%E8%AE%A1"><span class="toc-text">基于Android的电子词典设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E7%88%AC%E5%8F%96"><span class="toc-text">单词数据的爬取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1"><span class="toc-text">界面设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API%E6%88%96SDK"><span class="toc-text">API或SDK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM"><span class="toc-text">MVVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-MVC"><span class="toc-text">Android MVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-MVVM"><span class="toc-text">Android MVVM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%9A%E5%AE%A2"><span class="toc-text">博客</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B"><span class="toc-text">性能检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC"><span class="toc-text">基本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9"><span class="toc-text">压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CDN%E5%8A%A0%E9%80%9F"><span class="toc-text">CDN加速</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-text">缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">预加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-text">组件渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB"><span class="toc-text">加载动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">懒加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%BC%93%E5%AD%98"><span class="toc-text">HTTP缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%EF%BC%88%E5%BC%BA%E7%BC%93%E5%AD%98%E3%80%81%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%89"><span class="toc-text">基本流程（强缓存、协商缓存）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-text">缓存发展历程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%88%B7%E6%96%B0%E7%9A%84%E8%AF%B7%E6%B1%82%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">不同刷新的请求执行过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2"><span class="toc-text">浏览器解析渲染页面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81%EF%BC%88Repaint%E3%80%81Reflow%EF%BC%89"><span class="toc-text">浏览器的重绘与回流（Repaint、Reflow）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%B5%81-%E9%87%8D%E6%8E%92reflow"><span class="toc-text">回流&#x2F;重排reflow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BB%98Repaint"><span class="toc-text">重绘Repaint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81-%E9%87%8D%E7%BB%98%E8%87%B3%E5%B0%91%E6%9C%80%E5%B0%8F%E5%8C%96%E5%AE%83%E4%BB%AC%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-text">如何避免回流&#x2F;重绘至少最小化它们对性能的影响？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML-amp-CSS"><span class="toc-text">HTML&amp;CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3%E2%AD%90"><span class="toc-text">语义化的理解⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE"><span class="toc-text">常用的一些语义化标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML5%E6%96%B0%E5%A2%9E"><span class="toc-text">HTML5新增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%AB%E6%BB%A5%E7%94%A8%E7%9A%84%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE"><span class="toc-text">被滥用的语义化标签</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#H5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%E2%AD%90"><span class="toc-text">H5的新特性有哪些⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E2%AD%90"><span class="toc-text">CSS中，有哪些方式可以隐藏页面元素？有什么区别?⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%A4%E8%AF%86%E2%AD%90"><span class="toc-text">对CSS盒模型的认识⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E7%9B%92%E5%AD%90%EF%BC%88Block-box%EF%BC%89-%E5%92%8C-%E5%86%85%E8%81%94%E7%9B%92%E5%AD%90%EF%BC%88Inline-box%EF%BC%89"><span class="toc-text">块级盒子（Block box） 和 内联盒子（Inline box）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inline%EF%BC%8Cblock%EF%BC%8Cinline-block%E7%9A%84%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="toc-text">inline，block，inline-block的区别⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%9D%97%E5%85%83%E7%B4%A0-inline-block"><span class="toc-text">行内块元素(inline-block)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E4%B8%8E%E5%9D%97%E7%8A%B6%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">行内元素与块状元素之间的转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCSS-%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">什么是CSS 盒模型?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%92%8CIE%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-text">标准盒模型和IE盒子模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFC%E2%AD%90"><span class="toc-text">BFC⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">BFC的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90BFC"><span class="toc-text">如何生成BFC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">BFC 的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3margin%E9%87%8D%E5%8F%A0"><span class="toc-text">解决margin重叠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%BD%B1%E5%93%8D%EF%BC%88%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%EF%BC%89"><span class="toc-text">清除浮动影响（高度塌陷）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flex%E2%AD%90"><span class="toc-text">Flex⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-text">容器属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-flex-flow"><span class="toc-text">1. flex-flow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-justify-content"><span class="toc-text">2. justify-content</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-align-items"><span class="toc-text">3. align-items</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-align-content"><span class="toc-text">4. align-content</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="toc-text">元素属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-align-self"><span class="toc-text">1. align-self</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-flex"><span class="toc-text">2. flex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-order"><span class="toc-text">3. order</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%E2%AD%90"><span class="toc-text">居中布局⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD"><span class="toc-text">水平居中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-text">垂直居中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-text">水平垂直居中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E2%AD%90"><span class="toc-text">三栏布局⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E5%8A%A8"><span class="toc-text">浮动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D"><span class="toc-text">绝对定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flexbox%E5%B8%83%E5%B1%80"><span class="toc-text">Flexbox布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80table"><span class="toc-text">表格布局table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80-grid"><span class="toc-text">网格布局 grid</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7%E2%AD%90"><span class="toc-text">CSS选择器优先级⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#less%E2%AD%90"><span class="toc-text">less⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#script%E6%A0%87%E7%AD%BE%E7%9A%84defer%E5%92%8Casync%E5%B1%9E%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="toc-text">script标签的defer和async属性有什么区别⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#async"><span class="toc-text">async</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer"><span class="toc-text">defer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B0%E5%BA%95%E8%AF%A5%E7%94%A8%E5%93%AA%E4%B8%AA%E6%A0%87%E8%AE%B0"><span class="toc-text">到底该用哪个标记</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E2%AD%90"><span class="toc-text">自适应布局⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%8F%A3"><span class="toc-text">视口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E9%80%82%E9%85%8D%E6%96%B9%E6%B3%95"><span class="toc-text">解决适配方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rem%E9%80%82%E9%85%8D"><span class="toc-text">rem适配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vw%EF%BC%8Cvh%E5%B8%83%E5%B1%80"><span class="toc-text">vw，vh布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80"><span class="toc-text">媒体查询 响应式布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#px%E4%B8%BA%E4%B8%BB%EF%BC%8Cvx%E5%92%8Cvxxx%EF%BC%88vw-vh-vmax-vmin%EF%BC%89%E4%B8%BA%E8%BE%85%EF%BC%8C%E6%90%AD%E9%85%8D%E4%B8%80%E4%BA%9Bflex%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">px为主，vx和vxxx（vw&#x2F;vh&#x2F;vmax&#x2F;vmin）为辅，搭配一些flex（推荐）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1px%E8%BE%B9%E6%A1%86%E9%97%AE%E9%A2%98"><span class="toc-text">1px边框问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEmeta%E6%A0%87%E7%AD%BEviewport"><span class="toc-text">通过设置meta标签viewport</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87transform-scale-%E7%BC%A9%E6%94%BE%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">通过transform: scale()缩放（推荐）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E6%A1%86%E2%AD%90"><span class="toc-text">边框⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8border%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-text">利用border画三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#border-radius"><span class="toc-text">border-radius</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#box-shadow"><span class="toc-text">box-shadow</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#position%E2%AD%90"><span class="toc-text">position⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87%E2%AD%90"><span class="toc-text">层叠上下文⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E5%8A%A8%E7%94%BB%E2%AD%90"><span class="toc-text">CSS动画⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transform"><span class="toc-text">transform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#animation"><span class="toc-text">animation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#keyframes"><span class="toc-text">@keyframes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-duration"><span class="toc-text">animation-duration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-timing-function"><span class="toc-text">animation-timing-function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-delay"><span class="toc-text">animation-delay</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-iteration-count"><span class="toc-text">animation-iteration-count</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-direction"><span class="toc-text">animation-direction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-fill-mode"><span class="toc-text">animation-fill-mode</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB-%E4%BC%AA%E5%85%83%E7%B4%A0%E2%AD%90"><span class="toc-text">伪类&#x2F;伪元素⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB"><span class="toc-text">伪类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-text">伪元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%AFCSS3%E5%AE%9E%E7%8E%B0%E5%8D%A1%E9%80%9A%E4%BA%BA%E7%89%A9%E7%9C%BC%E7%9D%9B%E7%9A%84%E5%8A%A8%E7%94%BB%E7%89%B9%E6%95%88%E2%AD%90"><span class="toc-text">纯CSS3实现卡通人物眼睛的动画特效⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JacaScript"><span class="toc-text">JacaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E2%AD%90"><span class="toc-text">语言⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%BB%A3%E7%A0%81-vs-%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81"><span class="toc-text">解释代码 vs 编译代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BB%A3%E7%A0%81-vs-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-text">服务器端代码 vs 客户端代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB-vs-%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-text">基于类 vs 基于原型的语言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Js%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88%E2%AD%90"><span class="toc-text">Js中的堆栈⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%8C%BA"><span class="toc-text">栈区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%8C%BA"><span class="toc-text">堆区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-text">引用计数算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">标记清除算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%AD%90"><span class="toc-text">数据类型⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-7-1"><span class="toc-text">8种数据类型: 7+1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-text">类型判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof%EF%BC%88%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%8C%E9%9D%9E%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-text">typeof（操作符，非函数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceof"><span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-prototype-toString-call-toString-call"><span class="toc-text">Object.prototype.toString.call()&#x2F;toString.call()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84"><span class="toc-text">判断数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#amp"><span class="toc-text">&#x3D;&#x3D;&#x3D; &amp; &#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-is"><span class="toc-text">Object.is()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C1%E2%80%9D-%E2%80%9D2%E2%80%9D-%E2%80%9D3%E2%80%9D-map-parseInt-%E7%9A%84%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E6%98%AF%E5%A4%9A%E5%B0%91-%E2%AD%90"><span class="toc-text">[“1”,”2”,”3”].map(parseInt)的输出结果是多少?⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Number%E2%AD%90"><span class="toc-text">Number⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-0-2-0-3"><span class="toc-text">0.1 + 0.2 !&#x3D;&#x3D; 0.3?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%E2%AD%90"><span class="toc-text">作用域与闭包⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E2%AD%90"><span class="toc-text">原型与原型链⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93%E2%AD%90"><span class="toc-text">DOM事件总结⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BA%A7%E5%88%AB"><span class="toc-text">DOM事件的级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-text">DOM事件模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81-api-%E6%96%B9%E6%B3%95"><span class="toc-text">Event对象的常见 api 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%BB%A3%E7%90%86%EF%BC%89"><span class="toc-text">事件委托（代理）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E5%90%91%E2%AD%90"><span class="toc-text">this指向⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E2%AD%90"><span class="toc-text">JS数组常用方法总结⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-text">实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-text">实例方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E2%AD%90"><span class="toc-text">浅拷贝和深拷贝⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Js%E4%B8%ADDate%E5%AF%B9%E8%B1%A1%E2%AD%90"><span class="toc-text">Js中Date对象⭐</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES6"><span class="toc-text">ES6+</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#let%E3%80%81const%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="toc-text">let、const和var的区别⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#var"><span class="toc-text">var</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#let"><span class="toc-text">let</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-text">const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87"><span class="toc-text">变量提升和函数提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82"><span class="toc-text">函数传参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class%E4%B8%8E%E7%BB%A7%E6%89%BF%E2%AD%90"><span class="toc-text">Class与继承⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B0%83%E7%94%A8"><span class="toc-text">类定义与调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-text">严格模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="toc-text">构造函数与方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-%E5%AD%97%E6%AE%B5"><span class="toc-text">属性&#x2F;字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="toc-text">箭头函数与普通函数区别⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%EF%BC%8CWeakSet%EF%BC%8CMap%E5%92%8CWeakMap%E2%AD%90"><span class="toc-text">Set，WeakSet，Map和WeakMap⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakSet"><span class="toc-text">WeakSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakMap"><span class="toc-text">WeakMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%AD%90"><span class="toc-text">事件循环机制⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E2%AD%90"><span class="toc-text">异步编程⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83"><span class="toc-text">异步回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setTimeout-amp-setInterval"><span class="toc-text">setTimeout() &amp; setInterval()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise%E2%AD%90"><span class="toc-text">Promise⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E6%97%A7%E5%BC%8F%E5%9B%9E%E8%B0%83%E7%9B%B8%E6%AF%94"><span class="toc-text">与旧式回调相比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-text">状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-all-iterable"><span class="toc-text">Promise.all(iterable)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-race-iterable"><span class="toc-text">Promise.race(iterable)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-resolve-value"><span class="toc-text">Promise.resolve(value)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-reject-reason"><span class="toc-text">Promise.reject(reason)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">原型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-prototype-then-onFulfilled-onRejected"><span class="toc-text">Promise.prototype.then(onFulfilled, onRejected)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-prototype-catch-onRejected"><span class="toc-text">Promise.prototype.catch(onRejected)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-prototype-finally-onFinally"><span class="toc-text">Promise.prototype.finally(onFinally)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Async-await"><span class="toc-text">Async&#x2F;await</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">模块化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81"><span class="toc-text">手写代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E2%AD%90"><span class="toc-text">数组去重⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95Set"><span class="toc-text">最简单Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#indexOf-includes-for-forEach-for%E2%80%A6of"><span class="toc-text">indexOf&#x2F;includes+for&#x2F;forEach&#x2F;for…of</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filter%E9%85%8D%E5%90%88indexOf"><span class="toc-text">filter配合indexOf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce%E9%85%8D%E5%90%88includes"><span class="toc-text">reduce配合includes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E6%95%B0%E7%BB%84%E7%9B%B4%E6%8E%A5%E5%8E%BB%E9%87%8D"><span class="toc-text">原数组直接去重</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call%E3%80%81apply%E3%80%81bind%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="toc-text">call、apply、bind区别⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-call"><span class="toc-text">模拟实现 call</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-apply"><span class="toc-text">模拟实现 apply</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0bind"><span class="toc-text">模拟实现bind</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81%E2%AD%90"><span class="toc-text">防抖&#x2F;节流⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96"><span class="toc-text">防抖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E7%AB%8B%E5%8D%B3%E9%98%B2%E6%8A%96"><span class="toc-text">非立即防抖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E9%98%B2%E6%8A%96"><span class="toc-text">立即防抖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%B5%81"><span class="toc-text">节流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E5%AE%9E%E7%8E%B0"><span class="toc-text">时间戳实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">定时器实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E2%AD%90"><span class="toc-text">new⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-create"><span class="toc-text">Object.create()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof%E2%AD%90"><span class="toc-text">instanceof⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax%E2%AD%90"><span class="toc-text">Ajax⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9FAjax"><span class="toc-text">原生Ajax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fetch"><span class="toc-text">Fetch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise%E5%B0%81%E8%A3%85axios"><span class="toc-text">Promise封装axios</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E2%AD%90"><span class="toc-text">深拷贝⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise"><span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E2%AD%90"><span class="toc-text">继承⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-text">原型链继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">借用构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-text">寄生组合式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6%E7%B1%BB%E7%BB%A7%E6%89%BFextends"><span class="toc-text">ES6类继承extends</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%BB%84"><span class="toc-text">拷贝数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-text">如何实现数组扁平化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B0%E6%96%B9%E6%B3%95-flat-depth"><span class="toc-text">ES6提供的新方法 flat(depth)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce%E6%96%B9%E6%B3%95-%E9%80%92%E5%BD%92"><span class="toc-text">reduce方法 递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E9%93%BA%E6%95%B0%E7%BB%84%E8%BD%AC%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="toc-text">平铺数组转树形结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84shuffle"><span class="toc-text">随机打乱数组shuffle</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">计算机网络和浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%E2%AD%90"><span class="toc-text">从URL输入到页面展现到底发生什么？⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URL%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">URL是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%EF%BC%88DNS%EF%BC%89"><span class="toc-text">域名解析（DNS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">TCP三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E5%BC%80TCP%E8%BF%9E%E6%8E%A5-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">断开TCP连接 四次挥手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E2%AD%90"><span class="toc-text">HTTP⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E6%96%B9%E6%B3%95"><span class="toc-text">HTTP方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GET-%E4%B8%8E-POST"><span class="toc-text">GET 与 POST</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F"><span class="toc-text">参数传递方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E4%B8%8D%E5%90%8C"><span class="toc-text">参数长度限制不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%92%8C%E5%B9%82%E7%AD%89"><span class="toc-text">安全和幂等</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8D%E5%90%8C%EF%BC%88%E4%BC%A0%E8%BE%93%E7%9A%84%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="toc-text">安全性不同（传输的角度）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%B8%8D%E5%90%8C"><span class="toc-text">缓存机制不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%B6%88%E8%80%97%E4%B8%8D%E5%90%8C"><span class="toc-text">时间消耗不同</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HEAD"><span class="toc-text">HEAD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUT"><span class="toc-text">PUT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DELETE"><span class="toc-text">DELETE</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%89%B9%E6%80%A7"><span class="toc-text">HTTP特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS"><span class="toc-text">HTTP和HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E4%BC%98%E7%82%B9"><span class="toc-text">HTTPS优点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86"><span class="toc-text">混合加密</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-text">数字证书</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95"><span class="toc-text">摘要算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E8%BF%9E%E6%8E%A5"><span class="toc-text">HTTPS连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1%E3%80%81HTTP-2%E3%80%81HTTP-3%E6%BC%94%E5%8F%98"><span class="toc-text">HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3演变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-1"><span class="toc-text">HTTP&#x2F;1.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-2"><span class="toc-text">HTTP&#x2F;2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-3"><span class="toc-text">HTTP&#x2F;3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E2%AD%90"><span class="toc-text">跨域通信⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">跨域解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSONP"><span class="toc-text">JSONP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS"><span class="toc-text">CORS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ECORS%E7%9A%84-cookie-%E9%97%AE%E9%A2%98"><span class="toc-text">关于CORS的 cookie 问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86"><span class="toc-text">代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Node%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-text">Node中间件代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#React%E4%B8%AD%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86"><span class="toc-text">React中配置代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">Nginx反向代理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocket"><span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie%E3%80%81sessionStorage%E3%80%81localStorage-%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E2%AD%90"><span class="toc-text">Cookie、sessionStorage、localStorage 详解及应用场景⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie"><span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#localStorage-amp-amp-sessionStorage"><span class="toc-text">localStorage &amp;&amp; sessionStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IndexedDB"><span class="toc-text">IndexedDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E2%AD%90"><span class="toc-text">Cookie、Session、Token、JWT⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XSS%E5%92%8CCSRF"><span class="toc-text">XSS和CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS"><span class="toc-text">XSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%98%B2%E8%8C%83%E6%96%B9%E6%B3%95"><span class="toc-text">常用防范方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF"><span class="toc-text">CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CSRF%E4%B8%8E-XSS-%E5%8C%BA%E5%88%AB"><span class="toc-text">CSRF与 XSS 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1"><span class="toc-text">防御</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-UDP"><span class="toc-text">TCP UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-text">TCP 协议如何保证可靠传输</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">计算机网络体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-text">传输层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="toc-text">网络接口层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-text">数据链路层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-text">物理层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BD%91%E7%BB%9C%E8%A6%81%E5%88%86%E5%B1%82%EF%BC%9F"><span class="toc-text">为什么网络要分层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-text">网络通信</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#One-Piece-%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">One Piece 商城后台管理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">项目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE"><span class="toc-text">后端数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">模块化、组件化、工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96-1"><span class="toc-text">模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">工程化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="toc-text">组件化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A9%E6%B0%94API"><span class="toc-text">天气API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2"><span class="toc-text">界面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80"><span class="toc-text">居中布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Flex-margin-line-height"><span class="toc-text">Flex margin line-height</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2"><span class="toc-text">登录界面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB"><span class="toc-text">预加载动画</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%BC%8F%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="toc-text">类式组件与函数式组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-Router-v6-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">React-Router v6 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SPA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">SPA的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-text">基础使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">路由参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#param%E5%8F%82%E6%95%B0"><span class="toc-text">param参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#search%E5%8F%82%E6%95%B0-amp-sate%E5%8F%82%E6%95%B0"><span class="toc-text">search参数&amp;sate参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Antd-v3%E5%8D%87%E7%BA%A7%E6%88%90v4"><span class="toc-text">Antd v3升级成v4</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E9%99%A4-Form-create"><span class="toc-text">去除 Form.create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E6%8E%A7%E5%88%B6%E8%B0%83%E6%95%B4"><span class="toc-text">表单控制调整</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#onFinish-%E6%9B%BF%E4%BB%A3-onSubmit"><span class="toc-text">onFinish 替代 onSubmit</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-text">数据可视化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-text">功能实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">登录数据持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-text">权限管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%A1%E9%AA%8C"><span class="toc-text">输入校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E5%92%8CAjax"><span class="toc-text">跨域和Ajax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E9%80%9A%E4%BF%A1"><span class="toc-text">父子通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#props"><span class="toc-text">props</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83"><span class="toc-text">发布</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BrowserRouter"><span class="toc-text">BrowserRouter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashRouter"><span class="toc-text">HashRouter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GitHub-Pages%E5%8F%91%E5%B8%83%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2"><span class="toc-text">GitHub Pages发布静态页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96"><span class="toc-text">项目优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89hook%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E9%98%B2%E6%8A%96"><span class="toc-text">自定义hook实现搜索防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E5%90%8E%E7%88%B6%E7%BA%A7%E8%8F%9C%E5%8D%95%E7%9A%84%E5%B1%95%E5%BC%80%E9%97%AE%E9%A2%98"><span class="toc-text">刷新后父级菜单的展开问题</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#React"><span class="toc-text">React</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E6%A1%86%E6%9E%B6%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8E%9F%E7%94%9F"><span class="toc-text">为什么选择使用框架而不是原生?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-vs-Vue"><span class="toc-text">React vs Vue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJSX%EF%BC%9F"><span class="toc-text">什么是JSX？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM"><span class="toc-text">虚拟DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">虚拟DOM实现原理?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-%E2%80%9CReact-Fiber%E2%80%9D%EF%BC%9F"><span class="toc-text">什么是 “React Fiber”？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#diff-%E7%AE%97%E6%B3%95-%E5%8D%8F%E8%B0%83"><span class="toc-text">diff 算法&#x2F;协调</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Keys"><span class="toc-text">Keys</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E7%BB%84%E4%BB%B6%E5%AE%9A%E4%B9%89%E5%8C%BA%E5%88%AB"><span class="toc-text">两种组件定义区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E5%A3%B0%E6%98%8E%E7%BB%84%E4%BB%B6"><span class="toc-text">函数式声明组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%BC%8F%E7%BB%84%E4%BB%B6-%E6%9C%89%E7%8A%B6%E6%80%81-state"><span class="toc-text">类式组件(有状态 state)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-text">事件处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%9C%B0%E4%BD%BF%E7%94%A8-State"><span class="toc-text">正确地使用 State</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9-State"><span class="toc-text">不要直接修改 State</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#State-%E7%9A%84%E6%9B%B4%E6%96%B0%E5%8F%AF%E8%83%BD%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84"><span class="toc-text">State 的更新可能是异步的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#State-%E7%9A%84%E6%9B%B4%E6%96%B0%E4%BC%9A%E8%A2%AB%E5%90%88%E5%B9%B6"><span class="toc-text">State 的更新会被合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-Refs-and-the-DOM%E6%8F%AD%E7%A7%98"><span class="toc-text">React Refs and the DOM揭秘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRef"><span class="toc-text">什么是Ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B-Declarative-Programming"><span class="toc-text">什么是声明式编程(Declarative Programming)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ref%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">Ref使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ref%E7%94%A8%E6%B3%95"><span class="toc-text">Ref用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Refs"><span class="toc-text">创建 Refs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-Refs"><span class="toc-text">访问 Refs</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Refs-%E4%B8%8E%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6"><span class="toc-text">Refs 与函数组件</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">React组件通信如何实现?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3-React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%97%EF%BC%9F"><span class="toc-text">你真的了解 React 生命周期吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hooks-%E7%BB%84%E4%BB%B6"><span class="toc-text">Hooks 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">单个组件的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD"><span class="toc-text">挂载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0"><span class="toc-text">更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD"><span class="toc-text">卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-text">常用的生命周期方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#constructor-props"><span class="toc-text">constructor(props)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#componentDidMount"><span class="toc-text">componentDidMount()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#componentDidUpdate-prevProps-prevState-snapshot"><span class="toc-text">componentDidUpdate(prevProps, prevState, snapshot)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#componentWillUnmount"><span class="toc-text">componentWillUnmount()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-text">不常用的生命周期方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#shouldComponentUpdate-nextProps-nextState"><span class="toc-text">shouldComponentUpdate(nextProps, nextState)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hook"><span class="toc-text">Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook-%E8%A7%84%E5%88%99"><span class="toc-text">Hook 规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E5%9C%A8%E6%9C%80%E9%A1%B6%E5%B1%82%E4%BD%BF%E7%94%A8-Hook"><span class="toc-text">只在最顶层使用 Hook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E5%9C%A8-React-%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8-Hook"><span class="toc-text">只在 React 函数中调用 Hook</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useState"><span class="toc-text">useState</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%A6%81"><span class="toc-text">概要</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%83%BD%E7%94%A8%E5%85%B6%E4%BB%96%E7%8A%B6%E6%80%81%E8%AE%A1%E7%AE%97%E5%87%BA%E6%9D%A5%E5%B0%B1%E4%B8%8D%E7%94%A8%E5%8D%95%E7%8B%AC%E5%A3%B0%E6%98%8E%E7%8A%B6%E6%80%81%E3%80%82"><span class="toc-text">能用其他状态计算出来就不用单独声明状态。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%94%AF%E4%B8%80"><span class="toc-text">保证数据源唯一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#useState-%E9%80%82%E5%BD%93%E5%90%88%E5%B9%B6"><span class="toc-text">useState 适当合并</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%9B%B4%E6%96%B0"><span class="toc-text">函数式更新</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B-state"><span class="toc-text">惰性初始 state</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%B3%E8%BF%87-state-%E6%9B%B4%E6%96%B0"><span class="toc-text">跳过 state 更新</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useEffect"><span class="toc-text">useEffect</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E9%9C%80%E6%B8%85%E9%99%A4%E7%9A%84-effect"><span class="toc-text">无需清除的 effect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B8%85%E9%99%A4%E7%9A%84-effect"><span class="toc-text">需要清除的 effect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-1"><span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA-Effect-%E5%AE%9E%E7%8E%B0%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB"><span class="toc-text">使用多个 Effect 实现关注点分离</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%B7%B3%E8%BF%87-Effect-%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">通过跳过 Effect 进行性能优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E7%9A%84-effect-%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A2%91%E7%B9%81%E5%8F%98%E5%8C%96%EF%BC%8C%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">如果我的 effect 的依赖频繁变化，我该怎么办？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%90%86%E8%A7%A3"><span class="toc-text">自己理解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useRef"><span class="toc-text">useRef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useCallback"><span class="toc-text">useCallback</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">关于使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useMemo"><span class="toc-text">useMemo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useImperativeHandle"><span class="toc-text">useImperativeHandle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useReducer"><span class="toc-text">useReducer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89hook"><span class="toc-text">自定义hook</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-memo"><span class="toc-text">React.memo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#React-PureComponent"><span class="toc-text">React.PureComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-memo-1"><span class="toc-text">React.memo</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redux"><span class="toc-text">Redux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redux%E7%90%86%E8%A7%A3"><span class="toc-text">redux理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8redux"><span class="toc-text">什么情况下需要使用redux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redux%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">redux工作流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redux%E7%9A%84%E4%B8%89%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">redux的三个核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#action"><span class="toc-text">action</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reducer"><span class="toc-text">reducer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#store"><span class="toc-text">store</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-text">队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">二叉树的种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">二叉树的存储方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-text">二叉树的遍历方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-text">数组排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E8%87%AA%E5%B8%A6%E6%8E%92%E5%BA%8F"><span class="toc-text">JS自带排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%88%E4%BB%85%E6%95%B0%E5%AD%97%EF%BC%89"><span class="toc-text">排序数组（仅数字）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%81%94%E5%90%88%E6%8E%92%E5%BA%8F"><span class="toc-text">数字和字符串联合排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble-Sort%EF%BC%89"><span class="toc-text">冒泡排序（Bubble Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion-Sort%EF%BC%89"><span class="toc-text">插入排序（Insertion Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Selection-Sort%EF%BC%89"><span class="toc-text">选择排序（Selection Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quick-Sort%EF%BC%89"><span class="toc-text">快速排序（Quick Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Merge-Sort%EF%BC%89"><span class="toc-text">归并排序（Merge Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Shell-Sort%EF%BC%89"><span class="toc-text">希尔排序（Shell Sort）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%EF%BC%88%E6%A0%88-%E5%93%88%E5%B8%8C%E8%A1%A8Map%EF%BC%89"><span class="toc-text">有效的括号（栈+哈希表Map）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%88%E9%80%86%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-text">合并两个有序数组（逆向双指针）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">爬楼梯(动态规划)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%80%92%E5%BD%92%E4%BC%9A%E8%B6%85%E6%97%B6"><span class="toc-text">斐波那契数列(动态规划) 递归会超时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">三数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3-%E3%80%81%E9%80%92%E5%BD%92%EF%BC%89"><span class="toc-text">反转链表（迭代 、递归）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">迭代 双指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8map%E3%80%81%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-text">环形链表（哈希表map、快慢指针）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%9F%E5%8A%A9%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">借助哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-text">快慢指针法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88BFS%EF%BC%89"><span class="toc-text">二叉树的最大深度（BFS）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BFS-%E5%85%B8%E5%9E%8B%E7%9A%84BFS%E6%A8%A1%E6%9D%BF%E5%86%99%E6%B3%95"><span class="toc-text">BFS (典型的BFS模板写法)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-%E5%93%88%E5%B8%8C%E8%A1%A8map"><span class="toc-text">两数之和(哈希表map)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-text">最长公共前缀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E4%B8%AA%E6%AF%94%E8%BE%83"><span class="toc-text">逐个比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">合并两个有序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92-1"><span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88BFS-%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-text">二叉树的层序遍历（BFS 队列）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-text">字符串相加（双指针）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%A0%E5%80%92%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-text">颠倒字符串中的单词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的前序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-2"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-text">迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-%E9%9D%9E%E7%BB%9F%E4%B8%80%E6%A0%BC%E5%BC%8F"><span class="toc-text">方法一 非统一格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-%E7%BB%9F%E4%B8%80%E6%A0%BC%E5%BC%8F"><span class="toc-text">方法二 统一格式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-text">删除字符串中的所有相邻重复项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%83%E4%BD%8D%E5%88%86%E9%9A%94%E6%95%B0"><span class="toc-text">千位分隔数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E6%95%B0"><span class="toc-text">回文数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">只出现一次的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%EF%BC%88%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%89"><span class="toc-text">x 的平方根（二分法）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%A0%E9%81%93"><span class="toc-text">渠道</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/28d62aa4.html" title="居中布局与Flex"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/14.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="居中布局与Flex"></a><div class="content"><a class="title" href="/posts/28d62aa4.html" title="居中布局与Flex">居中布局与Flex</a><time datetime="2022-04-02T10:14:52.000Z" title="发表于 2022-04-02 18:14:52">2022-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/24025dd2.html" title="原型和继承"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/13.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="原型和继承"></a><div class="content"><a class="title" href="/posts/24025dd2.html" title="原型和继承">原型和继承</a><time datetime="2022-04-01T11:12:22.000Z" title="发表于 2022-04-01 19:12:22">2022-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9a4e49b6.html" title="let、const和var的区别"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/2.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="let、const和var的区别"></a><div class="content"><a class="title" href="/posts/9a4e49b6.html" title="let、const和var的区别">let、const和var的区别</a><time datetime="2022-04-01T04:22:32.000Z" title="发表于 2022-04-01 12:22:32">2022-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/90460439.html" title="this指向与箭头函数"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/2.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="this指向与箭头函数"></a><div class="content"><a class="title" href="/posts/90460439.html" title="this指向与箭头函数">this指向与箭头函数</a><time datetime="2022-03-30T13:01:02.000Z" title="发表于 2022-03-30 21:01:02">2022-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/447bd1ff.html" title="DOM事件总结"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/15.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="DOM事件总结"></a><div class="content"><a class="title" href="/posts/447bd1ff.html" title="DOM事件总结">DOM事件总结</a><time datetime="2022-03-29T12:11:52.000Z" title="发表于 2022-03-29 20:11:52">2022-03-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Leslie Waong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:""},null))},e=()=>{twikoo.getCommentsCount({envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))},n=(n=!1)=>{"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})};btf.loadComment(document.getElementById("twikoo-wrap"),n)})()</script></div><div class="aplayer no-destroy" data-id="6995412795" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="auto" data-autoplay="true" muted></div><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":0,"vOffset":0},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body></html>