<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MQ | Leslie Waong</title><meta name="keywords" content="前端 Java 空间光通信"><meta name="author" content="Leslie Waong"><meta name="copyright" content="Leslie Waong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTML&amp;CSS语义化★ 考察公司：小米、字节  语义化，指选择合乎语义的标签  使文本内容的结构化， 便于开发者阅读、维护和写出更优雅的代码， 同时让浏览器的爬虫和辅助技术更好的解析。  常用的一些语义化标签  &lt;h1&gt;~&lt;h6&gt; ，标题 &lt;p&gt; 段落 &lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;，无序、有序列表 &lt;table"><meta property="og:type" content="article"><meta property="og:title" content="MQ"><meta property="og:url" content="https://lesliewaong.top/posts/186242d5.html"><meta property="og:site_name" content="Leslie Waong"><meta property="og:description" content="HTML&amp;CSS语义化★ 考察公司：小米、字节  语义化，指选择合乎语义的标签  使文本内容的结构化， 便于开发者阅读、维护和写出更优雅的代码， 同时让浏览器的爬虫和辅助技术更好的解析。  常用的一些语义化标签  &lt;h1&gt;~&lt;h6&gt; ，标题 &lt;p&gt; 段落 &lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;，无序、有序列表 &lt;table"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/8.webp"><meta property="article:published_time" content="2022-01-01T08:46:40.000Z"><meta property="article:modified_time" content="2022-10-18T03:35:10.156Z"><meta property="article:author" content="Leslie Waong"><meta property="article:tag" content="前端 Java 空间光通信"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/8.webp"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg"><link rel="canonical" href="https://lesliewaong.top/posts/186242d5"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"一年之内的产物",messageNext:"技术可能存在过期"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Leslie Waong",link:"链接: ",source:"来源: Leslie Waong",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"MQ",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-10-18 11:35:10"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px");const a=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};a(),document.addEventListener("pjax:complete",a)})(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Leslie Waong" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">122</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li><li><a class="site-page child" href="/item/test/"><i class="fa-fw fa fa-star"></i><span> test</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/8.webp)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leslie Waong</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li><li><a class="site-page child" href="/item/test/"><i class="fa-fw fa fa-star"></i><span> test</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MQ</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-01T08:46:40.000Z" title="发表于 2022-01-01 16:46:40">2022-01-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-18T03:35:10.156Z" title="更新于 2022-10-18 11:35:10">2022-10-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">232.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>795分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="MQ"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML&amp;CSS"></a>HTML&amp;CSS</h1><h2 id="语义化★"><a href="#语义化★" class="headerlink" title="语义化★"></a>语义化★</h2><blockquote><p>考察公司：小米、字节</p></blockquote><p>语义化，指<strong>选择合乎语义的标签</strong></p><ul><li>使<strong>文本内容的结构化</strong>，</li><li>便于<strong>开发者阅读</strong>、<strong>维护和写出更优雅的代码，</strong></li><li>同时让浏览器的<strong>爬虫和辅助技术</strong>更好的解析。</li></ul><p><strong>常用的一些语义化标签</strong></p><ul><li><code>&lt;h1&gt;~&lt;h6&gt;</code> ，标题</li><li><code>&lt;p&gt;</code> 段落</li><li><code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>，无序、有序列表</li><li><code>&lt;table&gt;</code>、<code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;td&gt;</code>、<code>&lt;th&gt;</code>、<code>&lt;caption&gt;</code>， 表格</li></ul><p><strong>HTML5新增</strong></p><ul><li><code>header</code>：头部,包裹目录部分、搜索框、一个nav或者任何相关的logo</li><li><code>main</code>：主体,唯一的，其后代元素常常包括<code>&lt;article&gt;</code></li><li><code>nav</code>：导航,一般和<code>ul</code>、<code>li</code>配合做导航栏</li><li><code>footer</code>：底部,通常包含作者、版权信息或者相关链接等</li><li><code>aside</code>：侧边栏,作为主要内容的附属信息，如索引，词条列表</li><li><code>article</code>：独立文章,通常带有标题，当article内嵌article时，里外层的内容应该是相关的</li><li><code>section</code>：独立区块,它是整体的一部分，或者是文章的一节，一般来说section也会带有标题</li><li><code>div</code>：作为一个没有任何语义，仅仅是用来构建结构的元素，是<strong>最适合做容器的标签。</strong></li></ul><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/byFgUA"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/07/byFgUA.png" alt="byFgUA.png"></a></p><p><strong>滥用的语义化</strong></p><ul><li><p><code>p</code>：不要用来增加额外的空白段落，应使用<code>CSS</code>的<code>margin/padding</code>来实现；</p></li><li><p><code>&lt;h1&gt;~&lt;h6&gt;</code>：该标签可以使文本字体变大，变粗，但如果文本<strong>并非是标题</strong>，应该使用<code>CSS font-weight font-size</code>；</p></li><li><p>不要将<code>&lt;b&gt;</code>元素与 <code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>或<code>&lt;mark&gt;</code>元素混淆。</p><ul><li><code>&lt;strong&gt;</code>用来对一个句子的部分增加<strong>重要性</strong>。（<strong>粗体</strong>）</li><li><code>&lt;em&gt;</code>用于改变一个句子的意思，<strong>强调</strong>某些文本。（<em>斜体</em>）</li><li><code>&lt;mark&gt;</code>表示上下文的<strong>关联性</strong>。（高亮）</li><li><code>&lt;b&gt;</code>用于<strong>吸引读者的注意</strong>到该元素的内容上，仅在没有其他合适的元素时使用它，如摘要中的关键字（<strong>粗体</strong>）</li></ul><p>如果不是出于语义目的而使用 <code>&lt;b&gt;</code> 元素，那么让文本显示粗体更好的方式是使用将 CSS 的 <code>font-weight</code> 属性设置为 <code>&quot;bold&quot;</code>。</p></li></ul><h2 id="H5新特性★"><a href="#H5新特性★" class="headerlink" title="H5新特性★"></a>H5新特性★</h2><blockquote><p>考察公司：小米</p></blockquote><ul><li><p>新增<strong>语义化</strong>标签。</p></li><li><p>H5提供了<code>sessionStorage</code>、<code>localStorage</code>和<code>indexedDB</code>加强本地存储。</p></li><li><p>input标签新增属性:</p><ul><li><p>placeholder属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>autofocus属性，页面只能有一个,自动获得焦点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">autofocus</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>canvas</code> 是 HTML5 新定义的标签，通过使用脚本（通常是 JavaScript）绘制图形。<code>&lt;canvas&gt;</code> 标签只是图形容器，相当于一个画布，<code>canvas</code> 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成，相当于使用画笔在画布上画画。</p><p>默认情况下，<code>&lt;canvas&gt;</code> 没有边框和内容。默认是一个 300*150 的画布，所以我们创建了 <code>&lt;canvas&gt;</code> 之后要对其设置宽高。</p><p>我们可以通过html属性<code>width</code>，<code>height</code>来设置canvas的宽高，不可以通过 css 属性来设置宽高。因为通过 css 属性设置的宽高会使 canvas 内的图像按照 300*150 时的比例放大或缩小。</p></li><li><p>地理(<code>Geolocation</code>) API</p></li><li><p>音频、视频API(<code>audio</code>、<code>video</code>)</p></li><li><p><code>webworker</code>, <code>websocket</code></p><ul><li><p><code>webworker</code>是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过<code>postMessage</code>传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。</p><p>双方都使用<code>postMessage()</code>方法发送各自的消息，使用<code>onmessage</code>事件处理函数来响应消息（消息被包含在<code>Message</code>事件的data属性中）。这个过程中数据并不是被共享而是被复制。</p><p><strong>但不能访问 DOM</strong>— 不能让一个worker直接更新UI。</p></li><li><p><code>WebSocket</code>是HTML5的一个持久化的协议，它实现了<strong>浏览器与服务器的全双工通信</strong>，同时也是跨域的一种解决方案。</p><p><code>WebSocket</code>和<code>HTTP</code>都是<strong>应用层协议</strong>，都基于 <code>TCP</code> 协议。</p><p>但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。</p><p>同时，<code>WebSocket</code> 在建立连接时需要借助 <code>HTTP</code> 协议，连接建立好了之后 <code>client</code> 与 <code>server</code> 之间的双向通信就与 <code>HTTP</code> 无关了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建WebSocket连接</span></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:8080&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接打开，发送数据</span></span><br><span class="line">socket.addEventListener(<span class="string">&#x27;open&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    socket.send(<span class="string">&#x27;Hello Server!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听数据</span></span><br><span class="line">socket.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Message from server &#x27;</span>, event.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="CSS盒模型-行内元素、块元素★"><a href="#CSS盒模型-行内元素、块元素★" class="headerlink" title="CSS盒模型 / 行内元素、块元素★"></a>CSS盒模型 / 行内元素、块元素★</h2><blockquote><p>考察公司：完美世界、字节、百度</p></blockquote><h3 id="块级盒子-block-box-和内联盒子-block-box"><a href="#块级盒子-block-box-和内联盒子-block-box" class="headerlink" title="块级盒子 (block box) 和内联盒子(block box)"></a>块级盒子 (block box) 和内联盒子(block box)</h3><p>块级盒子 (block box)：</p><ul><li><strong>在绝大数情况下意味着盒子会和父容器一样宽</strong></li><li>每个盒子都会<strong>换行</strong></li><li><code>width</code>和 <code>height</code> 属性可以发挥作用</li><li>内边距（<code>padding</code>）, 外边距（<code>margin</code>） 和 边框（<code>border</code>） 会将其他元素从当前盒子周围“推开”</li><li>除非特殊指定，诸如标题(<code>&lt;h1&gt;</code>等)、段落(<code>&lt;p&gt;</code>)和<code>div</code>默认情况下都是块级的盒子。</li></ul><p>内联盒子(block box) ：</p><ul><li>盒子<strong>不会产生换行</strong>。</li><li><code>width</code>和 <code>height</code> 属性将不起作用。</li><li><strong>垂直方向的内边距、外边距以及边框</strong>会被应用但是<strong>不会</strong>把其他处于 <code>inline</code> 状态的盒子推开。<ul><li>无内容<ul><li>垂直<code>padding</code>和<code>border</code>单独设置不会生效。</li><li>水平垂直<code>padding</code>和<code>border</code>同时设置，垂直<code>padding</code>和<code>border</code>会覆盖其他元素。</li></ul></li><li>有内容<ul><li>垂直<code>padding</code>和<code>border</code>会覆盖其他元素。</li></ul></li><li>不论有无内容，垂直<code>margin</code>不生效</li></ul></li><li><strong>水平方向的内边距、外边距以及边框</strong>会被应用且<strong>会</strong>把其他处于 <code>inline</code> 状态的盒子推开。</li><li>用做链接的 <code>&lt;a&gt;</code> 元素、 <code>&lt;span&gt;</code>、 <code>&lt;em&gt;</code> 以及 <code>&lt;strong&gt;</code> 都是默认处于 <code>inline</code> 状态的。</li></ul><p>我们通过对盒子<code>display</code> 属性的设置，比如 <code>inline</code> 或者 <code>block</code> ，来控制盒子的外部显示类型。</p><h3 id="inline，block，inline-block"><a href="#inline，block，inline-block" class="headerlink" title="inline，block，inline-block"></a>inline，block，inline-block</h3><blockquote><p>HTML 标准中块级元素和行内元素的区别至高出现在 4.01 标准中。</p><p>在 HTML5，这种区别被一个更复杂的内容类别代替。</p><p>”块级“类别大致相当于 HTML5 中的<code>Flow content(流内容)</code>类别，</p><p>而”行内“类别相当于 HTML5 中的<code>Phrasing content(短语内容)</code>类别，不过除了这两个还有其他类别。</p></blockquote><p>同块级盒子（块级元素）和内联盒子（行内元素）。</p><p>行内元素：</p><ul><li>一般情况下<strong>只能包含数据和其他行内元素</strong>。</li><li>一般是<strong>内容的容器</strong>。</li></ul><p>块级元素：</p><ul><li><strong>包含行内元素和其他块级元素</strong>。</li><li>适合做<strong>布局</strong>。</li></ul><p><strong>行内块元素</strong></p><ul><li><strong>既可以设置宽高，又可以和其他行内元素并排</strong>。</li><li><code>inline-block</code>的<code>margin、padding</code>会生效，而且<strong>不会发生外边距重叠</strong>。</li><li><code>inline</code>和<code>inline-block</code>会引起<strong>间距</strong>。这个间距是有<strong>空格</strong>或<strong>换行</strong>导致的。解决方法一：<strong>将空格直接删除，放到一行</strong></li></ul><p><strong>转换</strong></p><ul><li><strong>float:</strong> 行内=&gt;块。</li><li><strong>position:</strong> <code>position:absolute/fixed</code>，行内=&gt;块。</li><li><strong>display:</strong><ul><li><code>display:inline;</code></li><li><code>display:block;</code></li><li><code>display:inline-block;</code></li></ul></li></ul><h3 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h3><p>完整的 CSS 盒模型应用于<strong>块级盒子</strong>，<strong>内联盒子只使用盒模型中定义的部分内容</strong>。</p><ul><li><code>margin</code> 外边距</li><li><code>border</code> 边框</li><li><code>padding</code> 内边距</li><li><code>content</code> 内容区</li></ul><h3 id="标准盒模型和IE盒子模型"><a href="#标准盒模型和IE盒子模型" class="headerlink" title="标准盒模型和IE盒子模型"></a>标准盒模型和IE盒子模型</h3><p>CSS标准盒模型和IE盒模型的区别：</p><ul><li><p>在 <strong>标准盒子模型</strong>中，<strong>width 和 height 指的是内容区域</strong>的宽度和高度。</p></li><li><p><strong>IE盒子模型</strong>中，<strong>width 和 height 指的是内容区域+padding+border</strong>的宽度和高度。</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置当前盒子为 标准盒模型（默认） */</span></span><br><span class="line"><span class="attribute">box-sizing</span>: content-box;</span><br><span class="line"><span class="comment">/* 设置当前盒子为 IE盒模型 */</span></span><br><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br></pre></td></tr></table></figure><h2 id="BFC-消除浮动★"><a href="#BFC-消除浮动★" class="headerlink" title="BFC/消除浮动★"></a>BFC/消除浮动★</h2><blockquote><p>考察公司：字节、百度、b站</p></blockquote><p><strong>块级格式化上下文（Block Formatting Context，BFC）</strong>是 Web 页面的可视 CSS 渲染的一部分，是块级盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p><p>可以看作是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。</p><p><strong>生成</strong></p><ul><li>根元素（<code>&lt;html&gt;</code>）</li><li>浮动元素（<code>float</code>值不为 <code>none</code>）</li><li>绝对定位元素（<code>position</code>值为 <code>absolute</code> 或 <code>fixed</code>）</li><li><code>overflow</code>值不为 <code>visible</code>、<code>clip</code> 的块元素</li><li>行内块元素（<code>display</code>值为 <code>inline-block</code>）</li><li>表格单元格（<code>display</code>值为 <code>table-cell</code>，HTML 表格单元格默认值）</li><li>表格标题（<code>display</code>值为 <code>table-caption</code>，HTML 表格标题默认值）</li><li>匿名表格单元格元素（<code>display</code>值为 <code>table</code>、<code>table-row</code>、 <code>table-row-group</code>、<code>table-header-group</code>、<code>table-footer-group</code>（分别是 HTML table、tr、tbody、thead、tfoot 的默认值）或 <code>inline-table</code>）</li><li><code>display</code>]值为 <code>flow-root</code> 的元素</li><li><code>contain</code> 值为 <code>layout</code>、<code>content</code> 或 <code>paint</code> 的元素</li><li>弹性元素（<code>display</code> 值为 <code>flex</code> 或 <code>inline-flex</code> 元素的直接子元素），如果它们本身既不是 flex、grid 也不是 table 容器</li><li>网格元素（<code>display</code>值为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素），如果它们本身既不是 flex、grid也不是 table容器</li><li>多列容器（<code>column-count</code> 或 <code>column-width</code> 值不为 <code>auto</code>，包括<code>column-count</code> 为 <code>1</code>）</li><li><code>column-span</code> 值为 <code>all</code> 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中 (<a target="_blank" rel="noopener" href="https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51">规范变更</a>, <a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/chromium/issues/detail?id=709362">Chrome bug</a>)</li></ul><p>格式化上下文影响布局，通常，我们会为定位和清除浮动创建新的 BFC，而不是更改布局，因为它将：</p><ul><li><strong>包含内部浮动</strong></li><li><strong>排除外部浮动</strong></li><li><strong>阻止外边距重叠</strong></li></ul><p><strong>备注：</strong> flex/grid 容器（<code>display：flex/grid/inline-flex/inline-grid</code>）建立新的 flex/grid 格式上下文，除布局之外，它与块格式上下文类似。<strong>flex/grid 容器中没有可用的浮动子级，但排除外部浮动和阻止外边距重叠仍然有效。</strong> 在flex/grid容器中，<code>float</code>属性被忽略。</p><h3 id="包含内部浮动"><a href="#包含内部浮动" class="headerlink" title="包含内部浮动"></a>包含内部浮动</h3><p><strong>让浮动内容和周围的内容等高</strong>。</p><p>子元素浮动带来的高度塌陷：</p><ul><li><strong>父元素不设置高度默认是被子元素撑开的</strong>，当<strong>子元素浮动</strong>后，其会完全<strong>脱离文档流</strong>。</li><li>子元素从文档流中脱离，将会无法撑起父元素的高度，<strong>导致父元素的高度丢失</strong>。父元素高度丢失以后，其下的元素会自动上移，导致<strong>页面的布局混乱</strong>。</li></ul><p><strong>解决方案：</strong></p><ul><li><p><strong>使用 <code>overflow: auto</code></strong></p><ul><li>在创建包含浮动元素的 BFC 时，通常的做法是设置父元素 <code>overflow: auto</code> 或者其它除默认的 <code>overflow: visible</code> 以外的值。父元素变成布局中的迷你布局，<strong>任何子元素都会被包含进去</strong>。</li><li>使用 <code>overflow</code> 创建新的 BFC，是因为 <code>overflow</code> 属性会告诉浏览器应该<strong>怎样处理溢出的内容</strong>。</li><li>如果使用它仅仅为了创建 BFC，你<strong>可能会遇到不希望出现的滚动条或阴影</strong>，需要注意。另外，对于后续的开发者，可能不清楚当时为什么使用 <code>overflow</code>，所以最好添加一些注释来解释为什么这样做。</li></ul></li><li><p><strong>使用 <code>display: flow-root</code></strong></p><ul><li>一个新的 <code>display</code> 属性的值，它可以创建<strong>无副作用的 BFC</strong>。在父级块中使用 <code>display: flow-root</code> 可以创建新的 BFC。</li><li>给 <code>&lt;div&gt;</code> 元素设置 <code>display: flow-root</code> 属性后，<code>&lt;div&gt;</code> 中的所有内容都会参与 BFC，浮动的内容不会从底部溢出。</li><li>你可以从 <code>flow-root</code> 这个值的名字上看出来，它创建一个新的用于流式布局的上下文，类似于浏览器的根（<code>html</code>）元素。</li></ul></li><li><p>给父亲设置高度。正所谓<strong>有高度的盒子，才能关住浮动</strong>。</p></li><li><p><strong>伪元素+clear</strong></p><ul><li><p><code>clear</code> 属性指定一个元素是否必须移动(清除浮动后)到<strong>在它之前的浮动元素下面</strong>。</p></li><li><p><strong>要被清除的相关浮动元素</strong>指的是在相同<strong>块级格式化上下文</strong>中的<strong>前置浮动</strong>。</p></li><li><p>具体方法：</p><ul><li>给<strong>浮动元素的容器</strong>添加一个<code>clearfix</code>的class。</li><li>然后给这个class添加一个<code>::after</code>(用来创建一个伪元素，作为已选中元素的最后一个子元素)，</li><li>内容为空即没有高度看不到，但<code>display: block;</code>宽度仍然占满父元素，方便判断之前的左右浮动以清理。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.father</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: pink;</span></span><br><span class="line"><span class="css">        <span class="comment">/* overflow: hidden; */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* display: flow-root; */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* 注意 flex容器中不包含可用的浮动子级，也就是子元素浮动属性会失效 */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* display: flex; */</span></span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.son</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 确保该元素是一个块级元素 */</span></span></span><br><span class="line"><span class="css">        <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="css">        <span class="comment">/*清除浮动*/</span></span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;father clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">        hello son</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="排除外部浮动"><a href="#排除外部浮动" class="headerlink" title="排除外部浮动"></a>排除外部浮动</h3><p>我们可以使用 <code>display: flow-root</code> 和浮动实现双列布局，因为<strong>正常文档流中建立的 BFC 不得与元素本身所在的块格式化上下文中的任何浮动的外边距重叠</strong>。</p><p>flexbox 是在现代 CSS 中实现多列布局的更有效的方法。</p><h3 id="外边距重叠"><a href="#外边距重叠" class="headerlink" title="外边距重叠"></a>外边距重叠</h3><ul><li><p>解决margin重叠（父子、兄弟元素）</p><ul><li><strong>标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin</strong>(水平方向的margin是可以叠加的）。</li><li>且<strong>只会发生在块级元素</strong>，行内元素和行内块元素不会出现。</li><li><strong>儿子和父亲在竖直方向上为一个margin</strong>。</li><li>解决办法：<strong>给子元素或父元素（兄弟元素）创建BFC</strong>。</li></ul></li><li><p>同一层相邻元素之间</p><ul><li>相邻的两个元素之间的外边距重叠，除非后一个元素加上<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear">clear-fix 清除浮动</a>。</li></ul></li><li><p>没有内容将父元素和后代元素分开</p><ul><li>如果没有边框<code>border</code>，内边距<code>padding</code>，行内内容，也没有创建块级格式上下文或清除浮动来分开一个块级元素的上边界<code>margin-top</code>与其内一个或多个后代块级元素的上边界<code>margin-top</code>；</li><li>或没有边框，内边距，行内内容，高度<code>height</code>，最小高度<code>min-height</code>或 最大高度<code>max-height</code>来分开一个块级元素的下边界<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-bottom"><code>margin-bottom</code></a>与其内的一个或多个后代块元素的下边界<code>margin-bottom</code>，</li><li>则就会出现父块元素和其内后代块元素外边界重叠，重叠部分最终会溢出到父级块元素外面。</li></ul></li></ul><ul><li><p>空的块级元素</p><ul><li>当一个块元素上边界<code>margin-top</code> 直接贴到元素下边界<code>margin-bottom</code>时也会发生边界折叠。</li><li>这种情况会发生在一个块元素<strong>完全没有</strong>设定边框<code>border</code>、内边距<code>padding</code>、高度<code>height</code>、最小高度<code>min-height</code> 、最大高度<code>max-height</code>、内容设定为 inline 或是加上clear-fix的时候。</li></ul></li><li><p>一些需要注意的地方：</p><ul><li>上述情况的组合会产生更复杂的外边距折叠。</li><li>即使某一外边距为 0，这些规则仍然适用。因此就算<strong>父元素的外边距是 0</strong>，第一个或最后一个子元素的外边距仍然会“溢出”到父元素的外面。</li><li>如果参与折叠的外边距中包含<strong>负值</strong>，折叠后的外边距的值为<strong>最大的正边距与最小的负边距（即绝对值最大的负边距）的和</strong>；也就是说如果有 -13px 8px 100px 叠在一起，边界范围的技术就是 100px -13px 的 87px。</li><li>如果所有参与折叠的外边距<strong>都为负</strong>，折叠后的外边距的值为<strong>最小的负边距的值</strong>。这一规则适用于相邻元素和嵌套元素。</li></ul><p>以上这些内容都是发生在 Block-Level 的元素，设定 <code>floating</code> 和 <code>absolutely positioned</code> 的元素完全不用担心边界重叠的问题。</p></li></ul><h2 id="Flex★"><a href="#Flex★" class="headerlink" title="Flex★"></a>Flex★</h2><blockquote><p>考察公司：完美世界、字节</p></blockquote><p>Flex是Flexible Box的缩写，翻译成中文就是“<strong>弹性盒子</strong>”，用来为盒模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。</p><p>采用Flex布局的元素，被称为**Flex容器(flex container)**，简称“容器”。</p><p>其所有子元素自动成为容器成员，成为**Flex项目(Flex item)**，简称“项目”。</p><p>容器默认存在两根轴：<strong>水平方向</strong>主轴(main axis)和垂直方向交叉轴(cross axis)，<strong>默认项目按主轴排列</strong>。</p><h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><ul><li><p><strong>flex-flow</strong></p><ul><li><code>flex-direction</code>（主轴的方向） 默认<code>row</code>（水平）</li><li><code>flex-wrap</code>（换行），默认<code>nowrap</code>（不换行）</li></ul></li><li><p><strong>justify-content</strong></p><ul><li>定义项目在<strong>主轴上的对齐方式</strong>。</li><li><code>justify-content:center</code> 默认用作<strong>水平居中</strong>。</li></ul></li><li><p><strong>align-items</strong></p><ul><li>定义在<strong>交叉轴上的对齐方式</strong></li><li><code>align-items:center</code> 默认用作<strong>垂直居中</strong>。</li></ul></li><li><p><strong>align-content</strong></p><ul><li>定义<strong>多根轴线的对齐方式</strong></li><li>必须通过<code>flex-wrap</code>先有多根轴线</li></ul></li></ul><h3 id="元素属性"><a href="#元素属性" class="headerlink" title="元素属性"></a>元素属性</h3><ul><li><p><strong>align-self</strong></p><p>定义<strong>单个项目的对齐方式</strong>，常用于<strong>居中布局</strong>。</p></li><li><p><strong>flex</strong></p><p><strong>flex-grow，flex-shrink和flex-basis的简写</strong></p><p>默认值为<code>0 1 auto</code>，<strong>第一个属性必须</strong>，后两个属性可选。</p><ul><li><code>flex-grow</code>定义项目的放大比例<ul><li><strong>容器宽度&gt;元素总宽度</strong>时如何伸展，按比例分配<strong>剩余空间</strong>增加给各元素</li></ul></li></ul></li><li><p><code>flex-shrink</code>定义了项目的缩小比例</p><ul><li><strong>容器宽度&lt;元素总宽度</strong>时如何收缩</li><li>默认为1，即如果空间不足，该项目将缩小。</li><li>赋予<strong>更大的数值</strong>可以比赋予小数值的同级元素<strong>收缩程度更大</strong></li><li>在分配<strong>负空间</strong>时，<strong>收缩系数乘以元素尺寸</strong>。这将<strong>按项目能够收缩的大小比例分配负空间</strong>，因此，例如，一个小项目不会在一个较大的项目显著减少之前收缩为零。</li></ul></li><li><p><code>flex-basis</code>定义在分配多余空间之前，项目占据的主轴空间。</p><ul><li>flex容器里除了元素所占的空间以外的富余空间就是<strong>可用空间</strong> 。</li><li>该属性的默认值是 <code>auto</code> 。此时，浏览器会检测这个元素是否具有确定的尺寸。</li><li>如果没有给元素设定尺寸，<code>flex-basis</code> 的值采用元素<strong>内容的尺寸</strong>。</li><li>所以我们给只要给Flex元素的父元素声明 <code>display: flex</code> ，所有子元素就会排成一行，且自动分配小大以充分展示元素的内容。</li></ul></li><li><p>常见一些属性有：</p><ul><li><p><code>flex: 1</code> = <code>flex: 1 1 0</code>，常用作<strong>自适应布局</strong>。</p></li><li><p><code>flex: 2</code> = <code>flex: 2 1 0</code></p></li><li><p><code>flex: auto</code> = <code>flex: 1 1 auto</code></p></li><li><p><code>flex: none</code> = <code>flex: 0 0 auto</code>，常用于<strong>固定尺寸不伸缩</strong></p></li></ul></li><li><p><code>flex:1</code> 和 <code>flex:auto</code> 的区别，可以归结于<code>flex-basis:0</code>和<code>flex-basis:auto</code>的区别。</p><ul><li><p>当设置为<code>0</code>时（绝对弹性元素），伸缩时不考虑元素尺寸。</p></li><li><p>当设置为<code>auto</code>时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑。</p></li></ul></li></ul><ul><li><p><strong>order</strong></p><p>定义项目的<strong>排列顺序</strong>。<strong>数值越小，排列越靠前</strong>，默认为0，可以是负值。</p></li></ul><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.parent</span> &gt; <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.item-1</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">140px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">flex</span>: <span class="number">2</span> <span class="number">1</span> <span class="number">0%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: blue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.item-2</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">flex</span>: <span class="number">2</span> <span class="number">1</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: darkblue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.item-3</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: lightblue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>主轴上父容器总尺寸为 600px</li><li>子元素的总基准值是：<code>0% + auto + 200px = 300px</code>，其中<ol><li>0% 即 0 宽度</li><li>auto 对应取主尺寸即 100px</li></ol></li><li>故剩余空间为 <code>600px - 300px = 300px</code></li><li>伸缩放大系数之和为： <code>2 + 2 + 1 = 5</code></li><li>剩余空间分配如下：<ol><li>- item-1 和 item-2 各分配 2/5，各得 120px</li><li>- item-3 分配 1/5，得 60px</li></ol></li><li>各项目最终宽度为：<ol><li>- item-1 = <code>0% + 120px = 120px</code></li><li>- item-2 = <code>auto + 120px = 220px</code></li><li>- item-3 = <code>200px + 60px = 260px</code></li></ol></li><li>当 item-1 基准值取 0% 的时候，是<strong>把该项目视为零尺寸的，故即便声明其尺寸为 140px，也并没有什么用，形同虚设</strong></li><li>而 item-2 基准值取 <code>auto</code> 的时候，根据规则基准值使用值是主尺寸值即 100px，故<strong>这 100px 不会纳入剩余空间</strong></li></ul><h2 id="居中布局★"><a href="#居中布局★" class="headerlink" title="居中布局★"></a>居中布局★</h2><blockquote><p>考察公司：完美世界、字节、腾讯、百度</p></blockquote><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ul><li><p><code>text-align: center</code></p><ul><li>设置<strong>块元素或表格单元格</strong>中<strong>内容</strong>的水平对齐方式。</li><li><strong>不能直接用于行内元素</strong> 。</li><li>另外，这个内容不一定是行内元素，块元素中有h1(块元素)一样可以实现效果。</li></ul></li><li><p><code>margin: 0 auto</code></p><ul><li>计算元素对应方向上应该获得的<strong>剩余空间</strong>大小。</li><li>因为块级元素设置宽度后仍占据一行空间，<code>margin: 0 auto</code>会将这一行的剩余空间平均分配给左右外边距。</li><li><code>margin:auto</code> 能使<strong>块级元素</strong>水平居中，但是不能垂直居中，因为<strong>垂直方向上默认没有剩余的空间</strong>。</li><li><code>margin:auto</code> <strong>行内元素</strong>既不能水平居中也不能垂直居中，因为行内元素<strong>水平垂直方向上默认都没有剩余的空间</strong>。</li></ul></li></ul><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ul><li><code>line-height: 父元素高度</code> 适合文本。</li></ul><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><ul><li><code>flex + justify-content + align-items</code><ul><li>但对<strong>子元素图片、文字</strong>都有时，<strong>竖直方向</strong>的对齐会有差异</li><li><strong>父元素开启Flex布局</strong>。</li><li>图片子元素设置<code>align-self: center;</code></li><li>文字子元素使用<code>line-height: 父元素高度</code>。</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">align-self</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>absolute + transform</code><ul><li><code>top,left</code>跟根据<strong>父元素的宽和高</strong>偏移的。<code>top: 50%;left: 50%;</code> 元素左上角居中。</li><li><code>transform: translate(-50%, -50%);</code>是根据<strong>自身的宽高</strong>偏移的。</li><li>这个<strong>计算的元素自身不包含margin</strong>，用此方法要注意设置<code>margin: 0;</code></li><li>也可以<code>margin</code>和<code>absolute</code>结合实现居中布局<ul><li><code>absolute(top:50%;left:50%;) + 负margin</code></li><li><code>absolute(top:0;left:0;right:0;bottom:0;)+margin:auto</code></li></ul></li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wp</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;  </span><br><span class="line">&#125;     </span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li><strong>网格布局（Grid）</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    justify-items: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.small</span> &#123;</span><br><span class="line">    justify-self: center;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="position定位-★"><a href="#position定位-★" class="headerlink" title="position定位 ★"></a>position定位 ★</h2><blockquote><p>考察公司：完美世界</p></blockquote><ul><li><p><strong>Static</strong></p><ul><li>元素的默认定位方式，元素出现在<strong>正常的文档流</strong>中，会<strong>占用页面空间</strong>。</li><li>该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。</li><li>此时 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 和 <code>z-index</code> 属性无效。</li></ul></li><li><p><strong>Relative</strong></p><ul><li>相对定位方式，<strong>相对于其父级元素</strong>（无论父级元素此时为何种定位方式）进行定位。</li><li>准确地说是<strong>相对于其父级元素所剩余的未被占用的空间进行定位</strong>（在父元素有多个相对定位的子元素时可以看出），且<strong>会占用该元素在文档中初始的页面空间</strong>，即在使用top，bottom，left，right进行移动位置之后依旧<strong>不会改变其所占用空间的位置</strong>。</li><li>元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此<strong>会在此元素未添加定位时所在位置留下空白</strong>）。</li><li>可以使用<code>z-index</code>进行在z轴方向上的移动。</li></ul></li><li><p><strong>Absolute</strong></p><ul><li>绝对定位方式，<strong>脱离文档流，不会占用页面空间</strong>。</li><li><strong>以最近的不是static定位的父级元素</strong>作为参考进行定位，如果其所有的父级元素都是static定位，那么此元素最终则是以<strong>当前窗口</strong>作为参考进行定位。</li><li>可以使用top，bottom，left，right进行位置移动，亦可使用<code>z-index</code>在z轴上面进行移动。</li><li>当元素为此定位时，如果该元素为<strong>内联元素</strong>，则会变为<strong>块级元素</strong>，即可以直接设置其宽和高的值；</li><li>如果该元素为块级元素，则其宽度会由初始的<code>100%</code>变为<code>auto</code>。</li><li>注意：当元素设置为绝对定位时，在没有指定top，bottom，left，right的值时，他们的值并<strong>不是0</strong>，这几个值是有默认值的，默认值就是<strong>该元素设置为绝对定位前所处的正常文档流中的位置</strong>。</li><li>绝对定位的元素可以设置外边距（margins），且<strong>不会与其他边距合并</strong>。</li></ul></li><li><p><strong>Fixed</strong></p><ul><li>绝对定位方式，直接以<strong>浏览器视口</strong>作为参考进行定位。其它特性同absolute定位。</li></ul></li><li><p><strong>sticky</strong></p><ul><li>粘性定位，可以简单理解为relative和fixed布局的混合。</li><li>当粘性约束矩形在可视范围内为relative，反之，则为fixed粘性定位元素。</li><li>如果和它的父元素一样高，则垂直滚动的时候，粘性定位效果是不会出现的，它的定位效果完全受限于父级元素们。</li><li>如果父元素的overflow属性设置了scroll，auto,overlay值，那么，粘性定位将会失效。</li><li>同一容器中多个粘贴定位元素独立偏移，因此可能重叠；位置上下靠在一起的不同容器中的粘贴定位元素则会鸠占鹊巢，挤开原来的元素，形成依次占位的效果。</li></ul></li><li><p>补充</p><ul><li><code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>这四个属性要生效的话,必须得设置<strong>相对定位/绝对定位</strong>。</li><li>子绝父相就是：子元素为绝对定位(<code>position：absolute;</code>)，父元素为相对定位<code>position：relative;</code>。</li><li>当元素祖先的 <code>transform</code>, <code>perspective</code> 或 <code>filter</code> 属性非 <code>none</code> 时，绝对定位（absolute/fixed）参考元素就会变为该祖先。</li></ul></li></ul><h2 id="margin与padding-包含块-★"><a href="#margin与padding-包含块-★" class="headerlink" title="margin与padding 包含块 ★"></a>margin与padding 包含块 ★</h2><blockquote><p>考察公司：b站</p></blockquote><p><code>margin</code>控制的是<strong>元素外部空出的空间</strong>。相反，<code>padding</code>操作<strong>元素内部空出的空间</strong>。</p><p>设置百分比都是相对于<strong>包含块</strong>的<strong>宽度</strong>。</p><p>一个元素的尺寸和位置经常受其**包含块 (containing block)**的影响。</p><p>大多数情况下，<strong>包含块就是这个元素最近的祖先块元素的内容区</strong>，但也不是总是这样。</p><p>对于一些属性，例如 <code>width</code>, <code>height</code>, <code>padding</code>, <code>margin</code>，绝对定位元素的偏移值（比如 <code>position</code> 被设置为 <code>absolute</code> 或 <code>fixed</code>），当我们对其赋予百分比值时，这些值的计算值，就是通过元素的包含块计算得来。</p><p>确定一个元素的包含块的过程完全依赖于这个元素的<code>position</code> 属性：</p><ol><li>如果 position 属性为 <strong><code>static</code><strong>、</strong><code>relative</code></strong> <strong>或 <code>sticky</code><strong>，包含块可能由它的最近的祖先</strong>块元素</strong>（比如说 inline-block, block 或 list-item 元素）的内容区的边缘组成，也可能会建立格式化上下文 (比如说 a table container, flex container, grid container, 或者是 the block container 自身)。</li><li>如果 position 属性为 <strong><code>absolute</code></strong> ，包含块就是由它的最近的 position 的值不是 <code>static</code> （也就是值为<code>fixed</code>, <code>absolute</code>, <code>relative</code> 或 <code>sticky</code>）的祖先元素的内边距区的边缘组成。</li><li>如果 position 属性是 <strong><code>fixed</code><strong>，在连续媒体的情况下 (continuous media) 包含块是</strong>视口</strong> ,在分页媒体 (paged media) 下的情况下包含块是分页区域 (page area)。</li><li>如果 position 属性是<code>absolute</code>或<code>fixed</code>，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：<ol><li><code>transform</code>或 <code>perspective</code>的值不是 <code>none</code></li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change"><code>will-change</code></a> 的值是 <code>transform</code> 或 <code>perspective</code></li><li><code>filter</code> 的值不是 <code>none</code> 或 <code>will-change</code> 的值是 <code>filter</code>(只在 Firefox 下生效).</li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain"><code>contain</code></a> 的值是 <code>paint</code> (例如: <code>contain: paint;</code>)</li></ol></li></ol><p><strong>备注：</strong> 根元素 (<code>&lt;html&gt;</code>) 所在的包含块是一个被称为<strong>初始包含块</strong>的矩形。他的尺寸是视口(for continuous media) 或分页媒体 page media (for paged media).</p><p>如上所述，<strong>如果某些属性被赋予一个百分值的话，它的计算值是由这个元素的包含块计算而来的。这些属性包括盒模型属性和偏移属性：</strong></p><ol><li>要计算 <code>height</code> <code>top</code>及 <code>bottom</code>中的百分值，是通过包含块的 <code>height</code> 的值。如果包含块的 <code>height</code> 值会根据它的内容变化，而且包含块的 <code>position</code> 属性的值被赋予 <code>relative</code> 或 <code>static</code> ，那么，这些值的计算值为 auto（由浏览器为元素计算并选择一个高度。）。</li><li>要计算 <code>width</code>, <code>left</code>, <code>right</code>, <code>padding</code>, <code>margin</code>这些属性由包含块的 <code>width</code> 属性的值来计算它的百分值。</li></ol><blockquote><p>补充：</p></blockquote><p><code>perspective</code>指定了观察者与 z=0 平面的距离，使具有三维位置变换的元素产生透视效果。</p><p><code>will-change</code> 为 web 开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。</p><p>用好这个属性并不是很容易：</p><ul><li><strong>不要将 will-change 应用到太多元素上</strong>：浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与 <code>will-change</code> 结合在一起的话，有可能会消耗很多机器资源，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源。</li><li><strong>有节制地使用：</strong>通常，当元素恢复到初始状态时，浏览器会丢弃掉之前做的优化工作。但是如果直接在样式表中显式声明了 <code>will-change</code> 属性，则表示目标元素可能会经常变化，浏览器会将优化工作保存得比之前更久。所以最佳实践是当元素变化之前和之后通过脚本来切换 <code>will-change</code> 的值。</li><li><strong>不要过早应用 will-change 优化：</strong>如果你的页面在性能方面没什么问题，则不要添加 <code>will-change</code> 属性来榨取一丁点的速度。 <code>will-change</code> 的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题。过度使用 <code>will-change</code> 会导致大量的内存占用，并会导致更复杂的渲染过程，因为浏览器会试图准备可能存在的变化过程。这会导致更严重的性能问题。</li><li><strong>给它足够的工作时间：</strong>这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上 <code>will-change 属性。</code></li></ul><p><code>filter</code> 将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像、背景和边框的渲染。</p><p><code>contain</code>属性允许开发者声明当前元素和它的内容尽可能的<em>独立</em>于 DOM 树的其他部分。这使得浏览器在重新计算布局、样式、绘图、大小或这四项的组合时，只影响到有限的 DOM 区域，而不是整个页面，可以有效改善性能。</p><p>这个属性在包含大量独立组件的页面非常实用，它可以防止某个小部件的 CSS 规则改变对页面上的其他东西造成影响。</p><p><strong>备注：</strong>如果应用（具有值：<code>paint</code>，<code>strict</code>或<code>content</code>），此属性创建：</p><ol><li>一个新的包含块（对于<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的后代）。</li><li>一个新的堆叠上下文。</li><li>一个新的块格式化上下文。</li></ol><h2 id="CSS选择器优先级★"><a href="#CSS选择器优先级★" class="headerlink" title="CSS选择器优先级★"></a>CSS选择器优先级★</h2><blockquote><p>考察公司：百度</p></blockquote><p>CSS 中的权重，指的是<strong>选择器的优先级</strong>。</p><p>对同一HTML元素设置样式时，不同选择器的优先级不同，<strong>优先级低的样式将被高优先级的样式层叠掉</strong>。</p><p>CSS 权重优先级顺序简单表示为：</p><ul><li><code>!important</code></li><li>内联样式(<code>style=&quot;&quot;</code>)</li><li>类(<code>.class属性值</code>)、伪类(<code>:nth-child()</code>)、属性(<code>[属性名]</code>)</li><li>ID (<code>#id属性值</code>)</li><li>标签名(<code>p&#123;&#125;</code>)、伪元素(<code>::after</code>)</li><li>通配符(<code>*</code>)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.red</span> <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: red;&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.green</span> <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: green;&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;green&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>p: 颜色<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>.red p</code>和<code>.green p</code>的选择器权重相同，那么<strong>谁在后面，最后就应用谁</strong>。所以最后是绿色。</p><p>如果<code>red</code>换成id选择器或者添加<code>!important</code>，就会变成红色。</p><p>对于同一个元素设置<strong>z-index不会对选择器权重产生影响</strong>，另外<code>z-index</code> 属性设定了一个<strong>定位元素及其后代元素</strong>或 <strong>flex 项目</strong>的 z-order。 当元素之间重叠的时候， z-index 较大的元素会覆盖较小的元素在上层进行显示。</p><p><strong>继承样式</strong></p><ul><li><strong>继承得到的样式的优先级是最低的</strong>，在任何时候，只要元素本身有同属性的样式定义，就可以覆盖掉继承值。</li><li>在存在多个继承样式时，层级关系距离当前元素最近的父级元素的继承样式，具有相对最高的优先级。</li></ul><h2 id="滚动条-★"><a href="#滚动条-★" class="headerlink" title="滚动条 ★"></a>滚动条 ★</h2><blockquote><p>考察公司：百度</p></blockquote><p>问题：苹果电脑设置始终显示滚动条，会使得页面中设置了滚动条的部分显示滚动条背景色</p><p><strong>CSS 滚动条选择器</strong></p><p>你可以使用以下伪元素选择器去修改<strong>基于 webkit 的浏览器</strong>的滚动条样式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">::<span class="selector-tag">-webkit-scrollbar</span>        		<span class="comment">// 整个滚动条。</span></span><br><span class="line">::<span class="selector-tag">-webkit-scrollbar-button</span> 		<span class="comment">// 滚动条上的按钮（上下箭头）。</span></span><br><span class="line">::<span class="selector-tag">-webkit-scrollbar-thumb</span>  		<span class="comment">// 滚动条上的滚动滑块。</span></span><br><span class="line">::<span class="selector-tag">-webkit-scrollbar-track</span>  		<span class="comment">// 滚动条轨道。</span></span><br><span class="line">::<span class="selector-tag">-webkit-scrollbar-track-piece</span> <span class="comment">// 滚动条没有滑块的轨道部分。</span></span><br><span class="line">::<span class="selector-tag">-webkit-scrollbar-corner</span>      <span class="comment">// 当同时有垂直滚动条和水平滚动条时交汇的部分。通常是浏览器窗口的右下角。</span></span><br><span class="line">::<span class="selector-tag">-webkit-resizer</span>               <span class="comment">// 出现在某些元素底角的可拖动调整大小的滑块。</span></span><br></pre></td></tr></table></figure><p>上述内容不兼容Firefox，火狐64位目前只提供了部分自定义滚动条的属性：</p><ul><li><code>scrollbar-width</code>：该属性可取值：</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrollbar-<span class="attribute">width</span>: auto; <span class="comment">// 默认值</span></span><br><span class="line">scrollbar-<span class="attribute">width</span>: thin; <span class="comment">// 比默认滚动条窄</span></span><br><span class="line">scrollbar-<span class="attribute">width</span>: none; <span class="comment">// 不显示滚动条，但是仍可以滚动 </span></span><br></pre></td></tr></table></figure><ul><li><code>scrollbar-color</code>： 其可填写的值有：</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scrollbar-<span class="attribute">color</span>: auto; <span class="comment">// 默认值</span></span><br><span class="line">scrollbar-<span class="attribute">color</span>: dark;</span><br><span class="line">scrollbar-<span class="attribute">color</span>: light;</span><br><span class="line">scrollbar-<span class="attribute">color</span>: red green; <span class="comment">// 第一个滚轮颜色，第二个滚动条背景色 </span></span><br></pre></td></tr></table></figure><blockquote><p>其中<code>dark</code>和<code>light</code>并没有实现。</p></blockquote><p>使用插件或者自己DIY</p><p>比较好用的插件：</p><ul><li><p><a target="_blank" rel="noopener" href="https://github.com/malihu/malihu-custom-scrollbar-plugin">JQuery Custom Scrollbar</a></p></li><li><p><a target="_blank" rel="noopener" href="https://github.com/mdbootstrap/perfect-scrollbar">Perfect Scrollbar</a> ： 只有6K大小。</p></li></ul><p>隐藏滚动条</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">    scrollbar-<span class="attribute">width</span>: none;</span><br><span class="line">&#125;</span><br><span class="line">::<span class="selector-tag">-webkit-scrollbar</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">color</span>: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS动画★"><a href="#CSS动画★" class="headerlink" title="CSS动画★"></a>CSS动画★</h2><blockquote><p>考察公司：字节、腾讯</p></blockquote><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>**<code>transform</code>**属性允许你旋转<code>rotate()</code>，缩放<code>scale()</code>，倾斜或平移<code>translate()</code>给定元素。</p><p><strong><code>transform-origin</code></strong> 属性让你更改一个元素变形的原点。（默认的转换原点是 <code>center</code>)</p><blockquote><p>transform对定位元素的影响</p></blockquote><p>当给一个元素加上<code>transform</code>属性的时候，这个元素就会具有<code>relative</code>的特性。</p><p>所以<strong>若一个元素的父元素拥有tranform属性，那么子元素在使用定位属性的时候要注意。</strong></p><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">animation</span>: <span class="number">3s</span> ease-in <span class="number">1s</span> <span class="number">2</span> reverse both paused slidein;</span><br></pre></td></tr></table></figure><h4 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h4><p>后边指定动画名称<code>animation-name</code></p><p>关键帧 <strong><code>@keyframes</code></strong> 通过在动画序列中定义关键帧的样式来<strong>控制CSS动画序列中的中间步骤</strong>。</p><p><code>0%</code>/<code>from</code> 和<code>100%</code>/<code>to</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> slidein &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0%</span>); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="animation-duration"><a href="#animation-duration" class="headerlink" title="animation-duration"></a>animation-duration</h4><p>指定一个<strong>动画周期的时长</strong>。</p><h4 id="animation-timing-function"><a href="#animation-timing-function" class="headerlink" title="animation-timing-function"></a>animation-timing-function</h4><p><code>ease/ease-in/ease-out/ease-in-out/linear</code></p><p>定义CSS动画在每一动画周期中<strong>执行的节奏</strong> 可能值为一或多个 <code>&lt;timing-function&gt;</code> 。</p><p>对于关键帧动画来说,<code>timing function</code>作用于<strong>一个关键帧周期</strong>。</p><h4 id="animation-delay"><a href="#animation-delay" class="headerlink" title="animation-delay"></a>animation-delay</h4><p>定义动画于何时开始，即<strong>从动画应用在元素上到动画开始的这段时间的长度</strong>。</p><h4 id="animation-iteration-count"><a href="#animation-iteration-count" class="headerlink" title="animation-iteration-count"></a>animation-iteration-count</h4><p>定义动画在结束前运行的<strong>次数</strong> 。可以是n次/无限循环<code>infinite</code>.</p><h4 id="animation-direction"><a href="#animation-direction" class="headerlink" title="animation-direction"></a>animation-direction</h4><p><code>normal/alternate/reverse/alternate-reverse</code></p><p>指示动画是否<strong>反向播放</strong>。</p><h4 id="animation-fill-mode"><a href="#animation-fill-mode" class="headerlink" title="animation-fill-mode"></a>animation-fill-mode</h4><p><code>none/forwards/backwards/both</code></p><p>设置CSS动画在<strong>执行之前和之后如何将样式应用于其目标</strong>。</p><h3 id="轮子"><a href="#轮子" class="headerlink" title="轮子"></a>轮子</h3><p><a target="_blank" rel="noopener" href="https://animate.style/">Animate.css</a></p><h2 id="自适应布局-移动端适配★"><a href="#自适应布局-移动端适配★" class="headerlink" title="自适应布局/移动端适配★"></a>自适应布局/移动端适配★</h2><blockquote><p>考察公司：腾讯、百度</p></blockquote><p>网页在各终端上的展示效果就像缩放设计稿图片一样，在不同屏幕上等比缩放，每一个元素与整体比例保持不变，真实还原设计稿。</p><h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><p>视口(viewport)代表当前可见的计算机图形区域。</p><p>在Web浏览器术语中，通常与<strong>浏览器窗口相同</strong>，但不包括浏览器的UI， 菜单栏等——即指你正在浏览的文档的那一部分。</p><p>而移动端则较为复杂，它涉及到三个视口：<strong>布局视口（Layout Viewport）</strong>、<strong>视觉视口（Visual Viewport）</strong>和<strong>理想视口（Ideal Viewport）</strong>。</p><ul><li>布局视口使视口与移动端浏览器屏幕宽度完全独立开。<strong>CSS 布局将会根据它来进行计算，并被它约束</strong>。</li><li>视觉视口是用户当前看到的区域，<strong>用户可以通过缩放操作视觉视口，同时不会影响布局视口</strong>。</li><li><strong>理想视口对设备而言是最理想的布局视口尺寸</strong>。显示在理想视口中的网站具有最理想的宽度，用户无需进行缩放。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1px边框"><a href="#1px边框" class="headerlink" title="1px边框"></a>1px边框</h3><p><strong>dpr(物理像素和设备独立像素（逻辑像素）的比值）可以用来解释不同分辨率手机呈现页面的精细度的差异</strong>，但并不能解释1px问题。</p><p><strong>多（2，3）倍的设计图设计了1px的边框，在手机上缩小呈现时，由于css最低只支持显示1px大小，导致边框太粗的效果。（ps：ios较新版已支持0.5px，安卓不支持，这里暂且忽略）。</strong></p><h4 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h4><p>如果设置<strong>content的width就等于设计图大小750px</strong>，然后通过<strong>动态设置initial-scale值让网页整体缩放</strong>，就能实现效果了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=750,initial-scale=0.5,user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="transform-scale-缩放"><a href="#transform-scale-缩放" class="headerlink" title="transform: scale()缩放"></a>transform: scale()缩放</h4><p>具体的scale缩放比例取决于你是<strong>几倍设计图尺寸下的1px</strong>。</p><h3 id="自适应单位"><a href="#自适应单位" class="headerlink" title="自适应单位"></a>自适应单位</h3><h4 id="px"><a href="#px" class="headerlink" title="px"></a>px</h4><p>px像素 就是pixel的缩写。</p><p>px是设备或者图片中最小的一个点，很多人认为css 中的 px 是一个绝对单位，代表的是屏幕中的一个物理像素点，实际上这种说话是错误的，css中的px是一个相对（抽象）单位是虚拟像素，因为不同的设备在大小宽高相同时，他们的物理像素大小也可能是不同的，物理像素高的设备单位面积内存放的像素点就高，因此画质看起来就更精细，通常情况下在pc端中，css中的px就接近于实际的像素大小，但是在移动设备上，根据不用机型的分辨率大小，css中的一个px可能就会对应不同数量的物理像素点。</p><p>特点：网页设计的常用单位，也是基本单位，用过px单位可以固定设置布局或者元素的大小</p><p>缺点：没有弹性，大小死板，使用在多端的页面上时，无法做到适应效果，如从PC端切向移动端时样式可能会炸掉，但是纯pc端一般不会出现这样的问题。</p><h4 id="百分比"><a href="#百分比" class="headerlink" title="百分比%"></a>百分比%</h4><p>%一般是相对于父元素为基础的，如给一个元素 margin-left 为百分比，他会寻找该元素的父元素以百分比形式计算 但是也有几点例外如：</p><ul><li>对于position：absolute 就是相对于已经定位的父元素</li><li>对于position：fixed 就是对于ViewPort（视窗）</li><li>对于transform 2D水平移动变化来说就是相对于自身</li></ul><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><ul><li><p><code>em</code>：在 <code>font-size</code> 中使用是相对于<strong>父元素的字体大小</strong>，在<strong>其他属性</strong>中使用是相对于<strong>自身的字体大小</strong>，如 width。</p></li><li><p>使用<code>rem</code>为元素设定字体大小时，仍然是相对大小，但<strong>相对的只是HTML根元素</strong>。</p></li><li><p>通过它既可以做到<strong>只修改根元素就成比例地调整所有字体大小</strong>，又可以避免字体大小逐层复合的连锁反应。</p></li></ul><p>补充：</p><ul><li>rem在制作响应式页面中经常使用到，因为我们可以根据不同的设备尺寸，去动态的调整根元素的大小，使用rem单位达到适配不同尺寸设备的效果，有些自适应的页面框架单位上的使用就是基于此种特性</li><li>有时我们为了换算方便会将根元素的字体大小先设置为62.5%，然后根据需要进行调整，原因是62.5%*16px = 10px，此时也就是1rem = 10px</li><li>postcss-pxtorem：转换px为rem的插件</li></ul><h4 id="vw，vh"><a href="#vw，vh" class="headerlink" title="vw，vh"></a>vw，vh</h4><p>vh、vw方案即将视觉视口宽度和视觉视口高度等分为100份。</p><p>像<code>vw</code>、<code>vh</code>，比较容易混淆的一个单位是<code>%</code>，不过百分比宽泛的讲是相对于<strong>父元素</strong>。</p><p>视口单位主要包括以下4个：</p><ul><li><strong>vw</strong>：1vw等于视口宽度的1%。</li><li><strong>vh</strong>：1vh等于视口高度的1%。</li><li><strong>vmin</strong>：选取vw和vh中最小的那个。</li><li><strong>vmax</strong>：选取vw和vh中最大的那个。</li></ul><p><strong>缺点</strong>：</p><ul><li>用户失去了放缩任何使用<code>vw</code>单位的元素的能力。</li><li>vh和vw方案和rem类似也是相当麻烦需要做单位转化，而且px转换成vw不一定能完全整除，因此有一定的像素差。</li><li>不过在工程化的今天，webpack解析css 的时候用postcss-loader 有个postcss-px-to-viewport能自动实现px到vw的转化</li></ul><h4 id="媒体查询-响应式布局"><a href="#媒体查询-响应式布局" class="headerlink" title="媒体查询/响应式布局"></a>媒体查询/响应式布局</h4><p><code>@media 查询规则&#123;&#125;</code>通过媒体查询，可以为不同的设备，或设备不同状态来分别设置样式</p><h4 id="最佳"><a href="#最佳" class="headerlink" title="最佳"></a>最佳</h4><p><code>px</code>为主，<code>vx</code>和<code>vxxx（vw/vh/vmax/vmin）</code>为辅，搭配一些<code>flex</code>（推荐）</p><h4 id="min-width-max-width"><a href="#min-width-max-width" class="headerlink" title="min-width/max-width"></a>min-width/max-width</h4><p>给元素设置最小宽度，当width小于 min-width ，min-width会覆盖width的值。</p><p>给元素设置最大宽度，当width大于 max-width ，max-width会覆盖width的值。</p><p><code>overflow: auto;</code></p><h4 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h4><p>除了显式的指定列大小之外，CSS <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Grid&spm=1001.2101.3001.7020">Grid</a> 还有个非常强大的功能 —— 模式填充（repeat-to-fill）列然后对内容进行自动布局。</p><p>也就是说，开发者只需要指定列数，自适应方面的事情（视口尺寸小则显示列数少，反之则多）交给浏览器来处理就行了，也不需要用媒体查询。</p><p>比如我们可以用<code>grid-template-columns:repeat(6,1fr)</code>来指定该容器中包含6列，每列宽度轨道平均分配该容器的剩余空间。</p><p>有时候我们想完成响应式布局，给定一个元素的最小的宽度，然后该元素可以根据窗口的大小来显示该元素加宽和变窄，在小于设定的最小宽度时换行。</p><p>例如如下效果，设定最小宽度为200px。</p><p>当宽度足够的时候，宽度可以自适应大于200px</p><p>当宽度不足以容纳全部200px元素时进行换行操作</p><p>当容器宽度继续变小，宽度不足以容纳两个时再次换行</p><p>在以前实现这种自适应布局需要媒体查询@media或者js来控制实现，但是现在仅需要几行grid代码就可以轻松实现：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>:<span class="built_in">repeat</span>(auto-fit,<span class="built_in">minmax</span>(<span class="number">200px</span>,<span class="number">1</span>fr));</span><br><span class="line">    gap:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中核心为：<code>grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));</code>意思是我的每个子元素至少需要200px的宽度，如果视口宽度足够就平均分配剩余空间给每个子元素，至于换行问题需要看分配的所有的轨道空间够不够200，如果不够200就换一行，把多的元素换行，比如有580px（不考虑gap），不足以容纳3*200=600，3个子元素，那么就换行，一行两个子元素，那么剩余的80px呢，这就属于剩余空间，将（1fr）平均分配给两个轨道。</p><p>这里涉及填充模式中的auto-fit和auto-fill的区别，auto-fit和auto-fill只有在容器宽度大于子元素的最小宽度总和时才有显示区别，例如容器随着窗口现在有1500px宽度，子元素在一行排列总共需要600px（不考虑gap)。</p><p>auto-fit和auto-fill首先会尽可能多的创建基于min的200px的轨道宽度，例如创建1500/200=7.5。那么会有7个轨道的200px还剩余了100px的剩余空间，接着会把这100px再次分配到这7个轨道中，100/7=14.28。所以每个轨道的宽度现在为214.28px。在这里位置，auto-fill和auto-fit做的事情是一样的：</p><p><strong>1.就是尽可能多的创建轨道</strong></p><p><strong>2.然后不足一个轨道的空间平均分配给已有的轨道</strong></p><p>auto-fill的前两步骤中创建的空轨道被保留下来了，并且可以看到留白。</p><p><strong>auto-fill的最后一步时保留空轨道留白，不会折叠空轨道</strong></p><p><strong>auto-fit的最后一步是，折叠空轨道，将空轨道的空间全部平均分配给已有元素的轨道</strong></p><p>*值得注意的是这种区别是在容器中元素数量*元素的最小宽度&lt;容器的总宽度时才会显示看到的差异，如果元素数量*最小宽度&gt;容器宽度，那么auto-fill和auto-fit展现的效果是一样的</p><p><strong>总结：</strong></p><ul><li>auto-fill:在轨道重复过程中，尽可能多的根据元素创建轨道，如果创建的轨道数量是小数比如6.5，那么0.5就被称为剩余空间，剩余的空间不够一个轨道了，就相当于每个轨道1fr进行分配这个0.5的剩余空间，没有元素填充的空轨道不会折叠依然保留（相当于留了空白）。</li><li>auto-fit:在轨道重复过程中，尽可能多的根据元素创建轨道，并均分不到一个轨道的剩余空间。轨道分配完以后如果轨道中没有元素则将所有没有元素填充的空轨道折叠为0，即把没有元素填充的空轨道全被分配给有元素的轨道（相当于有元素填充的轨道全部为1fr）。最后没有空轨道剩余。</li><li>auto-fill和auto-fit一开始做的事情是一样的就是尽可能的分配轨道数量，区别在于后面空轨道是否会折叠为0。auto-fill不折叠空轨道，auto-fit折叠空轨道。</li></ul><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><h4 id="图片缩放"><a href="#图片缩放" class="headerlink" title="图片缩放"></a>图片缩放</h4><p><a target="_blank" rel="noopener" href="https://zmage.caldis.me/">ReactZmage</a> 最新版样式存在问题</p><p>新版本缺失了css文件，需要手动导入 <code>import &#39;react-zmage/lib/zmage.css&#39;</code></p><h4 id="图片保持原始比例"><a href="#图片保持原始比例" class="headerlink" title="图片保持原始比例"></a>图片保持原始比例</h4><blockquote><p>可替换元素</p></blockquote><p>在CSS中，<strong>可替换元素</strong>（<strong>replaced element</strong>）的展现效果不是由 CSS 来控制的。</p><p>这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。</p><p>简单来说，它们的内容不受当前文档的样式的影响。CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。某些可替换元素，例如<code>&lt;iframe/&gt;</code>元素，可能具有自己的样式表，但它们不会继承父文档的样式。</p><p>CSS 能对可替换元素产生的唯一影响在于，部分属性支持控制元素内容在其框中的位置或定位方式。</p><p>典型的可替换元素有：</p><ul><li><code>&lt;iframe/&gt;</code></li><li><code>&lt;video/&gt;</code></li><li><code>&lt;embed/&gt;</code></li><li><code>&lt;img/&gt;</code></li></ul><p>有些元素仅在特定情况下被作为可替换元素处理，例如：</p><ul><li><p><code>&lt;option&gt;</code></p></li><li><p><code>&lt;audio&gt;</code></p></li><li><p><code>&lt;canvas&gt;</code></p></li><li><p><code>&lt;object&gt;</code></p></li><li><p><code>&lt;applet&gt;</code></p></li></ul><p>HTML 规范也说了 <code>&lt;input&gt;</code> 元素可替换，因为 “image” 类型的 <code>&lt;input&gt;</code> 元素就像<code>&lt;img&gt;</code>一样被替换。但是其他形式的控制元素，包括其他类型的 <code>&lt;input&gt;</code> 元素，被明确地列为非可替换元素（non-replaced elements）。该规范用术语小挂件（Widgets）来描述它们默认的限定平台的渲染行为。</p><p>用 CSS content 属性插入的对象是匿名的可替换元素。它们并不存在于 HTML 标记中，因此是“匿名的”。</p><p>CSS 在某些情况下会对可替换元素做一些特殊处理，比如计算外边距（<code>margin</code>）和一些 <code>auto</code> 的具体值。</p><p>需要注意的是，一部分（并非全部）可替换元素，其本身具有的尺寸和基线（baseline）会被一些 CSS 属性用到，加入计算之中，例如 <code>vertical-align</code>。只有可替换元素才能具有这种自带值。</p><p>某些 CSS 属性可用于指定 可替换元素中包含的内容对象 在该元素的盒区域内的位置或定位方式。</p><ul><li><p><code>object-fit</code></p><p>指定可替换元素的内容对象在元素盒区域中的填充方式。</p></li><li><p><code>object-position</code></p><p>指定可替换元素的内容对象在元素盒区域中的位置。</p></li></ul><p><code>object-fit</code>和<code>object-position</code>之间的关系有点类似于<code>background-size</code>和<code>background-position</code>，无论是，关系还是属性值，都有相似之处，因此，我们在理解<code>object-fit</code>和<code>object-position</code>的时候，可以或多或少映射<code>background-size</code>和<code>background-position</code>。</p><p><strong><code>object-fit</code></strong> 属性指定可替换元素的内容应该如何适应到其使用的高度和宽度确定的框。</p><ul><li><p><code>contain</code><br>被替换的内容将被缩放，以在填充元素的内容框时保持其宽高比。整个对象在填充盒子的同时保留其长宽比，因此如果宽高比与框的宽高比不匹配，该对象将被添加“<strong>空白</strong>”。</p></li><li><p><code>cover</code><br>被替换的内容在保持其宽高比的同时填充元素的整个内容框。如果对象的宽高比与内容框不相匹配，该对象将被<strong>裁剪</strong>以适应内容框。</p></li><li><p><code>fill</code><br>被替换的内容正好填充元素的内容框。整个对象将完全填充此框。如果对象的宽高比与内容框不相匹配，那么该对象将被<strong>拉伸</strong>以适应内容框。</p></li><li><p><code>none</code><br>被替换的内容将保持其原有的尺寸。</p></li><li><p><code>scale-down</code><br>内容的尺寸与 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会<strong>更小</strong>一些。</p></li></ul><p>补充：</p><ol><li><p><code>img</code>是个元素，且是个替换元素；</p></li><li><p>一个图片<code>&lt;img&gt;</code>，如果没有<code>src</code>，它依然是个替换元素，它在浏览器中的解析依然是正确的；</p></li><li><p><code>src</code>指向的图片属于替换内容，注意，这个替换内容和这个<code>img</code>替换元素是壳子与内容的关系，<strong>两者是独立的</strong>。</p><p>在CSS2.1时代，壳子的实际尺寸（如果没有CSS或HTML设置），则是跟随内容的实际尺寸，因此，网页加载的时候，我们会看到图片占据的高度从0到图片实际高度跳动的过程；如果壳子，也就是<code>img</code>有尺寸限制，则替换内容<code>fill</code>拉伸适应于 <code>img</code>替换元素的设定尺寸。总而言之，壳子与内容的尺寸永远是一样的。于是，我们就会误认为图片就是那个图片，唯一的存在，导致我们理解<code>object-fit</code>的特性表现出现了障碍。</p></li><li><p>在CSS3时代，<code>object-fit</code>的世界里，<code>object-fit</code>控制的永远是替换内容的尺寸表现，注意，是替换内容的尺寸表现，不是<code>img</code>替换元素。</p></li><li><p>之所以<code>object-fit:contain</code>会透明留白，是因为我们没有对壳子<code>img</code>设置背景色，假设我们给壳子<code>img</code>增加个红色背景，会发现，原来的透明留白现在是红色背景，说明了什么？说明<code>img</code>替换元素和<code>src</code>替换内容是两个独立体。<code>img</code>替换元素受到了CSS <code>100%</code>拉伸控制（所以红色背景充满容器），<code>src</code>替换内容也受到了<code>object-fit</code>展示控制。大家各司其职，没有什么覆盖冲突！</p></li><li><p>无论<code>object-fit</code>值为那般，图片都是水平垂直居中的。</p></li></ol><h3 id="窗口伸缩"><a href="#窗口伸缩" class="headerlink" title="窗口伸缩"></a>窗口伸缩</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 窗口伸缩监听</span><br><span class="line">const onResize = useCallback(() =&gt; &#123;</span><br><span class="line">    if (document.body.clientWidth &lt; 1500 &amp;&amp; !collapsed) &#123;</span><br><span class="line">        setCollapsed(true)</span><br><span class="line">    &#125; else if (document.body.clientWidth &gt;= 1500 &amp;&amp; collapsed) &#123;</span><br><span class="line">        setCollapsed(false)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [collapsed])</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    window.addEventListener(&#x27;resize&#x27;, onResize)</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        window.removeEventListener(&#x27;resize&#x27;, onResize)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [onResize])</span><br></pre></td></tr></table></figure><h3 id="侧边栏收缩"><a href="#侧边栏收缩" class="headerlink" title="侧边栏收缩"></a>侧边栏收缩</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 收缩控制</span><br><span class="line">const handleFold = (): void =&gt; &#123;</span><br><span class="line">    setCollapsed(!collapsed)</span><br><span class="line">&#125;</span><br><span class="line">&lt;Aside width=&#123;collapsed ? &#x27;0&#x27; : &#x27;350px&#x27;&#125;&gt;</span><br><span class="line">    &lt;TreeNav</span><br><span class="line">        menu=&#123;menu&#125;</span><br><span class="line">        selectedKey=&#123;selectedKey&#125;</span><br><span class="line">        setSelectedKey=&#123;setSelectedKey&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/Aside&gt;</span><br><span class="line">&lt;div</span><br><span class="line">    className=&quot;aside-control&quot;</span><br><span class="line">    style=&#123;</span><br><span class="line">        collapsed</span><br><span class="line">            ? &#123; borderLeft: &#x27;0&#x27; &#125;</span><br><span class="line">        : &#123; borderLeft: &#x27;2px solid #c9c9c9&#x27; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;Tooltip</span><br><span class="line">        placement=&quot;right&quot;</span><br><span class="line">        message=&#123;collapsed ? &#x27;展开侧边栏&#x27; : &#x27;收起侧边栏&#x27;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">        &lt;Button</span><br><span class="line">            className=&quot;slidebar-header-btn&quot;</span><br><span class="line">            onClick=&#123;handleFold&#125;</span><br><span class="line">            icon=&quot;ellipsis&quot;</span><br><span class="line">            shape=&quot;text&quot;</span><br><span class="line">            size=&quot;large&quot;</span><br><span class="line">            /&gt;</span><br><span class="line">    &lt;/Tooltip&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>echarts 侧边栏收缩 宽度变化，echarts图重绘问题</p><p>窗口缩小放大的时候，图表的大小自适应</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">windouw.addEventListener(<span class="string">&quot;resize&quot;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	myEchart.resize()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>侧边栏收缩 echarts子组件 useEffect 监听collapsed resize()</p><h2 id="rgba-vs-opacity-★"><a href="#rgba-vs-opacity-★" class="headerlink" title="rgba vs opacity ★"></a>rgba vs opacity ★</h2><blockquote><p>考察公司：小米</p></blockquote><h3 id="opacity"><a href="#opacity" class="headerlink" title="opacity"></a>opacity</h3><p><code>opacity：x</code>，css3中有opacity设定透明度，其数值在[0,1]范围内,当数值为0时即为全透明，而1为不透明，opacity适用于<strong>整个元素（包括其内容）</strong>。</p><h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><p><code>background：rgba（r,g,b,a）</code>,r：红色值，g：绿色值，b：蓝色值，a：Alpha透明度，取[0,1]之间，正整数为十进制0~255任意值，而百分比亦之同理。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>opacity在设定上会适用于整个元素，也就是说它不仅仅对自己生效，还会<strong>影响其子元素的透明度</strong>（不管其子元素透明度多少都会以设定opacity为主）。</p><p>background在设定上只对其本身起作用，<strong>不会被子元素所继承</strong>。原因在于，其<strong>通过alpha通道</strong>去操作元素，而非直接去影响dom。</p><h2 id="文本溢出截断省略★"><a href="#文本溢出截断省略★" class="headerlink" title="文本溢出截断省略★"></a>文本溢出截断省略★</h2><blockquote><p>考察公司：小米</p></blockquote><h3 id="单行文本溢出省略"><a href="#单行文本溢出省略" class="headerlink" title="单行文本溢出省略"></a>单行文本溢出省略</h3><p><strong>核心 CSS 语句</strong></p><ul><li><code>overflow: hidden；</code>（文字长度超出限定宽度，则隐藏超出的内容）</li><li><code>white-space: nowrap；</code>（设置文字在一行显示，不能换行）</li><li><code>text-overflow: ellipsis；</code>（规定当文本溢出时，显示省略符号来代表被修剪的文本）</li></ul><p><strong>优点</strong></p><ul><li>无兼容问题</li><li>响应式截断</li><li>文本溢出范围才显示省略号，否则不显示省略号</li><li>省略号位置显示刚好</li></ul><p><strong>短板</strong></p><ul><li>只支持单行文本截断</li></ul><p><strong>适用场景</strong></p><ul><li>适用于单行文本溢出显示省略号的情况</li></ul><h3 id="多行文本溢出省略（按行数）"><a href="#多行文本溢出省略（按行数）" class="headerlink" title="多行文本溢出省略（按行数）"></a>多行文本溢出省略（按行数）</h3><h4 id="纯-CSS-实现方案"><a href="#纯-CSS-实现方案" class="headerlink" title="纯 CSS 实现方案"></a>纯 CSS 实现方案</h4><p><strong>核心 CSS 语句</strong></p><ul><li><code>-webkit-line-clamp: 2；</code>（用来限制在一个块元素显示的文本的行数, 2 表示最多显示 2 行。 为了实现该效果，它需要组合其他的WebKit属性）</li><li><code>display: -webkit-box；</code>（和 1 结合使用，将对象作为弹性伸缩盒子模型显示 ）</li><li><code>-webkit-box-orient: vertical；</code>（和 1 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 ）</li><li><code>overflow: hidden</code>；（文本溢出限定的宽度就隐藏内容）</li><li><code>text-overflow: ellipsis；</code>（多行文本的情况下，用省略号“…”隐藏溢出范围的文本)</li></ul><p><strong>优点</strong></p><ul><li>响应式截断</li><li>文本溢出范围才显示省略号，否则不显示省略号</li><li>省略号显示位置刚好</li></ul><p><strong>短板</strong></p><ul><li>兼容性一般： -webkit-line-clamp 属性<strong>只有 WebKit 内核的浏览器才支持</strong></li></ul><p><strong>适用场景</strong></p><ul><li>多适用于移动端页面，因为移动设备浏览器更多是基于 WebKit 内核</li></ul><h4 id="基于-JavaScript-的实现方案"><a href="#基于-JavaScript-的实现方案" class="headerlink" title="基于 JavaScript 的实现方案"></a>基于 JavaScript 的实现方案</h4><p><strong>优点</strong></p><ul><li>无兼容问题</li><li>响应式截断</li><li>文本溢出范围才显示省略号，否则不显示省略号</li></ul><p><strong>短板</strong></p><ul><li>需要 JS 实现，背离展示和行为相分离原则</li><li>文本为中英文混合时，省略号显示位置略有偏差</li></ul><p><strong>适用场景</strong></p><ul><li>适用于响应式截断，多行文本溢出省略的情况</li></ul><p><strong>Demo</strong></p><p>当前仅适用于文本为中文，若文本中有英文，可自行修改</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> text = <span class="string">&#x27;这是一段很长的文本&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> totalTextLen = text.length;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> formatStr = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> ele = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;demo&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> lineNum = <span class="number">2</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> baseWidth = <span class="built_in">window</span>.getComputedStyle(ele).width;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> baseFontSize = <span class="built_in">window</span>.getComputedStyle(ele).fontSize;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> lineWidth = +baseWidth.slice(<span class="number">0</span>, -<span class="number">2</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 所计算的strNum为元素内部一行可容纳的字数(不区分中英文)</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> strNum = <span class="built_in">Math</span>.floor(lineWidth / +baseFontSize.slice(<span class="number">0</span>, -<span class="number">2</span>));</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> content = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        </span></span><br><span class="line"><span class="javascript">      	<span class="comment">// 多行可容纳总字数</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> totalStrNum = <span class="built_in">Math</span>.floor(strNum * lineNum);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> lastIndex = totalStrNum - totalTextLen;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (totalTextLen &gt; totalStrNum) &#123;</span></span><br><span class="line"><span class="javascript">            content = text.slice(<span class="number">0</span>, lastIndex - <span class="number">3</span>).concat(<span class="string">&#x27;...&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            content = text;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        ele.innerHTML = content;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">    formatStr();</span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">		<span class="built_in">window</span>.onresize = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        formatStr();</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;demo&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="封装-轮子"><a href="#封装-轮子" class="headerlink" title="封装/轮子"></a>封装/轮子</h3><blockquote><p>凡重复的，让它单一；凡复杂的，让它简单。</p></blockquote><p>每次都要搞一坨代码，太麻烦。这时候你需要考虑将文本截断的能力，封装成一个可随时调用的自定义容器组件。市面上很多 UI 组件库，都提供了同类组件的封装，如<strong>antd的Typography</strong> 。</p><h2 id="实现一个不定宽高的正方形★"><a href="#实现一个不定宽高的正方形★" class="headerlink" title="实现一个不定宽高的正方形★"></a>实现一个不定宽高的正方形★</h2><blockquote><p>考察公司：百度</p></blockquote><h3 id="宽高设置为vw，vh"><a href="#宽高设置为vw，vh" class="headerlink" title="宽高设置为vw，vh"></a>宽高设置为vw，vh</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    * &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        <span class="comment">/*只是为了证明宽高不等而已*/</span></span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">100vw</span> + <span class="number">100px</span>);</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: skyblue;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">        <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">        <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">40vw</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">40vw</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式最简单了，<strong>缺点：</strong>它是基于窗口的宽高的，不是基于父元素的宽高的</p><h3 id="设置垂直方向的-padding-撑开容器"><a href="#设置垂直方向的-padding-撑开容器" class="headerlink" title="设置垂直方向的 padding 撑开容器"></a>设置垂直方向的 padding 撑开容器</h3><p>在 CSS 盒模型中，一个比较容易被忽略的就是 <strong>margin, padding 的百分比数值</strong>计算。</p><p>按照规定，margin, padding 的百分比数值是相对<strong>包含块宽度的宽度</strong>计算的。</p><p>由此可以发现只需将元素垂直方向的一个 padding 值设定为与 width 相同的百分比就可以制作出自适应正方形了：</p><p><strong>代码如下：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    * &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        <span class="comment">/*只是为了证明宽高不等而已*/</span></span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">100vw</span> + <span class="number">100px</span>);</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: skyblue;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">        <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">        <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">padding-bottom</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">        <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为什么需要设置<code>height:0</code>,如果不设置，box中有内容的话，最终高度为<strong>内容撑开的高度+padding</strong>。</p><h3 id="伪元素的-margin-padding-top"><a href="#伪元素的-margin-padding-top" class="headerlink" title="伪元素的 margin(padding)-top"></a>伪元素的 margin(padding)-top</h3><p>利用<strong>伪元素的 margin(padding)-top</strong> 撑开容器,在加一个<strong>绝对定位容器放置内容</strong>。</p><p>这个其实和方案一思路一样，只不过使用伪元素副作用更小。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    * &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        <span class="comment">/*只是为了证明宽高不等而已*/</span></span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">100vw</span> + <span class="number">100px</span>);</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: skyblue;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">        <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">        <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">        <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="comment">/*伪元素的目的是用来撑开父容器的*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin-top</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        <span class="comment">/*padding-top: 100%;*/</span></span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="comment">/*单独增加一个容器，用来放置内容*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">            我是内容我是内容我是内容我是内容我是内容我是内容</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>应用：可以用于一些图片的自适应展示。</p><h2 id="lt-img-gt-的title和alt有什么区别"><a href="#lt-img-gt-的title和alt有什么区别" class="headerlink" title="&lt;img&gt;的title和alt有什么区别"></a><code>&lt;img&gt;</code>的<code>title</code>和<code>alt</code>有什么区别</h2><ul><li>通常当鼠标滑动到元素上的时候显示<code>title</code>。</li><li><code>alt</code>是<code>&lt;img&gt;</code>的<strong>特有属性</strong>，是<strong>图片内容的等价描述</strong>，用于图片无法加载时显示，和读屏器阅读图片，提高图片可访问性，除了纯装饰图片外都必须设置有意义的值，<strong>搜索引擎</strong>会重点分析。</li></ul><h2 id="CSS中link和-import区别"><a href="#CSS中link和-import区别" class="headerlink" title="CSS中link和@import区别"></a>CSS中link和@import区别</h2><p><strong>1.从属关系区别</strong><br><code>@import</code>是 <strong>CSS</strong> 提供的语法规则，只有<strong>导入样式表</strong>的作用；<code>link</code>是<strong>HTML</strong>提供的标签，不仅可以<strong>加载 CSS 文件</strong>，还可以<strong>定义 RSS、rel 连接属性</strong>等。</p><p><strong>2.加载顺序区别</strong><br>加载页面时，<code>link</code>标签引入的 CSS 被同时加载；<code>@import</code>引入的 CSS 将<strong>在页面加载完毕后被加载</strong>。</p><p><strong>3.兼容性区别</strong><br><code>@import</code>是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；<code>link</code>标签作为 HTML 元素，不存在兼容性问题。</p><p>操控DOM和样式的权重暂不理解。</p><p>react import与link 加载顺序</p><h2 id="简述一下src与href的区别"><a href="#简述一下src与href的区别" class="headerlink" title="简述一下src与href的区别"></a>简述一下src与href的区别</h2><ul><li><code>src</code>是<code>source</code>的缩写，<strong>指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置</strong>；在请求<code>src</code>资源时会将其指向的资源下载并应用到文档内，例如<code>js</code>脚本，<code>img</code>图片和<code>iframe</code>等元素</li><li>img、script、input、iframe</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> =<span class="string">”js.js”</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>js脚本阻塞渲染并不是因为他是src引入的，而是因为他有可能改变DOM树或CSSOM树。</p><p>是否阻塞跟href和src没有关系，跟浏览器实现最佳体检的设计有关。</p></blockquote><ul><li><code>href</code>是<code>Hypertext Reference</code>的缩写，<strong>指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接</strong></li><li>link、a</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">”common.css”</span> <span class="attr">rel</span>=<span class="string">”stylesheet”/</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。</p></blockquote><h2 id="原生实现弹出框"><a href="#原生实现弹出框" class="headerlink" title="原生实现弹出框"></a>原生实现弹出框</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 遮罩层 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-id">#overlay</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="css">        <span class="attribute">left</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">top</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-size</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 弹出框主体 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.popup</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: <span class="number">#ffffff</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">max-width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">min-width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">240px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span></span><br><span class="line"><span class="css">        <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 弹出框的标题 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.popup_title</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">line-height</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">border-bottom</span>: solid <span class="number">1px</span> <span class="number">#cccccc</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 弹出框的内容 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.popup_content</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">line-height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 弹出框的按钮栏 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.popup_btn</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">padding-bottom</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 弹出框的按钮 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.popup_btn</span> <span class="selector-tag">button</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: <span class="number">#778899</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">40%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="css">        <span class="attribute">border</span>: solid <span class="number">1px</span> <span class="number">#cccccc</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: <span class="number">#337ab7</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;showPopup&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;showPopup()&quot;</span>&gt;</span>弹出<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;overlay&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;hidePopup()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;popup&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;popup_title&quot;</span>&gt;</span>提示<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;popup_content&quot;</span>&gt;</span>学会制作弹出框了吗？<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;popup_btn&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;cancelBtn&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;hidePopup()&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;confirmBtn&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;confirmPopup()&quot;</span>&gt;</span>确认<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> overlay = <span class="built_in">document</span>.getElementById(<span class="string">&quot;overlay&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> popup = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;popup&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> showPopup = <span class="function">() =&gt;</span> overlay.style.display = <span class="string">&quot;block&quot;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> hidePopup = <span class="function">() =&gt;</span> overlay.style.display = <span class="string">&quot;none&quot;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> confirmPopup = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        overlay.style.display = <span class="string">&quot;none&quot;</span>;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;11111&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    overlay.addEventListener(<span class="string">&#x27;click&#x27;</span>, hidePopup)</span></span><br><span class="line"><span class="javascript">    popup.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        e.stopPropagation()</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="iframe优缺点"><a href="#iframe优缺点" class="headerlink" title="iframe优缺点"></a>iframe优缺点</h2><p>iframe可以在一个网站里面嵌入另一个网站的内容。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>iframe能够原封不动的把嵌入的网页展现出来。</li><li>如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。</li><li>网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。</li><li>如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>会产生很多页面，不容易管理。</li><li>iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。</li><li>代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以<strong>使用iframe会不利于搜索引擎优化。</strong></li><li>iframe 里面的样式、脚本资源，会增加请求次数，对于大型网站是不可取的。</li><li>iframe 会阻碍页面的 <code>onload</code> 事件，给用户页面加载很慢的感觉。</li></ul><h2 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h2><p>DOCTYPE 是一种<strong>通用标记语言的文档声明类型</strong>，它主要作用是告诉浏览器的解析器，应该以什么样的<strong>文档类型定义</strong>来解析文档，不同的<strong>渲染模式</strong>会影响浏览器对 CSS 代码甚至 JavaScript 脚本的解析。</p><p>它必须声明在文档的<strong>第一行</strong>。</p><p><strong>Document Type Definition</strong>，缩写 <strong>DTD</strong>。 定义了 <strong>XML</strong> 或 <strong>HTML</strong> 的特定版本中允许有什么，不允许有什么，在渲染解析页面的时候，浏览器会根据这些规则检查页面的有效性并采取相应的措施。</p><blockquote><p>HTML 5</p></blockquote><p>因为 HTML 5 不基于 SGML，所以<strong>不需要引用DTD</strong>，但是需要<strong>DOCTYPE</strong>来规范浏览器的行为，让浏览器按照 W3C 的标准解析渲染页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>HTML 4.01</p></blockquote><ul><li><p>Strict 严格</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Transitional 过渡</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Frameset 框架</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/html4/frameset.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>XML 1.0</p></blockquote><ul><li><p>Strict 严格</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Transitional 过渡</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Framset 框架</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>浏览器渲染页面的两种模式：<strong>标准模式</strong>和<strong>怪异模式</strong>。可用<code>document.compatMode</code>来获取。</p><ul><li>CSS1Compat：<strong>标准模式（严格模式）（Strict mode）</strong>，是默认模式，浏览器按照 <strong>W3C</strong> 标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li><li>BackCompat：<strong>怪异模式（混杂模式）（Quick mode）</strong>，浏览器使用<strong>自己的方式解析渲染页面</strong>。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li></ul><p>浏览器解析时到底使用严格模式还是混杂模式，与网页中的 <strong>DTD</strong> 直接相关。</p><ul><li><strong>严格 DTD ——严格模式</strong> 。如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。</li><li><strong>有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式</strong>。含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。</li><li><strong>DTD不存在或者格式不正确——混杂模式</strong>。不存在或形式不正确会导致文档以混杂模式呈现。</li><li><strong>HTML5 没有严格和混杂之分</strong>。HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有<strong>相对宽松的语法</strong>，实现时，已经尽可能大的实现了向后兼容。</li></ul><p>严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。</p><ul><li>严格模式下 —— W3C 标准的盒模型</li><li>怪异模式下 —— IE 盒模型</li></ul><h2 id="CSS隐藏页面元素"><a href="#CSS隐藏页面元素" class="headerlink" title="CSS隐藏页面元素"></a>CSS隐藏页面元素</h2><p>通过<code>css</code>实现隐藏元素方法有如下：</p><ul><li><code>display:none</code> 元素不可见，不占据空间（<strong>不会出现在Render树上</strong>），无法响应点击事件</li><li><code>visibility:hidden</code> 元素不可见，占据页面空间，无法响应点击事件</li><li><code>opacity:0</code> 改变元素透明度，元素不可见，占据页面空间，<strong>可以响应点击事件</strong></li><li>设置<code>height、width</code>模型属性为<strong>0</strong> 如果元素内有子元素或内容，还应该设置其<code>overflow:hidden</code>来隐藏其子元素</li><li><code>position:absolute</code> 将元素移出可视区域</li><li><code>clip-path</code> 通过裁剪的形式</li></ul><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>less是一门css的预处理语言</p><ul><li>less是一个css的增强版，通过less可以<strong>编写更少的代码实现更强大的样式</strong>，添加了许多的新特性：像对<strong>变量</strong>的支持、对<strong>mixin</strong>的支持… …</li><li>less的语法大体上和css语法一致，但是less中增添了许多对css的扩展，所以浏览器无法直接执行less代码，要执行必须向将<strong>less转换为css</strong>，然后再由浏览器执行。</li></ul><p>特点</p><ul><li><strong>结构写的更加清晰</strong> 使用<strong>嵌套（nesting）</strong>代替层叠或与层叠结合使用</li><li>变量 <code>@变量名</code></li><li><code>&amp;</code> 表示外层的父元素 <code>&amp;::after</code> <code>&amp;:hover</code></li><li><code>:extend()</code> 对当前选择器扩展指定选择器的样式（选择器分组）</li><li>支持<code>//</code>注释</li></ul><h2 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h2><blockquote><p>问题：假设容器的高度默认100px，请写出<strong>三栏布局</strong>，其中左栏、右栏的宽度各为300px，中间的宽度自适应。</p></blockquote><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>左侧设置<strong>左浮动</strong>，右侧设置<strong>右浮动</strong>，中间设置<code>margin</code>或<code>overflow:hidden</code>。</p><ul><li>需要将中间的内容放在<code>html</code>结构最后，主体内容是最后加载的。</li><li>脱离文档流，需要解决浮动带来影响。</li></ul><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>左侧设置为绝对定位， <code>left：0px</code>。右侧设置为绝对定位， <code>right：0px</code>。</p><p>中间设置为绝对定位，<code>left 和right 都为300px</code>，即可。中间的宽度会自适应。</p><p>脱离文档流。</p><h3 id="Flexbox布局"><a href="#Flexbox布局" class="headerlink" title="Flexbox布局"></a>Flexbox布局</h3><p>将父容器设置<code>display：flex</code>，侧边栏大小固定后，将内容区<code>flex：1</code>，内容区则会自动放大占满剩余空间。</p><p>比较完美的解决了浮动和绝对定位的问题。在移动端比较常用。</p><h3 id="表格布局table"><a href="#表格布局table" class="headerlink" title="表格布局table"></a>表格布局table</h3><p>设置整个容器的宽度为<code>100%</code>，<code>display: table;</code>，设置三个部分均为表格单元<code>display: table-cell;</code>，然后左边的单元格为 <code>300px</code>，右边的单元格为 <code>300px</code>，即可。中间的单元格会自适应。</p><p>兼容性非常好；三个部分都当成了<strong>单元格</strong>来对待，此时，如果中间的部分变高了，其会部分也会被迫调整高度。</p><h3 id="网格布局-grid"><a href="#网格布局-grid" class="headerlink" title="网格布局 grid"></a>网格布局 grid</h3><p>设置容器为网格布局<code>display: grid</code>，宽度为<code>100%</code>，并设置<code>grid-template-columns: 300px auto 300px</code>。</p><p>CSS3中引入的布局，功能强大。</p><h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><h3 id="border画三角形"><a href="#border画三角形" class="headerlink" title="border画三角形"></a>border画三角形</h3><p><code>border</code>可以用于设置一个或多个以下属性的值: <code>border-width</code>, <code>border-style</code>, <code>border-color</code></p><p>本质还是利用了盒模型，<strong>每个边框都是梯形</strong>，当<strong>内容区宽高为0</strong>时就成三角形。</p><p>最简单：内容区宽高为0，border设置大小但颜色透明，单独给一个边框颜色。四个边框分别设置会得到更多不同形状的三角形。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">125px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left-color</span>: aqua;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日常用的更多可能是利用<strong>伪元素</strong>，<code>content: &#39;&#39;;</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div5</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-top-color</span>:  white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h3><p><code>border-radius</code>允许你设置元素的外边框圆角当使用<strong>一个半径时确定一个圆形</strong>,当使用<strong>两个半径时确定一个椭圆</strong></p><p>这个(椭)圆与边框的交集形成圆角效果。</p><p>该属性是一个简写属性,是为了将这四个属性 <code>border-top-left-radius</code> 、<code>border-top-right-radius</code> 、<code>border-bottom-right-radius</code>和 <code>border-bottom-left-radius</code> 简写为一个属性。</p><p>即使元素<strong>没有边框</strong>,圆角也可以用到 <code>background</code> 上面。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 右上和左下设置圆角*/</span></span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">12vmin</span> <span class="number">0</span> <span class="number">12vmin</span>;</span><br><span class="line"><span class="comment">/* 圆形*/</span></span><br><span class="line"><span class="attribute">width</span>: <span class="number">60vmin</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">60vmin</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br></pre></td></tr></table></figure><h3 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h3><p>用于在元素的框架上添加阴影效果。</p><p>该属性可设置的值包括<code>阴影的X轴偏移量</code>、<code>Y轴偏移量</code>、<code>模糊半径</code>、<code>扩散半径</code>和<code>颜色</code>。</p><p>如果元素同时设置了 <code>border-radius</code>属性 ，那么<strong>阴影也会有圆角效果</strong>。</p><p>使用 <code>inset</code> 关键字会使得阴影落在盒子内部，此时阴影会在<strong>边框之内 (即使是透明边框）、背景之上、内容之下</strong>。</p><p>ios中<code>box-shadow</code>容易出现bug，一种方式是设置<code>border: none;</code>，使用<code>box-shadow</code>和<code>border-radius</code>可以获得类似<strong>边框</strong>的效果。</p><h2 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h2><p>下列元素会脱离常规流：</p><ul><li>浮动的元素</li><li>通过设置 position 属性为 absolute 或者 fixed 的元素</li><li>(<code>html</code>) 根元素</li></ul><p>脱离常规流的元素会创建一个<strong>新的块级格式化上下文（Block Formatting Context: BFC）环境</strong>，其中包含的所有元素构成了一个小的布局环境，与页面中的其他内容分隔开来。</p><p>而根元素，作为页面中所有内容的容器，自身脱离常规流，<strong>为整个文档创建了一个块级格式化上下文环境</strong>。</p><h2 id="伪类-伪元素"><a href="#伪类-伪元素" class="headerlink" title="伪类/伪元素"></a>伪类/伪元素</h2><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p><strong>伪类</strong>是选择器的一种，它用于选择处于<strong>特定状态</strong>的元素。</p><p><code>:first-child</code> 第一个子元素，<code>:last-child</code>，最后一个子元素 <code>:nth-child()</code> 选中第n个子元素。</p><p><code>:hover</code>- 这仅适用于用户在元素上<strong>移动鼠标</strong>，通常是<strong>链接</strong>。</p><p><code>:focus</code> - 仅在用户通过<strong>单击或使用键盘控件</strong>来适用元素。</p><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p><strong><code>::before</code></strong>/<code>::after</code>用来创建一个伪元素，作为已选中元素的<strong>第一个</strong>/<strong>最后一个子元素</strong>。通常会配合<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content"><code>content</code></a>属性来为该元素添加装饰内容。这个虚拟元素<strong>默认是行内元素</strong>。</p><p><strong><code>::before</code></strong>/<code>::after</code>表示法是在<strong>CSS 3</strong>中引入的，<code>::</code>符号是用来区分<strong>伪类</strong>和伪元素的。支持CSS3的浏览器同时也都支持CSS2中引入的表示法<code>:before</code>/<code>:after</code>。</p><h2 id="常用的-meta-元素"><a href="#常用的-meta-元素" class="headerlink" title="常用的 meta 元素"></a>常用的 meta 元素</h2><p><code>&lt;meta&gt;</code>元素标签是提供有关HTML文档的元数据，元数据不会显示在页面上，但是能够被机器识别。</p><p><strong>meta标签是用来让机器识别的，同时它对SEO起着重要的作用</strong>。</p><p><strong>charset</strong></p><p>指定了html文档的<strong>编码格式</strong>，常用的是utf-8(Unicode的字符编码)，还有ISO-8859-1(拉丁字母的字符编码)。</p><p><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code></p><p><strong>name &amp; content</strong></p><p>指定元数据的名称(这部分对SEO非常有用)</p><ul><li>author——定义了页面的作者</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Tony&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>keywords——为搜索引擎提供关键字</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML, CSS, JavaScript&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>description——对网页整体的描述</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;My tutorials on HTML, CSS and JavaScript&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>viewport——对页面视图相关进行定义</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">width=device-width——将页面宽度设置为跟随屏幕宽度变化而变化</span><br><span class="line">initial-scale=1.0——设置浏览器首次加载页面时的初始缩放比例(0.0-10.0正数)</span><br><span class="line">maximum-scale=1.0——允许用户缩放的最大比例(0.0-10.0正数)，必须大于等于minimum-scale</span><br><span class="line">minimum-scale=1.0——允许用户缩放的最小比例(0.0-10.0正数)，必须小于等于maximum-scale</span><br><span class="line">user-scalable=no——是否允许用户手动缩放(yes或者no)</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minmum-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>theme-color——定义主题颜色</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;theme-color&quot;</span> <span class="attr">content</span>=<span class="string">&quot;#222&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h2><ul><li>当 DOM 准备就绪时，document 上的<code>DOMContentLoaded</code>事件就会被触发。在这个阶段，我们可以将JavaScript 应用于元素。<ul><li>诸如 <code>&lt;script&gt;...&lt;/script&gt;</code> 或 <code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code> 之类的脚本会阻塞 DOMContentLoaded，浏览器将等待它们执行结束。</li><li>图片和其他资源仍然可以继续被加载。</li></ul></li><li>当页面和所有资源都加载完成时，window 上的 <code>load</code> 事件就会被触发。我们很少使用它，因为通常无需等待那么长时间。</li><li>当用户想要离开页面时，window 上的 <code>beforeunload</code> 事件就会被触发。如果我们取消这个事件，浏览器就会询问我们是否真的要离开（例如，我们有未保存的更改）。</li><li>当用户最终离开时，window 上的 <code>unload</code> 事件就会被触发。在处理程序中，我们只能执行不涉及延迟或询问用户的简单操作。正是由于这个限制，它很少被使用。我们可以使用 navigator.sendBeacon 来发送网络请求。</li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>常见的数组定义：<strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p><p><strong>JavaScript 数组的长度和元素类型都是非固定的。</strong></p><p>因为数组的<strong>长度可随时改变</strong>，并且其数据<strong>在内存中也可以不连续</strong>（存储相同类型元素内存连续）。</p><p><strong>优点</strong>：可以通过下标值访问，效率高；</p><p><strong>缺点</strong>：查找数据时需要先对数据进行排序，生成有序数组，才能提高查找效率；并且在插入和删除元素时，需要大量的位移操作；</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一种通过<strong>指针</strong>串联在一起的线性结构，每一个节点由两部分组成，一个是<strong>数据域</strong>一个是<strong>指针域</strong>（存放指向下一个节点的指针），<strong>最后一个节点的指针域指向null</strong>（空指针的意思）。链接的入口节点称为链表的头结点也就是<code>head</code>。</p><p><strong>单链表</strong>：单链表中的节点只能指向节点的下一个节点。</p><p><strong>双链表</strong>：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p><p><strong>双链表既可以向前查询也可以向后查询</strong>。</p><p><strong>循环链表</strong>，就是链表首尾相连。</p><p>链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><p>链表的增添和删除都是O(1)操作，也不会影响到其他节点。</p><p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p><p>链表的长度可以是不固定的，并且可以动态增删， <strong>适合数据量不固定，频繁增删，较少查询的场景</strong>。</p><p><strong>优点</strong>：数据的插入和删除操作效率都很高；</p><p><strong>缺点</strong>：查找效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><blockquote><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p></blockquote><p>其实<strong>数组就是一张哈希表</strong>。哈希表中关键码就是数组的索引下表，然后通过下表直接访问数组中的元素。</p><p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><p>我们一般会选择如下三种数据结构：</p><ul><li><strong>数组</strong></li><li><strong>set（集合）</strong></li><li><strong>map（映射）</strong></li></ul><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><p><strong>优点</strong>：哈希表的插入/查询/删除效率都非常高；</p><p><strong>缺点</strong>：空间利用率不高，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是无序的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中最大值或最小值这些特殊值。</p><h3 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h3><p>常用术语：</p><ul><li>节点的度（Degree）：<strong>节点的子树个数</strong>，比如节点 B 的度为 2；</li><li>树的度：<strong>树的所有节点中最大的度数</strong>，如上图树的度为 2；</li><li>叶节点（Leaf）：<strong>度为 0 的节点（也称为叶子节点）</strong>，如上图的 H，I 等；</li><li>父节点（Parent）：<strong>度不为 0 的节点称为父节点</strong>，如上图节点 B 是节点 D 和 E 的父节点；</li><li>子节点（Child）：若 B 是 D 的父节点，那么 D 就是 B 的子节点；</li><li>兄弟节点（Sibling）：具有同一父节点的各节点彼此是兄弟节点，比如上图的 B 和 C，D 和 E 互为兄弟节点；</li><li>路径和路径长度：<strong>路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长</strong>度，比如 A-&gt;H 的路径长度为 3；</li><li>节点的层次（Level）：规定根节点在 1 层，其他任一节点的层数是其父节点的层数加 1。如 B 和 C 节点的层次为 2；</li><li>树的深度（Depth）：<strong>树种所有节点中的最大层次是这棵树的深度</strong>，如上图树的深度为 4；</li></ul><p>如果树中的每一个节点最多只能由两个子节点，这样的树就称为<strong>二叉树</strong></p><p><strong>二叉树的种类</strong></p><ul><li><p><strong>满二叉树</strong>：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p><p>也可以说深度为k，有2^k-1个节点的二叉树。</p></li><li><p><strong>完全二叉树</strong>：除了最<strong>底层节点可能没填满外</strong>，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层<strong>最左边的若干位置</strong>。若最底层为第 h 层，则该层包含 1~ 2^h -1 个节点。</p></li></ul><p><strong>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</strong></p><p>二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵<strong>空树</strong>或它的<strong>左右两个子树的高度差的绝对值不超过1</strong>，并且<strong>左右两个子树都是一棵平衡二叉树</strong>。</p><p><strong>二叉树的存储方式</strong></p><ul><li>链式存储 通过<strong>指针</strong>把分布在散落在各个地址的节点串联一起</li><li>顺序存储 数组 在内存是连续分布的</li></ul><p><strong>二叉树的遍历方式</strong></p><ul><li><strong>深度优先遍历</strong>：先往深走，遇到叶子节点再往回走。前中后，其实指的就是根节点的遍历顺序<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li><strong>广度优先遍历</strong>：一层一层的去遍历。<ul><li>层次遍历（迭代法，队列）</li></ul></li></ul><p><strong>前端应用</strong>：DOM树、CSS规则树、虚拟DOM、AST语法树</p><p><strong>优点</strong>：树结构综合了上述三种结构的优点，同时也弥补了它们存在的缺点（虽然效率不一定都比它们高），比如树结构中数据都是有序的，查找效率高；空间利用率高；并且可以快速获取最大值和最小值等。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈（stack）是一种运算受限的线性表。特点：<strong>先进后出</strong>。</p><blockquote><p>程序中的栈结构</p></blockquote><ul><li>函数调用栈：A(B(C(D())))：<br>即 A 函数中调用 B，B 调用 C，C 调用 D；在 A 执行的过程中会将 A 压入栈，随后 B 执行时 B 也被压入栈，函数 C 和 D 执行时也会被压入栈。所以当前栈的顺序为：A-&gt;B-&gt;C-&gt;D（栈顶）；函数 D 执行完之后，会弹出栈被释放，弹出栈的顺序为 D-&gt;C-&gt;B-&gt;A;</li><li>递归：<br>为什么没有停止条件的递归会造成栈溢出？比如函数 A 为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数 A 压入栈，最后造成栈溢出（Queue Overfloat）。</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列（Queue）是一种运算受限的线性表，特点：<strong>先进先出</strong>。</p><p>事件循环中的宏任务和微任务队列。</p><p><strong>优先队列</strong></p><ul><li>每个元素不再只是一个数据，还包含优先级。</li><li>在添加元素过程中，根据优先级放入到正确位置。</li></ul><h2 id="递归★"><a href="#递归★" class="headerlink" title="递归★"></a>递归★</h2><blockquote><p>考察公司：华为</p></blockquote><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>递归就是把规模较大的一个问题，分解成规模较小的多个子问题去解决，而每一个子问题又可以继续拆分成多个更小的子问题。</p><p>递归就是<strong>一个函数在它的函数体内调用它自身</strong>。</p><p>执行递归函数]将反复调用其自身，每调用一次就进入新的一层。递归函数必须有<strong>结束条件</strong>。</p><p>我一般处理递归的思路主要注意以下两点：</p><ul><li>先处理一小步（先处理最简情况）,然后自己调自己</li><li>找到退出条件</li></ul><p>迭代：迭代是重复反馈过程的活动。每一次对过程的重复称为一次“迭代”，每一次迭代得到的结果会作为下一次迭代的初始值。</p><p>递归中有迭代，但迭代中不一定有递归，大部分可以相互转换；</p><p>相比较而言，能用迭代就不要用递归，递归不断调用函数，浪费空间，也容易引起堆栈溢出。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>简洁</li><li>在树的前序，中序，后序遍历算法中，递归的实现明显要比循环简单得多。</li></ul><h3 id="问题（缺点）"><a href="#问题（缺点）" class="headerlink" title="问题（缺点）"></a>问题（缺点）</h3><ul><li><strong>性能</strong>：假设传入的参数值特别大，那么这个调用栈将会非常之大，最终可能超出调用栈的缓存大小而崩溃导致程序执行失败。每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。</li><li>效率：<ul><li>递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址以及临时变量，而往栈中压入数据和弹出数据都需要时间。</li><li>递归中很多计算都是重复的，由于其本质是把一个问题分解成两个或者多个小问题，多个小问题存在相互重叠的部分，则存在<strong>重复计算</strong>，如fibonacci斐波那契数列的递归实现。</li></ul></li></ul><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>尾递归是一种递归的写法，可以避免不断的将函数压栈最终导致堆栈溢出。</p><p>通过设置一个累加参数，并且每一次都将当前的值累加上去，然后递归调用。通过尾递归，我们可以<strong>把复杂度从O(n)降低到O(1)</strong></p><p>先说尾调用来理解尾递归</p><blockquote><p>尾调用是指一个函数里的最后一个动作是返回一个函数的调用结果的情形，即最后一步新调用的返回值直接被当前函数的返回结果</p></blockquote><p><strong>尾调用核心理解</strong></p><p>就是看一个函数在调用另一个函数得时候，<strong>本身是否可以被“释放”</strong></p><p><strong>尾调用好处</strong></p><p>如果将函数优化为尾调用，那么完全可以做到每次执行时，调用帧为一，这将大大节省内存，提高能效。</p><p><strong>尾递归 = 尾调用 + 递归</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.trace()</span></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用factorial(3)函数执行步骤如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="number">3</span>, <span class="number">1</span>) </span><br><span class="line">factorial(<span class="number">2</span>, <span class="number">3</span>) </span><br><span class="line">factorial(<span class="number">1</span>, <span class="number">6</span>) </span><br><span class="line">factorial(<span class="number">0</span>, <span class="number">6</span>) <span class="comment">// n = 0; return 6</span></span><br></pre></td></tr></table></figure><p>调用栈不再需要多次对factorial进行压栈处理，因为<strong>每一个递归调用都不在依赖于上一个递归调用的值</strong>。</p><p>因此，空间的复杂度为o(1)而不是0(n)。查看控制台，发现第三次打印的结果如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.trace</span><br><span class="line">factorial @ VM362:<span class="number">2</span></span><br><span class="line">factorial @ VM362:<span class="number">7</span></span><br><span class="line">factorial @ VM362:<span class="number">7</span></span><br><span class="line">factorial @ VM362:<span class="number">7</span></span><br><span class="line">(anonymous) @ VM362:<span class="number">9</span></span><br></pre></td></tr></table></figure><p>既然说了调用栈不再需要多次对factorial进行压栈处理，那为什么结果还是不会在每次调用的时候压栈，只有一个factorial呢?</p><p>正确的使用方式应该是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.trace()</span></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，虽然说这里启用了严格模式，但是经测试，在Chrome和Firefox下，还是会报栈溢出错误，并没有进行尾调用优化</span></span><br><span class="line"><span class="comment">// Safari浏览器进行了尾调用优化，factorial(500000, 1)结果为Infinity，因为结果超出了JS可表示的数字范围</span></span><br><span class="line"><span class="comment">// 如果在node v6版本下执行，需要加--harmony_tailcalls参数，node --harmony_tailcalls test.js</span></span><br><span class="line"><span class="comment">// 但是node最新版本已经移除了--harmony_tailcalls功能</span></span><br></pre></td></tr></table></figure><h3 id="Memoization"><a href="#Memoization" class="headerlink" title="Memoization"></a>Memoization</h3><blockquote><p>memoization最初是用来优化计算机程序使之计算的更快的技术，是通过存储调用函数的结果并且在同样参数传进来的时候返回结果。大部分应该是在递归函数中使用。memoization 是一种优化技术，避免一些不必要的重复计算，可以提高计算速度。</p></blockquote><p>同样以阶乘函数为例：</p><p><strong>不使用memoization</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用memoization</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = [] <span class="comment">// 定义一个空的存放缓存的数组</span></span><br><span class="line"><span class="keyword">const</span> factorial = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache[n - <span class="number">1</span>]) &#123; <span class="comment">// 先从cache数组里查询结果，如果没找到的话再计算</span></span><br><span class="line">    <span class="keyword">return</span> cache[n - <span class="number">1</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = factorial(n - <span class="number">1</span>) * n</span><br><span class="line">    cache[n - <span class="number">1</span>] = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>搭配闭包使用memoization</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorialMemo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = []</span><br><span class="line">  <span class="keyword">const</span> factorial = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache[n - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`get factorial(<span class="subst">$&#123;n&#125;</span>) from cache...`</span>)</span><br><span class="line">      <span class="keyword">return</span> cache[n - <span class="number">1</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> result = factorial(n - <span class="number">1</span>) * n</span><br><span class="line">      cache[n - <span class="number">1</span>] = result</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> factorial</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = factorialMemo()</span><br></pre></td></tr></table></figure><p>memorization 可以把函数每次的返回值存在一个数组或者对象中，在接下来的计算中可以直接读取已经计算过并且返回的数据，不用重复多次相同的计算。<strong>是一个空间换时间的方式</strong>，这种方法可用于部分递归中以提高递归的效率。</p><h2 id="数组排序★"><a href="#数组排序★" class="headerlink" title="数组排序★"></a>数组排序★</h2><blockquote><p>考察公司：华为、完美世界</p></blockquote><h3 id="JS自带排序"><a href="#JS自带排序" class="headerlink" title="JS自带排序"></a>JS自带排序</h3><p><code>sort()</code> 方法对数组的元素进行<strong>就地排序</strong>并返回排序后的数组。</p><p>默认排序顺序是<strong>升序</strong>，将元素转换为<strong>字符串</strong>，然后比较它们的 <strong>UTF-16</strong> 代码单元值序列（根据每个字符的 Unicode 代码点值进行排序）。</p><p>排序的时间和空间复杂度不能保证，因为它取决于实现。</p><p>ASCII是计算机中最常用的编码方式，用于<strong>将字母，数字，标点符号和控制字符转换为计算机可以理解的数字形式</strong>。</p><p>UTF-8 (UCS Transformation Format 8)是<strong>万维网上最常用的字符编码</strong>。</p><p><strong>前 128 个 UTF-8 字符与前 128 个 ASCII 字符(编号为 0-127) 精确匹配</strong>。</p><p>在JavaScript中，所有的string类型都是使用<code>UTF-16</code>编码的。</p><p><code>str.charCodeAt()</code> 方法返回 <code>0</code> 到 <code>65535</code> 之间的整数，表示给定索引处的<strong>UTF-16代码单元</strong>。</p><h4 id="仅数字"><a href="#仅数字" class="headerlink" title="仅数字"></a>仅数字</h4><table><thead><tr><th align="left"><code>compareFunction(a, b)</code> return value</th><th align="left">sort order</th></tr></thead><tbody><tr><td align="left">&gt; 0</td><td align="left">sort <code>b</code> before <code>a</code></td></tr><tr><td align="left">&lt; 0</td><td align="left">sort <code>a</code> before <code>b</code></td></tr><tr><td align="left">=== 0</td><td align="left">keep original order of <code>a</code> and <code>b</code></td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b);<span class="comment">// 升序排序</span></span><br><span class="line">    <span class="comment">// nums.sort((a,b) =&gt; b-a);// 降序排序</span></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="数字-字符串"><a href="#数字-字符串" class="headerlink" title="数字/字符串"></a>数字/字符串</h4><p>n个人，先按身高排序，再按姓名排序，姓名只有小写英文字母，且各不相同。</p><p><strong>方法一</strong>：将身高字母放入map，{身高字母:字母}，对身高字母排序，最后返回所对应的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortSoldier = <span class="function">(<span class="params">n,h,s</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(),k=[];</span><br><span class="line">  <span class="keyword">let</span> res=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    k[i]=h[i]+s[i];</span><br><span class="line">    map.set(k[i],s[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  k.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 先按数字排序</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">parseInt</span>(a)!==<span class="built_in">parseInt</span>(b))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">parseInt</span>(a)-<span class="built_in">parseInt</span>(b);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 再按字母 +转数字 TRUE-&gt;1 FALSE-&gt;0</span></span><br><span class="line">      <span class="keyword">return</span> +(a&gt;b) || +(a&gt;b)-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 按排好的顺序从map中取值</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    res = res + map.get(k[i])+<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.trim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sortSoldier(<span class="number">4</span>,[<span class="number">123</span>,<span class="number">12</span>,<span class="number">196</span>,<span class="number">196</span>],[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;abcv&#x27;</span>,<span class="string">&#x27;abcd&#x27;</span>]))<span class="comment">//b a abcd abcv</span></span><br></pre></td></tr></table></figure><p><strong>方法二</strong>：也可创建一个二维数组，<code>[[身高1,字母1],[身高2,字母2]...]</code></p><p>将该数组用身高和字母排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortSoldier = <span class="function">(<span class="params">n,h,s</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">  <span class="keyword">let</span> res=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    arr[i]=[h[i],s[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]!==b[<span class="number">0</span>])&#123;</span><br><span class="line">      <span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> +(a[<span class="number">1</span>]&gt;b[<span class="number">1</span>]) || +(a[<span class="number">1</span>]&gt;b[<span class="number">1</span>])-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    res = res + arr[i][<span class="number">1</span>]+<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.trim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sortSoldier(<span class="number">4</span>,[<span class="number">123</span>,<span class="number">12</span>,<span class="number">196</span>,<span class="number">196</span>],[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;abcv&#x27;</span>,<span class="string">&#x27;abcd&#x27;</span>]))<span class="comment">//b a abcd abcv</span></span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>冒泡排序只会操作<strong>相邻的两个数据</strong>。</li><li>外层需要n-1次排序，第n次比较是多余的，每一次结束后，未排序部分的最大值冒泡到最后。（从后向前）</li><li>内层循环不断对<strong>未排序部分</strong>两两比较交换。</li><li>每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。</li><li>一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> hasChange,</span><br><span class="line">        n=nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=n-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        hasChange = <span class="literal">false</span>;<span class="comment">// 提前停止标志位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                [nums[j],nums[j+<span class="number">1</span>]] = [nums[j+<span class="number">1</span>],nums[j]];<span class="comment">// 两两比较交换</span></span><br><span class="line">                hasChange = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hasChange) <span class="keyword">break</span>;<span class="comment">// 本轮没有数据交换，说明已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>冒泡的过程只涉及相邻数据的交换操作，空间复杂度为 O(1)，是一个<code>原地</code>排序算法。</p><p>为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换， 所以冒泡排序是<code>稳定</code>的排序算法。</p><p>时间复杂度：最佳：<code>T(n) = O(n)</code>，正序。 最差：<code>T(n) = O(n^2)</code>，反序。 平均：<code>T(n) = O(n^2)</code>。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>我们通常说的插入排序是指直接插入排序。</p><p>插入排序的工作原理：<strong>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</strong>。</p><p><strong>步骤</strong></p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中<strong>从后向前</strong>扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤 2 ~ 5。</li></ul><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> preIndex,current,</span><br><span class="line">        n=nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        preIndex=i-<span class="number">1</span>;<span class="comment">// 待比较元素下标</span></span><br><span class="line">        current=nums[i];<span class="comment">// 保存当前元素</span></span><br><span class="line">        <span class="keyword">while</span>(preIndex&gt;=<span class="number">0</span> &amp;&amp; nums[preIndex]&gt;current)&#123;</span><br><span class="line">            <span class="comment">// 待比较元素比当前元素大，后移</span></span><br><span class="line">            nums[preIndex+<span class="number">1</span>]=nums[preIndex];</span><br><span class="line">            preIndex--;<span class="comment">//下标左移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束，preIndex + 1即为当前元素应该插入的位置，避免同一个元素赋值给自身</span></span><br><span class="line">        <span class="keyword">if</span> (preIndex + <span class="number">1</span> != i) nums[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>插入排序算法的运行不需要额外的存储空间，空间复杂度是 O(1)，是一个<code>原地</code>排序算法。</p><p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是<code>稳定</code>的排序算法。</p><p>时间：最佳：<code>T(n) = O(n)</code>，正序。 最差：<code>T(n) = O(n^2)</code>，反序。 平均：<code>T(n) = O(n^2)</code>。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序<strong>每次会从未排序区间中找到最大（小）的元素，将其放到已排序区间的末尾。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 选择</span></span><br><span class="line">    <span class="keyword">let</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        minIndex=i;</span><br><span class="line">        <span class="comment">// 寻找未排序中最小数的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j= i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;nums[minIndex])&#123;</span><br><span class="line">                minIndex=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将未排序中最小的数放到已排序好数组的最后</span></span><br><span class="line">        [nums[i],nums[minIndex]]=[nums[minIndex],nums[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>选择排序空间复杂度为 O(1)，是一种<code>原地</code>排序算法。</p><p>选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，破坏了稳定性。</p><p>无论是正序还是逆序，选择排序都会遍历 <code>T = （n-1)）+ （n -2）+（n - 3）.... + 1; ===&gt;&gt; T = [n*(n-1) ] / 2；</code> 次来排序，所以，最佳、最差和平均的复杂度是一样的。 <code>T(n) = O(n^2)</code>。</p><h3 id="快速排序-★"><a href="#快速排序-★" class="headerlink" title="快速排序 ★"></a>快速排序 ★</h3><ul><li>先找到一个基准点（一般指数组的中部<code>midIndex</code>或随机数），然后数组被该基准点分为两部分，依次与该基准点数据<code>mid</code>比较，如果比它小，放左边；反之，放右边。</li><li>左右分别用一个空数组去存储比较后的数据。</li><li>最后递归执行上述操作，直到数组长度 &lt;= 1;</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 快排</span></span><br><span class="line">    <span class="keyword">const</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">1</span>) <span class="keyword">return</span> nums;<span class="comment">// 同时是递归终止条件</span></span><br><span class="line">    <span class="comment">// 基准点</span></span><br><span class="line">    <span class="keyword">let</span> midIndex=<span class="built_in">Math</span>.floor(len/<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// splice会从原数组中删除基准点数据，并返回一个数组</span></span><br><span class="line">    <span class="keyword">let</span> midNum = nums.splice(midIndex,<span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 依次与该基准点数据mid比较，如果比它小，放左边；反之，放右边</span></span><br><span class="line">    <span class="keyword">let</span> left=[],right=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        num&lt;midNum ? left.push(num) : right.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归执行上述操作</span></span><br><span class="line">    <span class="keyword">return</span> [...sortArray(left),midNum,...sortArray(right)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>缺点：<strong>需要另外声明两个数组，浪费了内存空间资源</strong>。</p><p>优化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">const</span> partition = <span class="function">(<span class="params">nums, l, r</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> pivot = nums[r]; <span class="comment">// 最右边的元素作为 pivot 元素</span></span><br><span class="line">        <span class="keyword">let</span> pIndex = l;</span><br><span class="line">        <span class="comment">// 循环结束时，pIndex左边都是比pivot小的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = l;i&lt;r; i++) &#123; </span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                [nums[i],nums[pIndex]]=[nums[pIndex],nums[i]]</span><br><span class="line">                pIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pIndex和r交换，更新pivot元素</span></span><br><span class="line">        [nums[r],nums[pIndex]]=[nums[pIndex],nums[r]] </span><br><span class="line">        <span class="keyword">return</span> pIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> quick = <span class="function">(<span class="params">nums,l, r</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((r - l) / <span class="number">2</span>) + l; <span class="comment">// 选取中间</span></span><br><span class="line">        <span class="comment">// 将它和位置r的元素交换，让 nums[r] 作为 pivot 元素</span></span><br><span class="line">        [nums[mid],nums[r]]=[nums[r],nums[mid]]</span><br><span class="line">        <span class="keyword">let</span> pIndex = partition(nums, l, r);</span><br><span class="line">        quick(nums,l, pIndex - <span class="number">1</span>);</span><br><span class="line">        quick(nums,pIndex + <span class="number">1</span>, r);</span><br><span class="line">    &#125;;</span><br><span class="line">    quick(nums,<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化的算法进行分区时，不需要很多额外的内存空间，所以快排是<code>原地排序</code>算法。</p><p>快速排序每次交换的元素都有可能不是相邻的，因此它有可能打破原来值为相同的元素之间的顺序。因此，快速排序并<code>不稳定</code>。</p><p>极端的例子：如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为基准点，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n / 2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n^2)。<strong>快排时间复杂度与基准点的选取有关，一般取中部或随机最优。</strong></p><p>时间：最佳：<code>T(n) = O(nlogn)</code>。 最差：<code>T(n) = O(n^2)</code>。 平均：<code>T(n) = O(nlogn)</code>。</p><p>为什么？解决？</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序采用的是<code>分治思想</code>。排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><p>分治，顾名思义，就是分而治之，将<strong>一个大问题分解成小的子问题来解决</strong>。小的子问题解决了，大问题也就解决了。</p><p>因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。所以<strong>不是原地排序算法</strong>。</p><p>归并排序是<strong>稳定</strong>的排序方法。</p><p>时间：最佳：<code>T(n) = O(nlogn)</code>。 最差：<code>T(n) = O(nlogn)</code>。 平均：<code>T(n) = O(nlogn)</code>。</p><p><strong>归并排序与快速排序：</strong></p><ul><li>归并排序的处理过程是<code>由下而上</code>的，先处理子问题，然后再合并。</li><li>而快排正好相反，它的处理过程是<code>由上而下</code>的，先分区，然后再处理子问题。</li><li>归并排序虽然是<strong>稳定的</strong>、时间复杂度为<code>O(nlogn)</code> 的排序算法，但是它是<strong>非原地</strong>排序算法。</li><li>快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，它是一种<strong>选择排序</strong>，最坏 、最好、平均时间复杂度均为 <code>O(nlogn)</code>，它是<strong>不稳定排序</strong>。</p><p>注意因为完全二叉树的性质，可以用数组表示对应的树结构（所以，堆排序过程中，你是看不到树这数据结构的，用数组进行映射了），这叫顺序存储。</p><p>堆是具有以下性质的完全二叉树：</p><ul><li><p>大顶堆：每个节点的值都<strong>大于或等于</strong>其左右孩子节点的值</p><p>注：<strong>没有要求左右值的大小关系</strong></p></li><li><p>小顶堆：每个节点的值都<strong>小于或等于</strong>其左右孩子节点的值</p></li></ul><p><strong>排序说明</strong></p><p>升序：一般采用大顶堆</p><p>降序：一般采用小顶堆</p><p><strong>基本思想</strong></p><ul><li><p>将待排序序列构造成一个<strong>大顶堆</strong></p><p>注意：这里使用的是<strong>数组</strong>，而不是一颗二叉树</p></li><li><p>此时：整个序列的最大值就是<strong>堆顶的根节点</strong></p></li><li><p>将其<strong>与末尾元素进行交换</strong>，此时末尾就是最大值</p></li><li><p>然后将剩余 n-1 个元素<strong>重新构造成一个堆</strong>。如此反复，便能的得到一个有序序列。</p></li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul><li>先将整个待排序的记录序列分割成为<strong>若干子序列</strong>。</li><li>分别进行<strong>直接插入排序</strong>。</li><li>待整个序列中的记录基本有序时，再对全体记录进行<strong>依次直接插入排序</strong>。</li></ul><p>希尔排序过程中，只涉及相邻数据的交换操作，空间复杂度为 O(1) 。所以是<strong>原地排序</strong>算法。</p><p>单次直接插入排序是稳定的，它不会改变相同元素之间的相对顺序，但在多次不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，可能导致相同元素相对顺序发生变化。 因此，希尔排序<strong>不稳定</strong>。</p><p>时间：最佳：<code>T(n) = O(nlogn)</code>。 最差：<code>T(n) = O(n(logn)^2)</code>。 平均：<code>T(n) = O(n(logn)^2)</code>。</p><h2 id="动态规划★"><a href="#动态规划★" class="headerlink" title="动态规划★"></a>动态规划★</h2><blockquote><p>考察公司：美团、百度</p></blockquote><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>(动态规划) 递归会超时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fib = <span class="function"><span class="params">n</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// dp[i]=dp[i-1]+dp[i-2]</span></span><br><span class="line">  <span class="comment">// dp[0]=0,dp[1]=1</span></span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>);</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = (dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">const</span> MOD = <span class="number">1000000007</span>; <span class="comment">//用来取模</span></span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="comment">// 不需要保存所有的dp值，用两个变量保存过去的状态</span></span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">0</span>,</span><br><span class="line">    cur = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    [cur, pre] = [(pre + cur) % MOD, cur];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cur;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="爬楼梯-★"><a href="#爬楼梯-★" class="headerlink" title="爬楼梯 ★"></a>爬楼梯 ★</h3><p>青蛙跳台阶取模</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> climbStairs = <span class="function"><span class="params">n</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// dp</span></span><br><span class="line">    <span class="comment">// 爬到第i阶台阶,需要先爬到i-1或i-2阶</span></span><br><span class="line">    <span class="comment">// dp[i] = dp[i-1]+dp[i-2]</span></span><br><span class="line">    <span class="comment">// dp[0]=1,dp[1]=1</span></span><br><span class="line">    <span class="comment">// 不需要保存所有dp，用变量代替</span></span><br><span class="line">    <span class="keyword">let</span> pre=<span class="number">1</span>,cur=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 题目规定n&gt;=1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        [cur,pre] = [cur+pre,cur];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><p><strong>以子序列的结束节点为基准</strong>，先遍历出以某个节点为结束的所有子序列，因为每个节点都可能会是子序列的结束节点，因此要遍历下整个序列，如: 以 b 为结束点的所有子序列: [a , b]、[b] ;以 c 为结束点的所有子序列: [a, b, c]、[b, c]、[ c ]。</p><p>因为可以产生递推关系, 采用动态规划时, 经常通过此种遍历方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxSubArray = <span class="function"><span class="params">nums</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// dp[i] 以i结束的最大子数组和</span></span><br><span class="line">    <span class="comment">// dp[i] = max(dp[i - 1] + nums[i], nums[i])</span></span><br><span class="line">    <span class="comment">// dp[0] = nums[0]</span></span><br><span class="line">    <span class="comment">// 没有必要存下所有计算过的dp项。用变量sum去存过去的状态就好</span></span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">let</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> ans = sum; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        sum = <span class="built_in">Math</span>.max(sum+nums[i], nums[i]);</span><br><span class="line">        ans = <span class="built_in">Math</span>.max(ans,sum);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lengthOfLIS = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// dp[i] 表示以 nums[i] 结尾的最长上升子序列</span></span><br><span class="line">    <span class="comment">// dp[i] = max(dp[i], dp[j] + 1); j &lt; i</span></span><br><span class="line">    <span class="keyword">let</span> n = nums.length</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//不断的找前面比自己小的数，然后加1，比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">Math</span>.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(...dp)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><p>动态规划方程：<code>dp[n] = MAX( dp[n-1], dp[n-2] + num )</code></p><p>由于不可以在相邻的房屋闯入，所以在当前位置 <code>n</code> 房屋可盗窃的最大值，要么就是 <code>n-1</code> 房屋可盗窃的最大值，要么就是 <code>n-2</code> 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值</p><p>时间复杂度：<code>O(n)</code>，n为数组长度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rob = <span class="function"><span class="params">nums</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> n=nums.length;</span><br><span class="line">    <span class="keyword">let</span> dp=[];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i]=<span class="built_in">Math</span>.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 优化空间</span></span><br><span class="line"><span class="keyword">const</span> rob = <span class="function"><span class="params">nums</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> n=nums.length;</span><br><span class="line">    <span class="keyword">let</span> pre=<span class="number">0</span>,cur=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        [pre,cur]=[cur,<span class="built_in">Math</span>.max(cur,pre+nums[i-<span class="number">1</span>])];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>我们定义 target 是在一个在左闭右闭的区间里，也就是<code>[left, right]</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> search = <span class="function">(<span class="params">nums, target</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="comment">// [l,r]</span></span><br><span class="line">    <span class="keyword">let</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((l+r)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]===target)<span class="keyword">return</span> mid;</span><br><span class="line">        <span class="comment">// 中心值&lt;目标，取右区间，否则左区间</span></span><br><span class="line">        nums[mid]&lt;target ? l=mid+<span class="number">1</span> : r= mid-<span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="x-的平方根"><a href="#x-的平方根" class="headerlink" title="x 的平方根"></a>x 的平方根</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySqrt = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">1</span>,right = x;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 中间值  下面这样写是防止溢出</span></span><br><span class="line">        <span class="keyword">let</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 判断mid的平方是否小于或等于x，如果mid的平方小于x</span></span><br><span class="line">        <span class="keyword">if</span> (mid &lt;= x / mid) &#123;</span><br><span class="line">            <span class="comment">// 判断(mid+1)的平方是否大于x，如果(mid+1)的平方大于x，那么mid就是x的平方根</span></span><br><span class="line">            <span class="keyword">if</span> (mid + <span class="number">1</span> &gt; x / (mid + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果mid的平方小于x并且(mid+1)的平方小于x，那么x的平方根比mid大，接下来搜索从mid+1到x的范围</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果mid的平方大于x，则x的平方根小于mid，接下来搜索1到mid-1的范围</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果输入参数是0，left等于1而right等于0，就直接返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h2><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p><strong>中心扩展</strong></p><p>两种情况</p><ul><li>一种是回文子串长度为奇数（如aba，中心是b）</li><li>另一种回文子串长度为偶数（如abba，中心是b，b）</li></ul><p>循环遍历字符串，对取到的每个值，都假设他可能成为最后的中心进行判断。</p><p>由中心向两边扩散，直到左右边界不相等时，与之前得到的回文子串长度进行比较，大的话记录。</p><p>最后通过slice()截取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> longestPalindrome = <span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 中心扩展 分奇偶</span></span><br><span class="line">    <span class="keyword">const</span> n=s.length;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">let</span> l=<span class="number">0</span>,r=<span class="number">0</span>;<span class="comment">// 截取边界 (l,r)</span></span><br><span class="line">    <span class="keyword">const</span> helper = <span class="function">(<span class="params">left,right</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; right&lt;n &amp;&amp; s[left]===s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回文串长度=right-left-1</span></span><br><span class="line">        <span class="comment">// 如果此轮询得到回文串长度大于之前记录， 记录此轮循边界</span></span><br><span class="line">        <span class="keyword">if</span>(right-left-<span class="number">1</span>&gt;r-l-<span class="number">1</span>)&#123;</span><br><span class="line">            l=left;</span><br><span class="line">            r=right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        helper(i,i); <span class="comment">// 奇数</span></span><br><span class="line">        helper(i,i+<span class="number">1</span>);<span class="comment">// 偶数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.slice(l+<span class="number">1</span>,r);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isPalindrome = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 中心扩展</span></span><br><span class="line">    <span class="keyword">let</span> s = x.toString();</span><br><span class="line">    <span class="keyword">let</span> n = s.length, l, r;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 下标从0开始</span></span><br><span class="line">    r = n &gt;&gt; <span class="number">1</span>;<span class="comment">// n/2向下取整</span></span><br><span class="line">    l= (n % <span class="number">2</span>) ? r : r-<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(l&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[l]!==s[r])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        l--;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="双指针★"><a href="#双指针★" class="headerlink" title="双指针★"></a>双指针★</h2><blockquote><p>考察公司：华为、百度</p></blockquote><h3 id="无重复字符的最长子串-★"><a href="#无重复字符的最长子串-★" class="headerlink" title="无重复字符的最长子串 ★"></a>无重复字符的最长子串 ★</h3><p><strong>滑动窗口</strong>（双指针）</p><p><strong>依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的</strong>！</p><p>假设我们选择字符串中的第 k个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 r_k。</p><p>那么当我们选择第k+1 个字符作为起始位置时，首先从k+1 到 r_k的字符显然是不重复的，并且由于少了原本的第k 个字符，我们可以尝试继续增大 r_k，直到右侧出现了重复字符为止。</p><ul><li><p>我们使用<strong>两个指针</strong>表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中<code>枚举子串的起始位置</code>，而右指针即为上文中的 <code>r_k</code>；</p></li><li><p>在每一步的操作中，我们会将<strong>左指针向右移动一格</strong>，表示<strong>我们开始枚举下一个字符作为起始位置</strong>，然后我们可以不断地向右移动右指针，但需要保证这<strong>两个指针对应的子串中没有重复的字符</strong>。在移动结束后，这个子串就对应着<strong>以左指针开始的，不包含重复字符的最长子串</strong>。我们记录下这个子串的长度；</p></li><li><p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p></li></ul><p><strong>判断重复字符</strong></p><p>需要使用一种数据结构来判断是否有重复的字符，常用的数据结构为哈希集合（<code>JavaScript</code> 中的 <code>Set</code>）。</p><p>在<strong>左指针向右移动</strong>的时候，我们从哈希集合中<strong>移除一个字符</strong>，在<strong>右指针向右移动</strong>的时候，我们<strong>往哈希集合中添加一个字符</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lengthOfLongestSubstring = <span class="function"><span class="params">s</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();<span class="comment">// 哈希集合，记录每个字符是否出现</span></span><br><span class="line">    <span class="keyword">const</span> n = s.length;</span><br><span class="line">    <span class="keyword">let</span> rk=-<span class="number">1</span>,ans=<span class="number">0</span>;<span class="comment">// 右指针，初始值为 -1 相当于在字符串的左边界的左侧，还没开始移动</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">// 左指针 i</span></span><br><span class="line">        <span class="keyword">if</span>(i!==<span class="number">0</span>) set.delete(s[i-<span class="number">1</span>]);<span class="comment">// 左指针每向右移动一格，移除集合中第一个字符</span></span><br><span class="line">        <span class="keyword">while</span>(rk+<span class="number">1</span>&lt;n &amp;&amp; !set.has(s[rk+<span class="number">1</span>]))&#123;<span class="comment">// 不断地移动右指针，直到第rk+1个字符已存在</span></span><br><span class="line">            set.add(s[rk+<span class="number">1</span>]);</span><br><span class="line">            rk++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">Math</span>.max(ans,rk-i+<span class="number">1</span>);<span class="comment">// [i,rk]为无重复子串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><p><strong>逆向双指针</strong></p><p>考查<strong>原地修改</strong> ，将空间复杂度降低到 <code>O(1)</code>。</p><p>不需要使用额外的数组空间了，我们完全可以把nums2也放入nums1 中。</p><p>原地修改时，为了避免从前往后遍历导致原有数组元素被破坏掉，我们要选择<strong>从后往前遍历</strong>！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">nums1, m, nums2, n</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 逆向双指针 原地修改</span></span><br><span class="line">    <span class="keyword">let</span> i=m-<span class="number">1</span>,j=n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[i+j+<span class="number">1</span>]=nums2[j--];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[i+j+<span class="number">1</span>]=nums1[i--];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i]&lt;nums2[j])&#123;</span><br><span class="line">            nums1[i+j+<span class="number">1</span>]=nums2[j--];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nums1[i+j+<span class="number">1</span>]=nums1[i--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h3><p><strong>分割、双指针</strong></p><p>我们可以将版本号按照<strong>点号</strong>分割（<code>split(&#39;.&#39;)</code>）成修订号，然后从左到右比较两个版本号的相同下标的修订号。在比较修订号时，需要将字符串转换成整数进行比较。注意根据题目要求，如果版本号不存在某个下标处的修订号，则该修订号视为 0。</p><p>方法一需要<strong>存储分割后的修订号</strong>，为了优化空间复杂度，我们可以在分割版本号的同时解析出修订号进行比较。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compareVersion = <span class="function">(<span class="params">version1, version2</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> m=version1.length,n=version2.length;</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m || j&lt;n)&#123;</span><br><span class="line">        <span class="keyword">let</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m &amp;&amp; version1[i]!==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            x=x*<span class="number">10</span>+<span class="built_in">Number</span>(version1[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n &amp;&amp; version2[j]!=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            y=y*<span class="number">10</span>+<span class="built_in">Number</span>(version2[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(x!==y)<span class="keyword">return</span> x&gt;y ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="字符串相加-★"><a href="#字符串相加-★" class="headerlink" title="字符串相加 ★"></a>字符串相加 ★</h3><p><strong>双指针</strong></p><p>因为本题不能使用任何 BigInteger 库，所以我们可以使用双指针来模拟人工计算，步骤如下：</p><ul><li>创建指针 i 指向 nums1 末位数字，j 指向 nums2末位数字。</li><li>i, j 数字相加，用进位就用 <code>carry</code> 来记录进位值，无则为0。</li><li>若产生进位，则当前数字为 (i+j+carry)%10 的值。</li><li>若遍历过程中，nums1 或 nums2 当前已无数字，则用0 补位来计算。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addStrings = <span class="function">(<span class="params">num1, num2</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 双指针来模拟人工计算</span></span><br><span class="line">    <span class="comment">// carry模拟进位</span></span><br><span class="line">    <span class="keyword">let</span> i=num1.length-<span class="number">1</span>,j=num2.length-<span class="number">1</span>,carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> ans = [] ; <span class="comment">// 保存结果的数组</span></span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span> || carry&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> n1 = i&gt;=<span class="number">0</span> ? num1[i]-<span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>,</span><br><span class="line">            n2 = j&gt;=<span class="number">0</span> ? num2[j]-<span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;<span class="comment">// - &#x27;0&#x27;字符串转数字</span></span><br><span class="line">        <span class="keyword">let</span> sum = n1 + n2 + carry;</span><br><span class="line">        ans.unshift(sum % <span class="number">10</span>);</span><br><span class="line">        carry = <span class="built_in">Math</span>.floor(sum/<span class="number">10</span>); <span class="comment">// 向下取整</span></span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.join(<span class="string">&#x27;&#x27;</span>);<span class="comment">//数组元素拼接成字符串</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><p><strong>逐个比较</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> longestCommonPrefix =<span class="function"><span class="params">strs</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = strs.length;</span><br><span class="line">    <span class="comment">// 字符串数组为空</span></span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 初始化最长公共前缀为第一个字符串</span></span><br><span class="line">    <span class="keyword">let</span> ans = strs[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 与其他字符串两两相比，不断截取以得到最长公共前缀</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> j=<span class="number">0</span>;<span class="comment">// 放在for循环外面是因为循环结束还要用到j</span></span><br><span class="line">        <span class="keyword">for</span>(;j&lt;ans.length &amp;&amp; j &lt; strs[i].length;j++) &#123;</span><br><span class="line">            <span class="comment">// 字符串也可以用[]进行字符访问</span></span><br><span class="line">            <span class="keyword">if</span>(ans[j] !== strs[i][j])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从0索引开始截取j个 </span></span><br><span class="line">        ans = ans.substr(<span class="number">0</span>, j); </span><br><span class="line">        <span class="comment">// 最长公共前缀变为&quot;&quot;就提前返回</span></span><br><span class="line">        <span class="keyword">if</span>(ans===<span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="颠倒字符串中的单词"><a href="#颠倒字符串中的单词" class="headerlink" title="颠倒字符串中的单词"></a>颠倒字符串中的单词</h3><p><strong>正则 + JS API</strong></p><p><code>\s</code> 匹配一个<strong>空白字符</strong>，包括空格、制表符、换页符和换行符。</p><p><code>\S</code> 匹配一个<strong>非空白字符</strong>。</p><p><code>+</code> 至少一个，相当于{1,}</p><p><code>match</code> 一个在字符串中执行查找匹配的String方法，它返回一个<strong>数组</strong>，在未匹配到时会返回 null。</p><p><code>i</code> 忽略大小写</p><p><code>g</code> 全局匹配模式</p><p>两种思路</p><ul><li>一种匹配非空字符，翻转，拼接</li><li>另一种去除首尾空字符后匹配空字符，按空字符分割，翻转，拼接</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s.match(<span class="regexp">/\S+/g</span>).reverse().join(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="comment">// return s.trim().replace(/\s+/g,&#x27; &#x27;).split(&#x27; &#x27;).reverse().join(&#x27; &#x27;);</span></span><br><span class="line">    <span class="comment">// return s.trim().split(/\s+/).reverse().join(&#x27; &#x27;);</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>双指针</strong></p><p>使用双指针的方法，<strong>从后向前</strong>遍历字符</p><ul><li>右端的指针遇到空格跳过，直到单词的末尾</li><li>没有到头就将左端的指针指向右端</li><li>左指针继续向前，直到遇到空格或小于0才停下（此时左右指针之间就是单词）</li><li>遍历单词将其添加到结果字符串中</li><li>把右指针指向左指针，开始下一轮遍历</li></ul><p>下一轮遍历开始后，<strong>如果还有新单词</strong>，就给上一个单词后面添加一个空格。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> r=s.length-<span class="number">1</span>, l=r,res=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//先找到单词的尾部</span></span><br><span class="line">        <span class="keyword">while</span>(s[r]===<span class="string">&#x27; &#x27;</span>)r--;</span><br><span class="line">        <span class="comment">// 如果找到头了就退出，否则l=r</span></span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l=r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给上次单词后加空格，排除第一次</span></span><br><span class="line">        <span class="keyword">if</span>(res) res += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="comment">// 找到单词的头部</span></span><br><span class="line">        <span class="keyword">while</span>(s[l] &amp;&amp; s[l]!== <span class="string">&#x27; &#x27;</span>)l--;</span><br><span class="line">        <span class="comment">// 遍历单词并添加  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = l + <span class="number">1</span>; i &lt;= r; i++)res += s[i];</span><br><span class="line">        <span class="comment">// 右指针跳过当前单词</span></span><br><span class="line">        r = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p>外层循环：指针 i 遍历数组。</p><p>内层循环：用双指针，去寻找满足三数之和 == 0 的元素</p><p><strong>先排序的意义</strong></p><p>便于跳过重复元素，如果当前元素和前一个元素相同，跳过。</p><p><strong>双指针的移动时，避免出现重复解</strong></p><p>找到一个解后，左右指针同时向内收缩，为了避免指向重复的元素，需要：</p><ul><li>左指针在保证left &lt; right的前提下，一直右移，直到指向不重复的元素</li><li>右指针在保证left &lt; right的前提下，一直左移，直到指向不重复的元素</li></ul><p><strong>小优化</strong></p><p>排序后，如果外层遍历的数已经大于0，则另外两个数一定大于0，sum不会等于0，直接break。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> threeSum = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);<span class="comment">// 排序便于跳过重复元素</span></span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> n1 = nums[i];</span><br><span class="line">        <span class="keyword">if</span> (n1 &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 升序排序，n1是三数中最小的</span></span><br><span class="line">        <span class="comment">// 遍历到重复的数，跳过,因为排序，重复元素的第一个总是能取到</span></span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; n1 == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">let</span> left = i + <span class="number">1</span>;<span class="comment">// 左指针</span></span><br><span class="line">        <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;<span class="comment">// 右指针</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">let</span> n2 = nums[left], n3 = nums[right];</span><br><span class="line">            <span class="keyword">if</span> (n1 + n2 + n3 === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 三数和=0，加入解集res</span></span><br><span class="line">                res.push([n1, n2, n3]);</span><br><span class="line">                <span class="comment">// 直到指向不一样的数</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == n2) left++;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == n3) right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n1 + n2 + n3 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 三数和小于0，则左指针右移</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 三数和大于0，则右指针左移</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h3><p>双指针交换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moveZeroes = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] !== <span class="number">0</span> ) &#123;</span><br><span class="line">            [nums[i++], nums[j++]] = [nums[j], nums[i]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>非 0 项覆盖到数组前头</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moveZeroes = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 遇到非0项,覆盖到j上,j后移</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)nums[j++] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = j; i &lt; nums.length; i++) &#123; <span class="comment">// 剩下的位置赋为0</span></span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="栈★"><a href="#栈★" class="headerlink" title="栈★"></a>栈★</h2><blockquote><p>考察公司：小米、美团、华为</p></blockquote><h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><p><strong>栈+哈希表Map</strong></p><p>我们遍历给定的字符串 s。</p><p>当我们遇到一个<strong>左括号</strong>时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。</p><p>由于<strong>后遇到的左括号要先闭合</strong>，因此我们可以将这个<strong>左括号放入栈顶</strong>。</p><p>当我们遇到一个<strong>右括号</strong>时，我们需要将一个相同类型的左括号闭合。</p><p>此时，我们可以<strong>取出栈顶的左括号</strong>并判断它们是否是相同类型的括号。</p><p>如果<strong>不是相同的类型</strong>，或者栈中并<strong>没有左括号</strong>，那么字符串 s 无效，返回 <code>False</code>。</p><p>为了快速判断括号的类型，我们可以使用<strong>哈希表</strong>存储每一种括号。</p><p>哈希表的<strong>键为右括号</strong>，<strong>值为相同类型的左括号</strong>。</p><p>在遍历结束后，如果<strong>栈中没有左括号</strong>，说明我们将字符串 s 中的所有左括号闭合，返回 <code>True</code>，否则返回 False。</p><p>注意到有效字符串的长度一定为<strong>偶数</strong>，因此如果字符串的长度为<strong>奇数</strong>，我们可以直接返回<code>False</code>，省去后续的遍历判断过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isValid = <span class="function"><span class="params">s</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = s.length;</span><br><span class="line">    <span class="comment">// 如果字符数为奇数一定无效</span></span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>===<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// map存储括号</span></span><br><span class="line">    <span class="comment">// 将数组传入Map构造函数，就可以转为 Map</span></span><br><span class="line">    <span class="keyword">const</span> pairs = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">        [<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;(&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;[&#x27;</span>]</span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">const</span> stack =[];<span class="comment">// 栈 存放左括号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s)&#123;      </span><br><span class="line">        <span class="keyword">if</span>(pairs.has(ch))&#123;</span><br><span class="line">            <span class="comment">// 如果遇到右括号，但栈里没有左括号或最后一个左括号不能与之对应 返回false</span></span><br><span class="line">            <span class="keyword">if</span>( !stack.length || stack[stack.length-<span class="number">1</span>] !== pairs.get(ch))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop();<span class="comment">// 否则从栈里取出对应的左括号</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            stack.push(ch);<span class="comment">// 左括号入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack.length;<span class="comment">// 结束后，栈为空说明所有的括号都能闭合</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="有效的括号字符串"><a href="#有效的括号字符串" class="headerlink" title="有效的括号字符串"></a>有效的括号字符串</h3><p>正向把所有星号转成左括号，反向把所有星号转成右括号,统计左括号和右括号的数量，只要有一个小于0，说明不匹配，也就不是一个有效字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> checkValidString = <span class="function"><span class="params">s</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> n=s.length</span><br><span class="line">    <span class="keyword">let</span> l=<span class="number">0</span>,r=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        l += s[i] === <span class="string">&#x27;)&#x27;</span> ? -<span class="number">1</span> : <span class="number">1</span></span><br><span class="line">        r += s[n-i-<span class="number">1</span>] === <span class="string">&#x27;(&#x27;</span> ? -<span class="number">1</span> : <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(l&lt;<span class="number">0</span> || r&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>两个栈</strong>， 一个存放（ ，一个存放 *</p><p>栈中存放下标</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> checkValidString = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [], star = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123; <span class="comment">// 一遍遍历， 对每一个s[i]，判断是入栈还是抵消</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>) stack.push(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;*&#x27;</span>) star.push(i);</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// 是个 &quot;)&quot;, 两个栈都不收，不仅不收，还要‘抵消’， 处理如下👇</span></span><br><span class="line">            <span class="keyword">if</span>(stack.length) stack.pop();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(star.length) star.pop();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 没得抵消了， 只能返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stack.length &gt; star.length) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//对两个栈 处理</span></span><br><span class="line">    <span class="keyword">while</span>(stack.length &amp;&amp; star.length)&#123;</span><br><span class="line">         <span class="keyword">if</span>(stack.pop() &gt; star.pop()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// **((, 类似这样，虽个数合适，但顺序（下标）不可</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h3><p>维护一个栈。</p><p>因为扫描过的字符还不知道要不要删，要保留对它的记忆，入栈暂存</p><p>遍历字符串，如果当前字符和栈顶字符相同，则栈顶出栈（删字符），否则入栈</p><p>最后将栈中剩下的字符转成字符串即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> removeDuplicates = <span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.length &gt; <span class="number">0</span> &amp;&amp; stack[stack.length - <span class="number">1</span>] === s[i]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="队列★"><a href="#队列★" class="headerlink" title="队列★"></a>队列★</h2><h2 id="哈希★"><a href="#哈希★" class="headerlink" title="哈希★"></a>哈希★</h2><blockquote><p>考察公司：百度、b站</p></blockquote><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p><strong>哈希表map</strong></p><p>我们遍历到数字 a时，用 target 减去 a，就会得到 b，若 b 存在于哈希表中，我们就可以直接返回结果了。若 b 不存在，那么我们需要将 a 存入哈希表，好让后续遍历的数字使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> twoSum = <span class="function">(<span class="params">nums, target</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 哈希表map</span></span><br><span class="line">    <span class="keyword">const</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">// map存在一个键名=target-nums[i]，取出对应的键值</span></span><br><span class="line">        <span class="keyword">if</span>(map.has(target-nums[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> [map.get(target-nums[i]),i];<span class="comment">// 题目要求返回下标</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.set(nums[i],i);<span class="comment">// 键名：数nums[i]；键值：下标i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="存在重复元素-II"><a href="#存在重复元素-II" class="headerlink" title="存在重复元素 II"></a>存在重复元素 II</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> containsNearbyDuplicate = <span class="function">(<span class="params">nums, k</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">const</span> n = nums.length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(nums[i]) &amp;&amp; i - map.get(nums[i]) &lt;= k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        map.set(nums[i],i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="链表★"><a href="#链表★" class="headerlink" title="链表★"></a>链表★</h2><blockquote><p>考察公司：美团、华为、w’m</p></blockquote><h3 id="封装链表"><a href="#封装链表" class="headerlink" title="封装链表"></a>封装链表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装单链表的节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.val = value;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输入链表</span></span><br><span class="line"><span class="keyword">const</span> input = []</span><br><span class="line"><span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//初始化头节点</span></span><br><span class="line"><span class="keyword">if</span>(input[<span class="number">0</span>] !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">  head = <span class="keyword">new</span> ListNode(input[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentNode = head;<span class="comment">// 中间变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; input.length; i++) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!currentNode.next) &#123;</span><br><span class="line">    currentNode = currentNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后一个节点的next指向新节点</span></span><br><span class="line">  currentNode.next = <span class="keyword">new</span> ListNode(input[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(head);</span><br><span class="line"><span class="keyword">let</span> output = head;</span><br><span class="line"><span class="built_in">console</span>.log(output)</span><br><span class="line"><span class="keyword">const</span> res = [];</span><br><span class="line"><span class="keyword">while</span> (!output) &#123;</span><br><span class="line">  <span class="comment">// if(output.val === undefined)break;// 返回空数组</span></span><br><span class="line">  res.push(output.val);<span class="comment">// 将当前节点值存入数组</span></span><br><span class="line">  output = output.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p><strong>递归</strong></p><p>反转</p><ul><li>当前节点<code>head</code>，下一个节点 <code>head.next</code></li><li><code>head.next.next = head</code> 此处将下一个节点指向当前节点，即是反转</li><li><code>head.next = null</code>此处将当前节点指向下一个节点的指针断开</li></ul><p><strong>最先调用的函数会在递归过程中最后被执行，而最后调用的会最先执行</strong></p><ul><li><strong>最先返回最后两个节点开始反转操作</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseList = <span class="function"><span class="params">head</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">const</span> reverseHead = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> reverseHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>迭代 双指针</strong></p><p>初始化：设置pre指针指向 null，将当前节点cur指向head。</p><p>将当前节点cur的next指针指向上一个节点pre。</p><p>然后当前节点和下一个节点更新为pre和cur。</p><p>重复以上动作直到当前节点cur指向null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseList = <span class="function"><span class="params">head</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 双指针</span></span><br><span class="line">    <span class="comment">// 定义一个cur指针，指向头节点，再定义一个pre指针，初始化为null</span></span><br><span class="line">    <span class="keyword">let</span> cur=head,pre=<span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 直到当前节点指向null结束</span></span><br><span class="line">    <span class="keyword">while</span>(cur !==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 简化版本 解构赋值</span></span><br><span class="line">        [cur.next,pre,cur] = [pre,cur,cur.next];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p><strong>借助哈希表</strong></p><p>哈希表存遍历过的节点，每遍历一个节点，都查看哈希表是否存在当前节点，如果存在，则说明链表有环</p><p>如果不存在，则存入哈希表，继续遍历</p><p>时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(n)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasCycle = <span class="function"><span class="params">head</span>  =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();<span class="comment">//哈希表存遍历过的节点</span></span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(head)) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 如果存在，则说明链表有环</span></span><br><span class="line">        map.set(head,<span class="literal">true</span>);<span class="comment">// 存的是节点的地址引用，而不是节点值</span></span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>快慢指针法</strong></p><p>快、慢指针，从头节点出发。</p><p>慢指针每次走一步，快指针每次走两步，不断比较它们指向的节点的值。</p><p>如果节点值相同，说明有环。如果不同，继续循环。</p><blockquote><p>类似 “追及问题”</p></blockquote><p>两个人在环形跑道上赛跑，同一个起点出发，一个跑得快一个跑得慢，在某一时刻，跑得快的必定会追上跑得慢的，只要是跑道是环形的，不是环形就肯定追不上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasCycle = <span class="function"><span class="params">head</span>  =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="keyword">let</span> fast =head,slow=head;</span><br><span class="line">    <span class="comment">// fast 防止链表为空的情况</span></span><br><span class="line">    <span class="comment">// fast.next 快指针每次移动两格，</span></span><br><span class="line">    <span class="comment">// 如果fast.next已经指向null，fast.next.next就不存在，且此时一定没有环</span></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.next )&#123;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">// 相对速度是1，快的只能一格一格追，有环的话一定会相遇</span></span><br><span class="line">        <span class="keyword">if</span>(slow===fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p><strong>递归</strong></p><p>这道题可以使用递归实现，新链表也不需要构造新节点，我们下面列举递归三个要素</p><ul><li>终止条件：两条链表分别名为 <code>l1</code> 和 <code>l2</code>，当 <code>l1</code> 为空或 <code>l2</code> 为空时结束</li><li>返回值：每一层调用都返回排序好的链表头</li><li>本级递归内容：如果 <code>l1</code> 的 val 值更小，则将 <code>l1.next</code> 与排序好的链表头相接，<code>l2</code> 同理</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeTwoLists = <span class="function">(<span class="params">list1, list2</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// list1&lt;list2,list1.next=null,此时令list1.next=list2</span></span><br><span class="line">    <span class="keyword">if</span>(list1 === <span class="literal">null</span>)<span class="keyword">return</span> list2</span><br><span class="line">    <span class="keyword">if</span>(list2 === <span class="literal">null</span>)<span class="keyword">return</span> list1</span><br><span class="line">    <span class="comment">// 每一层调用都返回排序好的链表头</span></span><br><span class="line">    <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">        list1.next = mergeTwoLists(list1.next,list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        list2.next = mergeTwoLists(list1,list2.next);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h3><p><strong>快慢指针</strong></p><p>快慢指针的思想。我们将第一个指针fast 指向链表的第 k + 1 个节点，第二个指针slow 指向链表的第一个节点，此时指针 fast 与 slow 二者之间刚好间隔 k 个节点。此时两个指针同步向后走，当第一个指针 fast 走到链表的尾部空节点时，则此时 slow 指针刚好指向链表的倒数第k个节点。</p><p>我们首先将 fast 指向链表的头节点，然后向后走 k 步，则此时fast 指针刚好指向链表的第 k+1 个节点。</p><p>我们首先将 slow 指向链表的头节点，同时 slow 与 fast 同步向后走，当fast 指针指向链表的尾部空节点时，则此时返回 slow 所指向的节点即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getKthFromEnd = <span class="function">(<span class="params">head, k</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="keyword">let</span> fast = head,slow=head;</span><br><span class="line">    <span class="comment">// fast 指向链表的第 k + 1 个节点，</span></span><br><span class="line">    <span class="comment">// slow 指向链表的第一个节点</span></span><br><span class="line">    <span class="comment">// 此时指针 fast 与 slow 二者之间刚好间隔 k 个节点</span></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fast 指针指向链表的尾部空节点时</span></span><br><span class="line">    <span class="comment">// slow 指向倒数第k个</span></span><br><span class="line">    <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="链表随机节点-★"><a href="#链表随机节点-★" class="headerlink" title="链表随机节点 ★"></a>链表随机节点 ★</h3><h2 id="树★"><a href="#树★" class="headerlink" title="树★"></a>树★</h2><blockquote><p>考察公司：美团、华为</p></blockquote><h3 id="封装树"><a href="#封装树" class="headerlink" title="封装树"></a>封装树</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装树的节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.val = val;</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h3><p><strong>递归</strong></p><p>前序遍历的定义：对每个节点，都是先处理当前节点，对它执行我们的处理逻辑，再递归它的左子树，再递归它的右子树，对子树中的节点执行相同的逻辑。(<strong>中左右</strong>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preorderTraversal = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 递归 中左右</span></span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> preOrder = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span>;<span class="comment">// 递归终止条件</span></span><br><span class="line">        res.push(root.val);<span class="comment">// 中</span></span><br><span class="line">        preOrder(root.left);<span class="comment">// 左</span></span><br><span class="line">        preOrder(root.right);<span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root);<span class="comment">//递归入口</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>迭代</strong></p><p>为什么可以用迭代法（非递归的方式）来实现二叉树的前后中序遍历呢？</p><p>递归的实现就是：<strong>每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因</strong>。</p><p>此时大家应该知道我们用<strong>栈</strong>也可以是实现二叉树的前后中序遍历了。</p><p>统一格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">let</span> stack=[];</span><br><span class="line">    <span class="keyword">let</span> node =root;</span><br><span class="line">    <span class="comment">// 和递归思想类似</span></span><br><span class="line">    <span class="keyword">while</span>(node || stack.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            res.push(node.val);</span><br><span class="line">            node=node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;    </span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的中序遍历-★"><a href="#二叉树的中序遍历-★" class="headerlink" title="二叉树的中序遍历 ★"></a>二叉树的中序遍历 ★</h3><p>递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">const</span> inOrder = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        res.push(root.val);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inorderTraversal = <span class="function"><span class="params">root</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 迭代 栈 左中右</span></span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> node = root;</span><br><span class="line">    <span class="keyword">while</span>(node || stack.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        res.push(node.val);</span><br><span class="line">        node = node.right</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h3><p><strong>递归</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inorderTraversal = <span class="function"><span class="params">root</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 递归 左中右</span></span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    <span class="keyword">const</span> inOrder = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        res.push(root.val);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>迭代</strong></p><p>统一格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res =[];</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> node = root;</span><br><span class="line">    <span class="keyword">while</span>(node || stack.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            <span class="comment">//res.push(node.val);</span></span><br><span class="line">            res.unshift(node.val);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">//return res.reverse();</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><p><strong>递归+二叉树</strong></p><p>sum： 从根节点到叶子节点的路径上的节点值相加的目标和</p><p>对 root 递归。转为判断：root 的左、右子树中能否找出和为 sum-root.val 的路径</p><p>就变成一个规模小一点的相同问题</p><p>即，每遍历一个节点，sum 就减去当前节点值，当遍历到叶子节点时，因为没有子节点了，如果 sum - 当前叶子节点值 == 0 ，即找到了从根节点到叶子节点的和为 sum 的路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasPathSum = <span class="function">(<span class="params">root, targetSum</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root===<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 树空或者递归返回点</span></span><br><span class="line">    <span class="comment">// 遇到叶子节点，判断当前目标值-叶子节点值是否为0</span></span><br><span class="line">    <span class="keyword">if</span>(root.left===<span class="literal">null</span> &amp;&amp; root.right ===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> targetSum - root.val ===<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右节点继续递归 所有节点都会遍历一次，只要存在一条路径符合，就会返回true</span></span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="求根节点到叶节点数字之和"><a href="#求根节点到叶节点数字之和" class="headerlink" title="求根节点到叶节点数字之和"></a>求根节点到叶节点数字之和</h3><p><strong>DFS</strong></p><p>一个递归分支维护一个 cur 变量，在下探的过程中计算，更新 cur。</p><p><code>cur = 10 * cur + root.val;</code></p><p>当遍历到叶子节点时，当前分支计算结束，返回 cur。</p><p>遍历到非叶子节点时，基于当前cur，递归计算左右子分支，并把结果相加：</p><p>默认root.left和root.right是存在的，如果不存在呢？或者，递归入口传的 root 就不存在呢？</p><p>设置一个递归的出口：当遍历到 null 时，不存在 root.val，直接返回 0（cur已经在叶子节点处返回了）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sumNumbers = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> helper = <span class="function">(<span class="params">root,cur</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//设置一个递归的出口：当遍历到 null 时，不存在 root.val，直接返回 0</span></span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 一个递归分支维护一个cur变量，在下探的过程中计算，更新cur。</span></span><br><span class="line">        cur = cur*<span class="number">10</span>+root.val;</span><br><span class="line">        <span class="comment">// 当遍历到叶子节点时，当前分支计算结束，返回 cur。</span></span><br><span class="line">        <span class="keyword">if</span>(root.left===<span class="literal">null</span> &amp;&amp; root.right===<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历到非叶子节点时，基于当前cur，递归计算左右子分支，并把结果相加</span></span><br><span class="line">        <span class="keyword">return</span> helper(root.left,cur)+helper(root.right,cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(root,<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的层序遍历（BFS-队列）"><a href="#二叉树的层序遍历（BFS-队列）" class="headerlink" title="二叉树的层序遍历（BFS 队列）"></a>二叉树的层序遍历（BFS 队列）</h3><p><strong>DFS（Deep First Search）深度优先搜索。</strong></p><p><strong>BFS（Breath First Search）广度优先搜索。</strong></p><p><strong>队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p>遍历每一层的节点，将节点值推入 subRes 数组中</p><p>将 subRes 数组推入 res 数组中</p><p>维护一个 <strong>queue 队列</strong>，是层序遍历的特征</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> levelOrder = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 广度优先遍历 BFS</span></span><br><span class="line">    <span class="comment">// 队列 先进先出</span></span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> [];<span class="comment">// 树空</span></span><br><span class="line">    <span class="keyword">const</span> res=[];<span class="comment">// 初始化结果</span></span><br><span class="line">    <span class="keyword">const</span> queue = [root];<span class="comment">// 根节点入列</span></span><br><span class="line">    <span class="comment">// 队列中没有节点时，遍历完毕</span></span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> subRes = [];<span class="comment">// 储存每一层的节点</span></span><br><span class="line">        <span class="keyword">const</span> len =queue.length;<span class="comment">//当前层的节点数目</span></span><br><span class="line">        <span class="comment">//遍历当前层的节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> cur = queue.shift();<span class="comment">// 当前层的节点出列</span></span><br><span class="line">            subRes.push(cur.val);<span class="comment">// 同时存入subRes</span></span><br><span class="line">            <span class="comment">// 下层左右节点入列</span></span><br><span class="line">            <span class="keyword">if</span>(cur.left) queue.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right) queue.push(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(subRes);<span class="comment">// 将当前层的结果放入res</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>易错点</strong></p><ul><li><code>const len = queue.length</code> <strong>必须先保存当前层的节点数</strong>，再做遍历</li><li>不能 <code>for (let i = 0; i &lt; queue.length; i++) &#123;...&#125;</code></li><li>因为在 for 循环时，queue有出列和入列，长度是动态变化的</li></ul><h3 id="二叉树的最大深度（BFS）"><a href="#二叉树的最大深度（BFS）" class="headerlink" title="二叉树的最大深度（BFS）"></a>二叉树的最大深度（BFS）</h3><p><strong>BFS</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxDepth = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> queue = [root];</span><br><span class="line">    <span class="keyword">let</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="comment">// 当前层的节点个数</span></span><br><span class="line">        <span class="keyword">const</span> len = queue.length;          </span><br><span class="line">        <span class="comment">// 逐个让当前层的节点出列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;    </span><br><span class="line">            <span class="comment">// 当前出列的节点</span></span><br><span class="line">            <span class="keyword">let</span> cur = queue.shift();            </span><br><span class="line">            <span class="comment">// 左右子节点入列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left) queue.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right) queue.push(cur.right); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前层所有节点已经出列，如果队列不为空，说明有下一层节点，depth+1</span></span><br><span class="line">        <span class="keyword">if</span> (queue.length) depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TprtV1"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2021/12/15/TprtV1.png" alt="TprtV1.png"></a></p><p>有了左右子树的 postOrder 和 inorder 之后，就能继续递归构建左、右子树，一直递归下去，直到：无法形成 postOrder 和 inorder 数组，就构建不出子树了，即来到树的底部了，返回 null 节点。</p><p>递归函数可以选择接受数组本身，也可以接收指针，我采用后者，根据指针 iStart 到指针 iEnd 的 inorder 数组，和从 pStart 到 pEnd 的 postorder 数组，构建当前子树，避免每次递归都要切割字符串。</p><p>定位root在inorder数组中的位置<br>我用了一个 map 去提前存下所有节点值在 inorder 数组中的索引，这样就不用每次都花 O(n) 的时间去定位 root 的位置。（不用类似 indexOf 这样的库函数），用空间换取时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildTree = <span class="function">(<span class="params">inorder, postorder</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> map =<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="comment">// 将节点值在inorder数组中的位置提前存入map</span></span><br><span class="line">    inorder.forEach(<span class="function">(<span class="params">val,i</span>)=&gt;</span>map.set(val,i))</span><br><span class="line">    <span class="comment">// 根据iStart到iEnd的inorder数组，和从pStart到pEnd的postorder数组构建当前子树</span></span><br><span class="line">    <span class="keyword">const</span> helper =<span class="function">(<span class="params">iStart, iEnd, pStart, pEnd</span>) =&gt;</span>&#123;</span><br><span class="line">       <span class="comment">// 指针交错了，返回null节点</span></span><br><span class="line">       <span class="keyword">if</span>(pStart&gt;pEnd || iStart&gt;iEnd)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="comment">// 获取当前要构建的根节点的值</span></span><br><span class="line">       <span class="keyword">const</span> rootVal = postorder[pEnd];</span><br><span class="line">       <span class="comment">// 获取到它在inorder数组中的位置</span></span><br><span class="line">       <span class="keyword">const</span> mid = map.get(rootVal);</span><br><span class="line">       <span class="comment">// 获取左子树的节点个数</span></span><br><span class="line">       <span class="keyword">const</span> leftNodeNum = mid - iStart;</span><br><span class="line">       <span class="comment">// 创建节点</span></span><br><span class="line">       <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">       <span class="comment">// 用递归构建左子树</span></span><br><span class="line">       root.left = helper(iStart,mid-<span class="number">1</span>,pStart,pStart+leftNodeNum-<span class="number">1</span>);</span><br><span class="line">       <span class="comment">// 用递归构建右子树</span></span><br><span class="line">       root.right = helper(mid+<span class="number">1</span>,iEnd,pStart+leftNodeNum,pEnd-<span class="number">1</span>);</span><br><span class="line">       <span class="comment">// 返回当前构建好的子树</span></span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归的入口</span></span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>,inorder.length-<span class="number">1</span>,<span class="number">0</span>,postorder.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="从中序和前序构造二叉树-★"><a href="#从中序和前序构造二叉树-★" class="headerlink" title="从中序和前序构造二叉树 ★"></a>从中序和前序构造二叉树 ★</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildTree = <span class="function">(<span class="params">preorder, inorder</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> map =<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="comment">// 将节点值在inorder数组中的位置提前存入map</span></span><br><span class="line">    inorder.forEach(<span class="function">(<span class="params">val,i</span>)=&gt;</span>map.set(val,i));</span><br><span class="line">    <span class="keyword">const</span> helper = <span class="function">(<span class="params">pStart,pEnd,iStart,iEnd</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pStart&gt;pEnd)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> rootVal = preorder[pStart];<span class="comment">//根节点的值</span></span><br><span class="line">        <span class="keyword">let</span> root = <span class="keyword">new</span> TreeNode(rootVal);<span class="comment">//根节点</span></span><br><span class="line">        <span class="keyword">let</span> mid =map.get(rootVal);<span class="comment">//根节点在inorder中的位置</span></span><br><span class="line">        <span class="keyword">let</span> leftNum = mid-iStart; <span class="comment">//左子树的节点数</span></span><br><span class="line">        root.left = helper(pStart+<span class="number">1</span>,pStart+leftNum,iStart,mid-<span class="number">1</span>);</span><br><span class="line">        root.right = helper(pStart+leftNum+<span class="number">1</span>,pEnd,mid+<span class="number">1</span>,iEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>,preorder.length-<span class="number">1</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h3><p>BFS</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rightSideView = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">let</span> queue =[root];</span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> len = queue.length;</span><br><span class="line">        <span class="keyword">while</span>(len)&#123;</span><br><span class="line">            <span class="keyword">let</span> cur=queue.shift();</span><br><span class="line">            <span class="keyword">if</span>(len === <span class="number">1</span>)res.push(cur.val);</span><br><span class="line">            <span class="keyword">if</span>(cur.left) queue.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right) queue.push(cur.right); </span><br><span class="line">            len--;          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a>二叉搜索树的第k大节点</h3><p>二叉搜索树的中序遍历是升序的</p><p>递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> kthLargest = <span class="function">(<span class="params">root, k</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">const</span> inOrder = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">        res.push(root.val);</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    <span class="keyword">return</span> res[k-<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> kthLargest = <span class="function">(<span class="params">root, k</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 迭代 栈 右中左</span></span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> node = root;</span><br><span class="line">    <span class="keyword">while</span>(node || stack.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        res.push(node.val);</span><br><span class="line">        <span class="keyword">if</span>(res.length===k)<span class="keyword">return</span> res[k-<span class="number">1</span>];</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><p><strong>局部最优</strong>：卖出股票时保证是在最低价格买入。</p><p><strong>全局最优</strong>：对每一天卖出股票得到的最大利润遍历比较。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxProfit = <span class="function"><span class="params">prices</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 贪心</span></span><br><span class="line">    <span class="keyword">const</span> n= prices.length;</span><br><span class="line">    <span class="keyword">let</span> ans =<span class="number">0</span>,minPrice=prices[<span class="number">0</span>];</span><br><span class="line">     <span class="comment">// 无论哪天卖掉股票，都要保证我是在价格最低时买入的。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        minPrice = <span class="built_in">Math</span>.min(minPrice,prices[i-<span class="number">1</span>]);<span class="comment">// 卖出股票前的最低价格</span></span><br><span class="line">        <span class="comment">// prices[i]-minPrice即为当天卖出所能得到的最大利润</span></span><br><span class="line">        <span class="comment">// 遍历所有情况即可得到哪一天卖出可以得到最大利润</span></span><br><span class="line">        ans = <span class="built_in">Math</span>.max(prices[i]-minPrice,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h3><p>将每一天与前一天价格比较，有利润的话，前一天买，当天卖。</p><p>局部最优：收集每天的正利润。</p><p>全局最优：累加获得最大利润。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxProfit = <span class="function"><span class="params">prices</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 贪心 </span></span><br><span class="line">    <span class="keyword">let</span> profit = <span class="number">0</span>;<span class="comment">//收益</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">        <span class="comment">// 今天和昨天的差价大于0，就昨天买，今天卖，赚差价</span></span><br><span class="line">        profit += <span class="built_in">Math</span>.max(prices[i]-prices[i-<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h3 id="千位分隔数"><a href="#千位分隔数" class="headerlink" title="千位分隔数"></a>千位分隔数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thousandSeparator = <span class="function"><span class="params">n</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> num=n.toString().split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i= num.length-<span class="number">3</span>;i&gt;<span class="number">0</span>;i-=<span class="number">3</span>)&#123;</span><br><span class="line">        num.splice(i,<span class="number">0</span>,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h3><p>某个元素只出现 1 次，其余元素都出现 2 次</p><p>时间复杂度O(n)，空间复杂度O(1)</p><p>只操作 nums 数组本身，不使用额外空间</p><p>异或：同为0，异为1 <code>n ^ n === 0 且 n ^ 0 === n</code></p><ul><li>异或遵循<strong>交换律</strong></li><li>[4,1,2,1,2] 将数字全部异或运算一遍：</li><li><code>4 ^ 1 ^ 2 ^ 1 ^ 2 =&gt; 1 ^ 1 ^ 2 ^ 2 ^ 4 =&gt; 0 ^ 2 ^ 2 ^ 4 =&gt; 2 ^ 2 ^ 4 =&gt; 0 ^ 4 =&gt; 4</code></li><li>出现 2 次的数字在异或中都抵消了，最后得出只出现 1 次的数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> singleNumber = <span class="function"><span class="params">nums</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        res= res ^ nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/LdZzod"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/04/18/LdZzod.png" alt="LdZzod.png"></a></p><h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><p>while循环只遍历<strong>环</strong>，不成环就不再便利。</p><ul><li>如果一条边从头遍历到底，则下一条边遍历的起点随之变化</li><li><strong>选择不遍历到底</strong>，可以减小横向、竖向遍历之间的影响</li><li>一轮迭代结束时，<strong>4条边的两端同时收窄 1</strong></li><li>一轮迭代所做的事情变得很清晰：<strong>遍历一个“圈”，遍历的范围收缩为内圈</strong></li><li>一层层向里处理，按<strong>顺时针</strong>依次遍历：上、右、下、左。</li><li>不再形成“环”了，就会剩下：<strong>一行或一列，然后单独判断</strong></li></ul><p><strong>四个边界</strong></p><ul><li>上边界 <code>top : 0</code></li><li>下边界 <code>bottom : matrix.length - 1</code></li><li>左边界 <code>left : 0</code></li><li>右边界 <code>right : matrix[0].length - 1</code></li></ul><p><strong>矩阵不一定是方阵</strong></p><p><code>top &lt; bottom &amp;&amp; left &lt; right</code> 是循环的条件</p><p>无法构成“环”了，就退出循环，退出时可能是这4种情况之一：</p><ul><li><code>top == bottom &amp;&amp; left &lt; right</code> —— 剩一行</li><li><code>top &lt; bottom &amp;&amp; left == right</code> —— 剩一列</li><li><code>top == bottom &amp;&amp; left == right</code> —— 剩一项（也算 一行/列）</li><li><code>top &gt;bottom || left &gt; right</code>——什么都不剩</li></ul><p><strong>处理剩下的单行或单列</strong></p><p>因为是按顺时针推入结果数组的，所以</p><ul><li>剩下的一行，<strong>从左至右</strong>依次推入结果数组</li><li>剩下的一列，<strong>从上至下</strong> 依次推入结果数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spiralOrder = <span class="function"><span class="params">matrix</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length === <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="comment">// 四个边界</span></span><br><span class="line">    <span class="keyword">let</span> top=<span class="number">0</span>,</span><br><span class="line">        bottom=matrix.length-<span class="number">1</span>,</span><br><span class="line">        left=<span class="number">0</span>,</span><br><span class="line">        right=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    <span class="keyword">while</span>(top &lt; bottom &amp;&amp; left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=left;i&lt;right;i++) res.push(matrix[top][i]);<span class="comment">//上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=top;i&lt;bottom;i++) res.push(matrix[i][right]);<span class="comment">//右</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=right;i&gt;left;i--) res.push(matrix[bottom][i]);<span class="comment">//下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=bottom;i&gt;top;i--) res.push(matrix[i][left]);<span class="comment">//左</span></span><br><span class="line">        <span class="comment">// 四个边界同时收缩</span></span><br><span class="line">        top++;</span><br><span class="line">        bottom--;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(top === bottom)&#123;<span class="comment">// 只剩一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=left;i&lt;=right;i++) res.push(matrix[top][i]);</span><br><span class="line">    <span class="comment">// 必须写明left === right ，top !== bottom时，不一定left === right，比如只有两列</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left === right)&#123;<span class="comment">// 只剩一列 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=top;i&lt;=bottom;i++) res.push(matrix[i][left]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>换一种遍历的策略：遍历到底</p><p>循环的条件改为： <code>top &lt;= bottom &amp;&amp; left &lt;= right</code></p><ul><li>每遍历一条边，下一条边遍历的起点被“挤占”，要更新相应的边界</li><li>注意到，可能在循环途中，突然不再满足循环的条件，即top &gt; bottom或left &gt; right，其中一对边界彼此交错了</li><li>这意味着所有项都遍历完了，要break了，如果没有及时 break ，就会<strong>重复遍历</strong></li></ul><p>解决办法</p><ul><li>每遍历完一条边，更新相应的边界后，都加上一句<code>if (top &gt; bottom || left &gt; right) break;</code>，避免因没有及时退出循环而导致重复遍历。</li><li>且，“遍历完成”这个时间点，要么发生在遍历完“<strong>上边</strong>”，要么发生在遍历完“<strong>右边</strong>”</li><li>所以只需在这两步操作之后，加 <code>if (top &gt; bottom || left &gt; right) break</code> 即可</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spiralOrder = <span class="function"><span class="params">matrix</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length === <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="comment">// 四个边界</span></span><br><span class="line">    <span class="keyword">let</span> top=<span class="number">0</span>,</span><br><span class="line">        bottom=matrix.length-<span class="number">1</span>,</span><br><span class="line">        left=<span class="number">0</span>,</span><br><span class="line">        right=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> res=[];</span><br><span class="line">    <span class="keyword">while</span>(top&lt;=bottom &amp;&amp; left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=left;i&lt;=right;i++) res.push(matrix[top][i]);<span class="comment">//上</span></span><br><span class="line">        top++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=top;i&lt;=bottom;i++) res.push(matrix[i][right]);<span class="comment">//右</span></span><br><span class="line">        right--;</span><br><span class="line">        <span class="keyword">if</span> (top&gt;bottom || left&gt;right) <span class="keyword">break</span> <span class="comment">// 防止重复遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=right;i&gt;=left;i--) res.push(matrix[bottom][i]);<span class="comment">//下</span></span><br><span class="line">        bottom--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=bottom;i&gt;=top;i--) res.push(matrix[i][left]);<span class="comment">//左     </span></span><br><span class="line">        left++;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>换一种循环的条件，也是可以的</p><p>遍历完所有项时，res 数组构建完毕。我们可以用 res 数组的长度 等于 矩阵的项的个数，作为循环的结束条件</p><p>不等于就继续遍历，等于就 break</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spiralOrder = <span class="function"><span class="params">matrix</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length === <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="comment">// 四个边界</span></span><br><span class="line">    <span class="keyword">let</span> top=<span class="number">0</span>,</span><br><span class="line">        bottom=matrix.length-<span class="number">1</span>,</span><br><span class="line">        left=<span class="number">0</span>,</span><br><span class="line">        right=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> res=[],size=matrix.length*matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">while</span>(res.length !== size)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=left;i&lt;=right;i++) res.push(matrix[top][i]);<span class="comment">//上</span></span><br><span class="line">        top++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=top;i&lt;=bottom;i++) res.push(matrix[i][right]);<span class="comment">//右</span></span><br><span class="line">        right--;</span><br><span class="line">        <span class="keyword">if</span> (res.length === size) <span class="keyword">break</span> <span class="comment">// 防止重复遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=right;i&gt;=left;i--) res.push(matrix[bottom][i]);<span class="comment">//下</span></span><br><span class="line">        bottom--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=bottom;i&gt;=top;i--) res.push(matrix[i][left]);<span class="comment">//左     </span></span><br><span class="line">        left++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findKthLargest = <span class="function">(<span class="params">nums, k</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">const</span> partition = <span class="function">(<span class="params">nums, l, r</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> pivot = nums[r]; <span class="comment">// 最右边的元素作为 pivot 元素</span></span><br><span class="line">        <span class="keyword">let</span> pIndex = l;</span><br><span class="line">        <span class="comment">// 循环结束时，pIndex左边都是比pivot小的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = l;i&lt;r; i++) &#123; </span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                [nums[i],nums[pIndex]]=[nums[pIndex],nums[i]]</span><br><span class="line">                pIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pIndex和r交换，更新pivot元素</span></span><br><span class="line">        [nums[r],nums[pIndex]]=[nums[pIndex],nums[r]] </span><br><span class="line">        <span class="keyword">return</span> pIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> quick = <span class="function">(<span class="params">nums,l, r</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((r - l) / <span class="number">2</span>) + l; <span class="comment">// 选取中间</span></span><br><span class="line">        <span class="comment">// 将它和位置r的元素交换，让 nums[r] 作为 pivot 元素</span></span><br><span class="line">        [nums[mid],nums[r]]=[nums[r],nums[mid]]</span><br><span class="line">        <span class="keyword">let</span> pIndex = partition(nums, l, r);</span><br><span class="line">        <span class="keyword">if</span>(n-k&lt;pIndex) quick(nums,l, pIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(n-k&gt;pIndex) quick(nums,pIndex + <span class="number">1</span>, r);</span><br><span class="line">    &#125;;</span><br><span class="line">    quick(nums,<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums[n - k];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p><strong>回溯法</strong></p><ul><li>递归函数参数</li></ul><p><strong>首先排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合</strong>。</p><p>但排列问题需要一个used数组，标记已经选择的元素。</p><ul><li>递归终止条件</li></ul><p>当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。</p><ul><li>单层搜索的逻辑</li></ul><p>因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。</p><p><strong>而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> permute = <span class="function"><span class="params">nums</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 回溯</span></span><br><span class="line">    <span class="comment">// 关键在于每一次递归结束后都会回到上一层的递归函数</span></span><br><span class="line">    <span class="comment">// 所以，递归前处理节点，递归后撤销操作，就实现了回溯到之前状态</span></span><br><span class="line">    <span class="comment">// 注意，执行递归函数时，当前的for循环可能还没执行完</span></span><br><span class="line">    <span class="keyword">const</span> res = []; <span class="comment">// 结果</span></span><br><span class="line">    <span class="keyword">const</span> backtrack= <span class="function">(<span class="params">nums,path,used</span>)=&gt;</span>&#123;<span class="comment">// path收集元素的数组used记录使用过的元素</span></span><br><span class="line">        <span class="comment">// 终止条件 当path的大小达到和nums一样大时，说明找到了一个全排列</span></span><br><span class="line">        <span class="keyword">if</span> (path.length === nums.length )&#123;</span><br><span class="line">            <span class="comment">//拷贝后放入res，后续对path的操作，就不会影响res</span></span><br><span class="line">            res.push([...path]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[num])<span class="keyword">continue</span>;<span class="comment">//使用过的，跳过</span></span><br><span class="line">            path.push(num);<span class="comment">// 没使用过的加入path</span></span><br><span class="line">            used[num]=<span class="literal">true</span>;<span class="comment">// 标记使用</span></span><br><span class="line">            backtrack(nums,path,used);<span class="comment">// 递归</span></span><br><span class="line">            path.pop(); <span class="comment">//回溯，将最后选的数pop出来</span></span><br><span class="line">            used[num]=<span class="literal">false</span>; <span class="comment">// 撤销这个记录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(nums,[],[]);<span class="comment">//递归入口</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h3><h4 id="回溯算法，死抓三点"><a href="#回溯算法，死抓三点" class="headerlink" title="回溯算法，死抓三点"></a>回溯算法，死抓三点</h4><ul><li>选择<ul><li>在这里，每次最多两个选择，选左括号或右括号，“选择”会展开出一棵解的空间树。</li><li>用 DFS 遍历这棵树，找出所有的解，这个过程叫回溯。</li></ul></li><li>约束条件<ul><li>即，什么情况下可以选左括号，什么情况下可以选右括号。</li><li>利用约束做“剪枝”，即，去掉不会产生解的选项，即，剪去不会通往合法解的分支。<ul><li>比如<code>()</code>，现在左右括号各剩一个，再选<code>)</code>就成了<code>())</code>，不能让这个错的选择成为选项（不落入递归）：</li></ul></li></ul></li><li>目标<ul><li>构建出一个用尽 n 对括号的合法括号串。</li><li>意味着，当构建的长度达到 2*n，就可以结束递归（不用继续选了）。</li></ul></li></ul><h4 id="充分剪枝的好处"><a href="#充分剪枝的好处" class="headerlink" title="充分剪枝的好处"></a>充分剪枝的好处</h4><ul><li>经过充分剪枝，所有不会通往合法解的选项都被剪掉，只要往下递归，就都通向合法解。</li><li>即只要递归到：当构建的字符串的长度为 2*n 时，一个合法解就生成了，放心地加入解集。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generateParenthesis = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="comment">// 左右括号所剩的数量，str是当前构建的字符串</span></span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">lRemain, rRemain, str</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.length === <span class="number">2</span> * n) &#123;<span class="comment">// 字符串构建完成</span></span><br><span class="line">            res.push(str);<span class="comment">// 加入解集</span></span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">// 结束当前递归分支</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lRemain &gt; <span class="number">0</span>) &#123;<span class="comment">// 只要左括号有剩，就可以选它，然后继续做选择（递归）</span></span><br><span class="line">            dfs(lRemain - <span class="number">1</span>, rRemain, str + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lRemain &lt; rRemain) &#123;   <span class="comment">// 右括号比左括号剩的多，才能选右括号</span></span><br><span class="line">            dfs(lRemain, rRemain - <span class="number">1</span>, str + <span class="string">&quot;)&quot;</span>); <span class="comment">// 然后继续做选择（递归）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(n, n, <span class="string">&#x27;&#x27;</span>); <span class="comment">// 递归的入口，剩余数量都是n，初始字符串是空串</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p>DFS</p><ul><li>遍历遇到 1 即遇到土地，土地肯定在一个岛上，计数 +1</li><li>如果不把与它和同在一个岛的土地变成 0，则DFS遍历到它们时，会对一个岛重复计数</li></ul><p><strong>怎么找出同处一岛的所有 1</strong></p><ul><li>DFS，以当前 1 为入口</li><li>DFS 做的事情：<ul><li>将当前的 1 变 0</li><li>当前坐标的上下左右依次递归，同处一个岛的 1 都变 0</li></ul></li><li>dfs 出口：超出矩阵边界，或遇到 0。不用沉岛，直接返回</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numIslands = <span class="function"><span class="params">grid</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> turnZero=<span class="function">(<span class="params">i,j,grid</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=grid.length || j&lt;<span class="number">0</span> || j&gt;=grid[<span class="number">0</span>].length ||grid[i][j]===<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        turnZero(i,j-<span class="number">1</span>,grid);</span><br><span class="line">        turnZero(i,j+<span class="number">1</span>,grid);</span><br><span class="line">        turnZero(i-<span class="number">1</span>,j,grid);</span><br><span class="line">        turnZero(i+<span class="number">1</span>,j,grid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]===<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                turnZero(i,j,grid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a>搜索二维矩阵</h2><p>编写一个高效的算法来搜索 <code>m x n</code> 矩阵 matrix 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> searchMatrix = <span class="function">(<span class="params">matrix, target</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length===<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> [i,j]=[<span class="number">0</span>,matrix[<span class="number">0</span>].length-<span class="number">1</span>];<span class="comment">// // 初始化位置(右上角)</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;matrix.length &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][j]&gt;target)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j]&lt;target)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> searchMatrix = <span class="function">(<span class="params">matrix, target</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length===<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> [i,j]=[<span class="number">0</span>,matrix[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;matrix.length &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][j]&gt;target)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j]&lt;target)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LRU-缓存★"><a href="#LRU-缓存★" class="headerlink" title="LRU 缓存★"></a>LRU 缓存★</h2><blockquote><p>考察公司：百度</p></blockquote><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><ul><li>数据被读取了，就是被使用了，所在的位置要刷新，浮到“顶部”。</li><li>写入数据时：<ul><li>之前就存在的：更新数据，刷新位置。</li><li>之前不存在的：有位置就直接写入，没有位置，就删掉最久没有使用的条目，再写入。</li></ul></li><li>要求 get 和 put 为 O(1)，这俩操作都可能导致条目的移动(有删除操作)，所以删除操作也要是 O(1)。</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>O(1)的快速查找–哈希表。</li><li>光靠哈希表可以吗？<ul><li>哈希表是无序的，无法知道里面的键值对哪些最近访问过，哪些很久没访问。</li></ul></li><li>快速删除，谁合适？<ul><li>数组？元素的插入/移动/删除都是 O(n)。不行。</li><li>单向链表？删除节点需要访问前驱节点，只能花 O(n)从前遍历查找。不行。</li><li>双向链表，结点有前驱指针，删除/移动节点都是纯纯的指针变动，都是 O(1)。</li></ul></li></ul><h3 id="双向链表、哈希表，各自的角色"><a href="#双向链表、哈希表，各自的角色" class="headerlink" title="双向链表、哈希表，各自的角色"></a>双向链表、哈希表，各自的角色</h3><ul><li>双向链表的结点：存 key 和 对应的数据值。</li><li>哈希表的存在意义：快速访问【存储于双向链表】的数据，不是它自己存数据<ul><li>key：双向链表中存的 key</li><li>value：链表结点的引用。</li></ul></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="定义-ListNode-节点"><a href="#定义-ListNode-节点" class="headerlink" title="定义 ListNode 节点"></a>定义 ListNode 节点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.key = key     </span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.prev = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义-LRUCache"><a href="#定义-LRUCache" class="headerlink" title="定义 LRUCache"></a>定义 LRUCache</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">capacity</span>)</span> &#123;     </span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity  <span class="comment">// 容量</span></span><br><span class="line">    <span class="built_in">this</span>.hash = &#123;&#125;            <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>            <span class="comment">// 缓存数目</span></span><br><span class="line">    <span class="built_in">this</span>.dummyHead = <span class="keyword">new</span> ListNode() <span class="comment">// 虚拟头结点</span></span><br><span class="line">    <span class="built_in">this</span>.dummyTail = <span class="keyword">new</span> ListNode() <span class="comment">// 虚拟尾节点</span></span><br><span class="line">    <span class="built_in">this</span>.dummyHead.next = <span class="built_in">this</span>.dummyTail</span><br><span class="line">    <span class="built_in">this</span>.dummyTail.prev = <span class="built_in">this</span>.dummyHead <span class="comment">// 还未添加真实节点，将虚拟头尾节点相连</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设计-dummyHead-和-dummyTail-的意义"><a href="#设计-dummyHead-和-dummyTail-的意义" class="headerlink" title="设计 dummyHead 和 dummyTail 的意义"></a>设计 dummyHead 和 dummyTail 的意义</h4><ul><li>虚拟头尾节点，只是为了让对真实头尾节点的操作，和对其他节点的操作一致，方便快速访问头尾节点。</li></ul><h4 id="get-方法实现"><a href="#get-方法实现" class="headerlink" title="get 方法实现"></a>get 方法实现</h4><ul><li>哈希表中找不到对应的值，则返回 -1。被读取的节点，要刷新它的位置，移动到链表头部</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="built_in">this</span>.hash[key]      <span class="comment">// 从哈希表中，获取对应的节点</span></span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>    <span class="comment">// 如果节点不存在，返回-1</span></span><br><span class="line">  <span class="built_in">this</span>.moveToHead(node)          <span class="comment">// 被读取了，该节点移动到链表头部</span></span><br><span class="line">  <span class="keyword">return</span> node.value              <span class="comment">// 返回出节点值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>moveToHead</code>方法实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">moveToHead</span>(<span class="params">node</span>)</span> &#123;         </span><br><span class="line">  <span class="built_in">this</span>.removeFromList(node) <span class="comment">// 先从链表中删除</span></span><br><span class="line">  <span class="built_in">this</span>.addToHead(node)      <span class="comment">// 再加到链表的头部</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">removeFromList</span>(<span class="params">node</span>)</span> &#123;        </span><br><span class="line">  <span class="keyword">let</span> temp1 = node.prev     <span class="comment">// 暂存它的后继节点</span></span><br><span class="line">  <span class="keyword">let</span> temp2 = node.next     <span class="comment">// 暂存它的前驱节点</span></span><br><span class="line">  temp1.next = temp2        <span class="comment">// 前驱节点的next指向后继节点</span></span><br><span class="line">  temp2.prev = temp1        <span class="comment">// 后继节点的prev指向前驱节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">addToHead</span>(<span class="params">node</span>)</span> &#123;                 <span class="comment">// 插入到虚拟头结点和真实头结点之间</span></span><br><span class="line">  node.prev = <span class="built_in">this</span>.dummyHead      <span class="comment">// node的prev指针，指向虚拟头结点</span></span><br><span class="line">  node.next = <span class="built_in">this</span>.dummyHead.next <span class="comment">// node的next指针，指向原来的真实头结点</span></span><br><span class="line">  <span class="built_in">this</span>.dummyHead.next.prev = node <span class="comment">// 原来的真实头结点的prev，指向node</span></span><br><span class="line">  <span class="built_in">this</span>.dummyHead.next = node      <span class="comment">// 虚拟头结点的next，指向node</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="put-方法实现"><a href="#put-方法实现" class="headerlink" title="put 方法实现"></a>put 方法实现</h4><ul><li>写入新数据，要先检查容量，看看是否要删“老家伙”，然后创建新的节点，添加到链表头部(最不优先被淘汰)，哈希表也更新一下。</li><li>写入已有的数据，则更新数据值，刷新节点的位置。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">put</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="built_in">this</span>.hash[key]            <span class="comment">// 获取链表中的node</span></span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;                  <span class="comment">// 不存在于链表，是新数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.count == <span class="built_in">this</span>.capacity) &#123; <span class="comment">// 容量已满</span></span><br><span class="line">      <span class="built_in">this</span>.removeLRUItem()             <span class="comment">// 删除最远一次使用的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> newNode = <span class="keyword">new</span> ListNode(key, value) <span class="comment">// 创建新的节点</span></span><br><span class="line">    <span class="built_in">this</span>.hash[key] = newNode          <span class="comment">// 存入哈希表</span></span><br><span class="line">    <span class="built_in">this</span>.addToHead(newNode)           <span class="comment">// 将节点添加到链表头部</span></span><br><span class="line">    <span class="built_in">this</span>.count++                      <span class="comment">// 缓存数目+1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                   <span class="comment">// 已经存在于链表，老数据</span></span><br><span class="line">    node.value = value       <span class="comment">// 更新value</span></span><br><span class="line">    <span class="built_in">this</span>.moveToHead(node)    <span class="comment">// 将节点移到链表头部</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>removeLRUItem</code> 方法实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">removeLRUItem</span>(<span class="params"></span>)</span> &#123;               <span class="comment">// 删除“老家伙”</span></span><br><span class="line">  <span class="keyword">let</span> tail = <span class="built_in">this</span>.popTail()     <span class="comment">// 将它从链表尾部删除</span></span><br><span class="line">  <span class="keyword">delete</span> <span class="built_in">this</span>.hash[tail.key]    <span class="comment">// 哈希表中也将它删除</span></span><br><span class="line">  <span class="built_in">this</span>.count--                  <span class="comment">// 缓存数目-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">popTail</span>(<span class="params"></span>)</span> &#123;                      <span class="comment">// 删除链表尾节点</span></span><br><span class="line">  <span class="keyword">let</span> tail = <span class="built_in">this</span>.dummyTail.prev <span class="comment">// 通过虚拟尾节点找到它</span></span><br><span class="line">  <span class="built_in">this</span>.removeFromList(tail)      <span class="comment">// 删除该真实尾节点</span></span><br><span class="line">  <span class="keyword">return</span> tail                    <span class="comment">// 返回被删除的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.key = key</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.prev = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">capacity</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity</span><br><span class="line">    <span class="built_in">this</span>.hash = &#123;&#125;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span></span><br><span class="line">    <span class="built_in">this</span>.dummyHead = <span class="keyword">new</span> ListNode()</span><br><span class="line">    <span class="built_in">this</span>.dummyTail = <span class="keyword">new</span> ListNode()</span><br><span class="line">    <span class="built_in">this</span>.dummyHead.next = <span class="built_in">this</span>.dummyTail</span><br><span class="line">    <span class="built_in">this</span>.dummyTail.prev = <span class="built_in">this</span>.dummyHead</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="built_in">this</span>.hash[key]</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="built_in">this</span>.moveToHead(node)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">put</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="built_in">this</span>.hash[key]</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.count == <span class="built_in">this</span>.capacity) &#123;</span><br><span class="line">        <span class="built_in">this</span>.removeLRUItem()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> newNode = <span class="keyword">new</span> ListNode(key, value)</span><br><span class="line">      <span class="built_in">this</span>.hash[key] = newNode</span><br><span class="line">      <span class="built_in">this</span>.addToHead(newNode)</span><br><span class="line">      <span class="built_in">this</span>.count++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.value = value</span><br><span class="line">      <span class="built_in">this</span>.moveToHead(node)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">moveToHead</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.removeFromList(node)</span><br><span class="line">    <span class="built_in">this</span>.addToHead(node)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">removeFromList</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temp1 = node.prev</span><br><span class="line">    <span class="keyword">let</span> temp2 = node.next</span><br><span class="line">    temp1.next = temp2</span><br><span class="line">    temp2.prev = temp1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">addToHead</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    node.prev = <span class="built_in">this</span>.dummyHead</span><br><span class="line">    node.next = <span class="built_in">this</span>.dummyHead.next</span><br><span class="line">    <span class="built_in">this</span>.dummyHead.next.prev = node</span><br><span class="line">    <span class="built_in">this</span>.dummyHead.next = node</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">removeLRUItem</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tail = <span class="built_in">this</span>.popTail()</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.hash[tail.key]</span><br><span class="line">    <span class="built_in">this</span>.count--</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">popTail</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tail = <span class="built_in">this</span>.dummyTail.prev</span><br><span class="line">    <span class="built_in">this</span>.removeFromList(tail)</span><br><span class="line">    <span class="keyword">return</span> tail</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子集★"><a href="#子集★" class="headerlink" title="子集★"></a>子集★</h2><blockquote><p>考察公司：华为</p></blockquote><p>集合所有子集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> subsets = <span class="function">(<span class="params">nums</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [[]],len1=nums.length</span><br><span class="line">    <span class="comment">// 外层遍历所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;len1;i++) &#123;</span><br><span class="line">        <span class="comment">// 记录上一个元素加入后集合子集个数</span></span><br><span class="line">        <span class="keyword">let</span> len2 = arr.length </span><br><span class="line">        <span class="comment">// 内层遍历之前存入的所有子集，并在每个子集添加当前元素</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;len2;j++)&#123;</span><br><span class="line">        arr.push(arr[j].concat(nums[i]))</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> subsets = <span class="function">(<span class="params">nums</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">const</span> traversal = <span class="function">(<span class="params">nums,arr,level</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level === nums.length)&#123;</span><br><span class="line">            res.push(arr)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        traversal(nums,arr,level+<span class="number">1</span>)</span><br><span class="line">        traversal(nums,arr.concat(nums[level]),level+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    traversal(nums,[],<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重复字母压缩★"><a href="#重复字母压缩★" class="headerlink" title="重复字母压缩★"></a>重复字母压缩★</h2><blockquote><p>考察公司：华为</p></blockquote><p>xxxyyyyyyz”压缩后就成为”2x5yz”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;xxxyyyzzcc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> a1 = []; <span class="comment">//定义空数组存放字符</span></span><br><span class="line"><span class="keyword">var</span> a2 = []; <span class="comment">//定义空数组存放字符个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">	<span class="keyword">var</span> ch = str[i]; <span class="comment">//得到每一个字符</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果当前字符与数组最后一个字符相等</span></span><br><span class="line">	<span class="keyword">if</span> (ch == a1[a1.length - <span class="number">1</span>]) &#123;</span><br><span class="line">		a2[a2.length - <span class="number">1</span>]++;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		a1.push(ch);</span><br><span class="line">		a2[a2.length] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a1--&gt;[x,y,z,c]</span></span><br><span class="line"><span class="comment">// a2--&gt;[3,3,2,2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&quot;&quot;</span>; <span class="comment">//定义空字符串，存放新字符串</span></span><br><span class="line"><span class="comment">//循环拼接</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a1.length; i++) &#123;</span><br><span class="line">	str2 = str2 + a2[i] + a1[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//去掉1</span></span><br><span class="line">str2 = str2.split(<span class="string">&quot;1&quot;</span>).join(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.write(str2);</span><br></pre></td></tr></table></figure><h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45629285/article/details/111146240">https://blog.csdn.net/weixin_45629285/article/details/111146240</a></p><h3 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a>和为 K 的子数组</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41329791/article/details/122364166">https://blog.csdn.net/qq_41329791/article/details/122364166</a></p><h1 id="计算机网络和浏览器"><a href="#计算机网络和浏览器" class="headerlink" title="计算机网络和浏览器"></a>计算机网络和浏览器</h1><h2 id="计算机网络体系结构★"><a href="#计算机网络体系结构★" class="headerlink" title="计算机网络体系结构★"></a>计算机网络体系结构★</h2><blockquote><p>考察公司：美团、华为</p></blockquote><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p><strong>物理层（Physical Layer）</strong></p><ul><li><p>网路的物理层面确保原始的数据可在各种物理媒体上传输。</p></li><li><p>功能</p><ul><li>为数据端设备提供传送数据通路</li><li>传输数据</li></ul></li><li><p>设备：</p><ul><li>光纤、CAT-5/6/7线 <strong>双绞线</strong></li><li>RJ-45接头 双绞线与网卡，双绞线与集线器的接口，俗称<strong>水晶头</strong>。</li><li>集线器 Ethernet <strong>hub</strong></li><li>串口 Universal Serial Bus（通用串行总线）、并口</li></ul></li></ul><p><strong>数据链路层（Data Link Layer）</strong></p><ul><li><p>在广播式多路访问链路中（局域网），由于可能存在介质争用，它还可以细分成介质访问控制（MAC）子层和逻辑链路控制（LLC）子层，介质访问控制（MAC）子层专职处理介质访问的争用与冲突问题。</p></li><li><p>功能</p><ul><li><p>在两个网络实体之间提供数据链路连接的创建、维持和释放管理。构成数据链路数据单元（frame：数据帧或帧），并对帧定界、同步、收发顺序的控制。并且包括传输过程中的网络流量控制、差错检测和差错控制等方面。</p></li><li><p>只提供导线的一端到另一端（本质是点到点）的数据传输。</p></li><li><p>数据链路层会在 frame 尾端置放检查码（parity，sum，CRC）以检查实质内容，将物理层提供的可能出错的物理连接改造成逻辑上无差错的数据链路，并对物理层的原始数据进行数据封装。</p></li><li><p>数据链路层中的数据封装是指：封装的数据信息中，包含了地址段和数据段等。地址段含有点对点]发送节点和接收节点的地址（如MAC），控制段用来表示数格连接帧的类型，数据段包含实际要传输的数据。</p></li></ul></li><li><p>协议：<strong>点对点协议</strong>（英语：<strong>P</strong>oint-to-<strong>P</strong>oint <strong>P</strong>rotocol，缩写：<strong>PPP</strong>）、以太网Ethernet（IEEE 802.3）、Wi-Fi（IEEE 802.11）</p></li><li><p>设备：</p><ul><li>网卡（物理层和数据链路层的MAC子层）</li><li>交换机是本层设备。而集线器是物理层设备，不是数据链路层设备。</li><li>桥接器（又称网桥）</li></ul></li></ul><p><strong>网络层（Network Layer）</strong></p><ul><li><p>提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。相当于发送邮件时需要地址一般重要。由于TCP/IP协议体系中的网络层功能由IP协议规定和实现，故又称IP层。</p></li><li><p><strong>功能</strong></p><ul><li>寻址：对网络层而言使用IP地址来唯一标识互联网上的各个寻址，网络层依靠IP地址进行相互通信（类似于MAC地址）。</li><li>路由：在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间相互通信则必须借助路由器等三层设备。</li></ul></li><li><p><strong>虚电路和数据报网络</strong></p><ul><li>在传输层每个应用可以被提供两个服务：无连接的UDP和有链接的TCP，在网络层也能为主机之间提供无连接和有链接的服务。</li></ul><ul><li>在网络层中这些服务（无论是有链接还是无连接）都是提供<strong>主机到主机</strong>的服务，在传输层中提供的则是提供<strong>应用层进程</strong>之间的服务。</li><li>在至今为止的所有的主要计算机网络结构体系中（因特网、ATM、帧中继等），网络层提供了主机到主机无连接或者有连接服务，而不同时提供两种服务。仅提供无连接的的网络称为数据报网络(Datagram Network)，仅提供有连接的网络称为虚电路网络（Virtual-Circuit，VC）。</li></ul></li><li><p><strong>协议</strong>：IP （V4、V6）、ICMP（V4、V6）、OSPF</p></li><li><p><strong>设备</strong>：路由器、三层交换机（具有部分路由器功能的交换机）</p></li></ul><p><strong>传输层（英语：Transport Layer）</strong></p><ul><li><p>该层的协议为应用进程提供端到端的通信服务。</p></li><li><p>最著名的TCP/IP传输协议是传输控制协议（TCP）, 它的名称借用自整个包的名称。它用于面向连接的传输，而无连接的用户数据报协议（UDP）用于简单消息传输。TCP是更复杂的协议，因为它的状态性设计结合了可靠传输和数据流服务。这个协议组中其他重要协议有数据拥塞控制协议（DCCP）与流控制传输协议（SCTP）。<br><a target="_blank" rel="noopener" href="https://imgse.com/i/x12dYR"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/10/06/x12dYR.png" alt="x12dYR.png"></a></p></li></ul><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p><a target="_blank" rel="noopener" href="https://imgse.com/i/x12ak9"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/10/06/x12ak9.png" alt="x12ak9.png"></a></p><p><strong>TCP/IP</strong>体系结构相当于将<strong>OSI</strong>体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p><p>教学时经常把TCP/IP体系结构的<strong>网络接口层</strong>分成了<strong>物理层</strong>和<strong>数据链路层</strong>。</p><ul><li><p><strong>应用层，负责向用户提供一组应用程序</strong></p><ul><li>HTTP 协议（超文本传输协议，网页浏览常用的协议）</li><li>DHCP 协议（动态主机配置）</li><li>DNS 系统原理（域名系统）</li><li>FTP 协议（文件传输协议）</li><li>Telnet协议（远程登陆协议）</li><li>电子邮件协议等（SMTP、POP3、IMAP）</li></ul></li><li><p><strong>传输层，负责端到端的通信，比如 TCP、UDP 等</strong>；</p></li><li><p><strong>网络层，负责网络包的封装、分片、路由、转发</strong></p><ul><li>IP 协议（TCP/IP 协议的基础，分为 IPv4 和 IPv6）</li><li>ARP 协议（地址解析协议，用于解析 IP 地址和 MAC 地址之间的映射）</li><li>ICMP 协议（控制报文协议，用于发送控制消息）</li><li>NAT 协议（网络地址转换协议）</li><li>RIP 协议、OSPF 协议、BGP 协议（路由选择协议）</li></ul></li><li><p><strong>网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等</strong>；</p><ul><li>差错检测技术</li><li>多路访问协议（信道复用技术）</li><li>CSMA/CD 协议</li><li>MAC 协议</li><li>以太网技术</li></ul></li></ul><h3 id="为什么网络要分层？"><a href="#为什么网络要分层？" class="headerlink" title="为什么网络要分层？"></a>为什么网络要分层？</h3><ul><li><strong>各层之间相互独立</strong></li><li><strong>提高了整体灵活性</strong> 高内聚，低耦合</li><li><strong>大问题化小</strong></li></ul><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><ul><li>两台电脑可以通过一根<strong>网线</strong>直接连接，进行通信。</li><li>机器一多，可以把网线都接到<strong>集线器</strong>（<strong>物理层</strong>）上，但是集线器会不管三七二十一进行<strong>广播</strong>。</li><li>不想广播，可以用（二层）<strong>交换机</strong>（<strong>数据链路层</strong>），又叫多端口网桥，它比较聪明，会自我学习生产<strong>MAC地址表</strong>，知道消息发到哪，那就<strong>不需要广播</strong>啦。</li><li><strong>互联网</strong>电脑这么多，交换机MAC地址表总不能全放下吧。改用<strong>路由器</strong>（<strong>网络层</strong>），也叫<strong>三层交换机</strong>，通过网段的方式定位要把消息转发到哪，就不需要像交换机那样苦哈哈一条条记录MAC地址啦（具有<strong>MAC地址</strong>和<strong>IP地址</strong>）。</li><li>路由器和光猫之间是好搭档，<strong>光猫</strong>负责把光纤里的光信号转换成电信号给路由器。</li><li>现在一般情况下，家里已经不用集线器和交换机了，<strong>大部分路由器也支持交换机的功能</strong>。所以可以看到，家里的台式机电脑一般就连到一个路由器，再连个光猫就够能快乐上网了。</li></ul><h2 id="URL输入到页面展现★"><a href="#URL输入到页面展现★" class="headerlink" title="URL输入到页面展现★"></a>URL输入到页面展现★</h2><blockquote><p>考察公司：字节、美团、百度、腾讯</p></blockquote><p>总体来说分为以下几个过程:</p><ul><li>浏览器查找当前URL是否存在<strong>缓存</strong>，并比较缓存是否过期。（先判断HTTP请求浏览器是否已缓存）<ul><li><strong>有缓存</strong><ul><li>如为<strong>强制缓存</strong>，通过<code>Expires</code>或<code>Cache-Control：max-age</code>判断该缓存是否过期，未过期，直接使用该资源；Expires和max-age，如果两者同时存在，则被Cache-Control的max-age覆盖。</li><li>如为<strong>协商缓存</strong>，请求头部带上相关信息如<code>if-none-match（Etag）</code>与<code>if-modified-since(last-modified)</code>，验证缓存是否有效，若有效则返回状态码为<code>304</code>，若无效则重新返回资源，状态码为<code>200</code></li></ul></li></ul></li></ul><ul><li><p><strong>解析URL并生成HTTP请求报文</strong></p></li><li><p><strong>DNS 解析</strong>：将<strong>域名</strong>解析成<strong>IP地址</strong></p></li><li><p><strong>TCP 三次握手</strong>建立连接、<strong>TLS三次握手</strong> =》在<strong>HTTPS</strong>上建立安全连接</p></li><li><p>将HTTP报文添加TCP头部（源、目标端口、序号、窗口大小和状态位）生成<strong>TCP报文</strong></p></li><li><p>添加<strong>IP包头</strong>（源、目标IP）和<strong>MAC包头</strong>（收发MAC地址）将数据封装成<strong>网络包</strong></p></li><li><p><strong>网卡驱动</strong>从IP模块获取到包之后，再次封装。</p></li><li><p><strong>网卡</strong>会将包转为<strong>电信号</strong>（光纤传输的话可能还有电光转换）。</p></li><li><p>网络包经过<strong>交换机</strong>和<strong>路由器</strong>转发到达<strong>服务器</strong></p></li><li><p>服务器将<strong>MAC、IP、TCP、HTTP头部一层层解析处理</strong>，<strong>将网页放入HTTP响应报文中</strong>，<strong>穿上TCP、IP、MAC头部返回</strong></p></li><li><p>浏览器拿到HTTP响应报文后，将<strong>HTML和CSS解析出DOM 树和 CSS 规则树</strong>（<strong>CSSOM</strong>），两者生成<strong>渲染树</strong>，之后进行<strong>页面布局与绘制</strong></p><ul><li>如果遇到 script 标签，则判断是否含有 <code>defer</code> 或者 <code>async</code> 属性，如果有，异步去下载该资源；如果没有设置，暂停dom的解析，去加载script的资源，然后执行该js代码（<strong>script标签加载和执行会阻塞页面的渲染</strong>）</li></ul></li><li><p>断开TCP连接 ：<strong>TCP四次挥手</strong></p></li></ul><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>统一资源定位符，URI是统一资源标志符</p><p><strong>URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</strong></p><p>URL遵守以下的语法规则：<code>scheme://host.domain:port/path/filename</code></p><ul><li><strong>scheme</strong> - 定义因特网服务的类型。常见的协议有 <strong>http、https、ftp、file</strong>，其中最常见的类型是 http，而 <strong>https 则是进行加密的网络传输</strong>。</li><li><strong>host</strong> - 定义域主机（http 的默认主机是 <strong>www</strong>）</li><li><strong>domain</strong> - 定义因特网<strong>域名</strong>，比如 <code>w3school.com.cn</code></li><li><strong>port</strong> - 定义主机上的<strong>端口号</strong>（http 的默认端口号是 80）</li><li><strong>path</strong> - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</li><li><strong>filename</strong> - 定义文档/资源的名称</li></ul><p>当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是<code>/index.html</code>或者<code>/default.html</code>这些文件，这样就不会发生混乱了。</p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>委托操作系统将消息发送给Web服务器，<strong>需要查询服务器域名对应的IP地址。</strong></p><p>DNS服务器就<strong>专门保存了Web服务器域名与IP的对应关系</strong>。</p><p><strong>查询过程</strong></p><ul><li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li><li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器<strong>缓存</strong>中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li><li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li><li>本地DNS服务器向<strong>顶级域名服务器（.com）</strong>发送请求，返回相关的下一级的权威域名服务器的地址</li><li>本地DNS服务器向**权威域名服务器(.baidu.com)**发送请求，域名服务器返回对应的结果(<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>)</li><li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li><li>本地DNS服务器将返回结果返回给浏览器</li></ul><p>DNS解析是一个包含<strong>迭代</strong>查询和<strong>递归</strong>查询的过程。</p><ul><li>一般<strong>我们向本地 DNS 服务器</strong>发送请求的方式就是<strong>递归查询</strong>，因为我们只需要发出<strong>一次请求</strong>，然后<strong>本地 DNS 服务器返回给我们最终的请求结果</strong>。</li><li>而<strong>本地 DNS 服务器向其他域名服务器</strong>请求的过程是<strong>迭代查询</strong>的过程，因为<strong>每一次域名服务器只返回单次查询的结果，下一级的查询由本地 DNS 服务器自己进行</strong>。</li></ul><p><strong>DNS预解析</strong></p><p>DNS Prefetch 是一种DNS 预解析技术，当你浏览网页时，浏览器会在对网页中的域名进行解析缓存，这样当页面中需要加载该域名的资源时就无需解析，减少用户等待时间，提高用户体验。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//hhh.images.test.com.cn&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="TCP三次握手-★"><a href="#TCP三次握手-★" class="headerlink" title="TCP三次握手 ★"></a>TCP三次握手 ★</h3><p>TCP连接的建立，通常称为三次握手。</p><p>这个所谓的「连接」，只是双方计算机里<strong>维护一个状态机</strong>。</p><p><strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小，称为连接。</strong></p><ul><li><strong>Socket</strong>:由<strong>IP地址</strong>和<strong>端口号</strong>组成</li><li><strong>序列号</strong>:用来解决乱序问题等</li><li><strong>窗口大小</strong>:用来做流量控制</li></ul><p><strong>三次握手</strong></p><ul><li>一开始，客户端和服务端都处于关闭状态。先是服务端<strong>主动监听某个端口</strong>。</li><li>客户端把第一个发送报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，其中包含<strong>客户端序列号</strong>（<code>client_isn</code> ），并且<code>SYN</code> 标志位置为<code>1</code>。</li><li>服务端收到客户端的<code>SYN</code>报文后，发送应答报文给客户端，该报文也不包含应用层数据，包含<strong>服务端序列号</strong>（<code>server_isn</code>）、<strong>确认序列</strong>（<code>client_isn +1</code>）、并且<code>SYN</code>和<code>ACK</code>置1。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，其中包含<strong>确认序列</strong>（<code>server_isn +1</code>），并且<code>ACK</code>置1。这次报文<strong>可以携带客户到服务器的数据</strong>，之后客户端处于建立连接状态。</li><li>服务器收到客户端的应答报文后，也进入建立连接状态。</li></ul><p><strong>为什么三次？</strong></p><p><strong>因为三次握手才能保证双方具有接收和发送的能力</strong>。</p><p><strong>序列号能够保证数据包不重复、不丢弃和按序传输。</strong></p><p><strong>通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。</strong></p><p>不使用<strong>两次握手</strong>和<strong>四次握手</strong>的原因:</p><ul><li>两次握手︰<strong>无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号</strong>;</li><li>四次握手︰三次握手就已经<strong>理论上最少可靠连接建立</strong>，所以不需要使用更多的通信次数。</li></ul><h3 id="TCP四次挥手-★"><a href="#TCP四次挥手-★" class="headerlink" title="TCP四次挥手 ★"></a>TCP四次挥手 ★</h3><p><strong>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</strong></p><ul><li>客户端打算关闭连接，此时会发送<code>FIN</code>报文（<code>FIN</code>置1），之后客户端进入<code>FIN_WAIT_1</code>状态。</li><li>服务端收到该报文后，就向客户端发送<code>ACK</code>应答报文，接着服务端进入<code>CLOSED_WAIT</code>状态；客户端收到服务端的<code>ACK</code>应答报文后，之后进入<code>FIN_WAIT_2</code>状态。</li><li>等待<strong>服务端处理完数据后</strong>，也向客户端发送<code>FIN</code> 报文，之后服务端进入<code>LAST_ACK</code>状态。</li><li>客户端收到服务端的<code>FIN</code> 报文后，回一个<code>ACK</code>应答报文，之后进入<code>TIME_WAIT</code>状态。</li><li>服务器收到了<code>ACK</code>应答报文后，就完成连接的关闭。</li><li>客户端在经过<code>2MSL</code>一段时间后，自动进入关闭状态。</li></ul><p><strong>主动关闭连接的，才有TIME_WAIT状态</strong>。</p><p><strong>为什么挥手需要四次</strong>?</p><p>再来回顾下四次挥手双方发FIN 包的过程，就能理解为什么需要四次了。</p><ul><li>关闭连接时，客户端向服务端发送<code>FIN</code> 时，仅仅表示<strong>客户端不再发送数据了但是还能接收数据</strong>。</li><li>服务器收到客户端的<code>FIN</code>报文时，先回一个<code>ACK</code>应答报文，而服务端可能还有数据需要处理和发送，等<br>服务端不再发送数据时，才发送<code>FIN</code>报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，<strong>服务端通常需要等待完成数据的发送和处理</strong>，所以服务端的<code>ACK</code>和 <code>FIN</code>一般都会分开发送，从而比三次握手导致多了一次。</p><p><code>MSL</code>是<code>Maximum Segment Lifetime</code>，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><ul><li>保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，如果服务端没有收到，服务端会重发一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</li><li>防止“已经失效的连接请求报文段”出现在本连接中</li></ul><p>客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的所产生的所有报文都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><p>经过<code>2MSL</code>这个时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><p><code>TIME-WAIT</code>更重要的作用是<strong>等待足够的时间以确保最后的ACK能让被动关闭方接收，从而帮助其正常关闭</strong>。</p><h2 id="性能优化★"><a href="#性能优化★" class="headerlink" title="性能优化★"></a>性能优化★</h2><blockquote><p>考察公司：字节、美团、百度、腾讯</p></blockquote><p>因为页面自身还是在 GitHub Pages 托管，有时候首个请求还是会挺久才返回。</p><h3 id="性能检测"><a href="#性能检测" class="headerlink" title="性能检测"></a>性能检测</h3><ul><li><p><code>Network</code>面板是一个常被用到的工具，通过它可以<strong>获取到网站所有资源的请求情况</strong>，包括<strong>加载时间</strong>，<strong>资源大小</strong>，优先级设置、<strong>瀑布图</strong>以及<code>HTTP</code>缓存等信息。可以帮助开发者发现可能由于未进行有效压缩而导致资源尺寸过大的问题，未配置缓存策略导致二次请求加载时间过长的问题。</p></li><li><p><code>Lighthouse</code>是谷歌开发并开源的<code>web</code>性能测试工具，用于改进网络应用的质量，可以将其作为一个<code>Chrome</code>扩展程序运行，或从命令行运行。在浏览器的调试工具中默认就存在<code>lighthouse</code>选项，只需要切换至<code>lighthouse</code>，在右侧的选项区选中需要的选项。点击生成报告。</p></li><li><p>使用<code>Performance</code>面板主要对网站应用的运行时性能表现进行检测和分析，包括页面的每秒帧数，<code>CPU</code>的消耗和各种请求花费的时间。</p></li></ul><h3 id="如何保证资源更快的加载速度？"><a href="#如何保证资源更快的加载速度？" class="headerlink" title="如何保证资源更快的加载速度？"></a>如何保证资源更快的加载速度？</h3><h4 id="使用-dns-prefetch-减少-DNS-的查询时间"><a href="#使用-dns-prefetch-减少-DNS-的查询时间" class="headerlink" title="使用 dns-prefetch 减少 DNS 的查询时间"></a>使用 <code>dns-prefetch</code> 减少 DNS 的查询时间</h4><p><code>dns-prefetch</code> 能够 <strong>提前解析</strong> 后续可能会用到的 <strong>不同域的域名</strong>，使解析结果 <strong>缓存到系统缓存</strong> 中，缩短 <code>DNS</code> 解析时间以提高网站的访问速度。</p><h4 id="使用-preconnect-提前建立连接"><a href="#使用-preconnect-提前建立连接" class="headerlink" title="使用 preconnect 提前建立连接"></a>使用 <code>preconnect</code> 提前建立连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preconnect` 的作用是提前和第三方资源建立连接，设置了它浏览器就会做好早期的连接工作，但这个连接通常只会维持 `10 s</span><br></pre></td></tr></table></figure><h4 id="压缩资源体积"><a href="#压缩资源体积" class="headerlink" title="压缩资源体积"></a>压缩资源体积</h4><h5 id="HTTP-压缩"><a href="#HTTP-压缩" class="headerlink" title="HTTP 压缩"></a>HTTP 压缩</h5><p>HTTP 压缩中一个典型代表就是 <code>gzip</code>，它是一种优秀的压缩算法，可对 <code>http</code> 请求中的一些文件资源进行压缩处理，一般来讲是要在服务端处理的，可通过在响应头中设置 <code>Content-encoding: gzip</code> 表示当前资源使用的压缩方式（如：<code>gzip、deflate、br</code> 等），便于客户端使用正确的方式解压。</p><h5 id="Webpack-压缩"><a href="#Webpack-压缩" class="headerlink" title="Webpack 压缩"></a>Webpack 压缩</h5><p><strong>有 <code>HTTP</code> 压缩 不就够了吗？为什么还需要 <code>Webpack</code> 压缩？</strong></p><p>首先必须要明确的是压缩的过程本身就是会消耗时间的，如果所有资源都等到被访问的时候再由服务端进行压缩，在压缩完成之前客户端还是得处于等待状态，即仍 <strong>不能保证资源以最快的速度到达客户端</strong>。</p><p>那么优化方案就是将压缩资源的时间放到打包构建中，毕竟只有真正需要发布线上生产环境时才需要执行一系列的打包优化的操作，而这相比于 <strong><code>http</code></strong> 的 <strong>请求/响应</strong> 速度，稍微延长产物打包时间没有什么大问题。</p><p>下面会列举一些 <strong>Webpack</strong> 插件，但并不会去讲其中的具体用法，因为这些只是达到目的的不同方案而已，每个方案要是细讲都可以独占一篇文章，在这是没有必要的，具体用法可自行查阅。</p><blockquote><p><strong>使用 <code>CompressionPlugin</code> 压缩文件</strong></p></blockquote><p><strong><code>webpack</code> 文档</strong>提供插件合集中就包含了该插件，它的作用就是：**<code>Prepare compressed versions of assets to serve them with Content-Encoding.</code>**</p><blockquote><p><strong>使用 <code>HtmlWebpackPlugin</code> 压缩 <code>HTML</code> 文件</strong></p></blockquote><p>通常我们需要 <a href="https://link.juejin.cn/?target=https://github.com/jantimon/html-webpack-plugin"><strong><code>HtmlWebpackPlugin</code></strong></a> 插件来生成对应 <code>HTML</code> 或 对已有的 <code>HTML</code> 模板自动注入 <code>webpack bundles</code> 资源，除此之外，它还可配置 <code>minify</code> 选项实现压缩模板的目的。</p><blockquote><p><strong>使用 <code>SplitChunksPlugin</code> 自定义分包策略</strong></p></blockquote><p><code>Webpack</code> 默认会将尽可能多的模块代码打包在一起，这种默认规则的带来的优点和缺点都很明显:</p><ul><li>优点：<strong>能减少最终页面的 <code>HTTP</code> 请求数</strong></li><li>缺点：<ul><li><strong>页面初始代码包过大，影响首屏渲染性能</strong></li><li><strong>无法有效应用浏览器缓存</strong></li></ul></li></ul><p>**<code>SplitChunksPlugin</code>**是 <code>Webpack 4</code> 之后内置实现的最新分包方案，与 <code>Webpack 3</code> 中的 <code>CommonsChunkPlugin</code> 相比，它能够基于一些更灵活、合理的启发式规则将 <code>Module</code> 编排进不同的 <code>Chunk</code>，最终构建出 <strong>性能更佳、缓存更友好</strong> 的应用产物。</p><blockquote><p><strong>使用 <code>MiniCssExtractPlugin</code> 抽离和压缩 <code>CSS</code></strong></p></blockquote><p>**<code>MiniCssExtractPlugin</code>**会将 <code>CSS</code> 提取到单独的文件中，为每个包含 <code>CSS</code> 的 <code>JS</code> 文件创建一个 <code>CSS</code> 文件，并且支持 <code>CSS</code> 和 <code>SourceMaps</code> 的 <strong>按需加载</strong> 。</p><blockquote><p><strong>使用 <code>ImageMinimizerWebpackPlugin</code> 压缩图片资源</strong></p></blockquote><p>图片仍是一个 <code>Web</code> 应用中的必不可少的资源，而图片资源的体积也是首屏页面加载的瓶颈之一，因此，压缩图片也是性能优化需要考虑的内容。</p><p><strong><code>ImageMinimizerWebpackPlugin</code></strong> 可用于使用 <strong>优化/压缩</strong> 所有图像，它可以支持 <strong>无损（不损失质量）</strong>、<strong>有损（质量下降）</strong> 两种模式的压缩方式。</p><blockquote><p><strong>通过 <code>Tree Shaking</code> 移除无用代码</strong></p></blockquote><p><a href="https://link.juejin.cn/?target=https://webpack.docschina.org/guides/tree-shaking/%23root"><strong><code>Tree Shaking</code></strong></a> 依赖于 <code>ES6</code> 模块语法的 <strong>静态结构</strong> 特性（如： <code>import</code>和 <code>export</code>），当 <code>webpack</code> 的模式 <code>mode</code> 为 <code>&quot;production&quot;</code> 时，就可以启用 <strong>更多优化项</strong>，包括 <strong>压缩代码</strong> 与 <strong>Tree Shaking</strong>。</p><p>但同时我们就必须保证：</p><ul><li>尽量使用 <code>ES6</code> 模块语法，即 <code>import</code> 和 <code>export</code></li><li>保证没有 <strong>编译器</strong>（如：<code>babel</code>）将对应的 <code>ES6</code> 模块语法转换为 <code>CommonJS</code> 的语法（如：<code>@babel/preset-env</code> 的默认行为）</li><li>可在项目的 <code>package.json</code> 文件中添加 <code>&quot;sideEffects&quot;</code> 属性，标识当前内容是否存在副作用操作</li><li>可在通过 <code>/*#__PURE__*/</code> 注释，将函数调用标记为无副作用</li></ul><h4 id="减少-http-请求数量"><a href="#减少-http-请求数量" class="headerlink" title="减少 http 请求数量"></a>减少 http 请求数量</h4><p><strong>不同协议</strong> 下 <strong>请求数量</strong> 仍然可能成为 <strong>请求/响应</strong> 慢的原因：</p><ul><li>合并公共资源，如 雪碧图 等</li><li>内置模块资源，如 生成 <code>base64</code> 图片、通过 <code>symbol</code> 引用 <code>svg</code> 等</li><li>合并代码块，如构建工具分包策略配合公共组件封装、组件复用逻辑抽离 等</li><li>按需加载资源，如 路由懒加载、图片懒加载、上拉加载、分页加载 等</li></ul><h5 id="webpack对图片资源进行优化"><a href="#webpack对图片资源进行优化" class="headerlink" title="webpack对图片资源进行优化"></a>webpack对图片资源进行优化</h5><p>将小于某个大小的图片转化成 data URI 形式（Base64 格式）</p><ul><li>优点：<strong>减少请求数量</strong></li><li>缺点：<strong>体积变得更大</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载器  </span></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span> <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h4 id="减少不必要的-cookie"><a href="#减少不必要的-cookie" class="headerlink" title="减少不必要的 cookie"></a>减少不必要的 cookie</h4><p>不必要的 <code>cookie</code> 来回传输会造成带宽浪费：</p><ul><li>减少 <code>cookie</code> 存储的内容</li><li>对于静态资源采用 <code>CDN</code> 托管（即非同域），不同域名默认不携带 <code>cookie</code></li></ul><h4 id="CDN-托管静态资源-HTTP-缓存"><a href="#CDN-托管静态资源-HTTP-缓存" class="headerlink" title="CDN 托管静态资源 + HTTP 缓存"></a>CDN 托管静态资源 + HTTP 缓存</h4><p>性能优化的第一定律就是：优先考虑使用缓存。</p><p>缓存的主要手段有：浏览器缓存、CDN。</p><p><strong><code>CDN</code> 加速的本质是缓存加速</strong>，将服务器上存储的静资源容缓存在 <code>CDN</code> 节点上，当后续访问这些静态内容时，无需访问服务器源站，选择就近访问 <code>CDN</code> 节点即可，从而达到加速的效果，同时减轻服务器源站的压力。</p><p>主要用在博客的图片上面。但图片存在了Github仓库，所以性能还是有影响。</p><p>CDN是“去中心化的”。</p><p>静态资源是指在<strong>不同请求中访问到的数据都相同的静态文件</strong>。例如：<strong>图片、视频、网站中的文件（html、css、js）</strong>、软件安装包、apk文件、压缩包文件等。</p><p>动态资源是指在<strong>不同请求中访问到的数据不相同的动态内容</strong>。例如：网站中的文件（asp、jsp、php、perl、cgi）、<strong>API接口、数据库交互请求</strong>等。</p><p><strong>CDN的作用</strong></p><ul><li>加速网站的访问</li><li>CDN的负载均衡和分布式存储技术，可以加强网站的可靠性。</li><li>使用CDN加速可以实现网站的全国铺设，你不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，也不用为了管理维护技术人员而烦恼，节省了人力、精力和财力。</li></ul><p><strong>CDN工作原理</strong></p><ul><li>当用户点击网站页面上的内容URL，经过<strong>本地DNS系统</strong>解析，DNS系统会最终将域名的解析权交给CNAME指向的<strong>CDN专用DNS服务器</strong>。</li><li>CDN的DNS服务器将CDN的<strong>全局负载均衡设备IP地址</strong>返回用户。</li><li>用户向CDN的全局负载均衡设备发起内容URL访问请求。</li><li>CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的<strong>区域负载均衡设备</strong>。</li><li>区域负载均衡设备会为用户选择一台合适的<strong>缓存服务器</strong>提供服务（地址、内容、负载），区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。</li><li>全局负载均衡设备把该IP地址返回给用户。</li><li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，那么这台服务器就要向它的上一级缓存服务器请求内容，<strong>直至追溯到网站的源服务器将内容拉到本地</strong>。</li><li>DNS服务器根据用户IP地址，<strong>将域名解析成相应节点的缓存服务器IP地址</strong>，实现用户<strong>就近访问</strong>。</li></ul><h4 id="协议升级为-Http2-0"><a href="#协议升级为-Http2-0" class="headerlink" title="协议升级为 Http2.0"></a>协议升级为 Http2.0</h4><blockquote><p><strong><code>http1.x</code> 存在的问题：</strong> <code>HTTP</code> 的底层协议是 <code>TCP</code>，而 <code>TCP</code> 是面向连接即需要 <strong>三次握手</strong> 才能建立连接，其中：</p></blockquote><ul><li><code>http1.0</code> 中使用的是 <strong>短连接</strong>，即 <strong>一次请求/响应</strong> 结束后就会断开连接，这个过程比较耗时</li><li><code>http1.1</code>中使用的是长连接，在请求/响应头中设置<code>Connection: keep-alive</code>即可开启，优点是长连接允许多个请求共用一个TCP连接，缺点是带来了队头阻塞：<ul><li>每个 <code>TCP</code> 连接中的多个请求，需要进行排队，只有队头的请求被响应，才能继续处理下一个请求</li><li>其中一个缓解方案就是如果当前 <code>TCP</code> 连接中发生 <strong>队头阻塞</strong>，那就将部分请求放到其他 <code>TCP</code> 连接中</li><li>浏览器一般会限制同一个域名建立 <code>6-8</code> 个 <code>TCP</code> 链接，这也就是为什么需要为应用划分子域名、静态资源托管 <code>CDN</code> 的原因之一。</li></ul></li><li><code>http1.x</code> 中 <code>header</code> 部分的内容可能会很大，而且每一个请求可能都需要携带大量 <strong>重复</strong> <code>header</code> 的 <strong>文本内容</strong>，而这些也是导致 <strong>请求/响应</strong> 慢的原因之一。</li></ul><blockquote><p><strong>以上问题 <code>http2.0</code> 都能够解决：</strong></p></blockquote><ul><li><p>针对 <strong>TCP 连接数</strong> 被限制的问题，<code>http2.0</code> 采用 <strong>多路复用</strong> 一个域名只对应一个 <code>TCP</code> 连接。</p></li><li><p>针对 <strong>http 队头阻塞</strong> 问题，<code>http2.0</code> 中通过二进制分帧层为每个 <strong>请求/响应</strong> 添加 <code>stream id</code> 保证 <strong>请求/响应</strong> 一一对应，即不必等待前面的请求处理完成，并且还可以为每个请求添加 <strong>优先级</strong>。</p></li><li><p>针对<code>header</code>数据大的问题，http2.0中传输的header帧经过处理后会用二进制的方式表示，替换了原本的文本格式，并使用HPACK算法进行压缩</p><ul><li><strong>接收/发送</strong> 两端会维护一个 <strong>索引表</strong>，通过下标来标识 <code>header</code>，针对后续重复的 <code>header</code> 信息就可以用对应的索引来代替。</li></ul></li><li><p>针对传统的 <strong>请求 —&gt; 响应</strong> 模式，<code>http2.0</code> 中提供了 <strong>服务端推送</strong> 的能力，让服务端能够主动向客户端推送关键资源，加快资源加载。</p></li></ul><h4 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h4><p>使用<code>link</code>的<code>preload</code>属性预加载一个资源。webpack也可配置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>as属性可以指定预加载的类型，除了style还支持很多类型，常用的一般是<code>style</code>和<code>script</code>，<code>css</code>和<code>js</code>。</p><blockquote><p>【<strong>注意</strong>】<code>as</code> 属性一定要设置，除了设置优先级外，还涉及到浏览识别的问题：如果没有设置 <code>as</code> 属性，后续遇到该请求就会被作为一个 <code>XHR</code> 请求，把意味着资源预加载的功能可能会失效，因为可能会每次都发起新的请求获取</p></blockquote><p><code>preload</code> 是对资源的预加载，它虽提前加载但只在需要执行时执行，即这个资源一定是当前页面所需要的资源，如果是需要为下一个页面提前加载资源，那么应该使用 <code>prefetch</code>，它会在 <strong>浏览器空闲时</strong> 下载资源。。webpack也可配置。</p><h3 id="如何保证视图更快的渲染和交互？"><a href="#如何保证视图更快的渲染和交互？" class="headerlink" title="如何保证视图更快的渲染和交互？"></a>如何保证视图更快的渲染和交互？</h3><h4 id="渲染层面"><a href="#渲染层面" class="headerlink" title="渲染层面"></a>渲染层面</h4><h5 id="减少阻塞渲染的因素"><a href="#减少阻塞渲染的因素" class="headerlink" title="减少阻塞渲染的因素"></a>减少阻塞渲染的因素</h5><p>真正渲染视图之前，必然要生成 <strong><code>DOM Tree</code></strong> 和 **<code>CSSOM</code>**，因此必须保证 <strong>HTML 解释器</strong> 和 <strong>CSS 解释器</strong> 都尽早处理完成，同时 <strong><code>JavaScript</code></strong> 的加载和执行可能会阻塞这个过程：</p><ul><li><code>HTML</code> 文档中首次渲染的节点数量要尽量少，避免深层次的嵌套结构，避免大量使用慢标签（如：<code>iframe</code>）等。</li><li><code>CSS</code> 资源放文档头部，降低 <code>CSS</code> 复杂度，比如 合理使用 <code>CSS</code> 选择器。</li><li><code>JavaScript</code> 资源放文档底部，合理使用 <code>defer、async</code> 的加载方式。</li></ul><h5 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h5><p>懒加载主要是针对数量大、资源加载慢的情况，比如图片资源、大量列表数据展示等：</p><ul><li><strong>图片资源</strong>：优先加载在可视区范围内的图片，可视区外的图片 **<code>延后加载</code>**，或者说当移入的可视区时再加载。</li><li><strong>列表数据</strong>：列表数据通常数据里量大，不可能一次渲染完所有数据，一般通过 <strong><code>分页加载、上拉加载</code></strong> 等方式分批次渲染。</li></ul><p>在HTML中，图片是由 <code>&lt;img&gt;</code> 标签引入的，是由其中的<code>src</code>属性去请求的。所以实现懒加载的关键就是，在图片没有进入可视区的时候，不给<code>src</code>属性赋值，等图片进入到了可视区，再给<code>src</code>属性赋值，去请求图片。</p><p><code>img</code>的<code>loading</code>属性。</p><p><code>&lt;img src=&quot;./example.jpg&quot; loading=&quot;lazy&quot;&gt;</code></p><p><strong>js实现原理</strong></p><p>我们通过js监听页面的滚动也能实现。</p><p>使用js实现的原理主要是判断当前图片是否到了可视区域：</p><ul><li>拿到所有的图片 dom 。</li><li>遍历每个图片判断当前图片是否到了可视区范围内。</li><li>如果到了就设置图片的 src 属性。</li><li>绑定 window 的 scroll 事件，对其进行事件监听。</li></ul><p>在页面初始化的时候，<code>&lt;img&gt;</code>图片的src实际上是放在data-src属性上的，当元素处于可视范围内的时候，就把data-src赋值给src属性，完成图片加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> viewHeight = <span class="built_in">document</span>.body.clientHeight <span class="comment">//获取可视区高度</span></span><br><span class="line">  <span class="keyword">let</span> imgs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;img[data-src]&#x27;</span>)</span><br><span class="line">  imgs.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.dataset.src === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置</span></span><br><span class="line">    <span class="keyword">let</span> rect = item.getBoundingClientRect()</span><br><span class="line">    <span class="keyword">if</span> (rect.bottom &gt;= <span class="number">0</span> &amp;&amp; rect.top &lt; viewHeight) &#123;</span><br><span class="line">      item.src = item.dataset.src</span><br><span class="line">      item.removeAttribute(<span class="string">&#x27;data-src&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, lazyload)</span><br></pre></td></tr></table></figure><p>但是这样存在较大的性能问题，因为 scroll 事件会在很短的时间内触发很多次，严重影响页面性能，为了提高网页性能，我们需要一个节流函数来控制函数的多次触发，在一段时间内（如 200ms）只执行一次回调。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttle(lazyload, <span class="number">200</span>))</span><br></pre></td></tr></table></figure><h5 id="白屏优化"><a href="#白屏优化" class="headerlink" title="白屏优化"></a>白屏优化</h5><p>白屏是由于 <code>SPA</code> 应用需要等待 <code>JavaScript</code> 加载并执行完成后才会生成具体的页面结构内容导致的，即初始化模板中没有任何有意义需要被渲染的 <code>HTML</code> 结构：</p><ul><li>添加 **白屏 <code>loading</code>**，可在模板中添加默认的 <code>loading</code> 效果，等到真正页面内容被渲染就可以替换 <code>loading</code> 内容。</li><li>添加 <strong>骨架屏</strong>，和上述方案一致，在真正页面内容展示出来之前，先展示默认的视图内容，避免白屏。</li></ul><h5 id="服务端渲染（server-side-rendering）"><a href="#服务端渲染（server-side-rendering）" class="headerlink" title="服务端渲染（server-side rendering）"></a>服务端渲染（server-side rendering）</h5><p>现代框架默认是属于客户端应用框架，即组件的代码会在浏览器中运行，然后向页面输出 <strong>DOM</strong> 元素，也叫 <strong>客户端渲染（client-side rendering，CSR）</strong>：</p><ul><li>优点<ul><li>**<code>用户体验更好</code>**，基于 <strong>前端路由</strong> 的方式并不会真正进行 <strong>页面跳转</strong>，即不会使页面重新刷新、加载，带来更高的流畅度。</li><li><strong><code>占用服务端资源少</code><strong>，</strong>CSR 渲染</strong> 是交由客户端进行处理，服务端不需要关心渲染计算的过程，减轻了服务端的压力。</li></ul></li><li>缺点<ul><li>**<code>&quot;白屏&quot; 时间较长</code>**，主要是因为 <strong>CSR</strong> 渲染需要 <code>*.js</code> 的支持，而 <code>*.js</code> 又必须保证 <code>*.html</code> 被接收和解析， <code>*.html</code> 又强依赖于当前的 <strong>网络环境</strong>，因此，在差网环境下回导致 <strong>白屏时间过长</strong>，特别是在移动网络环境下。</li><li>**<code>对 SEO 的支持不友好</code>**，因为 <strong>白屏时间较长</strong> 导致在一段时间内没有重要的内容能够交由 <strong>搜索引擎</strong> 进行分析、分类、打标签等，并且 <strong>搜索引擎</strong> 并不会等待页面渲染完成，因此对 <strong>SEO</strong> 优化并不友好。</li></ul></li></ul><p><strong>服务端渲染（server-side rendering，SSR）</strong> 可将相同组件在服务渲染成相应的 <code>HTML</code> 字符串，并发送给浏览器进行渲染，即客户端不需要等待所有的 <strong>JavaScript</strong> 都被下载并执行之后才显示，所以用户可以更快看到完整的渲染好的内容。</p><h5 id="预渲染（prerender）"><a href="#预渲染（prerender）" class="headerlink" title="预渲染（prerender）"></a>预渲染（prerender）</h5><p>上述 <strong>服务端渲染（server-side rendering，SSR）</strong> 虽然能够解决一些客户端存在的问题，但它也带来了别的问题：</p><ul><li>**<code>需要保证开发一致性</code>**，比如 <strong>服务端</strong> 和 <strong>客户端</strong> 能够执行的组件生命周期钩子不同，一些外部库在 <strong>服务端渲染</strong> 应用中可能需要经过特殊处理。</li><li>**<code>需要更多的构建设定和部署要求</code>**，一个完全静态的 <strong>SPA</strong> 可以部署在任意的静态文件服务器，但服务端渲染应用需要一个能够运行 <strong>Node.js</strong> 服务器的环境。</li><li>**<code>更多的服务端负载</code>**，在 <strong>Node.js</strong> 中渲染一个完整的应用，会比仅供应静态文件产生更密集的 <strong>CPU</strong> 运算，并且需要考虑访问流量过大的情况等。</li></ul><p>因此，并不是所有应用都合适 <strong>服务端渲染</strong>，如果只是希望通过 <strong>SSR</strong> 来改善一些 <strong>推广页面</strong> (如 <code>/</code>、<code>/about</code>、<code>/contact</code> 等) 的 <strong>SEO</strong>，那么应该优先考虑 <strong>预渲染</strong> 的方式：</p><ul><li><strong>预渲染</strong> 是在打包构建过程中（离屏状态），针对对应的 <code>routes</code> 路由预先生成对应的页面内容。</li><li><strong>预渲染</strong> 需要和 <strong>打包构建工具（webpack、rollup 等）</strong> 进行配合，如 **<code>webpack</code>**，就可通过 <strong><code>prerender-spa-plugin</code></strong> 来支持 <strong>预渲染</strong>。</li></ul><h4 id="交互层面"><a href="#交互层面" class="headerlink" title="交互层面"></a>交互层面</h4><h5 id="减少回流-重绘"><a href="#减少回流-重绘" class="headerlink" title="减少回流/重绘"></a>减少回流/重绘</h5><p><strong>重绘</strong>：页面中元素样式的改变并不影响它在文档流中的位置时（如：<code>color、background-color、visibility</code> 等），浏览器会将新样式赋予给元素并 <strong>重新绘制</strong>.</p><p><strong>回流</strong>：当 <code>Render Tree</code> 中部分或全部元素的 <strong>尺寸、结构、某些属性</strong> 发生改变时，浏览器 <strong>重新渲染</strong> 部分或全部文档。</p><ul><li>减少对 <code>DOM</code> 进行频繁操作。</li><li>使经常变动的元素脱离文档流，如具有持续性的动画效果，会一直触发回流和重绘。</li><li>避免访问或减少访问会导致浏览器强制刷新队列的属性，如：<code>offsetTop、offsetLeft、offsetWidth</code>等<ul><li>【<strong>扩展</strong>】浏览器的渲染队列机制会通过 <strong>队列</strong> 将会触发 <strong>回流或重绘</strong> 的操作进行存储，等到一定的时间或一定的数量时再执行这些操作。</li></ul></li><li>避免对 <code>css</code> 进行单个修改，如在 <code>JavaScript</code> 修改多个样式时，尽量使用 <code>css</code> 选择器实现样式的集中变更。</li><li>使用 <code>will-change</code> 开启 <code>GPU</code> 加速，<code>will-change</code> 指定的属性使得浏览器可在元素属性真正发生变化之前提前做好对应的优化。</li><li>预先设定图片尺寸，避免图片资源加载完成后引发回流。</li></ul><h5 id="防抖-节流"><a href="#防抖-节流" class="headerlink" title="防抖/节流"></a>防抖/节流</h5><p><strong>防抖</strong>：多次频繁触发执行操作，以 <strong>最后一次</strong> 为准，忽略中间过程。</p><p><strong>节流</strong>：在指定的时间间隔内，<strong>只允许</strong> 执行一次对应的操作。</p><p>合理使用 <strong><code>防抖/节流</code></strong> 优化应用中的操作，比如 <strong><code>节流</code></strong> 可用于优化滚动事件、模糊搜索等，**<code>防抖</code>** 可用于优化一些按钮点击操作等。</p><h5 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h5><p><code>JavaScript</code> 是单线程的，如果存在需要大量计算的场景（如视频解码），<code>UI</code> 线程就会被阻塞，甚至浏览器直接卡死。</p><p><code>Web Worker</code> 可以使脚本运行在新的线程中，它们独立于主线程，可以进行大量的计算活动，而不会影响主线程的 <code>UI</code> 渲染，但不能滥用 <code>Web Worker</code> 。</p><h5 id="虚拟列表"><a href="#虚拟列表" class="headerlink" title="虚拟列表"></a>虚拟列表</h5><p>最常用的还是 <strong>分页加载</strong> 的方式：</p><ul><li>基于 <code>table</code> 表格的渲染，只会渲染固定数量的 <code>DOM</code></li><li>基于 <code>上拉加载</code> 列表的渲染，随着加载数据的增多，对应的 <code>DOM</code> 节点也会增多，达到某个限制页面一定会发生卡顿</li></ul><p><strong>虚拟列表</strong> 核心就是固定渲染的 <strong><code>DOM</code></strong> 数，通过动态切换数据内容实现视图的更新，并保证文档中真实 <strong><code>DOM</code></strong> 的数量不随着数据量增大而增大（其实和 <code>table</code> 分页很像，但它支持滚动）。</p><p>想了解其核心实现的，可查看 <a target="_blank" rel="noopener" href="https://juejin.cn/post/7129919300994859015"><strong>虚拟滚动是怎么做性能优化的?</strong></a></p><h5 id="大文件分片上传"><a href="#大文件分片上传" class="headerlink" title="大文件分片上传"></a>大文件分片上传</h5><p>大部分的项目总少不了文件上传功能，但对大文件的上传还是有必要进行优化，所谓的 <strong>断点续传</strong>、<strong>秒传</strong> 都要基于 <strong>分片上传</strong> 这个核心功能。</p><p>想了解其核心实现的，可查看 <a target="_blank" rel="noopener" href="https://juejin.cn/post/7074534222748188685"><strong>请问：怎么实现大文件快速上传？</strong></a></p><h5 id="Excel-导入-导出"><a href="#Excel-导入-导出" class="headerlink" title="Excel 导入/导出"></a>Excel 导入/导出</h5><p>针对 <strong>Excel 导入/导出</strong> 的功能相信很多人第一印象是后端的活，但大多数情况下，后端接口的处理速度会受各种影响，导致速度方面不是很理想，有时候也是需要前端来进行优化处理的，比如导入时前端不发送文件只发送解析后的 <code>JSON</code> 数据，导出时不需要单独发送额外接口，直接使用当前展示数据实现导出等。</p><p>想了解其核心实现的，可查看 <a target="_blank" rel="noopener" href="https://juejin.cn/post/7135945969425711111"><strong>给我实现一个前端的 Excel 导入和导出功能</strong></a></p><h3 id="React项目的优化-★"><a href="#React项目的优化-★" class="headerlink" title="React项目的优化 ★"></a>React项目的优化 ★</h3><h4 id="尽量避免重新render"><a href="#尽量避免重新render" class="headerlink" title="尽量避免重新render"></a>尽量避免重新render</h4><h5 id="使用PureComponent"><a href="#使用PureComponent" class="headerlink" title="使用PureComponent"></a>使用PureComponent</h5><p>React.PureComponent中<strong>浅层对比</strong>了<code>props</code>和<code>state</code>来避免重新渲染，但是假如props和state的属性值是对象的情况下，并不能阻止不必要的渲染，因为只是比较了地址，所以在使用PureComponent的时候要确保数据类型是值的类型，如果是引用类型，最好不要有深层次的变化。</p><h5 id="使用ShouldComponentUpdate"><a href="#使用ShouldComponentUpdate" class="headerlink" title="使用ShouldComponentUpdate"></a>使用ShouldComponentUpdate</h5><p>这个函数可以决定是否要重新渲染组件，也属于一个生命周期函数，如果props更改或者调用setState这个函数会返回一个布尔值，true表示会重新渲染，如果为false则不会重新渲染。</p><h5 id="使用React-memo"><a href="#使用React-memo" class="headerlink" title="使用React.memo"></a>使用React.memo</h5><p>如果组件在相同的props的情况下渲染结果相同时，可以通过将其包装在React.memo中，React将跳过渲染组件并直接复用最近一次渲染的结果。</p><p>React.memo对比的是<code>props</code>的变化，如果一个组件被这个钩子函数包裹，但是其内部有useState或者useReducer之类的，仍会进行重新渲染，这个也是进行的浅层比较，如果想要控制对比的过程，可以将自定义的函数通过第二个参数进行传递。</p><h5 id="使用useMemo缓存计算结果"><a href="#使用useMemo缓存计算结果" class="headerlink" title="使用useMemo缓存计算结果"></a>使用useMemo缓存计算结果</h5><p>如果一个组件中有一个计算量比较大的函数，重新渲染每次都调用比较消耗性能，所以我们可以使用useMemo来缓存这个函数的计算结果，这样只有传入的参数发生变化才会重新进行计算。</p><h5 id="使用useCallback来缓存函数"><a href="#使用useCallback来缓存函数" class="headerlink" title="使用useCallback来缓存函数"></a>使用useCallback来缓存函数</h5><p>假如一个组件中有一个函数，只要状态发生变化，这个函数就会被重新定义，使用useCallback可以进行缓存。</p><h5 id="使用发布订阅模式来避免中间组件不必要的渲染"><a href="#使用发布订阅模式来避免中间组件不必要的渲染" class="headerlink" title="使用发布订阅模式来避免中间组件不必要的渲染"></a>使用发布订阅模式来避免中间组件不必要的渲染</h5><p>如果组件的嵌套层级比较深，可能造成中间组件不必要的渲染，可能中间组件只是传递了props，这种情况我们可以通过发布订阅模式，让只关心某个状态的组件去更新，可以借助一些类似的第三方库：redux。</p><h5 id="尽量将状态放到子组件中（状态下方）"><a href="#尽量将状态放到子组件中（状态下方）" class="headerlink" title="尽量将状态放到子组件中（状态下方）"></a>尽量将状态放到子组件中（状态下方）</h5><p>如果一个状态只是某部分子组件在使用，可以将其提取为一个组件，然后状态定义到这个组件中，避免中间组件不必要的渲染。</p><h5 id="列表的每个item加上key属性"><a href="#列表的每个item加上key属性" class="headerlink" title="列表的每个item加上key属性"></a>列表的每个item加上key属性</h5><p>通过添加key属性可以更好的辅助Diff算法进行虚拟DOM计算，避免不必要的渲染。</p><h4 id="尽量减少要渲染的节点"><a href="#尽量减少要渲染的节点" class="headerlink" title="尽量减少要渲染的节点"></a>尽量减少要渲染的节点</h4><h5 id="组件懒加载"><a href="#组件懒加载" class="headerlink" title="组件懒加载"></a>组件懒加载</h5><p>组件懒加载实现的效果是让真正需要真是这个组件的时候才渲染，主要是通过<code>React.lazy</code>和<code>React.Suspense</code>这两个组件来进行组件懒加载。</p><p>主要是使用<code>React.lazy</code>来定义一个动态加载的组件，<code>React.Suspense</code>主要是用来包裹要懒加载的组件的。</p><h5 id="使用虚拟列表"><a href="#使用虚拟列表" class="headerlink" title="使用虚拟列表"></a>使用虚拟列表</h5><p>虚拟列表可以根据滚动容器的元素的高度来渲染长列表的数据，尤其是在一些没有直接分页的场景，主要是使用第三方库：r<code>eact-window</code>、<code>react-virtualized</code>。</p><h4 id="避免添加额外的DOM"><a href="#避免添加额外的DOM" class="headerlink" title="避免添加额外的DOM"></a>避免添加额外的DOM</h4><h6 id="使用React-fragment来避免不必要的div"><a href="#使用React-fragment来避免不必要的div" class="headerlink" title="使用React.fragment来避免不必要的div"></a>使用React.fragment来避免不必要的div</h6><p>因为React规定一个组件只能有一个父元素，我们可以通过<code>React.Fragment</code>或<code>&lt;&gt;&lt;/&gt;</code>来代替不必要的div。</p><h2 id="HTTP-浏览器缓存★"><a href="#HTTP-浏览器缓存★" class="headerlink" title="HTTP/浏览器缓存★"></a>HTTP/浏览器缓存★</h2><blockquote><p>考察公司：完美世界、小米、美团、百度</p></blockquote><p>浏览器缓存(Brower Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力。</p><h3 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h3><ul><li><code>200 form memory cache</code> :不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。<strong>浏览器关闭后，数据将不存在（资源被释放掉了）</strong>，再次打开相同的页面时，不会出现from memory cache。</li><li><code>200 from disk cache</code>：不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，<strong>关闭浏览器后，数据依然存在</strong>，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。</li><li>优先访问<code>memory cache</code>,其次是<code>disk cache</code>，最后是<strong>请求网络资源</strong></li></ul><p>http缓存机制主要在<strong>http响应头</strong>中设定，响应头中相关字段为<code>Expires</code>、<code>Cache-Control</code>、<code>Last-Modified</code>、<code>Etag</code>。</p><h3 id="强缓存、协商缓存"><a href="#强缓存、协商缓存" class="headerlink" title="强缓存、协商缓存"></a>强缓存、协商缓存</h3><p>在第一次请求时，没有缓存，直接向服务器发送请求，服务器可能会将一些关于缓存的字段放入响应头。</p><p>第二次浏览器请求某一资源时：</p><ul><li>强缓存 <code>Cache-Control</code>（max-age,优先级高）、<code>Expires</code>(GMT）=&gt; 判断<strong>是否过期</strong><ul><li>没过期则直接从缓存中获取资源信息，<strong>不会与服务器进行通信</strong>。</li><li>如果两者同时存在，以 <code>Cache-Control</code> 为准。</li><li><code>Cache-Control:max-age=3600</code>，代表着资源的有效期是3600秒。除了该字段外，还有下面几个比较常用的设置值：<ul><li><code>no-cache</code>：<strong>不使用本地缓存</strong>。需要使用<strong>协商缓存</strong>。</li><li><code>no-store</code>：直接<strong>禁止游览器缓存数据</strong>，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</li><li><code>public</code>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</li><li><code>private</code>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</li><li><code>max-age</code> 为 0 可以近似理解为与 <code>no-cache</code> 等效。</li></ul></li></ul></li></ul><ul><li><p>协商缓存 <strong>由服务器来确定缓存资源是否可用</strong></p><ul><li><p><code>Last-Modified + If-Modified-Since http1.0</code></p><ul><li><p>Last-Modified：浏览器向服务器发送资源最后的修改时间。</p></li><li><p>If-Modified-Since：</p><p>当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有<code>Last-Modified</code>声明，则再次向服务器请求时带上头<code>If-Modified-Since</code>，表示请求时间。服务器收到请求后发现有<code>If-Modified-Since</code>则与被请求资源的最后修改时间进行对比（<code>Last-Modified</code>）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，<code>HTTP 200 OK</code>;若最后修改时间较旧（小），说明资源无新修改，响应<code>HTTP 304</code> 走缓存。</p></li></ul></li><li><p><code>Etag+ If-None-Match HTTP 1.1</code></p><ul><li><p>Etag是属于HTTP 1.1属性，它是由服务器（Apache或者其他工具）生成返回给前端，用来帮助服务器控制Web端的缓存验证。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</p></li><li><p>If-None-Match：当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头If-None-Match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304。</p></li><li><p>如果同时设了 <code>ETag</code> 和 <code>Last-Modified</code>，那么必须<strong>同时满足条件才会 304</strong>，不存在谁更优先就使用谁一说。</p><p>但一般分布式环境下（比如 CDN）很少使用 <code>ETag</code>，因为 <code>ETag</code> 依赖 Web Server 的哈希算法，不同 Web Server、不同版本、不同的配置，都会导致同样的文件 <code>ETag</code> 可能是不相等的。当然了，如果你能限制上述信息都一样，也可以使用 <code>ETag</code>，并不绝对。</p></li></ul></li></ul></li></ul><h3 id="缓存发展"><a href="#缓存发展" class="headerlink" title="缓存发展"></a>缓存发展</h3><p>强缓存有缺点，比如说，设置了<code>expires</code>，<code>GMT</code>格式，但是可能客户端与服务器时间不一致，或者网络延迟导致时间不准确，因此就通过<code>cache-control</code>返回一个<strong>相对时间</strong>来。</p><p>但是假如说<strong>资源并没有更新</strong>，但是强缓存时间过期了，那就需要重新拉去资源，因此就有了<code>Last-Modified</code>。</p><p>但是<code>last-modified</code>的时间单位是<code>s</code>，当1s内有资源修改，那浏览器返回的最后修改时间和上次的修改时间相同，那就不会重新拉取资源，还有可能**内容并不改变(仅仅改变的修改时间)**。</p><p>因此推出了<code>Etag</code>，通过<strong>比对资源内容</strong>来判断是否修改。</p><h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><ul><li><p><strong>浏览器地址栏中写入URL，回车 / 普通刷新F5</strong></p><p>不同浏览器和不同类型资源缓存方式不同，个人理解：</p><ul><li>返回200，并显示从缓存中获取，则为强缓存（虽然没有发出真实的 http 请求）。</li><li>返回304，说明是协商缓存命中走<strong>缓存</strong>。</li></ul></li><li><p><strong>强制刷新Ctrl+F5</strong> 删除缓存，重新请求。</p></li></ul><h2 id="浏览器解析渲染★"><a href="#浏览器解析渲染★" class="headerlink" title="浏览器解析渲染★"></a>浏览器解析渲染★</h2><blockquote><p>考察公司：美团、百度、腾讯</p></blockquote><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/LuRQC4"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/04/13/LuRQC4.jpg" alt="LuRQC4.jpg"></a></p><p>请求回来的文档数据先保存在网络进程。在提交文档阶段，浏览器进程将网络进程接收到的HTML数据提交给渲染进程。</p><ul><li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</li><li>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；</li><li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li></ul><p>浏览器解析渲染页面分为以下步骤：</p><ul><li>根据 HTML 解析出 DOM 树<ul><li><strong>图片/CSS不会影响解析</strong></li><li><code>&lt;script&gt;</code><strong>阻塞渲染并停止HTML的解析</strong>（因为它可能操作dom）</li><li><strong>预加载</strong>在后台检索资源，可以减少阻塞</li><li>display:none被隐藏的节点也会在dom树上</li></ul></li><li>根据 CSS 解析生成 CSS 规则树（<strong>CSSOM</strong>）</li><li>结合 DOM 树和 CSS 规则树，生成渲染树<ul><li><code>&lt;head&gt;</code>和它的<strong>子节点</strong>以及任何具有<code>display: none</code>样式的结点，不会出现在Render树上</li><li><code>visibility: hidden</code>的节点会出现在Render树上</li><li><code>display: none</code> 会引起页面的<strong>回流</strong>(重排)以及<strong>重绘</strong>，而<code>visibility: hidden</code>只会引起<strong>重绘</strong></li></ul></li><li>根据渲染树计算每一个节点的信息</li><li>根据计算好的信息绘制页面<ul><li>第一次确定节点的大小和位置称为布局。</li><li>随后对节点大小和位置的重新计算称为<strong>回流</strong>，不改变大小位置的样式改变为<strong>重绘</strong>。</li><li>对布局树进行分层，并生成分层树，为每个图层生成绘制列表，并将其提交到合成线程。</li><li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li><li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程，浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</li><li>可以将内容提升到GPU上的层（而不是CPU上的主线程）可以提高绘制和重新绘制性能。<ul><li>有一些特定的属性和元素可以<strong>实例化一个层</strong>，包括<code>&lt;video&gt;</code>和<code>&lt;canvas&gt;</code>，任何CSS属性为<code>opacity</code>、3D <code>transform</code>等</li><li>分层确实可以提高重绘速度，但是它以<strong>内存管理</strong>为代价。</li></ul></li></ul></li></ul><h2 id="script标签属性★"><a href="#script标签属性★" class="headerlink" title="script标签属性★"></a>script标签属性★</h2><blockquote><p>考察公司：百度、腾讯</p></blockquote><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>async标记告诉浏览器在等待js下载期间可以去干其他事，当js下载完成后会<strong>立即(尽快)执行</strong>，<strong>多条js可以并行下载</strong>。</p><p>async的好处是让多条js不会互相等待，<strong>下载期间浏览器会去干其他事(继续解析HTML等)<strong>，</strong>异步下载，异步执行</strong>。</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>与async一样，defer标记告诉浏览器在等待js下载期间可以去干其他事，<strong>多条js可以并行下载</strong>，不过当js下载完成之后<strong>不会立即执行</strong>，而是会等待解析完整个HTML之后在开始执行，而且多条defer标记的js会<strong>按照顺序执行</strong>。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>如果两个script之间<strong>没有依赖关系</strong>并且<strong>无需等待页面解析</strong>的更加适合使用<code>async</code>，反之如果两个script之间<strong>有依赖关系</strong>，或者希望<strong>优先解析HTML</strong>，则<code>defer</code>更加适合。</p><p>defer脚本会在文档渲染完毕后，<code>DOMContentLoaded</code>事件调用前执行。</p><h2 id="重绘-回流★"><a href="#重绘-回流★" class="headerlink" title="重绘/回流★"></a>重绘/回流★</h2><blockquote><p>考察公司：百度</p></blockquote><h3 id="回流-重排reflow"><a href="#回流-重排reflow" class="headerlink" title="回流/重排reflow"></a>回流/重排reflow</h3><p><strong>对节点大小和位置的重新计算</strong></p><h3 id="重绘Repaint"><a href="#重绘Repaint" class="headerlink" title="重绘Repaint"></a>重绘Repaint</h3><p><strong>不改变大小位置的样式改变</strong>（color、background-color、visibility）。</p><p>元素的回流会导致所有子元素和祖先元素以及 DOM 中跟随它的任何元素的后续<strong>回流</strong>。</p><p>在很多情况下，它们相当于<strong>重新布局整个页面</strong>。</p><p>回流一定会导致重绘，重绘成本也很高，<strong>因为浏览器必须验证 DOM 树中所有其他节点的可见性</strong>。</p><p>相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</p><p>不幸的是，很多事情都会引发回流。其中一些在编写 CSS 时特别相关：</p><ul><li><strong>调整窗口大小</strong></li><li><strong>添加或删除样式表</strong></li><li><strong>内容更改</strong>，例如用户在输入框中键入文本</li><li><strong>激活 CSS 伪类</strong>，例如 :hover（在 IE 中激活兄弟的伪类）</li><li><strong>操作 DOM 的脚本</strong></li></ul><h3 id="避免回流-重绘"><a href="#避免回流-重绘" class="headerlink" title="避免回流/重绘"></a>避免回流/重绘</h3><ul><li><p><strong>浏览器队列优化机制</strong></p><p>现代浏览器不会对每次回流重绘都进行操作，而是把涉及回流重绘的操作放到一个队列里面，当一段时间后或者队列放满了后，浏览器会一次性将队列中所有的操作执行，这样就会大大的减少回流重绘的次数，提高性能，但是当代码执行过程中需要获取某些元素的位置信息(比如执行到一些js自带获取位置信息的api时)，该队列会被强制刷新，这些api有：offsetLeft，offsetTop, offsetWidth, offsetHeight, clientWidth, clientHeigth，clientLeft，clientTop，scrollWidth, scrollHeight, scrollLeft, scrollTop， getBoundingClientRect()…</p></li><li><p><strong>CSS</strong></p><ul><li>使用transform来代替top(css硬件加速，相同效果前者少一个layout延时) 常见的触发硬件加速的css属性：transform，opacity，filters，Will-change</li><li>避免使用table布局</li><li>尽量避免多层嵌套，结构尽量扁平化</li><li>对于有复杂动画效果的DOM元素应该将其独立处出来，脱离文档流。应用<code>fixed</code>或<code>absolute</code>定位。</li><li>使用visibility，opacity 代替 display: none (前者的展现只涉及重绘， 后者需要回流)</li></ul></li></ul><ul><li><strong>JS</strong><ul><li><strong>避免频繁操作DOM</strong></li><li>React的虚拟DOM的作用是将真实 DOM 的副本存储在内存中。当您修改 DOM 时，它首先将这些更改应用到内存中的 DOM。然后，使用它的差异算法，找出真正发生了什么变化。最后，它对更改进行批处理，并调用一次将它们应用到real-dom 上。因此，<strong>最大限度地减少了回流和重绘。</strong></li></ul></li></ul><h3 id="display：none和visibility：hidden的区别"><a href="#display：none和visibility：hidden的区别" class="headerlink" title="display：none和visibility：hidden的区别"></a>display：none和visibility：hidden的区别</h3><ul><li>display：none隐藏完元素所占据的空间也会消失 。visibility：hidden隐藏完元素还是占据空间。</li><li>display：none没有继承性，visibility：hidden有继承性。给父元素设置visibility：hidden，其子元素也会继承该属性，如果给子元素设置visibility：visible，则子元素会显示出来。</li><li>visibility：hidden不会影响计数器的运算，比如ol标签中的li标签，隐藏其中的第二个标签，后续标签的序号不变，而如果使用display：none后续标签的序号会衔接上去上一个。</li><li>CSS3的transition支持visibility属性，但是并不支持display</li><li>display:none会引起回流(重排)和重绘 visibility:hidden会引起重绘</li></ul><h2 id="TCP-UDP★"><a href="#TCP-UDP★" class="headerlink" title="TCP UDP★"></a>TCP UDP★</h2><blockquote><p>考察公司：美团、腾讯、完美世界</p></blockquote><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li>在传送数据之前<strong>不需要先建立连接</strong>，远地主机在收到 UDP 报文后，<strong>不需要给出任何确认</strong>。</li><li>一般用于<strong>即时通信</strong>，比如： QQ 语音、 QQ 视频 、直播等等</li><li>基于<strong>UDP的QUIC</strong>协议可以实现类似TCP的可靠性传输</li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul><li>提供<strong>面向连接</strong>的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li>TCP 在传递数据之前，会有<strong>三次握手</strong>来建立连接，而且在数据传递时，有<strong>确认</strong>、<strong>窗口</strong>、<strong>重传</strong>、<strong>拥塞控制</strong>机制，在数据传完后，还会<strong>断开连接</strong>用来节约系统资源</li><li>由于 TCP 要提供可靠的，面向连接的传输服务，这难以避免增加了许多开销。</li><li>TCP 一般用于<strong>文件传输、发送和接收邮件、远程登录</strong>等场景。</li></ul><h3 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h3><ul><li><p><strong>基于数据块传输</strong> ：应用数据被<strong>分割</strong>成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</p></li><li><p><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个<strong>序列号</strong>，有了序列号能够将接收到的数据根据序列号排序，并且<strong>去掉重复序列号</strong>的数据就可以实现数据包去重。</p></li><li><p><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是<strong>检测数据在传输过程中的任何变化</strong>。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p></li><li><p><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在<strong>合理的往返时延（RTT）</strong>内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传。</p></li><li><p><strong>流量控制</strong> : TCP 连接的每一方都有<strong>固定大小的缓冲空间</strong>，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能<strong>提示发送方降低发送的速率</strong>，防止包丢失。TCP 使用的流量控制协议是<strong>可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）</strong>。</p></li><li><p><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</p></li></ul><h3 id="TCP-如何实现流量控制？"><a href="#TCP-如何实现流量控制？" class="headerlink" title="TCP 如何实现流量控制？"></a>TCP 如何实现流量控制？</h3><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong></p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><p><strong>为什么需要流量控制?</strong> 这是因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 <strong>接收缓冲区(Receiving Buffers)</strong> 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p><p>这里需要注意的是（常见误区）：</p><ul><li>发送端不等同于客户端</li><li>接收端不等同于服务端</li></ul><p>TCP 为<strong>全双工(Full-Duplex, FDX)通信</strong>，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是服务端。</p><p>因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。</p><p>接收窗口大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。</p><p>通信双方的发送窗口和接收窗口的要求相同。</p><p><strong>TCP发送窗口结构</strong><br><a target="_blank" rel="noopener" href="https://imgse.com/i/x1RMHe"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/10/06/x1RMHe.png" alt="x1RMHe.png"></a></p><p><strong>TCP 接收窗口结构</strong></p><p><a target="_blank" rel="noopener" href="https://imgse.com/i/x1RlAH"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/10/06/x1RlAH.png" alt="x1RlAH.png"></a></p><p><strong>接收窗口的大小是根据接收端处理数据的速度动态调整的。</strong> 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。另外，这里的滑动窗口大小只是为了演示使用，实际窗口大小通常会远远大于这个值。</p><h3 id="TCP-的拥塞控制是怎么实现的？"><a href="#TCP-的拥塞控制是怎么实现的？" class="headerlink" title="TCP 的拥塞控制是怎么实现的？"></a>TCP 的拥塞控制是怎么实现的？</h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。</p><p>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。</p><p>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p><p><strong>拥塞控制</strong>是一个<strong>全局性</strong>的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。</p><p>相反，<strong>流量控制</strong>往往是<strong>点对点通信量的控制，是个端到端的问题</strong>。</p><p>流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p><a target="_blank" rel="noopener" href="https://imgse.com/i/x1RBNj"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/10/06/x1RBNj.png" alt="x1RBNj.png"></a></p><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。</p><p>拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。</p><p>发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。</p><p>在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><ul><li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li><li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.</li><li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li></ul><h3 id="ARQ-协议了解吗"><a href="#ARQ-协议了解吗" class="headerlink" title="ARQ 协议了解吗?"></a>ARQ 协议了解吗?</h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。</p><p>它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息（Acknoledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。</p><p>ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p><h4 id="停止等待-ARQ-协议"><a href="#停止等待-ARQ-协议" class="headerlink" title="停止等待 ARQ 协议"></a>停止等待 ARQ 协议</h4><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p><p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p><p><strong>1) 无差错情况:</strong></p><p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p><p><strong>2) 出现差错情况（超时重传）:</strong></p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p><p><strong>3) 确认丢失和确认迟到</strong></p><ul><li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li><li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li></ul><h4 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h4><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p><p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p><p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p><h2 id="HTTP★"><a href="#HTTP★" class="headerlink" title="HTTP★"></a>HTTP★</h2><blockquote><p>考察公司：美团、腾讯、百度、完美世界、中兴</p></blockquote><p>HTTP：<strong>超文本传输协议</strong>。</p><p><strong>HTTP是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><p><strong>请求报文包括：</strong></p><ul><li><strong>请求行</strong>：包括<strong>请求方法</strong>、<strong>请求的URL</strong>、<strong>HTTP协议及版本</strong>。</li><li><strong>请求头</strong>：一大堆的键值对。</li><li><strong>空行</strong>指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。</li><li><strong>请求体</strong>：数据部分。</li></ul><p>响应报文包括：</p><ul><li><strong>状态行</strong>：<strong>HTTP协议及版本</strong>、<strong>状态码</strong>及<strong>状态描述</strong>。</li><li><strong>响应头</strong></li><li><strong>空行</strong></li><li><strong>响应体</strong></li></ul><h3 id="HTTP状态码-★"><a href="#HTTP状态码-★" class="headerlink" title="HTTP状态码 ★"></a>HTTP状态码 ★</h3><p><strong>1xx</strong>类状态码属于<strong>提示信息</strong>，是协议处理中的一种<strong>中间状态</strong>，实际用到的比较少。</p><p><strong>2xx</strong>类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li><strong>200 OK</strong> 是最常见的成功状态码，表示一切正常。</li></ul><p><strong>3xx</strong>类状态码表示客户端请求的资源发送了变动，需要客户端用新的URL重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li><p><strong>301 Moved Permanently</strong> 表示<strong>永久重定向</strong>，说明请求的资源已经不存在了，需改用新的URL再次访问。</p></li><li><p><strong>302 Found</strong> 表示<strong>临时重定向</strong>，说明请求的资源还在，但暂时需要用另一个URL来访问。</p><ul><li><strong>301</strong>和<strong>302</strong>都会在响应头里使用字段<strong>Location</strong>，指明后续要跳转的URL，浏览器会自动重定向新的URL。</li></ul></li><li><p><strong>304 Not Modified</strong> 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称<strong>缓存重定向</strong>，用于缓存控制。</p></li></ul><p><strong>4xx</strong>类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是<strong>错误码</strong>的含义。</p><ul><li><strong>400 Bad Request</strong> 表示客户端请求的报文有错误，但只是个笼统的错误</li><li><strong>403 Forbidden</strong> 表示<strong>服务器禁止访问资源</strong>，并不是客户端的请求出错。</li><li><strong>404 Not Found</strong> 表<strong>示请求的资源在服务器上不存在或未找到</strong>，所以无法提供给客户端。</li></ul><p><strong>5xx</strong>类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于<strong>服务器端的错误码</strong>。</p><p>项目静态网页状态码 <code>404 &amp; 405</code></p><p><strong>405 Method Not Allowed</strong>表明服务器禁止了使用当前 HTTP 方法的请求。绝大多数web服务器，都不允许静态文件响应POST请求。</p><h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><p><strong>根据场景合理使用各个方法，可以起到优化性能、增加网络安全的效果。</strong></p><h4 id="GET-与-POST-★"><a href="#GET-与-POST-★" class="headerlink" title="GET 与 POST ★"></a>GET 与 POST ★</h4><p><code>GET</code>方法的含义是<strong>请求从服务器获取资源</strong>，这个资源可以是静态的文本、页面、图片视频等。</p><p>而<code>POST</code>方法则是相反操作，它向<code>URI</code>指定的资源提交数据，数据就放在报文的<code>body</code>里。</p><h5 id="参数传递方式"><a href="#参数传递方式" class="headerlink" title="参数传递方式"></a>参数传递方式</h5><ul><li>GET 的参数一般是通过 <code>?</code> 跟在 URL 后面的，多个参数通过 <code>&amp;</code> 连接</li><li>POST 的参数一般是包含在请求体中。</li></ul><h5 id="参数长度限制不同"><a href="#参数长度限制不同" class="headerlink" title="参数长度限制不同"></a>参数长度限制不同</h5><p>GET 和 POST 传递参数的长度不同：</p><ul><li>get传送的数据量较小，不能大于2KB。</li><li>post传送的数据量较大，一般被默认为不受限制。</li></ul><p>在这里我们要明确一点：<strong>HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。</strong></p><p>服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。</p><h5 id="安全和幂等"><a href="#安全和幂等" class="headerlink" title="安全和幂等"></a>安全和幂等</h5><ul><li>在HTTP 协议里，<strong>所谓的「安全」是指请求方法不会「破坏」服务器上的资源</strong>。</li><li><strong>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</strong></li></ul><p>那么很明显<strong>GET方法就是安全且幂等</strong>的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</p><p><strong>POST</strong>因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等的</strong>。</p><h5 id="安全性不同（传输的角度）"><a href="#安全性不同（传输的角度）" class="headerlink" title="安全性不同（传输的角度）"></a>安全性不同（传输的角度）</h5><p>因为参数传递方式的不同，所以 GET 和 POST 的安全性不同：GET 比 POST 更不安全，因为参数直接暴露在URL上，所以 GET 不能用来传递敏感信息。</p><blockquote><p>从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上抓包，就能完整地获取数据报文，要想安全传输，就只有加密，也就是 HTTPS。</p></blockquote><h5 id="缓存机制不同"><a href="#缓存机制不同" class="headerlink" title="缓存机制不同"></a>缓存机制不同</h5><p>这个需要从以下几点来说明：</p><ul><li>GET 请求会<strong>被浏览器主动cache</strong>，而 POST 不会，除非手动设置。</li><li>GET 请求参数<strong>会被完整保留在浏览器历史记录里</strong>，而 POST 中的参数不会被保留。</li><li>GET 在<strong>浏览器回退时是无害的</strong>，而 POST 会再次提交请求。</li></ul><h5 id="时间消耗不同"><a href="#时间消耗不同" class="headerlink" title="时间消耗不同"></a>时间消耗不同</h5><p>GET 和 POST 请求时间的不同主要是因为：</p><ul><li>GET 产生<strong>一个</strong> TCP 数据包；</li><li>POST 产生<strong>两个</strong> TCP 数据包。</li></ul><p>对于 GET 方式的请求，浏览器会把 <strong>header 和 data</strong> 一并发送出去，服务器响应 200（返回数据）；而对于 POST，浏览器先发送 <strong>header</strong>，服务器响应 <strong>100 continue</strong>，浏览器再发送 <strong>data</strong>，服务器响应 200 ok（返回数据）。</p><p>在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，<strong>两次包的TCP在验证数据包完整性上，有非常大的优点</strong>。</p><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将不传回资源的本文部分，只返回<strong>头部消息</strong>。</p><p>HEAD 方法的使用场景</p><ul><li>在不获取资源的情况下，了解资源的一些信息，比如资源类型；</li><li>通过查看响应中的状态码，可以确定资源是否存在；</li><li>通过查看首部，测试资源是否被修改。</li></ul><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>PUT 方法用于将数据发送到服务器来创建/更新资源。</p><p>PUT 与 POST 方法的区别在于，<strong>PUT 方法是幂等的</strong>：<strong>调用一次与连续调用多次是等价的（即没有副作用）</strong>。</p><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>DELETE 方法就是请求服务器删除指定 URL 所对应的资源。</p><h3 id="HTTP头部"><a href="#HTTP头部" class="headerlink" title="HTTP头部"></a>HTTP头部</h3><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p><strong><code>Accept</code></strong> 请求头用来告知（服务器）客户端可以处理的内容类型，这种内容类型用MIME 类型来表示。借助内容协商机制，服务器可以从诸多备选项中选择一项进行应用，并使用 <code>Content-Type</code>应答头通知客户端它的选择。浏览器会基于请求的上下文来为这个请求头设置合适的值，比如获取一个 CSS 层叠样式表时值与获取图片、视频或脚本文件时的值是不同的。</p><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p><strong>Connection</strong> 头（header） 决定当前的事务完成后，是否会关闭网络连接。如果该值是“keep-alive”，网络连接就是持久的，不会关闭，使得对同一个服务器的请求可以继续在该连接上完成。</p><p><strong>备注：</strong> 特定于连接的标头字段（例如 Connection）不得与 HTTP/2 一起使用。</p><p>以逗号分隔的 HTTP 头 [通常仅有 <code>keep-alive</code>]</p><p>表明客户端想要保持该网络连接打开，HTTP/1.1 的请求默认使用一个持久连接。这个请求头列表由头部名组成，这些头将被第一个非透明的代理或者代理间的缓存所移除：这些头定义了发出者和第一个实体之间的连接，而不是和目的地节点间的连接。</p><h4 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h4><p><strong><code>Keep-Alive</code></strong> 是一个通用消息头，允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数。</p><p><strong>备注：</strong> 需要将 <code>Connection</code>]首部的值设置为 “keep-alive” 这个首部才有意义。同时需要注意的是，在 HTTP/2 协议中， <code>Connection</code>和<code>Keep-Alive</code> 是被忽略的；在其中采用其他机制来进行连接管理。</p><p><em>parameters</em></p><p>一系列用逗号隔开的参数，每一个参数由一个标识符和一个值构成，并使用等号 (<code>&#39;=&#39;</code>) 隔开。下述标识符是可用的：</p><ul><li><code>timeout</code>：指定了一个空闲连接需要保持打开状态的最小时长（以秒为单位）。需要注意的是，如果没有在传输层设置 keep-alive TCP message 的话，大于 TCP 层面的超时设置会被忽略。</li><li><code>max</code>：在连接关闭之前，在此连接可以发送的请求的最大值。在非管道连接中，除了 0 以外，这个值是被忽略的，因为需要在紧跟着的响应中发送新一次的请求。HTTP 管道连接则可以用它来限制管道的使用。</li></ul><h3 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h3><p><strong>简单<code>header（key-value） + body</code>、灵活和易于扩展（应用层(OSI第七层)，下层可随意变化）、应用广泛和跨平台</strong>。</p><p><strong>无状态</strong></p><ul><li><strong>不需要额外的资源来记录状态信息</strong></li><li>完成<strong>有关联性的操作</strong>时会非常麻烦</li></ul><p><strong>明文传输</strong></p><ul><li><strong>调试</strong>工作带了极大的便利性</li><li>毫<strong>无隐私</strong>可言，很容易就能被<strong>窃取</strong></li></ul><p>HTTP比较严重的缺点就是<strong>不安全:</strong></p><ul><li>**通信使用明文（不加密)**，内容可能会被窃听。</li><li><strong>不验证通信方的身份</strong>，因此有可能遭遇伪装。</li><li><strong>无法证明报文的完整性</strong>，所以有可能已遭篡改。</li></ul><p>HTTP的安全问题，可以用<strong>HTTPS</strong>的方式解决，也就是通过引入<strong>SSL/TLS</strong>层，使得在安全上达到了极致。</p><h3 id="HTTP和HTTPS-★"><a href="#HTTP和HTTPS-★" class="headerlink" title="HTTP和HTTPS  ★"></a>HTTP和HTTPS ★</h3><ul><li>HTTP是<strong>超文本传输协议</strong>，信息是<strong>明文传输</strong>，存在安全风险的问题。HTTPS则解决HTTP不安全的缺陷，<strong>在TCP和HTTP之间加入了SSL/TLS安全协议</strong>，使得报文能够<strong>加密</strong>传输。</li><li>HTTP 连接建立相对简单，<strong>TCP三次握手</strong>之后便可进行HTTP的报文传输。而 HTTPS在<strong>TCP三次握手</strong>之后，还需进行<strong>SSL/TLS的握手</strong>过程，才可进入加密报文传输。</li><li>HTTP的端口号是<strong>80</strong>，HTTPS的端口号是<strong>443</strong>。</li><li>HTTPS 协议需要<strong>向CA(证书权威机构）申请数字证书</strong>，来保证服务器的身份是可信的。</li></ul><blockquote><p>SSL和TLS？</p></blockquote><p>这两实际上是一个东西。很多相关的文章都把这两者并列称呼(SSL/TLS)，因为这两者可以视作<strong>同一个东西的不同阶段</strong>。</p><h4 id="HTTPS优点"><a href="#HTTPS优点" class="headerlink" title="HTTPS优点"></a>HTTPS优点</h4><h5 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h5><p>HTTPS采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的<strong>混合加密</strong>方式，保证信息的<strong>机密性</strong>，解决了窃听的风险:</p><ul><li>在<strong>通信建立前</strong>采用<strong>非对称加密</strong>的方式<strong>交换</strong>「会话秘钥」，后续就不再使用非对称加密。</li><li>在<strong>通信过程中</strong>全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul><p>采用「混合加密」的方式的原因:</p><blockquote><p>对称加密：加密和解密使用的是同一个密钥。</p><p>RSA（非对称加密算法）：双方必须协商一对密钥，一个私钥一个公钥。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。</p></blockquote><p>对称加密运算速度快，但最开始仍可能被拦截，发送信息依然不安全，非对称加密足够安全，但运算速度慢。</p><p><strong>使用非对称加密的方法将加密算法的对称密钥发送过去</strong>，之后就可以使用使用这个密钥，利用<strong>对称密钥</strong>来通信了。</p><h5 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h5><p><strong>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</strong></p><p><strong>如何保证公钥不被篡改和信任度?</strong></p><p>所以这里就需要借助第三方权威机构<code>CA</code>(数字证书认证机构)﹐将<strong>服务器公钥放在数字证书</strong>（由数字证书认证机构颁发)中，只要证书是可信的，公钥就是可信的。</p><h5 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h5><p><strong>摘要算法</strong>用来实现<strong>完整性</strong>，能够为数据生成独一无二的<strong>指纹</strong>﹐用于校验数据的完整性，解决了<strong>篡改</strong>的风险。</p><p>客户端在发送明文之前会通过<strong>摘要算法</strong>算出明文的<strong>指纹</strong>，发送的时候把<strong>指纹＋明文</strong>一同加密成密文后，发送给服务器，服务器解密后，用<strong>相同的摘要算法</strong>算出发送过来的明文，通过比较客户端携带的<strong>指纹</strong>和当前算出的<strong>指纹</strong>做比较，若<strong>指纹</strong>相同，说明数据是完整的。</p><h4 id="HTTPS连接"><a href="#HTTPS连接" class="headerlink" title="HTTPS连接"></a>HTTPS连接</h4><p><strong>https采用非对称加密+对称加密，非对称加密来传递密钥；对称加密来加密内容</strong></p><ul><li>客户端使用https的url访问web服务器，要求与服务器建立ssl连接</li><li>服务器收到客户端请求后, 会将**网站的证书(包含公钥)**传送一份给客户端</li><li>客户端收到网站证书后会检查证书的<strong>颁发机构以及过期时间</strong>, 如果没有问题就<strong>随机产生一个秘钥</strong></li><li>客户端利用<strong>公钥将会话秘钥加密</strong>, 并传送给服务端</li><li>服务端利用自己的<strong>私钥</strong>解密出会话秘钥，之后服务器与客户端使用秘钥加密传输</li></ul><p>整个SSL/TLS的握手阶段全部结束后，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用<strong>会话秘钥加密内容。</strong></p><p>SSL/TLS 1.2需要4次握手，SSL/TLS 1.3优化了过程，<strong>只需要3次握手</strong>。</p><h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><p><strong>中间人攻击过程如下：</strong></p><p>1）客户端向服务器发送建立连接的请求<br>2）服务器向客户端发送<strong>公钥</strong><br>3）<strong>攻击者截获公钥</strong>，保留在自己手上<br>4）然后攻击者自己生成一个<strong>【伪造的】公钥</strong>，发给客户端<br>5）客户端收到伪造的公钥后，生成加密的秘钥值发给服务器<br>6）攻击者获得加密秘钥，用自己的私钥解密获得秘钥<br>7）同时生成假的加密秘钥，发给服务器<br>8）服务器用私钥解密获得假秘钥<br>9）服务器用假秘钥加密传输信息</p><p><strong>防范方法：</strong></p><p>服务端在发送浏览器的<strong>公钥中加入CA证书</strong>，<strong>浏览器可以验证CA证书的有效性</strong>。</p><h4 id="浏览器如何验证ca证书的有效性"><a href="#浏览器如何验证ca证书的有效性" class="headerlink" title="浏览器如何验证ca证书的有效性"></a>浏览器如何验证ca证书的有效性</h4><p>浏览器读取证书中的证书所有者、有效期等信息进行校验</p><p>1）校验证书的网站域名是否与证书颁发的<strong>域名一致</strong>。</p><p>2）校验证书是否在<strong>有效期</strong>内。</p><p>3）浏览器查找<strong>操作系统中已内置的受信任的证书发布机构</strong>，与服务器发来的证书中的颁发者做比对，用于校验证书是否为合法机构颁发。</p><h3 id="HTTP-1-1、HTTP-2、HTTP-3演变-★"><a href="#HTTP-1-1、HTTP-2、HTTP-3演变-★" class="headerlink" title="HTTP/1.1、HTTP/2、HTTP/3演变  ★"></a>HTTP/1.1、HTTP/2、HTTP/3演变 ★</h3><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><p>HTTP/1.1相比HTTP/1.0性能上的改进︰</p><ul><li>使用TCP<strong>长连接</strong>的方式改善了<strong>HTTP/1.0短连接</strong>造成的性能开销。<ul><li><strong>减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载</strong>。</li><li><strong>只要任意一端没有明确提出断开连接，则保持TCP连接状态。</strong></li></ul></li><li>支持<strong>管道（pipeline)网络传输</strong>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li><li>缓存<code>Etag</code></li></ul><p>但HTTP/1.1还是有性能瓶颈︰</p><ul><li><strong>请求/响应头部(Header)未经压缩就发送</strong>，首部信息越多延迟越大。只能压缩<code>Body</code>的部分;</li><li><strong>服务器是按请求的顺序响应的</strong>，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>;</li><li><strong>没有请求优先级控制</strong>;</li><li>请求只能从客户端开始，<strong>服务器只能被动响应</strong>。</li></ul><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p><strong>HTTP/2协议是大多基于HTTPS的，所以HTTP/2的安全性也是有保障的。</strong></p><p>那HTTP/2相比HTTP/1.1 性能上的改进︰</p><ul><li><strong>头部压缩</strong>（HPACK算法）</li><li><strong>二进制格式</strong> 增加了数据传输的效率</li><li><strong>数据流</strong><ul><li>HTTP/2的数据包<strong>不是按顺序发送的</strong>，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</li><li>每个请求或回应的所有数据包，称为一个数据流（<strong>Stream</strong> )。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。</li><li>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</li></ul></li><li><strong>多路复用</strong><ul><li>HTTP/2是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。</li><li>移除了HTTP/1.1中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。</li></ul></li><li><strong>服务器推送</strong><ul><li>HTTP/2还在一定程度上改善了传统的「请求-应答」工作模式，服务不再是被动地响应，<strong>也可以主动向客户端发送消息</strong>。</li><li>举例来说，在浏览器刚请求HTML的时候，就提前把可能会用到的JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送(<strong>Server Push</strong>，也叫<strong>Cache Push</strong>)。</li></ul></li></ul><h4 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h4><p>HTTP/2主要的问题在于，<strong>多个HTTP请求在复用一个TCP连接</strong>，下层的TCP协议是不知道有多少个HTTP请求的。</p><p>所以<strong>一旦发生了丢包现象，就会触发TCP的重传机制</strong>，这样在一个TCP连接中的<strong>所有的HTTP请求都必须等待这个丢了的包被重传回来</strong>。</p><ul><li>HTTP/1.1中的管道（pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了。</li><li>HTTP/2多个请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的HTTP请求。</li></ul><p>这都是<strong>基于TCP传输层</strong>的问题，所以<strong>HTTP/3把HTTP下层的TCP协议改成了UDP</strong>!</p><p>UDP是<strong>不管顺序，也不管丢包的</strong>，所以<strong>不会出现HTTP/1.1的队头阻塞和HTTP/2的一个丢包全部重传问题</strong>。</p><p>大家都知道UDP是不可靠传输的，但<strong>基于UDP的QUIC协议可以实现类似TCP的可靠性传输</strong>。</p><ul><li>QUIC有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，<strong>其他流不会受到影响</strong>。</li><li>TLS3升级成了最新的<strong>1.3</strong>版本，头部压缩算法也升级成了<strong>QPack</strong> 。</li><li>HTTPS要建立一个连接，要花费6次交互，先是建立三次握手，然后是TLS/1.3的三次握手。QUIC直接把以往的TCP和 TLS/1.3的6次交互<strong>合并成了3次，减少了交互次数</strong>。</li></ul><p>所以，QUIC是一个在UDP之上的<strong>伪</strong>TCP+ TLS+ HTTP/2的多路复用的协议。</p><p>QUIC是新协议，对于很多网络设备，根本不知道什么是QUIC，只会当做UDP，这样会出现新的问题。所以HTTP/3现在普及的进度非常的缓慢，不知道未来UDP是否能够逆袭TCP。</p><p>QUIC 全称：Quick UDP Internet Connections，是一种基于 UDP 的传输层协议。由 Google 自研，2012 年部署上线，2013 年提交 IETF，2021 年 5 月，IETF 推出标准版 RFC9000。</p><p>从协议栈可以看出：QUIC = HTTP/2 + TLS + UDP</p><h2 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h2><h3 id="中间人劫持"><a href="#中间人劫持" class="headerlink" title="中间人劫持"></a>中间人劫持</h3><p>起因是这样，https 使用的是 443 端口进行数据传输，而浏览器的默认端口是 80. 劫持者首先劫持用户的 80 端口，当用户向目标页发起请求时，劫持者模拟正常的 https 请求向源服务器获取数据，然后通过 80 端口返回给用户。</p><p>用户一般不会在地址栏输入 <code>//www.taobao.com</code>，而是习惯性输入 <code>taobao.com</code> ，此时浏览器走的是 http，请求到达服务器之后，服务器告诉浏览器 302 跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Location: //www.taobao.com</span><br></pre></td></tr></table></figure><p>然后浏览器重新请求，通过 HTTPS 方式，443 端口通讯。而正因为用户不是直接输入 <code>//</code> 链接，劫持者利用这一点：</p><p>只要能够劫持你的网络，比如路由劫持、DNS劫持，就可以作为中间人注入代码、替换广告。。。</p><p>这种劫持出现在两种情况下：</p><ul><li>用户没有通过准确的方式访问页面，除非输入 <code>//</code> ，否则浏览器默认以 <code>http</code> 方式访问</li><li>HTTPS 页面的链接中包含 http，这个 http 页面可能被劫持</li></ul><h3 id="启用-HSTS"><a href="#启用-HSTS" class="headerlink" title="启用 HSTS"></a>启用 HSTS</h3><p>HSTS，HTTP Strict Transport Security，简单说就是<strong>强制客户端使用 HTTPS 访问页面</strong>。其原理就是：</p><ul><li>在服务器响应头中添加 <code>Strict-Transport-Security</code>，可以设置 <code>max-age</code></li><li>用户访问时，服务器种下这个头</li><li>下次如果使用 http 访问，只要 max-age 未过期，客户端会进行内部跳转，可以看到 <code>307 Redirect Internel</code> 的响应码</li><li>变成 https 访问源服务器</li></ul><p>这个过程有效避免了中间人对 80 端口的劫持。但是这里存在一个问题：如果用户在劫持状态，并且没有访问过源服务器，那么源服务器是没有办法给客户端种下 <code>Strict-Transport-Security</code> 响应头的（都被中间人挡下来了）。</p><p>启用 HSTS 不仅仅可以有效防范中间人攻击，同时也为浏览器节省来一次 302/301 的跳转请求，收益还是很高的。我们的很多页面，难以避免地出现 http 的链接，比如 help 中的链接、运营填写的链接等，这些链接的请求都会经历一次 302，对于用户也是一样，收藏夹中的链接保存的可能也是 http 的。</p><h3 id="307-状态码"><a href="#307-状态码" class="headerlink" title="307 状态码"></a>307 状态码</h3><p>在 GET、HEAD 这些幂等的请求方式上，302、303、307 没啥区别，而对于 POST 就不同了，大部分浏览器 都会302 会将 POST 请求转为 GET，而 303 是规范强制规定将 POST 转为 GET 请求，请求地址为 header 头中的 <code>Location</code>，307 则不一样，规范要求浏览器继续向 Location 的地址 POST 内容。</p><p>而在 HSTS 中，307 可以被缓存，缓存时间根据 max-age 而定，一般建议缓存 1 年甚至更长。</p><h3 id="HSTS-存在的坑"><a href="#HSTS-存在的坑" class="headerlink" title="HSTS 存在的坑"></a>HSTS 存在的坑</h3><ul><li>纯 IP 的请求，HSTS 没法处理，比如 <code>http://2.2.2.2</code> ， 即便响应头中设置了 STS，浏览器也不会理会（未测试）</li><li>HSTS 只能在 80 和 443 端口之间切换，如果服务是 8080 端口，即便设置了 STS，也无效（未测试）</li><li>如果浏览器证书错误，一般情况会提醒存在安全风险，然是依然给一个链接进入目标页，而 HSTS 则没有目标页入口，所以一旦证书配置错误，就是很大的故障了</li><li>如果服务器的 HTTPS 没有配置好就开启了 STS 的响应头，并且还设置了很长的过期时间，那么在你服务器 HTTPS 配置好之前，用户都是没办法连接到你的服务器的，除非 max-age 过期了。</li><li>HSTS 能让你的网站在 ssllab 上到 A+（这不是坑）</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>HSTS 在全站 https 下有一个较大的正向作用，推荐使用。</p><p>P.S：在 Chrome 中打开 <code>chrome://net-internals/#hsts</code>，添加域名之后，可以让浏览器强制对该域名启用 https，所有的 http 请求都会内部转到 https。</p><h2 id="为什么端口号最大为65535？★"><a href="#为什么端口号最大为65535？★" class="headerlink" title="为什么端口号最大为65535？★"></a>为什么端口号最大为65535？★</h2><p>端口是 TCP/IP 协议中，IP 层的一个概念。</p><p>在 IP 层（也就是网络层），远程通信的两个节点，通过端口找到对应的处理程序。</p><p>而 IP 协议中端口是一个 2字节的 unsighed char 的长度，其最大值是 2^16 -1 = 65535</p><p>此时端口的字段用二进制表示为16个1： 1111,1111,1111,1111</p><p>TCP/IP协议中的服务端口，端口号由16位构成，可分配的端口号范围是0~65535。这些端口号分为知名端口号以及动态端口号。其中，知名端口号（Well-Known Ports）默认是不可使用，范围从0到1023，这些端口号一般固定分配给一些系统服务。动态端口号（Dynamic Ports），范围从1024到65535可以随机分配给某些网络或系统服务。</p><p>端口0：一般是用来表示所有端口，即1–65535。</p><p>另外其他答主也提到1–1024是知名端口号，但那是很久以前数据，是该更新了。举几个大于1024的知名端口号：</p><blockquote><p>1614/1615：思科ISE用于AAA的端口号<br>1812/1813：Radius服务器使用的端口号<br>3306：数据库mysql使用的端口号<br>3389：微软Windows远程桌面使用的端口号<br>8080：一般的应用服务器使用的端口号，例如tomcat</p></blockquote><p>因此，还觉得知名端口号，范围是1–1024吗？在实际使用中，</p><blockquote><p>对于tcp，客户端使用的临时端口号，一般都是大于10000的。<br>对于udp，客户端使用的临时端口号，可以从大于10000中选，也可以使用跟服务器一样的端口号。</p></blockquote><h2 id="跨域通信★"><a href="#跨域通信★" class="headerlink" title="跨域通信★"></a>跨域通信★</h2><blockquote><p>考察公司：完美世界、字节、美团、百度、腾讯</p></blockquote><h3 id="同源-跨域"><a href="#同源-跨域" class="headerlink" title="同源/跨域"></a>同源/跨域</h3><p><strong>同源策略</strong>：用于隔离潜在恶意文件的安全机制。</p><p>同源是指”<strong>协议</strong>+<strong>域名</strong>+<strong>端口</strong>“三者相同，<strong>即便两个不同的域名指向同一个ip地址，也非同源</strong>。</p><p><strong>同源策略限制内容有：</strong></p><ul><li><code>Cookie</code>、<code>LocalStorage</code>、<code>IndexedDB</code> 等存储性内容</li><li><code>DOM</code> 节点</li><li><code>AJAX</code> 请求</li></ul><p>但是有的标签是允许跨域加载资源：</p><ul><li><code>&lt;img src=XXX&gt;</code></li><li><code>&lt;link href=XXX&gt;</code></li><li><code>&lt;script src=XXX&gt;</code></li></ul><p>当协议、域名、端口号中任意一个不相同时，都算作不同域。</p><p><strong>不同域之间相互请求资源，就算作“跨域”</strong>。</p><p>跨域并<strong>不是请求发不出去</strong>，请求能发出去，服务端能收到请求并正常返回结果，只是结果<strong>被浏览器拦截</strong>了。</p><h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h3><h4 id="JSONP（JSON-with-Padding）"><a href="#JSONP（JSON-with-Padding）" class="headerlink" title="JSONP（JSON with Padding）"></a>JSONP（JSON with Padding）</h4><p>JS函数包裹JSON数据。</p><p>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。</p><p>JSONP请求一定需要对方的服务器做支持才可以。</p><p><code>&lt;script&gt;</code> 标签中type的默认属性是<code>text/javascript</code>,<strong>会把收到的文本内容当成JS代码进行执行</strong>。</p><p>优点：简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。</p><p>缺点：仅支持<code>get</code>方法；不安全，可能会遭受<code>XSS</code>攻击。</p><p><strong>JSONP的实现流程</strong></p><ul><li>声明一个回调函数，将函数名(如<code>handle</code>)当做参数值传递给跨域请求数据的服务器，函数形参为要获取的目标数据(服务器返回的<code>data</code>)。</li><li>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给<code>&lt;script&gt;</code>的<code>src</code>，还要在这个地址中向服务器传递该函数名（可以通过问号传参:<code>?callback=handle</code>）。</li><li>服务器接收到请求后，需要进行特殊的处理：把<strong>传递进来的函数名</strong>和它需要给你的<strong>数据</strong>拼接成一个<strong>字符串</strong>（模板字符串）。</li><li>最后服务器把该字符串返回给客户端，客户端接收到后相当于执行之前声明的回调函数（<code>handle</code>），对返回的数据进行操作。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Live Sever  本地服务器</span></span><br><span class="line"><span class="comment">//获取 input和p元素</span></span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="comment">//声明回调函数 接收后台返回数据</span></span><br><span class="line"><span class="comment">//注意  jsonp返回的数据是json对象可以直接使用</span></span><br><span class="line"><span class="comment">// 例如服务器的json字符串为 &#x27;&#123;&quot;msg&quot;:&quot;用户名设置成功&quot;&#125;&#x27;</span></span><br><span class="line"><span class="comment">// 实际返回的字符串 &#x27;handle(&#123;&quot;msg&quot;:&quot;用户名设置成功&quot;&#125;)&#x27;</span></span><br><span class="line"><span class="comment">// 浏览器接收后，执行handle(&#123;&quot;msg&quot;:&quot;用户名设置成功&quot;&#125;)</span></span><br><span class="line"><span class="comment">// 此时的参数就是一个json对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//修改 p 标签的提示文本</span></span><br><span class="line">    p.innerHTML = data.msg;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取用户的输入值</span></span><br><span class="line">    <span class="keyword">let</span> username = input.value;</span><br><span class="line">    <span class="built_in">console</span>.log(username)</span><br><span class="line">    <span class="comment">//向服务器端发送请求 检测用户名是否存在</span></span><br><span class="line">    <span class="comment">//1. 创建 script 标签</span></span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    <span class="comment">//2. 设置标签的 src 属性</span></span><br><span class="line">    script.src = <span class="string">`http://127.0.0.1:8000/jsonp-server?name=<span class="subst">$&#123;username&#125;</span>&amp;callback=handle`</span>;</span><br><span class="line">    <span class="comment">//3. 将 script 插入到文档中</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 服务器</span></span><br><span class="line"><span class="comment">//1. 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">//2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="comment">//3. 创建路由规则</span></span><br><span class="line"><span class="comment">// request 是对请求报文的封装</span></span><br><span class="line"><span class="comment">// response 是对响应报文的封装</span></span><br><span class="line"><span class="comment">//jsonp服务</span></span><br><span class="line"><span class="keyword">const</span> username=[];</span><br><span class="line">app.all(<span class="string">&#x27;/jsonp-server&#x27;</span>,<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;name,callback&#125; = request.query;</span><br><span class="line">    <span class="keyword">const</span> data = &#123;<span class="attr">msg</span>:<span class="string">&quot;用户名设置成功&quot;</span>&#125;;      </span><br><span class="line">    username.includes(name) ? data.msg=<span class="string">&quot;用户名已存在&quot;</span> : username.push(name);</span><br><span class="line">    <span class="built_in">console</span>.log(username)</span><br><span class="line">    <span class="comment">//将数据转化为字符串</span></span><br><span class="line">    <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    response.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 监听端口启动服务</span></span><br><span class="line">app.listen(<span class="number">8000</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务已经启动, 8000 端口监听中....&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS（Cross-Origin Resource Sharing），跨域资源共享。</p><p>CORS是官方的跨域解决方案，需要浏览器和后端同时支持。</p><p>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 CORS。</p><p>该属性表示哪些域名可以访问资源，如果设置通配符<code>*</code>则表示所有网站都可以访问资源。</p><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><ul><li>请求方法是 <code>HEAD</code>、<code>GET</code>、<code>POST</code> 三种之一；</li><li>HTTP 头信息不超过右边着几个字段：<ul><li><code>Accept</code>、</li><li><code>Accept-Language</code>、</li><li><code>Content-Language</code>、</li><li><code>Last-Event-ID</code></li><li><code>Content-Type</code> 只限于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>；</li></ul></li></ul><p>需要这些条件是为了<strong>兼容表单</strong>，因为历史上表单一直可以跨域。</p><p>浏览器直接发出<strong>CORS请求</strong>，具体来说就是在头信息中增加<code>Origin</code>字段，表示请求来源来自哪个域(协议+域名+端口)，服务器根据这个值决定是否同意请求。如果同意，返回的响应会多出以下响应头信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//juejin.com // 和 Orign 一致  这个字段是必须的</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span> <span class="comment">// 表示是否允许发送 Cookie  这个字段是可选的</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar <span class="comment">// 指定返回其他字段的值   这个字段是可选的</span></span><br></pre></td></tr></table></figure><p>在简单请求中服务器至少需要设置：<code>Access-Control-Allow-Origin</code> 字段。</p><h5 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h5><ul><li><p>不符合以上条件的请求，比如请求方法是 <code>PUT</code> 或 <code>DELETE</code>，或 <code>Content-Type</code> 值为 <code>application/json</code>。</p></li><li><p>浏览器会在正式通信之前，发送一次 <strong>HTTP 预检</strong> <code>OPTIONS</code> 请求，先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 请求方法和头信息字段（服务器返回的响应头会包含允许的域名、方法等）。只有得到肯定答复，浏览器才会发出正式的 <code>XHR</code> 请求，否则报错。</p></li><li><p>预检请求的方法是<code>OPTIONS</code>，它的头信息中有几个字段</p><ul><li><code>Origin</code>: 表示请求来自哪个域，这个字段是必须的</li><li><code>Access-Control-Request-Method</code>：列出CORS请求会用到哪些HTTP方法，这个字段是必须的</li><li><code>Access-Control-Request-Headers</code>： 指定CORS请求会额外发送的头信息字段，用逗号隔开</li></ul></li><li><p>OPTIONS请求次数过多也会损耗性能，所以要尽量减少OPTIONS请求，可以让服务器在请求返回头部添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Max-Age: <span class="built_in">Number</span> <span class="comment">// 数字 单位是秒</span></span><br></pre></td></tr></table></figure><p>表示<strong>预检请求的返回结果可以被缓存多久</strong>，在这个时间范围内再请求就不需要预检了。不过这个缓存只对完全一样的URL才会生效。</p></li></ul><h5 id="关于CORS的-cookie-问题"><a href="#关于CORS的-cookie-问题" class="headerlink" title="关于CORS的 cookie 问题"></a>关于CORS的 cookie 问题</h5><p>想要传递 <code>cookie</code> 需要满足 3 个条件</p><ul><li>web 请求设置<code>withCredentials</code></li></ul><p>这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 <code>withCredentials</code> 来进行传递 <code>cookie</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 xml 的设置方式</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// axios 设置方式</span></span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li><code>Access-Control-Allow-Credentials</code> 为 <code>true</code></li><li><code>Access-Control-Allow-Origin</code>为<strong>非</strong> <code>*</code></li></ul><h5 id="CORS完整复杂请求的例子"><a href="#CORS完整复杂请求的例子" class="headerlink" title="CORS完整复杂请求的例子"></a>CORS完整复杂请求的例子</h5><p>客户端 <code>http://127.0.0.1:5500</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="built_in">document</span>.cookie=<span class="string">&quot;name=leslie&quot;</span>;<span class="comment">// cookie不能跨域</span></span><br><span class="line">    xhr.withCredentials=<span class="literal">true</span>;<span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">    xhr.open(<span class="string">&#x27;PUT&#x27;</span>,<span class="string">&#x27;http://127.0.0.1:8000/cors&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">    xhr.setRequestHeader(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;leslie&#x27;</span>);</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((xhr.status&gt;=<span class="number">200</span> &amp;&amp; xhr.status&lt;<span class="number">300</span>) || xhr.status === <span class="number">304</span>)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(xhr.response);</span><br><span class="line">                <span class="comment">//得到响应头，后台需设置Access-Control-Expose-Headers</span></span><br><span class="line">                <span class="built_in">console</span>.log(xhr.getResponseHeader(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>服务器 <code>http://127.0.0.1:8000</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">//2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="comment">// 把server.js文件所在的目录设置为静态文件目录</span></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line"><span class="comment">//3. 创建路由规则</span></span><br><span class="line"><span class="comment">// request 是对请求报文的封装</span></span><br><span class="line"><span class="comment">// response 是对响应报文的封装</span></span><br><span class="line"><span class="comment">//CORS</span></span><br><span class="line"><span class="keyword">let</span> whitList = [<span class="string">&#x27;http://127.0.0.1:5500&#x27;</span>] <span class="comment">//设置白名单</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> origin = req.headers.origin</span><br><span class="line">    <span class="keyword">if</span> (whitList.includes(origin)) &#123;</span><br><span class="line">        <span class="comment">// 设置哪个源可以访问我</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, origin)</span><br><span class="line">        <span class="comment">// 允许携带哪个头访问我</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        <span class="comment">// 允许哪个方法访问我</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>)</span><br><span class="line">        <span class="comment">// 允许携带cookie</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">        <span class="comment">// 预检的存活时间</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Max-Age&#x27;</span>, <span class="number">6</span>)</span><br><span class="line">        <span class="comment">// 允许返回的头</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (req.method === <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">            res.end() <span class="comment">// OPTIONS请求不做任何处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.put(<span class="string">&#x27;/cors&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.headers)</span><br><span class="line">    res.setHeader(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;lw&#x27;</span>) <span class="comment">//返回一个响应头，后台需设置</span></span><br><span class="line">    res.end(<span class="string">&#x27;我不爱你&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//4. 监听端口启动服务</span></span><br><span class="line">app.listen(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务已经启动, 8000 端口监听中....&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第三方中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>);</span><br><span class="line"><span class="comment">//2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="comment">//CORS</span></span><br><span class="line">app.use(</span><br><span class="line">  cors(&#123;</span><br><span class="line">    <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;http://127.0.0.1:5500&quot;</span>,</span><br><span class="line">    <span class="string">&quot;methods&quot;</span>: <span class="string">&quot;GET,HEAD,PUT,PATCH,POST,DELETE&quot;</span>,</span><br><span class="line">    <span class="string">&quot;allowedHeaders&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">    <span class="string">&quot;exposedHeaders&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">    <span class="string">&quot;credentials&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;maxAge&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="comment">// &quot;preflightContinue&quot;: true,</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>简单的说，一般给<strong>客户端</strong>做代理的都是正向代理，给<strong>服务器</strong>做代理的就是反向代理。</p><h5 id="Node中间件代理"><a href="#Node中间件代理" class="headerlink" title="Node中间件代理"></a>Node中间件代理</h5><p>同源策略是<strong>浏览器</strong>需要遵循的标准，而如果是<strong>服务器向服务器</strong>请求就无需遵循同源策略。</p><p>代理的思路为，<strong>利用服务端请求不会跨域的特性，让接口和当前站点同域</strong>。</p><h5 id="React中配置代理"><a href="#React中配置代理" class="headerlink" title="React中配置代理"></a>React中配置代理</h5><p>在<code>package.json</code>中追加如下配置 :<code>&quot;proxy&quot;:http://localhost:5000</code></p><p>setupProxy.js <code>http-proxy-middleware</code> 配置多个代理，可以灵活的控制请求是否走代理。</p><h5 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h5><p>配置一个代理服务器向服务器请求，再将数据返回给客户端，实质和CORS跨域原理一样，也需要配置请求响应头Access-Control-Allow-Origin等字段，只不过是在代理服务器配置。</p><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p><code>WebSocket</code>是<code>HTML5</code>的一个持久化的协议，它实现了<strong>浏览器与服务器的全双工通信</strong>，同时也是跨域的一种解决方案。</p><p><code>WebSocket</code>和<code>HTTP</code>都是<strong>应用层协议</strong>，都基于 <code>TCP</code> 协议。</p><p>但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。</p><p>同时，<code>WebSocket</code> 在建立连接时需要借助 <code>HTTP</code> 协议，连接建立好了之后 <code>client</code> 与 <code>server</code> 之间的双向通信就与 <code>HTTP</code> 无关了。</p><h5 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h5><p>客户端 <code>http://127.0.0.1:5500</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:4000&#x27;</span>);</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    socket.send(<span class="string">&#x27;我爱你&#x27;</span>);<span class="comment">//向服务器发送数据</span></span><br><span class="line">&#125;</span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data);<span class="comment">//接收服务器返回的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器 <code>http://localhost:4000</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);<span class="comment">//记得安装ws</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123;<span class="attr">port</span>:<span class="number">4000</span>&#125;);</span><br><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  ws.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    ws.send(<span class="string">`<span class="subst">$&#123;data&#125;</span>我不爱你`</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h4><p><code>postMessage</code>是<code>HTML5 XMLHttpRequest Level 2</code>中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li><strong>页面和其打开的新窗口</strong>的数据传递</li><li><strong>多窗口</strong>之间消息传递</li><li><strong>页面与嵌套的iframe</strong>消息传递</li></ul><p>上面三个场景的跨域数据传递。</p><p>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin, [transfer]);</span><br></pre></td></tr></table></figure><ul><li><code>message</code>: 将要发送到其他window的数据。</li><li><code>targetOrigin</code>:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”<code>*</code>“（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配<code>targetOrigin</code>提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li><li><code>transfer</code>(可选)：是一串和<code>message</code> 同时传递的 <code>Transferable</code> 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><h4 id="简单例子-1"><a href="#简单例子-1" class="headerlink" title="简单例子"></a>简单例子</h4><p>客户端 <code>http://127.0.0.1:5500</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 等它加载完触发一个事件 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内嵌在http://localhost:5500/index.html --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:8000&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">id</span>=<span class="string">&quot;frame&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;load()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;frame&#x27;</span>)</span></span><br><span class="line"><span class="javascript">            frame.contentWindow.postMessage(<span class="string">&#x27;我爱你&#x27;</span>, <span class="string">&#x27;http://localhost:4000&#x27;</span>) <span class="comment">//发送数据</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; <span class="comment">//接受返回数据</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(e.data) <span class="comment">//我不爱你</span></span></span><br><span class="line"><span class="javascript">                p.innerHTML =<span class="string">&#x27;客户端：&#x27;</span>+ e.data;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务器 <code>http://127.0.0.1:8000</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(e.data) <span class="comment">//我爱你</span></span></span><br><span class="line"><span class="javascript">            p.innerHTML = <span class="string">&#x27;服务器：&#x27;</span> + e.data;</span></span><br><span class="line"><span class="javascript">            e.source.postMessage(<span class="string">&#x27;我不爱你&#x27;</span>, e.origin)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>window.name + iframe、location.hash + iframe</p><h2 id="Cookie、sessionStorage、localStorage★"><a href="#Cookie、sessionStorage、localStorage★" class="headerlink" title="Cookie、sessionStorage、localStorage★"></a>Cookie、sessionStorage、localStorage★</h2><blockquote><p>考察公司：百度</p></blockquote><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是<strong>服务器发送到用户浏览器</strong>并<strong>保存在本地的一小块数据</strong>，它会在<strong>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</strong>。</p><p>通常，它用于告知服务端两个请求是否来自同一浏览器，如<strong>保持用户的登录状态</strong>。Cookie 使基于<strong>无状态</strong>的HTTP协议记录稳定的状态信息成为了可能。<strong>HTTP本质是无状态的，使用Cookies可以创建有状态的会话。</strong></p><h3 id="localStorage-amp-amp-sessionStorage"><a href="#localStorage-amp-amp-sessionStorage" class="headerlink" title="localStorage &amp;&amp; sessionStorage"></a>localStorage &amp;&amp; sessionStorage</h3><blockquote><p>Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在，而Web Storage仅仅是为了在本地“存储”数据而生。</p><p>即<code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p></blockquote><h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><p>IndexedDB 是一种底层 API，用于在客户端<strong>存储大量的结构化数据</strong>（也包括文件/二进制大型对象（blobs））。该 API 使用索引实现对数据的高性能搜索。虽然Web Storage在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th align="center">特性</th><th align="center">cookie</th><th align="center">localStorage</th><th align="center">sessionStorage</th><th align="center">indexDB</th></tr></thead><tbody><tr><td align="center">数据生命周期</td><td align="center">一般由服务器生成，会话期 Cookie/持久性 Cookie可以设置过期时间</td><td align="center">除非被清理，否则一直存在</td><td align="center">页面关闭就清理</td><td align="center">除非被清理，否则一直存在</td></tr><tr><td align="center">数据存储大小</td><td align="center">4K(数量20+，取决于浏览器)</td><td align="center">5M</td><td align="center">5M</td><td align="center">无限</td></tr><tr><td align="center">与服务端通信</td><td align="center">每次都会携带在header中，对于请求性能影响</td><td align="center">不参与</td><td align="center">不参与</td><td align="center">不参与</td></tr></tbody></table><p>Cookie <strong>曾一度用于客户端数据的存储</strong>，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。</p><h2 id="Cookie、Session、Token、JWT"><a href="#Cookie、Session、Token、JWT" class="headerlink" title="Cookie、Session、Token、JWT"></a>Cookie、Session、Token、JWT</h2><p>Cookie是<strong>服务器发送到用户浏览器</strong>并<strong>保存在本地的一小块数据</strong>，它会在<strong>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</strong>。</p><p>通常，它用于告知服务端两个请求是否来自同一浏览器，如<strong>保持用户的登录状态</strong>。Cookie 使基于<strong>无状态</strong>的HTTP协议记录稳定的状态信息成为了可能。</p><p>Cookie 主要用于以下三个方面：</p><ul><li><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li><strong>个性化设置</strong>（如用户自定义设置、主题等）</li><li><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</li></ul><p><strong>Session 是另一种记录服务器和客户端会话状态的机制</strong>，<strong>使服务端有状态化，可以记录会话信息</strong>。</p><p><strong>Session</strong> 是基于<code>cookie</code> 实现的<strong>，session 存储在服务器端</strong>，<code>sessionId</code> 会被<strong>存储到客户端的cookie 中</strong>。</p><p>第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个<code>Session ID</code>，以后每次请求把这个<code>Session ID</code>发送到服务器，服务器就知道你是谁了。</p><p>Token 是<strong>令牌</strong>，<strong>访问资源接口（API）时所需要的资源凭证</strong>。Token <strong>使服务端无状态化，不会存储会话信息。</strong></p><p><strong>JWT</strong> （JSON Web Token）</p><p>结构：<code>头部（Header）</code>、<code>载荷（Payload）</code>、<code>签名（Signature）</code>，并以<code>.</code>进行拼接。</p><p>其中头部和载荷都是以<code>JSON</code>格式存放数据，只是进行了编码。</p><p>签名是对头部和载荷内容进行签名，加密后存储于客户端，服务端只需要使用密钥解密进行校验即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</p><h2 id="XSS和CSRF"><a href="#XSS和CSRF" class="headerlink" title="XSS和CSRF"></a>XSS和CSRF</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p><code>Cross-Site Scripting</code>（跨站脚本攻击）简称 XSS，是一种<strong>代码注入攻击</strong>。</p><p>攻击者通过在<strong>目标网站</strong>上注入<strong>恶意脚本</strong>，使之在用户的<strong>浏览器</strong>上运行。</p><p>利用这些恶意脚本，攻击者可获取用户的敏感信息如<code>Cookie</code>、<code>SessionID</code> 等，进而危害数据安全。</p><p>简单来说,任何可以输入的地方都有可能引起,包括<strong>URL</strong>!</p><p>根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。</p><ul><li>XSS 的恶意代码存在数据库里，浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>用户点击<code>http://xxx/search?keyword=&quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code>，前端直接从url中将keyword后的参数取出来，并显示到页面上，但是没有做转义，就造成了XSS攻击。</li><li>常见于带有用户提交数据的网站功能，如填写基本信息、论坛发帖、商品评论等；在可输入内容的地方提交如<code>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>之类的代码。</li></ul><h4 id="常用防范方法"><a href="#常用防范方法" class="headerlink" title="常用防范方法"></a>常用防范方法</h4><ul><li><strong>httpOnly:</strong> 在 <code>cookie</code> 中设置 <code>HttpOnly</code> 属性后，js脚本将无法读取到 cookie 信息。</li><li><strong>输入过滤:</strong> 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。不仅仅是<strong>前端</strong>负责，<strong>后端</strong>也要做相同的过滤检查。因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。</li><li><strong>转义 HTML:</strong> 如果拼接 HTML 是必要的，就需要对于<strong>引号</strong>，<strong>尖括号</strong>，斜杠进行转义,但这还不是很完善。</li><li><strong>白名单:</strong> 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</li></ul><ul><li><strong>预防 DOM 型 XSS 攻击</strong><ul><li>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript代码本身不够严谨，把不可信的数据当作代码执行了。</li><li>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>（<strong>文本不会被解析为HTML</strong>）、<code>.setAttribute()</code> 等。</li><li>如果用 Vue/React 技术栈，尽量不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患。必须使用时尽量加上HTML净化工具（<a target="_blank" rel="noopener" href="https://github.com/cure53/DOMPurify">DOMPurify</a>）。</li><li>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能<strong>把字符串作为代码运行</strong>。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</li></ul></li></ul><h4 id="csp内容安全策略"><a href="#csp内容安全策略" class="headerlink" title="csp内容安全策略"></a>csp内容安全策略</h4><p>内容安全策略 CSP (Content Security Policy) ，CSP 防止 XSS 攻击， 浏览器自动禁止外部脚本注入。</p><p>CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。</p><p>CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。</p><p><strong>配置方式：</strong></p><p>1）通过 HTTP 头信息的<code>Content-Security-Policy</code>的字段<br><code>Content-Security-Policy: script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https:</code></p><p>2）通过网页的标签</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;<span class="attribute">Content</span>-Security-Policy&quot; <span class="attribute">content</span>=&quot;script-<span class="attribute">src</span> &#x27;self&#x27;; <span class="selector-tag">object</span>-<span class="attribute">src</span> &#x27;<span class="attribute">none</span>&#x27;; style-<span class="attribute">src</span> cdn<span class="selector-class">.example</span><span class="selector-class">.org</span> third-party<span class="selector-class">.org</span>; child-<span class="attribute">src</span> https:<span class="string">&quot;&gt;</span></span><br></pre></td></tr></table></figure><p>两种配置方式的效果一样。</p><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>跨站请求伪造（Cross-site request forgery），通常缩写为 CSRF 或者 XSRF， 是一种<strong>挟制用户在当前已登录的 Web 应用程序上执行非本意的操作</strong>的攻击方法。</p><h4 id="CSRF与-XSS-区别"><a href="#CSRF与-XSS-区别" class="headerlink" title="CSRF与 XSS 区别"></a>CSRF与 XSS 区别</h4><ul><li><strong>通常来说 CSRF 是由 XSS 实现的。</strong></li><li>本质上讲，XSS 是代码注入问题，<strong>CSRF 是 HTTP 问题。</strong> XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。<strong>CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(Token验证可以避免)。</strong></li></ul><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><ul><li><strong>验证码</strong>；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 CSRF，但是用户体验比较差。</li><li><strong>token 验证的 CSRF 防御机制是公认最合适的方案。</strong>若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。</li></ul><h2 id="浏览器允许的并发请求资源数★"><a href="#浏览器允许的并发请求资源数★" class="headerlink" title="浏览器允许的并发请求资源数★"></a>浏览器允许的并发请求资源数★</h2><blockquote><p>考察公司：百度</p></blockquote><p>首先，是基于端口数量和线程切换开销的考虑，浏览器不可能无限量的并发请求，因此衍生出来了并发限制和HTTP/1.1的Keep alive。</p><p>而随着技术的发展，负载均衡和各类NoSQL的大量应用，基本已经足以应对C10K的问题。</p><p>但却并不是每个网站都懂得利用domain hash也就是多域名来加速访问。</p><p>因此，新的浏览器加大了并发数的限制，但却仍<strong>控制在8以内</strong>。</p><p>浏览器即使放弃保护自己，将所有请求一起发给服务器，也很可能会引发服务器的并发阈值控制而被BAN，而另外一个控制在8以内的原因也是keep alive技术的存在使得浏览器复用现有连接和服务器通信比创建新连接的性能要更好一些。</p><p>所以，浏览器的并发数其实并不仅仅只是良知的要求，而是双方都需要保护自己的默契，并在可靠的情况下提供更好的性能。</p><ul><li><p>按照普通设计，当网站cookie信息有1 KB、网站首页共150个资源时，用户在请求过程中需要发送150 KB的cookie信息，在512 Kbps的常见上行带宽下，需要长达3秒左右才能全部发送完毕。 尽管这个过程可以和页面下载不同资源的时间并发，但毕竟对速度造成了影响。 而且这些信息在js/css/images/flash等静态资源上，几乎是没有任何必要的。 解决方案是<strong>启用和主站不同的域名来放置静态资源，也就是cookie free</strong>。跨域默认不带cookie</p></li><li><p>将css放置在页面最上方应该是很自然的习惯，但第一个css内引入的图片下载是有可能堵塞后续的其他js的下载的。而在目前普遍过百的整页请求数的前提下，浏览器提供的仅仅数个并发，对于进行了良好优化甚至是前面有CDN的系统而言，是极大的性能瓶颈。 这也就衍生了<strong>domain hash</strong>技术来使用多个域名加大并发量（因为浏览器是基于domain的并发控制，而不是page），不过过多的散布会导致DNS解析上付出额外的代价，所以一般也是控制在2-4之间。 这里常见的一个性能小坑是没有机制去确保URL的哈希一致性（即同一个静态资源应该被哈希到同一个域名下），而导致资源被多次下载。</p></li><li><p>再怎么提速，页面上过百的总资源数也仍然是很可观的，如果能将其中一些很多页面都用到的元素如常用元素如按钮、导航、Tab等的背景图，指示图标等等合并为一张大图，并利用css background的定位来使多个样式引用同一张图片，那也就可以大大的减少总请求数了，这就是<code>css sprites</code>雪碧图的由来。</p></li><li><p>全站的js/css原本并不多，其合并技术的产生却是有着和图片不同的考虑。 由于css/js通常可能对dom布局甚至是内容造成影响，在浏览器解析上，不连贯的载入是会造成多次重新渲染的。因此，在网站变大需要保持模块化来提高可维护性的前提下，<code>js/css combine</code>也就自然衍生了，同时也是<code>minify、compress</code>等对内容进行多余空格、空行、注释的整理和压缩的技术出现的原因。</p></li><li><p>随着cookie free和domain hash的引入，网站整体的打开速度将会大大的上一个台阶。 这时我们通常看到的问题是大量的请求由于全站公有header/footer/nav等关系，其对应文件早已在本地缓存里存在了，但为了确保这个内容没有发生修改，浏览器还是需要请求一次服务器，拿到一个304 Not Modified才能放心。 一些比较大型的网站在建立了比较规范的发布制度后，会将大部分静态资源的有效期设置为最长，也就是Cache-Control max-age为10年。 这样设置后，浏览器就再也不会在有缓存的前提下去确认文件是否有修改了。 超长的有效期可以让用户在访问曾访问过的网站或网页时，获得最佳的体验。 带来的复杂性则体现在每次对静态资源进行更新时，必须发布为不同的URL来确保用户重新加载变动的资源。</p></li><li><p>即使是这样做完，仍然还存在着一个很大的优化空间，那就是很多页面浏览量很大，但其实用户直接很大比例直接就跳走了，第一屏以下的内容用户根本就不感兴趣。 对于超大流量的网站如淘宝、新浪等，这个问题尤其重要。 这个时候一般是通过将图片的src标签设置为一个loading或空白的样式，在用户翻页将图片放入可见区或即将放入可见区时再去载入。 不过这个优化其实和并发资源数的关系就比较小了，只是对一些散布不合理，或第一页底部的资源会有一定的帮助。 主要意图还是降低带宽费用。</p></li></ul><p>总的来说，各类技术都是为了<strong>能让用户更快的看到页面进行下一步操作，但却不必将宝贵的资源浪费在没有必要的重复请求、不看的内容上</strong>。</p><p><strong>浏览器的并发请求数目限制是针对同一域名的</strong>。</p><p>意即，同一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。</p><h2 id="后端定期向前端推送数据★"><a href="#后端定期向前端推送数据★" class="headerlink" title="后端定期向前端推送数据★"></a>后端定期向前端推送数据★</h2><blockquote><p>考察公司：百度</p></blockquote><p>sse是后端向前端发信息的单向通道，客户端发送一个请求，服务端保持足够连接直到有新消息发送回客户端，仍然保持着连接，这样连接就可以消息再次发送，由服务器单向发送给客户端。</p><p><a target="_blank" rel="noopener" href="https://imgse.com/i/vxXAyV"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/09/15/vxXAyV.png" alt="vxXAyV.png"></a></p><h2 id="浏览器多个标签之间通信★"><a href="#浏览器多个标签之间通信★" class="headerlink" title="浏览器多个标签之间通信★"></a>浏览器多个标签之间通信★</h2><blockquote><p>考察公司：腾讯</p></blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_17775997/article/details/124312525">https://blog.csdn.net/sinat_17775997/article/details/124312525</a></p><table><thead><tr><th align="left">实现方式</th><th align="left">优缺点</th></tr></thead><tbody><tr><td align="left">localStorage</td><td align="left"><strong>优点：</strong> 操作简单，易于理解。<strong>缺点：</strong> 存储大小限制只能监听非己页面跨域不共享 （<strong>总体来说较为推荐</strong>）</td></tr><tr><td align="left">websocket</td><td align="left"><strong>优点：</strong> 理论上可是实现任何数据共享跨域共享 <strong>缺点：</strong> 需要服务端配合增加服务器压力上手不易 （<strong>总体不推荐</strong>）</td></tr><tr><td align="left">sharedWorker</td><td align="left"><strong>优点：</strong> 理论上可以实现任何数据共享性能较好 <strong>缺点：</strong> 跨域不共享调试不方便兼容性不好 （<strong>总体推荐一般</strong>）</td></tr><tr><td align="left">cookie</td><td align="left"><strong>优点：</strong> 兼容性好易于上手和理解 <strong>缺点：</strong> 有存储大小限制轮询消耗性能发请求会携带cookie （<strong>总体不推荐</strong>）</td></tr></tbody></table><h3 id="localStorage实现通信"><a href="#localStorage实现通信" class="headerlink" title="localStorage实现通信"></a>localStorage实现通信</h3><p>借助localStorage实现标签页之间通信在实际项目中使用的很多，因为它操作简单，易于理解。</p><p><strong>localStorage的特点：</strong></p><ul><li>同域共享存储空间</li><li>持久化数据存储</li><li>提供事件监听localStorage变化</li></ul><p>这里我们需要重点关注同域共享，如果多个标签页跨域了，那么数据将无法共享。</p><p>我们新建两个页面pageA和pageB，利用localStorage实现两个页面之间的通信。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// pageA.html</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>pageA<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.addEventListener(<span class="string">&quot;storage&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.info(<span class="string">&quot;localStorage发生变化：&quot;</span>, e)</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// pageB.html</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>pageB<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btnB&quot;</span>&gt;</span>添加数据到localStorage<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> btnB = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btnB&quot;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> num = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">  btnB.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;num&quot;</span>, num++)</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ul><li>pageA和pageB同源，即域名、端口、协议等都是相同的。</li><li>使用storage事件监听localStorage变化</li></ul><p>当然，如果你只是需要两个页面之间数据共享，那么可以不使用storage监听方法，直接通过localStorage.getItem()获取即可。</p><h3 id="使用websocket"><a href="#使用websocket" class="headerlink" title="使用websocket"></a>使用websocket</h3><p>websocket是一种网络通讯协议。我们都知道在使用HTTP协议的时候，我们与服务端都是通过发请求的方式进行通讯的，而且这种通讯只能由客户端发起。websocket协议就弥补了这一缺点，它是一个全双工通信的协议，意味着客户端和服务端可以互相通信，享受平等关系。</p><p>最简单列子就是聊天室，我们在聊天室里面可以收消息，也可以发消息，只要我们与服务端通过websocket建立好了连接。</p><p><strong>websocket特点：</strong></p><ul><li>保持连接状态，HTTP协议是无状态连接，即请求完毕后就会关闭连接。</li><li>全双工通信，客户端和服务端平等对待，可以互相通信。</li><li>建立在TCP协议之上</li><li>没有同源共享策略，即可实现跨域共享</li></ul><p>通过以上websocket的特点，我们再来思考如何利用websocket实现多标签页通信？</p><p>其实实现原理页比较简单，假如我们pageA和pageB都与服务器建立了websocket连接，那么连个页面都可以实时接收服务端发来的消息，也可以实时向服务端发送消息。如果pageA更改了数据，那么向服务端发送一条消息或数据，服务端在将这条消息或数据发送给pageB即可，这样就简单实现了两个标签页之间的通信。</p><p>原理有点类似于”中介“，我们可以通过中介来进行沟通。</p><p>总体来说，原理很简单，只是需要了解websocket。通常情况下，我们不建议使用websocket来进行多标签页通信，因为这回增加服务器的负担。</p><h3 id="SharedWorker"><a href="#SharedWorker" class="headerlink" title="SharedWorker"></a>SharedWorker</h3><p>我们都知道JavaScript是单线程的，单线程有好处也有坏处。为了弥补JS单线程的坏处，webWorker随之被提出，它可以为JS创造多线程环境。</p><p>sharedWorker就是webWorker中的一种，它可以由所有同源页面共享，利用这个特性，我们就可以使用它来进行多标签页之前的通信。</p><p><strong>sharedWorker特点：</strong></p><ul><li>跨域不共享，即多个标签页不能跨域</li><li>使用port发送和接收消息</li><li>如果url相同，且是同一个js，那么只会创建一个sharedWorker，多个页面共享这个sharedWorker</li></ul><p>其实它和我们的webSocket实现多页面通讯的原理很类似，都是发送数据和接收数据这样的步骤，shardWorker就好比我们的webSocket服务器。</p><p><strong>总结：</strong></p><p>sharedWorker的原理和websocket有点类似，都是广播和接收的原理，但是它也有一些缺点，比如调试不太方便、兼容性不太好。所以使用的时候一定要结合实际情况使用。</p><h3 id="使用cookie-setInterval"><a href="#使用cookie-setInterval" class="headerlink" title="使用cookie + setInterval"></a>使用cookie + setInterval</h3><p>我们都知道cookie可以用来存储数据，而且它是同源共享的，借助它的这些特点，我们就可以利用cookie实现多页面的通讯。</p><p><strong>cookie特点：</strong></p><ul><li>跨域不共享</li><li>具有存储空间限制</li><li>请求会自动携带cookie</li></ul><p>这种方式实现的原理非常简单，就是在需要接收消息的页面不断轮询去查询cookie，然后发送消息的页面将数据存储在cookie中，这样就实现了简单的数据共享。</p><h2 id="Ping★"><a href="#Ping★" class="headerlink" title="Ping★"></a>Ping★</h2><blockquote><p>考察公司：华为</p></blockquote><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><p>它的作用主要为：</p><p>（1）用来检测网络的连通情况和分析网络速度；</p><p>（2）根据域名得到服务器IP；</p><p>（3）根据ping返回的TTL值来判断对方所使用的操作系统及数据包经过路由器数量。</p><p>我们通常会用它来直接ping IP地址，来测试网络的连通情况。</p><p>bytes值：数据包大小，也就是字节。</p><p>time值：响应时间，这个时间越小，说明你连接这个地址速度越快。</p><p>TTL值：Time To Live,表示DNS记录在DNS服务器上存在的时间，它是IP协议包的一个值，告诉路由器该数据包何时需要被丢弃。可以通过Ping返回的TTL值大小，粗略地判断目标系统类型是Windows系列还是UNIX/Linux系列。</p><h2 id="服务端渲染★"><a href="#服务端渲染★" class="headerlink" title="服务端渲染★"></a>服务端渲染★</h2><blockquote><p>考察公司：百度</p></blockquote><p><code>React</code>、<code>Vue</code>、<code>Angular</code> 等基于客户端渲染的前端框架，这类框架所构建的单页应用（SPA）具有<strong>用户体验好、渲染性能好、可维护性高</strong>等优点。但也也有一些很大的缺陷，其中主要涉及到以下两点：</p><ol><li>首屏加载时间过长</li></ol><blockquote><p>与传统服务端渲染直接获取服务端渲染好的 <code>HTML</code> 不同，单页应用使用 <code>JavaScript</code> 在客户端生成 <code>HTML</code>来呈现内容，用户需要等待客户端 <code>JS</code> 解析执行完成才能看到页面，这就使得首屏加载时间变长，从而影响用户体验。</p></blockquote><p>2.不利于 SEO</p><blockquote><p>当搜索引擎爬取网站 <code>HTML</code> 文件时，单页应用的 <code>HTML</code> 没有内容，因为他它需要通过客户端 <code>JavaScript</code> 解析执行才能生成网页内容，而目前的主流的搜索引擎对于这一部分内容的抓取还不是很好。为了解决这两个缺陷，业界借鉴了传统的服务端直出 <code>HTML</code> 方案，提出在服务器端执行前端框架（<code>React/Vue/Angular</code>）代码生成网页内容，然后将渲染好的网页内容返回给客户端，客户端只需要负责展示就可以了；</p></blockquote><p>这里为了让大家更好的理解服务端渲染应用，我们要从以下这几个小点出发，一点点进行学习</p><ul><li>渲染是什么？本质是什么？</li><li>传统的服务端渲染优势在哪？，不足在哪里</li><li>客户端渲染</li><li>现代化的服务端渲染（同构渲染）</li></ul><h3 id="什么是渲染"><a href="#什么是渲染" class="headerlink" title="什么是渲染"></a>什么是渲染</h3><blockquote><ol><li>浏览器会解析三个东西：</li></ol><ul><li>一个是HTML/SVG/XHTML，事实上，Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree。</li><li>CSS，解析CSS会产生CSS规则树。</li><li>Javascript，脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree.</li></ul><ol><li>解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。注意：<strong>Rendering Tree 渲染树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了。</strong> CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element。也就是DOM结点。也就是所谓的Frame。然后，计算每个Frame（也就是每个Element）的位置，这又叫layout和reflow过程。</li><li>最后通过调用操作系统Native GUI的API绘制。</li></ol></blockquote><p>例如对于我们前端开发者来说最常见的一种场景就是：<em>请求后端接口数据，然后将数据通过模板绑定语法绑定到页面中，最终呈现给用户。这个过程就是我们这里所指的渲染</em>。</p><p>渲染本质其实就是字符串的解析替换，实现方式有很多种</p><h3 id="传统的服务端渲染"><a href="#传统的服务端渲染" class="headerlink" title="传统的服务端渲染"></a>传统的服务端渲染</h3><p>服务端运行过程中将所需的数据结合页面模板渲染为<code>HTML</code>，响应给客户端浏览器。</p><h4 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h4><ol><li>客户端发送请求给服务器</li><li>服务器查询数据库，使用视图、模板引擎等拼接成html字符串，返回给客户端</li><li>客户端渲染html</li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>缺点<ul><li>应用的前后端部分完全耦合在一起，前端写完页面样式和结构后，再将页面交给后端套数据，最后再一起联调。</li><li>前端的发布过于依赖于后端的同学；</li><li>前端没有足够的发挥空间，无法充分利用现在前端生态下的一些更优秀的方案；（能不能让前端又可以摸鱼事情还不用做就更好了）</li><li>由于内容都是在服务端动态生成的，所以服务端的压力较大；</li><li>相比目前流行的 SPA 应用来说，用户体验一般；</li></ul></li></ul><p>优点 - 页面渲染速度快 - 同时 SEO 效果好。</p><p><em>但是不得不说，在网页应用并不复杂的情况下，这种方式也是可取的。</em></p><h3 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h3><p>传统的服务端渲染有很多问题，但是这些问题随着客户端 <code>Ajax</code> 技术的普及得到了有效的解决，<code>Ajax</code> 技术可以使得客户端动态获取数据变为可能，<strong>也就是说原本服务端渲染这件事儿也可以拿到客户端做了</strong>。</p><p>我们就可以把【<strong>数据处理</strong>】和【<strong>页码渲染</strong>】这两件事儿分开了，也就是【<strong>后端</strong>】负责数据处理，【<strong>前端</strong>】负责页面渲染，这种分离模式极大的提高了开发效率和可维护性。</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ul><li>节省服务端资源,js动态生成页面,部署简单</li><li>局部刷新,无需每次都请求完整的页面,体验更好</li><li>前后端分离</li></ul></li><li>缺点<ul><li>首屏渲染慢,渲染前需要下载css和js资源</li><li>无法进行SEO</li></ul></li></ul><p>当然主要还是前后端分离了，让前端工作性质上了一个档次！</p><p>感谢客户端渲染！</p><blockquote><p><strong>对于客户端渲染的 SPA 应用的问题有没有解决方案呢？</strong></p><ul><li>服务端渲染，严格来说是现代化的服务端渲染，也叫同构渲染</li></ul></blockquote><h3 id="现代化的服务端渲染"><a href="#现代化的服务端渲染" class="headerlink" title="现代化的服务端渲染"></a>现代化的服务端渲染</h3><p>我们在上一小节了解到 SPA 应用有两个非常明显的问题：</p><ul><li>首屏渲染慢</li><li>不利于 SEO</li></ul><p>但是我们在复习过了服务端渲染之后，就会想到将客户端渲染的工作放到服务端渲染，这个问题不就解决了吗？</p><p>那当然不是用老版本的服务端渲染了啦，这就引出了<strong>同构渲染</strong>，也就是【<strong>服务端渲染</strong>】 + 【<strong>客户端渲染</strong>】。</p><h4 id="分析优缺点："><a href="#分析优缺点：" class="headerlink" title="分析优缺点："></a>分析优缺点：</h4><ul><li><strong>优点</strong>：<ul><li>首屏渲染速度快</li><li>有利于 SEO</li></ul></li><li><strong>缺点</strong>：<ul><li>开发成本高。</li><li>涉及构建设置和部署的更多要求。</li><li>server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)</li></ul></li></ul><h3 id="相关技术："><a href="#相关技术：" class="headerlink" title="相关技术："></a>相关技术：</h3><ul><li><p>React 生态中的 Next.js</p></li><li><p>Vue 生态中的 Nuxt.js</p></li><li><p>Angular 生态中的 Angular Universal</p></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在对你的应用程序使用服务器端渲染 (<strong>SSR</strong>) 之前，你应该问的第一个问题是： <strong>是否真的需要它</strong>。</p><blockquote><ul><li>例如，如果你<strong>正在构建一个内部仪表盘</strong>，<strong>初始加载时的额外几百毫秒并不重要</strong>，这种情况下去<strong>使用服务器端渲染 (SSR) 将是一个小题大作之举</strong></li><li>如果内容到达时间要求是<strong>绝对关键的指标</strong>，在这种情况下，<strong>服务器端渲染(SSR) 可以帮助你实现最佳的初始加载性能</strong>。</li></ul></blockquote><p>事实上，很多网站是出于效益的考虑才启用服务端渲染，性能倒是在其次。</p><blockquote><ul><li>假设 A 网站页面中有一个关键字叫“前端性能优化”，这个关键字是 JS 代码跑过一遍后添加到 HTML 页面中的。</li></ul></blockquote><blockquote><ul><li>那么客户端渲染模式下，我们在搜索引擎搜索这个关键字，是找不到 A 网站的——搜索引擎只会查找现成的内容，不会帮你跑 JS 代码。</li><li>A网站的运营方见此情形，感到很头大：搜索引擎搜不出来，用户找不到我们，谁还会用我的网站呢？</li></ul></blockquote><p><strong>为了把“现成的内容”拿给搜索引擎看，A 网站不得不启用服务端渲染</strong>。</p><p>说白了，一切实用性为主，业务为辅，一切为炫技而做的事情说白了，都是要贴近团队、产品的！</p><h1 id="JacaScript"><a href="#JacaScript" class="headerlink" title="JacaScript"></a>JacaScript</h1><h2 id="OOP★"><a href="#OOP★" class="headerlink" title="OOP★"></a>OOP★</h2><blockquote><p>考察公司：字节、腾讯</p></blockquote><h3 id="其他语言对比"><a href="#其他语言对比" class="headerlink" title="其他语言对比"></a>其他语言对比</h3><p><strong>解释代码 vs 编译代码</strong></p><ul><li><p>在<strong>解释型</strong>语言中，代码<strong>自上而下</strong>运行，且<strong>实时返回运行结果</strong>。代码将直接以<strong>文本格式（text form）</strong>被接收和处理。解释型语言代表有：JS、MATLAB、Python和Java。</p></li><li><p>相对的，<strong>编译型</strong>语言需要先将代码<strong>转化（编译）</strong>成另一种形式才能运行。比如 C/C++ 先被<strong>编译成汇编语言</strong>，然后才能由计算机运行。程序将以<strong>二进制</strong>的格式运行，这些二进制内容是由程序源代码产生的。</p></li><li><p>编译性语言不如解释性语言跨平台性好，也就是说不同平台的兼容性有区别，所以才有了两种语言。用c语言开发了程序后，需要通过编译器把程序编译成机器语言（即计算机识别的二进制文件，因为不同的操作系统计算机识别的二进制文件是不同的），所以c语言程序进行移植后，要重新编译。（如windows编译成ext文件，linux编译成erp文件）。java程序首先通过编译器编译成class文件，如果在windows平台上运行，则通过windows平台上的java虚拟机（VM）进行解释。如果运行在linux平台上，则通过linux平台上的java虚拟机进行解释执行。所以说能跨平台，前提是平台上必须要有相匹配的java虚拟机。如果没有java虚拟机，则不能进行跨平台。</p></li><li><p><strong>JavaScript 是轻量级解释型语言</strong>。</p><ul><li>浏览器接受到JavaScript代码，并以代码自身的文本格式运行它。</li><li>技术上，几乎所有 JavaScript 转换器都运用了一种叫做<strong>即时编译（just-in-time compiling）</strong>的技术；</li><li>当 JavaScript 源代码被执行时，它会被编译成<strong>二进制</strong>的格式，使代码<strong>运行速度更快</strong>。</li><li>尽管如此，JavaScript 仍然是一门解释型语言，因为<strong>编译过程发生在代码运行中，而非之前</strong>。</li></ul></li><li><p><strong>编译型与解释型的共同点</strong></p><p>他们都要弄成二进制代码才能执行，两类编程语言的源代码都是英文，但是我们的计算机并不认识英文，所以都要转化成二进制才能执行。区别就在于“转化的方式”不一样。</p></li><li><p><strong>编译型与解释型的不同点</strong></p><ul><li><p>从运行效果上来看。编译型语言要等全部写完后通过编译器去生成一个类似<code>*.exe</code>的二进制文件，然后双击这个文件才可以看到效果。而解释型语言并没生成<code>*.exe</code>文件，而是直接生成效果。</p></li><li><p>运行的时候是否需要编译器的伴随。编译型语言运行的是最终生成的二进制代码，所以不需要编译器伴随。而解释型语言则一边解释一边运行，所以运行的时候很可能还有部分代码没有解释好，所以需要编译器伴随（解释型语言把该工具叫做解释器）。</p><p>举个例子，网页的解释器就在浏览器中，所以要看HTML的效果必须用浏览器或者有编译工具在内的其他工具打开，比如：模拟浏览器的工具。</p></li><li><p>执行的速度对比。编译型语言运行的已经是完全的二进制内容，运行起来十分干净利落，所以速度很快。而解释型语言运行的不一定是完全的二进制内容，因为它是一边解释成二进制一边运行。</p></li><li><p>可移植性对比。编译型语言是运行二进制内容，所以一旦CPU指令系统改变，那么之前的二进制文件可能运行不了。比如，如果到其他硬件平台上运行，就可能出现错误，就需要根据该平台重新编译出新的二进制文件。所以可移植性、平台兼容性比价差。而解释型语言则没有弄成什么二进制内容，而是在需要的时候才开始编译、运行。所以它自然具有可移植性，即在任何平台都可以马上运行起来。</p><p>要注意的是它的解释工具如：浏览器，本身就是编译型语言解释出来的二进制代码，所以浏览器本身不具备可移植性，是需要针对不同的平台弄出对应的浏览器最终二进制文件的，这里可别混淆。</p></li><li><p>升级上对比。编译型语言弄出来的二进制文件若要升级，自然要重新下载一个新的二进制文件。所以重新下载、安装、覆盖是最大的特点。而解释型的语言只要重新写好源代码即可，用户想要最新的效果，只要刷新一下即可，所以体验性好。比如：某网站平台升级了，用户只要重新刷新一下。</p></li><li><p>应用领域，编译型语言应用领域通常是那些安装软件，例如桌面上的安装软件。解释型的语言的应用领域通常是互联网、网站等那种刷新了一下就可以看到最新效果的领域。</p></li></ul></li></ul><p><strong>服务器端代码 vs 客户端代码</strong></p><ul><li><p>客户端代码是在用户的电脑上运行的代码，在浏览一个网页时，它的客户端代码就会被下载，然后由浏览器来运行并展示。</p></li><li><p>而服务器端代码在服务器上运行，运行结果由浏览器下载并展示出来。</p><ul><li>流行的服务器端 web 语言包括：PHP、Python、Ruby、ASP.NET 以及…… JavaScript！</li><li><strong>JavaScript 也可用作服务器端语言</strong>，比如现在流行的 Node.js 环境。</li></ul></li></ul><p><strong>强类型 Vs. 弱类型</strong></p><ul><li>强和弱是一个相对的概念，强是指倾向于将<strong>未定义的行为</strong>视作错误（Java、Python），弱是指倾向于进行<strong>隐式的转换</strong>、忽略类型相关的错误（JavaScript）。<strong>如果语言经常隐式地转换变量的类型</strong>，那这个语言就是弱类型语言，如果很少会这样做，那就是强类型语言。</li><li>很多设计得不够严谨的语言，虽然大多数情况下（或者我们通常鼓励大家这么做）是强类型的，但也有弱类型的部分（PHP）</li><li>还有的语言因为提供的抽象能力很弱，我们不得不去用弱类型的部分（C）</li><li>鸭子类型（duck typing）是强弱类型的一个折中（常见于动态类型中，例如 Python），兼顾了灵活性和严谨性。</li><li>我们认为弱类型是为了方便，而强类型是为了尽早发现错误。</li></ul><p><strong>动态类型 Vs. 静态类型</strong></p><ul><li>静态类型的变量的类型是在编译时确定的（C++、Java）；动态类型的类型是在运行时确定的（JavaScript、Python），例如你可以在一个 if 的两个分支里给一个变量赋值不同的类型。</li><li>有的动态类型语言也会添加编译期的类型检查（TypeScript、Python），但因为语言本身的动态性，这些检查仅能覆盖一部分情况。</li><li>在动态类型的语言中因为类型不那么重要，所以很多时候甚至没有提供指定类型的语法（隐含了运行时的自动推导）；而在静态类型语言里通常需要为变量指定类型，所以才有了编译期自动类型推导来提供便利，而动态类型语言则做不到这一点（因为不能在编译期确定类型，更无从推导）。</li><li>我们认为静态类型有助于在编译时发现有关类型的错误，确定的类型也给了编译期更多的优化空间；而动态类型给了开发者更高的灵活度。</li></ul><p><strong>虚拟机 VS. 本地代码</strong></p><ul><li>虚拟机是指在语言和 CPU 之间还有一个用于进行翻译的层次（JavaScript、Java）；无虚拟机是指编译器直接生成本地代码给 CPU 执行（C/C++、Golang）。</li><li>虚拟机也提供了更为复杂的运行时的动态特性，但这些特性有的时候也可以在没有虚拟机的情况下实现（例如 C++ 的运行时类型识别、Go 的 GC）。</li><li>虚拟机可以以解释的方式执行（Python，将代码视作一种数据指令来执行），也可以即时编译（JIT）的方式来执行（V8，先将代码编译到本地代码然后执行），有时也会混合这两种方式（为了更快的启动速度）。</li><li>我们认为无虚拟机的语言可以在更低的层次和其他程序交互，同时也天然地有着更好的性能；而有虚拟机的语言则可以轻松地跨平台，针对特定的架构在运行时即时编译出更高性能的代码。</li></ul><h3 id="基于类-vs-基于原型的语言"><a href="#基于类-vs-基于原型的语言" class="headerlink" title="基于类 vs 基于原型的语言"></a>基于类 vs 基于原型的语言</h3><p><strong>基于类的面向对象语言</strong>，比如 Java 和 C++，是构建在两个不同实体之上的：类和实例。</p><ul><li>一个<strong>类(class)<strong>定义了</strong>某一对象集合所具有的特征性属性</strong>（可以将 Java 中的方法和域以及 C++ 中的成员都视作属性）。<strong>类是抽象的，而不是其所描述的对象集合中的任何特定的个体。</strong></li><li>另一方面，<strong>一个实例(instance)是一个类的实例化</strong>。<strong>实例具有和其父类完全一致的属性</strong>。</li></ul><p><strong>基于原型的语言（如 JavaScript）</strong>并不存在这种区别：它<strong>只有对象</strong>。</p><p>基于原型的语言具有所谓**原型对象(prototypical object)**的概念。</p><p><strong>原型对象可以作为一个模板，新对象可以从中获得原始的属性。</strong></p><p>任何对象都可以指定其自身的属性，既可以是创建时也可以在运行时创建。</p><p><strong>任何对象都可以作为另一个对象的原型(prototype)，从而允许后者共享前者的属性</strong>。</p><table><thead><tr><th align="left">基于类的（Java）</th><th align="left">基于原型的（JavaScript）</th></tr></thead><tbody><tr><td align="left">类和实例是不同的事物。</td><td align="left">所有对象均为实例。</td></tr><tr><td align="left">通过类定义来定义类；通过构造器方法来实例化类。</td><td align="left">通过构造器函数来定义和创建一组对象。</td></tr><tr><td align="left">通过 <code>new</code> 操作符创建单个对象。</td><td align="left">相同。</td></tr><tr><td align="left">通过类定义来定义现存类的子类，从而构建对象的层级结构。</td><td align="left">指定一个对象作为原型并且与构造函数一起构建对象的层级结构</td></tr><tr><td align="left">遵循类链继承属性。</td><td align="left">遵循原型链继承属性。</td></tr><tr><td align="left">类定义指定类的所有实例的<strong>所有</strong>属性。无法在运行时动态添加属性。</td><td align="left">构造器函数或原型指定实例的<strong>初始</strong>属性集。允许动态地向单个的对象或者整个对象集中添加或移除属性。</td></tr></tbody></table><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向对象是把构成问题事务分解成各个对象，<strong>建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</strong></p><p>万事万物皆对象。面向对象的思想主要是以对象为主，将一个问题抽象出具体的对象，并且将抽象出来的对象和对象的属性和方法封装成一个类。</p><ul><li><strong>面向过程</strong>的特点在于<strong>逻辑性强</strong>，符合思维方式和解决问题的流程。</li><li><strong>面向对象</strong>的特点就是<strong>可扩展性更强</strong>一些，解决了<strong>代码重用性</strong>的问题。</li></ul><p>js中对象，对象下的方法和属性，都是储存在<strong>内存</strong>中的，调用的时候，是可以随时拿到这些属性和方法的。</p><p>在编程中使用OOP就是为了<strong>提高代码的复用性</strong>，而提高代码复用性的根本原因是为了<strong>降低内存的使用率</strong>。</p><p>面向对象程序设计的<strong>目的</strong>是在编程中促进更好的<strong>灵活性和可维护性</strong>，在大型软件工程中广为流行。即代码各部分相对独立，耦合性低，且功能明确，遇到bug或者更改需求，都可以直接针对特定的对象进行修改，便于维护。另外，面向对象凭借其对<strong>模块化</strong>的重视，面向对象的代码开发更简单，更容易理解，相比非模块化编程方法 , 它能更直接地分析, 编码和理解复杂的情况和过程。</p><p><strong>面向对象有三大特性，封装、继承和多态</strong></p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>封装主要实现的功能就是将数据隐藏，只暴露出有限的接口。</strong></p><p>在js中万物皆对象，字符串、数值、数组、函数都属于Object。因此js基本的创建对象的方法有两种：</p><ul><li><p><strong>对象字面量法</strong></p></li><li><p><strong>new对象</strong></p></li></ul><p><strong>但这两种方法都会产生大量重复代码，基于面向对象思想，我们使用新的方式创建对象。</strong></p><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式如同它的名字一般，将对象从原料加工、制作、最后出厂，可实现大批量的功能相似产品对象！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//1、原料</span></span><br><span class="line">    <span class="keyword">var</span> obj=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">   <span class="comment">//2、加工</span></span><br><span class="line">    obj.name=name;</span><br><span class="line">    obj.showName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="comment">//3、出场</span></span><br><span class="line">     <span class="keyword">return</span> obj; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> p1=createPerson(<span class="string">&#x27;小米&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p1=createPerson(<span class="string">&#x27;小红&#x27;</span>);</span><br><span class="line">p1.showName();<span class="comment">//小米</span></span><br><span class="line">p2.showName();<span class="comment">//小红123456789101112131415</span></span><br></pre></td></tr></table></figure><p><strong>工厂模式的优缺点</strong>：虽然解决了创建相似对象的问题，但是却没有解决对象识别问题（即怎样知道一个对象的类型）。</p><h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><p>构造函数其实就是普通的函数，只不过有以下的特点：</p><ul><li><strong>首字母大写</strong>（建议构造函数首字母大写，即使用大驼峰命名，非构造函数首字母小写）</li><li>内部使用this</li><li>使用 new生成实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.varieties = varieties;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(varieties, age);</span><br><span class="line">    &#125;;     </span><br><span class="line">&#125;        </span><br><span class="line"><span class="keyword">var</span> dog1 = <span class="keyword">new</span> Dog(<span class="string">&quot;Husky&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> dog2 = <span class="keyword">new</span> Dog(<span class="string">&quot;Alaska&quot;</span>, <span class="number">3</span>);<span class="number">123456789</span></span><br></pre></td></tr></table></figure><p><strong>构造函数模式的优缺点</strong>：</p><ul><li>优点：创建自定义函数意味着将来可以将它的实例标识为一种特定的类型，这是构造函数胜过工厂模式的地方.</li><li>缺点：每个方法都要在每个实例上重新创建一遍.</li></ul><h4 id="原型-类-模式"><a href="#原型-类-模式" class="headerlink" title="原型(类)模式"></a>原型(类)模式</h4><p><strong>原型模式的优缺点：</strong></p><ul><li>优点：可以让所有的对象实例共享它所包含的属性和方法</li><li>缺点：原型中是所有属性都是<strong>共享</strong>的，但是实例一般都是要有自己的单独属性的。所以一般很少单独使用原型模式。</li></ul><h4 id="混合模式（常用作封装类）"><a href="#混合模式（常用作封装类）" class="headerlink" title="混合模式（常用作封装类）"></a>混合模式（常用作封装类）</h4><p>通过构造函数模式定义实例（私有）属性，而原型模式用于定义方法和共享的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name,age</span>)</span>&#123;<span class="comment">//定义私有属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayname = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;<span class="comment">//定义公有属性</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;chen&quot;</span>,<span class="number">22</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;qian&quot;</span>,<span class="number">21</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.age);<span class="comment">//22</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.age);<span class="comment">//21</span></span><br><span class="line">person1.sayname()<span class="comment">//chen</span></span><br><span class="line">person2.sayname()<span class="comment">//qian</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayname===person2.sayname);<span class="comment">//true</span></span><br><span class="line">person1.age = <span class="number">26</span>;</span><br><span class="line"><span class="comment">//改变person1的属性和方法</span></span><br><span class="line">person1.sayname = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&quot;change&quot;</span>)&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person1.age);<span class="comment">//26     </span></span><br><span class="line"><span class="built_in">console</span>.log(person2.age);<span class="comment">//21  person2不受影响</span></span><br><span class="line">person1.sayname()<span class="comment">//change</span></span><br><span class="line">person2.sayname()<span class="comment">//qian  person2访问原型的方法，不受影响</span></span><br></pre></td></tr></table></figure><h3 id="继承★"><a href="#继承★" class="headerlink" title="继承★"></a>继承★</h3><blockquote><p>考察公司：完美世界</p></blockquote><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>通过将<strong>子类的原型对象指向父类的实例</strong>，实现继承访问父类属性方法等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line">SubType.prototype.constructor = SubType; <span class="comment">// 修复constructor使符合原型链规定</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>原型链方案存在的缺点：</p><ul><li>由于所有SubType实例原型都指向同一个SuperType实例, 因此<strong>对某个SubType实例的来自父类的引用类型变量修改会影响所有的SubType实例</strong>。</li><li>在创建子类实例时无法向父类构造传参, 即没有实现super()的功能。</li></ul><h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><p>构造函数继承，即在<strong>子类的构造函数中执行父类的构造函数，并为其绑定子类的this</strong>，让父类的构造函数把成员属性和方法都挂到子类的this上去，这样既<strong>能避免实例之间共享一个原型实例，又能向父类构造方法传参</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color=[<span class="string">&quot;red&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;blue&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承自SuperType</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.color.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">alert(instance1.color);<span class="comment">//&quot;red,green,blue,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.color);<span class="comment">//&quot;red,green,blue&quot;</span></span><br></pre></td></tr></table></figure><p>核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用<code>SuperType</code>构造函数，于是<code>SubType</code>的每个实例都会将<code>SuperType</code>中的属性复制一份。</p><p>缺点：</p><ul><li>只能继承父类的<strong>实例</strong>属性和方法，不能继承<strong>原型</strong>属性/方法</li><li>无法实现复用，每个子类实际上是调用父类来生成的实例</li></ul><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>组合上述两种方法就是组合继承。用原型链实现对<strong>原型</strong>属性和方法的继承，用借用构造函数技术来实现<strong>实例</strong>属性的继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="comment">// 第二次调用SuperType()</span></span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="comment">// 构建原型链</span></span><br><span class="line"><span class="comment">// 第一次调用SuperType()</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line"><span class="comment">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span></span><br><span class="line">SubType.prototype.constructor = SubType; </span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line">instance1.sayName(); <span class="comment">//&quot;Nicholas&quot;;</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//&quot;red,blue,green&quot;</span></span><br><span class="line">instance2.sayName(); <span class="comment">//&quot;Greg&quot;;</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性<code>name</code>，<code>color</code>。</li><li>第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性<code>name</code>，<code>color</code>。</li></ul><p>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象<code>SubType.prototype</code>的两个同名属性。所以，组合模式的缺点就是在<strong>使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</strong></p><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p><strong>解决构造函数被执行两次</strong>的问题, 我们将<strong>指向父类实例改为指向父类原型</strong>, 减去一次构造函数的执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(superType.prototype); <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">  prototype.constructor = subType;                    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">  subType.prototype = prototype;                      <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类初始化实例属性和原型属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将子类的原型对象指向父类原型</span></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类原型属性</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;xyc&quot;</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;lxy&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">instance1.colors.push(<span class="string">&quot;2&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]</span></span><br><span class="line">instance1.colors.push(<span class="string">&quot;3&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;]</span></span><br></pre></td></tr></table></figure><p>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code> 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code> 和<code>isPrototypeOf()</code></p><p><strong>这是最成熟的方法，也是现在库实现的方法</strong>。</p><h4 id="ES6类继承extends"><a href="#ES6类继承extends" class="headerlink" title="ES6类继承extends"></a>ES6类继承extends</h4><p><code>extends</code>关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中<code>constructor</code>表示构造函数，一个类中只能有一个构造函数，有多个会报出<code>SyntaxError</code>错误,如果没有显式指定构造方法，则会添加默认的 <code>constructor</code>方法，使用例子如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getter</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.calcArea()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Method</span></span><br><span class="line">    <span class="function"><span class="title">calcArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rectangle.area);</span><br><span class="line"><span class="comment">// 输出 200</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(length, length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Square&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> Square(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(square.area);</span><br><span class="line"><span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>多态</strong>（Polymorphism）按字面的意思就是“多种状态”,在面向对象语言中，接口的多种不同的实现方式即为多态。</p><p><strong>可以解释为：</strong>同样的操作作用于不同对象上面，可以产生不同的解释和不同的运行结果。换句话说，给不同对象发送统一消息的时候，这些对象会根据这个信息分别给出不同的反馈。</p><p>JavaScript的多态的思想实际上就是把“做什么”和“谁去做”分离开来，要实现这一点，归根结底就是解耦。</p><p><strong>区分方法的重写和重载？</strong></p><ul><li><p>二者的概念：</p><ul><li><p>方法的重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.</p></li><li><p>方法的重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p></li></ul></li><li><p>重载：不表现为多态性。 重写：表现为多态性。</p></li></ul><h2 id="原型与原型链★"><a href="#原型与原型链★" class="headerlink" title="原型与原型链★"></a>原型与原型链★</h2><blockquote><p>考察公司：完美世界、小米、字节、腾讯、百度</p></blockquote><p><code>JS</code>中所有对象都具有一个<code>__proto__</code>隐式原型属性，指向该对象的原型对象。</p><p>每个函数都有一个<code>prototype</code>属性，也指向原型对象，原型对象有个<code>constructor</code>属性，指向该函数。</p><p>所有的对象（除了Object原型对象）本质上都是通过<code>new 函数</code>创建的。</p><p><strong>所有的函数（Object、Array、Function）都是对象</strong>，本质上都是通过<code>new Function</code>创建的。</p><p>实例对象的隐式原型属性<code>__proto__</code>指向其构造函数的显式原型属性<code>prototype</code>。</p><p>所有函数(包括<code>Function</code>)的隐式原型<code>__proto__</code>指向<code>Function</code>的显式原型（<code>Function.prototype</code>）。</p><p>所有函数（包括Function）的<strong>原型对象</strong>(默认是<strong>Object实例对象</strong>)都指向（<code>__proto__</code>）<strong>Object的原型对象</strong>。</p><p>Object的原型对象指向<code>null</code>。</p><p>实例对象在查找属性时，如果查找不到，就会沿着<code>__proto__</code>隐式原型去与对象关联的原型上查找，如果还查找不到，就去找原型的原型，直至查到最顶层null，这也就是<strong>原型链</strong>的概念。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TkhJ0I"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2021/12/17/TkhJ0I.png" alt="TkhJ0I.png"></a></p><h2 id="Js中的堆栈★"><a href="#Js中的堆栈★" class="headerlink" title="Js中的堆栈★"></a>Js中的堆栈★</h2><blockquote><p>考察公司：腾讯、华为</p></blockquote><p>堆<code>heap</code>是<strong>动态分配</strong>的内存，<strong>大小不定</strong>也<strong>不会自动释放</strong>，栈<code>stack</code>为<strong>自动分配</strong>的内存空间，在代码执行过程中<strong>自动释放</strong>。</p><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>在栈内存中提供一个供<code>Js</code>代码执行的环境，关于<strong>作用域</strong>以及<strong>函数的调用</strong>都是栈内存中执行的。</p><p><code>Js</code>中基本数据类型<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Null</code>、<code>Undefined</code>、<code>Symbol</code>、<code>BigInt</code>，</p><ul><li><strong>占用空间小且大小固定</strong>，<strong>值直接保存在栈内存中，是按值访问</strong>，</li><li>对于<code>Object</code>引用类型，其<strong>指针放置于栈内存中</strong>，<strong>指向堆内存的实际地址</strong>，是通过<strong>引用</strong>访问。</li></ul><p>关于调用栈，每调用一个函数，解释器就会把该函数添加进调用栈并开始执行；</p><p>正在调用栈中执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行；</p><p>当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码；</p><p>当分配的调用栈空间被占满时，会引发<strong>堆栈溢出</strong>错误。</p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>引用类型<code>Object</code>的变量<strong>占据空间大且大小不固定</strong>，堆内存中存储<strong>实际对象</strong>，在栈内存中存储对象的指针。</p><p>对于对象的访问是按引用访问的，在堆区的内存不会随着程序的运行而自动释放，这就需要实现<strong>垃圾回收机制</strong><code>GC</code>。</p><h2 id="垃圾回收★"><a href="#垃圾回收★" class="headerlink" title="垃圾回收★"></a>垃圾回收★</h2><blockquote><p>考察公司：小米、完美世界、腾讯、百度、华为</p></blockquote><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存。</p><p>并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存。</p><p>对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>需要注意的是在<code>Js</code>中没有类似于<code>C</code>中的<code>free()</code>函数去手动释放内存，对于堆区内存回收全部需要通过<code>Js</code>的垃圾回收机制去实现。<br>在<strong>栈</strong>区中执行的变量等是通过值访问，当其<strong>作用域销毁后变量也就随之销毁</strong>，</p><p>而使用引用访问的堆区变量，在一个作用域消失后还可能在外层作用域或者其他作用域仍然<strong>存在引用</strong>，不能直接销毁，</p><p>此时就需要通过算法计算该堆区变量是否属于不再需要的变量，从而决定是否需要进行内存回收，</p><p>在<code>Js</code>中主要有<strong>引用计数</strong>与<strong>标记清除</strong>两种垃圾回收算法。</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>对于引用计数垃圾回收算法，把对象是否不再需要简化定义为<strong>该对象有没有其他变量或对象引用到它</strong>，如果没有引用指向该对象，该对象将被垃圾回收机制回收。</p><p>在这里，对象的概念不仅特指<code>JavaScript</code>对象，还包括函数作用域或者全局词法作用域。</p><p>引用计数垃圾回收算法使用比较少，主要是在<code>IE6</code>与<code>IE7</code>等低版本<code>IE</code>浏览器中使用。</p><p>但是对于引用计数垃圾回收算法有个限制，当对象<strong>循环引用</strong>时，就会造成<strong>内存泄漏</strong>，也就是引用计数垃圾回收算法无法处理循环引用的对象。</p><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>对于标记清除垃圾回收算法，把对象是否不再需要简化定义为<strong>该对象是否可以获得</strong>。</p><p>该算法设置一个叫做根<code>root</code>的对象，在<code>Javascript</code>里根是全局对象，垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象，以此不断向下查找。</p><p><strong>从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象</strong>，这样便解决了循环引用的问题。</p><p>所有现代浏览器都使用了标记清除垃圾回收算法，所有对<code>JavaScript</code>垃圾回收算法的改进都是基于标记清除算法的改进。</p><ul><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都<strong>加上标记</strong>。</li><li>然后，它会<strong>去掉</strong>运行环境中的变量以及被环境中变量所引用的变量的标记。</li><li>此后，<strong>依然有标记</strong>的变量就被视为准备删除的变量，原因是<strong>在运行环境中已经无法访问到这些变量了</strong>。</li><li>最后，垃圾收集器完成内存清除工作，<strong>销毁那些带标记的值并回收它们所占用的内存空间</strong>。</li></ul><h3 id="V8对GC的优化"><a href="#V8对GC的优化" class="headerlink" title="V8对GC的优化"></a>V8对GC的优化</h3><p>V8 的垃圾回收策略主要基于分代式垃圾回收机制，这我们说过，关于新生代垃圾回收器，我们说使用并行回收可以很好的增加垃圾回收的效率，那老生代垃圾回收器用的哪个策略呢？我上面说了并行回收、增量标记与惰性清理、并发回收这几种回收方式来提高效率、优化体验，看着一个比一个好，那老生代垃圾回收器到底用的哪个策略？难道是并发？？内心独白：” 好像。。貌似。。并发回收效率最高 “</p><p>其实，这三种方式各有优缺点，所以在老生代垃圾回收器中这几种策略都是融合使用的。</p><p><strong>老生代主要使用并发标记</strong>，主线程在开始执行 <code>JavaScript</code> 时，辅助线程也同时执行标记操作（标记操作全都由辅助线程完成）。</p><p>标记完成之后，再执行<strong>并行清理操作</strong>（主线程在执行清理操作时，多个辅助线程也同时执行清理操作）。</p><p>同时，清理的任务会采用<strong>增量</strong>的方式分批在各个 <code>JavaScript</code> 任务之间执行。</p><h3 id="常见内存泄露情况及解决方法"><a href="#常见内存泄露情况及解决方法" class="headerlink" title="常见内存泄露情况及解决方法"></a>常见内存泄露情况及解决方法</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    bar = <span class="string">&quot;this is a hidden global variable&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种意外的全局变量可能由 <code>this</code> 创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.variable = <span class="string">&quot;potential accidental global&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 调用自己，this 指向了全局对象（window）</span></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上述使用<strong>严格模式</strong>，可以避免意外的全局变量。</p><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>定时器也常会造成内存泄露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = getData();</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;Node&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        <span class="comment">// 处理 node 和 someResource</span></span><br><span class="line">        node.innerHTML = <span class="built_in">JSON</span>.stringify(someResource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>如果<code>id</code>为Node的元素从<code>DOM</code>中移除，该定时器仍会存在，同时，因为回调函数中包含对<code>someResource</code>的引用，定时器外面的<code>someResource</code>也不会被释放。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>包括我们之前所说的闭包，维持函数内局部变量，使其得不到释放。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">document</span>.createElement(<span class="string">&#x27;XXX&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj, <span class="string">&#x27;闭包内引用obj obj不会被释放&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  obj = <span class="literal">null</span>; <span class="comment">// 解决方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dom"><a href="#dom" class="headerlink" title="dom"></a>dom</h4><p>没有清理对<code>DOM</code>元素的引用同样造成内存泄露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refA = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;refA&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.removeChild(refA); <span class="comment">// dom删除了</span></span><br><span class="line"><span class="built_in">console</span>.log(refA, <span class="string">&#x27;refA&#x27;</span>); <span class="comment">// 但是还存在引用能console出整个div 没有被回收</span></span><br><span class="line">refA = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(refA, <span class="string">&#x27;refA&#x27;</span>); <span class="comment">// 解除引用</span></span><br></pre></td></tr></table></figure><h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>包括使用事件监听<code>addEventListener</code>监听的时候，在不监听的情况下使用<code>removeEventListener</code>取消对事件监听。</p><h4 id="解决内存泄漏的数据结构"><a href="#解决内存泄漏的数据结构" class="headerlink" title="解决内存泄漏的数据结构"></a>解决内存泄漏的数据结构</h4><p>WeakSet WeakMap</p><h2 id="数据类型★"><a href="#数据类型★" class="headerlink" title="数据类型★"></a>数据类型★</h2><blockquote><p>考察公司：字节</p></blockquote><blockquote><p>JavaScript 是一种<strong>弱类型</strong>或者说<strong>动态</strong>语言。</p><p><strong>不用提前声明变量的类型</strong>，在程序<strong>运行</strong>过程中，<strong>类型会被自动确定</strong>。</p><p>可以使用<strong>同一个变量保存不同类型的数据</strong>。</p></blockquote><h3 id="7-1"><a href="#7-1" class="headerlink" title="7+1"></a>7+1</h3><ul><li>原始类型(值不可变，栈)：<code>Undefined</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>BigInt</code>、<code>Symbol</code>、<code>Null</code></li><li>引用数据类型（堆，地址：栈）：<code>Object</code>（几乎所有通过 <code>new</code> 创建的东西：Array、Set、Date）</li></ul><h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p><strong>操作符</strong></p><p>对于<strong>原始类型</strong>，除 <code>null</code> （遗留已久的 bug）都可以正确判断；</p><p>对于引用类型，除 <code>function</code> 外，都会返回 <code>&#39;object&#39;</code>。</p><p>返回值为 <code>string</code> （小写）。</p><p><code>typeof</code> 未定义的变量返回 <code>&#39;undefined&#39;</code>。</p><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p><strong>操作符</strong></p><p>用于检测构造函数的 <code>prototype</code> 属性是否出现在<strong>某个实例对象的原型链上</strong>。只能判断<strong>引用类型</strong>。</p><p>常用来判断 <code>A</code> 是否为 <code>B</code> 的实例。返回布尔值。</p><p><code>instanceof</code> 在多全局对象(例如：多个 frame 或多个 window 之间的交互)下不能正确判断。</p><p><strong>多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。</strong></p><h4 id="Object-prototype-toString-call-toString-call"><a href="#Object-prototype-toString-call-toString-call" class="headerlink" title="Object.prototype.toString.call()/toString.call()"></a>Object.prototype.toString.call()/toString.call()</h4><p>精准判断数据类型 。</p><p>统一返回格式<code>&#39;[object Xxx]&#39;</code> 的字符串</p><h3 id="判断数组"><a href="#判断数组" class="headerlink" title="判断数组"></a>判断数组</h3><ul><li><p><code>Array.isArray()</code></p></li><li><p><code>Object.prototype.toString.call()</code> 进行判断，此方式兼容性最好</p></li><li><p><code>instanceof</code></p><p>多个 frame 或多个 window 之间的交互不适用。</p></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><blockquote><p>隐式（自动）/显式强转（开发人员）</p></blockquote><p><strong>在 JS 中只会转换为以下 3 种类型</strong></p><ul><li><p><code>Number</code> 类型：</p><ul><li><p>强转：</p><ul><li><p><code>Number()</code></p><ul><li>字符串：<strong>空字符串变为0</strong>，如果出现<strong>任何一个非有效数字字符</strong>，结果都是<code>NaN</code></li><li>布尔： <code>true-&gt;1</code> <code>false-&gt;0</code></li><li><code>null-&gt;0</code> <code>undefined-&gt;NaN</code></li><li>Symbol<strong>无法</strong>转换为数字，<code>BigInt去除“n”</code></li><li><strong>对象</strong>：<ul><li><code>&#123;&#125;</code>：先转字符串<code>&#39;[object Object]&#39;</code>再转数字<code>NaN</code></li><li><code>[]</code>：先转字符串<code>&#39;&#39;</code>再转数字<code>0</code></li><li><code>[1]</code>：先转字符串<code>&#39;1&#39;</code>再转数字<code>1</code></li><li><code>[1,2]</code>：先转字符串<code>&#39;1,2&#39;</code>再转数字<code>NaN</code></li></ul></li></ul></li><li><p><code>parseInt(string, radix)</code>：</p><p><strong>逐个</strong>解析字符，并返回一个<strong>整数</strong>。</p><p>当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p></li><li><p><code>parseFloat(string)</code>：</p><p>指定字符串中的首个字符是否是数字。是，解析，直到到达数字的末端为止返回该数字。</p></li></ul></li><li><p>隐式：</p><ul><li>比较操作（<code>&gt;, &lt;, &lt;=, &gt;=</code>）</li><li>按位操作（<code>| &amp; ^ ~</code>）</li><li>算数操作（<code>- + * / %</code>） <strong>注意</strong>：当 <code>+</code> 操作存在任意的操作数是 <code>string</code> 类型时，不会触发number 类型的隐式转换</li></ul></li></ul></li><li><p><code>String</code> 类型：</p><ul><li>强转：<code>String()</code> / <code>toString()</code>(数组方法)</li><li>隐式：有 <code>+</code> 运算符并且有一个操作数是 <code>string/object</code> 类型</li></ul></li><li><p><code>Boolean</code> 类型:</p><ul><li>强转：<code>Boolean()</code></li><li>隐式：<strong>逻辑判断</strong>或者有逻辑运算符（<code>|| &amp;&amp; !</code>），<strong>逻辑运算符内部转换和比较，实际返回原始操作数值</strong><ul><li><strong>false</strong>：<code>0</code> <code>NaN</code> <code>&quot;&quot;</code> <code>null</code> <code>undefined</code>，其余都是true</li></ul></li></ul></li></ul><h3 id="amp-★"><a href="#amp-★" class="headerlink" title="=== &amp; ==★"></a><code>=== &amp; ==</code>★</h3><blockquote><p>考察公司：百度</p></blockquote><ul><li><code>===</code> 是严格相等，要求数据类型和值都要相等；<code>==</code> 只需要值相等。</li><li><code>==</code> 会发生隐式类型转换，<code>===</code> 不会发生隐式类型转换。</li></ul><p><code>==</code>类型转换规则</p><ul><li>两个<strong>对象</strong>，比较引用 <code>&#123;&#125;==&#123;&#125; //false</code></li><li><code>null/undefined</code>和其他任何值都不相等，但<code>null==undefined //true</code></li><li><code>NaN==NaN //false</code></li><li>一个<strong>对象</strong>，另一个是<strong>数字或字符串</strong>，会尝试使用<strong>对象方法转换为原始值</strong> <code>[] == 0 // true</code></li><li>当<strong>数字</strong>与<strong>字符串</strong>进行比较时，会尝试<strong>将字符串转换为数字值</strong>。<code>&#39;1222&#39;==1222 // true</code></li><li>操作数之一是<strong>Boolean</strong>，则将<strong>布尔操作数转换为1或0</strong> <code>true == 2 // false</code></li></ul><p>例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[] == ![]<span class="comment">// true</span></span><br><span class="line">![]=&gt;<span class="literal">false</span></span><br><span class="line"><span class="literal">false</span>=&gt;<span class="number">0</span></span><br><span class="line">[]=&gt;<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a><code>Object.is()</code></h3><p>判断两个值是否为同一个值。如果满足以下条件则两个值相等:</p><ul><li>都是 <code>undefined</code></li><li>都是 <code>null</code></li><li>都是 <code>true</code> 或 <code>false</code></li><li>都是相同长度的字符串且相同字符按相同顺序排列</li><li>都是相同对象（意味着每个对象有同一个引用）</li><li>都是数字且<ul><li>都是 <code>+0</code></li><li>都是 <code>-0</code></li><li>都是 <code>NaN</code></li><li>或都是非零而且非 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a> 且为同一个值</li></ul></li></ul><p>与<code>==</code>运算<em>不同。</em> <code>==</code> 运算符在判断相等前对两边的变量(如果它们不是同一类型) 进行强制转换, 而 <code>Object.is</code>不会强制转换两边的值。</p><p>与<code>===</code>运算也不相同。 <code>===</code> 运算符 (也包括 <code>==</code> 运算符) 将数字 <code>-0</code> 和 <code>+0</code> 视为相等 ，而将<code>Number.NaN</code>与<code>NaN</code>视为不相等。</p><h2 id="数组★"><a href="#数组★" class="headerlink" title="数组★"></a>数组★</h2><blockquote><p>考察公司：完美世界、字节、美团、华为、百度、腾讯</p></blockquote><p>常见的数组定义：<strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p><p><strong>JavaScript 数组的长度和元素类型都是非固定的。</strong></p><p>因为数组的<strong>长度可随时改变</strong>，并且其数据<strong>在内存中也可以不连续</strong>（存储相同类型元素内存连续）。</p><h3 id="JS数组常用方法总结★"><a href="#JS数组常用方法总结★" class="headerlink" title="JS数组常用方法总结★"></a>JS数组常用方法总结★</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/j0lv5T"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/07/j0lv5T.png" alt="j0lv5T.png" style="zoom:33%"></a></p><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p><code>Array.from()</code> 从一个<strong>类数组</strong>或<strong>可迭代对象</strong>创建一个<strong>新的</strong>、<strong>浅拷贝</strong>的Array实例。</p><p><code>Array.isArray()</code>判断数组</p><h4 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h4><p><code>Array.prototype.length</code></p><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p><strong>改变原数组</strong>的方法:</p><ul><li><code>push(element1, ...)</code>：<strong>末尾</strong>+1/多，并返回<code>length</code></li><li><code>pop()</code>：<strong>删除最后一个元素</strong>，并<strong>返回该元素的值</strong>。</li><li><code>unshift(element1, ...)</code>：<strong>开头</strong>+1/多，并返回<code>length</code></li><li><code>shift()</code>：<strong>删除第一个元素</strong>，并<strong>返回该元素的值</strong>。</li><li><code>splice(开始,删除个数,新元素1...)</code>：<strong>删除</strong>或<strong>替换</strong>现有元素或者<strong>原地添加</strong>新的元素来修改数组,并<strong>以数组形式返回被删除的元素</strong></li><li><code>sort([比较函数])</code>：<strong>原地算法</strong>对数组的元素进行排序，并返回数组。比较函数返回值&gt;0,交换a、b。升序排列：<code>arr.sort((a,b)=&gt;a - b)</code></li><li><code>reverse()</code>：翻转数组</li><li><code>fill(1,0,this.length)</code>：用一个<strong>固定值</strong>填充一个数组中从<strong>起始索引</strong>到<strong>终止索引</strong>内的全部元素。<strong>不包括终止索引</strong>。返回<strong>修改后的数组</strong>。</li></ul><p><strong>不改变原数组</strong>的方法:</p><ul><li><code>slice(begin,end)</code>：返回一个新的数组对象(一个<code>[begin,end)</code>决定的原数组的<strong>浅拷贝</strong>）</li><li><code>join(&#39;&#39;)</code>：将一个数组（或一个<strong>类数组对象</strong>）的所有元素连接成一个<strong>字符串</strong>并返回这个字符串。默认<code>,</code>分隔。</li><li><code>concat(arr1,...)</code>：合并数组，<strong>浅拷贝</strong></li><li><code>indexOf(searchElement, fromIndex)</code>：返回在数组中可以找到一个<strong>给定元素的第一个索引</strong>，如果不存在，则返回<code>-1</code>。严格相等<code>===</code>搜索元素。不能识别<code>NaN</code>。</li><li><code>includes</code>：判断一个数组是否包含一个指定的值，返回<strong>布尔值</strong>。</li></ul><p><strong>遍历</strong>方法:</p><ul><li><code>keys/values/entries</code><ul><li><code>arr.keys()/arr.values()/arr.entries()</code></li><li>返回一个新的<strong>Array Iterator</strong>对象，遍历<strong>索引键</strong>、遍历<strong>键值</strong>、遍历<strong>索引键+键值</strong></li><li>在<code>for..of</code>中如果遍历中途要退出，可以使用<code>break</code>退出循环。</li></ul></li></ul><h3 id="常见遍历方法及手写★"><a href="#常见遍历方法及手写★" class="headerlink" title="常见遍历方法及手写★"></a>常见遍历方法及手写★</h3><p>参考：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#polyfill">forEach#polyfill</a></p><h4 id="for、for…in和for…of有什么区别？"><a href="#for、for…in和for…of有什么区别？" class="headerlink" title="for、for…in和for…of有什么区别？"></a>for、for…in和for…of有什么区别？</h4><p>for 和 for ..of 可以使用 break 或者 continue 跳过或中断。</p><p>for …of 直接访问的是实际元素。for 遍历数组索引。</p><p>for …of 与 for 如果数组中存在空元素，同样会执行。</p><p><code>for…of</code> 是<code>ES6</code>新增的遍历方式，允许遍历一个含有<code>iterator</code>接口的数据结构（数组等）并且返回各项的值，和ES3中的<code>for…in</code>的区别如下：</p><ul><li><code>for…of</code> 遍历获取的是对象的<strong>键值</strong>，<code>for…in</code> 获取的是对象的<strong>键名</strong>；</li><li><code>for… in</code> 会遍历对象的整个<strong>原型链</strong>，性能非常差不推荐使用，而 <code>for … of</code> <strong>只遍历当前对象</strong>不会遍历原型链；</li><li>对于数组的遍历，<code>for…in</code> 会返回<strong>数组中所有可枚举的属性</strong>(包括原型链上可枚举的属性)，<code>for…of</code> 只返回数组的<strong>下标对应的属性值</strong>；</li></ul><p>总结： <code>for...in</code> 循环主要是为了<strong>遍历对象</strong>而生，不适用于遍历数组；<code>for...of</code> 循环可以用来<strong>遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象</strong>。</p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p><code>forEach</code>：对数组的每个元素执行一次给定的函数。<code>array.forEach(function(currentValue, index, arr), thisArg)</code></p><ul><li>无法break中途退出循环，只能用<code>return</code>退出本次回调，进行下一次回调。</li><li>它总是返回 <code>undefined</code>值,即使你return了一个值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype._forEach = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;this is null or not defined&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> O = <span class="built_in">Object</span>(<span class="built_in">this</span>)  <span class="comment">// this就是当前的数组 转为对象</span></span><br><span class="line">    <span class="keyword">const</span> len = O.length &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//无符号右移 0 位 保证转换后的值为正整数</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">            callback.call(thisArg, O[k], k, O);</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">onst array1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> f=array1._forEach(<span class="function"><span class="params">element</span> =&gt;</span> <span class="built_in">console</span>.log(element));<span class="comment">// a b c</span></span><br><span class="line"><span class="built_in">console</span>.log(f);<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><code>map</code>：创建一个<strong>新数组</strong>，其结果是<strong>该数组中的每个元素都调用一个提供的函数后返回的结果</strong>。</p><ul><li><p>可以使用break中断循环，可以使用return返回到外层函数。</p></li><li><p>map 会将回调函数的返回值组成一个新数组，数组长度与原数组一致。</p></li><li><p><code>let new_array = arr.map(function(currentValue, index, arr), thisArg)</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype._map = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;this is null or not defined&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> O = <span class="built_in">Object</span>(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">const</span> len = O.length &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span>, res = []</span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">            res[k] = callback.call(thisArg, O[k], k, O);</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> array2 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>];</span><br><span class="line"><span class="keyword">const</span> map1 = array2._map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map1); <span class="comment">// [2, 8, 18, 32]</span></span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p><code>filter</code>：返回一个<strong>新数组</strong>, 其包含<strong>通过所提供函数实现的测试的所有元素</strong>。</p><ul><li><code>let new_array = arr.filter(function(currentValue, index, arr), thisArg)</code></li><li>filter 会将符合回调函数条件的元素组成一个新数组，数组长度与原数组可能不同。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype._filter = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;this is null or not defined&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> O = <span class="built_in">Object</span>(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">const</span> len = O.length &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span>, res = []</span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">            <span class="keyword">if</span> (callback.call(thisArg, O[k], k, O)) &#123;</span><br><span class="line">                res.push(O[k])                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> words = [<span class="string">&#x27;spray&#x27;</span>, <span class="string">&#x27;limit&#x27;</span>, <span class="string">&#x27;elite&#x27;</span>, <span class="string">&#x27;exuberant&#x27;</span>, <span class="string">&#x27;destruction&#x27;</span>, <span class="string">&#x27;present&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> result = words._filter(<span class="function"><span class="params">word</span> =&gt;</span> word.length &gt; <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//[&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="some"><a href="#some" class="headerlink" title="some"></a>some</h4><p><code>some</code>：测试数组中是不是<strong>至少有1个元素</strong>通过了被提供的函数测试。它返回的是一个<code>Boolean</code>类型的值。</p><ul><li>some 若某一元素满足条件，返回 true，循环中断；所有元素不满足条件，返回 false。</li><li>every 与 some 相反，若有1个元素不满足条件，返回 false，循环中断；所有元素满足条件，返回 true。</li></ul><ul><li><code>let bool = arr.some(function(currentValue, index, arr), thisArg)</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype._some = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;this is null or not defined&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> O = <span class="built_in">Object</span>(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">const</span> len = O.length &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">            <span class="keyword">if</span> (callback.call(thisArg, O[k], k, O)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> even = <span class="function">(<span class="params">element</span>) =&gt;</span> element % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(array.some(even));<span class="comment">//  true</span></span><br></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p><code>find</code>:用于找出<strong>第一个符合条件</strong>的数组成员，并<strong>返回该成员</strong>，如果没有符合条件的成员，则返回<code>undefined</code>。</p><ul><li><code>let new_array = arr.find(function(currentValue, index, arr), thisArg)</code></li><li>find 方法返回数组中满足 callback 函数的第一个元素的值。如果不存在返回 undefined。</li><li>findIndex 它返回数组中找到的元素的索引，而不是其值，如果不存在返回 -1。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype._find = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;this is null or not defined&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> O = <span class="built_in">Object</span>(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">const</span> len = O.length &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">            <span class="keyword">if</span> (callback.call(thisArg, O[k], k, O)) &#123;</span><br><span class="line">                <span class="keyword">return</span> O[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> array3 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"><span class="keyword">const</span> found = array3._find(<span class="function"><span class="params">element</span> =&gt;</span> element &gt; <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(found);<span class="comment">//12</span></span><br></pre></td></tr></table></figure><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p><code>reduce</code>：对累加器和数组中的每个元素（<strong>从左到右</strong>）应用一个函数，最终合并为一个值。</p><ul><li><code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code></li><li>如果 <code>initialValue</code> 在调用 reduce 时被提供，那么<strong>第一个</strong> <code>total</code> 将等于 <code>initialValue</code>，此时 <code>currentValue</code> 等于数组中的<strong>第一个值</strong>；</li><li>如果 <code>initialValue</code> 未被提供，那么 <code>total</code> 等于数组中的<strong>第一个值</strong>，<code>currentValue</code> 等于数组中的<strong>第二个值</strong>。</li><li>reduceRight 方法除了与reduce执行方向相反外(从右往左)，其他完全与其一致。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype._reduce = <span class="function"><span class="keyword">function</span>(<span class="params">callback, initialValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;this is null or not defined&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> O = <span class="built_in">Object</span>(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">const</span> len = O.length &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span>, acc</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        acc = initialValue</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没传入初始值的时候，取数组中第一个非 empty 的值为初始值</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; len &amp;&amp; !(k <span class="keyword">in</span> O)) &#123;</span><br><span class="line">            k++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; len) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>( <span class="string">&#x27;Reduce of empty array with no initial value&#x27;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        acc = O[k++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">            acc = callback(acc, O[k], k, O)</span><br><span class="line">        &#125;</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// 数组求和 </span></span><br><span class="line"><span class="keyword">let</span> sum = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]._reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;, <span class="number">0</span>);<span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 将二维数组转化为一维 将数组元素展开</span></span><br><span class="line"><span class="keyword">let</span> flattened = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]]._reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.concat(b),[]);<span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(sum,flattened)</span><br></pre></td></tr></table></figure><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p><code>for</code>循环的速度是最快的,是最老的循环,也是优化得最好的,其次是<code>for-of</code>这个是es6才新增的循环非常好用,最慢是<code>for-in</code>我们可以作一下速度排序。</p><p><code>for</code>&gt;<code>for-of</code>&gt;<code>forEach</code> &gt;<code>filter</code>&gt;<code>map</code> &gt;<code>for-in</code></p><h3 id="数组去重★"><a href="#数组去重★" class="headerlink" title="数组去重★"></a>数组去重★</h3><p><strong>Set</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line">    <span class="comment">// return Array.from(new Set(arr));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>map去重</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique =<span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map =<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> a <span class="keyword">of</span> arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.has(n))map.set(n,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [...map.keys()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Object属性去重（时间复杂度低）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique =<span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">const</span> obj=&#123;&#125;;<span class="comment">// const obj = &#123;&#125;,newArr=[];</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> a <span class="keyword">of</span> arr)&#123;</span><br><span class="line">       <span class="keyword">if</span>(!obj[a])obj[a]=<span class="number">1</span>;<span class="comment">// newArr.push(arr[i]);</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Object</span>.keys(obj).map(<span class="built_in">Number</span>);<span class="comment">// return newArr; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>indexOf/includes+for/forEach/for…of</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newArr = [];</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// if(newArr.indexOf(a) === -1)  newArr.push(a);</span></span><br><span class="line">        <span class="keyword">if</span>(!newArr.includes(a)) newArr.push(a);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>filter配合indexOf</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.indexOf(cur) === index;<span class="comment">// 将原数组中每一个首次出现的元素存入新数组</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>reduce配合includes</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// res最初是[],遍历每一个元素，如果不在res中就放入，最后返回res</span></span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">res,cur</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!res.includes(cur))res.push(cur);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,[])  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原数组去重</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique7 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr=<span class="built_in">this</span>,len = <span class="built_in">this</span>.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">                arr.splice(j, <span class="number">1</span>);</span><br><span class="line">                len--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr1)</span><br><span class="line"><span class="built_in">console</span>.log(arr1.unique7())</span><br><span class="line"><span class="built_in">console</span>.log(arr1)</span><br></pre></td></tr></table></figure><h3 id="数组交-并集★"><a href="#数组交-并集★" class="headerlink" title="数组交/并集★"></a>数组交/并集★</h3><p>库函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> intersection = <span class="function">(<span class="params">nums1, nums2</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>(nums1)].filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Set</span>(nums2).has(x));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>交并差</strong></p><ul><li>交：<code>[...new Set(nums1)].filter(x =&gt; new Set(nums2).has(x));</code></li><li>并：<code>[...new Set([...nums1, ...nums2])]</code></li><li>差：<code>[...new Set(nums1)].filter(x =&gt; !new Set(nums2).has(x))</code></li></ul><p>依然使用set，但将去重和遍历交集拆分，降低复杂度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> intersection = <span class="function">(<span class="params">nums1, nums2</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(nums1),res=[];</span><br><span class="line">    nums2.forEach(<span class="function"><span class="params">n</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.has(n))&#123;</span><br><span class="line">            res.push(n);</span><br><span class="line">            set.delete(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="求数组的深度★"><a href="#求数组的深度★" class="headerlink" title="求数组的深度★"></a>求数组的深度★</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDeep</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> arr = []</span><br><span class="line">        <span class="keyword">let</span> arrLength = arr.length</span><br><span class="line">        <span class="comment">// 先遍历是不是里面还有对象类型，是就计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> (obj[item]) === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 然后把这个再存到数组中下次遍历</span></span><br><span class="line">                <span class="comment">// arr.push([...obj[item]])</span></span><br><span class="line">                <span class="comment">// 要分别存入，否则下次死循环</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj[item]) &#123;</span><br><span class="line">                    arr.push(obj[item][key])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束后判断arr有没有增加</span></span><br><span class="line">        <span class="keyword">if</span> (arr.length &gt; arrLength) &#123;</span><br><span class="line">            res++</span><br><span class="line">            arrLength = arr.length</span><br><span class="line">            <span class="comment">// 继续递归</span></span><br><span class="line">            <span class="keyword">return</span> fn(arr)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何实现数组扁平化★"><a href="#如何实现数组扁平化★" class="headerlink" title="如何实现数组扁平化★"></a>如何实现数组扁平化★</h3><p>数组扁平化就是把多维数组转化成一维数组。</p><h4 id="flat-depth"><a href="#flat-depth" class="headerlink" title="flat(depth)"></a>flat(depth)</h4><p>不会改变原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,[<span class="number">5</span>]]]];  </span><br><span class="line">a.flat(<span class="number">4</span>-<span class="number">1</span>); <span class="comment">// [1,2,3,4,5]  a是4维数组</span></span><br><span class="line">a.flat(<span class="literal">Infinity</span>); <span class="comment">// [1,2,3,4,5]  a是4维数组</span></span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flatten = <span class="function">(<span class="params">arr, dep=<span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i]) &amp;&amp; dep &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res = res.concat(flatten(arr[i], --dep))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Array原型上写方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFlat = <span class="function"><span class="keyword">function</span>(<span class="params">dep = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];<span class="comment">// 声明一个新数组</span></span><br><span class="line">    <span class="built_in">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;<span class="comment">// 遍历原数组</span></span><br><span class="line">        <span class="comment">// 当原数组内存在数组并且层级dep大于0时递归</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(item) &amp;&amp; dep &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 层级递减并使用concat链接数组</span></span><br><span class="line">            res = [...res,...item.myFlat(--dep)];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用reduce</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype._flat2 = <span class="function"><span class="keyword">function</span> (<span class="params">dep = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">res, item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(item) &amp;&amp; dep &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res.push(...item._flat2(--dep))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简单 利用展开语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype._flat3 = <span class="function"><span class="keyword">function</span> (<span class="params">dep = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=[...this];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dep; ++i) &#123;</span><br><span class="line">        res = [].concat(...res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]]]];</span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(arr.flat());</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(arr._flat1(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(arr._flat2(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(arr._flat3(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h3 id="类数组-set转化为数组"><a href="#类数组-set转化为数组" class="headerlink" title="类数组/set转化为数组"></a>类数组/set转化为数组</h3><p>类数组是具有<strong>length</strong>属性，但不具有数组原型上的方法。常见的类数组有<strong>arguments</strong>、<strong>DOM操作方法返回的结果</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b,c,d</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>))</span><br><span class="line">    <span class="built_in">console</span>.log([].slice.call(<span class="built_in">arguments</span>))<span class="comment">// Array.prototype.slice.call(arguments)</span></span><br><span class="line">    <span class="built_in">console</span>.log([...arguments])</span><br><span class="line">    <span class="built_in">console</span>.log([].concat.apply([], <span class="built_in">arguments</span>))<span class="comment">// 该方法如果类数组中有数组会展开一层放入新的数组</span></span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>,<span class="number">5</span>,<span class="string">&#x27;s&#x27;</span>,[<span class="number">2</span>,[<span class="number">3</span>]])</span><br></pre></td></tr></table></figure><p>set转化为数组</p><ul><li>使用扩展运算符“<code>...</code>”，语法“[…set对象]”；</li><li>使用<code>Array.from()</code>方法，语法“Array.from(set对象)”。</li><li>set没有length属性，所以没法用[].slice.call()等方法。</li></ul><h3 id="随机打乱数组shuffle★"><a href="#随机打乱数组shuffle★" class="headerlink" title="随机打乱数组shuffle★"></a>随机打乱数组shuffle★</h3><p>Fisher–Yates shuffle 洗牌算法可以做到理论上的完全乱序</p><p>lodash.js 中的 shuffle 函数也使用此算法实现</p><p>实现算法如下：</p><ul><li>设待原地乱序的数组<code>nums</code>。</li><li>循环n次，在第i次循环中（0&lt;=i&lt;n）：<ul><li>在 <code>[i,n)</code>中随机抽取一个下标 <code>j</code>；</li><li>将第 <code>i</code>个元素与第 <code>j</code>个元素交换。</li></ul></li></ul><p>其中数组中的<code>nums[i,..,n−1]</code> 的部分为待乱序的数组，其长度为 <code>n-i</code>；<code>nums[0, .. ,i−1]</code> 的部分为乱序后的数组，其长度为 <code>i</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Solution = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.nums=nums;</span><br><span class="line">    <span class="built_in">this</span>.original=[...nums];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Solution.prototype.reset = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.nums=[...this.original];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.nums;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Solution.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (<span class="built_in">this</span>.nums.length - i)) + i;</span><br><span class="line">        [<span class="built_in">this</span>.nums[i],<span class="built_in">this</span>.nums[j]]=[<span class="built_in">this</span>.nums[j],<span class="built_in">this</span>.nums[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.nums;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Solution(nums)</span><br><span class="line"><span class="keyword">var</span> param_1 = obj.reset()</span><br><span class="line"><span class="keyword">var</span> param_2 = obj.shuffle()</span><br></pre></td></tr></table></figure><h3 id="获取数组最大值"><a href="#获取数组最大值" class="headerlink" title="获取数组最大值"></a>获取数组最大值</h3><p><strong><code>Math.max()</code></strong> 函数返回作为输入参数的最大数字，如果没有参数，则返回<code>-Infinity</code>。</p><p><code>Array.prototype.reduce()</code>可以用来查找最大值元素，通过比较每个值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> max = arr.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="built_in">Math</span>.max(a, b), -<span class="literal">Infinity</span>);</span><br></pre></td></tr></table></figure><p>下面的方法使用 <code>Function.prototype.apply()</code>来获取数组的最大值。<code>getMaxOfArray([1, 2, 3])</code> 相当于 <code>Math.max(1, 2, 3)</code>，但是你可以使用 <code>getMaxOfArray()</code> 作用于任意长度的数组上。这应该只用于元素相对较少的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxOfArray</span>(<span class="params">numArray</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, numArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>展开语法是编写 <code>apply</code> 解决方案的一种更简短的方法，可以最大限度地利用数组:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max(...arr);</span><br></pre></td></tr></table></figure><p>但是，如果数组有太多的元素，展开语法（<code>...</code>）和 <code>apply</code> 都将失败或返回错误的结果，因为它们试图将数组元素作为函数形参传递。<code>reduce</code> 解决方案不存在这个问题。</p><blockquote><p>补充</p></blockquote><p>一个方法传入过多参数（比如一万个）时的后果在不同 JavaScript 引擎中表现不同。（JavaScriptCore 引擎中有被硬编码的参数个数上限：65536）。</p><p>这是因为此限制（实际上也是任何用到超大栈空间的行为的自然表现）是不明确的。一些引擎会抛出异常，更糟糕的是其他引擎会直接限制传入到方法的参数个数，导致参数丢失。比如：假设某个引擎的方法参数上限为 4（实际上限当然要高得多），这种情况下，上面的代码执行后，真正被传递到 <code>apply</code>的参数为 <code>5, 6, 2, 3</code> ，而不是完整的数组。</p><p>如果你的参数数组可能非常大，可以将数组切块后循环传入目标方法。</p><h2 id="Object对象★"><a href="#Object对象★" class="headerlink" title="Object对象★"></a>Object对象★</h2><blockquote><p>考察公司：完美世界</p></blockquote><p><code>Object</code>对象是<code>JavaScript</code>中两个顶层对象之一，提供方法供直接调用以及原型链继承调用。</p><h3 id="查询对象上的属性和遍历对象方法"><a href="#查询对象上的属性和遍历对象方法" class="headerlink" title="查询对象上的属性和遍历对象方法"></a>查询对象上的属性和遍历对象方法</h3><h4 id="查询对象上的属性"><a href="#查询对象上的属性" class="headerlink" title="查询对象上的属性"></a>查询对象上的属性</h4><h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><p>该方法可以判断对象的<strong>自有属性</strong>和<strong>继承来的属性</strong>是否存在。</p><h5 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h5><p>该方法<strong>只能判断自有属性</strong>是否存在，对于继承属性会返回false。</p><h4 id="Js遍历对象"><a href="#Js遍历对象" class="headerlink" title="Js遍历对象"></a>Js遍历对象</h4><h5 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h5><p><code>for in</code>语句以任意顺序迭代对象的可枚举属性，包括原型链上的可枚举属性，不包括<code>Symbol</code>属性。</p><h5 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h5><p><code>Object.keys()</code>方法会返回一个由一个指定对象的<strong>自身可枚举属性</strong>组成的数组，数组中属性名的排列顺序和使用<code>for...in</code>循环遍历该对象时返回的顺序一致。</p><p>类似的，<code>Object.entries()</code>方法返回一个指定对象自身可枚举属性的<strong>键值对</strong>数组，<code>Object.values()</code>方法返回一个指定对象自身的所有可枚举<strong>属性值</strong>的数组。</p><h5 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames"></a>Object.getOwnPropertyNames</h5><p><code>Object.getOwnPropertyNames()</code>方法返回一个由指定对象的<strong>所有自身属性的属性名</strong>，包括不可枚举属性但不包括<code>Symbol</code>值作为名称的属性组成的数组。</p><h5 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols"></a>Object.getOwnPropertySymbols</h5><p><code>Object.getOwnPropertySymbols()</code>方法返回一个指定对象自身的所有<code>Symbol</code>属性的数组。</p><h5 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys"></a>Reflect.ownKeys</h5><p><code>Reflect.ownKeys</code>方法返回一个由指定对象自身的属性键组成的数组，包括<strong>不可枚举属性</strong>与<code>Symbol</code>属性，它的返回值等同于<code>Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</code>。</p><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p><code>Object.assign()</code>方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。</p><p>它将返回目标对象，如果认为只有引用类型才有浅拷贝与深拷贝的概念，那么<code>Object.assign</code>拷贝方式就是浅拷贝。</p><p>假如认为对于基本数据类型也有浅拷贝与深拷贝的概念的话，那么对于基本数据类型的拷贝可以理解为按值深拷贝，那么关于<code>Object.assign</code>第一层是深拷贝，第二层及以后是浅拷贝的说法也是没有问题的。</p><p><code>Object.assign(target, ...sources)</code></p><p><code>target</code>: 目标对象。</p><p><code>sources</code>: 源对象。</p><p>返回目标对象<code>target</code>的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> source1 = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> source2 = &#123;<span class="attr">b</span>: <span class="number">11</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> merge = <span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line"><span class="built_in">console</span>.log(merge); <span class="comment">// &#123;a: 1, b: 11&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123;a: 1, b: 11&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(target === merge); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h3><p><code>Object.create()</code>方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</p><p><code>Object.create(proto[, propertiesObject])</code></p><p><code>proto</code>: 新创建对象的原型对象。</p><p><code>propertiesObject</code>: 可选，如果指定为一个对象，则是要添加到新创建对象的不可枚举（默认）属性对象的属性描述符以及相应的属性名称，即其自身定义的属性，而不是其原型链上的枚举属性，这些属性对应<code>Object.defineProperties()</code>的第二个参数。<br>返回一个新对象，带着指定的原型对象和属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">Object</span>.create(proto);</span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123;&#125; // 创建了一个新对象</span></span><br><span class="line"><span class="built_in">console</span>.log(target.__proto__ === proto); <span class="comment">// true // 将新对象的__proto__指向了原对象</span></span><br><span class="line"><span class="built_in">console</span>.log(target.a); <span class="comment">// 1 // 通过 Object.create 实现了继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123;&#125; // 创建了一个新对象</span></span><br><span class="line"><span class="built_in">console</span>.log(target.__proto__); <span class="comment">// undefined // 创建一个没有原型链指向的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = &#123;&#125;; <span class="comment">// 字面量形式创建对象</span></span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype); <span class="comment">// 等同于字面量方式创建对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype,&#123; <span class="comment">// 指定属性描述符</span></span><br><span class="line">    <span class="attr">key1</span>:&#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">key2</span>:&#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(target)); <span class="comment">// [&quot;key1&quot;] // key1可枚举</span></span><br><span class="line"><span class="built_in">console</span>.log(target[<span class="string">&quot;key1&quot;</span>]); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(target[<span class="string">&quot;key2&quot;</span>]); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.create 实现完整的浅拷贝 包括所有自身属性的描述符以及原型</span></span><br><span class="line"><span class="keyword">var</span> origin = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(origin, <span class="string">&quot;b&quot;</span>, &#123;<span class="attr">value</span>:<span class="string">&quot;11&quot;</span>, <span class="attr">enumerable</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">Object</span>.create(</span><br><span class="line">  <span class="built_in">Object</span>.getPrototypeOf(origin), </span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(origin) </span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123;a: 1, b: &quot;11&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(target)); <span class="comment">// [&quot;a&quot;]Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><h3 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties"></a>Object.defineProperties</h3><p><code>Object.defineProperties()</code>方法<strong>直接在一个对象上定义新的属性或修改现有属性，并返回该对象，该方法允许批量精确地添加或修改对象的属性</strong>。</p><p><code>Object.defineProperties(obj, props)</code></p><p><code>obj</code>: 在其上定义或修改属性的对象。</p><p><code>props</code>: 要定义其可枚举属性或修改的属性描述符的对象。对象中存在的属性描述符主要有两种：数据描述符和访问器描述符。<br>返回原对象的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target,&#123;</span><br><span class="line">    <span class="attr">key1</span>:&#123;</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 可配置</span></span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="comment">// 不可枚举</span></span><br><span class="line">        <span class="attr">value</span>: <span class="number">1</span>, <span class="comment">// 赋值</span></span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span> <span class="comment">// 可写</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">key2</span>:&#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 可枚举</span></span><br><span class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// getter 数据描述符与存取描述符不可共存 返回的是 key1 键的值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.key1;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="comment">// setter 数据描述符与存取描述符不可共存 设置的是 key1 键的值</span></span><br><span class="line">            <span class="built_in">this</span>.key1 = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(target)); <span class="comment">// [&quot;key2&quot;] // key2可枚举</span></span><br><span class="line"><span class="built_in">console</span>.log(target.key1); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(target.key2); <span class="comment">// 1</span></span><br><span class="line">target.key2 = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">console</span>.log(target.key1); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(target.key2); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p><code>Object.defineProperty()</code>方法会直接在一个对象上定义<strong>一个</strong>新属性，或者修改一个对象的现有属性，并返回此对象，该方法允许精确地添加或修改对象的属性。</p><p><code>Object.defineProperty(obj, prop, descriptor)</code></p><p><code>obj</code>: 要定义属性的对象。</p><p><code>prop</code>: 要定义或修改的属性的名称或<code>Symbol</code>。 <code>descriptor</code>: 要定义或修改的属性描述符。<br>返回原对象的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">&#x27;key1&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 可配置</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="comment">// 不可枚举</span></span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span>, <span class="comment">// 赋值</span></span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span> <span class="comment">// 可写</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">&#x27;key2&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 可枚举</span></span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// getter 数据描述符与存取描述符不可共存 返回的是 key1 键的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.key1;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="comment">// setter 数据描述符与存取描述符不可共存 设置的是 key1 键的值</span></span><br><span class="line">        <span class="built_in">this</span>.key1 = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(target)); <span class="comment">// [&quot;key2&quot;] // key2可枚举</span></span><br><span class="line"><span class="built_in">console</span>.log(target.key1); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(target.key2); <span class="comment">// 1</span></span><br><span class="line">target.key2 = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">console</span>.log(target.key1); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(target.key2); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><h3 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze"></a>Object.freeze</h3><p><code>Object.freeze()</code>方法可以冻结一个对象，一个被冻结的对象再也不能被修改，冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。</p><p>此外，冻结一个对象后该对象的原型也不能被修改，<code>Object.freeze()</code>返回和传入的参数相同的对象。</p><p><code>Object.isFrozen()</code>方法判断一个对象是否被冻结。</p><p><code>Object.freeze(obj)</code></p><p><code>obj</code>: 要被冻结的对象。</p><p>返回被冻结的对象的引用，是返回传递的对象，而不是创建一个被冻结的副本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>; <span class="comment">// 严格模式 // 非严格模式静默失败</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> freezeObj = <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj === freezeObj); <span class="comment">// true</span></span><br><span class="line">freezeObj.b = <span class="number">11</span>; <span class="comment">// Uncaught TypeError: Cannot add property b, object is not extensibleCopy to </span></span><br></pre></td></tr></table></figure><h3 id="Object-is-1"><a href="#Object-is-1" class="headerlink" title="Object.is"></a>Object.is</h3><p><code>Object.is()</code>方法判断两个值是否是相同的值。</p><h2 id="String★"><a href="#String★" class="headerlink" title="String★"></a>String★</h2><blockquote><p>考察公司：完美世界</p></blockquote><p>不同于类 C 语言，<strong>JavaScript 字符串是不可更改的</strong>。</p><p>这意味着字符串一旦被创建，就不能被修改。</p><p>但是，可以基于对原始字符串的操作来<strong>创建新的字符串</strong>。例如：</p><ul><li>获取一个字符串的子串可通过选择个别字母或者使用 <code>String.substr()</code>。</li><li>两个字符串的连接使用连接操作符 (<code>+</code>) 或者<code>String.concat()</code>。</li></ul><h3 id="字符访问"><a href="#字符访问" class="headerlink" title="字符访问"></a>字符访问</h3><p>有两种方法可以访问字符串中的单个字符。首先是 <code>charAt()</code>方法：</p><p>另一种方法（在 ECMAScript 5 中引入）是将字符串视为类似数组的对象，使用<strong>括号表示法</strong>进行字符访问。</p><p><strong>尝试删除这些属性或为这些属性赋值将不会成功</strong>。所涉及的属性既不可写也不可配置。</p><h3 id="基本字符串和字符串对象的区别"><a href="#基本字符串和字符串对象的区别" class="headerlink" title="基本字符串和字符串对象的区别"></a>基本字符串和字符串对象的区别</h3><p>字符串字面量 (通过<strong>单引号或双引号</strong>定义) 和 直接调用 String 方法(<strong>没有通过 new 生成字符串对象实例</strong>)的字符串都是<strong>基本字符串</strong>。</p><p>JavaScript会<strong>自动将基本字符串转换为字符串对象</strong>，只有将基本字符串转化为字符串对象之后才可以<strong>使用字符串对象的方法</strong>。</p><p><strong>当基本字符串需要调用一个字符串对象才有的方法或者查询值的时候</strong>(基本字符串是没有这些方法的)，JavaScript 会自动将基本字符串转化为字符串对象并且调用相应的方法或者执行查询。</p><h3 id="长文字字符串"><a href="#长文字字符串" class="headerlink" title="长文字字符串"></a>长文字字符串</h3><p>可以使用<code>+</code>运算符将多个字符串附加在一起。</p><p>可以在每行末尾 使用反斜杠字符 ( <code>\</code>) 来指示字符串将在下一行继续。</p><h3 id="模板字面量-★"><a href="#模板字面量-★" class="headerlink" title="模板字面量 ★"></a>模板字面量 ★</h3><p>模板字符串使用<strong>反引号</strong>来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（<code>$&#123;expression&#125;</code>）的占位符。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><p><code>s.length</code> 可以用来获取字符串的长度</p></li><li><p><code>s.charAt(i)</code> 可以返回字符串中指定位置i的字符</p></li><li><p><code>s.concat(s1,...)</code>可以用来连接两个或多个字符串，作用和<code>+</code>一样</p></li><li><p><code>s.indexOf(searchvalue,fromindex)</code>该方法可以检索一个字符串中是否含有指定内容</p><ul><li>如果字符串中含有该内容，则会返回其<strong>第一次出现的索引</strong></li><li>如果没有找到指定的内容，则返回**-1**</li><li>可以指定一个第二个参数，指定<strong>开始查找的位置</strong></li></ul></li><li><p><code>s.slice(a,b)</code> 可以从字符串中截取指定的内容,不会影响原字符串，而是将<strong>截取到内容返回</strong></p><ul><li>参数：[a,b)</li><li>如果省略第二个参数，则会截取到后边所有的</li><li>也可以传递一个负数作为参数，<strong>负数的话将会从后边计算</strong></li></ul></li><li><p><code>s.substring(a,b)</code>可以用来截取一个字符串，<strong>和slice()类似</strong></p><ul><li><p>不同的是这个方法<strong>不能接受负值</strong>作为参数，如果传递了一个负值，则默认使用0</p></li><li><p>而且他还<strong>自动调整参数的位置</strong>，如果第二个参数小于第一个，则自动交换</p></li></ul></li><li><p><code>s.split(&quot;&quot;)</code>可以将一个字符串拆分为一个数组</p><ul><li><p>需要一个<strong>字符串</strong>作为参数，将会根据该字符串去拆分数组</p></li><li><p>如果传递一个<strong>空串</strong>作为参数，则会将每个字符都拆分为数组中的一个元素</p></li></ul></li></ul><ul><li><code>s.toUpperCase()</code> 将一个字符串转换为<strong>大写</strong>并返回</li><li><code>s.toLowerCase()</code> 将一个字符串转换为<strong>小写</strong>并返回</li><li><code>s.charCodeAt(index)</code> 指定 <code>index</code> 处字符的 UTF-16 代码单元值的一个数字</li></ul><h3 id="拼接字符串？"><a href="#拼接字符串？" class="headerlink" title="拼接字符串？"></a>拼接字符串？</h3><p>一般来讲，JavaScript里拼接字符串有4种方式：</p><h4 id="使用-运算符来拼接"><a href="#使用-运算符来拼接" class="headerlink" title="使用+运算符来拼接"></a>使用<code>+</code>运算符来拼接</h4><p>这种方式比较常见，用+将字符串连起来，得到一个新的字符串。</p><p>这种方法，可能许多编程老手会说有性能问题，理由是字符串是不可变的，因此每次拼接操作都会重新创建一个新的字符串。在每一次拼接大量字符串的时候，都会产生内存申请及回收操作，当字符串很长的时候，会很耗内存，导致代码性能很低。</p><p>其实，这在JavaScript里是个老观念了，因为现代的JavaScript引擎已经对这种场景做了优化，性能不再是一个问题。稍后我们再来看性能比较。</p><p>这种方式在JavaScript里不推荐用，不是因为性能问题，而是和模版字符串相比，代码不直观。</p><h4 id="使用concat-方法"><a href="#使用concat-方法" class="headerlink" title="使用concat()方法"></a>使用<code>concat()</code>方法</h4><p>string对象有个<code>concat()</code>方法可以用来拼接字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="string">&quot;乐码范！&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> result = s1.concat(<span class="string">&quot; &quot;</span>, s2);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// Hello 乐码范！</span></span><br></pre></td></tr></table></figure><h4 id="使用Array-join-方法"><a href="#使用Array-join-方法" class="headerlink" title="使用Array.join()方法"></a>使用<code>Array.join()</code>方法</h4><p>JavaScript里的数组有个join()方法，可以将数组里面的字符串合成一个字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;乐码范！&quot;</span>].join(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// Hello 乐码范！</span></span><br></pre></td></tr></table></figure><p>这种方法可以用来做大量字符串的合并，是传统上性能比较高的方法。</p><h4 id="使用模版字符串（Template-literals）"><a href="#使用模版字符串（Template-literals）" class="headerlink" title="使用模版字符串（Template literals）"></a>使用模版字符串（Template literals）</h4><p>在ES5里面，JavaScript引入了一个新的叫做模版字符串的语法，使用反引号```来格式化一个字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="string">&quot;乐码范！&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">`<span class="subst">$&#123;s1&#125;</span> <span class="subst">$&#123;s2&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// Hello 乐码范！</span></span><br></pre></td></tr></table></figure><p>上面的代码和第一种使用+号的方式来比，我们很容易看出最终字符串result的结构，因此更容易读。</p><h4 id="比较一下性能"><a href="#比较一下性能" class="headerlink" title="比较一下性能"></a>比较一下性能</h4><p>由于模版字符串主要用于拼接数量有限的几个变量，所以在拼接大量字符串的时候，我们不会用它。</p><p>在同一台电脑上，Node.js v14和Chrome浏览器里面跑的一次结果是这样的：</p><table><thead><tr><th align="left">拼接方式</th><th align="right">NODE.JS V14 (毫秒)</th><th align="right">CHROME V92 (毫秒)</th></tr></thead><tbody><tr><td align="left">加号拼接</td><td align="right">121.78</td><td align="right">92.64</td></tr><tr><td align="left">concat()拼接</td><td align="right">116.99</td><td align="right">67.44</td></tr><tr><td align="left">Array.join()拼接</td><td align="right">142.75</td><td align="right">137.48</td></tr></tbody></table><p>由此可以看出，三种方式concat()是最快的，但是三种方式的性能，不管是在Node.js还是Chrome浏览器上，实际是差不多的。虽有差异，但偶尔跑的结果顶多是一两倍的差异，而不是数量级上的差异。</p><p>因此，在实际写代码的时候，完全可以根据场景和习惯来使用，不用考虑上面不同的写法造成的性能上的差异。</p><h2 id="DOM事件总结★"><a href="#DOM事件总结★" class="headerlink" title="DOM事件总结★"></a>DOM事件总结★</h2><blockquote><p>考察公司：完美世界、字节</p></blockquote><h3 id="DOM事件的级别"><a href="#DOM事件的级别" class="headerlink" title="DOM事件的级别"></a>DOM事件的级别</h3><p><strong>DOM0的写法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种事件绑定的方式，如果绑定多个，则后面的会覆盖掉前面的</span></span><br><span class="line">element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是在 js 中的写法；如果要在html中写，写法是：在onclick属性中，加 js 语句。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;hello&#x27;);&quot;</span>&gt;</span>我是按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p><strong>DOM2的写法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高版本浏览器</span></span><br><span class="line">element.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// IE8及以下版本浏览器。IE11和谷歌浏览器等不支持</span></span><br><span class="line">element.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的第三参数中，<strong>true</strong>表示事件在<strong>捕获阶段</strong>触发，<strong>false</strong>表示事件在<strong>冒泡阶段</strong>触发（默认）。</p><p><code>addEventListener()</code>中的<code>this</code>，是<strong>绑定事件的对象</strong>；如果写箭头函数是<strong>window</strong>。</p><p>绑定多个响应函数执行顺序是：<strong>先绑定先执行</strong>。</p><p><strong>DOM3的写法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>DOM3中，增加了很多事件类型，比如<strong>鼠标事件</strong>、<strong>键盘事件</strong>等。</p><h3 id="DOM事件模型-捕获-冒泡"><a href="#DOM事件模型-捕获-冒泡" class="headerlink" title="DOM事件模型 捕获/冒泡"></a>DOM事件模型 捕获/冒泡</h3><p><strong>DOM事件模型</strong>讲的就是<strong>捕获和冒泡</strong>。</p><p><strong>DOM事件流</strong>讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。</p><p>完整的事件流，分三个阶段：</p><ul><li><p><strong>捕获</strong>：从 <code>window</code> 对象传到 <strong>目标元素</strong>。</p></li><li><p><strong>目标阶段</strong>：事件通过捕获，到达目标元素，这个阶段就是目标阶段。</p></li><li><p><strong>冒泡</strong>：从<strong>目标元素</strong>传到 <code>Window</code> 对象。</p></li></ul><p>捕获阶段，事件依次传递的顺序是：<code>window</code> –&gt; <code>document</code> –&gt; <code>html</code>–&gt; <code>body</code> –&gt; 父元素、子元素、目标元素。</p><p>冒泡的流程与捕获的流程相反。</p><p><strong>事件捕获优先于事件冒泡</strong>。</p><h3 id="Event对象的常见-api-方法"><a href="#Event对象的常见-api-方法" class="headerlink" title="Event对象的常见 api 方法"></a>Event对象的常见 api 方法</h3><p><strong>Event 对象代表事件的状态</strong>，当dom tree中某个事件被触发的时候，会同时自动产生一个<strong>用来描述事件所有的相关信息</strong>（比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态）的对象。</p><p>阻止默认事件<code>event.preventDefault();</code> 如阻止了链接的默认跳转</p><p>阻止冒泡 <code>event.stopPropagation();</code></p><h3 id="事件委托（代理）"><a href="#事件委托（代理）" class="headerlink" title="事件委托（代理）"></a>事件委托（代理）</h3><p>事件委派指将事件统一绑定给元素的<strong>共同的祖先元素</strong>，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。事件委派是利用了<strong>冒泡</strong>，通过委派可以减少事件绑定的次数，提高程序的性能。</p><p><code>event.currentTarget</code> 返回<strong>绑定事件的元素</strong>。在事件委托中，一般是【祖先元素】。<br><code>event.target</code> 返回<strong>触发事件的元素</strong>。在事件委托中，一般是【子元素】。</p><p><strong>应用场景</strong></p><p>例如我们有<code>10</code>个<code>&lt;li&gt;</code>标签，每个标签有一个<code>uid</code>作为判断用户点击的区别，使用冒泡就不需要为每个<code>&lt;li&gt;</code>绑定点击事件，可以把点击事件绑定到<code>&lt;ul&gt;</code>上，通过<code>event.target</code>获得触发事件的元素，称为事件委托。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;u1&quot;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    alert(e.target.getAttribute(<span class="string">&#x27;uid&#x27;</span>));<span class="comment">//返回元素上一个指定的属性值。</span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><h3 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h3><p>常用鼠标事件：**</p><ul><li><p>click —— 当鼠标点击一个元素时（触摸屏设备会在点击时生成）。</p></li><li><p>contextmenu —— 当鼠标右键点击一个元素时。</p></li><li><p>mouseover / mouseout —— 当鼠标指针移入/离开一个元素时。</p></li><li><p>mousedown / mouseup —— 当在元素上按下/释放鼠标按钮时。</p></li><li><p>mousemove —— 当鼠标移动时。</p></li></ul><p><strong>键盘事件</strong>：</p><p>keydown 和 keyup —— 当按下和松开一个按键时。</p><p><strong>表单（form）元素事件</strong>：</p><ul><li>submit —— 当访问者提交 时。</li><li>focus —— 当访问者聚焦于一个元素时 。</li></ul><p><strong>Document 事件</strong>： DOMContentLoaded —— 当 HTML 的加载和处理均完成，DOM 被完全构建完成时。</p><p><strong>CSS 事件</strong>： transitionend —— 当一个 CSS 动画完成时。</p><h2 id="Ajax★"><a href="#Ajax★" class="headerlink" title="Ajax★"></a>Ajax★</h2><blockquote><p>考察公司：字节、百度</p></blockquote><p>一种异步请求数据的web开发技术，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。</p><h3 id="原生Ajax"><a href="#原生Ajax" class="headerlink" title="原生Ajax"></a>原生Ajax</h3><blockquote><p>XMLHttpRequest（XHR）对象用于与服务器交互。</p></blockquote><ul><li><p>创建<code>XMLHttpRequest</code> 对象。<code>const xhr = new XMLHttpRequest()</code></p></li><li><p>使用<code>open</code>方法设置请求的参数。<code>xhr.open(method, url, 是否异步)</code>。</p><ul><li><p><code>get</code>可以把请求参数拼接在<code>url</code></p></li><li><p>默认异步</p></li><li><p>如果想要使用<code>post</code>提交数据,必须添加此行。</p><p><code>xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">foo=bar&amp;baz=The+first+line.%0D%0AThe+second+line.%0D%0A</span><br><span class="line"></span><br><span class="line">Content-Type: text/plain</span><br><span class="line">foo=bar</span><br><span class="line">baz=The first line.</span><br><span class="line">The second line.</span><br><span class="line"></span><br><span class="line">Content-Type: multipart/form-data; boundary=---------------------------<span class="number">314911788813839</span></span><br><span class="line"></span><br><span class="line">-----------------------------<span class="number">314911788813839</span></span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line">-----------------------------<span class="number">314911788813839</span></span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line">The first line.</span><br><span class="line">The second line.</span><br><span class="line"></span><br><span class="line">-----------------------------<span class="number">314911788813839</span>--</span><br></pre></td></tr></table></figure></li></ul></li><li><p>注册<code>onreadystatechange</code>事件，<strong>状态改变时就会调用</strong>。</p><ul><li><code>xhr.readyState===4</code> 请求已完成，且响应已就绪。存有 <code>XMLHttpRequest</code> 的状态。从 0 到 4 发生变化。</li><li><code>(xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300) || xhr.status === 304</code> 304：服务器端资源未改变，可直接使用客户端未过期的缓存。</li></ul></li><li><p>发送请求。</p><ul><li><code>get</code>请求：<code>xhr.send()</code></li><li><code>post</code>请求：将数据通过<code>send</code>方法传递 <code>xhr.send(&#39;name=fox&amp;age=18&#39;);</code></li></ul></li><li><p>获取返回的数据，更新UI。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ajax = <span class="function">(<span class="params">method=<span class="string">&#x27;GET&#x27;</span>,url,data=&#123;&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(method,url);</span><br><span class="line">        <span class="keyword">if</span> (method.toUpperCase() === <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">            xhr.setRequestHeader(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onreadystatechange = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((xhr.status&gt;=<span class="number">200</span> &amp;&amp; xhr.status&lt;<span class="number">300</span>) || xhr.status === <span class="number">304</span>)&#123;</span><br><span class="line">                    resolve(xhr.response);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    reject(xhr.status);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">ajax(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;https://devapi.qweather.com/v7/weather/now?location=101010100&amp;key=d6d54c0f8bb54160b97507ce068abda8&#x27;</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(res).now.text);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p>fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。</p><h2 id="作用域与闭包★"><a href="#作用域与闭包★" class="headerlink" title="作用域与闭包★"></a>作用域与闭包★</h2><blockquote><p>考察公司：小米、百度、华为</p></blockquote><p><strong>作用域</strong>是当前的执行上下文，值和表达式在其中“可见”或可被访问。如果一个变量或表达式不在当前的作用域中，那么它是不可用的。作用域也可以堆叠成层次结构，子作用域可以访问父作用域，反过来则不行。</p><p>JavaScript 的作用域分以下三种：</p><ul><li>全局作用局：脚本模式运行所有代码的默认作用域</li><li>模块作用域：模块模式中运行代码的作用域</li><li>函数作用域：由函数创建的作用域</li></ul><p>此外，用 <code>let</code> 或 <code>const</code> 声明的变量属于额外的作用域：</p><ul><li>块级作用域：用一对花括号（一个代码块）创建出来的作用域</li></ul><p>由于函数会创建作用域，因而在函数中定义的变量无法从该函数外部访问，也无法从其他函数内部访问。</p><p><strong>一个函数</strong>和其<strong>词法环境</strong>的<strong>引用</strong>捆绑在一起，这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）。</p><p><strong>每当创建一个函数，闭包就会在函数创建的同时被创建出来。</strong>闭包让你可以在一个<strong>内层函数</strong>中<strong>访问到其外层函数的作用域</strong>。</p><p>内部函数对外部函数中定义的<strong>所有变量和函数</strong>有完全访问权，以及<strong>外部函数可以访问的所有其他变量和函数</strong>，这样就形成了<strong>作用域链</strong>。</p><p><strong>当内部函数以某种方式于外部函数之外的任何作用域执行时</strong>，就会看到一个<strong>可观察的闭包</strong>，此时<strong>外部函数中定义的变量和函数的存活时间就可以长于外部函数的执行时间</strong>。</p><p>本质就是<strong>上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放</strong>。导致上级作用域内的变量，<strong>等到下级作用域执行完以后才正常得到释放</strong>。</p><p><strong>总结</strong>：（对内保护，对外引用）</p><ul><li><p>闭包是函数执行形成私有作用域，对内，对于私有作用域内的私有变量，起到保护作用，外界无法直接对其进行访问和操作；</p></li><li><p>对外，私有作用域可以通过作用域链查找，对外部作用域进行访问查找。</p></li><li><p>如果形成对外部作用域引用，则会阻止引擎的垃圾回收器释放当前被引用的内存空间。</p></li><li><p>因此，可能会导致内存泄漏，需要特别关注。</p></li></ul><p><strong>优点</strong></p><ul><li>可以<strong>从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用</strong>。</li><li><strong>避免使用全局变量</strong>。</li><li>把变量存到独立的作用域，作为<strong>私有成员</strong>存在。</li></ul><p><strong>缺点</strong></p><ul><li>对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以<strong>使用不当会导致内存泄漏</strong>。</li><li>对处理速度具有负面影响。<strong>闭包的层级决定了引用的外部变量在查找时经过的作用域链长度</strong>。</li></ul><p><strong>应用</strong></p><ul><li><p><strong>用闭包模拟私有方法</strong> 模块模式：将共享环境创建于一个立即执行的匿名函数体内。这个环境中包含私有项无法在这个匿名函数外部直接访问，必须通过匿名函数返回的公共函数通过闭包机制访问。</p></li><li><p><strong>在循环中创建闭包</strong>：在<code>for</code>循环并未具备局部作用域，因此内层函数中的循环变量i都是外层函数的一个局部变量，循环结束后该变量是一个唯一值，可以使用<strong>立即执行匿名函数</strong>再创建一个闭包，将循环变量保存；或者使用<strong>let</strong>形成块作用域来保存每次的循环变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;索引&quot;</span>,i);</span><br><span class="line">    &#125;,<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;索引&quot;</span>,i);</span><br><span class="line">        &#125;,<span class="number">100</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>高阶函数与柯里化</strong></p><p>简单来说，高阶函数是一个接收函数作为参数或将函数作为输出返回的函数。</p><p>柯里化是指一个函数，它接收函数 A，并且能返回一个新的函数，这个新的函数能够处理函数 A 的剩余参数。函数传入的参数相当于在函数内声明一个变量并赋值，所以这里也是利用了闭包机制。</p></li><li><p><strong>节流与防抖</strong></p></li></ul><h3 id="防抖-节流-★"><a href="#防抖-节流-★" class="headerlink" title="防抖/节流 ★"></a>防抖/节流 ★</h3><p>作用都是为了<strong>防止函数被高频调用。</strong></p><p>当函数会进行<code>DOM</code>操作或者具有<strong>请求服务器</strong>等行为并且作为高频事件，就需要进行<strong>事件处理函数执行频率的控制</strong>，否则会造成大量的<strong>资源浪费</strong>致使<strong>性能下降</strong>，当然无论是防抖与节流实质上并没有减少事件触发次数，而是通过<strong>减少事件处理函数的执行次数</strong>从而提高性能。</p><p><strong>应用场景</strong></p><ul><li><p>防抖</p><ul><li><p>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。</p></li><li><p>window触发<code>resize</code>的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次。</p><p><code>resize</code> CSS 属性允许你控制一个元素的可调整大小性。</p></li></ul></li><li><p>节流</p><ul><li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li><li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li></ul></li></ul><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><h5 id="非立即防抖"><a href="#非立即防抖" class="headerlink" title="非立即防抖"></a>非立即防抖</h5><p>当持续触发事件的时候，事件处理函数是完全不执行的，等<strong>最后一次触发结束的一段时间之后，再去执行</strong>。</p><p>最常见的例子就是<strong>搜索</strong>建议功能，当用户进行持续输入时，并不会请求服务器进行搜索建议的计算，直至用户输入完成后的<code>N</code>毫秒后才会将数据传输至后端并返回搜索建议。<br>实现思路：<strong>每次触发事件时都取消之前的延时调用方法并重设定时器</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce1</span>(<span class="params">wait,fn,...args</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 闭包里存变量timer</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 这里不要用箭头函数，因为debounce1不是由h1调用，而是其返回函数由h1调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 每次触发事件时都取消之前的延时调用方法并重设定时器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        <span class="comment">// 定时器使用箭头函数和外层函数this一致，但h1只是调用了外层函数，fn的this需要自行绑定</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">            fn.call(<span class="built_in">this</span>,...args)</span><br><span class="line">        &#125;,wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> h1 =<span class="built_in">document</span>.querySelector(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line"><span class="comment">// 此处如果使用箭头函数，this将永远指向window</span></span><br><span class="line"><span class="keyword">const</span> fn =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">h1.addEventListener(<span class="string">&#x27;click&#x27;</span>,debounce1(<span class="number">300</span>,fn,<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 简洁版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce1</span>(<span class="params">fn,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;   </span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(fn,wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">h1.addEventListener(<span class="string">&#x27;click&#x27;</span>,debounce1(<span class="function">()=&gt;</span>fn.call(h1),<span class="number">300</span>));</span><br></pre></td></tr></table></figure><h5 id="立即防抖"><a href="#立即防抖" class="headerlink" title="立即防抖"></a>立即防抖</h5><p>当持续触发事件的时候，事件处理函数会<strong>立即执行</strong>，然后不再执行事件处理函数，直至<strong>最后一次事件触发之后的一段时间后才允许再次执行事件处理函数</strong>。<br>实现思路：<strong>判断是否存在定时器，没有则执行事件处理函数，然后无论是否已经存在定时器都需要重设定时器</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce2</span>(<span class="params">wait,fn,...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(!timer)fn.call(<span class="built_in">this</span>,...args);  </span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">            timer=<span class="literal">null</span>;</span><br><span class="line">        &#125;,wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> h1 =<span class="built_in">document</span>.querySelector(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fn =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">h1.addEventListener(<span class="string">&#x27;click&#x27;</span>,debounce2(<span class="number">300</span>,fn,<span class="number">1</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p>当事件持续触发时，节流操作可以稀释事件处理函数执行频率，假设在<code>1s</code>内<code>onmousemove</code>事件触发了<code>100</code>次，通过节流就可以使得<code>onmousemove</code>事件的事件处理函数每<code>100ms</code>触发一次，也就是在<code>1s</code>内<code>onmousemove</code>事件的事件处理函数只执行<code>10</code>次。</p><h5 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h5><p>实现思路：通过<strong>时间戳</strong>记录上次事件处理函数执行时间，事件触发时若时间差大于执行周期则执行事件处理函数并赋值执行时间为当前时间戳。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle1</span>(<span class="params">wait,fn,...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">if</span>(now - prev &gt; wait)&#123;</span><br><span class="line">            fn.call(<span class="built_in">this</span>,...args);</span><br><span class="line">            prev=now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h1 =<span class="built_in">document</span>.querySelector(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fn =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">h1.addEventListener(<span class="string">&#x27;click&#x27;</span>,throttle1(<span class="number">300</span>,fn,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h5 id="定时器-1"><a href="#定时器-1" class="headerlink" title="定时器"></a>定时器</h5><p>实现思路：判断是否存在定时器，没有则执行事件处理函数并重设定时器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle2</span>(<span class="params">wait,fn,...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">            fn.call(<span class="built_in">this</span>,...args);</span><br><span class="line">            timer=<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>timer=<span class="literal">null</span>,wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h1 =<span class="built_in">document</span>.querySelector(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fn =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">h1.addEventListener(<span class="string">&#x27;click&#x27;</span>,throttle2(<span class="number">300</span>,fn,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h3 id="柯里化-★"><a href="#柯里化-★" class="headerlink" title="柯里化 ★"></a>柯里化 ★</h3><p>柯里化是什么：是指这样一个函数，它接收函数 A，并且能返回一个新的函数，这个新的函数能够处理函数 A 的剩余参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func, args=[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> argity = func.length;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> _args = [].slice.apply(<span class="built_in">arguments</span>);</span><br><span class="line">        args.push(..._args);</span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; argity) &#123;</span><br><span class="line">            <span class="keyword">return</span> curry.call(<span class="built_in">this</span>, func, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> a + b + c;</span><br><span class="line"><span class="keyword">const</span> curriedSum = curry(sum);</span><br><span class="line"><span class="keyword">const</span> res = curriedSum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> log = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> curriedLog = curry(log);</span><br><span class="line">curriedLog(<span class="string">&#x27;a&#x27;</span>)(<span class="string">&#x27;b&#x27;</span>)(<span class="string">&#x27;c&#x27;</span>); <span class="comment">// a b c</span></span><br></pre></td></tr></table></figure><h2 id="下载功能★"><a href="#下载功能★" class="headerlink" title="下载功能★"></a>下载功能★</h2><blockquote><p>考察公司：百度</p></blockquote><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><p>两个请求接口实现异步下载</p><p>由于要下载的数据，经常会改动，所以每次下载都要重新生成文件。</p><p>第一个请求接口用来生成对应excel。</p><p>第二个请求接口用来获取下载列表，含有文件信息、下载地址，以及文件当前状态等。</p><p>通过轮询的方式，判断所有文件状态并在前端更新渲染，下载中的用loading，下载完成显示下载按钮（a标签）</p><p><a target="_blank" rel="noopener" href="https://usehooks-ts.com/">usehooks-ts</a></p><p><strong>useInterval</strong>：<a target="_blank" rel="noopener" href="https://usehooks-ts.com/react-hook/use-interval">https://usehooks-ts.com/react-hook/use-interval</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// See: https://usehooks-ts.com/react-hook/use-isomorphic-layout-effect</span></span><br><span class="line"><span class="keyword">import</span> &#123; useIsomorphicLayoutEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;../useIsomorphicLayoutEffect&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useInterval</span>(<span class="params">callback: () =&gt; <span class="keyword">void</span>, delay: number | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> savedCallback = useRef(callback)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remember the latest callback if it changes.</span></span><br><span class="line">  useIsomorphicLayoutEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    savedCallback.current = callback</span><br><span class="line">  &#125;, [callback])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up the interval.</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Don&#x27;t schedule if no delay is specified.</span></span><br><span class="line">    <span class="comment">// Note: 0 is a valid value for delay.</span></span><br><span class="line">    <span class="keyword">if</span> (!delay &amp;&amp; delay !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> savedCallback.current(), delay)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id)</span><br><span class="line">  &#125;, [delay])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useInterval</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求的页面数据中有未完成则设置isPlaying为true</span></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> status = <span class="literal">false</span></span><br><span class="line">    status = tableData.some(<span class="function">(<span class="params">tData</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tData.excelStatus !== <span class="string">&#x27;已完成&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    setPlaying(status)</span><br><span class="line">&#125;, [tableData])</span><br><span class="line"><span class="comment">// isPlaying为true，每隔1s发请求刷新列表状态</span></span><br><span class="line">useInterval(</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setLoading(<span class="literal">false</span>)</span><br><span class="line">        getPageDataExcelList()</span><br><span class="line">    &#125;,</span><br><span class="line">    isPlaying ? <span class="number">1000</span> : <span class="literal">null</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h3><h4 id="form表单提交"><a href="#form表单提交" class="headerlink" title="form表单提交"></a>form表单提交</h4><p>这是以前常使用的传统方式，毕竟那个年代，没那么多好用的新特性呀。</p><p>道理也很简单，为一个下载按钮添加<code>click</code>事件，点击时动态生成一个表单，利用表单提交的功能来实现文件的下载（实际上表单的提交就是发送一个请求）</p><p>来看下如何生成一个表单，生成怎么样的一个表单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">path</span></span> - 请求的地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">fileName</span></span> - 文件名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadFile</span> (<span class="params">downloadUrl, fileName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建表单</span></span><br><span class="line">    <span class="keyword">const</span> formObj = <span class="built_in">document</span>.createElement(<span class="string">&#x27;form&#x27;</span>);</span><br><span class="line">    formObj.action = downloadUrl;</span><br><span class="line">    formObj.method = <span class="string">&#x27;get&#x27;</span>;</span><br><span class="line">    formObj.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    <span class="comment">// 创建input，主要是起传参作用</span></span><br><span class="line">    <span class="keyword">const</span> formItem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">    formItem.value = fileName; <span class="comment">// 传参的值</span></span><br><span class="line">    formItem.name = <span class="string">&#x27;fileName&#x27;</span>; <span class="comment">// 传参的字段名</span></span><br><span class="line">    <span class="comment">// 插入到网页中</span></span><br><span class="line">    formObj.appendChild(formItem);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(formObj);</span><br><span class="line">    formObj.submit(); <span class="comment">// 发送请求</span></span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(formObj); <span class="comment">// 发送完清除掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul><li>传统方式，兼容性好，不会出现URL长度限制问题</li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>无法知道下载的进度</li><li>无法直接下载浏览器可直接预览的文件类型（如txt/png等）</li></ul><h4 id="open或location-href"><a href="#open或location-href" class="headerlink" title="open或location.href"></a>open或location.href</h4><p>最简单最直接的方式，实际上跟<code>a</code>标签访问下载链接一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">&#x27;downloadFile.zip&#x27;</span>);</span><br><span class="line">location.href = <span class="string">&#x27;downloadFile.zip&#x27;</span>;</span><br></pre></td></tr></table></figure><p>当然地址也可以是接口api的地址，而不单纯是个链接地址。</p><h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><ul><li>简单方便直接</li></ul><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul><li>会出现<strong>URL长度限制</strong>问题</li><li>需要注意<strong>url编码</strong>问题</li><li><strong>浏览器可直接浏览的文件类型是不提供下载的</strong>，如txt、png、jpg、gif等</li><li><strong>不能添加header，也就不能进行鉴权</strong></li><li><strong>无法知道下载的进度</strong></li></ul><h4 id="a标签的download"><a href="#a标签的download" class="headerlink" title="a标签的download"></a>a标签的download</h4><p>我们知道，<code>a</code>标签可以访问下载文件的地址，浏览器帮助进行下载。但是对于浏览器支持直接浏览的txt、png、jpg、gif等文件，是不提供直接下载（可右击从菜单里另存为）的。</p><p>为了解决这个直接浏览不下载的问题，可以利用<code>download</code>属性。</p><p><code>download</code>属性是HTML5新增的属性，兼容性可以了解下 <a href="https://link.juejin.cn/?target=https://caniuse.com/#search=download">can i use download</a></p><p>总体兼容性算是很好了，基本可以区分为IE和其他浏览。但是需要注意一些信息：</p><ul><li>Edge 13在尝试下载data url链接时会崩溃。</li><li>Chrome 65及以上版本只支持同源下载链接。</li><li>Firefox只支持同源下载链接。</li></ul><p>基于上面描述，如果你尝试下载跨域链接，那么其实<code>download</code>的效果就会没了，跟不设置<code>download</code>表现一致。即浏览器能预览的还是会预览，而不是下载。</p><p>简单用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;example.jpg&quot;</span> download&gt;点击下载&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>可以带上属性值，指定下载的文件名，即重命名下载文件。不设置的话默认是文件原本名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;example.jpg&quot;</span> download=<span class="string">&quot;test&quot;</span>&gt;点击下载&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>如上，会下载了一个名叫<code>test</code>的图片。</p><p><strong>监测是否支持download</strong></p><p>要知道浏览器是否支持<code>download</code>属性，简单的一句代码即可区分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isSupport = <span class="string">&#x27;download&#x27;</span> <span class="keyword">in</span> <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>对于在跨域下不能下载可浏览的文件，其实可以跟后端协商好，在后端层做多一层转发，最终返回给前端的文件链接跟下载页同域就好了。</p><h5 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h5><ul><li>能解决不能直接下载浏览器可浏览的文件</li></ul><h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><ul><li>得已知下载文件地址</li><li>不能下载跨域下的浏览器可浏览的文件</li><li>有兼容性问题，特别是IE</li><li>不能进行鉴权</li></ul><h4 id="利用Blob对象"><a href="#利用Blob对象" class="headerlink" title="利用Blob对象"></a>利用Blob对象</h4><p>该方法较上面的直接使用<code>a</code>标签<code>download</code>这种方法的优势在于，它除了能利用已知文件地址路径进行下载外，还能通过发送ajax请求api获取文件流进行下载。毕竟有些时候，后端不会直接提供一个下载地址给你直接访问，而是要调取api。</p><p>利用<code>Blob</code>对象可以将文件流转化成<code>Blob</code>二进制对象。该对象兼容性良好，需要注意的是</p><ul><li>IE10以下不支持。</li><li>在Safari浏览器上访问<code>Blob Url</code>或<code>Object URL</code>当前是有缺陷的，如下文中通过<code>URL.createObjectURL</code>生成的链接。<code>caniuse</code>官网有指出 Safari has a <a href="https://link.juejin.cn/?target=https://jsfiddle.net/24FhL/">serious issue</a> with blobs that are of the type application/octet-stream</li></ul><p>进行下载的思路很简单：发请求获取二进制数据，转化为<code>Blob</code>对象，利用<code>URL.createObjectUrl</code>生成url地址，赋值在<code>a</code>标签的<code>href</code>属性上，结合<code>download</code>进行下载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">path</span></span> - 下载地址/下载请求地址。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">name</span></span> - 下载文件的名字/重命名（考虑到兼容性问题，最好加上后缀名）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">downloadFile (path, name) &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">&#x27;get&#x27;</span>, path);</span><br><span class="line">    xhr.responseType = <span class="string">&#x27;blob&#x27;</span>;</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span> || <span class="built_in">this</span>.status === <span class="number">304</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是IE10及以上，不支持download属性，采用msSaveOrOpenBlob方法，但是IE10以下也不支持msSaveOrOpenBlob</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;msSaveOrOpenBlob&#x27;</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">                navigator.msSaveOrOpenBlob(<span class="built_in">this</span>.response, name);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// const blob = new Blob([this.response], &#123; type: xhr.getResponseHeader(&#x27;Content-Type&#x27;) &#125;);</span></span><br><span class="line">            <span class="comment">// const url = URL.createObjectURL(blob);</span></span><br><span class="line">            <span class="keyword">const</span> url = URL.createObjectURL(<span class="built_in">this</span>.response);</span><br><span class="line">            <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            a.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">            a.href = url;</span><br><span class="line">            a.download = name;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(a);</span><br><span class="line">            a.click();</span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(a);</span><br><span class="line">            URL.revokeObjectURL(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法不能缺少<code>a</code>标签的<code>download</code>属性的设置。</p><p>因为发请求时已设置返回数据类型为<code>Blob</code>类型（<code>xhr.responseType = &#39;blob&#39;</code>），所以<code>target.response</code>就是一个<code>Blob</code>对象，打印出来会看到两个属性<code>size</code>和<code>type</code>。</p><p>虽然<code>type</code>属性已指定了文件的类型，但是为了稳妥起见，还是在<code>download</code>属性值里指定后缀名，如Firefox不指定下载下来的文件就会不识别类型。</p><p>大家可能会注意到，上述代码有两处注释，其实除了上述的写法外，还有另一个写法，改动一丢丢。</p><p>如果发送请求时不设置<code>xhr.responseType = &#39;blob&#39;</code>，默认ajax请求会返回<code>DOMString</code>类型的数据，即字符串。</p><p>这时就需要两处注释的代码了，对返回的文本转化为<code>Blob</code>对象，然后创建blob url，此时需要注释掉原本的<code>const url = URL.createObjectURL(target.response)</code>。</p><h5 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h5><ul><li>能解决不能直接下载浏览器可浏览的文件</li><li>可设置header，也就可添加鉴权信息</li></ul><h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><ul><li>兼容性问题，IE10以下不可用；Safari浏览器可以留意下使用情况</li></ul><h4 id="利用base64"><a href="#利用base64" class="headerlink" title="利用base64"></a>利用base64</h4><p>这里的用法跟上面用<code>Blob</code>大同小异，基本上思路是一样的，唯一不同的是，上面是利用<code>Blob</code>对象生成<code>Blob URL</code>，而这里则是生成<code>Data URL</code>，所谓<code>Data URL</code>，就是<code>base64</code>编码后的url形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">path</span></span> - 下载地址/下载请求地址。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">name</span></span> - 下载文件的名字（考虑到兼容性问题，最好加上后缀名）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">downloadFile (path, name) &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">&#x27;get&#x27;</span>, path);</span><br><span class="line">    xhr.responseType = <span class="string">&#x27;blob&#x27;</span>;</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span> || <span class="built_in">this</span>.status === <span class="number">304</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> fileReader = <span class="keyword">new</span> FileReader();</span><br><span class="line">            fileReader.readAsDataURL(<span class="built_in">this</span>.response);</span><br><span class="line">            fileReader.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                a.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">                a.href = <span class="built_in">this</span>.result;</span><br><span class="line">                a.download = name;</span><br><span class="line">                <span class="built_in">document</span>.body.appendChild(a);</span><br><span class="line">                a.click();</span><br><span class="line">                <span class="built_in">document</span>.body.removeChild(a);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h5><ul><li>能解决不能直接下载浏览器可浏览的文件</li><li>可设置header，也就可添加鉴权信息</li></ul><h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><ul><li>兼容性问题，IE10以下不可用</li></ul><h4 id="关于文件名"><a href="#关于文件名" class="headerlink" title="关于文件名"></a>关于文件名</h4><p>有时候我们在发送下载请求之前，并不知道文件名，或者文件名是后端提供的，我们就要想办法获取。</p><h5 id="Content-Disposition"><a href="#Content-Disposition" class="headerlink" title="Content-Disposition"></a>Content-Disposition</h5><p>当返回文件流的时候，我们在浏览器上观察接口返回的信息，会看到有这么一个header：<code>Content-Disposition</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: attachment; filename=CMCoWork__________20200323151823_190342.xlsx; filename*=UTF<span class="number">-8</span>&#x27;&#x27;CMCoWork_%E4</span><br></pre></td></tr></table></figure><p>上面的值是例子。</p><p>其中包含了文件名，我们可以想办法获取其中的文件名。</p><p>我们看到，有<code>filename=</code>和<code>filename*=</code>，后者不一定有，在旧版浏览器中或个别浏览器中，会不支持这种形式，<code>filename*</code>采用了<code>RFC 5987</code>中规定的编码方式。</p><p>所以你要获取文件名，就变成，截取这段字符串中的这两个字段值了。</p><p>看上面的例子大家可能发现，怎么值怪怪的。是的，如果名字是英文，那好办， 如果是有中文或者其他特殊符号，是需要处理好编码的</p><ul><li><code>filename</code>，需要后端处理好编码形式，但是就算后端处理好了，也会应每个浏览器的不同，解析的情况也不同。是个比较难处理好的家伙，所以才有后面的<code>filename*</code></li><li><code>filename*</code>，是个现代浏览器支持的，为了解决<code>filename</code>的不足，一般是<code>UTF-8</code>，我们用<code>decodeURIComponent</code>就能解码了，能还原成原本的样子。当然，解码前你要把值中的<code>UTF-8&#39;&#39;</code>这种部分给去掉。</li></ul><p>所以，在我们实现之前，我们就要明白，取<code>Content-Disposition</code>的内容，并不是百分百能符合你预期的，除非你的文件名全是英文数字。</p><p>我们提取文件名值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xhr是XMLHttpRequest对象</span></span><br><span class="line"><span class="keyword">const</span> content = xhr.getResponseHeader(<span class="string">&#x27;content-disposition&#x27;</span>); <span class="comment">// 注意是全小写，自定义的header也是全小写</span></span><br><span class="line"><span class="keyword">if</span> (content) &#123;</span><br><span class="line">    <span class="keyword">let</span> name1 = content.match(<span class="regexp">/filename=(.*);/</span>)[<span class="number">1</span>]; <span class="comment">// 获取filename的值</span></span><br><span class="line">    <span class="keyword">let</span> name2 = content.match(<span class="regexp">/filename\*=(.*)/</span>)[<span class="number">1</span>]; <span class="comment">// 获取filename*的值</span></span><br><span class="line">    name1 = <span class="built_in">decodeURIComponent</span>(name1);</span><br><span class="line">    name2 = <span class="built_in">decodeURIComponent</span>(name2.substring(<span class="number">6</span>)); <span class="comment">// 这个下标6就是UTF-8&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们获得了两个文件名<code>name1,name2</code>，如果两个都存在，那么我们优先取<code>name2</code>的，因为这个更靠谱，<code>name1</code>如果包含中文或特殊符号，就有风险还原不了真正的文件名。</p><h5 id="自定义header"><a href="#自定义header" class="headerlink" title="自定义header"></a>自定义header</h5><p>本质上跟上述的<code>Content-Disposition</code>差不多，只是我们这里不使用默认的header，我们自己自定义一个<code>response header</code>，跟后端决定好编码方式返回，前端直接获取这个自定义header，然后使用对应的解码即可，如使用<code>decodeURIComponent</code>。</p><p>但是我们都要知道，在跨域的情况下，前端获取到的header只有默认的6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。</p><p>所以你想要获取到别的header，需要后端配合，设置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Expose-Headers: Content-Disposition, custom-header</span><br></pre></td></tr></table></figure><p>这样，前端就能获取到对应暴露的header字段，需要注意的是，<code>Content-Disposition</code>也是需要暴露的。</p><h5 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h5><p>这里额外提供个方法，该方法作用是，当你知道文件的全名（含后缀名），想要重命名，但是得后缀名一样，来获取后缀名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findType</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> index = name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> name.substring(index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="下载大文件"><a href="#下载大文件" class="headerlink" title="下载大文件"></a>下载大文件</h4><p>注意: 如果下载特别大的文件，则上面的就不行了，可能会造成网页崩溃，这里就需要用到下载的库。</p><p><a target="_blank" rel="noopener" href="https://github.com/eligrey/FileSaver.js">FileSaver</a>, 轻松实现下载文件500M</p><h2 id="function与感叹号"><a href="#function与感叹号" class="headerlink" title="function与感叹号"></a>function与感叹号</h2><p><strong>如果在function之前加上感叹号 (!) 会怎么样</strong>？比如下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&#x27;iifksp&#x27;</span>)&#125;()        <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在控制台运行后得到的值时true，为什么是true这很容易理解，因为这个匿名函数没有返回值，默认返回的就是undefined，求反的结果很自然的就是true。所以问题并不在于结果值，而是在于，为什么求反操作能够让一个匿名函数的自调变的合法？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&#x27;iifksp&#x27;</span>)&#125;)()        <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&#x27;iifksp&#x27;</span>)&#125;())        <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>虽然上述两者括号的位置不同，不过效果完全一样。</p><p>其实无论是括号，还是感叹号，让整个语句合法做的事情只有一件，就是<strong>让一个函数声明语句变成了一个表达式</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&#x27;iifksp&#x27;</span>)&#125;        <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这是一个函数声明，如果在这么一个声明后直接加上括号调用，解析器自然不会理解而报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&#x27;iifksp&#x27;</span>)&#125;()        <span class="comment">// SyntaxError: unexpected_token</span></span><br></pre></td></tr></table></figure><p>因为这样的代码混淆了函数声明和函数调用，以这种方式声明的函数 <code>a</code>，就应该以 <code>a();</code> 的方式调用。</p><p>但是括号则不同，它将一个函数声明转化成了一个表达式，解析器不再以函数声明的方式处理函数a，而是作为一个函数表达式处理，也因此只有在程序执行到函数a时它才能被访问。</p><p>所以，<strong>任何消除函数声明和函数表达式间歧义的方法，都可以被解析器正确识别</strong>。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">10</span>&#125;();        <span class="comment">// undefined</span></span><br><span class="line"><span class="number">1</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;();        <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&#x27;iifksp&#x27;</span>)&#125;();        <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>赋值，逻辑，甚至是逗号，各种操作符都可以告诉解析器，这个不是函数声明，它是个函数表达式。并且，对函数一元运算可以算的上是消除歧义最快的方式，感叹号只是其中之一，如果不在乎返回值，这些<strong>一元运算都是有效的</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&#x27;iifksp&#x27;</span>)&#125;()        <span class="comment">// true</span></span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&#x27;iifksp&#x27;</span>)&#125;()        <span class="comment">// NaN</span></span><br><span class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&#x27;iifksp&#x27;</span>)&#125;()        <span class="comment">// NaN</span></span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&#x27;iifksp&#x27;</span>)&#125;()        <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p>甚至下面这些关键字，都能很好的工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&#x27;iifksp&#x27;</span>)&#125;()        <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&#x27;iifksp&#x27;</span>)&#125;()        <span class="comment">// Object</span></span><br><span class="line"><span class="keyword">delete</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&#x27;iifksp&#x27;</span>)&#125;()        <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>最后，括号做的事情也是一样的，消除歧义才是它真正的工作，而不是把函数作为一个整体，所以无论括号括在声明上还是把整个函数都括在里面，都是合法的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&#x27;iifksp&#x27;</span>)&#125;)()        <span class="comment">// undefined</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&#x27;iifksp&#x27;</span>)&#125;())        <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>说了这么多，实则在说的一些都是最为基础的概念——语句，表达式，表达式语句，这些概念如同指针与指针变量一样容易产生混淆。虽然这种混淆对编程无表征影响，但却是一块绊脚石随时可能因为它而头破血流。</p><h2 id="“1”-”2”-”3”-map-parseInt-的输出"><a href="#“1”-”2”-”3”-map-parseInt-的输出" class="headerlink" title="[“1”,”2”,”3”].map(parseInt)的输出"></a>[“1”,”2”,”3”].map(parseInt)的输出</h2><p>这个网红题考察的就是 <code>parseInt</code> 有两个参数。 <code>map</code> 传入的函数可执行三个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ele   遍历的元素</span></span><br><span class="line"><span class="comment">// index 遍历的元素索引</span></span><br><span class="line"><span class="comment">// arr   数组</span></span><br><span class="line">arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">ele, index, arr</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>[‘1’,’2’,’3’].map(parseInt)相当于执行了以下三次过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;2&#x27;</span>, <span class="number">1</span>, [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;3&#x27;</span>, <span class="number">2</span>, [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br></pre></td></tr></table></figure><ul><li><code>parseInt(&#39;1&#39;, 0, [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;])</code>: radix为0时，默认取10，最后返回<code>1</code></li><li><code>parseInt(&#39;2&#39;, 1, [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;])</code>: radix取值为2~36，如果该参数小于 2 或者大于 36，返回<code>NaN</code></li><li><code>parseInt(&#39;3&#39;, 2, [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;])</code>: radix取值为2，二进制只包括0，1，返回<code>NaN</code></li></ul><p>如果想返回[1,2,3]，<code>[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;].map(n=&gt;parseInt(n))</code></p><p><strong>最简单的方案</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>].map(<span class="built_in">Number</span>)</span><br></pre></td></tr></table></figure><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>基于 IEEE 754 标准的<strong>双精度 64 位</strong>二进制格式的值（<code>-(2^53 -1) 到 2^53 -1</code>）。<strong>它并没有为整数给出一种特定的类型</strong>。</p><p>除了能够表示浮点数外，还有一些带符号的值：<code>+Infinity</code>，<code>-Infinity</code> 和 <code>NaN</code> (非数值，Not-a-Number)。</p><p>要检查值是否大于或小于 <code>+/-Infinity</code>，你可以使用常量<code>Number.MAX_VALUE</code> 和 <code>Number.MIN_VALUE</code>。</p><p>另外在 ECMAScript 6 中，你也可以通过 <code>Number.isSafeInteger()</code>方法还有 <code>Number.MAX_SAFE_INTEGER</code>和 <code>Number.MIN_SAFE_INTEGER</code>来检查值是否在双精度浮点数的取值范围内。</p><p><strong>超出这个范围，JavaScript 中的数字不再安全了。</strong></p><blockquote><p>0.1 + 0.2 !== 0.3?</p></blockquote><p>导致这样的问题是因为 <code>JavaScript</code> 中使用基于<strong>IEEE 754标准</strong>的<strong>浮点数</strong>运算，所以会产生<strong>舍入误差</strong>。</p><p>双精度浮点数使用<strong>64 bit</strong>来进行存储。</p><p><strong>计算机中用二进制来存储小数，而大部分小数转成二进制之后都是无限循环的值，因此存在取舍问题，也就是精度丢失。</strong></p><p><strong>不管是浮点数计算的计算结果错误和大整数的计算结果错误，最终都可以归结到JS的精度只有53位（尾数只能存储53位的有效数字）。</strong></p><blockquote><p>解决方案</p></blockquote><ol><li>使用 <code>JavaScript</code> 提供的<strong>最小精度值</strong>判断误差是否在该值范围内<br><code>Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON</code></li><li>使用别人的轮子,例如：<code>math.js</code></li></ol><h2 id="Js中Date对象"><a href="#Js中Date对象" class="headerlink" title="Js中Date对象"></a>Js中Date对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sun Oct 18 2020 10:46:54 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(value); <span class="comment">// new Date(1602989155183)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(dateString);<span class="comment">// new Date(&quot;2020-10-18 10:15:30&quot;)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);<span class="comment">// new Date(2020, 9, 18, 10, 15, 30)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">Date</span>())); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p><code>Date.now()</code>方法返回自<code>1970</code>年<code>1</code>月<code>1</code>日<code>00:00:00 (UTC)</code>到当前时间的毫秒数。</p><p><code>dateObj.getFullYear()</code>方法根据本地时间返回指定日期的年份。</p><p><code>dateObj.getMonth()</code>根据本地时间，返回一个指定的日期对象的月份，为基于<code>0</code>的值，<code>0</code>表示一年中的<strong>第一月</strong>。</p><p><code>dateObj.getDate()</code>根据本地时间，返回一个指定的日期对象为一个月中的哪一日，范围为从<code>1-31</code>。</p><p><code>dateObj.getDay()</code>方法根据本地时间，返回一个具体日期中一周的第几天，<code>0</code>表示星期天。</p><p><code>dateObj.getHours()</code>方法根据本地时间，返回一个指定的日期对象的小时。</p><p><code>dateObj.getMinutes()</code>方法根据本地时间，返回一个指定的日期对象的分钟数。</p><p><code>dateObj.getSeconds()</code>方法根据本地时间，返回一个指定的日期对象的秒数。</p><p><code>dateObj.toLocaleString([locales [, options]])</code>方法返回该日期对象的字符串，该字符串格式因不同语言而不同。新增的参数<code>locales</code>和<code>options</code>使程序能够指定使用哪种语言格式化规则，允许定制该方法的表现<code>behavior</code>。在旧版本浏览器中，<code>locales</code>和<code>options</code>参数被忽略，使用的语言环境和返回的字符串格式是各自独立实现的。</p><p><strong>每隔1s显示当前时间</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formateCurrentDate= <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> date.getFullYear() + <span class="string">&#x27;-&#x27;</span></span><br><span class="line">        + (date.getMonth() + <span class="number">1</span>) + <span class="string">&#x27;-&#x27;</span></span><br><span class="line">        + date.getDate() + <span class="string">&#x27; &#x27;</span></span><br><span class="line">        + date.getHours() + <span class="string">&#x27;:&#x27;</span></span><br><span class="line">        + date.getMinutes() + <span class="string">&#x27;:&#x27;</span></span><br><span class="line">        + date.getSeconds();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// document.querySelectorAll(&#x27;span&#x27;)[0].textContent=formateCurrentDate();</span></span><br><span class="line">    <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;span&#x27;</span>)[<span class="number">0</span>].textContent=<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString();</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// react</span></span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        setTime(formateCurrentDate())</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure><p><strong>日期格式化</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span>: 日期格式化函数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>date 日期类型</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>format 日期格式  默认 yyyy-MM-dd HH:mm:ss格式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params">date, format = <span class="string">&#x27;yyyy-MM-dd HH:mm:ss 星期w&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!date) &#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> typeDate = date <span class="keyword">instanceof</span> <span class="built_in">Date</span> ? date.getTime() : date;</span><br><span class="line">    date = <span class="keyword">new</span> <span class="built_in">Date</span>(typeDate);</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">        <span class="attr">yyyy</span>: date.getFullYear(), <span class="comment">// 完整年份 例：2021 -&gt; 2021</span></span><br><span class="line">        <span class="attr">yy</span>: (<span class="string">&#x27;&#x27;</span> + date.getFullYear()).slice(-<span class="number">2</span>), <span class="comment">// 缩写年份 例：2021 -&gt; 21</span></span><br><span class="line">        <span class="attr">M</span>: date.getMonth() + <span class="number">1</span>, <span class="comment">// 月份 不足两位不补0</span></span><br><span class="line">        <span class="attr">MM</span>: (<span class="string">&#x27;0&#x27;</span> + (date.getMonth() + <span class="number">1</span>)).slice(-<span class="number">2</span>), <span class="comment">// 月份 不足两位补0</span></span><br><span class="line">        <span class="attr">d</span>: date.getDate(), <span class="comment">// 天 不足两位不补0</span></span><br><span class="line">        <span class="attr">dd</span>: (<span class="string">&#x27;0&#x27;</span> + date.getDate()).slice(-<span class="number">2</span>), <span class="comment">// 天 不足两位补0</span></span><br><span class="line">        <span class="attr">H</span>: date.getHours(), <span class="comment">// 24小时 不足两位不补0</span></span><br><span class="line">        <span class="attr">HH</span>: (<span class="string">&#x27;0&#x27;</span> + date.getHours()).slice(-<span class="number">2</span>), <span class="comment">// 24小时 不足两位补0</span></span><br><span class="line">        <span class="attr">h</span>: date.getHours() % <span class="number">12</span>, <span class="comment">// 12小时制 不足两位不补0</span></span><br><span class="line">        <span class="attr">hh</span>: (<span class="string">&#x27;0&#x27;</span> + (date.getHours() % <span class="number">12</span>)).slice(-<span class="number">2</span>), <span class="comment">// 12小时制 不足两位补0</span></span><br><span class="line">        <span class="attr">m</span>: date.getMinutes(),  <span class="comment">// 分钟 不足两位不补0</span></span><br><span class="line">        <span class="attr">mm</span>: (<span class="string">&#x27;0&#x27;</span> + date.getMinutes()).slice(-<span class="number">2</span>), <span class="comment">// 分钟 不足两位补0</span></span><br><span class="line">        <span class="attr">s</span>: date.getSeconds(),  <span class="comment">// 秒 不足两位不补0</span></span><br><span class="line">        <span class="attr">ss</span>: (<span class="string">&#x27;0&#x27;</span> + date.getSeconds()).slice(-<span class="number">2</span>),  <span class="comment">// 秒 不足两位补0</span></span><br><span class="line">        <span class="attr">w</span>: [<span class="string">&#x27;日&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;二&#x27;</span>, <span class="string">&#x27;三&#x27;</span>, <span class="string">&#x27;四&#x27;</span>, <span class="string">&#x27;五&#x27;</span>, <span class="string">&#x27;六&#x27;</span>][date.getDay()], <span class="comment">// 星期</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> format.replace(<span class="regexp">/([a-z]+)/gi</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj[key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(formatDate(<span class="string">&#x27;2021-07-03 19:00:00&#x27;</span>));</span><br><span class="line"><span class="comment">// 2021-07-03 19:00:00 星期六</span></span><br></pre></td></tr></table></figure><p><strong>轮子</strong></p><p><a target="_blank" rel="noopener" href="https://dayjs.fenxianglu.cn/">dayjs</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @FilePath: /src/utils/dateUtils.ts</span></span><br><span class="line"><span class="comment"> * @Description: 包含n个日期时间处理的工具函数模块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> dayjs <span class="keyword">from</span> <span class="string">&#x27;dayjs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 日期格式化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>format 格式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>time 日期</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>格式化后的日期</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 格式化后的日期</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">format</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Date&#125;</span> <span class="variable">time</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span> <span class="variable">formatDate</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  format: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  time?: <span class="built_in">Date</span> | <span class="built_in">string</span> | <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> formatDate: <span class="built_in">string</span> = dayjs(time).format(format)</span><br><span class="line">  <span class="keyword">return</span> formatDate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 返回指定月份格式化后的时间(默认返回上一月份)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Date&#125;</span> <span class="variable">time</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span> </span>month YYYY-MM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getMonth</span>(<span class="params">time?: <span class="built_in">Date</span> | <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> month: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">const</span> mth = <span class="string">`0<span class="subst">$&#123;dayjs().month()&#125;</span>`</span></span><br><span class="line">  <span class="keyword">const</span> mth_time = <span class="string">`0<span class="subst">$&#123;dayjs(time).month() + <span class="number">1</span>&#125;</span>`</span></span><br><span class="line">  <span class="keyword">if</span> (!time) &#123;</span><br><span class="line">    month = <span class="string">`<span class="subst">$&#123;dayjs().year()&#125;</span>-<span class="subst">$&#123;mth.slice(-<span class="number">2</span>)&#125;</span>`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    month = <span class="string">`<span class="subst">$&#123;dayjs(time).year()&#125;</span>-<span class="subst">$&#123;mth_time.slice(-<span class="number">2</span>)&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> month</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSON数据展示"><a href="#JSON数据展示" class="headerlink" title="JSON数据展示"></a>JSON数据展示</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(value[, replacer [, space]])</span><br></pre></td></tr></table></figure><ul><li><p><code>value</code></p><p>将要序列化成 一个 JSON 字符串的值。</p></li><li><p><code>replacer</code> 可选</p><p>如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。</p></li><li><p><code>space</code> 可选</p><p>指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为 10。该值若小于 1，则意味着没有空格；如果该参数为字符串（当字符串长度超过 10 个字母，取其前 10 个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格。</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getLayout = (layout?: string): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (layout) &#123;</span><br><span class="line">            <span class="keyword">const</span> jsonObj = <span class="built_in">JSON</span>.parse(layout)</span><br><span class="line">            <span class="comment">// console.log(&#x27;jsonObj&#x27;, jsonObj)</span></span><br><span class="line">            <span class="comment">// return JSON.stringify(jsonObj, null, 2)</span></span><br><span class="line">            <span class="keyword">return</span> jsonObj</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;p  style=&#123;&#123;<span class="attr">whiteSpace</span>: <span class="string">&#x27;pre&#x27;</span>&#125;&#125;&gt;&#123;getLayout(selectedNodePage?.pageLayout) &#125;&lt;/p&gt; </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;getLayout(selectedNodePage?.pageLayout) &#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span> </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ReactJson</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">     <span class="attr">src</span>=<span class="string">&#123;getLayout(selectedNodePage?.pageLayout)&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">     <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">overflow:</span> &#x27;<span class="attr">auto</span>&#x27;, <span class="attr">height:</span> &#x27;<span class="attr">500px</span>&#x27; &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">/&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong><code>white-space</code></strong> CSS 属性是用来设置如何处理元素中的空白。</p><p>pre：连续的空白符会被保留。在遇到换行符或者<code>br</code>元素时才会换行。</p><p><code>&lt;pre&gt;</code> 元素表示预定义格式文本。在该元素中的文本通常按照原文件中的编排，以等宽字体的形式展现出来，文本中的空白符（比如空格和换行符）都会显示出来。(紧跟在 <code>&lt;pre&gt;</code> 开始标签后的换行符也会被省略)</p><p>轮子：react-json-view(常用于后台网站)</p><h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><h3 id="react"><a href="#react" class="headerlink" title="react"></a>react</h3><p>react-copy-to-clipboard</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;CopyToClipboard text=&#123;<span class="built_in">this</span>.state.value&#125;</span><br><span class="line">    onCopy=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.setState(&#123;<span class="attr">copied</span>: <span class="literal">true</span>&#125;)&#125;&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Copy to clipboard with span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/CopyToClipboard&gt;</span><br></pre></td></tr></table></figure><p>onCopy 可以用来弹出message</p><h3 id="原生"><a href="#原生" class="headerlink" title="原生"></a>原生</h3><p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Clipboard">Clipboard API</a> 提供了响应剪贴板命令（剪切、复制和粘贴）与异步读写系统剪贴板的能力。从权限 API (<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Permissions_API">Permissions API</a>) 获取权限之后，才能访问剪贴板内容；如果用户没有授予权限，则不允许读取剪贴板内容。</p><p>可以使用全局的 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Navigator/clipboard">Navigator.clipboard</a> 来访问剪贴板。</p><p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Navigator/clipboard">Navigator.clipboard</a> 属性返回 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Clipboard">Clipboard</a> 对象，所有操作都通过这个对象进行。</p><p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Clipboard">Clipboard</a> 对象提供了四个方法，用来读写剪贴板。它们都是异步方法，返回 Promise 对象。</p><p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand">Document.execCommand()</a>这个 API 已弃用，不推荐使用它。</p><h3 id="第三方的库"><a href="#第三方的库" class="headerlink" title="第三方的库"></a>第三方的库</h3><p>除了使用原生 JS 外，还可以使用一些第三方的库，比如 <a href="https://link.juejin.cn/?target=https://clipboardjs.com/">clipboard.js</a> 来实现复制文本到剪贴板的操作。</p><h3 id="事件监听-1"><a href="#事件监听-1" class="headerlink" title="事件监听"></a>事件监听</h3><h4 id="copy-事件"><a href="#copy-事件" class="headerlink" title="copy 事件"></a>copy 事件</h4><p>用户向剪贴板放入数据时，将触发 <code>copy</code> 事件。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;copy&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;触发复制事件&#x27;</span>)</span><br><span class="line">  <span class="comment">//剪切板数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.clipboardData)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面示例中，事件对象的 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/ClipboardEvent/clipboardData">clipboardData</a> 属性包含了剪贴板数据。它是一个对象，有以下属性和方法。</p><p><code>Event.clipboardData.setData(type, data)</code>：在 <code>cut</code> 和 <code>copy</code> 事件中修改剪贴板数据，需要指定数据类型。</p><p><code>Event.clipboardData.getData(type)</code>：在 <code>paste</code> 事件中获取剪贴板数据，需要指定数据类型。</p><p><code>Event.clipboardData.items</code>：一个类似数组的对象，包含了所有剪贴项，不过通常只有一个剪贴项。</p><h4 id="cut-事件"><a href="#cut-事件" class="headerlink" title="cut 事件"></a>cut 事件</h4><p><code>cut</code> 事件则是在用户进行剪切操作时触发，它的处理跟 <code>copy</code> 事件完全一样，也是从 <code>Event.clipboardData</code> 属性拿到剪切的数据。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;cut&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;触发剪切事件&#x27;</span>)</span><br><span class="line">	<span class="comment">//剪切板数据</span></span><br><span class="line">	<span class="built_in">console</span>.log(event.clipboardData)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="paste-事件"><a href="#paste-事件" class="headerlink" title="paste 事件"></a>paste 事件</h4><p>用户使用剪贴板数据，进行粘贴操作时，会触发 <code>paste</code> 事件。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;paste&#x27;</span>, <span class="keyword">async</span> (e) =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="comment">//获取剪贴板里的文本数据</span></span><br><span class="line">  <span class="keyword">const</span> text = <span class="keyword">await</span> navigator.clipboard.readText();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;粘贴文本: &#x27;</span>, text);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="innerText、textContent和innerHTML"><a href="#innerText、textContent和innerHTML" class="headerlink" title="innerText、textContent和innerHTML"></a>innerText、textContent和innerHTML</h2><h3 id="Node-textContent"><a href="#Node-textContent" class="headerlink" title="Node.textContent"></a>Node.textContent</h3><p><code>Node</code>接口的 <code>textContent</code> 属性表示一个节点及其后代的文本内容。</p><p>在节点上设置 <code>textContent</code> 属性的话，会删除它的所有子节点，并<strong>替换为一个具有给定值的文本节点</strong>。</p><h3 id="与innerText的区别"><a href="#与innerText的区别" class="headerlink" title="与innerText的区别"></a>与innerText的区别</h3><ul><li><code>textContent</code> 会获取<strong>所有</strong>元素的内容，包括 <code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code> 元素，然而 <code>innerText</code> 只展示给人看的元素。</li><li><code>textContent</code> 会返回节点中的<strong>每一个元素</strong> 相反,<code>innerText</code> 受 CSS 样式的影响,并且<strong>不会返回隐藏元素的文本</strong>。<ul><li>此外，由于 <code>innerText</code> 受 CSS 样式的影响，它会<strong>触发回流</strong>去确保是最新的计算样式。（回流在计算上可能会非常昂贵，因此应尽可能避免。）</li></ul></li><li>与 <code>textContent</code> 不同的是, 在 Internet Explorer (小于和等于 11 的版本) 中对 <code>innerText</code> 进行修改， 不仅会移除当前元素的子节点，而且还会<strong>永久性地破坏</strong>所有后代文本节点。在之后不可能再次将节点再次插入到任何其他元素或同一元素中。</li></ul><h3 id="与innerHTML的区别"><a href="#与innerHTML的区别" class="headerlink" title="与innerHTML的区别"></a>与innerHTML的区别</h3><p>正如其名称，<code>Element.innerHTML</code>返回 HTML。通常，为了在元素中检索或写入文本，人们使用 <code>innerHTML</code>。但是，<code>textContent</code> 通常具有更好的性能，因为文本不会被解析为HTML。</p><p>此外，使用 <code>textContent</code> 可以防止<strong>XSS 攻击</strong>。</p><h2 id="Js选择器"><a href="#Js选择器" class="headerlink" title="Js选择器"></a>Js选择器</h2><p>JS选择器常用的有<code>getElementById()</code>、<code>getElementsByClassName()</code>、<code>getElementsByName()</code>、<code>getElementsByTagName()</code>、<code>querySelector()</code>、<code>querySelectorAll()</code>。</p><h3 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById"></a>getElementById</h3><p>通过<code>id</code>来定位，返回对指定<code>id</code>的<strong>第一个</strong>对象的引用，返回类型为<code>HTMLDivElement</code>。</p><p><code>document.getElementById(&quot;id&quot;)</code></p><h3 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName"></a>getElementsByClassName</h3><p>通过<code>class</code>属性来定位，返回文档中指定<code>class</code>属性值的元素的引用，返回类型为<code>HTMLCollection</code>。</p><p><code>document.getElementsByClassName(&quot;class&quot;)[i]</code></p><h3 id="getElementsByName"><a href="#getElementsByName" class="headerlink" title="getElementsByName"></a>getElementsByName</h3><p>通过<code>name</code>属性来定位，返回文档中指定<code>name</code>属性值的元素的引用，返回类型为<code>NodeList</code>。</p><p><code>document.getElementsByName(&quot;name&quot;)[i]</code></p><h3 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName"></a>getElementsByTagName</h3><p>通过标签的名字来定位，返回文档中<strong>指定标签</strong>的元素的引用，返回类型为<code>HTMLCollection</code>。</p><p><code>document.getElementsByTagName(&quot;p&quot;)[i]</code></p><h3 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector"></a>querySelector</h3><p>通过<code>CSS</code>选择器来定位，返回文档中匹配指定<code>CSS</code>选择器的<strong>第一个</strong>元素的引用，返回类型为<code>HTMLDivElement</code>。</p><p><code>document.querySelector(&quot;div .t5&quot;)</code></p><h3 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll"></a>querySelectorAll</h3><p>通过<code>CSS</code>选择器来定位，返回文档中匹配指定<code>CSS</code>选择器的<strong>所有</strong>元素的引用，返回类型为<code>NodeList</code>。</p><p><code>document.querySelectorAll(&quot;#t6 ~ div&quot;)[i]</code></p><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p><strong>封装实参的对象</strong></p><ul><li>arguments是一个<strong>类数组</strong>对象,它也可以通过索引来操作数据，也可以获取长度。</li><li>在调用函数时，我们所传递的实参都会在arguments中保存</li><li><code>arguments.length</code>可以用来获取实参的长度</li><li><code>arguments[0]</code> 表示第一个实参，<code>arguments[1]</code> 表示第二个实参 。</li></ul><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p><code>eval()</code> 函数会将传入的字符串当做 JavaScript 代码进行执行。</p><p>如果 <code>eval()</code> 的参数不是字符串， <code>eval()</code> 会将参数原封不动地返回。</p><p>永远不要使用 <code>eval</code>！</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;正则&quot;</span>,<span class="string">&quot;匹配模式&quot;</span>);<span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/正则表达式/</span>匹配模式          <span class="comment">// 字面量</span></span><br></pre></td></tr></table></figure><p>匹配模式可以是</p><ul><li><code>i</code> 忽略大小写</li><li><code>g</code> 全局匹配模式</li></ul><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><p><strong>开头结尾</strong></p><p><code>^</code> 表示开头</p><p><code>$</code> 表示结尾</p><p>如果在正则表达式中同时使用<code>^ $</code>则要求字符串必须完全符合正则表达式</p><p><strong>或</strong></p><p>使用 <code>|</code> 表示或者的意思</p><p><code>[]</code>里的内容也是或的关系</p><ul><li>[ab] == a|b</li><li>[a-z] 任意小写字母</li><li>[A-Z] 任意大写字母</li><li>[A-z] 任意字母</li><li>[0-9] 任意数字</li><li>[^ ] 除了</li></ul><p><strong>量词</strong></p><p>通过量词可以设置一个内容出现的次数</p><p>量词只对它<strong>前边的一个内容</strong>起作用</p><ul><li><code>&#123;n&#125;</code> 正好出现n次</li><li><code>&#123;m,n&#125;</code> 出现m-n次</li><li><code>&#123;m,&#125;</code> m次以上</li></ul><ul><li><code>+</code> 至少一个，相当于{1,}</li></ul><ul><li><code>*</code> 0个或多个，相当于{0,}</li><li><code>?</code> 0个或1个，相当于{0,1}</li></ul><p><strong>转义字符</strong></p><p>在正则表达式中使用<code>\</code>作为转义字符</p><h3 id="正则表达式的方法"><a href="#正则表达式的方法" class="headerlink" title="正则表达式的方法"></a>正则表达式的方法</h3><p><code>reg.test(str)</code></p><p>使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果符合则返回true，否则返回false</p><h3 id="字符串和正则相关的方法"><a href="#字符串和正则相关的方法" class="headerlink" title="字符串和正则相关的方法"></a>字符串和正则相关的方法</h3><p><code>split()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据任意字母来将字符串拆分为一个数组</span></span><br><span class="line"><span class="keyword">var</span> result = str.split(<span class="regexp">/[A-z]/</span>);</span><br></pre></td></tr></table></figure><p><code>search()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搜索字符串中是否含有abc 或 aec 或 afc</span></span><br><span class="line"><span class="comment">// 如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1</span></span><br><span class="line">result = str.search(<span class="regexp">/a[bef]c/</span>);</span><br></pre></td></tr></table></figure><p><code>match()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从一个字符串中将符合条件的内容提取出来</span></span><br><span class="line"><span class="comment">// 默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索</span></span><br><span class="line"><span class="comment">// 我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容</span></span><br><span class="line">str = <span class="string">&quot;1a2a3a4a5e6f7A8B9C&quot;</span>;</span><br><span class="line">result = str.match(<span class="regexp">/[a-z]/ig</span>);</span><br></pre></td></tr></table></figure><p><code>replace()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串中指定内容替换为新的内容,默认只会替换第一个</span></span><br><span class="line">result = str.replace(<span class="regexp">/[a-z]/gi</span> , <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p><code>use strict</code></p><p>全局变量必须<strong>显式声明</strong></p><p><strong>禁止（函数中）this指向全局对象，而是指向undefined</strong></p><p><strong>禁止删除变量</strong></p><p>禁止了<strong>不在脚本或者函数层面上</strong>的函数声明(if、for等)</p><p>禁止<strong>变量</strong>、<strong>对象属性</strong>或<strong>函数参数</strong>重名</p><p>禁止动态绑定 <strong>动态绑定：即某些属性和方法到底属于哪个对象，不是在编译时确定，而是在运行时确定。</strong></p><p><strong>限制了arguments对象</strong>：不允许对arguments赋值，arguments不再跟踪参数的变化</p><h2 id="AST-抽象语法树"><a href="#AST-抽象语法树" class="headerlink" title="AST 抽象语法树"></a>AST 抽象语法树</h2><p>AST 全称为 Abstract Syntax Tree，译为抽象语法树。在 JavaScript 中，任何一个对象（变量、函数、表达式等）都可以转化为一个抽象语法树的形式。抽象语法树本质就是一个树形结构的对象。</p><p>一个对象生成 AST 的关键所在是词法分析和语法分析。</p><p>词法分析指的是将对象逐个扫描，获取每一个字母的信息，生成由对象组成的一维数组。</p><p>语法分析指的是将有关联的对象整合成树形结构的表达形式。</p><p>用途：</p><ol><li>常用各类转义、编译的插件中。比如最典型的 ES6 转换为 ES5工具 、JSX 语法转换为 JavaScript 语法。即 babel 模块。</li><li>代码语法的检查，比如代码规范工具 ESLint 模块。</li><li>各类 JS/CSS/HTML 压缩工具。</li><li>代码的格式化、高亮。</li><li>代码错误提示。</li><li>代码自动补全。</li></ol><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6+"></a>ES6+</h1><h2 id="模块化★"><a href="#模块化★" class="headerlink" title="模块化★"></a>模块化★</h2><blockquote><p>考察公司：百度</p></blockquote><p><strong>将 JavaScript 程序拆分为可按需导入的单独模块的机制</strong>。</p><ul><li><strong>避免命名冲突(减少命名空间污染)</strong></li><li><strong>更好的分离, 按需加载</strong></li><li><strong>更高复用性</strong></li><li><strong>高可维护性</strong></li></ul><p>早期 全局函数 对象 IIFE(闭包) 缺点：引入多个<code>&lt;script&gt;</code>，请求过多、依赖模糊、难以维护</p><p>通过<strong>模块化规范</strong>解决</p><ul><li><p>CommonJS 适合<strong>服务端</strong> <strong>同步</strong>加载</p></li><li><p>AMD 异步加载 开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</p></li><li><p>CMD与AMD规范很相似 依赖就近，延迟执行，可以很容易在Node.js中运行 依赖SPM 打包，模块的加载逻辑偏重。</p></li></ul><p><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</strong>。</p><p><strong>CommonJS</strong></p><ul><li><p>CommonJS 用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用<code>exports</code>），用<code>require</code>加载模块。</p></li><li><p>CommonJS 模块输出的是<strong>一个值的拷贝</strong>，ES6 模块输出的是<strong>值的引用</strong>。</p></li><li><p>CommonJS 模块是<strong>运行时加载（对象）</strong>，ES6 模块是<strong>编译时输出接口</strong>。</p></li></ul><p><strong>ES6模块化</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;main.mjs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>export 导出：<strong>函数</strong>，<code>var</code>，<code>let</code>，<code>const</code>, 和<strong>类</strong>。</p></li><li><p><code>import</code> <code>from</code></p></li><li><p>模块自动使用<strong>严格模式</strong>和<strong>自动延迟加载</strong>。</p></li><li><p><code>export default</code> 默认导出 <strong>不用大括号</strong></p></li><li><p>在你的 <code>import</code> 和 <code>export</code> 语句的大括号中，可以使用 <code>as</code> 关键字重命名</p></li><li><p><code>import * as Module</code> 创建模块对象</p></li><li><p><code>export &#123; name &#125; from &#39;x.mjs&#39;</code> 合并模块 <strong>导入后跟导出的简写</strong></p></li><li><p>动态加载模块 将<code>import()</code>作为函数调用，将其传递给模块的路径作为参数。 它返回一个 <code>promise</code>，它用一个<strong>模块对象</strong>来实现，让你可以访问该对象的导出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;/modules/myModule.mjs&#x27;</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Do something with the module.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="let、const和var★"><a href="#let、const和var★" class="headerlink" title="let、const和var★"></a>let、const和var★</h2><blockquote><p>考察公司：腾讯</p></blockquote><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul><li><p>存在<strong>变量提升</strong>，即变量可以在声明之前调用，值为<code>undefined</code>。</p></li><li><p>可以<strong>重复声明</strong>，第一次用来声明，后面只是重新赋值。</p></li><li><p>在<strong>函数</strong>中使用var声明变量的时候，该变量是<strong>局部</strong>的；对于声明在任何函数外（<strong>特别注意if和for中</strong>）的变量来说是<strong>全局</strong>的。</p></li></ul><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li><p>let声明变量前，该变量不能使用（<strong>暂时性死区</strong>）。</p></li><li><p>在<strong>块级作用域</strong>内有效。</p></li><li><p>let不允许在<strong>相同作用域</strong>中重复声明，注意是相同作用域，不同作用域有重复声明不会报错。</p></li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul><li><p><strong>暂时性死区</strong>。</p></li><li><p><strong>存在块级作用域</strong>。</p></li><li><p><strong>同一作用域不允许重复声明变量</strong>。</p></li><li><p>const声明创建对值的<strong>只读引用</strong>。这并不意味着它持有的值是不可变的，只是变量标识符不能被重新分配。例如，在内容是<strong>对象</strong>的情况下，这意味着可以更改对象的内容（例如，其属性）</p></li></ul><blockquote><p>全局中用<strong>let</strong>和<strong>const</strong>声明的变量存在<strong>Script</strong>上，用<strong>var</strong>声明的存在<strong>Global</strong>上（浏览器一般用<strong>Window</strong>表示）</p></blockquote><h2 id="Class与继承★"><a href="#Class与继承★" class="headerlink" title="Class与继承★"></a>Class与继承★</h2><blockquote><p>考察公司：字节、腾讯</p></blockquote><p><strong>类是用于创建对象的模板。</strong>JS中的类建立在<strong>原型</strong>上，但也具有某些语法和语义未与ES5类相似语义共享。</p><h3 id="类定义与调用"><a href="#类定义与调用" class="headerlink" title="类定义与调用"></a>类定义与调用</h3><p><strong>类表达式</strong>和<strong>类声明</strong>。<strong>两者都不会提升</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Rectangle(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;&#125; <span class="comment">//类声明</span></span><br><span class="line"><span class="keyword">let</span> Rectangle = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;<span class="comment">//类表达式</span></span><br></pre></td></tr></table></figure><p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p><h3 id="严格模式-1"><a href="#严格模式-1" class="headerlink" title="严格模式"></a>严格模式</h3><p>类的主体都执行在<strong>严格模式</strong>下，与普通构造函数不同。</p><p>当调用静态或原型方法时<strong>没有指定 this的值</strong>，那么方法内的 this值将被置为 **<code>undefined</code>**。</p><h3 id="构造函数与方法"><a href="#构造函数与方法" class="headerlink" title="构造函数与方法"></a>构造函数与方法</h3><p><code>constructor</code>（<strong>构造函数</strong>）方法是一个特殊的方法，这种方法用于<strong>创建和初始化</strong>一个由<code>class</code>创建的对象。</p><p>一个构造函数可以使用 <code>super</code> 关键字来<strong>调用一个父类的构造函数</strong>，从而获得父类的this。</p><p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。</p><p>事实上，<strong>类的所有非静态方法</strong>都定义在类的<code>prototype</code>属性上面。</p><p>因此，<strong>在类的实例上面调用方法，其实就是调用原型上的方法</strong>。</p><p>另外，类的内部所有定义的方法，都是<strong>不可枚举的（non-enumerable）</strong>。这一点与 ES5 的行为不一致。</p><p><code>static</code> 关键字用来定义一个类的一个静态方法。调用静态方法不需要<strong>实例化</strong>该类，但<strong>不能通过一个类实例调用静态方法</strong>。静态方法通常用于<strong>为一个应用程序创建工具函数</strong>。</p><h3 id="属性-字段"><a href="#属性-字段" class="headerlink" title="属性/字段"></a>属性/字段</h3><p><strong>实例的属性</strong>必须定义在<strong>类的方法里</strong>，静态的或原型的数据属性必须定义在<strong>类定义的外面</strong>。</p><p><strong>字段声明</strong>（实验性功能）</p><ul><li><p>公有字段：预先声明字段，类定义变得更加自我记录，并且字段始终存在。这个字段<strong>可以用也可以不用默认值来声明</strong>。</p></li><li><p>私有字段（<code>#</code>） 它们只能在类里面中读取或写入。</p></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><code>extends</code> 关键字在类声明或类表达式中用于创建一个类作为另一个类的一个子类。</p><p>如果子类中定义了构造函数，那么它必须先调用 <code>super()</code> 才能使用 <code>this</code> 。</p><p><code>super</code> 关键字也用于<strong>调用对象的父对象上的方法。</strong><code>super.fn();</code></p><p>也可以继承传统的基于函数的“类”，但不能继承<strong>常规对象（不可构造的）</strong>。</p><p>如果要继承常规对象，可以改用<code>Object.setPrototypeOf()</code>：</p><p><code>Object.setPrototypeOf(obj, proto);</code>直接修改已有对象的原型。</p><h2 id="Set-Map-★"><a href="#Set-Map-★" class="headerlink" title="Set/Map ★"></a>Set/Map ★</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>值的集合（键和值相同，且唯一）</p><p><strong>方法</strong>：</p><ul><li><code>set.add(v)</code></li><li><code>set.delete(v)</code></li><li><code>set.has(v)</code>（返回布尔值）</li><li><code>set.clear()</code></li></ul><p><strong>属性</strong>：<code>set.size</code></p><p><strong>实现了iterator接口</strong></p><ul><li><p>可以使用<code>for…of…</code>进行遍历 <code>set.keys()</code>，<code>set.values()</code>(默认)，<code>set.entries()</code></p></li><li><p>遍历顺序就是<strong>插入顺序</strong></p></li><li><p><code>forEach</code>（键值、键名、集合本身），用于对每个成员执行某种操作，没有返回值</p></li><li><p>扩展运算符（<code>...</code>）</p></li><li><p>数组的<code>map</code>和<code>filter</code>方法也可以<strong>间接</strong>用于 Set 了 <code>new Set([...set].map(x =&gt; x * 2))</code></p></li></ul><p><strong>应用</strong></p><ul><li><p><strong>去重</strong></p><ul><li><code>Set</code>函数可以接受一个数组（或者具有 <code>iterable</code> 接口的其他数据结构）作为参数，用来初始化。</li><li>数组去重：<code>Array.from(new Set(array))</code>或<code>[...new Set(array)]</code></li><li>字符串去重：<code>[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)</code></li><li>set中所有<code>NaN</code>值都是相等的。</li></ul></li><li><p><strong>交并差</strong></p><ul><li>交：<code>[...new Set(nums1)].filter(x =&gt; new Set(nums2).has(x));</code></li><li>并：<code>[...new Set([...nums1, ...nums2])]</code></li><li>差：<code>[...new Set(nums1)].filter(x =&gt; !new Set(nums2).has(x))</code></li></ul></li></ul><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>值只能是<strong>对象</strong></p><p><strong>弱引用：</strong>如果其他对象都不再引用该对象，那么<strong>垃圾回收机制会自动回收该对象所占用的内存</strong>，不考虑该对象还存在于 WeakSet 之中。</p><p>由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，所以<strong>不可遍历</strong> 。</p><p>方法：<code>ws.add(v)</code> <code>ws.delete(v)</code> <code>ws.has(v)</code></p><p>使用场景：<strong>储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏</strong>。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><strong>键值对</strong>的<strong>有序</strong>列表，而键和值都可以是<strong>任意类型</strong></p><p>方法：</p><ul><li><code>map.set(k, v)</code></li><li><code>map.get(k)</code>（返回键对应的值）</li><li><code>map.has(k)</code>（返回布尔值）</li><li><code>map.delete(k)</code></li><li><code>map.clear()</code></li></ul><p>属性：<code>map.size</code></p><p>遍历大致同Set，只是set的键值相同。Map初始化传入的应该至少是一个<strong>二维数组</strong>。<code>entries()</code>（默认，[键，值]）</p><p><strong>Object 和 map 的比较</strong></p><ul><li><p>map 只包含<strong>显式插入的键</strong>；Object <strong>原型链</strong>上的键名有可能和你自己在对象上的设置的键名产生冲突。</p></li><li><p>map 键可以是<strong>任意值</strong>；Object 的键必须是一个 <code>String</code> （其他类型键会转换为字符串，如对象=&gt;<code>&#39;[object Object]&#39;</code>）或是<code>Symbol</code>。<strong>不是有效的JavaScript标识符的属性名</strong>(如，具有空格或连字符的属性名，或以数字开头的属性名)<strong>只能使用方括号</strong>符号访问。</p></li><li><p>map 键 有序（插入）；Object 的键是<strong>无序</strong>的。自ECMAScript 2015规范以来，对象确实保留了字符串和Symbol键的创建顺序； 因此，在<strong>只有字符串键的对象</strong>上进行迭代将按插入顺序产生键。</p></li><li><p>键值对个数 map size；Object无。</p></li><li><p>map 本身可迭代； Object 需要以某种方式获得键。</p></li><li><p>map在<strong>频繁增删键值对</strong>的场景下表现更好。</p></li></ul><p><strong>对象和map互换</strong></p><ul><li><p>对象转为 Map 。 <code>new Map(Object.entries(obj))</code></p></li><li><p>map 转为对象。如果所有Map的键都是字符串，它可以无损地转为对象。如果有<strong>非字符串</strong>的键名，那么这个键名会被<strong>转成字符串</strong>，再作为对象的键名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>数组和map互换</strong></p><ul><li><p>Map 转为数组 <code>[...myMap]</code></p></li><li><p>数组 转为 Map</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="literal">true</span>, <span class="number">7</span>],</span><br><span class="line">  [&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]]</span><br><span class="line">])</span><br></pre></td></tr></table></figure></li></ul><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p><strong>键名</strong>只能<strong>对象</strong> ，<strong>弱引用的只是键名</strong>，<strong>无法遍历</strong></p><p>方法：<code>wm.get(k)</code>、<code>wm.set(k,v)</code>、<code>wm.has(k)</code>、<code>wm.delete(k)</code></p><p>应用：<strong>DOM 节点作为键名</strong>，防止内存泄漏；部署私有属性；<strong>深拷贝循环引用</strong></p><h2 id="Promise★"><a href="#Promise★" class="headerlink" title="Promise★"></a>Promise★</h2><blockquote><p>考察公司：字节、百度、b站</p></blockquote><h3 id="Promise概念"><a href="#Promise概念" class="headerlink" title="Promise概念"></a>Promise概念</h3><p>本质上，Promise 是一个<strong>对象</strong>，代表<strong>操作的中间状态</strong> —— 正如它的单词含义 ‘<strong>承诺</strong>‘ ，它<strong>保证在未来可能返回某种结果</strong>。</p><p>虽然 Promise 并不保证操作在何时完成并返回结果，但是它保证当结果可用时，你的代码能正确处理结果，当结果不可用时，你的代码同样会被执行，来优雅的处理错误。</p><h3 id="与旧式回调相比"><a href="#与旧式回调相比" class="headerlink" title="与旧式回调相比"></a>与旧式回调相比</h3><p><code>Promise</code>是专门为异步操作而设计的，与旧式回调相比具有许多优点:</p><ul><li>您可以<strong>使用多个then()操作将多个异步操作链接在一起，并将其中一个操作的结果作为输入传递给下一个操作</strong>。避免<strong>回调地狱</strong>（如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差）。</li><li><code>Promise</code>总是严格按照它们放置在事件队列中的<strong>顺序调用</strong>。</li><li>错误处理要好得多——所有的错误都由块末尾的一个<code>.catch()</code>块处理，而不是每一层单独处理。</li></ul><h3 id="状态-语法"><a href="#状态-语法" class="headerlink" title="状态/语法"></a>状态/语法</h3><p><strong>创建promise时</strong>，它既不是成功也不是失败状态。这个状态叫作<strong>pending</strong>（待定）。</p><p>当<strong>promise返回</strong>时，称为 <strong>resolved</strong>（已解决）。</p><ul><li>一个成功<strong>resolved</strong>的promise称为<strong>fullfilled</strong>（<strong>实现</strong>）。它返回一个值，可以通过将<code>.then()</code>块链接到promise链的末尾来访问该值。<code>.then()</code>块中的执行程序函数将包含promise的返回值。</li><li>一个不成功<strong>resolved</strong>的promise被称为<strong>rejected</strong>（<strong>拒绝</strong>）了。它返回一个原因（<strong>reason</strong>），一条错误消息，说明为什么拒绝promise。可以通过将<code>.catch()</code>块链接到promise链的末尾来访问此原因。</li></ul><p>状态只能由 <code>Pending --&gt; Fulfilled</code> 或者 <code>Pending --&gt; Rejected</code>，且<strong>一旦发生改变不可二次修改</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123; <span class="comment">/* executor */</span></span><br><span class="line">    <span class="comment">// 执行代码 需要指明resolve与reject的回调位置</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>executor</code>是带有<code>resolve</code>和<code>reject</code>两个参数的函数。</p><p><code>Promise</code>构造函数执行时<strong>立即调用</strong><code>executor</code>函数，<code>resolve</code>和<code>reject</code>两个函数作为参数传递给<code>executor</code>。</p><p><code>resolve</code>和<code>reject</code>函数被调用时，分别将<code>promise</code>的状态改为完成<code>fulfilled</code>或失败<code>rejected</code>。</p><p><code>executor</code>内部通常会执行一些<strong>异步操作</strong>，一旦异步操作执行完毕，要么调用<code>resolve</code>函数来将<code>promise</code>状态改成<code>fulfilled</code>，要么调用<code>reject</code>函数将<code>promise</code>的状态改为<code>rejected</code>。</p><p>如果在<code>executor</code>函数中抛出一个错误，那么该<code>promise</code>状态为<code>rejected</code>，<code>executor</code>函数的返回值被忽略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义三个常量表示状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = PENDING;<span class="comment">// 初始状态</span></span><br><span class="line">        <span class="built_in">this</span>.result = <span class="literal">null</span>;<span class="comment">// 成功之后的值</span></span><br><span class="line">        <span class="built_in">this</span>.reason = <span class="literal">null</span>; <span class="comment">// 失败之后的原因</span></span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallbacks = []; <span class="comment">// 成功回调函数的队列</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks = [];<span class="comment">// 失败回调函数的队列</span></span><br><span class="line">        <span class="comment">// 类中普通函数内部this指向的是undefined，用箭头函数指向当前实例对象</span></span><br><span class="line">        <span class="comment">// 更改成功后的状态</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123; <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">                <span class="built_in">this</span>.status = FULFILLED;</span><br><span class="line">                <span class="built_in">this</span>.result = result;</span><br><span class="line">                queueMicrotask(<span class="function">() =&gt;</span> &#123;<span class="comment">// resolve里面将所有成功的回调拿出来执行</span></span><br><span class="line">                    <span class="built_in">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                        callback(result)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更改失败后的状态</span></span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = REJECTED;</span><br><span class="line">                <span class="built_in">this</span>.reason = reason;</span><br><span class="line">                queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                        callback(reason)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// executor 是一个执行器，进入会立即执行</span></span><br><span class="line">        <span class="comment">// 并传入resolve和reject方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)<span class="comment">// 如果有错误，就直接执行reject</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h3><h4 id="then-onFulfilled-onRejected"><a href="#then-onFulfilled-onRejected" class="headerlink" title="then(onFulfilled, onRejected)"></a>then(onFulfilled, onRejected)</h4><p>返回一个<code>Promise</code> 。它最多需要有两个参数：Promise的成功和失败情况的回调函数。</p><h4 id="catch-onRejected"><a href="#catch-onRejected" class="headerlink" title="catch(onRejected)"></a>catch(onRejected)</h4><p>返回一个<code>Promise</code>，并且处理拒绝的情况。它的行为与调用<code>Promise.prototype.then(undefined, onRejected)</code>相同。</p><h4 id="finally-onFinally"><a href="#finally-onFinally" class="headerlink" title="finally(onFinally)"></a>finally(onFinally)</h4><p>返回一个<code>Promise</code>。在promise结束时，无论结果是<code>fulfilled</code>或者是<code>rejected</code>，都会执行指定的回调函数。这为在<code>Promise</code>是否成功完成后都需要执行的代码提供了一种方式。</p><p>这避免了同样的语句需要在<code>then()</code>和<code>catch()</code>中各写一次的情况。</p><p><code>finally()</code> 虽然与 <code>.then(onFinally, onFinally)</code> 类似，它们不同的是：</p><ul><li>调用内联函数时，不需要多次声明该函数或为该函数创建一个变量保存它。</li><li>由于无法知道<code>promise</code>的最终状态，所以<code>finally</code>的回调函数中不接收任何参数，它仅用于无论最终结果如何都要执行的情况。</li><li>与<code>Promise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)</code> （resolved的结果为<code>undefined</code>）不同，<code>Promise.resolve(2).finally(() =&gt; &#123;&#125;)</code> resolved的结果为 <code>2</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then 原型方法</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否为函数，不是的话使用默认函数</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 为了链式调用return一个promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">            <span class="comment">// 创建一个微任务等待 promise 完成初始化</span></span><br><span class="line">            queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.result); <span class="comment">//获取成功回调函数的执行结果</span></span><br><span class="line">                resolvePromise(result, resolve, reject); <span class="comment">// 传入resolvePromise集中处理</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">            queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                resolvePromise(result, resolve, reject);</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">            <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">            <span class="built_in">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">            <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装一个函数统一处理回调函数的执行结果 </span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">result, resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 判断result是不是 MyPromise 实例对象</span></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                result.then(resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// catch 原型方法 其实就是执行一下then的第二个回调</span></span><br><span class="line"><span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">finally</span>(<span class="params">onFinally</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123; <span class="comment">// then返回的也是一个Promise对象</span></span><br><span class="line">        onFinally(); <span class="comment">// 执行回调,但不传递数据</span></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 保证返回的Promise对象的数据一致</span></span><br><span class="line">    &#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">        onFinally();</span><br><span class="line">        <span class="keyword">throw</span> reason; <span class="comment">// 保证返回的Promise对象的数据状态一致</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="Promise-all-iterable-★"><a href="#Promise-all-iterable-★" class="headerlink" title="Promise.all(iterable) ★"></a>Promise.all(iterable) ★</h4><p>这个方法返回一个新的<code>promise</code>对象</p><ul><li>该<code>promise</code>对象在<code>iterable</code>参数对象里所有的<code>promise</code>对象<strong>都成功</strong>的时候才会触发成功</li><li>一旦有任何一个<code>iterable</code>里面的<code>promise</code>对象失败则立即触发该<code>promise</code>对象的失败。</li><li>这个新的<code>promise</code>对象在触发成功状态以后，会把一个包含<code>iterable</code>里所有<code>promise</code>返回值的数组作为成功回调的返回值，顺序跟<code>iterable</code>的顺序保持一致。</li><li>如果这个新的<code>promise</code>对象触发了失败状态，它会把<code>iterable</code>里第一个触发失败的<code>promise</code>对象的错误信息作为它的失败错误信息。</li><li><code>Promise.all</code>方法常被用于处理多个<code>promise</code>对象的状态集合。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//all 静态方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;<span class="comment">//记录resolve次数</span></span><br><span class="line">    <span class="keyword">const</span> result = [];<span class="comment">// resolve回调的结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 用于处理传入值不为Promise的情况</span></span><br><span class="line">            MyPromise.resolve(p).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                result[count++] = val;</span><br><span class="line">                <span class="comment">//所有then执行后, resolve结果,结果为一个数组</span></span><br><span class="line">                <span class="keyword">if</span> (count === promiseArr.length) resolve(result);</span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="comment">//有一个Promise被reject时，MyPromise的状态变为reject</span></span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise-race-iterable"><a href="#Promise-race-iterable" class="headerlink" title="Promise.race(iterable)"></a>Promise.race(iterable)</h4><p>返回一个<code>promise</code>，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// race 静态方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">            MyPromise.resolve(p).then(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="Promise.resolve(value)"></a>Promise.resolve(value)</h4><p>返回一个状态由给定<code>value</code>决定的<code>Promise</code>对象。</p><ul><li>如果该值是<code>thenable</code>(即，带有<code>then</code>方法的对象)，返回的<code>Promise</code>对象的最终状态由<code>then</code>方法执行决定；</li><li>否则的话(该<code>value</code>为空，基本类型或者不带<code>then</code>方法的对象),返回的<code>Promise</code>对象状态为<code>fulfilled</code>，并且将该<code>value</code>传递给对应的<code>then</code>方法。</li><li>通常而言，如果你不知道一个值是否是<code>Promise</code>对象，使用<code>Promise.resolve(value)</code>来返回一个<code>Promise</code>对象,这样就能将该<code>value</code>以<code>Promise</code>对象形式使用。不要在解析为自身的<code>thenable</code>上调用<code>Promise.resolve</code>，这将导致无限递归，因为它试图展平无限嵌套的<code>promise</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolve 静态方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果这个值是一个promise ，那么将返回这个promise </span></span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;<span class="comment">// 否则返回的promise将以此值完成。</span></span><br><span class="line">        resolve(result);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise-reject-reason"><a href="#Promise-reject-reason" class="headerlink" title="Promise.reject(reason)"></a>Promise.reject(reason)</h4><p>返回一个带有拒绝原因的<code>Promise</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reject 静态方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise-allSettled-iterable"><a href="#Promise-allSettled-iterable" class="headerlink" title="Promise.allSettled(iterable)"></a>Promise.allSettled(iterable)</h4><p>该方法返回一个在所有给定的promise都已经<code>fulfilled</code>或<code>rejected</code>后的promise，并带有一个对象数组，每个对象表示对应的promise结果。</p><p>当您有多个彼此不依赖的异步任务成功完成时，或者您总是想知道每个<code>promise</code>的结果时，通常使用它。</p><p>相比之下，<code>Promise.all()</code> 更适合彼此相互依赖或者在其中任何一个<code>reject</code>时立即结束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">allSettled</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> length = promiseArr.length;</span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">        promiseArr.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                result[count++] = &#123; <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>, <span class="attr">result</span>: val &#125;;</span><br><span class="line">                <span class="keyword">if</span> (count === length) resolve(result);</span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                result[count++] = &#123; <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>, <span class="attr">reason</span>: err &#125;;</span><br><span class="line">                <span class="keyword">if</span> (count === length) resolve(result)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     resolve(&quot;a&quot;);</span></span><br><span class="line">    <span class="comment">//     reject(&#x27;b&#x27;)</span></span><br><span class="line">    <span class="comment">//     console.log(4)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    reject(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">    <span class="comment">// throw new Error(&#x27;a&#x27;)</span></span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;other&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// console.log(3)</span></span><br><span class="line"><span class="keyword">var</span> p11 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p12 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">MyPromise.race([p11, p12]).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// all</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;success1&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;success2&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">MyPromise.all([p1, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);      <span class="comment">// 成功状态 //[&quot;success1&quot;, &quot;success2&quot;]</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">MyPromise.all([p1, p3, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);      <span class="comment">// 失败状态 // fail</span></span><br><span class="line">&#125;)</span><br><span class="line">MyPromise.allSettled([p1, p3, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br><span class="line">MyPromise.resolve(<span class="number">233</span>).finally(<span class="function">() =&gt;</span> &#123; &#125;)</span><br></pre></td></tr></table></figure><h3 id="Async-await-★"><a href="#Async-await-★" class="headerlink" title="Async/await ★"></a>Async/await ★</h3><p>es2017的新语法，async/await就是<code>generator</code> + <code>promise</code>的语法糖</p><p><code>async</code> 函数可以看作<strong>自带启动器</strong>的 generator 函数的语法糖，将 Generator 函数的星号（<code>*</code>）替换成 <code>async</code>，将 <code>yield</code> 替换成 <code>await</code>。</p><p>相对于 Generator 的改进主要集中集中在：</p><ul><li><strong>内置执行器</strong></li><li><strong>更好的语义化</strong></li><li><strong>Promise 的返回值</strong></li></ul><p>到这里大家会发现，Async/Await 本质也是 Promise 的语法糖：Async 函数返回了 Promise 对象。</p><p>async/await 和 Promise 的关系非常的巧妙，<strong>await必须在async内使用</strong>，<strong>并装饰一个Promise对象</strong>，<strong>async返回的也是一个Promise对象</strong>。</p><p>await 关键字使JavaScript运行时暂停于此行，允许其他代码在此期间执行，直到异步函数调用返回其结果。</p><p><code>await</code> 关键字<strong>会阻塞其后的代码</strong>，直到promise完成，就像执行同步操作一样。<strong>它确实可以允许其他任务在此期间继续运行，但您自己的代码被阻塞。</strong></p><h3 id="promiseTimeout-★"><a href="#promiseTimeout-★" class="headerlink" title="promiseTimeout ★"></a>promiseTimeout ★</h3><blockquote><p>b站的题目并不是传入promise，而是一个回调函数</p></blockquote><p>该方法接收两个参数，第一个参数为promise，第二个参数为number类型。该方法的作用为：</p><ol><li>若promise在第二个参数给定的时间内处于pending状态，则返回一个rejected的promise，其reason为new Error(“promise time out”)</li><li>若promise在第二个参数给定的时间内处于非pending状态，则返回值为promise</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseTimeout</span>(<span class="params">p, timeout</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> timerPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">_, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(reject, timeout, <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;promise time out&#x27;</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.race([p, timerPromise]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="js实现-sleep-函数"><a href="#js实现-sleep-函数" class="headerlink" title="js实现 sleep 函数"></a>js实现 sleep 函数</h3><p>sleep函数作用是让线程休眠，等到指定时间在重新唤起。</p><h4 id="普通版"><a href="#普通版" class="headerlink" title="普通版"></a>普通版</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">  <span class="keyword">while</span> ((<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() - start &lt; delay) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">  sleep(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;222&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>这种实现方式是利用一个伪死循环阻塞主线程。因为JS是单线程的。所以通过这种方式可以实现真正意义上的sleep()。</p><h4 id="定时器-2"><a href="#定时器-2" class="headerlink" title="定时器"></a>定时器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep1</span>(<span class="params">ms, callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(callback, ms)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sleep 1s</span></span><br><span class="line">sleep1(<span class="number">1000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><p>简单易实现，兼容性好，毕竟只是用了 setTimeout，而且非常好理解。</p><p><strong>缺点：</strong></p><p>我们需要传入回调函数的方式进去，如果函数里面有多回调函数可能不太好理解。另外一点就是它不会阻塞同步任务。</p><h4 id="Promise-版本"><a href="#Promise-版本" class="headerlink" title="Promise 版本"></a>Promise 版本</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve,time)) </span><br><span class="line">&#125; </span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function">()=&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;)</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><p>不用再传入回调函数，采用链式调用。</p><p><strong>缺点：</strong></p><p>仍未解决阻塞问题，依然会先执行同步任务。</p><h4 id="Async-Await-版本"><a href="#Async-Await-版本" class="headerlink" title="Async/Await 版本"></a>Async/Await 版本</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">reslove</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(reslove, delay)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">!<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">3000</span>)</span><br><span class="line">  <span class="keyword">const</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="built_in">console</span>.log(t2 - t1)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>优点：优雅、可以完美的阻塞我们的代码</p><p>缺点： ES7 语法存在兼容性问题，有 babel 一切兼容性都不是问题</p><h4 id="不要忘了开源的力量"><a href="#不要忘了开源的力量" class="headerlink" title="不要忘了开源的力量"></a>不要忘了开源的力量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = <span class="built_in">require</span>(<span class="string">&quot;sleep&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t1 = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">sleep.msleep(<span class="number">3000</span>)</span><br><span class="line"><span class="keyword">const</span> t2 = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="built_in">console</span>.log(t2 - t1)</span><br></pre></td></tr></table></figure><p>优点：能够实现更加精细的时间精确度，而且看起来就是真的 sleep 函数，清晰直白。</p><p>缺点：缺点需要安装这个模块，^_^，这也许算不上什么缺点。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><strong>箭头函数表达式</strong>的语法比<strong>函数表达式</strong>更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。</p><p>箭头函数表达式<strong>更适用于那些本来需要匿名函数的地方</strong>，并且它<strong>不能用作构造函数</strong>。</p><ol><li>箭头函数<strong>没有自己的this</strong>，它是<strong>通过作用域链查到外层作用域的this</strong>，且指向函数<strong>定义时</strong>的this而<strong>非执行时</strong>。</li><li><strong>不可以用作构造函数</strong>，<strong>不能使用new命令</strong>，否则会报错。同时，箭头函数<strong>没有prototype属性</strong>。</li><li>箭头函数<strong>没有arguments对象</strong>，如果要用，使用<strong>rest参数</strong>（<code>...args</code>）代替。</li><li><strong>不可以使用yield命令</strong>，因此箭头函数<strong>不能用作Generator函数</strong>。</li><li><strong>不能用call/apply/bind修改this指向</strong>，但<strong>可以通过修改外层作用域的this来间接修改</strong>。</li></ol><h2 id="展开语法、剩余参数"><a href="#展开语法、剩余参数" class="headerlink" title="展开语法、剩余参数"></a>展开语法、剩余参数</h2><ul><li><strong>展开语法</strong>（扩展运算符<code>...</code>）是将<strong>数组</strong>或者<strong>可迭代对象</strong>拆分成逗号分隔的参数序列。</li><li><strong>剩余参数</strong>语法允许我们<strong>将一个不定数量的参数表示为一个数组</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  alert(theArgs.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>展开语法:<code>...</code>，剩余参数：<code>theArgs</code></p><p>剩余（Rest）语法看起来和扩展（Spread）语法完全一样。在某种程度上，剩余语法与扩展语法相反。</p><p>扩展语法将数组“展开”为其元素，而剩余语法收集多个元素并将它们“压缩”为单个元素。</p><p>剩余参数和 <code>arguments</code>对象之间的区别主要有三个：</p><ul><li>剩余参数<strong>只包含那些没有对应形参的实参</strong>，而 <code>arguments</code> 对象包含了传给函数的<strong>所有实参</strong>。</li><li><code>arguments</code>对象不是一个真正的数组，而剩余参数是真正的 <code>Array</code>实例，也就是说你能够在它上面直接使用所有的数组方法，比如 <code>sort</code>，<code>map</code>，<code>forEach</code>或<code>pop</code>。</li><li><code>arguments</code>对象还有一些附加的属性 （如<code>callee</code>属性）。</li></ul><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p><code>ES6</code>允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 基本</span></span><br><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]]; <span class="comment">//嵌套</span></span><br><span class="line"><span class="keyword">let</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 可忽略</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b] = []; <span class="comment">// a = 1, b = undefined // 不完全解构</span></span><br><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 剩余运算符</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 字符串等</span></span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;; <span class="comment">// 对象模型的解构 前后两个key需对应</span></span><br></pre></td></tr></table></figure><h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><p><code>BigInt</code>类型是 JavaScript 中的一个基础的数值类型，可以<strong>用任意精度表示整数</strong>。</p><p>使用 BigInt，您可以<strong>安全地存储和操作大整数，甚至可以超过数字的安全整数限制</strong>。</p><p>BigInt 是通过在整数末尾附加 <code>n</code>或调用构造函数来创建的。</p><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol是 ECMAScript 第6版新定义的。符号类型是<strong>唯一</strong>的并且是<strong>不可修改</strong>的, 并且也可以<strong>用来作为 Object 的 key 的值</strong>。</p><h2 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h2><p>遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。</p><p><strong>任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）</strong>。</p><p>Iterator 的作用有三个：</p><ul><li>一是为各种数据结构，提供一个统一的、简便的访问接口；</li><li>二是使得数据结构的成员能够按某种次序排列；</li><li>三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</li></ul><p>创建一个指针对象，指向当前数据结构的起始位置。也就是说，<strong>遍历器对象本质上，就是一个指针对象</strong>。</p><p>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</p><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。</p><p>具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。</p><p>其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p><p>原生具备 Iterator 接口的数据结构如下。</p><ul><li><strong>Array</strong></li><li><strong>Map</strong></li><li><strong>Set</strong></li><li><strong>String</strong></li><li>TypedArray</li><li><strong>函数的 arguments 对象</strong></li><li>NodeList 对象</li></ul><p><strong>调用 Iterator 接口的场合：</strong></p><ul><li><p>对数组和 Set 结构进行<strong>解构赋值</strong>时，会默认调用<code>Symbol.iterator</code>方法。</p></li><li><p><strong>扩展运算符</strong>（…）也会调用默认的 Iterator 接口。</p></li></ul><p>实际上，这提供了一种简便机制，<strong>可以将任何部署了 Iterator 接口的数据结构，转为数组</strong>。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...iterable];</span><br></pre></td></tr></table></figure><ul><li><p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p></li><li><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。</p><ul><li><p><code>for...of</code></p></li><li><p><code>Array.from()</code></p></li><li><p><code>Map(), Set(), WeakMap(), WeakSet()</code>（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</p></li><li><p><code>Promise.all()</code></p></li><li><p><code>Promise.race()</code></p></li></ul></li></ul><h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><p><strong>调用生成器函数会返回一个生成器对象，每次调用生成器对象的 next 方法会执行函数到下一次 yield 关键字停止执行，并且返回一个 <code>&#123; value: Value, done: boolean &#125;</code>的对象。</strong></p><p><strong>当我们为 next 传递值进行调用时，传入的值会被当作上一次生成器函数暂停时 yield 关键字的返回值处理。</strong></p><p>生成器<code>generator</code>是<code>ES6</code>标准引入的新的数据类型，一个<code>generator</code>看上去像一个函数，但可以返回多次，通过<code>yield</code>关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而<strong>为异步编程提供解决方案</strong>。</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul><li><code>Generator.prototype.next()</code>：返回一个由<code>yield</code>表达式生成的值。</li><li><code>Generator.prototype.return()</code>：返回给定的值并结束生成器。</li><li><code>Generator.prototype.throw()</code>：向生成器抛出一个错误。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用<code>function*</code>声明方式会定义一个生成器函数<code>generator function</code>，它返回一个<code>Generator</code>对象。</p><p>可以把它理解成，<code>Generator</code>函数是一个状态机，封装了多个内部状态，执行<code>Generator</code>函数会返回一个遍历器对象。</p><p>调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的迭代器<code>iterator</code>对象，他是一个<strong>指向内部状态对象的指针</strong>。</p><p>当这个迭代器的<code>next()</code>方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现<code>yield</code>的位置为止，<code>yield</code>后紧跟迭代器要返回的值，也就是指针就会从函数头部或者上一次停下来的地方开始执行到下一个<code>yield</code>。</p><p>或者如果用的是<code>yield*</code>，则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。</p><p><code>next()</code>方法返回一个对象，这个对象包含两个属性：<code>value</code>和<code>done</code>，</p><ul><li><code>value</code>属性表示本次<code>yield</code>表达式的返回值，</li><li><code>done</code>属性为布尔类型，表示生成器后续是否还有<code>yield</code>语句，即生成器函数是否已经执行完毕并返回。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// f &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 11, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 21, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 31, done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: undefined, done: true&#125; // 可以无限next()，但是value总为undefined，done总为true</span></span><br></pre></td></tr></table></figure><p>调用<code>next()</code>方法时，如果传入了参数，那么这个参数会传给上一条执行的<code>yield</code>语句<strong>左边</strong>的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(y);</span><br><span class="line">    <span class="keyword">yield</span> x + y;</span><br><span class="line">    <span class="built_in">console</span>.log(x,y);</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// f &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 11, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="number">50</span>)); <span class="comment">// &#123;value: 51, done: false&#125; // y被赋值为50</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 31, done: true&#125; // x,y 1,50</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>若显式指明<code>return</code>方法给定返回值，则返回该值并结束遍历<code>Generator</code>函数，若未显式指明<code>return</code>的值，则返回<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// f &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 11, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 21, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 31, done: false&#125; // 注意此处的done为false</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p><code>yield*</code>表达式表示<code>yield</code>返回一个遍历器对象，用于在<code>Generator</code>函数内部，调用另一个 <code>Generator</code>函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">callee</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">300</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">yield</span>* callee();</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// f &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 11, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 100, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 200, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 31, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>异步操作的同步化表达</p><p><code>yield</code>表达式可以暂停函数执行，<code>next</code>方法用于恢复函数执行，这使得<code>Generator</code>函数非常适合将异步任务同步化。</p><h2 id="如何确保你的构造函数只能被new调用，而不能被普通调用？"><a href="#如何确保你的构造函数只能被new调用，而不能被普通调用？" class="headerlink" title="如何确保你的构造函数只能被new调用，而不能被普通调用？"></a>如何确保你的构造函数只能被new调用，而不能被普通调用？</h2><h3 id="明确函数的双重用途"><a href="#明确函数的双重用途" class="headerlink" title="明确函数的双重用途"></a>明确函数的双重用途</h3><p><code>JavaScript</code> 中的函数一般有两种使用方式:</p><ul><li>当作构造函数使用: <code>new Func()</code></li><li>当作普通函数使用: <code>Func()</code></li></ul><p>但 <code>JavaScript</code> 内部并没有区分两者的方式，我们人为规定<strong>构造函数名首字母要大写</strong>作为区分。也就是说，构造函数被当成普通函数调用不会有报错提示。</p><h3 id="使用-instanceof-实现"><a href="#使用-instanceof-实现" class="headerlink" title="使用 instanceof 实现"></a>使用 instanceof 实现</h3><p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object <span class="keyword">instanceof</span> <span class="title">constructor</span></span><br></pre></td></tr></table></figure><p>我们可以使用 <code>instanceof</code> 检测某个对象是不是另一个对象的实例，例如 <code>new Person() instanceof Person --&gt; true</code></p><h4 id="new-绑定-默认绑定"><a href="#new-绑定-默认绑定" class="headerlink" title="new 绑定/ 默认绑定"></a>new 绑定/ 默认绑定</h4><ul><li>通过 <code>new</code> 来调用构造函数，会生成一个新对象，并且把这个新对象绑定为调用函数的 <code>this</code> 。</li><li>如果普通调用函数，非严格模式 <code>this</code> 指向 <code>window</code>，严格模式指向 <code>undefined</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Window &#123;...&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Test())</span><br><span class="line"><span class="comment">// Test &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Test())</span><br></pre></td></tr></table></figure><p>使用 <code>new</code> 调用函数和普通调用函数最大的区别在于**函数内部 <code>this</code> 指向不同: <code>new</code> 调用后 <code>this</code> 指向实例，普通调用则会指向 <code>window</code>**。</p><p><code>instanceof</code> 可以检测某个对象是不是另一个对象的实例。如果为 <code>new</code> 调用， <code>this</code> 指向实例，<strong>this instanceof 构造函数</strong> 返回值为 <code>true</code> ，普通调用返回值为 <code>false</code>。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this instanceof Person</span></span><br><span class="line">    <span class="comment">// 如果返回值为 false，说明为普通调用</span></span><br><span class="line">    <span class="comment">// 返回类型错误信息——当前构造函数需要使用 new 调用</span></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Function constructor A cannot be invoked without &quot;new&quot;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">    <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    <span class="built_in">this</span>.fullName = <span class="built_in">this</span>.firstName + <span class="built_in">this</span>.lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当作普通函数调用</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Function constructor A cannot be invoked without &quot;new&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(Person(<span class="string">&quot;leslie&quot;</span>, <span class="string">&quot;wang&quot;</span>));</span><br></pre></td></tr></table></figure><p>通过输出结果，我们可以发现，定义的 <code>Person</code> 构造函数已经无法被普通调用了。</p><p>但这种方案并不是完美的，存在一点小小的瑕疵。我们可以通过伪造实例的方法骗过构造函数里的判断。</p><p>具体实现: <code>JavaScript</code> 提供的 <code>apply/call</code> 方法可以修改 <code>this</code> 指向，如果调用时将 <code>this</code> 指向修改为 <code>Person</code> 实例，就可以成功骗过上面的语法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.call(<span class="keyword">new</span> Person(),<span class="string">&quot;leslie&quot;</span>, <span class="string">&quot;wang&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p><code>ES6</code> 为 <code>new</code> 命令引入了一个 <code>new.target</code> 属性，该属性一般用在构造函数之中，返回 <code>new</code> 命令作用于的那个构造函数。如果构造函数不是通过 <code>new</code> 命令或 <code>Reflect.construct()</code> 调用的，<code>new.target</code> 会返回 <code>undefined</code> ，<strong>因此这个属性可以用来确定构造函数是怎么调用的</strong>。</p><p><code>new.target</code> 就是为确定构造函数的调用方式而生的，太符合这个场景了，我们来试一下 <code>new.target</code> 的用法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new: Person &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;new: &quot;</span>,<span class="keyword">new</span> Person())</span><br><span class="line"><span class="comment">// not new: undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;not new:&quot;</span>, Person())</span><br></pre></td></tr></table></figure><p>所以我们就可以使用 <code>new.target</code> 来非常简单的实现对构造函数的限制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">new</span>.target)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Function constructor A cannot be invoked without &quot;new&quot;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught TypeError: Function constructor A cannot be invoked without &quot;new&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;not new:&quot;</span>, Person())</span><br></pre></td></tr></table></figure><h3 id="使用ES6-Class"><a href="#使用ES6-Class" class="headerlink" title="使用ES6 Class"></a>使用ES6 Class</h3><p>类也具备限制构造函数只能用 <code>new</code> 调用的作用。</p><p><code>ES6</code> 提供 <code>Class</code> 作为构造函数的语法糖，来实现语义化更好的面向对象编程，并且对 <code>Class</code> 进行了规定：<strong>类的构造器必须使用 new 来调用</strong>。</p><p>因此后续在进行面向对象编程时，强烈推荐使用 <code>ES6</code> 的 <code>Class</code>。 <code>Class</code> 修复了很多 <code>ES5</code> 面向对象编程的缺陷，例如类中的所有方法都是不可枚举的；类的所有方法都无法被当作构造函数使用等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught TypeError: Class constructor Person cannot be invoked without &#x27;new&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(Person())</span><br></pre></td></tr></table></figure><h3 id="new-target-实现抽象类"><a href="#new-target-实现抽象类" class="headerlink" title="new.target 实现抽象类"></a>new.target 实现抽象类</h3><p>首先来看一下 <code>new.target</code> 在类中使用会返回什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Person()</span><br><span class="line"><span class="comment">// console.log</span></span><br><span class="line"><span class="comment">// class Person &#123;</span></span><br><span class="line"><span class="comment">//     constructor (name) &#123;</span></span><br><span class="line"><span class="comment">//         this.name = name;</span></span><br><span class="line"><span class="comment">//         console.log(new.target)</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><code>Class</code> 内部调用 <code>new.target</code>，会返回当前 <code>Class</code>。</p><p><strong>需要注意的是，子类继承父类时，<code>new.target</code>会返回子类</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">type, name, age</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// extends 是 Class 中实现继承的关键字</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;baobao&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog()</span><br></pre></td></tr></table></figure><p>子类调用和父类调用的返回结果是不同的，利用这个特性，就可实现父类不可调用而子类可以调用的情况——面向对象中的<strong>抽象类</strong>。</p><h4 id="抽象类实现"><a href="#抽象类实现" class="headerlink" title="抽象类实现"></a>抽象类实现</h4><p>什么是抽象类那？我们以动物世界为例。</p><p>我们定义了一个动物类 <code>Animal</code>，并且通过这个类来创建动物，动物是个抽象概念，当你提到动物类时，你并不知道我会创建什么动物。只有将动物实体化，比如说猫，狗，猪啊，这才是具体的动物，并且每个动物的行为都会有所不同。因此我们不应该通过创建 <code>Animal</code> 实例来生成动物，<code>Animal</code> 只是动物抽象概念的集合。</p><p><code>Animal</code> 就是一个抽象类，我们不应该通过它来生成动物，而是通过它的子类，例如 <code>Dog、Cat</code> 等来生成对应的 <code>dog/cat</code> 实例。</p><p><code>new.target</code> 子类调用和父类调用的返回值是不同的，所以我们可以借助 <code>new.target</code> 实现抽象类。</p><blockquote><p>抽象类也可以理解为不能独立使用、必须继承后才能使用的类。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">type, name, age</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Animal) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;abstract class cannot new&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// extends 是 Class 中实现继承的关键字</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;baobao&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught TypeError: abstract class cannot new</span></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Animal(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;baobao&quot;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了三种限制构造函数只能被 <code>new</code> 调用的方案</p><ul><li>借助 <code>instanceof</code> 和 <code>new</code> 绑定的原理，适用于低版本浏览器</li><li>借助 <code>new.target</code> 属性，可与 <code>class</code> 配合定义抽象类</li><li>面向对象编程使用 <code>ES6 class</code>——最佳方案</li></ul><h1 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h1><h2 id="深拷贝★"><a href="#深拷贝★" class="headerlink" title="深拷贝★"></a>深拷贝★</h2><blockquote><p>考察公司：美团、百度</p></blockquote><p>对象直接赋值的情况，不涉及任何拷贝。此时为<strong>同一个引用</strong>。</p><p>浅拷贝只能拷贝<strong>一层对象</strong>。如果有对象的<strong>嵌套</strong>，那么浅拷贝将无能为力。</p><p><strong>浅拷贝：</strong></p><ul><li><p><strong>concat()</strong> <code>let newArr = arr.concat();</code></p></li><li><p><strong>slice()</strong> <code>let newArr = arr.slice();</code></p></li><li><p><strong>…展开运算符</strong> <code>let newArr = [...arr];</code></p></li><li><p><strong>Array.from</strong> <code>let newArr = Array.from(arr);</code></p></li><li><p><strong>Object.assign(target, …sources)</strong> 拷贝的是<strong>（可枚举）属性值</strong>。假如源值是一个对象的引用，它仅仅会复制其<strong>引用值</strong>。</p><p><code>let newArr = Object.assign([],arr);</code></p></li></ul><p><strong>深拷贝:</strong></p><p><code>JSON.parse(JSON.stringify(object))</code></p><ol><li>无法解决<code>循环引用</code>的问题。举个例子：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">val</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a.target = a;</span><br></pre></td></tr></table></figure><p>拷贝a会出现系统栈溢出，因为出现了<code>无限递归</code>的情况。</p><ol start="2"><li>无法拷贝一些<code>特殊的对象</code>，诸如 RegExp, Date, Set, Map等。</li><li>无法拷贝<code>函数</code>。</li><li>会忽略 <code>undefined</code>、<code>symbol</code>等</li></ol><p>第三方最完善的深拷贝方法是<code>Lodash</code>库的 <code>_.cloneDeep()</code>方法。</p><p>原生API–structuredClone</p><p><strong>手写</strong></p><p><strong>递归</strong>的思路去实现一个深拷贝方法。WeakMap解决<strong>循环引用</strong>。</p><p>假设我们使用的 Map，那么 <code>foo</code> 对象和我们深拷贝内部的 <code>const map = new Map()</code> 创建的 <code>map</code> 对象一直都是强引用关系，那么在程序结束之前，<code>foo</code> 不会被回收，其占用的内存空间一直不会被释放。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝简易版本</span></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function"><span class="params">source</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> weakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">    <span class="keyword">const</span> isArray = <span class="function"><span class="params">arr</span> =&gt;</span> toString.call(arr) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> isMap = <span class="function"><span class="params">map</span> =&gt;</span> toString.call(map) === <span class="string">&#x27;[object Map]&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> isSet = <span class="function"><span class="params">set</span> =&gt;</span> toString.call(set) === <span class="string">&#x27;[object Set]&#x27;</span>;</span><br><span class="line">    <span class="comment">// const isObject = obj =&gt; toString.call(obj) === &#x27;[object Object]&#x27;;</span></span><br><span class="line">    <span class="keyword">const</span> isObject = <span class="function"><span class="params">obj</span> =&gt;</span> obj !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> ;</span><br><span class="line">    <span class="keyword">const</span> copy = <span class="function"><span class="params">input</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isObject(input))<span class="keyword">return</span> input;</span><br><span class="line">        <span class="keyword">if</span> (input <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(input);</span><br><span class="line">        <span class="keyword">if</span> (input <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(input);</span><br><span class="line">        <span class="keyword">if</span>(weakmap.has(input)) <span class="keyword">return</span> weakmap.get(input);</span><br><span class="line">        <span class="keyword">if</span>(isMap(input))<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Map</span>([...input]);</span><br><span class="line">        <span class="keyword">if</span>(isSet(input))<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>([...input]);</span><br><span class="line">        <span class="keyword">const</span> output = isArray(input) ? [] : &#123;&#125;;</span><br><span class="line">        weakmap.set(input,output);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> input)&#123;</span><br><span class="line">            <span class="keyword">if</span>(input.hasOwnProperty(k)) output[k]=copy(input[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set.add(<span class="string">&#x27;zvxvx&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> date=<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1111</span>)</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d+/</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj.b = obj;</span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, obj,[<span class="number">1</span>,<span class="number">2</span>],set,map,date,reg];</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="keyword">let</span> newArr1 = deepClone(arr1);</span><br><span class="line">newArr1[<span class="number">2</span>].a = <span class="number">1000</span>;</span><br><span class="line">newArr1[<span class="number">4</span>].add(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr1);</span><br></pre></td></tr></table></figure><h2 id="平铺数组-lt-gt-树形结构★"><a href="#平铺数组-lt-gt-树形结构★" class="headerlink" title="平铺数组&lt;=&gt;树形结构★"></a>平铺数组&lt;=&gt;树形结构★</h2><blockquote><p>考察公司：腾讯、小米</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;001&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;节点1&quot;</span>, <span class="attr">pid</span>: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;0011&quot;</span>, <span class="attr">pid</span>: <span class="string">&quot;001&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;节点1-1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;00111&quot;</span>, <span class="attr">pid</span>: <span class="string">&quot;0011&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;节点1-1-1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;002&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;节点2&quot;</span>, <span class="attr">pid</span>: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generateTree = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    item.children = arr.filter(<span class="function">(<span class="params">childitem</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item.id === childitem.pid;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> !item.pid; <span class="comment">// undefined null 0 &#x27;&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">tree = generateTree(arr);</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeToArr</span>(<span class="params">treeData, result = [], &#123; childrenName = <span class="string">&quot;children&quot;</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  treeData.forEach(<span class="function">(<span class="params">treeItem</span>) =&gt;</span> &#123;</span><br><span class="line">    result.push(treeItem);</span><br><span class="line">    <span class="keyword">if</span> (treeItem[childrenName]) &#123;</span><br><span class="line">      TreeToArr(treeItem[childrenName], result);</span><br><span class="line">      <span class="keyword">delete</span> treeItem[childrenName];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(TreeToArr(tree));</span><br></pre></td></tr></table></figure><h2 id="new★"><a href="#new★" class="headerlink" title="new★"></a>new★</h2><blockquote><p>考察公司：百度</p></blockquote><p><strong>new是一个运算符</strong>，用于创建一个给定构造函数的实例对象。</p><p><strong>new</strong> 关键字会进行如下的操作：</p><ol><li>创建一个空对象并将该对象的<code>__proto__</code>指向构造函数原型<code>prototype</code>；</li><li>将步骤1新创建的对象作为<code>this</code>的上下文执行构造函数 ；</li><li><strong>优先构造函数返回的对象</strong>，否则返回<strong>新创建的对象</strong>。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1、通过call，this指向了arguments，shift删除并返回arguments中第一个参数——构造函数</span></span><br><span class="line">    Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 2、创建一个空的对象并将该对象的__proto__指向构造函数原型，obj.__proto__ 影响性能，不建议用</span></span><br><span class="line">    <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(Con.prototype);</span><br><span class="line">    <span class="comment">// let obj =&#123;&#125;;</span></span><br><span class="line">    <span class="comment">// obj.__proto__=Con.prototype;</span></span><br><span class="line">    <span class="comment">// 3、绑定 this 执行构造函数</span></span><br><span class="line">    <span class="keyword">let</span> res = Con.apply(obj,<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 4、优先返回构造函数返回的对象</span></span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? res : obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">color</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color=color</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> car = _new(Car,<span class="string">&#x27;black&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(car)</span><br></pre></td></tr></table></figure><h2 id="setTimeout模拟实现setInterval-★"><a href="#setTimeout模拟实现setInterval-★" class="headerlink" title="setTimeout模拟实现setInterval ★"></a>setTimeout模拟实现setInterval ★</h2><blockquote><p>考察公司：百度</p></blockquote><blockquote><p>题目描述:setInterval 用来实现循环定时调用 可能会存在一定的问题 能用 setTimeout 解决吗</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setInterval</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer =<span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">interval</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        fn();</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(interval,delay);</span><br><span class="line">    &#125;</span><br><span class="line">    interval();</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;<span class="built_in">clearTimeout</span>(timer)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> claerFn=_setInterval(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(claerFn,<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><blockquote><p>扩展：我们能反过来使用 setinterval 模拟实现 settimeout 吗？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setTimeout</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer =<span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        fn();</span><br><span class="line">        <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">    &#125;,delay)</span><br><span class="line">&#125;</span><br><span class="line">_setTimeout(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">222</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><blockquote><p>扩展思考：为什么要用 settimeout 模拟实现 setinterval？setinterval 的缺陷是什么？</p></blockquote><ul><li><p><code>setTimeout()</code>在<strong>指定的时间后</strong>执行一段代码。</p></li><li><p><code>setInterval()</code>以<strong>固定的时间间隔</strong>，重复运行一段代码。</p></li><li><p><code>requestAnimationFrame()</code>setInterval()的现代版本;在浏览器下一次重新绘制显示之前执行指定的代码块，从而允许动画在<strong>适当的帧率</strong>下运行，而不管它在什么环境中运行。</p></li></ul><p>这些函数设置的异步代码实际上在<strong>主线程</strong>上运行（在其指定的计时器过去之后）。</p><p><strong>指定的时间（或延迟）不能保证在指定的确切时间之后执行，而是最短的延迟执行时间</strong>。<strong>在主线程上的堆栈为空之前，传递给这些函数的回调将无法运行。</strong></p><p>可以通过调用<code>clearTimeout()</code>，将<code>setTimeout()</code>调用的<strong>标识符</strong>作为参数传递给它，从而在超时运行之前取消。</p><p>通过将<code>setInterval()</code>调用返回的标识符传递给<code>clearInterval()</code>函数可以清除intervals。</p><p><strong>递归setTimeout()和setInterval()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">setTimeout</span>(run, <span class="number">100</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>上述代码的两个版本之间的差异是微妙的。</p><ul><li>递归 <code>setTimeout()</code> 保证<strong>执行之间的延迟相同</strong>，例如在上述情况下为100ms。 代码将运行，然后在它再次运行之前等待100ms，因此无论代码运行多长时间，间隔都是相同的。</li><li>使用 <code>setInterval()</code> 的示例有些不同。 <strong>我们选择的间隔包括执行我们想要运行的代码所花费的时间</strong>。假设代码需要40毫秒才能运行 - 然后间隔最终只有60毫秒。</li><li>当递归使用 <code>setTimeout()</code> 时，每次迭代都可以在运行下一次迭代之前计算不同的延迟。 换句话说，第二个参数的值可以指定在再次运行代码之前等待的不同时间（以毫秒为单位）。</li></ul><p>当<strong>你的代码有可能比你分配的时间间隔，花费更长时间运行时</strong>，最好使用递归的 <code>setTimeout()</code> - 这将使执行之间的时间间隔保持不变，无论代码执行多长时间，你不会得到错误。</p><p><code>requestAnimationFrame()</code>是一种<strong>允许您以给定当前浏览器/系统的最佳帧速率重复且高效地运行函数</strong>的方法。除非您需要特定的速率帧，否则您应该尽可能使用它而不要去使用<code>setInterval()/recursive setTimeout()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// Drawing code goes here</span></span><br><span class="line">   requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><h2 id="Event-Bus（事件总线）★"><a href="#Event-Bus（事件总线）★" class="headerlink" title="Event Bus（事件总线）★"></a>Event Bus（事件总线）★</h2><blockquote><p>考察公司：百度</p></blockquote><p><code>Event Bus</code> 事件总线，通常作为多个模块间的通信机制，相当于一个事件管理中心，一个模块发送消息，其它模块接受消息，就达到了通信的作用。</p><p>使用场景：兄弟组件传值</p><p><code>Event Bus</code> 本质上是采用了发布-订阅的设计模式，比如多个模块 <code>A</code>、<code>B</code>、<code>C</code> 订阅了一个事件 <code>EventX</code>，然后某一个模块 <code>X</code> 在事件总线发布了这个事件，那么事件总线会负责通知所有订阅者 <code>A</code>、<code>B</code>、<code>C</code>，它们都能收到这个通知消息，同时还可以传递参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关系图</span></span><br><span class="line">                           模块X</span><br><span class="line">                            ⬇发布EventX</span><br><span class="line">╔════════════════════════════════════════════════════════════════════╗</span><br><span class="line">║                         Event Bus                                  ║</span><br><span class="line">║                                                                    ║</span><br><span class="line">║         【EventX】       【EventY】       【EventZ】   ...           ║</span><br><span class="line">╚════════════════════════════════════════════════════════════════════╝</span><br><span class="line">  ⬆订阅EventX            ⬆订阅EventX           ⬆订阅EventX</span><br><span class="line"> 模块A                   模块B                  模块C</span><br></pre></td></tr></table></figure><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><p>使用 JavaScript 来实现一个简单版本的 <code>Event Bus</code></p><ul><li>首先构造一个 <code>EventBus</code> 类，初始化一个空对象用于存放所有的事件</li><li>在接受订阅时，将事件名称作为 key 值，将需要在接受发布消息后执行的回调函数作为 value 值，由于一个事件可能有多个订阅者，所以这里的回调函数要存储成列表</li><li>在发布事件消息时，从事件列表里取得指定的事件名称对应的所有回调函数，依次触发执行即可</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化事件列表</span></span><br><span class="line">      <span class="built_in">this</span>.eventObject = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发布事件</span></span><br><span class="line">    <span class="function"><span class="title">publish</span>(<span class="params">eventName</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 取出当前事件所有的回调函数</span></span><br><span class="line">      <span class="keyword">const</span> callbackList = <span class="built_in">this</span>.eventObject[eventName];</span><br><span class="line">      <span class="keyword">if</span> (!callbackList) <span class="keyword">return</span> <span class="built_in">console</span>.warn(eventName + <span class="string">&quot; not found!&quot;</span>);</span><br><span class="line">      <span class="comment">// 执行每一个回调函数</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> callback <span class="keyword">of</span> callbackList) &#123;</span><br><span class="line">        callback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 订阅事件</span></span><br><span class="line">    <span class="function"><span class="title">subscribe</span>(<span class="params">eventName, callback</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化这个事件</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.eventObject[eventName]) &#123;</span><br><span class="line">        <span class="built_in">this</span>.eventObject[eventName] = [];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 存储订阅者的回调函数</span></span><br><span class="line">      <span class="built_in">this</span>.eventObject[eventName].push(callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 测试</span></span><br><span class="line">  <span class="keyword">const</span> eventBus = <span class="keyword">new</span> EventBus();</span><br><span class="line">  <span class="comment">// 订阅事件eventX</span></span><br><span class="line">  eventBus.subscribe(<span class="string">&quot;eventX&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;模块A&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  eventBus.subscribe(<span class="string">&quot;eventX&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;模块B&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  eventBus.subscribe(<span class="string">&quot;eventX&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;模块C&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发布事件eventX</span></span><br><span class="line">  eventBus.publish(<span class="string">&quot;eventX&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="1-如何在发送消息时传递参数"><a href="#1-如何在发送消息时传递参数" class="headerlink" title="1. 如何在发送消息时传递参数"></a>1. 如何在发送消息时传递参数</h4><p>发布者传入一个参数到 <code>EventBus</code> 中，在 <code>callback</code> 回调函数执行的时候接着传出参数，这样每一个订阅者就可以收到参数了。</p><h4 id="2-订阅后如何取消订阅"><a href="#2-订阅后如何取消订阅" class="headerlink" title="2. 订阅后如何取消订阅"></a>2. 订阅后如何取消订阅</h4><p>有时候订阅者只想在某一个时间段订阅消息，这就涉及带取消订阅功能。我们将对代码进行改造。</p><p>首先，要实现指定订阅者取消订阅，每一次订阅事件时，都生成唯一一个取消订阅的函数，用户直接调用这个函数，我们就把当前订阅的回调函数删除。</p><p>其次，订阅的回调函数列表使换成对象结构存储，为每一个回调函数设定一个唯一 <code>id</code>， 注销回调函数的时候可以提高删除的效率，如果还是使用数组的话需要使用 <code>split</code> 删除，效率不如对象的 <code>delete</code>。</p><h4 id="3-如何只订阅一次"><a href="#3-如何只订阅一次" class="headerlink" title="3. 如何只订阅一次"></a>3. 如何只订阅一次</h4><p>如果一个事件只发生一次，通常也只需要订阅一次，收到消息后就不用再接受消息。</p><p>首先，我们提供一个 <code>subscribeOnce</code> 的接口，内部实现几乎和 <code>subscribe</code> 一样，只有一个地方有区别，在 <code>callbackId</code> 前面的加一个字符 <code>d</code>，用来标示这是一个需要删除的订阅。</p><p>然后，在执行回调函数后判断当前回调函数的 <code>id</code> 有没有标示，决定我们是否需要删除这个回调函数。</p><h4 id="4-如何清除某个事件或者所有事件"><a href="#4-如何清除某个事件或者所有事件" class="headerlink" title="4. 如何清除某个事件或者所有事件"></a>4. 如何清除某个事件或者所有事件</h4><p>我们还希望通过一个 <code>clear</code> 的操作来将指定事件的所有订阅清除掉，这个通常在一些组件或者模块卸载的时候用到。</p><p>和取消订阅的逻辑相似，只不过这里统一处理了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化事件列表</span></span><br><span class="line">        <span class="built_in">this</span>.eventObject = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 回调函数列表的id</span></span><br><span class="line">        <span class="built_in">this</span>.callbackId = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发布事件</span></span><br><span class="line">    <span class="function"><span class="title">publish</span>(<span class="params">eventName, ...args</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 取出当前事件所有的回调函数</span></span><br><span class="line">        <span class="keyword">const</span> callbackObject = <span class="built_in">this</span>.eventObject[eventName];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!callbackObject) <span class="keyword">return</span> <span class="built_in">console</span>.warn(eventName + <span class="string">&quot; not found!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行每一个回调函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> callbackObject) &#123;</span><br><span class="line">            <span class="comment">// 执行时传入参数</span></span><br><span class="line">            callbackObject[id](...args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只订阅一次的回调函数需要删除</span></span><br><span class="line">            <span class="keyword">if</span> (id[<span class="number">0</span>] === <span class="string">&quot;d&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> callbackObject[id];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 订阅事件</span></span><br><span class="line">    <span class="function"><span class="title">subscribe</span>(<span class="params">eventName, callback</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化这个事件</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.eventObject[eventName]) &#123;</span><br><span class="line">            <span class="comment">// 使用对象存储，注销回调函数的时候提高删除的效率</span></span><br><span class="line">            <span class="built_in">this</span>.eventObject[eventName] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> id = <span class="built_in">this</span>.callbackId++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储订阅者的回调函数</span></span><br><span class="line">        <span class="comment">// callbackId使用后需要自增，供下一个回调函数使用</span></span><br><span class="line">        <span class="built_in">this</span>.eventObject[eventName][id] = callback;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一次订阅事件，都生成唯一一个取消订阅的函数</span></span><br><span class="line">        <span class="keyword">const</span> unSubscribe = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 清除这个订阅者的回调函数</span></span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.eventObject[eventName][id];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果这个事件没有订阅者了，也把整个事件对象清除</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.eventObject[eventName]).length === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="built_in">this</span>.eventObject[eventName];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123; unSubscribe &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只订阅一次</span></span><br><span class="line">    <span class="function"><span class="title">subscribeOnce</span>(<span class="params">eventName, callback</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化这个事件</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.eventObject[eventName]) &#123;</span><br><span class="line">            <span class="comment">// 使用对象存储，注销回调函数的时候提高删除的效率</span></span><br><span class="line">            <span class="built_in">this</span>.eventObject[eventName] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标示为只订阅一次的回调函数</span></span><br><span class="line">        <span class="keyword">const</span> id = <span class="string">&quot;d&quot;</span> + <span class="built_in">this</span>.callbackId++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储订阅者的回调函数</span></span><br><span class="line">        <span class="comment">// callbackId使用后需要自增，供下一个回调函数使用</span></span><br><span class="line">        <span class="built_in">this</span>.eventObject[eventName][id] = callback;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一次订阅事件，都生成唯一一个取消订阅的函数</span></span><br><span class="line">        <span class="keyword">const</span> unSubscribe = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 清除这个订阅者的回调函数</span></span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.eventObject[eventName][id];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果这个事件没有订阅者了，也把整个事件对象清除</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.eventObject[eventName]).length === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="built_in">this</span>.eventObject[eventName];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123; unSubscribe &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除事件</span></span><br><span class="line">    <span class="function"><span class="title">clear</span>(<span class="params">eventName</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 未提供事件名称，默认清除所有事件</span></span><br><span class="line">        <span class="keyword">if</span> (!eventName) &#123;</span><br><span class="line">            <span class="built_in">this</span>.eventObject = &#123;&#125;;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清除指定事件</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.eventObject[eventName];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> eventBus = <span class="keyword">new</span> EventBus();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件eventX</span></span><br><span class="line">eventBus.subscribe(<span class="string">&quot;eventX&quot;</span>, <span class="function">(<span class="params">obj, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;模块A&quot;</span>, obj, num);</span><br><span class="line">&#125;);</span><br><span class="line">eventBus.subscribe(<span class="string">&quot;eventX&quot;</span>, <span class="function">(<span class="params">obj, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;模块B&quot;</span>, obj, num);</span><br><span class="line">&#125;);</span><br><span class="line">eventBus.subscribe(<span class="string">&quot;eventX&quot;</span>, <span class="function">(<span class="params">obj, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;模块C&quot;</span>, obj, num);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件eventX</span></span><br><span class="line">eventBus.publish(<span class="string">&quot;eventX&quot;</span>, &#123; <span class="attr">msg</span>: <span class="string">&quot;EventX published!&quot;</span> &#125;, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除</span></span><br><span class="line">eventBus.clear(<span class="string">&quot;eventX&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次发布事件eventX，由于已经清除，所有模块都不会再收到消息了</span></span><br><span class="line">eventBus.publish(<span class="string">&quot;eventX&quot;</span>, &#123; <span class="attr">msg</span>: <span class="string">&quot;EventX published again!&quot;</span> &#125;, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="手写实现-1-add-2-add-3-★"><a href="#手写实现-1-add-2-add-3-★" class="headerlink" title="手写实现(1).add(2).add(3) ★"></a>手写实现(1).add(2).add(3) ★</h2><blockquote><p>考察公司：百度</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.add =<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>+n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><h2 id="Object-create-1"><a href="#Object-create-1" class="headerlink" title="Object.create()"></a>Object.create()</h2><p>**<code>Object.create()</code>**方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</p><table><thead><tr><th>比较</th><th>new</th><th>Object.create</th></tr></thead><tbody><tr><td>构造函数</td><td>保留原构造函数属性</td><td>丢失原构造函数属性</td></tr><tr><td>原型链</td><td>原构造函数prototype属性</td><td>原构造函数/（对象）本身</td></tr><tr><td>作用对象</td><td>function</td><td>function和object</td></tr></tbody></table><p>利用一个<strong>空对象</strong>作为中介，将<strong>某个对象直接赋值给空对象构造函数的原型</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype=obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">    <span class="comment">// let o=&#123;&#125;;</span></span><br><span class="line">    <span class="comment">// o.__proto__=obj;</span></span><br><span class="line">    <span class="comment">// return o;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a=&#123;<span class="attr">b</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> c=create(a);</span><br><span class="line"><span class="built_in">console</span>.log(c.b)</span><br></pre></td></tr></table></figure><p>object()对传入其中的对象执行了一次<code>浅复制</code>，<strong>将构造函数F的原型直接指向传入的对象</strong>。</p><h2 id="instanceof-1"><a href="#instanceof-1" class="headerlink" title="instanceof"></a>instanceof</h2><ol><li><strong><code>instanceof</code></strong> <strong>是一个运算符</strong></li><li><code>instanceof</code> 判断<strong>对象的原型链上是否存在构造函数的原型</strong>。只能判断引用类型。</li><li><code>instanceof</code> 常用来判断 <code>A</code> 是否为 <code>B</code> 的实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance_of</span>(<span class="params">Case,Con</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 基本数据类型返回false，兼容一下函数</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">typeof</span> Case !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> Case !== <span class="string">&#x27;function&#x27;</span>) || Case ===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> CaseProto = <span class="built_in">Object</span>.getPrototypeOf(Case);<span class="comment">//返回指定对象的原型</span></span><br><span class="line">    <span class="comment">// let CaseProto = Case.__proto__;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(CaseProto === <span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 查到原型链顶端，仍未查到，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(CaseProto === Con.prototype)<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到相同的原型</span></span><br><span class="line">        CaseProto=<span class="built_in">Object</span>.getPrototypeOf(CaseProto);</span><br><span class="line">        <span class="comment">// CaseProto = CaseProto.__proto__;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a=&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(instance_of(<span class="built_in">Object</span>,<span class="built_in">Function</span>));<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance_of(<span class="built_in">Function</span>,<span class="built_in">Object</span>));<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance_of(a,<span class="built_in">Object</span>));<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance_of(<span class="literal">null</span>,<span class="built_in">Object</span>));<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如何获取到一个实例对象的原型对象？</p><ul><li>从 <code>构造函数</code> 获得原型对象：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造函数.prototype</span><br></pre></td></tr></table></figure><ul><li>从 <code>对象实例</code> 获得 <code>父级原型对象</code>：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法一：对象实例.__proto__        【 有兼容性问题，不建议使用】</span><br><span class="line">方法二：<span class="built_in">Object</span>.getPrototypeOf( 对象实例 )</span><br></pre></td></tr></table></figure><h2 id="树的遍历查看祖先节点"><a href="#树的遍历查看祖先节点" class="headerlink" title="树的遍历查看祖先节点"></a>树的遍历查看祖先节点</h2><p>树的全部展开操作，一般需要获取到所有的树的组件节点key</p><h3 id="树的数据结构"><a href="#树的数据结构" class="headerlink" title="树的数据结构"></a>树的数据结构</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface TNode &#123;</span><br><span class="line">  title: string;</span><br><span class="line">  key: number;</span><br><span class="line">  children: TNode[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看所有的父节点"><a href="#查看所有的父节点" class="headerlink" title="查看所有的父节点"></a>查看所有的父节点</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAllParentKeys</span>(<span class="params"><span class="keyword">list</span>: TNode[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> keys: number[] = [];</span><br><span class="line">  <span class="keyword">list</span>.<span class="keyword">forEach</span>((&#123; key, children &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      keys.push(key, ...getAllParentKeys(children));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找某个指定节点的所有祖先节点"><a href="#查找某个指定节点的所有祖先节点" class="headerlink" title="查找某个指定节点的所有祖先节点"></a>查找某个指定节点的所有祖先节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 找到某个节点的所有祖先节点</span><br><span class="line">function findParentKeys(list: TNode[], childKey: number) &#123;</span><br><span class="line">  const resultKey: number[] = [];</span><br><span class="line">  canFindKey(list, childKey, resultKey);</span><br><span class="line">  return resultKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function canFindKey(list: TNode[], childKey: number, result: number[]) &#123;</span><br><span class="line">  let canFind = false;</span><br><span class="line"> // 这里的遍历需要注意！使用some return true可以跳出some循环</span><br><span class="line">// 如果使用forEach return只能跳出当前循环，但是不能终止forEach，可以使用try catch终止</span><br><span class="line">  list.some((&#123; key, children &#125;) =&gt; &#123;</span><br><span class="line">    if (key === childKey) &#123;</span><br><span class="line">      canFind = true;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (children.length &gt; 0) &#123;</span><br><span class="line">      result.push(key);</span><br><span class="line">      canFind = canFindKey(children, childKey, result);</span><br><span class="line">      if (canFind) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">      result.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;);</span><br><span class="line">  return canFind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="React★"><a href="#React★" class="headerlink" title="React★"></a>React★</h1><blockquote><p>考察公司：字节、美团、腾讯、百度、华为、完美世界、小米</p></blockquote><h2 id="框架好处"><a href="#框架好处" class="headerlink" title="框架好处"></a>框架好处</h2><ol><li><strong>组件化</strong>: 其中以 React 的组件化最为彻底,甚至可以到<strong>函数级</strong>别的原子组件,高度的组件化可以是我们的工程<strong>易于维护、易于组合拓展</strong>。</li><li><strong>天然分层</strong>: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。</li><li><strong>生态</strong>: 现在主流前端框架都<strong>自带生态</strong>,不管是<strong>数据流管理架构</strong>还是 <strong>UI 库</strong>都有成熟的解决方案。</li><li><strong>开发效率</strong>: 现代前端框架都默认<strong>自动更新DOM</strong>,而非我们手动操作,解放了开发者的手动DOM成本,提高开发效率,从根本上解决了UI 与状态同步问题。</li></ol><p>常见框架：<strong>Angular React Vue Svelte</strong></p><h2 id="React-vs-Vue-★"><a href="#React-vs-Vue-★" class="headerlink" title="React vs Vue ★"></a>React vs Vue ★</h2><p><strong>设计理念不同</strong></p><ul><li>react整体上是<strong>函数式编程</strong>思想，组件使用<code>jsx</code>语法，all in js，将html与css全都融入javaScript中，jsx语法相对来说更加灵活。</li><li>vue的整体思想，是拥抱经典的<code>html(结构)+css(表现)+js(行为)</code>的形式，使用template模板，并提供指令供开发者使用，如v-if、v-show、v-for等，开发时有结构、表现、行为分离的感觉。</li></ul><p><strong>数据是否可变</strong></p><ul><li>vue的思想是<strong>响应式</strong>的，通过<code>Object.defineproperty</code>或<code>proxy</code>代理实现数据监听，每一个属性添加一个<code>dep</code>对象（用来存储对应的<code>watcher</code>），当属性变化的时候，通知对应的<code>watcher</code>发生改变。</li><li>react推崇的是<strong>数据不可变</strong>，react使用的是<strong>浅比较</strong>，如果对象和数据的引用地址没有变，react认为该对象没有变化，所以react变化时一般都是新创建一个对象。</li></ul><p><strong>更新渲染方式不同</strong></p><ul><li>当组件的状态发生变化时，vue是响应式，通过对应的watcher自动找到对应的组件重新渲染。</li><li>react需要更新组件时，会重新走渲染的流程，通过从根节点开始遍历，dom diff找到需要变更的节点，更新任务还是很大，需要使用到 Fiber，将大任务分割为多个小任务，可以中断和恢复，不阻塞主进程执行高优先级的任务。</li></ul><p><strong>各自的优势不同</strong></p><ul><li>vue的优势包括：框架内部封装的多，更容易上手，简单的语法及项目创建， 更快的渲染速度和更小的体积。</li><li>react的优势包括： react更灵活，更接近原生的js、可操控性强，对于能力强的人，更容易造出更个性化的项目。</li></ul><p><strong>React优势</strong></p><ul><li><strong>灵活的结构和可扩展性</strong>。</li><li><strong>丰富的JavaScript库</strong>。</li><li>发展： React得到了<code>Facebook</code>专业开发人员的支持，他们不断寻找改进方法。</li><li>Web或移动平台： React提供<code>React Native</code>平台，可通过相同的React组件模型为<code>iOS</code>和<code>Android</code>开发本机呈现的应用程序。</li></ul><p><code>react</code>在中后台项目中由于在<strong>处理复杂的业务逻辑或组件的复用问题</strong>比<code>vue</code>优雅而被人认可，但这种优雅是要有成本代价的，它更需要团队技术整体比较给力，领头大佬的设计与把关能力要更优秀，因此开发成本更大。</p><p><code>vue</code><strong>更友好更易上手</strong>的写法著称，渐进式的框架、更友好的api、更亲民的设计让开发成本大大下降而效率大大提升。</p><p><code>vue</code>与<code>react</code>在发展长河中越发成熟，深思熟虑后觉得<strong>两者不管在移动端或大型中后台都是非常可行的</strong>，其实框架本无好坏之分，我们更应该思考的是团队想要用什么技术栈、自己喜欢与擅长什么技术栈。</p><h2 id="immutable"><a href="#immutable" class="headerlink" title="immutable"></a>immutable</h2><p>Immutable，不可改变的，在计算机中，即指一旦创建，就不能再被更改的数据。</p><p>对 <code>Immutable</code>对象的任何修改或添加删除操作都会返回一个新的 <code>Immutable</code>对象。</p><p><code>Immutable</code> 实现的原理是 <code>Persistent Data Structure</code>（持久化数据结构）:</p><ul><li>用一种数据结构来保存数据。</li><li>当数据被修改时，会返回一个对象，但是新的对象会尽可能的利用之前的数据结构而不会对内存造成浪费。</li></ul><p>也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变，同时为了避免 <code>deepCopy</code>把所有节点都复制一遍带来的性能损耗，<code>Immutable</code> 使用了 <code>Structural Sharing</code>（结构共享）。</p><p><strong>如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</strong></p><h3 id="immutable-js"><a href="#immutable-js" class="headerlink" title="immutable.js"></a>immutable.js</h3><p>使用<code>Immutable</code>对象最主要的库是<code>immutable.js</code></p><p>immutable.js 是一个完全独立的库，无论基于什么框架都可以用它</p><p>其出现场景在于弥补 Javascript 没有不可变数据结构的问题，通过 structural sharing来解决的性能问题</p><p>内部提供了一套完整的 Persistent Data Structure，还有很多易用的数据类型，如<code>Collection</code>、<code>List</code>、<code>Map</code>、<code>Set</code>、<code>Record</code>、<code>Seq</code>，其中：</p><ul><li>List: 有序索引集，类似 JavaScript 中的 Array</li><li>Map: 无序索引集，类似 JavaScript 中的 Object</li><li>Set: 没有重复值的集合</li></ul><p>主要的方法如下：</p><ul><li>fromJS()：将一个js数据转换为Immutable类型的数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1<span class="keyword">const</span> obj = Immutable.fromJS(&#123;<span class="attr">a</span>:<span class="string">&#x27;123&#x27;</span>,<span class="attr">b</span>:<span class="string">&#x27;234&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>toJS()：将一个Immutable数据转换为JS类型的数据</li><li>is()：对两个对象进行比较</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="built_in">Map</span>, is &#125; <span class="keyword">from</span> <span class="string">&#x27;immutable&#x27;</span></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="built_in">Map</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">1</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> map2 = <span class="built_in">Map</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">1</span> &#125;)</span><br><span class="line">map1 === map2   <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Object</span>.is(map1, map2) <span class="comment">// false</span></span><br><span class="line">is(map1, map2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>get(key)：对数据或对象取值</li><li>getIn([]) ：对嵌套对象或数组取值，传参为数组，表示位置</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> abs = Immutable.fromJS(&#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>:<span class="number">2</span>&#125;&#125;);</span><br><span class="line">abs.getIn([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]) <span class="comment">// 2</span></span><br><span class="line">abs.getIn([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]) <span class="comment">// 子级没有值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = Immutable.fromJS([<span class="number">1</span> ,<span class="number">2</span>, <span class="number">3</span>, &#123;<span class="attr">a</span>: <span class="number">5</span>&#125;]);</span><br><span class="line">arr.getIn([<span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>]); <span class="comment">// 5</span></span><br><span class="line">arr.getIn([<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>]); <span class="comment">// 子级没有值</span></span><br></pre></td></tr></table></figure><ul><li>setIn([],value) ：对嵌套对象或数组取值，传参为数组，表示位置如下例子：使用方法如下：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Immutable <span class="keyword">from</span> <span class="string">&#x27;immutable&#x27;</span>;</span><br><span class="line">foo = Immutable.fromJS(&#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;);</span><br><span class="line">bar = foo.setIn([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], <span class="number">2</span>);   <span class="comment">// 使用 setIn 赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getIn([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]));  <span class="comment">// 使用 getIn 取值，打印 1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo === bar);  <span class="comment">//  打印 false</span></span><br></pre></td></tr></table></figure><h3 id="在React中应用"><a href="#在React中应用" class="headerlink" title="在React中应用"></a>在React中应用</h3><p>使用 <code>Immutable</code>可以给 <code>React</code> 应用带来性能的优化，主要体现在减少渲染的次数。</p><p>在做<code>react</code>性能优化的时候，为了避免重复渲染，我们会在<code>shouldComponentUpdate()</code>中做对比，当返回<code>true</code>执行<code>render</code>方法。</p><p><code>Immutable</code>通过<code>is</code>方法则可以完成对比，而无需像一样通过深度比较的方式比较。</p><h2 id="函数式编程-★"><a href="#函数式编程-★" class="headerlink" title="函数式编程 ★"></a>函数式编程 ★</h2><p>根据学术上函数的定义，函数即是一种描述集合和集合之间的转换关系，输入通过函数都会返回有且只有一个输出值。</p><p>所以，函数实际上是一个关系，或者说是一种映射，而这种映射关系是可以组合的，一旦我们知道一个函数的输出类型可以匹配另一个函数的输入，那他们就可以进行组合。</p><p>在编程世界中，我们需要处理的其实也只有数据和关系，而关系就是函数。</p><p>我们所谓的编程工作也不过就是在找一种映射关系，一旦关系找到了，问题就解决了，剩下的事情，就是让数据流过这种关系，然后转换成另一个数据罢了。</p><p>这其实就是一种类似于流水线的工作，把输入当做原料，把输出当做产品，数据可以不断的从一个函数的输出可以流入另一个函数输入，最后再输出结果。</p><p>所以通过这里就可以理解函数式编程其实就是强调在编程过程中把更多的关注点放在如何去构建关系，通过构建一条高效的建流水线，一次解决所有问题，而不是把精力分散在不同的加工厂中来回奔波传递数据。</p><h3 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h3><p>函数是一等公民<code>First-Class Functions</code>，这是函数式编程得以实现的前提，因为我们基本的操作都是在操作函数。</p><p>这个特性意味着函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p><h3 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h3><p>声明式编程<code>Declarative Programming</code>，大多时候都是在声明我需要做什么，而非怎么去做，这种编程风格称为声明式编程。</p><p>这样有个好处是代码的可读性特别高，因为声明式代码大多都是接近自然语言的，同时它解放了大量的人力，因为它不关心具体的实现，因此它可以把优化能力交给具体的实现，这也方便我们进行分工协作。</p><p><code>SQL</code>语句就是声明式的，你无需关心<code>Select</code>语句是如何实现的，不同的数据库会去实现它自己的方法并且优化。</p><p><code>React</code>也是声明式的，你只要描述你的<code>UI</code>，接下来状态变化后<code>UI</code>如何更新，是<code>React</code>在运行时帮你处理的，而不是靠你自己去渲染和优化<code>diff</code>算法。</p><h3 id="无状态和数据不可变"><a href="#无状态和数据不可变" class="headerlink" title="无状态和数据不可变"></a>无状态和数据不可变</h3><p>无状态和数据不可变<code>Statelessness and Immutable data</code>，是函数式编程的核心概念，为了实现这个目标，函数式编程提出函数应该具备的特性，没有副作用和纯函数。</p><ul><li>数据不可变： <strong>它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象</strong>。</li><li>无状态： 主要是强调<strong>对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化</strong>。</li></ul><h3 id="没有副作用"><a href="#没有副作用" class="headerlink" title="没有副作用"></a>没有副作用</h3><p>没有副作用<code>No Side Effects</code>，是指在完成函数主要功能之外完成的其他副要功能。</p><p>在我们函数中最主要的功能当然是根据输入返回结果，而在函数中我们最常见的副作用就是随意操纵外部变量。</p><p>由于<code>Js</code>中对象传递的是引用地址，哪怕我们用<code>const</code>关键词声明对象，它依旧是可以变的。</p><p>保证函数没有副作用，一来能保证数据的不可变性，二来能避免很多因为共享状态带来的问题。</p><p>当你一个人维护代码时候可能还不明显，但随着项目的迭代，项目参与人数增加，大家对同一变量的依赖和引用越来越多，这种问题会越来越严重，最终可能连维护者自己都不清楚变量到底是在哪里被改变而产生<code>Bug</code>。</p><p>传递引用一时爽，代码重构火葬场。</p><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>纯函数<code>pure functions</code>，纯函数算是在没有副作用的要求上再进一步了。</p><p>在<code>Redux</code>的三大原则中，我们看到它要求所有的修改必须使用纯函数，纯函数才是真正意义上的函数，它意味着相同的输入，永远会得到相同的输出，其实纯函数的概念很简单就是两点：</p><ul><li>不依赖外部状态(无状态)：函数的的运行结果不依赖全局变量，<code>this</code>指针、<code>IO</code>操作等。</li><li>没有副作用(数据不变)：不修改全局变量，不修改入参。</li></ul><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>Create React App是一个用于<strong>学习 React</strong> 的舒适环境，也是用 React 创建<strong>新的单页应用</strong>的最佳方式。</p><p>它会配置你的开发环境，以便使你能够使用最新的 JavaScript 特性，提供良好的开发体验，并为生产环境优化你的应用程序。你需要在你的机器上安装 Node &gt;= 14.0.0 和 npm &gt;= 5.6。要创建项目，请执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>第一行的 <code>npx</code> 不是拼写错误 —— 它是 npm 5.2+ 附带的 package 运行工具。</p><ul><li><code>npx</code>侧重于执行命令的，执行某个模块命令。虽然会自动安装模块，但是重在执行某个命令；非常智能的识别模块，如果模块存在，就使用。如果不存在，就临时下载，用完就删除，使用某个<code>node</code>模块的时候，根本不用关心是否安装过了。<code>npx</code>会给你最满意的答案（没有对应模块就临时下载）。</li><li><code>npm</code>侧重于安装或者卸载某个模块的。重在安装，并不具备执行某个模块的功能。</li></ul></blockquote><p>Create React App 不会处理后端逻辑或操纵数据库；它只是创建一个前端构建流水线（build pipeline），所以你可以使用它来配合任何你想使用的后端。它在内部使用 Babel 和 webpack，但你无需了解它们的任何细节。</p><p>当你准备好部署到生产环境时，执行 <code>npm run build</code> 会在 <code>build</code> 文件夹内生成你应用的优化版本。</p><p><code>Next.js</code>是一个流行的、轻量级的框架，用于配合 React 打造<strong>静态化和服务端渲染应用</strong>。它包括开箱即用的<strong>样式和路由方案</strong>，并且假定你使用 Node.js作为服务器环境。</p><h2 id="设计-★"><a href="#设计-★" class="headerlink" title="设计 ★"></a>设计 ★</h2><h3 id="将设计好的-UI-划分为组件层级"><a href="#将设计好的-UI-划分为组件层级" class="headerlink" title="将设计好的 UI 划分为组件层级"></a>将设计好的 UI 划分为组件层级</h3><p>首先，你需要在设计稿上用方框圈出每一个组件（包括它们的子组件），并且以合适的名称命名。</p><p>但你如何确定应该将哪些部分划分到一个组件中呢？</p><p>你可以将组件当作一种函数或者是对象来考虑，根据<strong>单一功能原则</strong>来判定组件的范围。也就是说，一个组件原则上只能负责一个功能。</p><p>如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。</p><p>在实践中，因为你经常是在向用户展示 JSON 数据模型，所以如果你的模型设计得恰当，UI（或者说组件结构）便会与数据模型一一对应，这是因为 UI 和数据模型都会倾向于遵守相同的<em>信息结构</em>。</p><p>将 UI 分离为组件，其中每个组件需与数据模型的某部分匹配。</p><h3 id="用-React-创建一个静态版本"><a href="#用-React-创建一个静态版本" class="headerlink" title="用 React 创建一个静态版本"></a>用 React 创建一个静态版本</h3><p>现在我们已经确定了组件层级，可以编写对应的应用了。</p><p>最容易的方式，是先用已有的数据模型渲染一个不包含交互功能的 UI。</p><p>最好将渲染 UI 和添加交互这两个过程分开。</p><p>这是因为，编写一个应用的静态版本时，往往要编写大量代码，而不需要考虑太多交互细节；添加交互功能时则要考虑大量细节，而不需要编写太多代码。所以，将这两个过程分开进行更为合适。我们会在接下来的代码中体会到其中的区别。</p><p>在构建应用的静态版本时，我们需要创建一些会重用其他组件的组件，然后通过 <em>props</em> 传入所需的数据。</p><p><em>props</em> 是父组件向子组件传递数据的方式。即使你已经熟悉了 <em>state</em> 的概念，也<strong>完全不应该使用 state</strong> 构建静态版本。</p><p>state 代表了随时间会产生变化的数据，<strong>应当仅在实现交互时使用</strong>。所以构建应用的静态版本时，你不会用到它。</p><p>你可以自上而下或者自下而上构建应用：自上而下意味着首先编写层级较高的组件，自下而上意味着从最基本的组件开始编写。当你的应用比较简单时，使用自上而下的方式更方便；<strong>对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式</strong>。</p><p>到此为止，你应该已经有了一个可重用的组件库来渲染你的数据模型。由于我们构建的是静态版本，所以这些组件目前只需提供 <code>render()</code> 方法用于渲染。最顶层的组件通过 props 接受你的数据模型。如果你的数据模型发生了改变，再次调用 <code>root.render()</code>，UI 就会相应地被更新。数据模型变化、调用 <code>render()</code> 方法、UI 相应变化，这个过程并不复杂，因此很容易看清楚 UI 是如何被更新的，以及是在哪里被更新的。React <strong>单向数据流</strong>（也叫<em>单向绑定</em>）的思想使得组件模块化，易于快速开发。</p><h3 id="确定-UI-state-的最小（且完整）表示"><a href="#确定-UI-state-的最小（且完整）表示" class="headerlink" title="确定 UI state 的最小（且完整）表示"></a>确定 UI state 的最小（且完整）表示</h3><p>想要使你的 UI 具备交互功能，需要有触发基础数据模型改变的能力。React 通过实现 <strong>state</strong> 来完成这个任务。</p><p>为了正确地构建应用，你首先需要找出应用所需的 state 的最小表示，并根据需要计算出其他所有数据。</p><p>其中的关键正是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY: <em>Don’t Repeat Yourself</em></a>。</p><p>只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生。比如，你要编写一个任务清单应用，你只需要保存一个包含所有事项的数组，而无需额外保存一个单独的 state 变量（用于存储任务个数）。当你需要展示任务个数时，只需要利用该数组的 length 属性即可。</p><p>通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：</p><ol><li>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。</li><li>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。</li><li>你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。</li></ol><h3 id="确定-state-放置的位置"><a href="#确定-state-放置的位置" class="headerlink" title="确定 state 放置的位置"></a>确定 state 放置的位置</h3><p>我们已经确定了应用所需的 state 的最小集合。接下来，我们需要确定哪个组件能够改变这些 state，或者说<em>拥有</em>这些 state。</p><p>注意：React 中的数据流是单向的，并顺着组件层级从上往下传递。哪个组件应该拥有某个 state 这件事，<strong>对初学者来说往往是最难理解的部分</strong>。尽管这可能在一开始不是那么清晰，但你可以尝试通过以下步骤来判断：</p><p>对于应用中的每一个 state：</p><ul><li>找到根据这个 state 进行渲染的所有组件。</li><li>找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。</li><li>该共同所有者组件或者比它层级更高的组件应该拥有该 state。</li><li>如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。</li></ul><h3 id="添加反向数据流"><a href="#添加反向数据流" class="headerlink" title="添加反向数据流"></a>添加反向数据流</h3><p>到目前为止，我们已经借助自上而下传递的 props 和 state 渲染了一个应用。</p><p>现在，我们将尝试让数据反向传递：处于较低层级的表单组件更新较高层级的中的 state。</p><p>React 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递。</p><p>尽管如此，但这种需要显式声明的方法更有助于人们理解程序的运作方式。</p><h2 id="语义化的-HTML"><a href="#语义化的-HTML" class="headerlink" title="语义化的 HTML"></a>语义化的 HTML</h2><p>有时，语义化的 HTML 会被破坏。比如当在 JSX 中使用 <code>&lt;div&gt;</code> 元素来实现 React 代码功能的时候，又或是在使用列表（<code>&lt;ol&gt;</code>， <code>&lt;ul&gt;</code> 和 <code>&lt;dl&gt;</code>）和 HTML <code>&lt;table&gt;</code> 时。 在这种情况下，我们应该使用 <code>React Fragments</code>来组合各个组件。</p><p><code>key</code> 是唯一可以传递给 <code>Fragment</code> 的属性。</p><p>当你不需要在 fragment 标签中添加任何 prop 且你的工具支持的时候，你可以使用短语法：<code>&lt;&gt;&lt;/&gt;</code></p><h2 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h2><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>大多数 React 应用都会使用 <a target="_blank" rel="noopener" href="https://webpack.docschina.org/">Webpack</a>，<a target="_blank" rel="noopener" href="https://rollupjs.org/">Rollup</a> 或 <a target="_blank" rel="noopener" href="http://browserify.org/">Browserify</a> 这类的构建工具来打包文件。打包是一个将文件引入并合并到一个单独文件的过程，最终形成一个 “bundle”。接着在页面上引入该 bundle，整个应用即可一次性加载。</p><h3 id="代码分割-1"><a href="#代码分割-1" class="headerlink" title="代码分割"></a>代码分割</h3><p>打包是个非常棒的技术，但随着你的应用增长，你的代码包也将随之增长。尤其是在整合了体积巨大的第三方库的情况下。你需要关注你代码包中所包含的代码，以避免因体积过大而导致加载时间过长。</p><p>为了避免搞出大体积的代码包，在前期就思考该问题并对代码包进行分割是个不错的选择。 代码分割是由诸如 <a target="_blank" rel="noopener" href="https://webpack.docschina.org/guides/code-splitting/">Webpack</a>，<a target="_blank" rel="noopener" href="https://rollupjs.org/guide/en/#code-splitting">Rollup</a> 和 Browserify（<a target="_blank" rel="noopener" href="https://github.com/browserify/factor-bundle">factor-bundle</a>）这类打包器支持的一项技术，能够创建多个包并在运行时动态加载。</p><p>对你的应用进行代码分割能够帮助你“懒加载”当前用户所需要的内容，能够显著地提高你的应用性能。</p><p>尽管并没有减少应用整体的代码体积，但你可以避免加载用户永远不需要的代码，并在初始加载的时候减少所需加载的代码量。</p><h3 id="import"><a href="#import" class="headerlink" title="import()"></a><code>import()</code></h3><p>在你的应用中引入代码分割的最佳方式是通过动态 <code>import()</code> 语法。</p><p><strong>使用之前：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">16</span>, <span class="number">26</span>));</span><br></pre></td></tr></table></figure><p><strong>使用之后：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./math&quot;</span>).then(<span class="function"><span class="params">math</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(math.add(<span class="number">16</span>, <span class="number">26</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当 Webpack 解析到该语法时，会自动进行代码分割。如果你使用 Create React App，该功能已开箱即用，你可以立刻使用该特性。<a target="_blank" rel="noopener" href="https://nextjs.org/docs/advanced-features/dynamic-import">Next.js</a> 也已支持该特性而无需进行配置。</p><p>如果你自己配置 Webpack，你可能要阅读下 Webpack 关于<a target="_blank" rel="noopener" href="https://webpack.docschina.org/guides/code-splitting/">代码分割</a>的指南。你的 Webpack 配置应该<a target="_blank" rel="noopener" href="https://gist.github.com/gaearon/ca6e803f5c604d37468b0091d9959269">类似于此</a>。</p><p>当使用 <a target="_blank" rel="noopener" href="https://babeljs.io/">Babel</a> 时，你要确保 Babel 能够解析动态 import 语法而不是将其进行转换。对于这一要求你需要 <a target="_blank" rel="noopener" href="https://classic.yarnpkg.com/en/package/@babel/plugin-syntax-dynamic-import">@babel/plugin-syntax-dynamic-import</a> 插件。</p><h3 id="React-lazy"><a href="#React-lazy" class="headerlink" title="React.lazy"></a><code>React.lazy</code></h3><p><code>React.lazy</code> 函数能让你像渲染常规组件一样处理动态引入（的组件）。</p><p><strong>使用之前：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> OtherComponent <span class="keyword">from</span> <span class="string">&#x27;./OtherComponent&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>使用之后：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./OtherComponent&#x27;</span>));</span><br></pre></td></tr></table></figure><p>此代码将会在组件首次渲染时，自动导入包含 <code>OtherComponent</code> 组件的包。</p><p><code>React.lazy</code> 接受一个函数，这个函数需要动态调用 <code>import()</code>。它必须返回一个 <code>Promise</code>，该 Promise 需要 resolve 一个 <code>default</code> export 的 React 组件。</p><p>然后应在 <code>Suspense</code> 组件中渲染 lazy 组件，如此使得我们可以使用在等待加载 lazy 组件时做优雅降级（如 loading 指示器等）。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Suspense &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./OtherComponent&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">OtherComponent</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fallback</code> 属性接受任何在组件加载过程中你想展示的 React 元素。你可以将 <code>Suspense</code> 组件置于懒加载组件之上的任何位置。你甚至可以用一个 <code>Suspense</code> 组件包裹多个懒加载组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Suspense &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./OtherComponent&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> AnotherComponent = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./AnotherComponent&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">OtherComponent</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">AnotherComponent</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免兜底"><a href="#避免兜底" class="headerlink" title="避免兜底"></a>避免兜底</h3><p>任何组件都可能因渲染而暂停，甚至是已经展示给用户的组件。为了使屏幕内容始终一致，如果一个已经显示的组件暂停，React 必须隐藏它的树，直到最近的 <code>&lt;Suspense&gt;</code> 边界。然而，从用户的角度来看，这可能会使人很困惑。</p><p>参考这个标签切换的示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Suspense &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Tabs <span class="keyword">from</span> <span class="string">&#x27;./Tabs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Glimmer <span class="keyword">from</span> <span class="string">&#x27;./Glimmer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Comments = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./Comments&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> Photos = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./Photos&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [tab, setTab] = React.useState(<span class="string">&#x27;photos&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleTabSelect</span>(<span class="params">tab</span>) </span>&#123;</span><br><span class="line">    setTab(tab);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Tabs</span> <span class="attr">onTabSelect</span>=<span class="string">&#123;handleTabSelect&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">Glimmer</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">        &#123;tab === &#x27;photos&#x27; ? <span class="tag">&lt;<span class="name">Photos</span> /&gt;</span> : <span class="tag">&lt;<span class="name">Comments</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，如果标签从 <code>&#39;photos&#39;</code> 切换为 <code>&#39;comments&#39;</code>，但 <code>Comments</code> 会暂停，用户会看到屏幕闪烁。这符合常理，因为用户不想看到 <code>&#39;photos&#39;</code>，而 <code>Comments</code> 组件还没有准备好渲染其内容，而 React 为了保证用户体验的一致性，只能显示上面的 <code>Glimmer</code>，别无选择。</p><p>然而，有时这种用户体验并不可取。特别是在准备新 UI 时，展示 “旧” 的 UI 会体验更好。你可以尝试使用新的 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/react-api.html#starttransition"><code>startTransition</code></a> API 来让 React 实现这一点：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleTabSelect</span>(<span class="params">tab</span>) </span>&#123;</span><br><span class="line">  startTransition(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setTab(tab);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处代码会告知 React，将标签切换为 <code>&#39;comments&#39;</code> 不会标记为紧急更新，而是标记为需要一些准备时间的 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/react-api.html#transitions">transition</a>。然后 React 会保留旧的 UI 并进行交互，当它准备好时，会切换为 <code>&lt;Comments /&gt;</code>。</p><h3 id="异常捕获边界（Error-boundaries）"><a href="#异常捕获边界（Error-boundaries）" class="headerlink" title="异常捕获边界（Error boundaries）"></a>异常捕获边界（Error boundaries）</h3><p>如果模块加载失败（如网络问题），它会触发一个错误。你可以通过<strong>异常捕获边界（Error boundaries）</strong>技术来处理这些情况，以显示良好的用户体验并管理恢复事宜。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Suspense &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> MyErrorBoundary <span class="keyword">from</span> <span class="string">&#x27;./MyErrorBoundary&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./OtherComponent&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> AnotherComponent = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./AnotherComponent&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">() =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">MyErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">OtherComponent</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">AnotherComponent</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">MyErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="基于路由的代码分割"><a href="#基于路由的代码分割" class="headerlink" title="基于路由的代码分割"></a>基于路由的代码分割</h3><p>决定在哪引入代码分割需要一些技巧。你需要确保选择的位置能够均匀地分割代码包而不会影响用户体验。</p><p>一个不错的选择是从路由开始。大多数网络用户习惯于页面之间能有个加载切换过程。你也可以选择重新渲染整个页面，这样您的用户就不必在渲染的同时再和页面上的其他元素进行交互。</p><p>这里是一个例子，展示如何在你的应用中使用 <code>React.lazy</code> 和 <a target="_blank" rel="noopener" href="https://reactrouter.com/">React Router</a> 这类的第三方库，来配置基于路由的代码分割。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Suspense, lazy &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Routes, Route &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./routes/Home&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> About = lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./routes/About&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="命名导出（Named-Exports）"><a href="#命名导出（Named-Exports）" class="headerlink" title="命名导出（Named Exports）"></a>命名导出（Named Exports）</h3><p><code>React.lazy</code> 目前只支持默认导出（<code>default exports</code>）。如果你想被引入的模块使用命名导出（named exports），你可以创建一个中间模块，来重新导出为默认模块。这能保证 tree shaking 不会出错，并且不必引入不需要的组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ManyComponents.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MyComponent = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MyUnusedComponent = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="comment">// MyComponent.js</span></span><br><span class="line"><span class="keyword">export</span> &#123; MyComponent <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./ManyComponents.js&quot;</span>;</span><br><span class="line"><span class="comment">// MyApp.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; lazy &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> MyComponent = lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./MyComponent.js&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p><p>在一个典型的 React 应用中，数据是通过 props 属性自上而下（由父及子）进行传递的，但此种用法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI 主题），这些属性是应用程序中许多组件都需要的。Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</p><h3 id="何时使用-Context"><a href="#何时使用-Context" class="headerlink" title="何时使用 Context"></a>何时使用 Context</h3><p>Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。举个例子，在下面的代码中，我们通过一个 “theme” 属性手动调整一个按钮组件的样式：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Toolbar</span> <span class="attr">theme</span>=<span class="string">&quot;dark&quot;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toolbar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Toolbar 组件接受一个额外的“theme”属性，然后传递给 ThemedButton 组件。  </span></span><br><span class="line">    <span class="comment">// 如果应用中每一个单独的按钮都需要知道 theme 的值，这会是件很麻烦的事， </span></span><br><span class="line">    <span class="comment">// 因为必须将这个值层层传递所有组件。  </span></span><br><span class="line">    <span class="keyword">return</span> (   </span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ThemedButton</span> <span class="attr">theme</span>=<span class="string">&#123;props.theme&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemedButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">theme</span>=<span class="string">&#123;this.props.theme&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 context, 我们可以避免通过中间元素传递 props：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。</span></span><br><span class="line"><span class="comment">// 为当前的 theme 创建一个 context（“light”为默认值）。</span></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">&#x27;light&#x27;</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span></span><br><span class="line">    <span class="comment">// 无论多深，任何组件都能读取这个值。</span></span><br><span class="line">    <span class="comment">// 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&quot;dark&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Toolbar</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间的组件再也不必指明往下传递 theme 了。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toolbar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ThemedButton</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemedButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 指定 contextType 读取当前的 theme context。</span></span><br><span class="line">  <span class="comment">// React 会往上找到最近的 theme Provider，然后使用它的值。</span></span><br><span class="line">  <span class="comment">// 在这个例子中，当前的 theme 值为 “dark”。</span></span><br><span class="line">  <span class="keyword">static</span> contextType = ThemeContext;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">theme</span>=<span class="string">&#123;this.context&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Context-之前的考虑"><a href="#使用-Context-之前的考虑" class="headerlink" title="使用 Context 之前的考虑"></a>使用 Context 之前的考虑</h3><p>Context 主要应用场景在于<em>很多</em>不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。</p><p><strong>如果你只是想避免层层传递一些属性，<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/composition-vs-inheritance.html">组件组合（component composition）</a>有时候是一个比 context 更好的解决方案。</strong></p><p>比如，考虑这样一个 <code>Page</code> 组件，它层层向下传递 <code>user</code> 和 <code>avatarSize</code> 属性，从而让深度嵌套的 <code>Link</code> 和 <code>Avatar</code> 组件可以读取到这些属性：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Page user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line"><span class="comment">// ... 渲染出 ...</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">PageLayout</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">avatarSize</span>=<span class="string">&#123;avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="comment">// ... 渲染出 ...</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">NavigationBar</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">avatarSize</span>=<span class="string">&#123;avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="comment">// ... 渲染出 ...</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&#123;user.permalink&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Avatar</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">size</span>=<span class="string">&#123;avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>如果在最后只有 <code>Avatar</code> 组件真的需要 <code>user</code> 和 <code>avatarSize</code>，那么层层传递这两个 props 就显得非常冗余。而且一旦 <code>Avatar</code> 组件需要更多从来自顶层组件的 props，你还得在中间层级一个一个加上去，这将会变得非常麻烦。</p><p>一种 <strong>无需 context</strong> 的解决方案是将 <code>Avatar</code> 组件自身传递下去，因为中间组件无需知道 <code>user</code> 或者 <code>avatarSize</code> 等 props：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = props.user;</span><br><span class="line">  <span class="keyword">const</span> userLink = (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&#123;user.permalink&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Avatar</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">size</span>=<span class="string">&#123;props.avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">PageLayout</span> <span class="attr">userLink</span>=<span class="string">&#123;userLink&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，我们有这样的组件：</span></span><br><span class="line">&lt;Page user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line"><span class="comment">// ... 渲染出 ...</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">PageLayout</span> <span class="attr">userLink</span>=<span class="string">&#123;...&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="comment">// ... 渲染出 ...</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">NavigationBar</span> <span class="attr">userLink</span>=<span class="string">&#123;...&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="comment">// ... 渲染出 ...</span></span><br><span class="line">&#123;props.userLink&#125;</span><br></pre></td></tr></table></figure><p>这种变化下，只有最顶部的 Page 组件需要知道 <code>Link</code> 和 <code>Avatar</code> 组件是如何使用 <code>user</code> 和 <code>avatarSize</code> 的。</p><p>这种对组件的<em>控制反转</em>减少了在你的应用中要传递的 props 数量，这在很多场景下会使得你的代码更加干净，使你对根组件有更多的把控。</p><p>但是，这并不适用于每一个场景：这种将逻辑提升到组件树的更高层次来处理，会使得这些高层组件变得更复杂，并且会强行将低层组件适应这样的形式，这可能不会是你想要的。</p><p>而且你的组件并不限制于接收单个子组件。你可能会传递多个子组件，甚至会为这些子组件（children）封装多个单独的“接口（slots）”，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = props.user;</span><br><span class="line">  <span class="keyword">const</span> content = <span class="xml"><span class="tag">&lt;<span class="name">Feed</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> /&gt;</span></span>;</span><br><span class="line">  <span class="keyword">const</span> topBar = (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">NavigationBar</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&#123;user.permalink&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Avatar</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">size</span>=<span class="string">&#123;props.avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">NavigationBar</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">PageLayout</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">topBar</span>=<span class="string">&#123;topBar&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">content</span>=<span class="string">&#123;content&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式足够覆盖很多场景了，在这些场景下你需要将子组件和直接关联的父组件解耦。如果子组件需要在渲染前和父组件进行一些交流，你可以进一步使用 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/render-props.html">render props</a>。</p><p>但是，有的时候在组件树中很多不同层级的组件需要访问同样的一批数据。Context 能让你将这些数据向组件树下所有的组件进行“广播”，所有的组件都能访问到这些数据，也能访问到后续的数据更新。使用 context 的通用的场景包括管理当前的 locale，theme，或者一些缓存数据，这比替代方案要简单的多。</p><h2 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h2><p>过去，组件内的 JavaScript 错误会导致 React 的内部状态被破坏，并且在下一次渲染时产生可能无法追踪的错误。</p><p>这些错误基本上是由较早的其他代码（非 React 组件代码）错误引起的，但 React 并没有提供一种在组件中优雅处理这些错误的方式，也无法从错误中恢复。</p><h3 id="错误边界（Error-Boundaries）"><a href="#错误边界（Error-Boundaries）" class="headerlink" title="错误边界（Error Boundaries）"></a>错误边界（Error Boundaries）</h3><p>部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，为了解决这个问题，React 16 引入了一个新的概念 —— 错误边界。</p><p>错误边界是一种 React 组件，这种组件<strong>可以捕获发生在其子组件树任何位置的 JavaScript 错误，并打印这些错误，同时展示降级 UI</strong>，而并不会渲染那些发生崩溃的子组件树。错误边界可以捕获发生在整个子组件树的渲染期间、生命周期方法以及构造函数中的错误。</p><blockquote><p>注意</p><p>错误边界<strong>无法</strong>捕获以下场景中产生的错误：</p><ul><li>事件处理</li><li>异步代码（例如 <code>setTimeout</code> 或 <code>requestAnimationFrame</code> 回调函数）</li><li>服务端渲染</li><li>它自身抛出来的错误（并非它的子组件）</li></ul></blockquote><p>如果一个 class 组件中定义了 <code>static getDerivedStateFromError()</code> 或 <code>componentDidCatch()</code>这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。</p><p>当抛出错误后，请使用 <code>static getDerivedStateFromError()</code> 渲染备用 UI ，使用 <code>componentDidCatch()</code> 打印错误信息。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getDerivedStateFromError</span>(<span class="params">error</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidCatch</span>(<span class="params">error, errorInfo</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 你同样可以将错误日志上报给服务器</span></span><br><span class="line">    logErrorToMyService(error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// 你可以自定义降级后的 UI 并渲染</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.props.children; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以将它作为一个常规组件去使用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ErrorBoundary&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">MyWidget</span> /&gt;</span></span></span><br><span class="line">&lt;/ErrorBoundary&gt;</span><br></pre></td></tr></table></figure><p>错误边界的工作方式类似于 JavaScript 的 <code>catch &#123;&#125;</code>，不同的地方在于错误边界只针对 React 组件。</p><p><strong>只有 class 组件才可以成为错误边界组件</strong>。大多数情况下, 你只需要声明一次错误边界组件, 并在整个应用中使用它。</p><p>注意<strong>错误边界仅可以捕获其子组件的错误</strong>，它无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会冒泡至最近的上层错误边界，这也类似于 JavaScript 中 <code>catch &#123;&#125;</code> 的工作机制。</p><h3 id="错误边界应该放置在哪？"><a href="#错误边界应该放置在哪？" class="headerlink" title="错误边界应该放置在哪？"></a>错误边界应该放置在哪？</h3><p>错误边界的粒度由你来决定，可以将其包装在最顶层的路由组件并为用户展示一个 “Something went wrong” 的错误信息，就像服务端框架经常处理崩溃一样。你也可以将单独的部件包装在错误边界以保护应用其他部分不崩溃。</p><h3 id="未捕获错误（Uncaught-Errors）的新行为"><a href="#未捕获错误（Uncaught-Errors）的新行为" class="headerlink" title="未捕获错误（Uncaught Errors）的新行为"></a>未捕获错误（Uncaught Errors）的新行为</h3><p>这一改变具有重要意义，<strong>自 React 16 起，任何未被错误边界捕获的错误将会导致整个 React 组件树被卸载。</strong></p><p>我们对这一决定有过一些争论，但根据我们的经验，把一个错误的 UI 留在那比完全移除它要更糟糕。</p><p>增加错误边界能够让你在应用发生异常时提供更好的用户体验。</p><h3 id="关于-try-catch-？"><a href="#关于-try-catch-？" class="headerlink" title="关于 try/catch ？"></a>关于 try/catch ？</h3><p><code>try</code> / <code>catch</code> 很棒但它仅能用于命令式代码（imperative code）：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  showButton();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，React 组件是声明式的并且具体指出 <em>什么</em> 需要被渲染：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button /&gt;</span><br></pre></td></tr></table></figure><p>错误边界保留了 React 的声明性质，其行为符合你的预期。例如，即使一个错误发生在 <code>componentDidUpdate</code> 方法中，并且由某一个深层组件树的 <code>setState</code> 引起，其仍然能够冒泡到最近的错误边界。</p><h3 id="关于事件处理器"><a href="#关于事件处理器" class="headerlink" title="关于事件处理器"></a>关于事件处理器</h3><p>错误边界<strong>无法</strong>捕获事件处理器内部的错误。</p><p>React 不需要错误边界来捕获事件处理器中的错误。与 render 方法和生命周期方法不同，事件处理器不会在渲染期间触发。因此，如果它们抛出异常，React 仍然能够知道需要在屏幕上显示什么。</p><p>如果你需要在事件处理器内部捕获错误，使用普通的 JavaScript <code>try</code> / <code>catch</code> 语句：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="attr">error</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">    <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 执行操作，如有错误则会抛出</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123; error &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state.error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Caught an error.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意上述例子只是演示了普通的 JavaScript 行为，并没有使用错误边界。</p><h2 id="高阶组件-Render-Props"><a href="#高阶组件-Render-Props" class="headerlink" title="高阶组件 / Render Props"></a>高阶组件 / Render Props</h2><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。（将通用的逻辑抽离在高阶组件中,已达到复用的目的）</p><p>HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p><p>具体而言，<strong>高阶组件是参数为组件，返回值为新组件的函数。</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure><p>组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。</p><p>HOC 在 React 的第三方库中很常见。</p><p>与<code>HOC</code>一样，<code>Render Props</code>也是一直以来都存在的元老级模式。</p><p><code>render props</code>指在一种<code>React</code>组件之间使用一个值为函数的<code>props</code>共享代码的简单技术。</p><p>具有<code>render props</code>的组件接收一个函数，该函数返回一个<code>React</code>元素并调用它而不是实现一个自己的渲染逻辑，<code>render props</code>是一个用于告知组件需要渲染什么内容的函数<code>props</code>，也是组件逻辑复用的一种实现方式。</p><p>简单来说就是在被复用的组件中，通过一个名为<code>render</code>(属性名也可以不是<code>render</code>，只要值是一个函数即可)的<code>prop</code>属性，该属性是一个函数，这个函数接受一个对象并返回一个子组件，会将这个函数参数中的对象作为<code>props</code>传入给新生成的组件，而在使用调用者组件这里，只需要决定这个组件在哪里渲染以及该以何种逻辑渲染并传入相关对象即可。</p><p>对比<code>HOC</code>与<code>Render Props</code>，技术上，二者都基于组件组合机制，<code>Render Props</code>拥有与<code>HOC</code>一样的扩展能力，称之为<code>Render Props</code>，并不是说只能用来复用渲染逻辑，而是表示在这种模式下，组件是通过<code>render</code>()组合起来的，类似于<code>HOC</code>模式下通过<code>Wrapper</code>的<code>render</code>()建立组合关系形式上，二者非常相像，同样都会产生一层<code>Wrapper</code>，而实际上<code>Render Props</code>与<code>HOC</code>甚至能够相互转换。<br>同样，<code>Render Props</code>也会存在一些问题:</p><ul><li>数据流向更直观了，子孙组件可以很明确地看到数据来源，但本质上<code>Render Props</code>是基于闭包实现的，大量地用于组件的复用将不可避免地引入了<code>callback hell</code>问题。</li><li>丢失了组件的上下文，因此没有<code>this.props</code>属性，不能像<code>HOC</code>那样访问<code>this.props.children</code></li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="虚拟化长列表"><a href="#虚拟化长列表" class="headerlink" title="虚拟化长列表"></a>虚拟化长列表</h3><p>如果你的应用渲染了长列表（上百甚至上千的数据），我们推荐使用“虚拟滚动”技术。</p><p>这项技术会在有限的时间内仅渲染有限的内容，并奇迹般地降低重新渲染组件消耗的时间，以及创建 DOM 节点的数量。</p><p><a target="_blank" rel="noopener" href="https://react-window.now.sh/">react-window</a> 和 <a target="_blank" rel="noopener" href="https://bvaughn.github.io/react-virtualized/">react-virtualized</a> 是热门的虚拟滚动库。 它们提供了多种可复用的组件，用于展示列表、网格和表格数据。</p><h3 id="避免调停"><a href="#避免调停" class="headerlink" title="避免调停"></a>避免调停</h3><p>React 构建并维护了一套内部的 UI 渲染描述。它包含了来自你的组件返回的 React 元素。</p><p>该描述使得 React 避免创建 DOM 节点以及没有必要的节点访问，因为 DOM 操作相对于 JavaScript 对象操作更慢。</p><p>虽然有时候它被称为“虚拟 DOM”，但是它在 React Native 中拥有相同的工作原理。</p><p>当一个组件的 props 或 state 变更，React 会将最新返回的元素与之前渲染的元素进行对比，以此决定是否有必要更新真实的 DOM。当它们不相同时，React 会更新该 DOM。</p><p>即使 React 只更新改变了的 DOM 节点，重新渲染仍然花费了一些时间。</p><p>在大部分情况下它并不是问题，不过如果它已经慢到让人注意了，你可以通过覆盖生命周期方法 <code>shouldComponentUpdate</code> 来进行提速。</p><p>该方法会在重新渲染前被触发。其默认实现总是返回 <code>true</code>，让 React 执行更新：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你知道在什么情况下你的组件不需要更新，你可以在 <code>shouldComponentUpdate</code> 中返回 <code>false</code> 来跳过整个渲染过程。其包括该组件的 <code>render</code> 调用以及之后的操作。</p><p>在大部分情况下，你可以继承 <code>React.PureComponent</code>以代替手写 <code>shouldComponentUpdate()</code>。</p><p>它用当前与之前 props 和 state 的浅比较覆写了 <code>shouldComponentUpdate()</code> 的实现。</p><h2 id="受控与非受控组件"><a href="#受控与非受控组件" class="headerlink" title="受控与非受控组件"></a>受控与非受控组件</h2><p><code>React</code>的受控组件与非受控组件的概念是相对于表单而言的，在<code>React</code>中表单元素通常会持有一下内部的<code>state</code>，因此它的工作方式与其他<code>HTML</code>元素不一样，而获取表单元素内部<code>state</code>的实现方式的不同，就产生了受控组件和非受控组件。</p><p>就形式上来说，**<code>受控组件</code>就是为某个form表单组件添加<code>value</code>属性；<code>非受控组件</code>就是没有添加<code>value</code>属性的组件**</p><h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p>在<code>HTML</code>的表单元素中，它们通常自己维护一套<code>state</code>，并随着用户的输入自己进行<code>UI</code>上的更新，这种行为是不被我们程序所管控的，而如果将<code>React</code>里的<code>state</code>属性和表单元素的值建立依赖关系，再通过<code>onChange</code>事件与<code>setState()</code>结合更新<code>state</code>属性，就能达到控制用户输入过程中表单发生的操作，<code>React</code>以这种方式控制取值的表单输入元素就叫做受控组件。</p><p>在<code>React</code>中定义了一个<code>input</code>输入框的话，它并没有类似于<code>Vue</code>里<code>v-model</code>的这种双向绑定功能，也就是说我们并没有一个指令能够将数据和输入框结合起来，用户在输入框中输入内容，然后数据同步更新。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户在界面上的输入框输入内容时，它是自己维护了一个<code>state</code>，这个<code>state</code>并不是我们平常看见的<code>this.state</code>，而是每个表单元素上抽象的<code>state</code>，这样的话就能根据用户的输入自己进行<code>UI</code>上的更新，如果我们想要控制输入框的内容，而输入框的内容取决的是<code>input</code>中的<code>value</code>属性，那么我们可以在<code>this.state</code>中定义一个名为<code>username</code>的属性，并将<code>input</code>上的<code>value</code>指定为这个属性。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="attr">username</span>: <span class="string">&quot;1&quot;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.username&#125;</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这时候你会发现<code>input</code>的内容是只读的，因为<code>value</code>会被我们的<code>this.state.username</code>所控制，当用户输入新的内容时，<code>this.state.username</code>并不会自动更新，这样的话<code>input</code>内的内容也就不会变了，此时控制台通常会抛出一个<code>Warning</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>您为表单字段提供了一个没有<code>onChange</code>处理程序的<code>value</code>属性，这将呈现只读字段，如果字段应该是可变的，请使用<code>defaultValue</code>，否则请设置<code>onChange</code>或<code>readOnly</code>。 这段<code>Warning</code>其实给出了对于这个问题的解决方案，我们只需要对组件的<code>onChange</code>事件来监听输入内容的改变并使用<code>setState</code>更新<code>this.state.username</code>即可，如此我们在当前组件中能够控制这个表单元素的值，这就是受控组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="attr">username</span>: <span class="string">&quot;1&quot;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.username&#125;</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> this.setState(&#123;username: e.target.value&#125;)&#125; </span></span><br><span class="line"><span class="xml">        /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> console.log(this.state.username)&#125; &gt;Log<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外需要注意的是，如果是讲此组件作为一个共用的组件用以调用的话，是有弊端的，尽管此时<code>Input</code>组件本身是一个受控组件，但与之相对的调用方失去了更改<code>Input</code>组件值的控制权，所以对调用方而言，<code>Input</code>组件是一个非受控组件，以非受控组件的使用方式去调用受控组件是一种反模式，下边的例子都是属于<code>Hooks</code>的写法。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件提供方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Input</span>(<span class="params">&#123; defaultValue &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = React.useState(defaultValue)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> setValue(e.target.value)&#125; /&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UseInput</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">defaultValue</span>=<span class="string">&#123;1&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要对于组件提供方还是调用方<code>Input</code>组件都为受控组件，只需要提供方让出控制权即可。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件提供方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Input</span>(<span class="params">&#123; value, onChange &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UseInput</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = React.useState(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> setValue(e.target.value)&#125; /&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h3><p>如果表单元素并不经过<code>state</code>，而是通过<code>ref</code>修改或者直接操作<code>DOM</code>，那么它的数据无法通过<code>state</code>控制，这就是非受控组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.input = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.input&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> console.log(this.input.current.value)&#125; &gt;Log<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合成事件-事件处理"><a href="#合成事件-事件处理" class="headerlink" title="合成事件/事件处理"></a>合成事件/事件处理</h2><ul><li>通过<code>onXxx</code>属性指定事件处理函数(注意大小写)<ul><li>React使用的是<strong>自定义(合成)事件,而不是使用的原生DOM事件</strong>—-为了更好的<strong>兼容性</strong></li><li>React中的事件是通过<strong>事件委托</strong>的方式处理的(委托给组件最外层的元素)—-为了更<strong>高效</strong></li></ul></li><li>通过<code>event.target</code>得到发生事件的DOM元素对象 —–<strong>不要过度使用ref</strong></li><li>在 React 中另一个不同点是你不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式地使用 <code>preventDefault</code>。</li></ul><ul><li>合成事件的监听器是统一注册在document上的，且仅有冒泡阶段。所以<strong>原生事件的监听器响应总是比合成事件的监听器早</strong>。</li></ul><p>如果DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。</p><p>React为了<strong>避免这类DOM事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异</strong>，实现了一个中间层——<strong>SyntheticEvent</strong>。</p><p>React并不是将click事件绑在该div的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。</p><p>虽然React封装了几乎所有的原生事件，但诸如：</p><ul><li>Modal开启以后点其他空白区域需要关闭Modal</li><li>引入了一些以原生事件实现的第三方库，并且相互之间需要有交互</li></ul><p>等等场景时，不得不使用原生事件来进行业务逻辑处理。</p><p>由于原生事件需要绑定在真实DOM上，所以一般是在<code>componentDidMount阶段</code>/<code>ref的函数执行阶段</code>进行绑定操作，在<code>componentWillUnmount阶段</code>进行解绑操作以避免内存泄漏。Hook则是在useEffect中实现。</p><p>从 v0.14 开始，事件处理器返回 <code>false</code> 时，不再阻止事件传递。你可以酌情手动调用 <code>e.stopPropagation()</code> 或 <code>e.preventDefault()</code> 作为替代方案。</p><p>事件处理函数在冒泡阶段被触发。如需注册捕获阶段的事件处理函数，则应为事件名添加 <code>Capture</code>。例如，处理捕获阶段的点击事件请使用 <code>onClickCapture</code>，而不是 <code>onClick</code>。</p><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>JSX 是<strong>JavaScript XML</strong> 的简写，是一个 JavaScript 的语法扩展。</p><p>建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。</p><p>JSX 可能会使人联想到模板语言，但它具有 JavaScript 的全部功能。</p><p>React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。</p><p>React 并没有采用将<em>标记与逻辑分离到不同文件</em>这种人为的分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现<em>关注点分离</em>。</p><p><strong>React不强制要求使用 JSX</strong>，但是大多数人发现，<strong>在 JavaScript 代码中将 JSX 和 UI 放在一起时，会在视觉上有辅助作用</strong>。它还可以使 React <strong>显示更多有用的错误和警告消息</strong>。</p><p>Babel 会把 JSX 转译成一个名为 <code>React.createElement()</code> 函数调用。</p><p>实际上，JSX 仅仅只是 <code>React.createElement(component, props, ...children)</code> 函数的语法糖。</p><h2 id="虚拟DOM-★"><a href="#虚拟DOM-★" class="headerlink" title="虚拟DOM ★"></a>虚拟DOM ★</h2><p>操作DOM会引起页面的回流或者重绘。相比起来，通过多一些预先计算来减少DOM的操作要划算的多。</p><p>但是，“使用虚拟DOM会更快”这句话并不一定适用于所有场景。</p><p>例如：一个页面就有一个按钮，点击一下，数字加一，那肯定是直接操作DOM更快。</p><p>使用虚拟DOM无非白白增加了计算量和代码量。</p><p>即使是复杂情况，浏览器也会对我们的DOM操作进行优化，大部分浏览器会根据我们操作的时间和次数进行批量处理，所以直接操作DOM也未必很慢。</p><p><strong>使用虚拟DOM可以提高代码的性能下限，并极大的优化大量操作DOM时产生的性能损耗。</strong></p><p>同时这些框架也保证了，即使在少数虚拟DOM不太给力的场景下，<strong>性能也在我们接受的范围内</strong>。</p><p>UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫做<strong>协调</strong>。</p><p>这种方式赋予了 React <strong>声明式</strong>的 API：您告诉 React 希望让 UI 是什么状态，React 就确保 DOM 匹配该状态。</p><p>这使您可以从属性操作、事件处理和手动 DOM 更新这些在构建应用程序时必要的操作中解放出来。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>Virtual DOM 是一个<strong>轻量级的 JavaScript 对象</strong>，它最初只是 real DOM 的副本。</p><p>它是一个节点树，它将<strong>元素</strong>、它们的<strong>属性</strong>和<strong>内容</strong>作为<strong>对象及其属性</strong>。</p><p>React 的渲染函数从 React 组件中创建一个节点树。</p><p>然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。</p><ul><li>每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。</li><li>然后计算之前 DOM 表示与新DOM 表示的之间的差异。</li><li>完成计算后，将只用实际更改的内容更新 real DOM。</li></ul><h3 id="原生实现"><a href="#原生实现" class="headerlink" title="原生实现"></a>原生实现</h3><p>将VirtualDom转化为真实DOM结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vnode结构：</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   tag,</span></span><br><span class="line"><span class="comment">//   attrs,</span></span><br><span class="line"><span class="comment">//   children,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Virtual DOM =&gt; DOM</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  container.appendChild(_render(vnode));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_render</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是数字类型转化为字符串</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    vnode = <span class="built_in">String</span>(vnode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 字符串类型直接就是文本节点</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode(vnode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 普通DOM</span></span><br><span class="line">  <span class="keyword">const</span> dom = <span class="built_in">document</span>.createElement(vnode.tag);</span><br><span class="line">  <span class="keyword">if</span> (vnode.attrs) &#123;</span><br><span class="line">    <span class="comment">// 遍历属性</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(vnode.attrs).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> value = vnode.attrs[key];</span><br><span class="line">      dom.setAttribute(key, value);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子数组进行递归操作</span></span><br><span class="line">  vnode.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> render(child, dom));</span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h3><p>Fiber 是 React 16 中新的协调引擎。它的主要目的是使 Virtual DOM 可以进行<strong>增量式渲染</strong>。</p><p>React Fiber的思想: <strong>React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染</strong>。</p><p>Fiber 的中文翻译叫纤程，与进程、线程同为程序执行过程，Fiber 就是比线程还要纤细的一个过程。</p><p>纤程意在对渲染过程实现进行更加精细的控制。</p><p>从架构角度来看，Fiber 是对 React 核心算法（即<strong>调和</strong>过程）的重写。</p><p>从编码角度来看，Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的”<strong>虚拟 DOM</strong>“。</p><p>一个 fiber 就是一个 JavaScript 对象。</p><h4 id="Fiber-如何解决问题的"><a href="#Fiber-如何解决问题的" class="headerlink" title="Fiber 如何解决问题的"></a>Fiber 如何解决问题的</h4><p>Fiber 把一个渲染任务分解为多个渲染任务，而不是一次性完成。</p><p>把每一个分割得很细的任务视作一个”执行单元”。</p><p>React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去，故任务会被分散到多个帧里面，中间可以返回至主进程控制执行其他任务，最终实现更流畅的用户体验。</p><p>即是实现了”增量渲染”，实现了可中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber 节点。</p><h4 id="Fiber-实现原理"><a href="#Fiber-实现原理" class="headerlink" title="Fiber 实现原理"></a>Fiber 实现原理</h4><p>实现的方式是<code>requestIdleCallback</code>这一 API，但 React 团队 polyfill 了这个 API，使其对比原生的浏览器兼容性更好且拓展了特性。</p><blockquote><p>window.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。</p><p>这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。</p><p>函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间 timeout，则有可能为了在超时前执行函数而打乱执行顺序。</p></blockquote><p>requestIdleCallback回调的执行的前提条件是当前浏览器处于空闲状态。</p><p>即requestIdleCallback的作用是在浏览器一帧的剩余空闲时间内执行优先度相对较低的任务。</p><p>首先 React 中任务切割为多个步骤，分批完成。</p><p>在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间再进行页面的渲染。</p><p>等浏览器忙完之后有剩余时间，再继续之前 React 未完成的任务，是一种合作式调度。</p><p>简而言之，由浏览器给我们分配执行时间片，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。</p><p>React 16 的Reconciler基于 Fiber 节点实现，被称为 Fiber Reconciler。</p><p>作为静态的数据结构来说，每个 Fiber 节点对应一个 React element，保存了该组件的类型（函数组件/类组件/原生组件等等）、对应的 DOM 节点等信息。</p><p>作为动态的工作单元来说，每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的工作。</p><h3 id="diff-算法-协调"><a href="#diff-算法-协调" class="headerlink" title="diff 算法/协调"></a>diff 算法/协调</h3><p>在某一时间节点调用 React 的 <code>render()</code> 方法，会创建一棵由 React 元素组成的树。</p><p>在下一次 <code>state</code> 或 <code>props</code> 更新时，相同的 <code>render()</code> 方法会返回一棵不同的树。</p><p>React 需要基于这两棵树之间的差别来判断如何高效的更新 UI，以保证当前 UI 与最新的树保持同步。</p><p>此算法有一些通用的解决方案，即<strong>将一棵树转换成另一棵树的最小操作次数</strong>。</p><p>然而，即使使用最优的算法，该算法的复杂程度仍为 <code>O(n^3 )</code>，其中 n 是树中元素的数量。</p><p>于是 React 在以下两个假设的基础之上提出了一套 <code>O(n)</code> 的启发式算法：</p><ol><li><strong>两个不同类型的元素会产生出不同的树</strong>；</li><li>开发者可以通过设置 <code>key</code> 属性，来告知<strong>渲染哪些子元素在不同的渲染下可以保存不变</strong>；</li></ol><h4 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h4><p>“key” 是在创建元素数组时，需要用到的一个特殊字符串属性。</p><p>key 帮助 React 识别出被修改、添加或删除的 item。应当给数组内的每个元素都设定 key，以使元素具有固定身份标识。</p><p>只需要保证，<strong>在同一个数组中的兄弟元素之间的 key 是唯一的</strong>。而不需要在整个应用程序甚至单个组件中保持唯一。</p><p><strong>不要</strong>将 <code>Math.random()</code> 之类的值传递给 key。</p><p>重要的是，在前后两次渲染之间的 key 要具有“固定身份标识”的特点，以便 React 可以在添加、删除或重新排序 item 时，前后对应起来。理想情况下，key 应该从数据中获取，对应着唯一且固定的标识符，例如 <code>post.id</code>。</p><p>当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素，从而减少不必要的元素重新渲染。</p><p><strong>虚拟DOM中key的作用：</strong></p><ul><li><p>简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。</p></li><li><p>详细的说: 当状态中的数据发生变化时，react会根据<strong>新数据</strong>生成<strong>新的虚拟DOM,</strong> 随后React进行<strong>新虚拟DOM</strong>与<strong>旧虚拟DOM</strong>的diff比较，比较规则如下：</p><ul><li><p>旧虚拟DOM中找到了与新虚拟DOM相同的key：</p><ul><li>若虚拟DOM中内容没变, 直接使用之前的真实DOM</li><li>若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM</li></ul></li><li><p>旧虚拟DOM中未找到与新虚拟DOM相同的key</p><ul><li>根据数据创建新的真实DOM，随后渲染到到页面</li></ul></li></ul></li></ul><p><strong>用index作为key可能会引发的问题：</strong></p><ul><li><p>若对数据进行：<strong>逆序添加、逆序删除</strong>等破坏顺序操作：会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但<strong>效率低</strong>。</p></li><li><p>如果结构中还包含<strong>输入类的DOM</strong>：会产生错误DOM更新 ==&gt; <strong>界面有问题</strong>。</p></li><li><p>注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</p></li></ul><p><strong>开发中如何选择key?:</strong></p><ul><li><p><strong>最好使用每条数据的唯一标识作为key</strong>, 比如id、手机号、身份证号、学号等唯一值。</p></li><li><p><strong>如果确定只是简单的展示数据，用index也是可以的</strong>。</p></li></ul><h2 id="两种组件★"><a href="#两种组件★" class="headerlink" title="两种组件★"></a>两种组件★</h2><p>组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。</p><p><strong>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</strong></p><p>在不违反上述规则的情况下，state 允许 React 组件随用户操作、网络响应或者其他变化而动态更改输出内容。</p><p>State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件。</p><h3 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1.创建函数式组件</span><br><span class="line">function MyComponent()&#123;</span><br><span class="line">    console.log(this); //此处的this是undefined，因为babel编译后开启了严格模式</span><br><span class="line">    return &lt;h2&gt;我是用函数定义的组件(适用于【简单组件】的定义)&lt;/h2&gt;</span><br><span class="line">&#125;</span><br><span class="line">//2.渲染组件到页面</span><br><span class="line">ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#x27;test&#x27;))</span><br></pre></td></tr></table></figure><p>执行了<code>ReactDOM.render(&lt;MyComponent/&gt;.......)</code>之后，发生了什么？</p><ul><li>React解析组件标签，找到了MyComponent组件。</li><li>发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。</li></ul><h3 id="类式"><a href="#类式" class="headerlink" title="类式"></a>类式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//1.创建类式组件</span><br><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        //render是放在哪里的？—— MyComponent的原型对象上，供实例使用。</span><br><span class="line">        //render中的this是谁？—— MyComponent的实例对象 &lt;=&gt; MyComponent组件实例对象。</span><br><span class="line">        console.log(&#x27;render中的this:&#x27;,this);</span><br><span class="line">        return &lt;h2&gt;我是用类定义的组件&lt;/h2&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//2.渲染组件到页面</span><br><span class="line">ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#x27;test&#x27;))</span><br></pre></td></tr></table></figure><p>执行了<code>ReactDOM.render(&lt;MyComponent/&gt;.......)</code>之后，发生了什么？</p><ul><li><p>React解析组件标签，找到了MyComponent组件。</p></li><li><p>发现组件是使用类定义的，随后<strong>new出来该类的实例</strong>，并<strong>通过该实例调用到原型上的render方法</strong>。</p></li><li><p>将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。</p></li></ul><blockquote><p>类的方法默认开启了局部严格模式</p></blockquote><p>组件中的<strong>render方法中的this为组件实例对象</strong></p><p>但组件自定义方法中this为<code>undefined</code>,如何解决?</p><p>a) 强制绑定this:通过函数对象的<code>bind()</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造器调用几次？ ———— 1次</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;constructor&#x27;</span>);</span><br><span class="line">        <span class="built_in">super</span>(props)</span><br><span class="line">        <span class="comment">//初始化状态</span></span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">isHot</span>:<span class="literal">false</span>,<span class="attr">wind</span>:<span class="string">&#x27;微风&#x27;</span>&#125;</span><br><span class="line">        <span class="comment">//解决changeWeather中this指向问题,也可以在调用处直接使用</span></span><br><span class="line">        <span class="built_in">this</span>.changeWeather = <span class="built_in">this</span>.changeWeather.bind(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//render调用几次？ ———— 1+n次 1是初始化的那次 n是状态更新的次数</span></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;render&#x27;</span>);</span><br><span class="line">        <span class="comment">//读取状态</span></span><br><span class="line">        <span class="keyword">const</span> &#123;isHot,wind&#125; = <span class="built_in">this</span>.state</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span>今天天气很&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;，&#123;wind&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//changeWeather调用几次？ ———— 点几次调几次</span></span><br><span class="line">    <span class="function"><span class="title">changeWeather</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//changeWeather放在哪里？ ———— Weather的原型对象上，供实例使用</span></span><br><span class="line">        <span class="comment">//由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用</span></span><br><span class="line">        <span class="comment">//类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;changeWeather&#x27;</span>);</span><br><span class="line">        <span class="comment">//获取原来的isHot值</span></span><br><span class="line">        <span class="keyword">const</span> isHot = <span class="built_in">this</span>.state.isHot</span><br><span class="line">        <span class="comment">//严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换。</span></span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">isHot</span>:!isHot&#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！</span></span><br><span class="line">        <span class="comment">//this.state.isHot = !isHot //这是错误的写法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.渲染组件到页面</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Weather</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>))</span><br></pre></td></tr></table></figure><p>b) 箭头函数<code>推荐</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">	<span class="comment">//初始化状态</span></span><br><span class="line">   <span class="comment">//类中可以直接写赋值语句,如下代码的含义是：给Weather的实例对象添加一个属性 state</span></span><br><span class="line">	state = &#123;<span class="attr">isHot</span>:<span class="literal">false</span>,<span class="attr">wind</span>:<span class="string">&#x27;微风&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> &#123;isHot,wind&#125; = <span class="built_in">this</span>.state</span><br><span class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span>今天天气很&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;，&#123;wind&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自定义方法————要用赋值语句的形式+箭头函数</span></span><br><span class="line">	changeWeather = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> isHot = <span class="built_in">this</span>.state.isHot</span><br><span class="line">		<span class="built_in">this</span>.setState(&#123;<span class="attr">isHot</span>:!isHot&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.渲染组件到页面</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Weather</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>条件渲染：<code>if</code>、<code>&amp;&amp;</code>、<strong>三目运算符</strong></p><p>阻止组件渲染：让 <code>render</code> 方法直接返回 <code>null</code>，而不进行任何渲染。</p><h2 id="State-★"><a href="#State-★" class="headerlink" title="State ★"></a>State ★</h2><h3 id="不要直接修改-State"><a href="#不要直接修改-State" class="headerlink" title="不要直接修改 State"></a>不要直接修改 State</h3><p>而是应该使用 <code>setState()</code>:</p><h3 id="State更新可能异步"><a href="#State更新可能异步" class="headerlink" title="State更新可能异步"></a>State更新可能异步</h3><p>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用<strong>合并</strong>成一个调用。</p><p>因为 <code>this.props</code> 和 <code>this.state</code> 可能会<strong>异步更新</strong>，所以你<strong>不要依赖他们的值来更新下一个状态</strong>。</p><p>要解决这个问题，可以让 <code>setState()</code> 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">counter</span>: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>上面使用了箭头函数，不过使用普通的函数也同样可以：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function"><span class="keyword">function</span>(<span class="params">state, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">counter</span>: state.counter + props.increment</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>setState更新状态的2种写法</strong></p><ul><li><p><code>setState(stateChange, [callback])</code>——对象式的setState</p><ul><li>stateChange为<strong>状态改变对象</strong>(该对象可以体现出状态的更改)</li><li>callback是可选的回调函数, 它在状态更新完毕（状态更新是异步的）、界面也更新后(render调用后)才被调用</li></ul></li><li><p><code>setState(updater, [callback])</code>——函数式的setState</p><ul><li>updater为<strong>返回stateChange对象的函数</strong>。</li><li>updater可以接收到state和props。</li><li>callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。</li></ul></li></ul><p>总结:</p><ul><li>对象式的setState是函数式的setState的简写方式(<code>语法糖</code>)</li><li>使用原则：<ul><li>如果<strong>新状态不依赖于原状态</strong> =&gt; 使用<strong>对象</strong>方式</li><li>如果<strong>新状态依赖于原状态</strong> =&gt; 使用<strong>函数</strong>方式</li><li>如果<strong>需要在setState()执行后获取最新的状态数据, 要在第二个callback函数中读取</strong></li></ul></li></ul><p>setState只在<strong>合成事件和 hook()</strong> 中是“异步”的，在 <strong>原生事件和 setTimeout</strong> 中都是同步的。</p><h3 id="State更新会合并"><a href="#State更新会合并" class="headerlink" title="State更新会合并"></a>State更新会合并</h3><p>当你调用 <code>setState()</code> 的时候，React 会把你提供的对象<strong>合并</strong>到当前的 state。</p><p>这里的合并是<strong>浅合并</strong>。</p><h3 id="数据是向下流动的"><a href="#数据是向下流动的" class="headerlink" title="数据是向下流动的"></a>数据是向下流动的</h3><p>不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。</p><p>这就是为什么称 state 为局部的或是封装的的原因。</p><p>除了拥有并设置了它的组件，其他组件都无法访问。</p><p>组件可以选择把它的 state 作为 props 向下传递到它的子组件中。</p><p>这通常会被叫做“自上而下”或是<strong>单向</strong>的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。</p><p>如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。</p><p>在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state 都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个 state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/state-and-lifecycle.html#the-data-flows-down">自上而下的数据流</a>，而不是尝试在不同组件间同步 state。</p><p>虽然提升 state 方式比双向绑定方式需要编写更多的“样板”代码，但带来的好处是，排查和隔离 bug 所需的工作量将会变少。由于“存在”于组件中的任何 state，仅有组件自己能够修改它，因此 bug 的排查范围被大大缩减了。此外，你也可以使用自定义逻辑来拒绝或转换用户的输入。</p><p>如果某些数据可以由 props 或 state 推导得出，那么它就不应该存在于 state 中。</p><p>当你在 UI 中发现错误时，可以使用 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/tree/main/packages/react-devtools">React 开发者工具</a> 来检查问题组件的 props，并且按照组件树结构逐级向上搜寻，直到定位到负责更新 state 的那个组件。这使得你能够追踪到产生 bug 的源头。</p><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p>在典型的React数据流理念中，父组件跟子组件的交互都是通过传递<code>props</code>实现的。</p><p>如果父组件需要修改子组件，只需要将新的属性传递给子组件，由子组件来实现具体的绘制逻辑。</p><p>在特殊的情况下，如果你需要<strong>命令式(imperatively)的修改子组件</strong>，React也提供了应急的处理办法–Ref。</p><p>Ref 既支持修改<strong>DOM元素</strong>，也支持修改<strong>自定义的组件</strong>。</p><h3 id="声明式编程-1"><a href="#声明式编程-1" class="headerlink" title="声明式编程"></a>声明式编程</h3><p>React有2个基石设计理念：一个是声明式编程，一个是函数式编程。</p><p>声明式编程的特点体现在2方面：</p><ul><li>组件定义的时候，<strong>所有的实现逻辑都封装在组件的内部，通过state管理，对外只暴露属性</strong>。</li><li>组件使用的时候，组件调用者通<strong>过传入不同属性的值来达到展现不同内容的效果</strong>。一切效果都是事先定义好的，至于效果是怎么实现的，组件调用者不需要关心。</li></ul><p>因此，在使用React的时候，<strong>一般很少需要用到Ref</strong>。</p><h3 id="Ref使用场景"><a href="#Ref使用场景" class="headerlink" title="Ref使用场景"></a>Ref使用场景</h3><p>简单理解就是，<strong>控制一些DOM原生的效果，如输入框的聚焦效果和选中效果等；触发一些命令式的动画；集成第三方的DOM库</strong>。最后还补了一句：如果要实现的功能可以通过声明式的方式实现，就不要借助Ref。</p><p>refs是React组件中非常特殊的props， 可以附加到任何一个组件上，从字面意思上看，<strong>ref即reference，组件被调用时会创建一个该组件的实例，而ref就会指向这个实例</strong>。</p><h3 id="Ref用法"><a href="#Ref用法" class="headerlink" title="Ref用法"></a>Ref用法</h3><blockquote><p>如果<strong>作用在原生的DOM元素上，通过Ref获取的是DOM元素，可以直接操作DOM的API</strong>。</p><p>如果<strong>作用在自定义组件，Ref获取的是组件的实例，可以直接操作组件内的任意方法</strong>。</p></blockquote><h4 id="创建-Refs"><a href="#创建-Refs" class="headerlink" title="创建 Refs"></a>创建 Refs</h4><p>Refs 是使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素。</p><p>在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.myRef = React.createRef();  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span>;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问-Refs"><a href="#访问-Refs" class="headerlink" title="访问 Refs"></a>访问 Refs</h4><p>当 ref 被传递给 <code>render</code> 中的元素时，对该节点的引用可以在 ref 的 <code>current</code> 属性中被访问。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="built_in">this</span>.myRef.current;</span><br></pre></td></tr></table></figure><p>ref 的值根据节点的类型而有所不同：</p><ul><li>当 <code>ref</code> 属性用于 <strong>HTML 元素</strong>时，构造函数中使用 <code>React.createRef()</code> 创建的 <code>ref</code> 接收底层 DOM 元素作为其 <code>current</code> 属性。</li><li>当 <code>ref</code> 属性用于<strong>自定义 class 组件</strong>时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性。</li><li><strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为他们<strong>没有实例</strong>。</li></ul><p><strong>Refs 与函数组件</strong></p><p>默认情况下，<strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为它们没有实例。</p><p>如果要在函数组件中使用 <code>ref</code>，你可以使用 <code>forwardRef</code>（可与 <code>useImperativeHandle</code>结合使用）。</p><p>但你可以<strong>在函数组件内部使用 <code>ref</code> 属性</strong>，只要它<strong>指向一个 DOM 元素或 class 组件</strong>。</p><h2 id="React组件通信如何实现"><a href="#React组件通信如何实现" class="headerlink" title="React组件通信如何实现?"></a>React组件通信如何实现?</h2><blockquote><p>由于<code>React</code>是单向数据流，主要思想是组件不会改变接收的数据，只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值。因此，可以看到通信过程中，数据的存储位置都是存放在上级位置中。</p></blockquote><p>React组件间通信方式:</p><ul><li><strong>父组件</strong>向<strong>子组件</strong>通讯: 父组件可以向子组件通过传 <strong>props</strong> 的方式，向子组件进行通讯</li><li><strong>子组件</strong>向<strong>父组件</strong>通讯: <strong>props+回调</strong>的方式,父组件向子组件传递props进行通讯，此props为<strong>作用域为父组件自身的函数</strong>，子组件调用该函数，将子组件想要传递的信息，作为参数，<strong>传递到父组件的作用域中</strong>。</li><li>兄弟组件通信: <strong>找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信息进行通信</strong></li><li>跨层级通信: <code>Context</code>设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言,对于<strong>跨越多层的全局数据</strong>通过<code>Context</code>通信再适合不过。</li><li>发布订阅模式: <strong>发布者发布事件，订阅者监听事件并做出反应</strong>,我们可以通过引入event模块进行通信。</li><li>全局状态管理工具: 借助<code>Redux</code>或者<code>Mobx</code>等全局状态管理工具进行通信,这种工具会<strong>维护一个全局状态中心Store,并根据不同的事件产生新的状态</strong>。</li></ul><p>比较好的搭配方式</p><ul><li>父子组件：props</li><li>兄弟组件：消息订阅-发布、集中式管理</li><li>祖孙组件(跨级组件)：消息订阅-发布、集中式管理、Context(开发用的少，封装插件用的多)</li></ul><h2 id="React-生命周期-★"><a href="#React-生命周期-★" class="headerlink" title="React 生命周期 ★"></a>React 生命周期 ★</h2><h3 id="Hooks-组件"><a href="#Hooks-组件" class="headerlink" title="Hooks 组件"></a>Hooks 组件</h3><p><strong>函数组件</strong> 的本质是函数，没有 state 的概念的，因此<strong>不存在生命周期</strong>一说，仅仅是一个 <strong>render 函数</strong>而已。</p><p>但是引入 <strong>Hooks</strong> 之后就变得不同了，它能让组件在不使用 class 的情况下使用 state 以及其他的 React特性，相比与 class 的生命周期概念来说，它更接近于实现状态同步，而不是响应生命周期事件。但我们可以利用 <code>useState</code>、 <code>useEffect()</code> 和 <code>useLayoutEffect()</code> 来模拟实现生命周期。</p><p>即：<strong>Hooks 组件更接近于实现状态同步，而不是响应生命周期事件</strong>。</p><table><thead><tr><th>class 组件</th><th>Hooks /函数式组件</th></tr></thead><tbody><tr><td>constructor</td><td>useState</td></tr><tr><td>getDerivedStateFromProps</td><td>改为在渲染时安排一次更新 useState 里面 update 函数</td></tr><tr><td>shouldComponentUpdate</td><td>React.memo useMemo</td></tr><tr><td>render</td><td>函数本身</td></tr><tr><td>componentDidMount</td><td>useEffect</td></tr><tr><td>componentDidUpdate</td><td>useEffect</td></tr><tr><td>componentWillUnmount</td><td>useEffect 里面返回的函数</td></tr></tbody></table><h3 id="单个组件的生命周期"><a href="#单个组件的生命周期" class="headerlink" title="单个组件的生命周期"></a>单个组件的生命周期</h3><h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>当<strong>组件实例被创建并插入 DOM 中</strong>时，其生命周期调用顺序如下：</p><ul><li><strong><code>constructor()</code></strong></li><li><strong><code>render()</code></strong></li><li><strong><code>componentDidMount()</code></strong></li></ul><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>当<strong>组件的 props 或 state 发生变化时会触发更新</strong>。组件更新的生命周期调用顺序如下：</p><ul><li><code>shouldComponentUpdate()</code></li><li><strong><code>render()</code></strong></li><li><strong><code>componentDidUpdate()</code></strong></li></ul><h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><p>当<strong>组件从 DOM 中移除时</strong>会调用如下方法：</p><ul><li><strong><code>componentWillUnmount()</code></strong></li></ul><h4 id="常用的生命周期方法"><a href="#常用的生命周期方法" class="headerlink" title="常用的生命周期方法"></a>常用的生命周期方法</h4><h5 id="constructor-props"><a href="#constructor-props" class="headerlink" title="constructor(props)"></a>constructor(props)</h5><p><strong>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。</strong></p><p>在 React 组件挂载之前，会调用它的构造函数。在为 React.Component 子类实现构造函数时，应在其他语句之前调用 <code>super(props)</code>。否则，<code>this.props</code> 在构造函数中可能会出现未定义的 bug。</p><p>通常，在 React 中，构造函数仅用于以下两种情况：</p><ul><li>通过给 <code>this.state</code> 赋值对象来<strong>初始化内部 state</strong>。</li><li><strong>为事件处理函数绑定实例</strong>。</li></ul><h5 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h5><p><code>componentDidMount()</code> 会在<strong>组件挂载后（插入 DOM 树中）立即调用</strong>。</p><p><strong>依赖于 DOM 节点的初始化</strong>应该放在这里。如需<strong>通过网络请求获取数据</strong>，此处是实例化请求的好地方。</p><p>这个方法是<strong>比较适合添加订阅</strong>的地方。如果添加了订阅，请不要忘记在 <code>componentWillUnmount()</code> 里<strong>取消订阅</strong>。</p><p>你可以在 <code>componentDidMount()</code> 里**直接调用 <code>setState()</code>**。</p><p>它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。</p><p>如此保证了即使在 <code>render()</code> 两次调用的情况下，用户也不会看到中间状态。</p><h5 id="componentDidUpdate-prevProps-prevState-snapshot"><a href="#componentDidUpdate-prevProps-prevState-snapshot" class="headerlink" title="componentDidUpdate(prevProps, prevState, snapshot)"></a>componentDidUpdate(prevProps, prevState, snapshot)</h5><p><code>componentDidUpdate()</code> 会在<strong>更新后会被立即调用</strong>。首次渲染不会执行此方法。</p><p>当组件更新后，可以在此处对 DOM 进行操作。</p><p>如果你<strong>对更新前后的 props 进行了比较，也可以选择在此处进行网络请求</strong>。（例如，当 props 未发生变化时，则不会执行网络请求）。</p><p>你也可以在 <code>componentDidUpdate()</code> 中<strong>直接调用 <code>setState()</code><strong>，但请注意</strong>它必须被包裹在一个条件语句里</strong>，正如上述的例子那样进行处理，否则会导致死循环。</p><p>它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。</p><h5 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h5><p><code>componentWillUnmount()</code> 会在<strong>组件卸载及销毁之前直接调用</strong>。</p><p>在此方法中执行必要的清理操作，例如，<strong>清除 timer</strong>，<strong>取消网络请求</strong>或<strong>清除</strong>在 <code>componentDidMount()</code> 中创建的<strong>订阅</strong>等。</p><p><code>componentWillUnmount()</code> 中<strong>不应调用 <code>setState()</code><strong>，因为</strong>该组件将永远不会重新渲染</strong>。</p><p>组件实例卸载后，将永远不会再挂载它。</p><h4 id="不常用的生命周期方法"><a href="#不常用的生命周期方法" class="headerlink" title="不常用的生命周期方法"></a>不常用的生命周期方法</h4><p>本节中的生命周期方法并不太常用。它们偶尔会很方便，但是大部分情况下组件可能都不需要它们。</p><h5 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h5><p>根据 <code>shouldComponentUpdate()</code> 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。</p><p>默认行为是 <strong>state 每次发生变化组件都会重新渲染</strong>。大部分情况下，你应该遵循默认行为。</p><p><strong>当 props 或 state 发生变化时</strong>，<code>shouldComponentUpdate()</code> 会在渲染执行之前被调用。返回值默认为 true。</p><p>首次渲染或使用 <code>forceUpdate()</code> 时不会调用该方法。</p><p>此方法仅作为<strong>性能优化的方式</strong>而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。</p><p>你应该<strong>考虑使用内置的 <code>PureComponent</code> 组件</strong>，而不是手动编写 <code>shouldComponentUpdate()</code>。</p><p><code>PureComponent</code> 会<strong>对 props 和 state 进行浅层比较</strong>，并减少了跳过必要更新的可能性。</p><h2 id="Hook★"><a href="#Hook★" class="headerlink" title="Hook★"></a>Hook★</h2><blockquote><p>一系列以 <code>“use”</code> 作为开头的方法，它们提供了让你可以完全避开 <code>class式写法</code>，在函数式组件中完成生命周期、状态管理、逻辑复用等几乎全部组件开发工作的能力。</p></blockquote><h3 id="优势★"><a href="#优势★" class="headerlink" title="优势★"></a>优势★</h3><ul><li><strong>跨组件复用状态逻辑</strong>: 其实render props / <strong>HOC</strong> 也是为了复用，相比于它们，Hooks 作为官方的底层 API，最为轻量，而且改造成本小，不会影响原来的组件层次结构和传说中的<strong>嵌套地狱</strong>；</li><li>相比而言，<strong>类组件的实现更为复杂</strong><ul><li><strong>不同的生命周期会使逻辑变得分散且混乱，不易维护和管理</strong>；</li><li><strong>时刻需要关注this的指向问题</strong>；</li><li><strong>代码复用代价高</strong>，<strong>高阶组件</strong>的使用经常会使整个组件树变得臃肿；</li></ul></li><li><strong>状态与 UI 隔离</strong>: 正是由于 Hooks 的特性，状态逻辑会变成更小的粒度，并且极容易被抽象成一个<strong>自定义 Hooks</strong>，组件中的状态和 UI 变得更为清晰和隔离。</li></ul><p>长远来看，官方期望 Hook 能够成为人们编写 React 组件的主要方式。</p><p>目前暂时还没有对应不常用的 <code>getSnapshotBeforeUpdate</code>，<code>getDerivedStateFromError</code> 和 <code>componentDidCatch</code> 生命周期的 Hook 等价写法。</p><h3 id="Hook-规则"><a href="#Hook-规则" class="headerlink" title="Hook 规则"></a>Hook 规则</h3><h4 id="只在最顶层使用-Hook"><a href="#只在最顶层使用-Hook" class="headerlink" title="只在最顶层使用 Hook"></a>只在最顶层使用 Hook</h4><p><strong>不要在循环，条件或嵌套函数中调用 Hook，</strong> 确保总是在你的 <strong>React 函数的最顶层以及任何 return 之前调用他们</strong>。</p><p>遵守这条规则，你就能<strong>确保 Hook 在每一次渲染中都按照同样的顺序被调用</strong>。</p><p>这让 React 能够在多次的 <code>useState</code> 和 <code>useEffect</code> 调用之间保持 hook 状态的正确。</p><h4 id="只在-React-函数中调用-Hook"><a href="#只在-React-函数中调用-Hook" class="headerlink" title="只在 React 函数中调用 Hook"></a>只在 React 函数中调用 Hook</h4><p><strong>不要在普通的 JavaScript 函数中调用 Hook。</strong>你可以：</p><ul><li>在 <strong>React 的函数组件</strong>中调用 Hook</li><li>在<strong>自定义 Hook</strong> 中调用其他 Hook</li></ul><p>遵循此规则，<strong>确保组件的状态逻辑在代码中清晰可见</strong>。</p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>React 保持对当前渲染中的组件的追踪。</p><p>多亏了Hook 规范，我们得知 Hook 只会在 React 组件中被调用（或自定义 Hook —— 同样只会在 React 组件中被调用）。</p><p>每个组件内部都有一个「记忆单元格」列表。</p><p>它们只不过是我们用来存储一些数据的 JavaScript 对象。</p><p>当你用 <code>useState()</code> 调用一个 Hook 的时候，它会读取当前的单元格（或在首次渲染时将其初始化），然后把指针移动到下一个。这就是多个 <code>useState()</code> 调用会得到各自独立的本地 state 的原因。</p><h3 id="useState-★"><a href="#useState-★" class="headerlink" title="useState ★"></a>useState ★</h3><h4 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h4><blockquote><p>用于定义组件的 State，类似类定义中 <code>this.state</code> 的功能。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(initialState);</span><br></pre></td></tr></table></figure><ul><li><p><code>useState()</code> 方法里面唯一的参数<code>initialState</code>就是<strong>初始 state</strong>。</p><p>不同于 class 的是，我们可以按照需要使用数字或字符串对其进行赋值，而<strong>不一定是对象</strong>。</p></li><li><p>返回值为：<strong>当前 state</strong> 以及<strong>更新 state 的函数</strong>。</p><p>这与 class 里面 <code>this.state.count</code> 和 <code>this.setState</code> 类似，唯一区别就是你需要成对的获取它们。</p></li></ul><p><code>setState</code> 函数用于更新 state。它接收一个<strong>新的 state 值</strong>并将<strong>组件的一次重新渲染加入队列</strong>。</p><p>在后续的重新渲染中，<code>useState</code> 返回的第一个值将始终是<strong>更新后最新的 state</strong>。</p><blockquote><p>React 会确保 <code>setState</code> 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>setState</code>。</p></blockquote><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><h5 id="能用其他状态计算出来就不用单独声明状态-保证数据源唯一"><a href="#能用其他状态计算出来就不用单独声明状态-保证数据源唯一" class="headerlink" title="能用其他状态计算出来就不用单独声明状态 / 保证数据源唯一"></a>能用其他状态计算出来就不用单独声明状态 / 保证数据源唯一</h5><p>一个 state 必须不能通过其它 state/props 直接计算出来，否则就不用定义 state。</p><p>在项目中同一个数据，保证只存储在一个地方。</p><p>不要既存在 redux / 父级组件 / url query 中，又在组件中定义了一个 state 存储。</p><h5 id="useState-适当合并"><a href="#useState-适当合并" class="headerlink" title="useState 适当合并"></a>useState 适当合并</h5><p>如果我们想使用多个 state 变量，它允许我们<strong>给不同的 state 变量取不同的名称</strong>。</p><p>State 变量可以很好地存储<strong>对象和数组</strong>，因此，你仍然可以将<strong>相关数据</strong>分为一组。</p><p>然而，不像 class 中的 <code>this.setState</code>，<strong>更新 state 变量总是替换它而不是合并它</strong>。</p><p>同样含义的变量可以合并成一个 state，代码可读性会提升很多：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [userInfo, setUserInfo] = useState(&#123;</span><br><span class="line">  firstName,</span><br><span class="line">  lastName,</span><br><span class="line">  school,</span><br><span class="line">  age,</span><br><span class="line">  address</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [weather, setWeather] = useState();</span><br><span class="line"><span class="keyword">const</span> [room, setRoom] = useState();</span><br></pre></td></tr></table></figure><p>当然这种方式我们在变更变量时，一定不要忘记带上老的字段，比如我们只想修改 <code>firstName</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setUserInfo(<span class="function"><span class="params">s</span>=&gt;</span> (&#123;</span><br><span class="line">  ...s,</span><br><span class="line">  fristName,</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>其实如果是 React Class 组件，state 是会自动合并的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  firstName</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="函数式更新"><a href="#函数式更新" class="headerlink" title="函数式更新"></a>函数式更新</h5><p>如果新的 state 需要通过使用<strong>先前的 state</strong> 计算得出，那么可以将函数传递给 <code>setState</code>。</p><p>该函数将接收先前的 state，并返回一个更新后的值。下面的计数器组件示例展示了 <code>setState</code> 的两种用法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(initialCount);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      Count: &#123;count&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(initialCount)&#125;&gt;Reset<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“+” 和 “-” 按钮采用函数式形式，因为被更新的 state 需要基于之前的 state。</p><p>但是“重置”按钮则采用普通形式，因为它总是把 count 设置回初始值。</p><p>如果你的<strong>更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过</strong>。</p><p>与 class 组件中的 <code>setState</code> 方法不同，<code>useState</code> 不会自动合并更新对象。你可以用函数式的 <code>setState</code> 结合<strong>展开运算符</strong>来达到合并更新对象的效果。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(&#123;&#125;);</span><br><span class="line">setState(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 也可以使用 Object.assign</span></span><br><span class="line">  <span class="keyword">return</span> &#123;...prevState, ...updatedValues&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>useReducer</code> 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。</p><h5 id="惰性初始-state"><a href="#惰性初始-state" class="headerlink" title="惰性初始 state"></a>惰性初始 state</h5><p><code>initialState</code> 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。</p><p>如果初始 state 需要通过<strong>复杂计算</strong>获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> initialState = someExpensiveComputation(props);</span><br><span class="line">  <span class="keyword">return</span> initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="跳过-state-更新"><a href="#跳过-state-更新" class="headerlink" title="跳过 state 更新"></a>跳过 state 更新</h5><p>调用 State Hook 的更新函数并传入当前的 state 时，React 将跳过子组件的渲染及 effect 的执行。</p><p>（React 使用 <code>Object.is</code> 比较算法来比较 state。）</p><p>需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code> 来进行优化。</p><h3 id="useEffect-★"><a href="#useEffect-★" class="headerlink" title="useEffect ★"></a>useEffect ★</h3><blockquote><p>数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。不管你知不知道这些操作，或是“副作用”这个名字，应该都在组件中使用过它们。</p><p>如果你熟悉 React class 的生命周期函数，你可以把 <code>useEffect</code> Hook 看做 <code>componentDidMount</code>，<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 这三个函数的组合。</p><p>在 React 组件中有两种常见副作用操作：需要清除的和不需要清除的。我们来更仔细地看一下他们之间的区别。</p></blockquote><h4 id="无需清除的-effect"><a href="#无需清除的-effect" class="headerlink" title="无需清除的 effect"></a>无需清除的 effect</h4><p>有时候，我们只想<strong>在 React 更新 DOM 之后运行一些额外的代码。</strong>比如<strong>发送网络请求</strong>，<strong>手动变更 DOM</strong>，<strong>记录日志</strong>，这些都是常见的无需清除的操作。</p><p><strong><code>useEffect</code> 做了什么？</strong></p><p>通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行某些操作。</p><p>React 会<strong>保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它</strong>。</p><p><strong>为什么在组件内部调用 <code>useEffect</code>？</strong></p><p>将 <code>useEffect</code> 放在组件内部让我们可以在 effect 中直接访问 <code>state</code> 变量（或其他 <code>props</code>）。</p><p>我们不需要特殊的 API 来读取它 —— 它已经保存在函数作用域中。</p><p><strong>Hook使用了 JavaScript 的闭包机制</strong>，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。</p><p><strong><code>useEffect</code> 会在每次渲染后都执行吗？</strong></p><p>是的，默认情况下，它在<strong>第一次渲染之后</strong>和<strong>每次更新之后</strong>都会执行。</p><p>你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。</p><p>React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。</p><blockquote><p>与 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 不同，使用 <code>useEffect</code> 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 <code>useLayoutEffect</code> Hook 供你使用，其 API 与 <code>useEffect</code> 相同。</p></blockquote><h4 id="需要清除的-effect"><a href="#需要清除的-effect" class="headerlink" title="需要清除的 effect"></a>需要清除的 effect</h4><p>之前，我们研究了如何使用不需要清除的副作用，还有一些副作用是需要清除的。例如<strong>订阅外部数据源</strong>。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！</p><p><strong>为什么要在 effect 中返回一个函数？</strong></p><p>这是 effect 可选的清除机制。每个 effect 都可以返回一个<strong>清除函数</strong>。</p><p>如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</p><p><strong>React 何时清除 effect？</strong></p><p>React 会在<strong>组件卸载</strong>的时候执行清除操作。</p><p>正如之前学到的，effect 在每次渲染的时候都会执行。</p><p>这就是为什么 <strong>React 会在执行当前 effect 之前对上一个 effect 进行清除</strong>。</p><blockquote><p>并不是必须为 effect 中返回的函数命名。这里我们将其命名为 <code>cleanup</code> 是为了表明此函数的目的，但其实也可以返回一个箭头函数或者给起一个别的名字。</p></blockquote><h4 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h4><h5 id="使用多个-Effect-实现关注点分离"><a href="#使用多个-Effect-实现关注点分离" class="headerlink" title="使用多个 Effect 实现关注点分离"></a>使用多个 Effect 实现关注点分离</h5><p>使用 Hook 其中一个目的就是要<strong>解决 class 中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题</strong>。</p><p><strong>Hook 允许我们按照代码的用途分离他们，</strong> 而不是像生命周期函数那样。</p><p>React 将按照 effect 声明的顺序依次调用组件中的每一个 effect。</p><h5 id="通过跳过-Effect-进行性能优化"><a href="#通过跳过-Effect-进行性能优化" class="headerlink" title="通过跳过 Effect 进行性能优化"></a>通过跳过 Effect 进行性能优化</h5><p>在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题。</p><p>在 class 组件中，我们可以通过在 <code>componentDidUpdate</code> 中添加对 <code>prevProps</code> 或 <code>prevState</code> 的比较逻辑解决：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevState.count !== <span class="built_in">this</span>.state.count) &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;<span class="built_in">this</span>.state.count&#125;</span> times`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是很常见的需求，所以它被内置到了 <code>useEffect</code> 的 Hook API 中。</p><p>如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React <strong>跳过</strong>对 effect 的调用，只要传递数组作为 <code>useEffect</code> 的第二个可选参数即可：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// 仅在 count 更改时更新</span></span><br></pre></td></tr></table></figure><p>如果你要使用此优化方式，请确保数组中包含了<strong>所有外部作用域中会随时间变化并且在 effect 中使用的变量</strong>，否则你的代码会引用到<strong>先前渲染中的旧变量</strong>。</p><p>要记住 effect 外部的函数使用了哪些 props 和 state 很难。</p><p>这也是为什么 <strong>通常你会想要在 effect 内部去声明它所需要的函数。</strong></p><p><strong>只有</strong> 当函数（以及它所调用的函数）<strong>不引用 props、state 以及由它们衍生而来的值时</strong>，你才能放心地把它们从依赖列表中省略。</p><p><strong>如果出于某些原因你无法 把一个函数移动到 effect 内部，还有一些其他办法：</strong></p><ul><li><strong>你可以尝试把那个函数移动到你的组件之外</strong>。那样一来，这个函数就肯定不会依赖任何 props 或 state，并且也不用出现在依赖列表中了。</li><li>如果你所调用的方法是一个纯计算，并且可以在渲染时调用，你可以 <strong>转而在 effect 之外调用它，</strong> 并让 effect 依赖于它的返回值。</li><li>万不得已的情况下，你可以 <strong>把函数加入 effect 的依赖但把它的定义包裹</strong> 进 <code>useCallback</code>Hook。这就<strong>确保了它不随渲染而改变</strong>，除非它自身的依赖发生了改变。</li></ul><h5 id="如果我的-effect-的依赖频繁变化，我该怎么办？"><a href="#如果我的-effect-的依赖频繁变化，我该怎么办？" class="headerlink" title="如果我的 effect 的依赖频繁变化，我该怎么办？"></a>如果我的 effect 的依赖频繁变化，我该怎么办？</h5><p>有时候，你的 effect 可能会使用一些频繁变化的值。你可能会忽略依赖列表中 state，但这通常会引起 Bug：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>); <span class="comment">// 这个 effect 依赖于 `count` state</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, []); <span class="comment">// 🔴 Bug: `count` 没有被指定为依赖</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入空的依赖数组 <code>[]</code>，意味着该 hook <strong>只在组件挂载时运行一次，并非重新渲染时</strong>。</p><p>但如此会有问题，在 <code>setInterval</code> 的回调中，<code>count</code> 的值不会发生变化。</p><p>因为当 effect 执行时，我们会创建一个闭包，并将 <code>count</code> 的值被保存在该闭包当中，且初值为 <code>0</code>。</p><p>每隔一秒，回调就会执行 <code>setCount(0 + 1)</code>，因此，<code>count</code> 永远不会超过 1。</p><p>指定 <code>[count]</code> 作为依赖列表就能修复这个 Bug，但会导致每次改变发生时定时器都被重置。</p><p>事实上，每个 <code>setInterval</code> 在被清除前（类似于 <code>setTimeout</code>）都会调用一次。</p><p>但这并不是我们想要的。要解决这个问题，我们可以使用<code>setState</code> 的函数式更新形式。</p><p>它允许我们指定 state 该 如何改变而不用引用 当前state：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>); <span class="comment">// ✅ 在这不依赖于外部的 `count` 变量</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, []); <span class="comment">// ✅ 我们的 effect 不使用组件作用域中的任何变量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（<code>setCount</code> 函数的身份是被确保稳定的，所以可以放心的省略掉）</p><p>此时，<code>setInterval</code> 的回调依旧每秒调用一次，但每次 <code>setCount</code> 内部的回调取到的 <code>count</code> 是最新值（在回调中变量命名为 <code>c</code>）。</p><p>在一些更加复杂的场景中（比如一个 state 依赖于另一个 state），尝试用 <code>useReducer</code> Hook把 state 更新逻辑移到 effect 之外。</p><p><strong><code>useReducer</code> 的 <code>dispatch</code> 的身份永远是稳定的</strong> —— 即使 reducer 函数是定义在组件内部并且依赖 props。</p><p>万不得已的情况下，如果你想要类似 class 中的 <code>this</code> 的功能，你可以使用一个 <code>ref</code>来保存一个可变的变量。然后你就可以对它进行读写了。举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 把最新的 props 保存在一个 ref 中</span></span><br><span class="line">  <span class="keyword">const</span> latestProps = useRef(props);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    latestProps.current = props;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 在任何时候读取最新的 props</span></span><br><span class="line">      <span class="built_in">console</span>.log(latestProps.current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(tick, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, []); <span class="comment">// 这个 effect 从不会重新执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅当你实在找不到更好办法的时候才这么做，因为依赖于变更会使得组件更难以预测。</p><h5 id="自己理解"><a href="#自己理解" class="headerlink" title="自己理解"></a>自己理解</h5><p>依赖的值可以设置多个，只要有一个更新，就会执行effect。</p><p><strong>放到 deps 数组中的变量变化时，就会触发 useEffect 函数执行。</strong></p><ul><li>一种方法是在依赖中只放入需要触发函数执行的变量，选择性忽略 <code>eslint-plugin-react-hooks</code> 插件的警告。<code>// eslint-disable-next-line</code></li><li>另一种方法是在依赖中写全所有外部作用域中会随时间变化并且在 effect 中使用的变量，如果effect有条件触发，自己写if判断，而不是靠依赖数组。<strong>即具体逻辑是否执行应该在内部自己判断，而不是交给react。</strong></li></ul><h3 id="useRef-★"><a href="#useRef-★" class="headerlink" title="useRef ★"></a>useRef ★</h3><ul><li><p><strong>多次渲染之间保证唯一值的纽带</strong>。</p><p>useRef 会在所有的 render 中保持对返回值的唯一引用。因为所有对<code>ref</code>的赋值和取值拿到的都是最终的状态，并不会因为不同的 render 中存在不同的隔离。</p></li><li><p><strong>获取 Dom 元素</strong>，在 Function Component 中我们可以通过 useRef 来获取对应的 Dom 元素。</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = useRef(initialValue);</span><br></pre></td></tr></table></figure><p><code>useRef</code> 返回一个<strong>可变的 ref 对象</strong>，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。</p><p>返回的 ref 对象在组件的<strong>整个生命周期内</strong>持续存在。</p><p>一个常见的用例便是命令式地访问子组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span></span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputEl&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上，<code>useRef</code> 就像是可以在其 <code>.current</code> 属性中保存一个可变值的“盒子”。</p><p>你应该熟悉 ref 这一种访问 DOM的主要方式。</p><p>如果你将 ref 对象以 <code>&lt;div ref=&#123;myRef&#125; /&gt;</code> 形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 <code>.current</code> 属性设置为相应的 DOM 节点。</p><p>然而，<code>useRef()</code> 比 <code>ref</code> 属性更有用。它可以很方便地<strong>保存任何可变值</strong>，其类似于在 class 中使用实例字段的方式。</p><p>这是因为它创建的是一个<strong>普通Javascript 对象</strong>。</p><p>而 <code>useRef()</code> 和自建一个 <code>&#123;current: ...&#125;</code> 对象的唯一区别是，<code>useRef</code> 会在<strong>每次渲染时返回同一个 ref 对象</strong>。</p><h3 id="useCallback-★"><a href="#useCallback-★" class="headerlink" title="useCallback ★"></a>useCallback ★</h3><p>返回一个<code>memoized</code>回调函数。</p><p>把内联回调函数及依赖项数组作为参数传入 <code>useCallback</code>，它将返回该回调函数的 memoized 版本，<strong>该回调函数仅在某个依赖项改变时才会更新</strong>。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 <code>shouldComponentUpdate</code>）的子组件时，它将非常有用。</p><p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p><h4 id="关于使用"><a href="#关于使用" class="headerlink" title="关于使用"></a>关于使用</h4><p>在项目中不要随意useCallback，一些场景下，不仅没有提升性能，反而让代码可读性变的很差。</p><p>useCallback 可以记住函数，避免函数重复生成，这样函数在传递给子组件时，可以避免子组件重复渲染，提高性能。</p><p>但我们要注意，提高性能还必须有另外一个条件，子组件必须使用了 <code>shouldComponentUpdate</code> 或者 <code>React.memo</code> 来忽略同样的参数重复渲染。</p><h3 id="useMemo-★"><a href="#useMemo-★" class="headerlink" title="useMemo ★"></a>useMemo ★</h3><p>返回一个memoized 值。</p><p>把“创建”函数和依赖项数组作为参数传入 <code>useMemo</code>，它仅会在某个依赖项改变时才重新计算 memoized 值。</p><p>这种优化有助于避免在每次渲染时都进行高开销的计算。</p><p>记住，传入 <code>useMemo</code> 的函数会在<strong>渲染期间</strong>执行。</p><p>请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴，而不是 <code>useMemo</code>。</p><p>如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值。</p><p><strong>你可以把 <code>useMemo</code> 作为性能优化的手段，但不要把它当成语义上的保证。</strong></p><p><code>useMemo</code> Hook 使得控制具体子节点何时更新变得更容易，减少了对纯组件的需要。</p><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure><ul><li>ref 表示需要<strong>被赋值的 ref 对象</strong>。</li><li>createHandle 函数的<strong>返回值</strong>作为 <code>ref.current</code> 的值。</li><li>deps 依赖数组，依赖发生变化会重新执行 createHandle 函数。</li></ul><blockquote><p>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用。</p></blockquote><p>当然，在日常 React 开发中可能会存在这样一种情况。<strong>我们希望在父组件中调用子组件的方法</strong>，虽然 React 官方并不推荐这样声明式的写法，但是有时候我们不得不这样做。</p><h3 id="useContext-★"><a href="#useContext-★" class="headerlink" title="useContext ★"></a>useContext ★</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useContext(MyContext);</span><br></pre></td></tr></table></figure><p>接收一个 context 对象（<code>React.createContext</code> 的返回值）并返回该 context 的当前值。</p><p>当前的 context 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code> prop 决定。</p><p>当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>MyContext</code> provider 的 context <code>value</code> 值。</p><p>即使祖先使用 <code>React.memo</code>或 <code>shouldComponentUpdate</code>，也会在组件本身使用 <code>useContext</code> 时重新渲染。</p><p>别忘记 <code>useContext</code> 的参数必须是 <em>context 对象本身</em>：</p><ul><li><strong>正确：</strong> <code>useContext(MyContext)</code></li><li><strong>错误：</strong> <code>useContext(MyContext.Consumer)</code></li><li><strong>错误：</strong> <code>useContext(MyContext.Provider)</code></li></ul><p>调用了 <code>useContext</code> 的组件总会在 context 值变化时重新渲染。</p><p>如果重渲染组件的开销较大，你可以通过使用 memoization 来优化。==&gt; React.memo / useMemo</p><blockquote><p>提示</p><p>如果你在接触 Hook 前已经对 context API 比较熟悉，那应该可以理解，<code>useContext(MyContext)</code> 相当于 class 组件中的 <code>static contextType = MyContext</code> 或者 <code>&lt;MyContext.Consumer&gt;</code>。</p><p><code>useContext(MyContext)</code> 只是让你能够<em>读取</em> context 的值以及订阅 context 的变化。</p><p>你仍然需要在上层组件树中使用 <code>&lt;MyContext.Provider&gt;</code> 来为下层组件<em>提供</em> context。</p></blockquote><p><strong>把如下代码与 Context.Provider 放在一起</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> themes = &#123;</span><br><span class="line">  <span class="attr">light</span>: &#123;</span><br><span class="line">    <span class="attr">foreground</span>: <span class="string">&quot;#000000&quot;</span>,</span><br><span class="line">    <span class="attr">background</span>: <span class="string">&quot;#eeeeee&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">dark</span>: &#123;</span><br><span class="line">    <span class="attr">foreground</span>: <span class="string">&quot;#ffffff&quot;</span>,</span><br><span class="line">    <span class="attr">background</span>: <span class="string">&quot;#222222&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(themes.light);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;themes.dark&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Toolbar</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toolbar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ThemedButton</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemedButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> theme = useContext(ThemeContext);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">background:</span> <span class="attr">theme.background</span>, <span class="attr">color:</span> <span class="attr">theme.foreground</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">      I am styled by theme context!</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure><p><code>useState</code>的替代方案。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。）</p><p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 <strong>state 逻辑较复杂且包含多个子值</strong>，或者<strong>下一个 state 依赖于之前的 state</strong> 等。并且，使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数 。</p><h3 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h3><p>通过自定义 Hook，可以将<strong>组件逻辑</strong>提取到<strong>可重用的函数</strong>中。</p><p><strong>自定义 Hook 是一个函数，其名称以 “<code>use</code>” 开头，函数内部可以调用其他的 Hook。</strong></p><p><strong>自定义 Hook 必须以 “<code>use</code>” 开头吗？</strong></p><p>必须如此。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了<strong>Hook的规则</strong>。</p><p><strong>在两个组件中使用相同的 Hook 会共享 state 吗？</strong></p><p>不会。自定义 Hook 是一种<strong>重用状态逻辑</strong>的机制(例如设置为订阅并存储当前值)，所以<strong>每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的</strong>。</p><p>我们可以在一个组件中多次调用 <code>useState</code> 和 <code>useEffect</code>，它们是完全独立的。</p><h2 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h2><h3 id="React-PureComponent"><a href="#React-PureComponent" class="headerlink" title="React.PureComponent"></a>React.PureComponent</h3><p><code>React.Component</code> 是使用ES6 classes方式定义 React 组件的基类。</p><p><code>React.PureComponent</code> 与 <code>React.Component</code>很相似。</p><p>两者的区别在于 <code>React.Component</code>并未实现 <code>shouldComponentUpdate()</code>，而 <code>React.PureComponent</code> 中以<strong>浅层对比</strong> <code>prop</code> 和 <code>state</code> 的方式来实现了该函数。</p><p>如果赋予 React 组件相同的 props 和 state，<code>render()</code> 函数会渲染相同的内容，那么在某些情况下使用 <code>React.PureComponent</code> 可提高性能。</p><h3 id="React-memo-1"><a href="#React-memo-1" class="headerlink" title="React.memo"></a>React.memo</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = React.memo(<span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>React.memo</code> 为高阶组件。</p><p>如果你的组件在相同 <code>props</code> 的情况下渲染相同的结果，那么你可以通过将其包装在 <code>React.memo</code> 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。</p><p>这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p><p><code>React.memo</code> <strong>仅检查 props 变更</strong>。</p><p>如果函数组件被 <code>React.memo</code> 包裹，且其实现中拥有 <code>useState</code>，<code>useReducer</code>或 <code>useContext</code> 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。</p><p>默认情况下其只会对复杂对象做<strong>浅层对比</strong>，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p><h2 id="CSS-★"><a href="#CSS-★" class="headerlink" title="CSS ★"></a>CSS ★</h2><p>常见的<code>CSS</code>引入方式有以下：</p><ul><li>在组件内直接使用</li><li>组件中引入 .css 文件</li><li>组件中引入 .module.css 文件</li><li>CSS in JS</li></ul><h3 id="在组件内直接使用"><a href="#在组件内直接使用" class="headerlink" title="在组件内直接使用"></a>在组件内直接使用</h3><p>直接在组件中书写<code>css</code>样式，通过<code>style</code>属性直接引入。</p><p><code>css</code>属性需要转换成驼峰写法</p><p>这种方式优点：</p><ul><li>内联样式, 样式之间不会有冲突</li><li>可以动态获取当前state中的状态</li></ul><p>缺点：</p><ul><li>写法上都需要使用驼峰标识</li><li>某些样式没有提示</li><li>大量的样式, 代码混乱</li><li>某些样式无法编写(比如伪类/伪元素)</li></ul><h3 id="组件中引入css文件"><a href="#组件中引入css文件" class="headerlink" title="组件中引入css文件"></a>组件中引入css文件</h3><p>将<code>css</code>单独写在一个<code>css</code>文件中，然后在组件中直接引入。</p><p>这种方式存在不好的地方在于样式是全局生效，样式之间会互相影响。</p><h3 id="组件中引入-module-css-文件"><a href="#组件中引入-module-css-文件" class="headerlink" title="组件中引入 .module.css 文件"></a>组件中引入 .module.css 文件</h3><p>将<code>css</code>文件作为一个模块引入，这个模块中的所有<code>css</code>，只作用于当前组件。不会影响当前组件的后代组件。</p><p>这种方式是<code>webpack</code>特工的方案，只需要配置<code>webpack</code>配置文件中<code>modules:true</code>即可。</p><p>这种方式能够解决局部作用域问题，但也有一定的缺陷：</p><ul><li>引用的类名，不能使用连接符(.xxx-xx)，在 JavaScript 中是不识别的</li><li>所有的 className 都必须使用 {style.className} 的形式来编写</li><li>不方便动态来修改某些样式，依然需要使用内联样式的方式；</li></ul><h3 id="CSS-in-JS"><a href="#CSS-in-JS" class="headerlink" title="CSS in JS"></a>CSS in JS</h3><p>CSS-in-JS， 是指一种模式，其中<code>CSS</code>由 <code>JavaScript</code>生成而不是在外部文件中定义</p><p>此功能并不是 React 的一部分，而是由第三方库提供，例如：</p><ul><li>styled-components</li><li>emotion</li><li>glamorous</li></ul><p>下面主要看看<code>styled-components</code>的基本使用</p><p>本质是通过函数的调用，最终创建出一个组件：</p><ul><li>这个组件会被自动添加上一个不重复的class</li><li>styled-components会给该class添加相关的样式</li></ul><p>通过上面四种样式的引入，可以看到：</p><ul><li>在组件内直接使用<code>css</code>该方式编写方便，容易能够根据状态修改样式属性，但是大量的演示编写容易导致代码混乱</li><li>组件中引入 .css 文件符合我们日常的编写习惯，但是作用域是全局的，样式之间会层叠</li><li>引入.module.css 文件能够解决局部作用域问题，但是不方便动态修改样式，需要使用内联的方式进行样式的编写</li><li>通过css in js 这种方法，可以满足大部分场景的应用，可以类似于预处理器一样样式嵌套、定义、修改状态等</li></ul><p>至于使用<code>react</code>用哪种方案引入<code>css</code>，并没有一个绝对的答案，可以根据各自情况选择合适的方案</p><h1 id="React-Router★"><a href="#React-Router★" class="headerlink" title="React-Router★"></a>React-Router★</h1><blockquote><p>考察公司：百度、小米</p></blockquote><h2 id="v5-vs-v6-★"><a href="#v5-vs-v6-★" class="headerlink" title="v5 vs v6 ★"></a>v5 vs v6 ★</h2><h3 id="SPA的理解"><a href="#SPA的理解" class="headerlink" title="SPA的理解"></a>SPA的理解</h3><ul><li>单页Web应用（single page web application，SPA）。</li><li>整个应用只有<strong>一个完整的页面</strong>，点击页面中的链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部更新。</strong></li><li>数据都需要通过ajax请求获取, 并在前端异步展现。</li></ul><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>React Router v6 大量使用<code>React hooks</code>。官方明确推荐<strong>函数式组件</strong>了。</p><p><code>Routes</code>是以前 <code>Switch</code> 组件的升级版，它包括相对路由和链接、自动路由排名、嵌套路由和布局等功能。</p><p><code>component</code>重命名为<code>element</code>。</p><p>v6的<code>&lt;Routes&gt;</code>元素下的所有<code>&lt;Route path</code>&gt;和<code>&lt;Link to&gt;</code>值都是<strong>自动相对于它们的父路由渲染的</strong>，而且忽略当前URL中的尾部斜杠。头部斜杠代变绝对路径。</p><p>中小型项目<strong>嵌套路由可集中显示</strong>，在需要显示的地方使用<code>&lt;Outlet /&gt;</code>作为占位符。</p><p>若<strong>分别显示</strong>，具有后代路由（在其他组件中定义）的路由在其路径中使用尾随<code>*</code> 。</p><p>“默认子路由”：<code>index</code>（不写path）表示索引路由共享父路径。这就是重点——它没有路径。</p><p>“未找到”路由：<code>path=&#39;*&#39;</code>表示路径都不匹配时。具有最弱的优先级。</p><p>v6 提供了 <strong>Navigate</strong> 组件，以前版本中的<code>Redirect</code>组件也消失了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  根组件(函数式)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;login&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Login</span> /&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Admin</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">index</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;category&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Category</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;product&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Product</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">index</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ProductHome</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;detail&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ProductDetail</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;addupdate&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ProductAddUpdate</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;user&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">User</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;role&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Role</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;charts-bar&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Bar</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;charts-pie&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Pie</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;charts-line&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Line</span> /&gt;</span>&#125; /&gt;    </span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;/* 以上路径都不匹配时 */&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;*&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">NotFound</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后台管理的路由组件</span></span><br><span class="line"><span class="comment"> *  */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Admin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> user = memoryUtils.user</span><br><span class="line">    <span class="comment">// 如果内存没有存储user ==&gt; 当前没有登陆</span></span><br><span class="line">    <span class="keyword">if</span> (!user || !user._id) &#123;</span><br><span class="line">        <span class="comment">// 自动跳转到登陆(在render()中) Navigate替代Redirect</span></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&#x27;/login&#x27;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        ...     </span><br><span class="line">        &lt;Outlet /&gt;&#123;<span class="comment">/* 占位符 */</span>&#125;</span><br><span class="line">    	...</span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v6 <strong>无法直接访问history实例</strong>，将useHistory更改为 <strong>useNavigate</strong>（兼容性和体验）。</p><p>useNavigate返回一个函数用来实现编程式导航。<code>navigate(&#39;/&#39;, &#123; replace: true &#125;)</code></p><p>传入数值进行前进或后退，类似于5.x中的 history.go()方法 <code>navigate(-1)</code></p><p>v5:<strong>withRouter</strong>高阶组件:包装非路由组件, 返回一个新的组件，新的组件向非路由组件传递3个属性: <code>history/location/match</code></p><p>v6:<strong>非路由组件</strong>使用<code>useLocation</code>也可得到<code>location</code>对象，<code>withRouter</code>不再使用。<code>useLocation().pathname</code>得到当前路径名。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> location =useLocation();</span><br><span class="line"><span class="keyword">const</span> path = location.pathname;</span><br><span class="line"></span><br><span class="line"><span class="comment">// location对象</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">hash</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;hvfbi1fy&quot;</span></span><br><span class="line">    <span class="attr">pathname</span>: <span class="string">&quot;/role&quot;</span></span><br><span class="line">    <span class="attr">search</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">state</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>useRoutes</code>钩子是一个路由API，它允许你使用<strong>JavaScript对象</strong>而不是React元素来声明和组合路由。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> element = useRoutes([</span><br><span class="line">    <span class="comment">// 这些与您提供给 &lt;Route&gt; 的props相同</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;dashboard&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Dashboard</span> /&gt;</span></span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;invoices&quot;</span>,</span><br><span class="line">      <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Invoices</span> /&gt;</span></span>,</span><br><span class="line">      <span class="comment">// 嵌套路由使用 children 属性，这也与 &lt;Route&gt; 相同</span></span><br><span class="line">      children: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;:id&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Invoice</span> /&gt;</span></span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;sent&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">SentInvoices</span> /&gt;</span></span> &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Not found routes work as you&#x27;d expect</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;*&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">NotFound</span> /&gt;</span></span> &#125;,</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回的元素将呈现整个元素层次结构及其所需的所有适当上下文</span></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Link</strong></p><p>标签体内容也是一种特殊的标签属性。</p><p>在 v5 中，不以 / 开头的 <code>&lt;Link to&gt;</code> 值是不明确的； 这取决于当前的 URL 是什么。 例如，如果当前 URL 是 /users，则 v5 <code>&lt;Link to=&quot;me&quot;&gt;</code> 将呈现 <code>&lt;a href=&quot;/me&quot;&gt;</code>。 但是，如果当前 URL 有一个结尾斜杠，例如 /users/，则相同的 <code>&lt;Link to=&quot;me&quot;&gt;</code> 将呈现 <code>&lt;a href=&quot;/users/me&quot;&gt;</code>。 这使得很难预测链接的行为方式，因此在 v5 中，我们建议您从根 URL（使用 match.url）构建链接，而不是使用相对的 <code>&lt;Link to&gt;</code> 值。</p><p>React Router v6 修复了这种歧义。 在 v6 中，<code>&lt;Link to=&quot;me&quot;&gt;</code> 将始终呈现相同的 <code>&lt;a href&gt;</code>，而不管当前的 URL。</p><p>例如，在 <code>&lt;Route path=&quot;users&quot;&gt;</code> 中呈现的 <code>&lt;Link to=&quot;me&quot;&gt;</code> 将始终呈现指向 /users/me 的链接，无论当前 URL 是否具有尾部斜杠。</p><p>当您想“向上”链接回父路由时，请在 <code>&lt;Link to&gt;</code> 值中使用前导 <code>..</code> 段，类似于您在 <code>&lt;a href&gt;</code> 中所做的。</p><h3 id="路由参数传递"><a href="#路由参数传递" class="headerlink" title="路由参数传递"></a>路由参数传递</h3><h4 id="param参数"><a href="#param参数" class="headerlink" title="param参数"></a>param参数</h4><ul><li>在<code>Route组件</code>中的<code>path属性</code>中定义路径参数</li><li>在组件内通过<code>useParams</code> hook访问路径参数</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义参数</span></span><br><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/foo/:id&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;Foo&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line">&lt;/BrowserRouter&gt;</span><br><span class="line"><span class="comment">// 传递参数</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">LinkButton</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> navigate(`foo/$&#123;product.id&#125;`)&#125; &gt;</span></span><br><span class="line"><span class="xml">    修改</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">LinkButton</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 提取参数</span></span><br><span class="line"><span class="keyword">import</span> &#123; useParams &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> params = useParams();</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;params.id&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>个人理解：param参数适合想要在路由地址显示参数时使用，且传递参尽可能少。</strong></p><p><strong>useMatch</strong>()</p><ol><li><p>作用：返回当前匹配信息，对标5.x中的路由组件的<code>match</code>属性。</p></li><li><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/login/:page/:pageSize&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Login</span> /&gt;</span></span>&#125;/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;/login/1/10&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Login</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> match = useMatch(<span class="string">&#x27;/login/:x/:y&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(match) <span class="comment">//输出match对象</span></span><br><span class="line">  <span class="comment">//match对象内容如下：</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  	&#123;</span></span><br><span class="line"><span class="comment">      params: &#123;x: &#x27;1&#x27;, y: &#x27;10&#x27;&#125;</span></span><br><span class="line"><span class="comment">      pathname: &quot;/LoGin/1/10&quot;  </span></span><br><span class="line"><span class="comment">      pathnameBase: &quot;/LoGin/1/10&quot;</span></span><br><span class="line"><span class="comment">      pattern: &#123;</span></span><br><span class="line"><span class="comment">      	path: &#x27;/login/:x/:y&#x27;, </span></span><br><span class="line"><span class="comment">      	caseSensitive: false, </span></span><br><span class="line"><span class="comment">      	end: false</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  	<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="search参数-amp-sate参数"><a href="#search参数-amp-sate参数" class="headerlink" title="search参数&amp;sate参数"></a>search参数&amp;sate参数</h4><p>Location：这是一个 React Router 特定的对象，它基于内置浏览器的 window.location 对象。</p><p>您可以设置<code>location state</code>在<code>&lt;Link&gt;</code>上或<code>navigate</code>上，在下一路由组件中你可以用<code>useLocation</code>来访问它。</p><p><code>useLocation()</code>既可以获得<code>state</code>参数，也可以获得<code>search</code>参数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinkButton onClick=&#123;<span class="function">() =&gt;</span> navigate(<span class="string">&#x27;addupdate?name=tom&amp;age=18&#x27;</span>, &#123; <span class="attr">state</span>: product &#125;)&#125; &gt;</span><br><span class="line">    修改</span><br><span class="line">&lt;/LinkButton&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isUpdate = location.state</span><br><span class="line"><span class="keyword">const</span> search = location.search</span><br><span class="line"><span class="built_in">console</span>.log(search) <span class="comment">// ?name=tom&amp;age=18</span></span><br><span class="line"><span class="built_in">console</span>.log(isUpdate) <span class="comment">// &#123;status: 1, imgs: Array(2), _id: &#x27;5e12b97de31bb727e4b0e349&#x27;, name: &#x27;联想ThinkPad 翼4809&#x27;, desc: &#x27;年度重量级新品，X390、T490全新登场 更加轻薄机身设计9&#x27;, …&#125;</span></span><br></pre></td></tr></table></figure><p><strong>个人理解：state参数适合传js对象。</strong></p><p><code>search</code>参数一般使用<code>useSearchParams()</code>进行获取和修改。</p><ol><li>作用：用于读取和修改当前位置的 URL 中的查询字符串。</li><li>返回一个包含两个值的数组，内容分别为：当前的seaech参数、更新search的函数。</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [search,setSearch] = useSearchParams()</span><br><span class="line"><span class="keyword">const</span> age = search.get(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> name = search.get(<span class="string">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>个人理解：search参数适合传可能会被修改的参数。</strong></p><h2 id="v5-底层原理-★"><a href="#v5-底层原理-★" class="headerlink" title="v5 底层原理 ★"></a>v5 底层原理 ★</h2><h3 id="react-router-dom和react-router和history库三者什么关系"><a href="#react-router-dom和react-router和history库三者什么关系" class="headerlink" title="react-router-dom和react-router和history库三者什么关系"></a>react-router-dom和react-router和history库三者什么关系</h3><p><code>history</code> 可以理解为<code>react-router</code>的核心，也是整个路由原理的核心，里面集成了<code>popState,history.pushState</code>等底层路由实现的原理方法，接下来我们会一一解释。</p><p><code>react-router</code>可以理解为是<code>react-router-dom</code>的核心，里面封装了<code>Router，Route，Switch</code>等核心组件,实现了从路由的改变到组件的更新的核心功能,在我们的项目中只要一次性引入<code>react-router-dom</code>就可以了。</p><p><strong>react-router-dom</strong>,在react-router的核心基础上，添加了用于跳转的Link组件，和histoy模式下的BrowserRouter和hash模式下的HashRouter组件等。所谓<strong>BrowserRouter和HashRouter，也只不过用了history库中createBrowserHistory和createHashHistory方法</strong>。</p><h3 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h3><p><a target="_blank" rel="noopener" href="https://imgse.com/i/vXyD5n"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/09/12/vXyD5n.png" alt="vXyD5n.png"></a></p><p>单页面应用路由实现原理是，切换url，监听url变化，从而渲染不同的页面组件。</p><p>主要的方式有<code>history</code>模式和<code>hash</code>模式。</p><h4 id="history模式原理"><a href="#history模式原理" class="headerlink" title="history模式原理"></a>history模式原理</h4><h5 id="改变路由"><a href="#改变路由" class="headerlink" title="改变路由"></a>改变路由</h5><p><strong>history.pushState</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(state,title,path)</span><br></pre></td></tr></table></figure><ul><li><p><code>state</code>：一个与指定网址相关的状态对象， popstate 事件触发时，该对象会传入回调函数。如果不需要可填 null。</p></li><li><p><code>title</code>：新页面的标题，但是所有浏览器目前都忽略这个值，可填 null。</p></li><li><p><code>path</code>：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个地址。</p></li></ul><p><strong>history.replaceState</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.replaceState(state,title,path)</span><br></pre></td></tr></table></figure><p>参数和<code>pushState</code>一样，这个方法会修改当前的<code>history</code>对象记录， <code>history.length</code> 的长度不会改变。</p><h5 id="监听路由"><a href="#监听路由" class="headerlink" title="监听路由"></a>监听路由</h5><p>popstate事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;popstate&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 监听改变 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>同一个文档的 <code>history</code> 对象出现变化时，就会触发<code>popstate</code> 事件。</p><p><code>history.pushState</code> 可以使浏览器地址改变，但是无需刷新页面。</p><p><strong>注意⚠️的是：用 <code>history.pushState()</code> 或者 <code>history.replaceState()</code> 不会触发 <code>popstate</code> 事件</strong>。</p><p><code>popstate</code> 事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮或者调用 <code>history.back()、history.forward()、history.go()</code>方法。</p><p>前进后退底层是一种栈的结构。</p><h4 id="hash模式原理"><a href="#hash模式原理" class="headerlink" title="hash模式原理"></a>hash模式原理</h4><h5 id="改变路由-1"><a href="#改变路由-1" class="headerlink" title="改变路由"></a>改变路由</h5><p><strong>window.location.hash</strong></p><p>通过<code>window.location.hash</code>属性获取和设置 <code>hash</code>值。</p><h5 id="监听路由-1"><a href="#监听路由-1" class="headerlink" title="监听路由"></a>监听路由</h5><p><strong>onhashchange</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 监听改变 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><code>history</code>提供了核心api，如监听路由，更改路由的方法，以及保存路由状态state。</p><p><code>react-router</code>提供路由渲染组件，路由唯一性匹配组件，重定向组件等功能组件。</p><blockquote><p>当地址栏改变url，组件的更新渲染都经历了什么？</p></blockquote><p>拿history模式做参考。当url改变，首先触发histoy，调用事件监听<code>popstate</code>事件， 触发回调函数<code>handlePopState</code>，触发history下面的<code>setstate</code>方法，产生新的location对象，然后通知Router组件更新<code>location</code>并通过<code>context</code>上下文传递，<code>switch</code>通过传递的更新流，匹配出符合的Route组件渲染，最后有<code>Route</code>组件取出<code>context</code>内容，传递给渲染页面，渲染更新。</p><blockquote><p>当我们调用<code>history.push</code>方法，切换路由，组件的更新渲染又都经历了什么呢？</p></blockquote><p>我们还是拿history模式作为参考，当我们调用<code>history.push</code>方法，首先调用history的<code>push</code>方法，通过<code>history.pushState</code>来改变当前<code>url</code>，接下来触发history下面的<code>setState</code>方法，接下来的步骤就和上面一模一样了，这里就不一一说了。</p><p><a target="_blank" rel="noopener" href="https://imgse.com/i/vXyWb4"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/09/12/vXyWb4.png" alt="vXyWb4.png"></a></p><h2 id="Router两种模式-★"><a href="#Router两种模式-★" class="headerlink" title="Router两种模式 ★"></a>Router两种模式 ★</h2><p>HashRouter :hash模式</p><p>BrowserRouter: history模式</p><h3 id="Router内部原理"><a href="#Router内部原理" class="headerlink" title="Router内部原理"></a>Router内部原理</h3><p>Router 组件：包裹整个应用，一个 React 应用只需要使用一次</p><p>两种常用 Router：<code>HashRouter</code> 和 <code>BrowserRouter</code></p><ul><li>HashRouter：使用 URL 的哈希值实现<ul><li>原理：监听 window 的 <code>hashchange</code> 事件来实现的</li></ul></li><li>（推荐）BrowserRouter：使用 H5 的 history.pushState() API 实现<ul><li>原理：监听 window 的 <code>popstate</code> 事件来实现的</li></ul></li></ul><h3 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h3><blockquote><p>这一种很自然，比如 <code>/</code> 对应 <code>Home页</code> ，<code>/about</code> 对应 <code>About 页</code>，但是<code>这样的设计需要服务器端渲染</code>，因为<code>用户可能直接访问任何一个 URL，服务器端必须能对 /的访问返回 HTML，也要对 /about的访问返回 HTML</code>。BrowserRouter支持这种URL。</p></blockquote><p>①基于<code>history</code>模式：页面跳转原理是使用了HTML5为浏览器全局的history对象新增了两个API，包括 history.pushState、history.replaceState；和vue router的history模式实现一致<br>②更加优雅： 直接拼接路径；如：<code>www.abc.com/xx</code><br>③<strong>后端需做请求处理</strong>： 切换路由后，请求接口路径会发生变化，后端需要配合，做处理</p><h3 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h3><blockquote><p>这一种看起来不自然，但是实现更简单。</p><p><code>只有一个路径 /，通过 URL 后面的 # 部分来决定路由</code>，<code>/#/</code> 对应 Home 页，<code>/#/about</code> 对应 About 页。</p><p>因为URL中<code>#</code>之后的部分是不会发送给服务器的，所以，<code>无论哪个 URL，最后都是访问服务器的 / 路径，服务器也只需要返回同样一份 HTML</code>就可以，<code>然后由浏览器端解析#后的部分，完成浏览器端渲染</code>。HashRouter支持这种URL。</p></blockquote><p>①<strong>基于hash模式</strong>：页面跳转原理是使用了location.hash、location.replace；和vue router的hash模式实现一致。<br>②<strong>比较丑</strong>：在域名后，先拼接<code>/#</code>，再拼接路径；也就是利用锚点，实现路由的跳转；如：<code>www.abc.com/#/xx</code></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><strong>HashRouter</strong>：<strong>项目部署在内网</strong>：如To B的项目、本公司业务人员用的项目等等。</p><p><strong>BrowserRouter</strong>：<strong>项目部署在公网</strong>：如To C的项目、面向大众的项目，url路径美观点当然更好，但后端需要做处理。</p><h2 id="v6底层原理"><a href="#v6底层原理" class="headerlink" title="v6底层原理"></a>v6底层原理</h2><h3 id="新版-Route-设计"><a href="#新版-Route-设计" class="headerlink" title="新版 Route 设计"></a>新版 Route 设计</h3><p>老版本的路由，核心的组件是 **<code>Route</code>**，之前的路由原理文章中介绍过，Route 内部通过消费 context 方式，当路由改变的时候，消费 context 的 Route 会重新渲染，内部通过 match 匹配到当前的路由组件是否挂载，那么就是说真正去匹配，去挂载的核心组件为 Route。</p><p>而在新版本的 Route 中，对于路由更新，到路由匹配，再到渲染真正的页面组件，这些逻辑主要交给了 <code>Routes</code> ，而且加了一个 <code>branch</code> ‘分支’ 的概念。可以把新版本的路由结构理解一颗分层级的树状结构，也就是当路由变化的时候，会在 Routes 会从路由结构树中，找到需要渲染 branch 分支。此时的 Route 组件的主要目的仅仅是形成这个路由树结构中的每一个节点，但是没有真正的去渲染页面。</p><p>新版本的路由可以说把路由从业务组件中解耦出来，路由的配置不在需要制定的业务组件内部，而是通过外层路由结构树统一处理。对于视图则是通过 <code>OutletContext</code> 来逐层传递，接下来我们一起来看一下细节。</p><h3 id="外层容器，更新源泉-BrowserRouter-HashRouter-｜-Router"><a href="#外层容器，更新源泉-BrowserRouter-HashRouter-｜-Router" class="headerlink" title="外层容器，更新源泉 BrowserRouter | HashRouter ｜ Router"></a>外层容器，更新源泉 BrowserRouter | HashRouter ｜ Router</h3><p>在新版本的路由中，对于外层的 Router 组件和老版本的有所差别。以 BrowserRouter 为例子，先看一下老版本。</p><p><strong>老版本的 BrowserRouter</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createBrowserHistory <span class="keyword">as</span> createHistory &#125; <span class="keyword">from</span> <span class="string">&quot;history&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserRouter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  history = createHistory(<span class="built_in">this</span>.props) </span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;this.history&#125;</span> <span class="attr">children</span>=<span class="string">&#123;this.props.children&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>老版本的 BrowserRouter 就是通过 <code>createHistory</code> 创建 <code>history</code> 对象，然后传递给 Router 组件。</li></ul><p>接下来就是新版本的 BrowserRouter， 做了哪些事情呢？</p><blockquote><p>react-router-dom/index.tsx</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">export function BrowserRouter(&#123;</span><br><span class="line">  basename,</span><br><span class="line">  children,</span><br><span class="line">  window</span><br><span class="line">&#125;: BrowserRouterProps) &#123;</span><br><span class="line">  /* 通过 useRef 保存 history 对象  */</span><br><span class="line">  let historyRef = React.useRef&lt;BrowserHistory&gt;();</span><br><span class="line">  if (historyRef.current == null) &#123;</span><br><span class="line">    historyRef.current = createBrowserHistory(&#123; window &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let history = historyRef.current;</span><br><span class="line">  let [state, setState] = React.useState(&#123;</span><br><span class="line">    action: history.action,</span><br><span class="line">    location: history.location</span><br><span class="line">  &#125;);</span><br><span class="line">  /* history 变化，通知更新。 */</span><br><span class="line">  React.useLayoutEffect(() =&gt; history.listen(setState), [history]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Router</span><br><span class="line">      basename=&#123;basename&#125;</span><br><span class="line">      children=&#123;children&#125;</span><br><span class="line">      location=&#123;state.location&#125;</span><br><span class="line">      navigationType=&#123;state.action&#125;</span><br><span class="line">      navigator=&#123;history&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新版本的 BrowserRouter 的功能如下：</p><ul><li>通过 <code>createBrowserHistory</code> 创建 <code>history</code> 对象，并通过 <code>useRef</code> 保存 history 对象。</li><li>通过 <code>useLayoutEffect</code> 来监听 <code>history</code> 变化，当 history 发生变化（浏览器人为输入，获取 a 标签跳转，api 跳转等 ）。派发更新，渲染整个 router 树。<strong>这是和老版本的区别，老版本里面，监听路由变化更新组件是在 Router 中进行的。</strong></li><li>还有一点注意的事，在老版本中，有一个 <code>history</code> 对象的概念，新版本中把它叫做 <code>navigator</code> 。</li></ul><p>接下来分析一下新版本 Router 做了哪些事。</p><blockquote><p>react-router/index.tsx</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Router</span>(<span class="params">&#123;basename,children,location:locationProp,navigator&#125;</span>)</span>&#123;</span><br><span class="line">  <span class="comment">/* 形成 navigationContext 对象   保存 basename ， navigator 对象等信息。*/</span></span><br><span class="line">  <span class="keyword">let</span> navigationContext = React.useMemo(</span><br><span class="line">    <span class="function">() =&gt;</span> (&#123; basename, navigator, <span class="attr">static</span>: staticProp &#125;),</span><br><span class="line">    [basename, navigator, staticProp]</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">/* 把 location 里面的状态结构出来  */</span></span><br><span class="line">  <span class="keyword">const</span> &#123; pathname, search, hash, state, key &#125; = locationProp</span><br><span class="line">  <span class="comment">/* 形成 locationContext 对象，保存 pathname，state 等信息。 */</span></span><br><span class="line">  <span class="keyword">let</span> location = React.useMemo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* .... */</span></span><br><span class="line">     <span class="keyword">return</span> &#123; pathname, search, hash, state, key  &#125;</span><br><span class="line">  &#125;,[basename, pathname, search, hash, state, key])</span><br><span class="line">  <span class="comment">/* 通过 context 分别传递 navigationContext 和 locationContext */</span></span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">NavigationContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;navigationContext&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">LocationContext.Provider</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">children</span>=<span class="string">&#123;children&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">location</span>, <span class="attr">navigationType</span> &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">      /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">NavigationContext.Provider</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Router</code></strong> 在新版路由中充当的角色如下：</p><ul><li>通过 useMemo 来派生出负责跳转路由等功能的 navigator 对象和路由信息的 location 对象。通过 React context 来传递它们。</li><li>当路由变化时候，在 <code>BrowserRouter</code> 中通过 useState 改变 location ，那么当 location 变化的时候，<code>LocationContext</code> 发生变化，消费 LocationContext 会更新。</li></ul><h3 id="原理深入，Routes-和-branch-概念"><a href="#原理深入，Routes-和-branch-概念" class="headerlink" title="原理深入，Routes 和 branch 概念"></a>原理深入，Routes 和 branch 概念</h3><p>上述我们拿 BrowserRouter 为例子，讲解了外层容器做了哪些事。我们继续深入探秘，看一下 routes 内部做了什么事，还有如何形成的路由的层级结构。以及路由跳转，到对应页面呈现的流程。</p><p>以如下例子为参考：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Routes&gt;</span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; path=&quot;/home&quot; /&gt;</span></span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">List</span>/&gt;</span>&#125;  path=&quot;/list&quot; /&gt;</span></span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Layout</span>/&gt;</span>&#125; path=&quot;/children&quot; &gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Child1</span>/&gt;</span>&#125; path=&quot;/children/child1&quot; /&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Child2</span>/&gt;</span>&#125; path=&quot;/children/child2&quot; /&gt;</span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/Routes&gt;</span><br></pre></td></tr></table></figure><p>我们带着两个问题去思考。</p><ul><li>如果当前 <code>pathname</code> 为 <code>/home</code>，那么整个路由如何展示 Home 组件的。</li><li>如果切换路由为 <code>/children/child1</code>，那么从页面更新到呈现的流程是怎么样的。又如何在 <code>Layout</code> 内部渲染的 <code>Child1</code> 。</li></ul><h4 id="Route-和-Routes-形成路由结构"><a href="#Route-和-Routes-形成路由结构" class="headerlink" title="Route 和 Routes 形成路由结构"></a>Route 和 Routes 形成路由结构</h4><p>上面我们讲到过，新版的 Route 必须配合上 Routes 联合使用。老版本 Route 至关重要，负责匹配和更新容器，<strong>那么新版本 Route 又做了哪些事呢？</strong></p><blockquote><p>react-router/index.tsx</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Route</span>(<span class="params">_props</span>)</span>&#123;</span><br><span class="line">  invariant(</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    <span class="string">`A &lt;Route&gt; is only ever to be used as the child of &lt;Routes&gt; element, `</span> +</span><br><span class="line">      <span class="string">`never rendered directly. Please wrap your &lt;Route&gt; in a &lt;Routes&gt;.`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚看到 Route 的同学，可能会发懵，里面没有任何的逻辑，只有一个 <code>invariant</code> 提示。这可能会颠覆很多同学的认识，Route 组件不是常规的组件，可以理解成一个空函数。如果是正常按照组件挂载方式处理，那么肯定会报错误，那么我们写的 <code>&lt;Route&gt;</code> 是怎么处理的呢？ 实际上一切处理的源头就在 Routes 这个组件，它的作用就是根据路由的变化，匹配出一个正确的渲染分支 branch 。</p><p>那么 Routes 就是我们需要重点研究的对象。</p><h4 id="Routes-和-useRoutes"><a href="#Routes-和-useRoutes" class="headerlink" title="Routes 和 useRoutes"></a>Routes 和 useRoutes</h4><p>首先来看一下 <code>Routes</code> 的实现：</p><blockquote><p>react-router/index.tsx</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Routes</span>(<span class="params">&#123;children,location &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useRoutes(createRoutesFromChildren(children), location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 <code>&lt;Routes /&gt;</code> 的时候，本质上是通过 useRoutes 返回的 react element 对象，那么可以理解成此时的 useRoutes 作为一个视图层面意义上的 <code>hooks</code> 。 Routes 本质上就是使用 useRoutes 。</li></ul><p>上面我们讲到了，如果可以用 useRoutes ，可以直接把 route 配置结构变成 element 结构，并且负责展示路由匹配的路由组件，那么 useRoutes 就是整个路由体系核心。</p><p>在弄清楚 useRoutes 之前我们先来明白 <strong><code>createRoutesFromChildren</code></strong> 做了些什么？</p><blockquote><p>react-router/index.tsx -&gt; createRoutesFromChildren</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function createRoutesFromChildren(children) &#123; /* 从把 变成层级嵌套结构  */</span><br><span class="line">  let routes = [];</span><br><span class="line">  Children.forEach(children, element =&gt; &#123;</span><br><span class="line">    /* 省略 element 验证，和 flagement 处理逻辑 */</span><br><span class="line">    let route = &#123;</span><br><span class="line">      caseSensitive: element.props.caseSensitive,  // 区分大小写</span><br><span class="line">      element: element.props.element,              // element 对象 </span><br><span class="line">      index: element.props.index,                  // 索引 index </span><br><span class="line">      path: element.props.path                     // 路由路径 path</span><br><span class="line">    &#125;;</span><br><span class="line">    if (element.props.children) &#123;</span><br><span class="line">      route.children = createRoutesFromChildren(element.props.children);</span><br><span class="line">    &#125;</span><br><span class="line">    routes.push(route);</span><br><span class="line">  &#125;);</span><br><span class="line">  return routes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>createRoutesFromChildren 内部通过 React.Children.forEach 把 Route 组件给结构化，并且内部调用递归，深度递归 children 结构。</li></ul><p><code>createRoutesFromChildren</code> 可以把 <code>&lt;Route&gt;</code> 类型的 react element 对象，变成了普通的 route 对象结构。我们上面说过了 Route 本质是一个空函数，并没有实际挂载，所以是通过 createRoutesFromChildren 处理转化了。</p><p>比如如下的结构:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Routes&gt;</span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; path=&quot;/home&quot; /&gt;</span></span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">List</span>/&gt;</span>&#125;  path=&quot;/list&quot; /&gt;</span></span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Layout</span>/&gt;</span>&#125; path=&quot;/children&quot; &gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Child1</span>/&gt;</span>&#125; path=&quot;/children/child1&quot; /&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Child2</span>/&gt;</span>&#125; path=&quot;/children/child2&quot; /&gt;</span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/Routes&gt;</span><br></pre></td></tr></table></figure><p>element 会被转化成如下结构：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8f0205f211d4df49fdb9587f0e0153b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="10.jpg"></p><p>接下来暴露的重点就是 <strong>useRoute</strong> ，似乎从路由挂载，再到切换路由重新渲染，都和它有关系。那么接下来重点看一下这个自定义 hooks。</p><blockquote><p>react-router/useRoutes</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useRoutes</span>(<span class="params">routes, locationArg</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> locationFromContext = useLocation();</span><br><span class="line">   <span class="comment">/* <span class="doctag">TODO:</span> 第一阶段：计算 pathname  */</span></span><br><span class="line">   <span class="comment">// ...代码省略</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* <span class="doctag">TODO:</span> 第二阶段：找到匹配的路由分支  */</span></span><br><span class="line">  <span class="keyword">let</span> matches = matchRoutes(routes, &#123;</span><br><span class="line">    <span class="attr">pathname</span>: remainingPathname</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;----match-----&#x27;</span>,matches)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> 第三阶段：渲染对应的路由组件 */</span></span><br><span class="line">  <span class="keyword">return</span> _renderMatches(matches &amp;&amp; matches.map(<span class="function"><span class="params">match</span> =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, match, &#123;</span><br><span class="line">    <span class="attr">params</span>: <span class="built_in">Object</span>.assign(&#123;&#125;, parentParams, match.params),</span><br><span class="line">    <span class="attr">pathname</span>: joinPaths([parentPathnameBase, match.pathname]),</span><br><span class="line">    <span class="attr">pathnameBase</span>: match.pathnameBase === <span class="string">&quot;/&quot;</span> ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])</span><br><span class="line">  &#125;)), parentMatches);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是 v6 路由比较核心的一部分，为了加强理解，我把它分成三个阶段。</p><ul><li><strong>第一阶段 ，生成对应的 pathname</strong> ：还是以上面的 demo 为例子，比如切换路由 <code>/children/child1</code>，那么 pathname 就是 <code>/children/child1</code>。</li><li><strong>第二阶段，通过 <code>matchRoutes</code>，找到匹配的路由分支。</strong>，什么叫做匹配的路由分支呢，比如上面的切换路由到 <code>/children/child1</code>，那么明显是一个二级路由，那么它的路由分支就应该是 root -&gt; children -&gt; child1。 我们打印 matches 看一下数据结构。</li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e71520c097944b80bc55efb76a4c8348~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="11.jpg"></p><ul><li>还有一点就是 <code>useRoutes</code> 内部用了 <code>useLocation</code>。 当 location 对象变化的时候，useRoutes 会重新执行渲染。</li></ul><p>通过上面可以看到，matches 为扁平化后匹配的路由结构，是一个数组结构，那么索引 0 为第一层路由，索引 1 为第二层路由。那么来看一下 <strong>matchRoutes</strong> 的实现。</p><h4 id="matchRoutes-和-renderMatches-渲染路由分支"><a href="#matchRoutes-和-renderMatches-渲染路由分支" class="headerlink" title="matchRoutes 和 _renderMatches 渲染路由分支"></a>matchRoutes 和 _renderMatches 渲染路由分支</h4><blockquote><p>react-router/index.tsx -&gt; matchRoutes</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchRoutes</span>(<span class="params">routes,locationArg,basename</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 扁平化 routes 结构 */</span></span><br><span class="line">    <span class="keyword">let</span> branches = flattenRoutes(routes);</span><br><span class="line">    <span class="comment">/* 排序 route */</span></span><br><span class="line">    rankRouteBranches(branches);</span><br><span class="line">    <span class="keyword">let</span> matches = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/* 通过 matchRouteBranch  */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; matches == <span class="literal">null</span> &amp;&amp; i &lt; branches.length; ++i) &#123;</span><br><span class="line">      matches = matchRouteBranch(branches[i], pathname);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先通过 <strong>flattenRoutes</strong> 将数组进行扁平化处理，扁平化处理后变成了如下的样子。</li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46d4ed8757e543328dbf55b8c26e75d9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="12.jpg"></p><p>扁平化的 branches 里面有一个 <strong>routesMeta</strong> 属性，存放了每一个 route 信息，比如上面那个 <code>/children/child1</code> 那么本质上有2层路由组成。第一层是 <code>/children</code>，第二层是 <code>/child1</code>；</p><ul><li>接下来通过 rankRouteBranches 调整 route 的顺序。</li><li>最后 <code>for</code> 循环和 <code>matchRouteBranch</code> 来找到待渲染的路由分支，如果 matches 不为 null ，那么会终止循环。由于篇幅原因 matchRouteBranch 的原理就不讲了，它主要的作用就是通过 pathname 来找到待渲染的 routesMeta 下面的路由。然后形成最终的 <code>matches</code> 结构。</li></ul><p>找到了对应的 <code>matches</code> ，我们知道 <code>matches</code> 里面保存了即将待渲染的路由。那么接下来就是去渲染路由，渲染对应的页面。那么主要就是 _renderMatches 做的事情了，所以我们看一下这个函数做了些什么？</p><blockquote><p>react-router/index.tsx -&gt; _renderMatches</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_renderMatches</span>(<span class="params">matches, parentMatches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parentMatches === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">    parentMatches = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (matches == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> matches.reduceRight(<span class="function">(<span class="params">outlet, match, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* 把前一项的 element ，作为下一项的 outlet */</span></span><br><span class="line">    <span class="keyword">return</span>  createElement(RouteContext.Provider, &#123;</span><br><span class="line">      <span class="attr">children</span>: match.route.element !== <span class="literal">undefined</span> ? match.route.element : <span class="comment">/*#__PURE__*/</span>createElement(Outlet, <span class="literal">null</span>),</span><br><span class="line">      <span class="attr">value</span>: &#123;</span><br><span class="line">        outlet,</span><br><span class="line">        <span class="attr">matches</span>: parentMatches.concat(matches.slice(<span class="number">0</span>, index + <span class="number">1</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很精妙，信息量也非常大，通过 <code>reduceRight</code> 来形成 react 结构 elmenet，这一段解决了三个问题：</p><ul><li>第一层 route 页面是怎么渲染。</li><li>outlet 是如何作为子路由渲染的。</li><li>路由状态是怎么传递的。</li></ul><p>首先我们知道 reduceRight 是从右向左开始遍历，那么之前讲到过 match 结构是 root -&gt; children -&gt; child1， reduceRight 把前一项返回的内容作为后一项的 outlet，那么如上的 match 结构会这样被处理。</p><ul><li>首先通过 provider 包裹 child1，那么 child1 真正需要渲染的内容 Child1 组件 ，将被当作 provider 的 children，最后把当前 provider 返回，child1 没有子路由，所以第一层 outlet 为 null。</li><li>接下来第一层返回的 provider，讲作为第二层的 outlet ，通过第二层的 provider 的 value 里面 outlet 属性传递下去。然后把 Layout 组件作为 children 返回。</li><li>接下来渲染的是第一层的 Provider ，所以 Layout 会被渲染，那么 Child1 并没有直接渲染，而是作为 provider 的属性传递下去。</li></ul><p>那么从上面我们都知道 child1 是在 <code>container</code> 中用 <code>Outlet</code> 占位组件的形式渲染的。那么我们先想一下 Outlet 会做哪些事情，应该会用 useContext 把第一层 provider 的 outlet 获取到然后渲染就可以渲染 child1 的 provider 了，而 child1 为 children 也就会被渲染了。我们验证一下猜想是否正确。</p><blockquote><p>react-router/index.tsx -&gt; Outlet</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Outlet</span>(<span class="params">props: OutletProps</span>): <span class="title">React</span>.<span class="title">ReactElement</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useOutlet(props.context);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>Outlet 本质就是用了 useOutlet ，接下来一起看一下 <code>useOutlet</code>。</li></ul><blockquote><p>react-router/index.tsx -&gt; useOutlet</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useOutlet</span>(<span class="params">context?: unknown</span>): <span class="title">React</span>.<span class="title">ReactElement</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> outlet = React.useContext(RouteContext).outlet;</span><br><span class="line">  <span class="keyword">if</span> (outlet) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">OutletContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;context&#125;</span>&gt;</span>&#123;outlet&#125;<span class="tag">&lt;/<span class="name">OutletContext.Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> outlet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看出来就是获取上一级的 Provider 上面的 outlet ，（在上面 demo 里就是包裹 Child1 组件的 Provider ），然后渲染 outlet ，所以二级子路由就可以正常渲染了。</li></ul><p>到此为止，整个 v6 渲染原理就很清晰了。</p><p>我们把 reduceRight 做的事，用一幅流程图来表示。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8867575ece754c359bfb6004f78d31d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="13.jpg"></p><h4 id="路由更新到对应组件渲染展示流程"><a href="#路由更新到对应组件渲染展示流程" class="headerlink" title="路由更新到对应组件渲染展示流程"></a>路由更新到对应组件渲染展示流程</h4><p>接下来我们来分析一下如果通过 navigator 实现跳转，比如 home 跳转到 child1 组件，那么会发生哪些事情呢？</p><ul><li>还是拿 BrowserRouter 为例子，当更新路由的时候，首先 BrowserRouter 中的 listen 事件会触发，那么会形成新的 location 对象。接下来 locationContext 会更新。</li><li>useRoutes 内部消费了 locationContext ，locationContext 变化会让 useRoutes 重新执行。</li><li>useRoutes 重新执行，内部会调用 matchRoutes 和 _renderMatches 找到新的渲染分支，渲染对应的页面。</li></ul><p>整个渲染流程还是比较简单和清晰的。</p><h2 id="v5-和-v6-区别"><a href="#v5-和-v6-区别" class="headerlink" title="v5 和 v6 区别"></a>v5 和 v6 区别</h2><p><strong>组件层面上：</strong></p><ul><li>老版本路由采用了 Router Switch Route 结构，Router -&gt; 传递状态，负责派发更新； Switch -&gt; 匹配唯一路由 ；Route -&gt; 真实渲染路由组件。</li><li>新版本路由采用了 Router Routes Route 结构，Router 为了抽离一 context； Routes -&gt; 形成路由渲染分支，渲染路由；Route 并非渲染真实路由，而是形成路由分支结构。</li></ul><p><strong>使用层面上：</strong></p><ul><li>老版本路由，对于嵌套路由，配置二级路由，需要写在具体的业务组件中。</li><li>新版本路由，在外层统一配置路由结构，让路由结构更清晰，通过 Outlet 来实现子代路由的渲染，一定程度上有点类似于 vue 中的 <code>view-router</code>。</li><li>新版本做了 API 的大调整，比如 useHistory 变成了 useNavigate，减少了一些 API ，增加了一些新的 api 。</li></ul><p><strong>原理层面上：</strong></p><ul><li>老版本的路由本质在于 Route 组件，当路由上下文 context 改变的时候，Route 组件重新渲染，然后通过匹配来确定业务组件是否渲染。</li><li>新版本的路由本质在于 Routes 组件，当 location 上下文改变的时候，Routes 重新渲染，重新形成渲染分支，然后通过 provider 方式逐层传递 Outlet，进行匹配渲染。</li></ul><h2 id="路由拦截★"><a href="#路由拦截★" class="headerlink" title="路由拦截★"></a>路由拦截★</h2><h3 id="登录拦截（简单实现）"><a href="#登录拦截（简单实现）" class="headerlink" title="登录拦截（简单实现）"></a>登录拦截（简单实现）</h3><p>通过向后端发送<strong>用户名和密码</strong>，后端返回<strong>用户信息</strong>，其中<strong>密码</strong>在后端使用<strong>md5</strong>加密格式返回，然后将用户信息保存在内存和<code>localStorage</code>中（store.js），每次打开该网站时就从localStorage中读取数据到内存，实现登录功能。</p><p>管理后台最外层组件，判断当前用户名是否存在，若存在则进行页面展示，不存在则跳转登录界面。</p><h3 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h3><blockquote><p>Prompt组件是react-router4 提供的组件，主要作用于路由跳转前的阻止、提示等操作，常使用于提示用户未保存等提示。</p></blockquote><p>when：当Prompt的when属性为true时，渲染Prompt该组件。</p><p>message：阻止时的提示框的文字内容(string)，也可以使用函数形式的属性值，动态返回message值，也可以通过函数形式实现自定义提示组件</p><h4 id="简单形式"><a href="#简单形式" class="headerlink" title="简单形式"></a>简单形式</h4><blockquote><p>默认的Prompt提示样式</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Prompt的默认提示框阻止跳转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Prompt, Link &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultPrompt</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/function/message&quot;</span>&gt;</span>跳转到function形式的message的页面<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;/* when为true时表示阻止默认的跳转行为 */&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Prompt</span> <span class="attr">when</span>=<span class="string">&#123;true&#125;</span> <span class="attr">message</span>=<span class="string">&#x27;确认离开此页面？&#x27;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">          使用Prompt的默认提示框阻止跳转</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Prompt的message的function形式实现自定义的提示样式"><a href="#使用Prompt的message的function形式实现自定义的提示样式" class="headerlink" title="使用Prompt的message的function形式实现自定义的提示样式"></a>使用Prompt的message的function形式实现自定义的提示样式</h4><blockquote><p>可以实现自定义样式，如使用常用UI组件库的弹窗提示等，只能作用于当前次组件的跳转时的自定义样式,优先级高于Router的getUserConfirmation方法。message方法返回false才会阻止默认的跳转行为。当路由push带有search时可能第一次进入就会触发一次拦截。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Prompt的message的function形式实现自定义的提示样式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Prompt, Link &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Modal &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionMessage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">isBlock</span>: <span class="literal">true</span>, <span class="comment">// 是否阻止离开此页面</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确认离开时的方法</span></span><br><span class="line">  onConfirmLeave = <span class="function"><span class="params">pathname</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 将isBlock设置为false，不再阻止跳转行为，并手动进行路由跳转</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      <span class="attr">isBlock</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;, <span class="function">() =&gt;</span> <span class="built_in">this</span>.props.history.push(pathname));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; isBlock &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/default/prompt&quot;</span>&gt;</span>跳转到默认提示的页面<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Prompt</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">when</span>=<span class="string">&#123;isBlock&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">message</span>=<span class="string">&#123;location</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="xml">            Modal.confirm(&#123;</span></span><br><span class="line"><span class="xml">              title: &#x27;确认离开此页面？&#x27;,</span></span><br><span class="line"><span class="xml">              onOk: () =&gt; this.onConfirmLeave(location),</span></span><br><span class="line"><span class="xml">            &#125;)</span></span><br><span class="line"><span class="xml">            return false;</span></span><br><span class="line"><span class="xml">          &#125;&#125;</span></span><br><span class="line"><span class="xml">        /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">          使用Message的function的用法实现自定义阻止效果</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Router的getUserConfirmation实现自定义提示样式"><a href="#使用Router的getUserConfirmation实现自定义提示样式" class="headerlink" title="使用Router的getUserConfirmation实现自定义提示样式"></a>使用Router的getUserConfirmation实现自定义提示样式</h4><blockquote><p>可以作用于所有使用Prompt组件的路由页面。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Route, Switch, Redirect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Modal &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> FunctionMessage <span class="keyword">from</span> <span class="string">&#x27;./FunctionMessage&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> DefaultPrompt <span class="keyword">from</span> <span class="string">&#x27;./DefaultPrompt&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 提示框的确认的方法(移除挂载自定义提示组件的dom)</span></span><br><span class="line">  onOk = <span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">    callback(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> routerDom = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;router-dom&#x27;</span>);</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>].removeChild(routerDom);</span><br><span class="line">    ReactDOM.unmountComponentAtNode(routerDom);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提示框的取消的方法(移除挂载自定义提示组件的dom)</span></span><br><span class="line">  onCancel = <span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">    callback(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> routerDom = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;router-dom&#x27;</span>);</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>].removeChild(routerDom);</span><br><span class="line">    ReactDOM.unmountComponentAtNode(routerDom);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getUserConfirmation自定义提示，message就是对应路由页面的message信息</span></span><br><span class="line">  getConfirmation = <span class="function">(<span class="params">message, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在body下添加新的节点用于挂载自定义提示组件</span></span><br><span class="line">    <span class="keyword">const</span> routerDom = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    routerDom.setAttribute(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;router-dom&#x27;</span>);</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>].appendChild(routerDom);</span><br><span class="line">    <span class="keyword">const</span> ConFirmComponent = <span class="function">() =&gt;</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Modal</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">title</span>=<span class="string">&quot;使用getUserConfirmation实现自定义离开样式&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">visible</span>=<span class="string">&#123;true&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onOk</span>=<span class="string">&#123;()</span> =&gt;</span> this.onOk(callback)&#125;</span></span><br><span class="line"><span class="xml">        onCancel=&#123;() =&gt; this.onCancel(callback)&#125;</span></span><br><span class="line"><span class="xml">      &gt;</span></span><br><span class="line"><span class="xml">        &#123;message&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Modal</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">ConFirmComponent</span> /&gt;</span></span>,</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">&#x27;router-dom&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">getUserConfirmation</span>=<span class="string">&#123;this.getConfirmation&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/default/prompt&quot;</span> <span class="attr">component</span>=<span class="string">&#123;DefaultPrompt&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/function/message&quot;</span> <span class="attr">component</span>=<span class="string">&#123;FunctionMessage&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/default/prompt&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Redux★"><a href="#Redux★" class="headerlink" title="Redux★"></a>Redux★</h1><blockquote><p>考察公司：小米、百度</p></blockquote><h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><ol><li>redux是一个专门用于做<strong>状态管理的JS库</strong>(不是react插件库)。</li><li>它可以用在react, angular, vue等项目中, 但基本与react配合使用。</li><li>作用: 集中式管理react应用中多个组件<strong>共享</strong>的状态。</li></ol><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>某个组件的状态，需要让其他组件可以随时拿到（共享）。</li><li>一个组件需要改变另一个组件的状态（通信）。</li><li>总体原则：能不用就不用, 如果不用比较吃力才考虑使用。</li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5W48UO"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/24/5W48UO.png" alt="5W48UO.png"></a></p><h2 id="三个核心概念"><a href="#三个核心概念" class="headerlink" title="三个核心概念"></a>三个核心概念</h2><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><ul><li><p><strong>动作的对象</strong></p></li><li><p>包含2个属性</p><p>type：标识属性, 值为字符串, 唯一, 必要属性</p><p>data：数据属性, 值类型任意, 可选属性</p></li><li><p>例子：<code>&#123; type: &#39;ADD_STUDENT&#39;,data:&#123;name: &#39;tom&#39;,age:18&#125; &#125;</code></p></li></ul><h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><ul><li><p><strong>用于初始化状态、加工状态</strong>。</p></li><li><p>加工时，根据旧的state和action， 产生新的state的<strong>纯函数</strong></p><ul><li>纯函数:一类特别的函数: 只要是同样的输入(实参)，必定得到同样的输出(返回)</li><li>必须遵守以下一些约束<ul><li><strong>不得改写参数数据</strong> <code>preState.unshift(data)</code></li><li>不会产生任何副作用，例如网络请求，输入和输出设备</li><li>不能调用<code>Date.now()</code>或者<code>Math.random()</code>等不纯的方法</li></ul></li></ul></li><li><p>redux的<strong>reducer函数必须是一个纯函数</strong></p></li></ul><h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><ul><li><p><strong>将state、action、reducer联系在一起的对象</strong></p></li><li><p>如何得到此对象?</p><ul><li><code>import &#123;createStore&#125; from &#39;redux&#39;</code></li><li><code>import reducer from &#39;./reducers&#39;</code></li><li><code>const store = createStore(reducer)</code></li></ul></li><li><p>此对象的功能?</p><ul><li><p><code>getState()</code>: 得到state</p></li><li><p><code>dispatch(action)</code>: 分发action, 触发reducer调用, 产生新的state</p></li><li><p><code>subscribe(listener)</code>: 注册监听, 当产生了新的state时, 自动调用</p></li></ul></li></ul><h1 id="Android词典"><a href="#Android词典" class="headerlink" title="Android词典"></a>Android词典</h1><p>基于Android的电子词典设计</p><p>离线情况和有网络的情况。</p><h2 id="单词数据的爬取"><a href="#单词数据的爬取" class="headerlink" title="单词数据的爬取"></a>单词数据的爬取</h2><blockquote><p>借助Python的Requests库和lxml库</p></blockquote><ul><li><p>Requests构建HTTP的请求头<strong>伪装成浏览器与词典网站进行通信</strong>，<strong>发起请求</strong>和<strong>获取响应内容</strong>，对应的方法为<strong>get</strong>方法。主要是获得相应url对应的html。</p></li><li><p>XPath，全称 XML Path Language，即<strong>XML路径语言</strong>,以<strong>XML树结构</strong>为基础，能够在数据的结构树中查找各类节点，比如属性节点、文本节点和元素节点等等。在检查元素中右键即可复制它的XPath路径，分析规律并且结合XPath的表达式语法，就可获取相关文本内容。</p></li><li><p>本项目使用<code>Multiprocessing</code>的<code>Pool</code>方法设置一定进程数量的进程池，将所有需要爬虫的单词异步执行，也就是非阻塞的方式。</p></li><li><p>当时遇到的问题<strong>多进程爬取的数据无法同时向SQLite数据库中保存</strong>，因此先爬取内容到<code>TXT</code>，再保存到数据库中。</p></li></ul><h2 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h2><p>使用<strong>布局编辑器</strong>构建界面。</p><ul><li><p>根布局就是<code>DrawerLayout</code>，在根布局之后又主要分为两大部分，第一部分就是我们主界面的内容，第二部分是左边滑出的布局，这里用NavitationView来代替。</p></li><li><p>线性布局（<code>LinearLayout</code>）和相对布局（<code>RelativeLayout</code>）实现。</p><ul><li>线性布局是将界面中的全部控件按照<strong>水平</strong>或<strong>竖直</strong>方向进行排列，同时它也是最基本的布局方式。</li><li>相对布局则是通过控件之间的<strong>相对位置</strong>关系实现控件的摆放，有利于适配不同屏幕大小的手机，因此使用更为普遍。</li></ul></li><li><p>一般布局都是用<code>dp</code>，字体用<code>sp</code>（手机字体调大了，APP的字体会随之变大）来布局的，用来<strong>适配移动端分辨率</strong>。</p></li></ul><h2 id="API或SDK"><a href="#API或SDK" class="headerlink" title="API或SDK"></a>API或SDK</h2><p>调用百度API实现句子翻译的功能。调用讯飞开放平台的SDK实现语音输入的功能。</p><ul><li><p>API 全称 Application Programming Interface，即<strong>「应用程序接口」</strong>。一般是指一些预先定义的<strong>函数</strong>，目的是供应用程序与开发人员基于某软件或硬件得以访问一组程序的能力，而又无需访问源码，或理解内部工作机制的细节。</p></li><li><p>SDK 全称 Software Development Kit，<strong>软件开发工具包</strong>。通俗来讲就是<strong>第三方服务商提供的实现产品软件某项功能的工具包</strong>。例如 JDK 就是一种 SDK。</p></li><li><p><strong>API 在更多场合下更像是 SDK 的一个子集</strong>，他们的区别如下：</p><ul><li><p>API 通常是一个<strong>函数</strong>，有特定的功能；而 SDK 是一个很多功能函数的<strong>集合体</strong>，更像是一个<strong>工具包</strong>。</p></li><li><p>API 通常扮演<strong>数据接口</strong>的形象，SDK 相当于一个<strong>工具环境</strong>，通常是需要在 SDK 的环境下调用 APl。</p></li><li><p><strong>SDK 相较于 API 封装层次更高</strong>。</p></li></ul></li></ul><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过<strong>分离关注点</strong>的方式来组织代码结构，优化我们的开发效率。</p><h3 id="Android-MVC"><a href="#Android-MVC" class="headerlink" title="Android MVC"></a>Android MVC</h3><ul><li><p><strong>View：</strong>XML布局文件。</p></li><li><p><strong>Model：</strong>实体模型（数据的获取、存储、数据状态变化）。</p></li><li><p><strong>Controller：</strong>对应于Activity，处理数据、业务和UI。</p></li></ul><p>从上面这个结构来看，Android本身的设计还是符合MVC架构的，但是<strong>Android中纯粹作为View的XML视图功能太弱，我们大量处理View的逻辑只能写在Activity中，这样Activity就充当了View和Controller两个角色</strong>，直接导致Activity中的代码大爆炸。相信大多数Android开发者都遇到过一个Acitivty数以千行的代码情况吧！所以，更贴切的说法是，这个MVC结构最终其实只是一个<strong>Model-View（Activity:View&amp;Controller）</strong>的结构。</p><h3 id="Android-MVVM"><a href="#Android-MVVM" class="headerlink" title="Android MVVM"></a>Android MVVM</h3><p>**View: **对应于Activity和XML，负责View的绘制以及与用户交互。</p><p>**Model: **实体模型。</p><p><strong>ViewModel: <strong>负责完成View与Model间的交互，负责</strong>业务逻辑</strong>。</p><p>Android为此提供了一套<strong>架构组件</strong>，主要有LiveData、ViewModel 和Room。</p><ul><li>LiveData是用来构建数据对象，当基础数据库改变时会通知视图；</li><li>ViewModel是用来<strong>存储和管理与界面相关的数据</strong>，这些数据在应用跳转时不会被销毁；</li><li>Room是一个SQLite对象映射库，它可以轻松地将SQLite表数据转换为Java对象，主要负责底层数据库的处理，本文调用其中的Dao接口来执行数据库增删改查等操作，利用 Database创建和管理数据库。同时，Room可以为SQLite语句提供编译时检查，并能够返回RxJava、Flowable和LiveData可观察对象。</li><li>Repository是一个仓库类，介于视图层与数据映射层（数据访问层）之间。它的作用是让视图层感觉不到数据访问层的存在，提供了一个类似集合的接口给视图层进行访问。</li></ul><p>采用MVVM模式最大的优点就是编写代码是思路明确，<strong>视图层与模型层完全解耦</strong>，方便后期的管理与维护，数据库相关的操作非常方便。</p><p>MVVM 模式中的VM，通过双向的数据绑定，<strong>将 View 和 Model 的同步更新给自动化了</strong>。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如vue是通过使用数据劫持和发布订阅者模式来实现的这一功能。</p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p><strong>Hexo</strong>：一个快速、简洁且高效的<strong>博客框架</strong>。Hexo 使用 <code>Markdown</code>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p><strong>Butterfly</strong>：主题。</p><p><strong>Github Pages</strong>：简单点来说，就是它为你的项目提供一个<strong>访问站点</strong>，并且<strong>直接指向你的仓库</strong>，你仓库更新，站点网站自动更新。</p><p>Github Pages可以被认为是<strong>用户编写的、托管在Github上的静态网页</strong>。使用Github Pages可以为你提供一个免费的服务器，<strong>免去了自己搭建服务器和写数据库</strong>的麻烦。此外还可以<strong>绑定自己的域名</strong>。</p><p><code>npm</code>：安装各种依赖。</p><h1 id="商城后台管理系统★"><a href="#商城后台管理系统★" class="headerlink" title="商城后台管理系统★"></a>商城后台管理系统★</h1><blockquote><p>考察公司：字节</p></blockquote><p>One Piece商城后台管理系统</p><ol><li>此项目为一个<strong>前后台分离</strong>的<strong>后台管理的 SPA</strong>（单页面应用）, 包括前端 PC 应用和后端应用</li><li>包括<strong>用户管理</strong> / <strong>商品管理</strong> / <strong>权限管理</strong>等功能模块</li><li>前端: 使用 <strong>React 全家桶（函数式组件、react-router V6）</strong> + <strong>Antd（v4）</strong> + <strong>Axios</strong> + <strong>ES6</strong> + <strong>Webpack</strong> 等技术</li><li>后端: 使用 <strong>Node</strong> + <strong>Express</strong> + <strong>Mongodb</strong> 等技术</li><li>采用<strong>模块化</strong>、<strong>组件化</strong>、<strong>工程化</strong>的模式开发</li></ol><p>使用<code>create-react-app</code>(脚手架)搭建项目。</p><p><code>create-react-app</code> 是react 官方提供的用于搭建基于<code>react</code>+<code>webpack</code>+<code>es6</code> 的脚手架</p><p><code>antd</code> 是基于 Ant Design 设计体系的 <strong>React UI 组件库</strong>，主要用于研发企业级中后台产品。</p><p><code>craco</code>一个对 create-react-app 进行<strong>自定义配置</strong>的社区解决方案</p><h2 id="模块化、组件化、工程化-★"><a href="#模块化、组件化、工程化-★" class="headerlink" title="模块化、组件化、工程化 ★"></a>模块化、组件化、工程化 ★</h2><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>后端：<strong>CommonJS</strong> :<code>module.exports</code>、<code>require</code>方法用于加载模块。</p><p>前端：<strong>ES6</strong> 模块化语法：export 和 import；</p><h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><p><code>webpack</code>最热门的前端资源模块化管理和打包工具、</p><p><code>create-react-app</code> 脚手架初始化react 项目开发、</p><p><code>ESLint</code> 插件化的 JavaScript 代码检测工具</p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>其中以React的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。</p><p>理解:<strong>用来实现局部功能效果的代码和资源的集合(html/css/js/img等等)</strong></p><p>为什么要用组件:一个界面的功能复杂</p><p>作用:<strong>复用编码,简化项目编码,提高运行效率</strong></p><p>当应用是以多组件的方式实现,这个应用就是组件化的应用。</p><h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><h3 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h3><blockquote><p>气泡背景原理：</p></blockquote><p><strong>background</strong>可以设置多个，默认地，每个背景图像在水平和垂直方向上<strong>重复</strong>。因此，通过设置多个背景图像的<strong>位置</strong>和<strong>大小</strong>产生重叠效果。</p><p>气泡：<code>radial-gradient</code>+<code>rgba</code></p><p>开始和结束的透明度都设为0。通过两个确定位置的固定色值（有一定透明度的白色），实现渐变效果。</p><p><code>radial-gradient(rgba(255,255,255,0) 0, rgba(255,255,255,.15) 30%, rgba(255,255,255,.3) 32%, rgba(255,255,255,0) 33%)</code></p><blockquote><p>边框</p></blockquote><p><code>box-shadow</code> 内外阴影效果。</p><blockquote><p>背景毛玻璃</p></blockquote><p><code>backdrop-filter: blur(5px);</code></p><p>该属性可以让你为一个元素后面区域添加图形效果（如模糊或颜色偏移）。 因为它适用于元素背后的所有元素，为了看到效果，必须使元素或其背景至少部分透明。</p><blockquote><p>头像旋转</p></blockquote><p><code>animation</code>+<code>transform: rotate</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">animation</span>: spin <span class="number">0.5s</span> linear <span class="number">0s</span> forwards;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">        <span class="attribute">animation</span>: spin <span class="number">1s</span> linear forwards infinite;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> spin &#123;</span><br><span class="line">    <span class="selector-tag">100%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotate(<span class="number">360deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预加载动画"><a href="#预加载动画" class="headerlink" title="预加载动画"></a>预加载动画</h3><p>在index.html中的<code>div root</code>中先填充加载元素，通过css设置样式</p><p>多个<code>span</code> <code>animation</code> <code>animation-delay</code> <code>opacity</code> <code>background</code> 无限循环</p><p><strong>等react组件加载完成后就会覆盖</strong>。</p><h2 id="Antd-v3升级成v4"><a href="#Antd-v3升级成v4" class="headerlink" title="Antd v3升级成v4"></a>Antd v3升级成v4</h2><h3 id="去除-Form-create"><a href="#去除-Form-create" class="headerlink" title="去除 Form.create"></a>去除 Form.create</h3><p>v4 的 Form 不再需要通过 <code>Form.create()</code> 创建上下文。Form 组件现在自带数据域，因而 <code>getFieldDecorator</code> 也不再需要，直接写入 Form.Item 即可。</p><p>由于移除了 <code>Form.create()</code>，原本的 <code>onFieldsChange</code> 等方法移入 Form 中，通过 <code>fields</code> 对 Form 进行控制。</p><h3 id="表单控制调整"><a href="#表单控制调整" class="headerlink" title="表单控制调整"></a>表单控制调整</h3><p>Form 自带表单控制实体，如需要调用 form 方法，可以通过 <code>Form.useForm()</code> 创建 <strong>Form 实体</strong>进行操作。</p><h3 id="onFinish-替代-onSubmit"><a href="#onFinish-替代-onSubmit" class="headerlink" title="onFinish 替代 onSubmit"></a>onFinish 替代 onSubmit</h3><p>对于表单校验，过去版本需要通过监听 <code>onSubmit</code> 事件手工触发 <code>validateFields</code>。新版直接使用 <code>onFinish</code> 事件，该事件仅当校验通过后才会执行：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// antd v4</span></span><br><span class="line"><span class="keyword">const</span> Demo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> onFinish = <span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Received values of form: &#x27;</span>, values);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Form</span> <span class="attr">onFinish</span>=<span class="string">&#123;onFinish&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Form.Item</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">rules</span>=<span class="string">&#123;[&#123;</span> <span class="attr">required:</span> <span class="attr">true</span> &#125;]&#125;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Input</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><ul><li>echarts echarts-for-react</li><li>bizcharts</li></ul><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="用户登录和权限管理★"><a href="#用户登录和权限管理★" class="headerlink" title="用户登录和权限管理★"></a>用户登录和权限管理★</h3><p>默认使用最高级管理员登录，该管理员名称和密码为默认值，且拥有最高权限。</p><p>通过向后端发送<strong>用户名和密码</strong>，后端返回<strong>用户信息</strong>，其中<strong>密码</strong>在后端使用<strong>md5</strong>加密格式返回，然后将用户信息保存在内存和<code>localStorage</code>中（store.js），每次打开该网站时就从localStorage中读取数据到内存，实现登录功能。</p><p>权限管理则是通过事先准备一个菜单列表的数组，该数组是一个树形结构，每一个菜单下可能有子菜单，每一个菜单对象存储左侧导航的相关信息，图标、名称和key。</p><p>通过对菜单列表的数组<strong>递归（map）</strong>返回antd里的菜单组件，生成左侧导航栏。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getMenuNodes = <span class="function"><span class="params">menuList</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> menuList.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasAuth(item)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!item.children) &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">Menu.Item</span> <span class="attr">key</span>=<span class="string">&#123;item.key&#125;</span> <span class="attr">icon</span>=<span class="string">&#123;item.icon&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;item.key&#125;</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Menu.Item</span>&gt;</span></span></span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">SubMenu</span> <span class="attr">key</span>=<span class="string">&#123;item.key&#125;</span> <span class="attr">icon</span>=<span class="string">&#123;item.icon&#125;</span> <span class="attr">title</span>=<span class="string">&#123;item.title&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">              &#123;getMenuNodes(item.children)&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">SubMenu</span>&gt;</span></span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125; </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上述过程的一开始加入权限管理的功能，本地保存的用户信息中包含权限信息，前端渲染前先进行检查是否拥有展示权限。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasAuth = <span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; key &#125; = item</span><br><span class="line">    <span class="comment">// console.log(memoryUtils.user)</span></span><br><span class="line">    <span class="keyword">const</span> menus = memoryUtils.user.role.menus</span><br><span class="line">    <span class="keyword">const</span> username = memoryUtils.user.username</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 如果当前用户是admin</span></span><br><span class="line"><span class="comment">    2. 当前用户有此item的权限: key有没有在menus中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (username === <span class="string">&#x27;admin&#x27;</span> || menus.indexOf(key) !== -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.children) &#123; <span class="comment">// 3. 如果当前用户有此item的某个子item的权限 pie  &quot;/charts/pie&quot;</span></span><br><span class="line">        <span class="keyword">return</span> !!item.children.find(<span class="function"><span class="params">child</span> =&gt;</span> menus.indexOf(child.key) !== -<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于只是一个简单的后台管理系统，后端并没有保存登录状态。</p><p>在自己的权限内，所有用户都可以对数据库进行权限内的操作，所以后端不需要记录用户。</p><h3 id="输入校验"><a href="#输入校验" class="headerlink" title="输入校验"></a>输入校验</h3><p><strong>正则</strong></p><p><code>/^[a-zA-Z0-9_]+$/</code>用户名必须是英文,数字和下划线组成</p><p><code>/^[a-zA-Z0-9_]+$/.test(value)</code></p><h3 id="跨域和Ajax"><a href="#跨域和Ajax" class="headerlink" title="跨域和Ajax"></a>跨域和Ajax</h3><p>React中配置代理</p><p>在<code>package.json</code>中追加如下配置 :<code>&quot;proxy&quot;:http://localhost:5000</code></p><p><strong>Promise封装axios</strong></p><p>axios是一个基于<code>promise</code>的<code>HTTP</code>库，可以用在<code>浏览器</code>或者<code>node.js</code>中。</p><p>axios是通过promise实现对ajax技术的一种封装。</p><ul><li>对get和post请求进行封装</li><li>请求成功该方法返回一个以<code>response.data</code>值解析后的Promise对象</li><li>请求失败了，不调用<code>reject(reason)</code>，而是统一处理异常，结合antd的message组件提示错误信息</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; message &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url,data=&#123;&#125;,type=<span class="string">&#x27;GET&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> promise;</span><br><span class="line">        <span class="comment">// 执行异步ajax请求</span></span><br><span class="line">        <span class="keyword">if</span>(type===<span class="string">&#x27;GET&#x27;</span>)&#123;<span class="comment">//发GET请求</span></span><br><span class="line">            promise=axios.get(url,&#123;</span><br><span class="line">                <span class="attr">params</span>:data</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//发POST请求</span></span><br><span class="line">            promise=axios.post(url,data)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果请求成功了，调用resolve(value)</span></span><br><span class="line">        <span class="comment">// 该方法返回一个以response.data值解析后的Promise对象</span></span><br><span class="line">        promise.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(response.data)</span><br><span class="line">            <span class="comment">// console.log(response.data)</span></span><br><span class="line">        <span class="comment">// 如果请求失败了，不调用reject(reason)，而是提示异常信息（统一处理异常）   </span></span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            message.error(<span class="string">&#x27;请求出错了：&#x27;</span>+error.message)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有的请求函数封装在一个文件中</p><p>ajax第二个参数必须是对象 当属姓名和值相同时可以简写</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BASE = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">// 登陆 ajax第二个参数必须是对象，username:username =&gt; username 匹配请求参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reqLogin = <span class="function">(<span class="params">username, password</span>) =&gt;</span> ajax(BASE+<span class="string">&#x27;/login&#x27;</span>, &#123; username, password &#125;, <span class="string">&#x27;POST&#x27;</span>)</span><br><span class="line"><span class="comment">// 天气</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reqWeather = <span class="function">(<span class="params">key, location</span>) =&gt;</span> ajax(<span class="string">&#x27;https://devapi.qweather.com/v7/weather/now&#x27;</span>, &#123; key, location &#125;)</span><br><span class="line"><span class="comment">// 更新分类 传一个对象 解构 外部传的时候名字要一致</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reqUpdateCateGories = <span class="function">(<span class="params">&#123; categoryName, categoryId &#125;</span>) =&gt;</span> ajax(BASE+<span class="string">&#x27;/manage/category/update&#x27;</span>, &#123; categoryName, categoryId &#125;, <span class="string">&#x27;POST&#x27;</span>)</span><br></pre></td></tr></table></figure><p>登录组件中发送请求</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onFinish = <span class="keyword">async</span> values =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username, password &#125; = values;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> reqLogin(username, password);<span class="comment">//发送AJAX</span></span><br><span class="line">    <span class="keyword">if</span> (result.status === <span class="number">0</span>) &#123; <span class="comment">// 登陆成功</span></span><br><span class="line">        message.success(<span class="string">&#x27;登陆成功&#x27;</span>)</span><br><span class="line">        <span class="comment">// 保存user            </span></span><br><span class="line">        <span class="keyword">const</span> user = result.data</span><br><span class="line">        <span class="built_in">console</span>.log(user)</span><br><span class="line">        memoryUtils.user = user <span class="comment">// 保存在内存中</span></span><br><span class="line">        storageUtils.saveUser(user) <span class="comment">// 保存到local中</span></span><br><span class="line">        <span class="comment">// 跳转到管理界面 (不需要再回退回到登陆)</span></span><br><span class="line">        navigate(<span class="string">&#x27;/&#x27;</span>, &#123; <span class="attr">replace</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        message.error(result.msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h3><p><strong>props</strong></p><ul><li><p>【父组件】给【子组件】传递数据：通过<code>props</code>传递</p></li><li><p>【子组件】给【父组件】传递数据：通过<code>props</code>传递，<strong>要求父提前给子传递一个函数</strong>。</p><p>此props为<strong>作用域为父组件自身的函数</strong>，子组件调用该函数，将子组件想要传递的信息，作为参数，<strong>传递到父组件的作用域中</strong>。该项目中将<code>useState</code>的更新函数传给子组件。</p></li><li><p>【子组件】给【父组件】传递函数/方法</p><ul><li><code>useRef</code>: 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 ref 对象在组件的整个生命周期内持续存在。一个常见的用例便是命令式地访问子组件。</li><li><code>useImperativeHandle</code>:可以让你在使用 <code>ref</code> 时<strong>自定义暴露给父组件的实例值</strong>。比如暴露子组件的某个方法。<code>useImperativeHandle</code> 应当与<code>React.forwardRef</code> 一起使用。</li></ul></li></ul><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>因为是静态站点，所以完全是<strong>客户端部分</strong>，使用<strong>Hash</strong>路由跳转会没有任何问题。因为<strong>BrowserRouter依赖于服务端支持</strong>，使用它的话访问会出现404 not Found/405.</p><h3 id="GitHub-Pages发布静态页面"><a href="#GitHub-Pages发布静态页面" class="headerlink" title="GitHub Pages发布静态页面"></a>GitHub Pages发布静态页面</h3><p><code>package.json</code> 打包好的build文件夹上传gh-pages分支</p><h2 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h2><h3 id="自定义hook实现搜索防抖"><a href="#自定义hook实现搜索防抖" class="headerlink" title="自定义hook实现搜索防抖"></a>自定义hook实现搜索防抖</h3><p><strong>Input</strong> <code>event.target.value</code> 获取输入值 ，<strong>useState</strong> 更新此时的搜索状态 。</p><p>自定义 hook <strong>useDebounce</strong></p><p>debounce一般使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lodash</span></span><br><span class="line"><span class="keyword">import</span> debounce <span class="keyword">from</span> <span class="string">&#x27;lodash/debounce&#x27;</span></span><br><span class="line">debounce(<span class="function">()=&gt;</span>search(value), <span class="number">500</span>)</span><br><span class="line"><span class="comment">// 自定义</span></span><br><span class="line"><span class="keyword">const</span> debounceFn =<span class="function">(<span class="params">fn, wait=<span class="number">1000</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(fn, wait);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [value, setValue] = useState(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&lt;!--搜索函数--&gt;</span><br><span class="line"><span class="keyword">const</span> search = <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">    &lt;!--调用接口--&gt;</span><br><span class="line">&#125;</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    debounceFn(<span class="function">()=&gt;</span>search(value),<span class="number">500</span>)</span><br><span class="line">&#125;, [value])</span><br></pre></td></tr></table></figure><p>测试发现这一套在useEffect里是行不通的，<strong>每次组件重新渲染，都会创建新的定时器，定时器无法按规定清除</strong>，这样debounce高阶函数里面的timer就不能起到缓存的作用。timer不可靠，debounce的核心就被破坏了。</p><p>使用useCallback返回回调函数的 memoized 版本，<strong>该回调函数仅在某个依赖项改变时才会更新</strong>，通过设置空数组，使debounce高阶函数里面的timer唯一。</p><p>也可以借助useEffect自定义useDebounce ，关键<strong>React 会在执行当前 effect 之前对上一个effect进行清除</strong>。</p><p>当首次渲染时，执行effect延时后执行一次搜索操作，可以通过给value赋初值跳过这次搜索请求，之后每当输入时，value就会变化，每次变化先清除上一次effect的timer，然后建立新的timer等待执行，当输入停止后搜索函数在延时后就会发送请求，实现防抖。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理方案四 useEffect自定义hooks</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDebounce</span>(<span class="params">fn, delay, dep=[]</span>) </span>&#123;</span><br><span class="line">   useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> timer;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(fn, delay);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">()=&gt;</span><span class="built_in">clearTimeout</span>(timer); <span class="comment">// 这里用到useEffect清除的能力 类似于componentWillUnmount</span></span><br><span class="line">   &#125;, [...dep]</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useDebounce</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">useDebounce(<span class="function">()=&gt;</span>search(value), <span class="number">500</span>, [value])</span><br></pre></td></tr></table></figure><p>使用useRef保证<strong>多次渲染之间保证唯一值的纽带</strong>。将timer通过<code>useRef</code>创建。</p><p>useRef 会在所有的 render 中保持对返回值的唯一引用。因为所有对<code>ref</code>的赋值和取值拿到的都是最终的状态，并不会因为不同的 render 中存在不同的隔离。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理方案五 useRef自定义hooks</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDebounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = useRef(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer.current);</span><br><span class="line">        timer.current = <span class="built_in">setTimeout</span>(fn, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useDebounce</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">const</span> debounceSearch = useDebounce(<span class="function">() =&gt;</span> handleParams(params), <span class="number">500</span>)</span><br><span class="line">useEffect(<span class="function">()=&gt;</span>debounceSearch(),[value]</span><br></pre></td></tr></table></figure><p>关于useEffect还有一个问题，除了在依赖数组变化时会执行，初始渲染也会执行，但输入搜索显然不希望在初始进行搜索。</p><p>可以设置依赖值的初值，在请求函数中跳过请求。</p><h3 id="刷新后父级菜单的展开问题"><a href="#刷新后父级菜单的展开问题" class="headerlink" title="刷新后父级菜单的展开问题"></a>刷新后父级菜单的展开问题</h3><p>Menu可以通过<code>defaultOpenKeys</code>设置当前的菜单是否展开。</p><p>需求：如果点击了一个子菜单后，再刷新时该子菜单对应的上一级菜单是展开的。</p><p>方法：</p><ul><li><p>拿到当前路径（location属性中的<code>pathname</code>）</p><ul><li>withRouter高阶组件包装非路由组件, 返回一个新的组件。新的组件向非路由组件传递3个属性: <code>history/location/match</code></li><li>v6:使用<code>useLocation</code>即可得到location属性，withRouter不再使用。</li></ul></li><li><p>当存在子Item时，通过find和indexOf判断是否有与当前请求路径匹配的子Item，如果匹配就将父item设置展开。</p></li><li><p>由于需要将所有菜单遍历判断与当前路径是否匹配，而且OpenKeys的属性需要在组件渲染完成前得到，但我们仅希望刷新时调用一次，得到初始openKey，而不希望<strong>路由跳转</strong>等操作也执行该函数。</p></li><li><p>所以使用useMemo和useRef进行优化。使用useRef是因为pathname是个随路由跳转变化的值，放到useMemo中，如果不加入依赖数组会有警告。使用useRef也可以存储最新的pathname，而且不用加入依赖。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path = useLocation().pathname; </span><br><span class="line">path = <span class="string">&#x27;/&#x27;</span> + path.split(<span class="regexp">/\//</span>)[<span class="number">1</span>]<span class="comment">// 当前请求的含有子路由界面时过滤出子路由地址</span></span><br><span class="line"><span class="keyword">const</span> pathRef = useRef(path);</span><br><span class="line">pathRef.current=path;<span class="comment">// /子路由地址</span></span><br><span class="line">useMemo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> getOpenKey = <span class="function"><span class="params">menuList</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(menuList)</span><br><span class="line">        menuList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历菜单数组，匹配到当前路径下的子路由地址时，将其父菜单默认展开</span></span><br><span class="line">            <span class="keyword">if</span> (item.children) &#123;</span><br><span class="line">                <span class="comment">// 查找一个与当前请求路径匹配的子Item</span></span><br><span class="line">                <span class="comment">// find() 方法返回通过测试（函数内判断）的数组的第一个元素的值。</span></span><br><span class="line">                <span class="keyword">const</span> cItem = item.children.find(<span class="function"><span class="params">cItem</span> =&gt;</span> pathRef.current.indexOf(cItem.key) === <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 如果存在, 说明当前item的子列表需要打开</span></span><br><span class="line">                <span class="keyword">if</span> (cItem) &#123;</span><br><span class="line">                    setOpenKey(item.key)     </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    getOpenKey(menuList)</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure></li></ul><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p><strong>前端</strong></p><p>面试官好，我叫王吉晨，现在就读于北京邮电大学，是一名研三的学生。今天我想应聘的是前端开发的岗位。</p><p>下面我来介绍下我的学习、项目实习经历。</p><p>最早是本科做了一个Android电子词典APP，通过这个项目对前端（HTML）后端（JAVA和Python）都有了一定的了解，积累了开发经验。</p><p>后来研究生阶段利用空闲时间开始学习前端，先是系统学习了HTML，CSS和JS前端三件套，并通过Hexo搭建了个人博客网站记录一些学习内容。后面进一步学习了ES6+的部分内容、以及Ajax等相关知识，对前后端分离技术的基础有了一些了解。</p><p>关于框架主要是学习了React，自己做了一个后台管理系统，主要基于react和antd等技术实现前端界面的搭建，通过这个项目熟悉了前后端分离的开发模式，以及模块化、组件化、工程化的开发理念，对React有了一定认识，主要使用react hooks结合react router v6完成相应的功能。</p><p>实习的话，暑期在美团实习，基于组内微前端一体化研发平台，实现MBR报表的线上化，技术栈为React+TypeScript+MTD，通过这个项目熟悉了整个开发流程，从需求分析、方案设计、代码开发，再到联调测试，主要工作是实现MBR产品的前台页面和管理后台的展示与交互功能。</p><p>我的经历大概就是这样。</p><p><strong>国企</strong></p><p>面试官好，我叫王吉晨，现在就读于北京邮电大学，电子信息专业，是一名研三的学生，预计2023年六月份毕业。下面我就介绍一下我的项目和实习经历。</p><p>本科时，我基于Android平台实现了一个电子词典APP，其中词典的离线数据使用Python爬取并保存在SQLite数据库中，并基于Android Studio完成界面设计和功能实现，主要开发语言是Java，通过这个项目学习了MVVM开发模式，体会到了逻辑、视图以及模型分离的开发理念，积累了开发经验。</p><p>后来研究生阶段利用空闲时间系统学习了前端的相关知识，框架主要是学习了React，像国家电投招聘网站前端界面就是React+Antd实现的。自己做了一个后台管理系统的项目，通过这个项目熟悉了前后端分离的开发模式，以及模块化、组件化、工程化的开发理念。</p><p>暑期时在美团实习，基于组内的微前端研发平台，实现MBR报表的线上化，通过这个项目熟悉了整个开发流程，从需求分析、方案设计、代码开发，再到联调测试，主要工作是实现MBR产品的前台页面和管理后台的展示与交互功能。</p><p>实验室的研究方向为自由空间光通信系统空间分集接收方案研究与设计，通过Matlab和Optilux实现40Gbps PM-CO-16QAM FSO空间分集接收仿真平台搭建，并进行了离线实验验证，在该方向下成功发表一篇二区SCI。</p><p>我认为我的优势是热爱技术、学习能力较强，像我刚去公司实习时，虽然是做前端，但跟平时常用的技术栈还是不一样，所以需要尽快的学习并上手；另外我不管学校还是公司，都能与人和睦相处、乐于助人；还有就是我的抗压能力也还可以，不管实验室还是实习，都经常会有时间紧任务重的情况出现，所以我觉具备一定的抗压能力也很关键。</p><p>综上所述，我想应聘的是软件开发的岗位。希望有机会能够加入贵公司!谢谢！</p><h1 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h1><h2 id="项目介绍、难点、收获"><a href="#项目介绍、难点、收获" class="headerlink" title="项目介绍、难点、收获"></a>项目介绍、难点、收获</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>MBR系统开发，支撑MBR平台一期需求页面搭建</strong></p><p>产品定位：面向B-Team以及管理层，实现餐饮SaaS MBR报表线上化，实现商分提效。</p><p>短期目标：MBR平台一期前后台页面开发上线，实现MBR核心指标线上化。</p><p>工作成果：</p><ul><li>参与MBR三端评审，针对MBR平台一期需求完成方案调研与设计，主要对富文本编辑器和树形控件进行调研与选型，并对PRD中的各项需求进行分析设计。</li><li>完成MBR前后台页面需求开发，基于steamer平台将MBR前台和管理后台分别创建一个业务模块进行开发。前台页面主要完成页面整体布局、目录树导航（翻页、面包屑关联等）开发、页面动态渲染、页面部分组件（负责人卡片、富文本组件、无权限页面、文件下载页面等）开发；后台页面主要完成页面整体布局、目录树维护（增删改节点、节点关联页面、不同类型节点的功能区分等）、路由拦截等。</li><li>将请求发送、UI组件库这类公共服务（组件）发布为服务模块供业务模块使用，并在Shepherd网关编写mock接口进行本地测试。</li><li>前后台业务模块与服务模块的联调、构建与发布，并协助指导外包同学进行开发。</li><li>页面埋点、前后端联调、泳道环境和ST环境的部署与发布。</li></ul><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p><strong>业务方面：</strong></p><ul><li><strong>第一次从零开始做团队项目，不知道如何下手以及估算排期。</strong></li></ul><p>解决：在mentor引导下，针对需求进行方案调研与设计，确定好可以实现需求的合适的组件库。对于开发流程，首先对整个开发过程进行拆分例如这个项目，前台展示页面更重要优先级最高，再针对页面UI进行组件层级的拆分，每一个组件下又可以根据不同的功能点确定拆分成更小组件还是组件内通过写一个函数来实现等等，整个开发还是以先实现静态页面，再通过state等实现数据展示交互功能，这样从整体到部分再到细节，就能梳理出大致的开发流程以及估算合适排期。</p><ul><li><strong>产品对需求进行变更或提出了新需求，导致延期风险。</strong></li></ul><p>解决：与产品、后端及组内同事积极沟通，协调需求变更。首先对所提需求进行分类，对于必须实现的需求，如管理后台目录树的编辑与页面关联的需求必须实现，但前期PRD对这方面描述不完善且设计不合理，经过积极与后端、产品讨论对齐尽快提出可行的方案并加以实现；对于非必须实现且不合理的需求，与产品说明需求的不合理性及实现成本，尽可能取消这类需求或进行更改。</p><p><strong>技术方面：</strong></p><ul><li><p><strong>功能性问题</strong>：开发经验、博客论坛、谷歌搜索等</p><ul><li>目录树维护（增删改节点、节点关联页面、不同类型节点的功能区分等）：UI库的树组件一般不支持可编辑，因此需要二次开发，另外项目要求对不同层级的节点编辑要求有区别，比如有子节点父节点不能删除、父节点不能挂页面等，除此之外，编辑完后怎么像后端发请求保存。我的做法是封装一个递归遍历所有节点的函数，根据传参实现对节点不同的操作，弹出框和编辑按钮也可以根据不同的类型进行一部分的复用，向后端传参这里有两种方式，一种每进行一次操作发请求保存，但由于设计到拖拽节点等操作，我需要时刻拿到对应节点的位置，后端也需要对拿到数据进行处理，另外，每更改一次前台页面的数据就相当于变化一次；另一种方案，不管增删改还是关联页面，只要不点击保存就不向后端请求，点击保存，将整棵树的数据传给后端，点击取消则重新获取上一次的数据，为了防止不保存就离开或关闭页面，还要进行路由拦截。</li><li>无刷新修改url：需求是点击某个节点或翻页，内容区局部刷新，路由地址也要变化，最早想到是用路由的param参数，但内容区组件其实是固定的，只是根据请求的数据进行渲染，用路由意义不大；因为内容区可以根据react的重新渲染机制，只要state或props变更就进行对比和重渲染，路由地址可以直接用History.pushState()/replaceState()来更改。但这里面要注意react的浅比较和key的使用。</li><li>请求封装、下载</li><li>展示 滚动条、图片、grid</li></ul></li><li><p>平台基建/团队技术栈问题</p><ul><li><p>echarts等引起的ST环境导航切换白屏（removeChild） 错误边界 部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，不会渲染那些发生崩溃的子组件树，捕获错误，由于我们的bug是在路由跳转才会产生，因此错误边界组件捕获到错误可能立刻被卸载，因此并没有输出错误原因，而是直接让这个错误消失了。</p></li><li><p>组内的开发平台不熟悉，导致开发中经常遇到瓶颈，如样式不生效、构建发布失败和服务模块没有成功引入等。</p><p>解决：一方面，学习组内的wiki文档或者去学城搜索，很多问题别人已经遇到并解决过，同时可以结合之前别人的代码进行比对，排查原因并解决；另一方面，多向mentor和组内同事请教，他们的开发经验可以帮助快速定位问题并找到解决方案，甚至有些问题别人一两句话就能搞定，靠自己则会浪费过多时间。因此需要权衡问题的紧急程度，争取在不耽误项目排期的情况下快速定位问题并解决。</p></li><li><p>新技术栈如TypeScript不熟悉。</p><p>解决：首先集中时间对TypeScript的基础进行整体学习，同时结合组内之前的代码学习TypeScript在React的使用方式，在后续开发中不断完善编码规范，遇到报错可以去StackOverflow等网站查询他人的解决方法。</p></li></ul></li></ul><h3 id="收获与不足"><a href="#收获与不足" class="headerlink" title="收获与不足"></a>收获与不足</h3><p>通过上述项目与工作的锻炼，以及与mentor及组内同事的交流和学习，我得到了以下收获：</p><p><strong>业务方面：</strong></p><ul><li>对于业务理解有了提升，逐渐开始理解新需求的背景和目标，并能针对业务需求进行任务拆分。</li><li>第一次参与较大型且周期较⻓的业务项目开发，熟悉了整个开发流程，从需求分析、方案设计、代码开发，再到现在的联调测试，同时能够独立地进行方案设计与开发实现。</li></ul><p><strong>技术方面：</strong></p><ul><li><p>对Git常用命令、分支和冲突等方面有了进一步的学习和认识。</p></li><li><p>学习了新的技术栈TypeScript，同时对React、React Hook和React Router等有了进一步学习和更深的理解。</p></li><li><p>学习了新的UI组件库的使用，也尝试在项目中使用一些实用性轮子，同时对富文本编辑器、下载导出Excel等进行了调研学习与开发。</p></li><li><p>对公司和组内的各项基建更加熟悉，例如Shepherd、Ocean、steamer等，对steamer平台的使用有了一定了解，如业务模块和服务模块的构建与发布。</p></li><li><p>代码能力得到了成长，能够独立完成需求的开发以及BUG的定位与修复。同时，代码编程风格得到优化，代码格式逐渐统一与规范。</p></li></ul><p><strong>软实力：</strong></p><ul><li><p>沟通能力得到了提高，从最开始不好意思开口问，到现在可以有不懂的地方及时发问，并能快速对齐需求，与产品、后端及组内同事保持良好沟通，共同完成项目的开发。</p></li><li><p>合作意识提高，由于第一次参与团队项目，从最开始只顾自己开发，到现在能够及时沟通进度与存在问题，并互相帮助并提供解决方案。</p></li><li><p>抗压能力得到提升。</p></li></ul><p>反思不足：</p><p><strong>业务方面：</strong></p><ul><li>业务理解还停留于表层，经常被动接受并消化产品传递来的信息而无法很好的反馈。</li><li>对业务的远瞻性和敏感度不足，相对模糊的需求没有尽早明确，导致对开发耗时及排期估算不准确。</li><li>方案设计不够完善，例如组件库的选择只考虑是否能够完成相应需求以及当前是否在维护，没有与组内通用的组件库保持一致，导致后续重构的风险。</li></ul><p><strong>技术方面：</strong></p><ul><li>技术涉猎单一且固定，代码编写水平依然需要进一步提高，同时对React等技术栈底层原理还不够深入。</li><li>技术设计水平还有待提高，在开发过程中出现过设计不够合理的情况，导致代码需要重构。</li><li>对组内平台的底层原理不够了解，遇到样式或功能bug不能及时定位。</li></ul><p><strong>软实力：</strong></p><ul><li>当多任务并行时，心态会比较急躁，时间安排不合理，导致某段时间过于疲劳。</li><li>沟通表达能力还是有所欠缺。</li><li>写文档的能力有待提高，同时由于时间安排不合理，有时做了很多事情，来不及总结与整理。</li></ul><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>可以大体从三方面讲：</p><p><strong>业务方面：</strong></p><ul><li>尽快熟悉业务脉络和逻辑，加深组内平台和常用工具的理解与使用，快速融入工作氛围并适应工作节奏。</li><li>多关注业务的发展，弄清楚为何这么做，如何做的更好。视野不只停留在业务的开发上，更要对业务的落地、性能、效益进行思考。</li><li>对于接到手中的需求，提高方案调研与设计的能力，另外，对于产品需求不要总是被动地接收和消化，要多质疑、常思考、敢提问，争取在需求评审中能经常给出自己的意见。</li></ul><p><strong>技术方面：</strong></p><ul><li>对React、TypeScript、Webpack等源码及底层原理进行深入学习，提高自身在行业内的技术竞争力。</li><li>能力不只停留在已有的技术上，更要对新知识保持热情与追求，不断拓展技术的广度并持续钻研技术的深度，提升自己的行业竞争力。希望以后自己能成为行业大牛。</li><li>提升编写代码的鲁棒性和可靠性，当出现BUG时，能快速定位问题，主动担责，并尽快修复。</li></ul><p><strong>软实力：</strong></p><ul><li>协调好生活与工作的平衡，合理安排时间，确保工作有序无误地开展，培养自己的耐心并提高自己的抗压能力。</li><li>提升多方协作能力，能够对项目需求合理拆解，协调多人保质按时交付任务。</li><li>不要总是埋头做事，沟通表达能力要多加练习，平时注意反思总结，每天/周抽出时间进行个人的沉淀与记录。</li></ul><h2 id="遇到的困难"><a href="#遇到的困难" class="headerlink" title="遇到的困难"></a>遇到的困难</h2><p>STAR原则，什么情景，发生了什么事情，你怎么处理的，最终的结果是什么</p><p>本科时参加了一个电子设计大赛，当时要做的是设计一个电路特性测试仪模块。但由于这个题目本身就比较复杂，比赛时间又比较短，也没有提前购买一些器材，因此比赛进行到一半时，一起参赛的队友已经想放弃了。但我觉得放弃太可惜了，一方面给队友打气鼓劲，一方面要做的事情进行规划和任务分级，因为这个比赛是有基础部分和发挥部分，首先不一定按照先基础再发挥去实现，而应该具体去分析里面最容易实现、耗时最短的先实现，同时针对一些问题提出自己的一些解决方案，比如单片机ad采集太小太大都不行，所以我当时提出使用负反馈的方法接入运算放大器，在这种接法中，放大倍数与运放外接的反馈电阻大小有关：倍数为反馈电阻和信号输入端电阻之比。在保证放大后的电压正常采集的情况下，对输入电压经过放大再采集。这样就能同时记录输入前后的电压。就这样，大家坚持到了最后一天，最后也是取得了省二等奖的成绩。最大感悟就是不轻言放弃，理论联系实际，敢于动手尝试。当时间紧、任务多时，一定要做好任务分级、 学会取舍，同时团队分工要明确合理，并要关注团队成员的心态。另外，凡事预则立，不预则废。如果提前尽可能做准备，可能就不会陷入这种境地。</p><p>研究生阶段遇到的最大的困难应该是实验室课题研究到发论文这整个阶段。首先那段时间从各种角度来说都不顺利，第一点就是我这个研究点最早是一位博士师兄提的仿真，导师想让我进行实验验证，当时那个点是基于OFDM来做的，而博士师兄已经毕业，实验室其他人几乎没有相关经验，实验进行非常不顺利。后来我改变思路，因为我只是要验证其中的某个算法，完全可以将系统中OFDM替换成单载波进行研究，后面一方面跟实验室师兄师姐请教，另一方面不断尝试总结，经历了几个月的时间，实验总算取得了还算不错的结果，最终成果发表了一篇二区SCI。</p><p>因为我们实验主要做的就是光通信DSP算法，而我做的又是空间光通信大气湍流抑制算法的研究，因此我投的这个期刊已经是比较高的了。</p><p>带给我收获就是：一要多进行思维的转变，但这并不是说不断放弃手中现有的方案，而是不断总结与改进，朝着我们最终的目标坚持下去，毕竟通往终点的路不是只有一条。二是善于与人沟通，做实验那段时间我几乎认识实验室所有博士老师，外校的学生，甚至器材维修人员，因为实验也好，工作也罢，跟身边人交流能带来最大的帮助就是他们的经验，多问几句话有时可以节省很多时间。</p><h2 id="课程-成绩-获奖情况-竞赛"><a href="#课程-成绩-获奖情况-竞赛" class="headerlink" title="课程/成绩/获奖情况/竞赛"></a>课程/成绩/获奖情况/竞赛</h2><p>研究生 通信网理论基础 86 光网络技术 88 研究生课程很多不进行考试 主要重点在实验室项目或课题</p><p>本科 高等数学 98 复变函数与积分变换 100 计算机程序设计（C语言） 93 信号与系统 96 电路 99</p><p>计算机二级、三级 GET4、6 普通话二级乙等</p><p>北邮 山科校一等奖学金 三好学生 优秀共青团员 优秀学生标兵等</p><p>第八届山东省大学生数学竞赛（非数学类）——省一等奖<br>山东省大学生物理竞赛——省三等奖<br>2019年全国大学生电子设计竞赛——省二等奖<br>2017年第十届“认证杯”数学建模网络挑战赛——省二等奖<br>2017年APMCM亚太地区大学生数学建模竞赛——省三等奖</p><p>2020-09～至今，研究自由空间光通信中的分集接收方案，并通过Matlab和Optilux实现40Gbps PM-CO-16QAM FSO空间分集接收仿真平台搭建，并进行了离线实验验证。成功发表一篇二区（Optics Express）SCI（导师一作、本人二作）：Performance analysis of a spatial diversity coherent free-space optical communication system based on optimal branch block phase correction.</p><h2 id="你经历的最大挫折是什么？"><a href="#你经历的最大挫折是什么？" class="headerlink" title="你经历的最大挫折是什么？"></a>你经历的最大挫折是什么？</h2><p>高考对我来说就是挺大的挫折吧，高中时期其实我成绩还算不错，当时正常发挥考上211应该不成问题，但最后因为考试心态等问题，考的相比平时差了不少，本科专业因为调剂也不想学，但后来也是慢慢调整自己，在本科期间换了专业，参加各类比赛等等，最终考研来到了北邮，现在看来高考失利也只是人生路上的一个小插曲，未来路还很长，还是要一直充满希望的。</p><h2 id="优缺点-竞争力"><a href="#优缺点-竞争力" class="headerlink" title="优缺点 竞争力"></a>优缺点 竞争力</h2><h3 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h3><p>乐观开朗，乐于助人，适应能力强，不管学校还是公司，都能够与身边的人愉快相处。</p><p>技术视野开阔，喜欢钻研，具有良好的学习能力，热爱编程，对业界新技术敏感，开拓创新意识强，能保持不断进取的精神。像平时经常会在B站看一些学习或者技术类的视频，也会经常浏览知乎、掘金、包括一些个人的博客论坛网站，丰富自己的视野，如果是比较新的技术，可能直接去看一些国外的网站或文章会收获更多。</p><p>注重团队合作，有着强烈的责任心和高度执行力。</p><p>抗压能力还算可以，应对实验室或公司中时间紧任务重的情况，能够从容进行任务的分级与梳理，积极沟通协调，同时调整生活<br>和工作上的平衡，力争每次都能按时保质地交付手中的任务。</p><h3 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h3><p>沟通能力还是需要进一步提高，在之前实习过程中，从最开始不好意思开口问，到后来有不懂的地方及时发问，并能与产品、后端及组内同事保持良好沟通，共同完成项目的开发。但沟通交流本身就是一门学问，需要不断磨练与提高，自己在这方面还是有很长的路要走。</p><p>提升多方协作能力，能够对项目需求合理拆解，协调多人保质按时交付任务。尽量提高自己的一个管理或者领导能力，树立大局观，不要总是埋头做事，平时注意反思总结，每天/周抽出时间进行个人的沉淀与记录，这样之后才能走得更远。</p><h2 id="你平时是怎么学习的？"><a href="#你平时是怎么学习的？" class="headerlink" title="你平时是怎么学习的？"></a>你平时是怎么学习的？</h2><p>基础学习：</p><p>B站、MDN（建议英文，中译有误）和官网（React、React Router）</p><p>知识拓展：</p><p>掘金/知乎/segmentfault思否/CSDN、阮一峰博客</p><p>bug：</p><p>Stack overflow</p><h2 id="你什么时候接触前端的-为啥学前端"><a href="#你什么时候接触前端的-为啥学前端" class="headerlink" title="你什么时候接触前端的/为啥学前端"></a>你什么时候接触前端的/为啥学前端</h2><p>本科时候做词典APP，里面离线数据是通过爬虫获取的，所以对html有了一些了解，包括安卓开发的XML布局，其实也跟前端比较类似。在我看来，学习前端是一件很有意思的一件事，随着我学习进度的增加，慢慢的，我发现了前端所做的都是用户可以最直观感受和体验的，也是最能让开发者感受到成就感的。</p><p>当然最早学前端，也因为它入门更容易，但随着学习深入就会发现现在的前端已经不是原先的切图仔，如果把前端狭义的理解为做页面，那天花板当然低了，但对应的，后端也可以被理解为 CRUD，天花板也很低。这时候如果把数据库 AI 这些扯进后端范畴，那么广义的前端也应该包含一切和交互相关的内容，比如网络资源优化、自动化部署、交互体验研究、设计和开发协作、跨平台渲染引擎、字符排版、甚至浏览器本身就是前端范畴。</p><p>当然，前端也不是归宿，后端语言像nodejs或其他也要学习，语言永远只是工具，重要的是开发的思想。另一方面，技术是需要给业务赋能，所以想走的更远，只学技术也不够。</p><p>前端的工程体系难就难在庞杂，链路长，环节多，而且和许多其他领域有交叉（比如网络、运维、编译器、图形学、人机交互理论、PL/DSL 设计），吃透一个环节的难度确实不难，但作为大厂的前端负责人需要规划整合这些东西，我是觉得天花板一点也不低。</p><h2 id="有无意向offer"><a href="#有无意向offer" class="headerlink" title="有无意向offer"></a>有无意向offer</h2><p>可能我秋招投的不是很早吧，现在有一些公司进展到二面、三面环节了，比如华为等。</p><p>美团因为实习的原因，估计会有转正，但那边主要做的是ToB的项目或低代码，而且工作强度还是有一些的，所以就想看看其他公司的业务或技术的发展方向，其次包括团队氛围、工作压力或稳定、还有技术提升都会考虑。</p><p>当初投B站也是因为很早就开始玩B站，平时看视频B站相对更多一些，也有一个六级号，所以本身对B站这个公司还是很感兴趣的，而且B站不论是用户还是工作人员，基本还是比较年轻的，所以工作氛围可能相对更好一些。</p><h2 id="情商跟职商"><a href="#情商跟职商" class="headerlink" title="情商跟职商"></a>情商跟职商</h2><p>举几个例子：</p><p>1.你和同事意见相左怎么办？</p><p>2.你和老板意见出现分歧，而你比较笃定你的想法是正确的。这时你会怎么做？</p><p>3.领导如果让你做假账，你做不做？</p><p>4.上司分配给你的任务，并不是你喜欢的，这个时候你应该怎么做？</p><p>5.如果你的leader和boss意见冲突，都要求你完成一个紧急任务，该怎么办？</p><p><strong>比如第一个问题，“你和同事意见相左怎么办？”我们不妨可以这样回答。</strong></p><p><strong>答：</strong>工作中遇到分歧的是在所难免的。</p><p>我会尽量站在对方的⻆度去理解这个问题，首先审视一下自己的认识有没有局限。</p><p>如果发现我的观点没有问题，那我会在坚持我最主要原则的前提下，多通过一些策略性的沟通方式，比如，多对对方的观点、付出的努力、观点的价值表示认可，然后阐述我自己考虑问题的出发点是什么，以此来争取对方的理解和支持。</p><p><strong>一句话总结：理解分歧，坚持底线，柔性解决。记住，体现态度！</strong></p><h2 id="城市"><a href="#城市" class="headerlink" title="城市"></a>城市</h2><p>像上海、北京这种大城市虽然生活成本偏高；但对个人来讲，发展和上升空间相较于小城市和县城还是高不少。另外，很多曾经包括现在的同学都留在了大城市，没事还能一起聚餐玩一玩，生活圈子可能会更广一些。</p><p>大城市就是工作机会多、发展好等等，小城市就是离家近、消费低等等。</p><p>北上深仍旧是薪资高地，杭州紧随其后，硕士平均薪资杭州甚至排第二。</p><p>值得注意的是，<strong>西安是北方城市里北京以外唯一上榜城市</strong>，虽然时不时被唱衰，但如果想留在北方，又觉得北京生活压力大，西安确实是个不错的选择。</p><p><strong>未来竞争力 ：</strong>根据仲量联行最新发布的《中国城市12强》报告，遴选出全国12座具有「未来竞争力」的城市。拥有未来竞争力的城市主要特点是<strong>聚集了众多新一代高新技术企业，能推动下一轮发展浪潮。</strong>这12座城市按照得分高低排列依次是<strong>上海、北京、深圳、广州、杭州、南京、苏州、武汉、天津、成都、重庆、西安。</strong></p><p><strong>处于第一梯队：厦门、深圳、上海、北京和广州。</strong></p><p>全国排名第一的是厦门，房价收入比超过30，也就是说以目前厦门的平均工资和房价，两夫妻购买一套120平的房子，得不吃不喝30年，又吃又喝得60年，又吃又喝带上一个娃估计90年。</p><p><strong>处于第二梯队「房价收入比＞20」是福州、天津、南京、杭州。</strong></p><p>大多数人，入驻北上广深杭是为了赚取高工资、获取剪刀差，本没指望在当地成家的。<strong>但厦门、福州、天津和南京可不一样，以目前的房价收入比，是很难支撑梦想的。</strong></p><p>全国主要城市中，房价收入比较为合理的是沈阳、长沙和西安（10左右）。</p><p><strong>西安：</strong>除了「三放四降」，同时给予大学毕业生住房租住支持。<br><strong>长沙：</strong>本科及以上学历青年人才落户并工作，政府提供两年生活补贴；<br><strong>沈阳：</strong>只要你来找工作，政府提供免费的住宿；<br><strong>海南：</strong>为愿意落户并创业的人才提供300万元的贷款；<br><strong>武汉：</strong>打出5年留下百万大学生，每个月都有政策出台；<br><strong>天津：</strong>本科生不超过40岁，硕士生不超过45岁，博士不受年龄限制，直接落户天津，不用缴纳社保，不用居住证。</p><h2 id="爱好"><a href="#爱好" class="headerlink" title="爱好"></a>爱好</h2><p>平时会和朋友们一起打篮球、打羽毛球，也喜欢动漫、影视、听音乐之类放松下自己，其实本科阶段我也做过B站的up主，上传过一些自己剪辑的视频，只不过后来因为时间有限就断更了。（国漫、日漫、影视的剪辑类视频，2000+粉丝）</p><h2 id="对公司的了解？为啥选"><a href="#对公司的了解？为啥选" class="headerlink" title="对公司的了解？为啥选"></a>对公司的了解？为啥选</h2><p>公司了解、企业文化、影响力</p><p>跟岗位匹配</p><p>研究生课题自由空间光通信其实很早就有了相关研究，但其应用场景太有限，对其前景暂不看好。更喜欢做工程开发，能带来更多成就感。</p><p>不太喜欢互联网公司一味图快的工作氛围，有许多不必要的竞争，希望选择踏实做事的企业作为长期赛道，认认真真地去将具体事落地，产出价值。</p><h3 id="完美世界"><a href="#完美世界" class="headerlink" title="完美世界"></a>完美世界</h3><p>完美世界控股集团<strong>全球领先的文化娱乐产业集团，拥有A股上市公司完美世界股份有限公司（002624）。旗下产品遍布美、欧、亚等全球100多个国家和地区；在北京、香港、上海、重庆、成都、海南、武汉、杭州等地皆设有分支机构，在欧美、日韩、东南亚等国家和地区设有多个海外分支机构。</strong>目前，集团涵盖影视、游戏、电竞、院线、动画、教育、全历史、成家相亲、万词王、88邮箱等业务板块。</p><p>完美世界自2011年至2021年，10次被认定为中国文化企业30强，并获评2011-2012年度、2013-2014年度、2015-2016年度、2017-2018年度、2019-2020年度国家文化出口重点企业；2016年、2020年，两次获最具社会责任上市公司奖；2021年入选第四批“国家文化和科技融合示范基地”。</p><h3 id="B站"><a href="#B站" class="headerlink" title="B站"></a>B站</h3><p>六级用户 日漫/国漫、科技、学习、生活、鬼畜等 up主 做过视频 动漫影视剪辑类的</p><p><strong>没有广告</strong> 生态环境：高自由度的并且激励用户创作的运营方式，二次创作和自主创作较多</p><p>B站其实最有竞争力的是专业，硬核，不管游戏，鬼畜，还是财经。这一点其实还是在优质up主上，b站今后如果可以给优质up主创造一个良好的盈利和发展环境，还是未来可期的。</p><p>其实，现在在首页和排行榜的尽是良莠不齐、鱼龙混杂的内容，需要用户自己寻找其中的宝藏。长此以往，必将“劣币驱逐良币”，B站赖以生存的基石（优秀内容创造者）也会土崩瓦解。一方面可要让用户更轻松地看到更优质有趣的视频，另一方面激励这类视频up主的创造积极性。</p><p>还有很重要的一点，就是用户量的激增，用户质量肯定良莠不齐，弹幕评论环境也会有所恶化，这也十分需要关注。</p><p>当然，这些情况的改善需要更高管理层做出一些举措，作为开发人员，我们能做的可能就是用技术，帮助up主活的更好。</p><p>当初投B站也是因为很早就开始玩B站，平时看视频B站相对更多一些，也有一个六级号，所以本身对B站这个公司还是很感兴趣的，而且B站不论是用户还是工作人员，基本还是比较年轻的，所以工作氛围可能相对更好一些。</p><h3 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h3><p><strong>为什么选择华为，华为有哪些吸引你加入的地方</strong></p><ul><li>对于应届毕业生来说，第一份工作尤为重要，这将决定你的职业眼光，发展前景，还有你身边的人将极大的影响你的未来，需要谨慎选择。华为作为一个较大的平台。</li><li>该部门的方向也是与我比较匹配的。</li></ul><p><strong>如何看待华为文化</strong></p><p>华为的”<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%8B%BC%E6%80%A7%E6%96%87%E5%8C%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2259609598%22%7D">狼性文化</a>“可以用这样的几个词语来概括:<strong>学习，创新、获益、团结</strong>。用狼性文化来说，学习和创新代表敏锐的嗅觉，获益代表进攻精神，而团结就代表群体奋斗精神</p><p>不是出路，就是出局。适应公司或者是个人。</p><p><strong>对华为的了解</strong></p><p>华为当前的业务可分为四大领域：运营商业务、企业业务、消费者业务和云服务。四大业务领域相互协同、共同发展，拼接成华为生态战略布局版图。</p><p>对于我们很多普通人来说，对华为的了解也仅仅只限于手机。</p><p>特别是我爸妈这一代人，都比较喜欢用华为荣耀的手机。</p><p>她说，别人都说华为手机好，所以就买了。</p><p>我觉得这就很有代表性：知道华为手机好，但不知道华为手机为什么好，你再问问ta对华为还知道什么，他们也就说不清楚了。</p><p>其实华为手机并不是华为的全部，华为除了在手机行业，华为目前仍在开展的业务有很多，其中大部分业务都处于行业前列。</p><p>华为每年投入那么多钱搞研发，是实实在在的做出来了成果。</p><p>华为智能汽车解决方案BU作为<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%8D%8E%E4%B8%BA%E5%85%AC%E5%8F%B8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2271488088%22%7D">华为公司</a>面向汽车行业的研发和商业实体，聚焦以ICT技术为客户提供高价值、高可靠的智能驾驶、智能座舱、智能电动、智能车云产品和解决方案，帮助车企造好车，引领汽车进入数字智能新时代。</p><h3 id="国家电投"><a href="#国家电投" class="headerlink" title="国家电投"></a>国家电投</h3><p>月薪1w *16 1000餐补 房补 8000福利 总包20 户口</p><p>老师推荐</p><p>国家电投是我国五大发电集团之一，是全球最大的光伏发电企业</p><p>国家电投集团数字科技有限公司成立于2013年8月，是国家电力投资集团有限公司承担信息化建设实施和信息技术开发应用的专业化平台公司。公司现有资产总额4.29亿元，获得国家高新企业资质，具备咨询服务、应用开发、项目管理、运行维护、信息安全等IT全产业链业务能力和完备资质。</p><p>公司秉承“服务集团，让企业和能源更智慧”的使命，致力于成为集团公司管理数字化的坚强平台，产业数字化的技术领跑者、市场主力军，成为国内领先、国际知名的能源数字科技企业</p><h3 id="中兴"><a href="#中兴" class="headerlink" title="中兴"></a>中兴</h3><p>一方面实验室之前有跟中兴有过项目合作，虽然我并没有参与，但也有所耳闻，比如LDPC信道编码、FTN-WDM（超奈奎斯特波分复用）等等；另一方面，中兴的手机也是我们大家最早了解的，现像今年出了一款屏下摄像头的中兴 Axon 40 Ultra，另外还有努比亚和红魔两个品牌。红魔作为游戏手机，总体销量不错。</p><p>中兴通讯是全球领先的综合通信解决方案提供商，中国最大的通信设备上市公司。主要产品包括：2G/3G/4G/5G无线基站与核心网、IMS、固网接入与承载、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%89%E7%BD%91%E7%BB%9C/6219507?fromModule=lemma_inlink">光网络</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%8A%AF%E7%89%87/32249?fromModule=lemma_inlink">芯片</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%AB%98%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%99%A8/6620986?fromModule=lemma_inlink">高端路由器</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%99%BA%E8%83%BD%E4%BA%A4%E6%8D%A2%E6%9C%BA/742295?fromModule=lemma_inlink">智能交换机</a>、政企网、大数据、云计算、数据中心、手机及家庭终端、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82/9334841?fromModule=lemma_inlink">智慧城市</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ICT/32270?fromModule=lemma_inlink">ICT</a>业务，以及航空、铁路与城市轨道交通信号传输设备。</p><h2 id="期望薪资"><a href="#期望薪资" class="headerlink" title="期望薪资"></a>期望薪资</h2><p>总包 月薪 年终奖 其他补贴 当地消费水平</p><h3 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h3><p>普通 21-24k sp 25-26 ssp 27-29 *15.5</p><p>晚走 饭补车补</p><h3 id="华为-1"><a href="#华为-1" class="headerlink" title="华为"></a>华为</h3><p>普通14 (16-24) sp15 (25-29) ssp16 (30-38) *(14-16)</p><p>公积金5% 通信补贴 交通补贴</p><h3 id="b站"><a href="#b站" class="headerlink" title="b站"></a>b站</h3><p>普通 (20-23) sp (24-27) ssp (28-30) *(15-18)</p><p>上海 饭补 优秀的转正后1k补贴</p><h3 id="中兴-1"><a href="#中兴-1" class="headerlink" title="中兴"></a>中兴</h3><p>20 / 23*12</p><p>西安</p><h3 id="完美"><a href="#完美" class="headerlink" title="完美"></a>完美</h3><p>很多游戏 23k 25k</p><h2 id="家庭-单身"><a href="#家庭-单身" class="headerlink" title="家庭/单身"></a>家庭/单身</h2><p>家是在一个普通小县城，感觉相比大城市的工作机遇和发展前景还是差很多，因此想在大城市工作感受下；家里父母都是普通打工人，但家庭氛围很和睦，也很重视教育，父母也都支持我的决定。目前没有女朋友，但我觉得对找工作可能不是一件坏事，我可以只考虑自身情况去选择工作地点等等。</p><h2 id="期望的团队"><a href="#期望的团队" class="headerlink" title="期望的团队"></a>期望的团队</h2><p>和谐愉快地相处、平时工作上可以互相帮助，下班有时间也能一起玩耍。团队做的项目期望是一些核心或者能对个人有所提升的项目，当然也不是除此之外的项目就不做了。</p><h2 id="加班"><a href="#加班" class="headerlink" title="加班"></a>加班</h2><p>如果公司需要，我是可以加班的，比如项目着急上线等等，但我不希望有无意义的加班，另一方面我会尽可能提高工作效率，避免加班问题的出现。</p><h2 id="如何看待-toB-与-toC"><a href="#如何看待-toB-与-toC" class="headerlink" title="如何看待 toB 与 toC"></a>如何看待 toB 与 toC</h2><p>从职业方向取舍的角度看，我认为纠结这两个点没必要，toB 的业务可能很简单，toC 的业务也可能很复杂，两个端的壁垒也没有那么大。</p><p>从传统观点上看：</p><p>toB：业务复杂，表单和定制化需求较多，需要给出一整套解决方案，但对体验和交互要求没有那么重要 。</p><p>toC：偏向用户体验的内容稍多，移动端的内容稍多。对性能的要求略高，每个产品的功能不复杂，业务开始只需要满足用户的一个痛点。</p><p>但随着前端能力的增加，很多工具类软件都可以由前端承载，代码的复杂度也随之上升，前端从传统的辅助地位逐渐走向了客户端工程师的地位，内容也逐渐变得更有挑战性。</p><p>但如果从公司的角度看，toB 的公司一般面向政府、企事业单位，以供应商的身份提供技术咨询、定制化开发、业务支持等服务，回款周期较长，如果外部环境不好，资金流不畅，很容易拖欠工资。 但是，节奏没有那么快，一切都有较长的排期，相对更规范一些。</p><p>toC 的公司，一般都自负盈亏，现金流相对会快一些。但是现在的互联网企业都搞什么敏捷开发，基本上一周或者两周就一个版本，面向市场需要小步快跑。</p><h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><h4 id="主管面反问"><a href="#主管面反问" class="headerlink" title="主管面反问"></a>主管面反问</h4><ul><li>对应届生的培养方式</li><li>我的base地</li><li>试用期的考核？</li><li>晋升体系</li><li>业务方向的发展？</li></ul><h4 id="技术面反问"><a href="#技术面反问" class="headerlink" title="技术面反问"></a>技术面反问</h4><p>您觉得，这份工作所需的能力，我还有哪些不具备？</p><p>部门/公司的主要研究方向？工作地点？</p><p>部门/公司的团队规模以及未来的主要规划？</p><p>入职是否有员工培训，具体内容是什么？</p><p>前端未来的发展如何？例如低代码、web3.0这种?</p><h3 id="HR"><a href="#HR" class="headerlink" title="HR"></a>HR</h3><p>待遇、部门业务、发展前景、加班情况、培训体系、签约年限、不要主动问三方违约金、试用期/见习期</p><p>年假、事假、病假等每年都有多少天？</p><p>工作的作息</p><p>试用期多久（试用期的工资）</p><p>公积金是多少？</p><p>面试结果什么时候出来？</p><p>面试官您好，我想知道您听完我的回答有什么比较好的建议么？</p><p>进去之后的晋升机制是怎样的？会经常有技术交流的活动么？</p><p>总包20W，但是这一年是哪一年，这是HR的一个模糊话说。通常人会认为这是从入职起的第一年，总包20W。但HR可能说的是转正之后的第一个完整年总包20万。这里的差异可是不小的，所以有必要拿到offer时问清楚。国企和银行的试用期的待遇都是较低的，一般是转正之后的八折，甚至有银行试用期的工资是转正之后的五折（如中国农业银行）。年终奖</p><h1 id="SaaS、IaaS、PaaS、iPaaS和aPaaS"><a href="#SaaS、IaaS、PaaS、iPaaS和aPaaS" class="headerlink" title="SaaS、IaaS、PaaS、iPaaS和aPaaS"></a>SaaS、IaaS、PaaS、iPaaS和aPaaS</h1><h2 id="SaaS、IaaS、PaaS"><a href="#SaaS、IaaS、PaaS" class="headerlink" title="SaaS、IaaS、PaaS"></a>SaaS、IaaS、PaaS</h2><p>我们传统开发一个软件，需要9个东西：</p><p><a target="_blank" rel="noopener" href="https://imgse.com/i/vXwRDs"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/09/12/vXwRDs.png" alt="vXwRDs.png"></a></p><p>作为使用软件的人，左边的【应用】和【数据】，是<strong>离我们最近的部分。</strong></p><blockquote><p>比如最常见的：我们在某软件里提交了报销申请，其实我们就是上传了自己的报销数据到应用中。</p></blockquote><p>最右边的【虚拟化】、【服务器】、【存储】、【网络】是制作一个软件的基础条件，除了虚拟化技术其他都是硬件，所以在云计算领域中，这块被称为基础设施。</p><blockquote><p>它们在机房都能看到。</p></blockquote><p>而中间的这些，就是<strong>利用最右边</strong>的基础设施搭建出的平台，从而<strong>承载最左边</strong>的【应用】和【数据】。</p><p>所以说，从右到左就是一个硬件逐渐软化（软件开发）的过程，IT技术在这个过程中扮演了必要角色：</p><p>但！</p><p><strong>不是所有企业都具有独立开发一个软件的资本</strong>（钱、人、力缺哪个都不行）。</p><p>所以，云服务产生了。</p><p>大大小小企业，财力不同、问题不同，因此对于软件的开发，总有形形色色的需求。</p><p><strong>经过演变，云服务逐渐分为三类：</strong></p><blockquote><p>第一种，云服务提供基础设施，我们可能听过某某说“租了哪里的服务器，准备自己搞个软件……”，其实就是Iaas。<br>第二种，云服务提供一个平台，企业自己设计应用，数据也由自己保管。这就是Paas。<br>第三种，云服务提供现成的软件，数据也全部上云。这就是SaaS。</p></blockquote><p>如图：</p><p><a target="_blank" rel="noopener" href="https://imgse.com/i/vXw55V"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/09/12/vXw55V.png" alt="vXw55V.png"></a></p><p>从Iaas到SaaS的过程，企业需要付出的成本越来越小，云化的程度也越来越高。</p><h2 id="iPaaS和aPaaS"><a href="#iPaaS和aPaaS" class="headerlink" title="iPaaS和aPaaS"></a>iPaaS和aPaaS</h2><p><strong>ipaas和apaas的产生，是因为企业在使用软件过程中，又遇到了难以解决的问题：</strong></p><p>1、<strong>对于很多企业来说，SaaS都是固定功能的软件，</strong>对于自己需要个性化的需求难以满足，虽然软件开发能灵活满足自己的需求，但是无论是自研还是托管，开发和运维费用都极其高昂</p><p>3、一个软件解决不了所有问题，那就多堆几个软件，<strong>导致一个企业可能用了五六个软件，但都互相独立，无论是功能还是数据，都不能连起来</strong></p><p>本来想通过信息化提高效率、解决数据难题的，却使得数据壁垒越来越厚、事情越做越多。</p><p><strong>这可不行。</strong></p><p><strong>所以ipaas和apaas产生了。</strong></p><p><strong>首先，是企业的个性化问题。</strong></p><p>堵死一大批企业的，其实就是软件开发的门槛过高。要找到懂开发又懂业务的IT太难了，业务人员为了开发去学编程也不是朝夕就能实现。</p><p>怎么才能提供一种框架，让业务人员不需要学代码就能自己设计出一个管理软件呢？这种模式就是apaas，从应用和数据层面入手，设计搭建工具与逻辑，实现零代码开发。</p><p>而apaas从<strong>应用和数据层面入手</strong>，就足以看出，它趋向于PaaS和SaaS之间。</p><p><strong>其次，就是打通企业内部的各个软件问题。</strong></p><p>由于企业堆叠的各种SaaS软件，用着不同的主机和数据库，怎么将这些软件集成起来？这就需要一种技术，也就是iPaaS。</p><p>它从<strong>虚拟主机和数据库层面</strong>入手，创建一个中心生态系统来查看、管理和修改所有数据、基础设施和操作。从而轻松打通各个系统的数据与功能。</p><p>可以看出，iPaaS则趋向于IaaS和PaaS之间。</p><h3 id="各自功能："><a href="#各自功能：" class="headerlink" title="各自功能："></a>各自功能：</h3><ul><li>解决企业里各个软件造成的壁垒问题，减轻IT任务量——ipaas</li><li>满足企业追求的灵活但要性价比高的软件开发，降低开发门槛——apaas</li></ul><h3 id="技术偏重点："><a href="#技术偏重点：" class="headerlink" title="技术偏重点："></a>技术偏重点：</h3><ul><li>ipaas偏向IaaS</li><li>apaas偏向SaaS</li></ul><h3 id="使用对象："><a href="#使用对象：" class="headerlink" title="使用对象："></a>使用对象：</h3><ul><li>ipaas：IT人员</li><li>apaas：所有人</li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></p><p><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</p><p><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</p><p><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</p><p>简单来讲，操作系统就是一种复杂的软件，相当于软件管家。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。</p><p><strong>操作系统的核心概念都是对具体物理硬件的抽象</strong>，主要有如下：</p><ul><li>进程（线程）：<strong>进程（线程）是操作系统对CPU的抽象</strong></li><li>虚拟内存（地址空间）：<strong>虚拟内存是操作系统对物理内存的抽象</strong></li><li>文件：<strong>文件是操作系统对物理磁盘的抽象</strong></li><li>多线程(multithreading)：是指从软件或者硬件上实现多个线程并发执行的技术</li><li>CPU 核心(core)：它是 CPU 的大脑，它接收指令，并执行计算或运算以满足这些指令。一个 CPU 可以有多个内核</li><li>图形处理器(Graphics Processing Unit)：又称显示核心、视觉处理器、显示芯片或绘图芯片</li><li>缓存命中(cache hit)：当应用程序或软件请求数据时，会首先发生缓存命中</li><li>RAM((Random Access Memory)：随机存取存储器，也叫主存，是与 CPU 直接交换数据的内部存储器</li><li>ROM (Read Only Memory)：只读存储器是一种半导体存储器，其特性是一旦存储数据就无法改变或删除</li><li>进程间通信(interprocess communication)： 指至少两个进程或线程间传送数据或信号的一些技术或方法</li></ul><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ol><li><strong>用户态(user mode)</strong> : 用户态运行的进程可以直接读取用户程序的数据。</li><li><strong>系统态(kernel mode)</strong>:可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li></ol><p>说了用户态和系统态之后，那么什么是<strong>系统调用</strong>呢？</p><p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p><p>也就是说在我们运行的用户程序中，<strong>凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</strong></p><p>这些系统调用按功能大致可分为如下几类：</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/L181kk2Eou-compress.jpg" alt="img"></p><h2 id="进程和线程★"><a href="#进程和线程★" class="headerlink" title="进程和线程★"></a>进程和线程★</h2><blockquote><p>考察公司：华为</p></blockquote><h3 id="进程、线程和协程"><a href="#进程、线程和协程" class="headerlink" title="进程、线程和协程"></a>进程、线程和协程</h3><ul><li>进程是<strong>系统进行资源分配和调度的一个独立单位</strong>。</li><li>线程是<strong>CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位</strong>。</li><li>协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的轻量级线程，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。</li></ul><p><strong>一个进程至少由一个线程组成</strong>。线程自己基本上<strong>不拥有系统资源</strong>，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程<strong>共享进程所拥有的全部资源</strong>。</p><p>进程与进程之间完全隔离，互不干扰，一个进程崩溃不会影响其他进程，避免一个进程出错影响整个程序 。</p><p>一个进程中可以并发多个线程，每个线程并行执行不同的任务 。</p><p>一个进程中的任意一个线程执行出错，会导致这个进程崩溃 。</p><p>同一进程下的线程之间可以直接通信和共享数据 。</p><p>当一个进程关闭之后，操作系统会回收该进程的内存空间。</p><h3 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h3><p>浏览器从关闭到启动，然后新开一个页面至少需要：1个浏览器进程，1个GPU进程，1个网络进程，和1个渲染进程，一共4个进程；</p><p>后续如果再打开新的标签页：浏览器进程，GPU进程，网络进程是共享的，不会重新启动，然后默认情况下会为每一个标签页配置一个渲染进程，但是也有例外，比如从A页面里面打开一个新的页面B页面，而A页面和B页面又属于同一站点的话，A和B就共用一个渲染进程，其他情况就为B创建一个新的渲染进程。</p><p>所以，最新的Chrome浏览器包括：1个浏览器主进程，1个GPU进程，1个网络进程，多个渲染进程，和多个插件进程。</p><ul><li><strong>浏览器进程</strong>：负责控制浏览器除标签页外的界面，包括地址栏、书签、前进后退按钮等，以及负责与其他进程的协调工作，同时提供存储功能。</li><li><strong>GPU进程</strong>：负责整个浏览器界面的渲染。Chrome刚开始发布的时候是没有GPU进程的，而使用GPU的初衷是为了实现3D CSS效果，只是后面网页、Chrome的UI界面都用GPU来绘制，这使GPU成为浏览器普遍的需求，最后Chrome在多进程架构上也引入了GPU进程 。</li><li><strong>网络进程</strong>：负责发起和接受网络请求，以前是作为模块运行在浏览器进程一时在面的，后面才独立出来，成为一个单独的进程。</li><li><strong>插件进程</strong>：主要是负责插件的运行，因为插件可能崩溃，所以需要通过插件进程来隔离，以保证插件崩溃也不会对浏览器和页面造成影响。</li><li><strong>渲染进程</strong>：负责控制显示tab标签页内的所有内容，核心任务是将HTML、CSS、JS转为用户可以与之交互的网页，排版引擎Blink和JS引擎V8都是运行在该进程中，默认情况下Chrome会为每个Tab标签页创建一个渲染进程。</li></ul><p><strong>渲染进程（浏览器内核）</strong></p><p>浏览器的渲染进程是<strong>多线程</strong>的，<strong>页面的渲染，JavaScript 的执行，事件的循环</strong>，都在这个进程内进行：</p><ul><li><strong>GUI 渲染线程</strong>：负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。</li><li><strong>JavaScript 引擎线程</strong>：也称为 JavaScript 内核，负责处理 Javascript 脚本程序、解析 Javascript 脚本、运行代码等。（例如 V8 引擎）</li><li><strong>事件触发线程</strong>：用来控制浏览器事件循环，注意这不归 JavaScript 引擎线程管，当事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。</li><li><strong>定时触发器线程</strong>：传说中的 setInterval 与 setTimeout 所在线程，注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms 。</li><li><strong>异步 http 请求线程</strong>：在 XMLHttpRequest 连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li></ul><p>注意，<strong>GUI 渲染线程与 JavaScript 引擎线程是互斥的</strong>，当 JavaScript 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JavaScript 引擎空闲时立即被执行。所以如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><p><strong>单线程的JavaScript</strong></p><p>所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><ol><li><strong>管道/匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li><li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li><li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li><li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。</strong></li><li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li><li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li><li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。</p><p><strong>产生死锁的四个必要条件是什么?</strong></p><p>如果系统中以下四个条件同时成立，那么就能引起死锁：</p><ul><li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li><li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li><li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li><li><strong>循环等待</strong>：有一组等待进程 <code>&#123;P0, P1,..., Pn&#125;</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li></ul><p>注意，只有四个条件同时成立时，死锁才会出现。</p><p><strong>解决死锁的方法</strong></p><p>解决死锁的方法可以从多个角度去分析，一般的情况下，有<strong>预防，避免，检测和解除四种</strong>。</p><ul><li><strong>预防</strong> 是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</li><li><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></li><li><strong>检测</strong>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</li><li><strong>解除</strong> 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</li></ul><h2 id="虚拟内存★"><a href="#虚拟内存★" class="headerlink" title="虚拟内存★"></a>虚拟内存★</h2><blockquote><p>考察公司：腾讯</p></blockquote><p>再问你一个常识性的问题！<strong>什么是虚拟内存(Virtual Memory)?</strong></p><p>这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。<strong>为什么可以这样呢？</strong> 正是因为 <strong>虚拟内存</strong> 的存在，通过 <strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。这样会更加有效地管理内存并减少出错。</p><p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。<strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 <strong>把内存扩展到硬盘空间</strong>。</p><h2 id="常见的锁★"><a href="#常见的锁★" class="headerlink" title="常见的锁★"></a>常见的锁★</h2><blockquote><p>考察公司：华为</p></blockquote><h3 id="互斥锁与自旋锁：谁更轻松自如？"><a href="#互斥锁与自旋锁：谁更轻松自如？" class="headerlink" title="互斥锁与自旋锁：谁更轻松自如？"></a>互斥锁与自旋锁：谁更轻松自如？</h3><p>最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。</p><p>加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。</p><p>当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：</p><ul><li><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li><li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li></ul><p>互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，<strong>既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞</strong>。</p><p><strong>对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的</strong>。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b4d5c8a73274715886c9bf672eca0d2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。</p><p>那这个开销成本是什么呢？会有<strong>两次线程上下文切换的成本</strong>：</p><ul><li>当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；</li><li>接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。</li></ul><p>线程的上下文切换的是什么？当两个线程是属于同一个进程，<strong>因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</strong></p><p>上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。</p><p>所以，<strong>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。</strong></p><p>自旋锁是通过 CPU 提供的 <code>CAS</code> 函数（<em>Compare And Swap</em>），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。</p><p>一般加锁的过程，包含两个步骤：</p><ul><li>第一步，查看锁的状态，如果锁是空闲的，则执行第二步；</li><li>第二步，将锁设置为当前线程持有；</li></ul><p>CAS 函数就把这两个步骤合并成一条硬件级指令，形成<strong>原子指令</strong>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</p><p>使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 <code>while</code> 循环等待实现，不过最好是使用 CPU 提供的 <code>PAUSE</code> 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。</p><p>自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。<strong>需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</strong></p><p>自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。</p><p>自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：<strong>当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对</strong>。</p><p>它俩是锁的最基本处理方式，更高级的锁都会选择其中一个来实现，比如读写锁既可以选择互斥锁实现，也可以基于自旋锁实现。</p><hr><h3 id="读写锁：读和写还有优先级区分？"><a href="#读写锁：读和写还有优先级区分？" class="headerlink" title="读写锁：读和写还有优先级区分？"></a>读写锁：读和写还有优先级区分？</h3><p>读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。</p><p>所以，<strong>读写锁适用于能明确区分读操作和写操作的场景</strong>。</p><p>读写锁的工作原理是：</p><ul><li>当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。</li><li>但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。</li></ul><p>所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。</p><p>知道了读写锁的工作原理后，我们可以发现，<strong>读写锁在读多写少的场景，能发挥出优势</strong>。</p><p>另外，根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。</p><p>读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取读锁。如下图：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24eeac7c225746cd8bff53ed2d8be52b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>而写优先锁是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取读锁。如下图：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f355161b38c94aa499292a6055b4c88f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。</p><p>写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。</p><p>既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。</p><p><strong>公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。</strong></p><p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p><hr><h3 id="乐观锁与悲观锁：做事的心态有何不同？"><a href="#乐观锁与悲观锁：做事的心态有何不同？" class="headerlink" title="乐观锁与悲观锁：做事的心态有何不同？"></a>乐观锁与悲观锁：做事的心态有何不同？</h3><p>前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。</p><p>悲观锁做事比较悲观，它认为<strong>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁</strong>。</p><p>那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。</p><p>乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：<strong>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作</strong>。</p><p>放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。</p><p>可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现<strong>乐观锁全程并没有加锁，所以它也叫无锁编程</strong>。</p><p>这里举一个场景例子：在线文档。</p><p>我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。</p><p>那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。</p><p>怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交改动，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。</p><p>服务端要怎么验证是否冲突了呢？通常方案如下：</p><ul><li>由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；</li><li>当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号一致则修改成功，否则提交失败。</li></ul><p>实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。</p><p>乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以<strong>只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。</strong></p><hr><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。</p><p>如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。</p><p>如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。</p><p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p><p>另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。</p><p>相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p><p>但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。</p><p>不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="操作系统简单分类"><a href="#操作系统简单分类" class="headerlink" title="操作系统简单分类"></a>操作系统简单分类</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>目前最流行的个人桌面操作系统 ，不做多的介绍，大家都清楚。界面简单易操作，软件生态非常好。</p><h3 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h3><p>最早的多用户、多任务操作系统 。后面崛起的 Linux 在很多方面都参考了 Unix。</p><p>目前这款操作系统已经逐渐逐渐退出操作系统的舞台。</p><h3 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h3><p><strong>Linux 是一套免费使用、开源的类 Unix 操作系统。</strong> Linux 存在着许多不同的发行版本，但它们都使用了 <strong>Linux 内核</strong> 。</p><blockquote><p>严格来讲，Linux 这个词本身只表示 Linux 内核，在 GNU/Linux 系统中，Linux 实际就是 Linux 内核，而该系统的其余部分主要是由 GNU 工程编写和提供的程序组成。单独的 Linux 内核并不能成为一个可以正常工作的操作系统。</p><p><strong>很多人更倾向使用 “GNU/Linux” 一词来表达人们通常所说的 “Linux”。</strong></p></blockquote><h3 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h3><p>苹果自家的操作系统，编程体验和 Linux 相当，但是界面、软件生态以及用户体验各方面都要比 Linux 操作系统更好。</p><h2 id="操作系统的内核（Kernel）"><a href="#操作系统的内核（Kernel）" class="headerlink" title="操作系统的内核（Kernel）"></a>操作系统的内核（Kernel）</h2><p>我们先来看看维基百科对于内核的解释，我觉得总结的非常好！</p><blockquote><p><strong>内核</strong>（英语：Kernel，又称核心）在计算机科学中是一个用来管理软件发出的数据 I/O（输入与输出）要求的电脑程序，将这些要求转译为数据处理的指令并交由中央处理器（CPU）及电脑中其他电子组件进行处理，是现代操作系统中最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并由内核决定一个程序在什么时候对某部分硬件操作多长时间。 <strong>直接对硬件操作是非常复杂的。所以内核通常提供一种硬件抽象的方法，来完成这些操作。有了这个，通过进程间通信机制及系统调用，应用进程可间接控制所需的硬件资源（特别是处理器及 IO 设备）。</strong></p><p>早期计算机系统的设计中，还没有操作系统的内核这个概念。随着计算机系统的发展，操作系统内核的概念才渐渐明晰起来了!</p></blockquote><p>简单概括两点：</p><ol><li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</strong></li><li><strong>操作系统的内核是连接应用程序和硬件的桥梁，决定着操作系统的性能和稳定性。</strong></li></ol><h2 id="中央处理器（CPU，Central-Processing-Unit）"><a href="#中央处理器（CPU，Central-Processing-Unit）" class="headerlink" title="中央处理器（CPU，Central Processing Unit）"></a>中央处理器（CPU，Central Processing Unit）</h2><p>关于 CPU 简单概括三点：</p><ol><li><strong>CPU 是一台计算机的运算核心（Core）+控制核心（ Control Unit），可以称得上是计算机的大脑。</strong></li><li><strong>CPU 主要包括两个部分：控制器+运算器。</strong></li><li><strong>CPU 的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。</strong></li></ol><h2 id="CPU-vs-Kernel-内核"><a href="#CPU-vs-Kernel-内核" class="headerlink" title="CPU vs Kernel(内核)"></a>CPU vs Kernel(内核)</h2><p>很多人容易无法区分操作系统的内核（Kernel）和中央处理器（CPU），你可以简单从下面两点来区别：</p><ol><li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。</li><li>CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。</li></ol><p>下图清晰说明了应用程序、内核、CPU 这三者的关系。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png" alt="Kernel_Layout"></p><h2 id="初探-Linux"><a href="#初探-Linux" class="headerlink" title="初探 Linux"></a>初探 Linux</h2><h3 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h3><p>我们上面已经简单了 Linux，这里只强调三点。</p><ul><li><strong>类 Unix 系统</strong> ： Linux 是一种自由、开放源码的类似 Unix 的操作系统</li><li><strong>Linux 本质是指 Linux 内核</strong> ： 严格来讲，Linux 这个词本身只表示 Linux 内核，单独的 Linux 内核并不能成为一个可以正常工作的操作系统。所以，就有了各种 Linux 发行版。</li><li><strong>Linux 之父(林纳斯·本纳第克特·托瓦兹 Linus Benedict Torvalds)</strong> ： 一个编程领域的传奇式人物，真大佬！我辈崇拜敬仰之楷模。他是 <strong>Linux 内核</strong> 的最早作者，随后发起了这个开源项目，担任 Linux 内核的首要架构师。他还发起了 Git 这个开源项目，并为主要的开发者。</li></ul><h3 id="Linux-诞生"><a href="#Linux-诞生" class="headerlink" title="Linux 诞生"></a>Linux 诞生</h3><p>1989 年，Linus Torvalds 进入芬兰陆军新地区旅，服 11 个月的国家义务兵役，军衔为少尉，主要服务于计算机部门，任务是弹道计算。服役期间，购买了安德鲁·斯图尔特·塔能鲍姆所著的教科书及 minix 源代码，开始研究操作系统。1990 年，他退伍后回到大学，开始接触 Unix。</p><blockquote><p><strong>Minix</strong> 是一个迷你版本的类 Unix 操作系统，由塔能鲍姆教授为了教学之用而创作，采用微核心设计。它启发了 Linux 内核的创作。</p></blockquote><p>1991 年，Linus Torvalds 开源了 Linux 内核。Linux 以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。</p><h3 id="常见-Linux-发行版本有哪些？"><a href="#常见-Linux-发行版本有哪些？" class="headerlink" title="常见 Linux 发行版本有哪些？"></a>常见 Linux 发行版本有哪些？</h3><p>Linus Torvalds 开源的只是 Linux 内核，我们上面也提到了操作系统内核的作用。一些组织或厂商将 Linux 内核与各种软件和文档包装起来，并提供系统安装界面和系统配置、设定与管理工具，就构成了 Linux 的发行版本。</p><blockquote><p>内核主要负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</p></blockquote><p>Linux 的发行版本可以大体分为两类：</p><ul><li>商业公司维护的发行版本，以著名的 Red Hat 为代表，比较典型的有 CentOS 。</li><li>社区组织维护的发行版本，以 Debian 为代表，比较典型的有 Ubuntu、Debian。</li></ul><p>对于初学者学习 Linux ,推荐选择 CentOS 。</p><h2 id="Linux-文件系统概览"><a href="#Linux-文件系统概览" class="headerlink" title="Linux 文件系统概览"></a>Linux 文件系统概览</h2><h3 id="Linux-文件系统简介"><a href="#Linux-文件系统简介" class="headerlink" title="Linux 文件系统简介"></a>Linux 文件系统简介</h3><p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong> 也就是说在 Linux 系统中有一个重要的概念：<strong>一切都是文件</strong>。</p><p>其实这是 UNIX 哲学的一个体现，在 UNIX 系统中，把一切资源都看作是文件，Linux 的文件系统也是借鉴 UNIX 文件系统而来。</p><h3 id="inode-介绍"><a href="#inode-介绍" class="headerlink" title="inode 介绍"></a>inode 介绍</h3><p><strong>inode 是 linux/unix 文件系统的基础。那么，inode 是什么?有什么作用呢?</strong></p><p>硬盘的最小存储单位是扇区(Sector)，块(block)由多个扇区组成。文件数据存储在块中。块的最常见的大小是 4kb，约为 8 个连续的扇区组成（每个扇区存储 512 字节）。一个文件可能会占用多个 block，但是一个块只能存放一个文件。</p><p>虽然，我们将文件存储在了块(block)中，但是我们还需要一个空间来存储文件的 <strong>元信息 metadata</strong> ：如某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等。这种 <strong>存储文件元信息的区域就叫 inode</strong>，译为索引节点：<strong>i（index）+node</strong>。 每个文件都有一个 inode，存储文件的元信息。</p><p>可以使用 <code>stat</code> 命令可以查看文件的 inode 信息。每个 inode 都有一个号码，Linux/Unix 操作系统不使用文件名来区分文件，而是使用 inode 号码区分不同的文件。</p><p>简单来说：inode 就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。</p><p>简单总结一下：</p><ul><li><strong>inode</strong> ：记录文件的属性信息，可以使用 stat 命令查看 inode 信息。</li><li><strong>block</strong> ：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个 block，但是一个块只能存放一个文件。（因为数据是由 inode 指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）</li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://javaguide.cn/assets/%E6%96%87%E4%BB%B6inode%E4%BF%A1%E6%81%AF.d9175a2d.png" alt="文件inode信息"></p><h3 id="Linux-文件类型"><a href="#Linux-文件类型" class="headerlink" title="Linux 文件类型"></a>Linux 文件类型</h3><p>Linux 支持很多文件类型，其中非常重要的文件类型有: <strong>普通文件</strong>，<strong>目录文件</strong>，<strong>链接文件</strong>，<strong>设备文件</strong>，<strong>管道文件</strong>，<strong>Socket 套接字文件</strong>等。</p><ul><li><strong>普通文件（-）</strong> ： 用于存储信息和数据， Linux 用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。</li><li><strong>目录文件（d，directory file）</strong> ：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。</li><li><strong>符号链接文件（l，symbolic link）</strong> ：保留了指向文件的地址而不是文件本身。</li><li><strong>字符设备（c，char）</strong> ：用来访问字符设备比如键盘。</li><li><strong>设备文件（b，block）</strong> ： 用来访问块设备比如硬盘、软盘。</li><li><strong>管道文件(p,pipe)</strong> : 一种特殊类型的文件，用于进程之间的通信。</li><li><strong>套接字(s,socket)</strong> ：用于进程间的网络通信，也可以用于本机之间的非网络通信。</li></ul><h3 id="Linux-目录树"><a href="#Linux-目录树" class="headerlink" title="Linux 目录树"></a>Linux 目录树</h3><p>所有可操作的计算机资源都存在于目录树这个结构中，对计算资源的访问，可以看做是对这棵目录树的访问。</p><p><strong>Linux 的目录结构如下：</strong></p><p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录： <img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://javaguide.cn/assets/Linux%E7%9B%AE%E5%BD%95%E6%A0%91.b82202fa.png" alt="Linux的目录结构"></p><p><strong>常见目录说明：</strong></p><ul><li><strong>/bin：</strong> 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；</li><li><strong>/etc：</strong> 存放系统管理和配置文件；</li><li><strong>/home：</strong> 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是/home/user，可以用~user 表示；</li><li><strong>/usr ：</strong> 用于存放系统应用程序；</li><li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；</li><li><strong>/proc：</strong> 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li><li><strong>/root：</strong> 超级用户（系统管理员）的主目录（特权阶级^o^）；</li><li><strong>/sbin:</strong> 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；</li><li><strong>/dev：</strong> 用于存放设备文件；</li><li><strong>/mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li><li><strong>/boot：</strong> 存放用于系统引导时使用的各种文件；</li><li><strong>/lib ：</strong> 存放着和系统运行相关的库文件 ；</li><li><strong>/tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li><li><strong>/var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li><li><strong>/lost+found：</strong> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。</li></ul><h2 id="Linux-基本命令"><a href="#Linux-基本命令" class="headerlink" title="Linux 基本命令"></a>Linux 基本命令</h2><p>下面只是给出了一些比较常用的命令。</p><p>推荐一个 Linux 命令快查网站，非常不错，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。Linux 命令在线速查手册：<a target="_blank" rel="noopener" href="https://www.w3xue.com/manual/linux/">https://www.w3xue.com/manual/linux/</a> 。</p><p>另外，<a target="_blank" rel="noopener" href="https://www.shell.how/">shell.howopen in new window</a> 这个网站可以用来解释常见命令的意思，对你学习 Linux 基本命令以及其他常用命令（如 Git、NPM）。</p><h3 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h3><ul><li><strong><code>cd usr</code>：</strong> 切换到该目录下 usr 目录</li><li><strong><code>cd ..（或cd../）</code>：</strong> 切换到上一层目录</li><li><strong><code>cd /</code>：</strong> 切换到系统根目录</li><li><strong><code>cd ~</code>：</strong> 切换到用户主目录</li><li><strong><code>cd -</code>：</strong> 切换到上一个操作所在目录</li></ul><h3 id="目录的操作命令-增删改查"><a href="#目录的操作命令-增删改查" class="headerlink" title="目录的操作命令(增删改查)"></a>目录的操作命令(增删改查)</h3><ul><li><strong><code>mkdir 目录名称</code>：</strong> 增加目录。</li><li>**<code>ls/ll</code>**（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息。</li><li><strong><code>find 目录 参数</code>：</strong> 寻找目录（查）。示例：① 列出当前目录及子目录下所有文件和文件夹: <code>find .</code>；② 在<code>/home</code>目录下查找以.txt 结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code> ,忽略大小写: <code>find /home -iname &quot;*.txt&quot;</code> ；③ 当前目录及子目录下查找所有以.txt 和.pdf 结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code>。</li><li><strong><code>mv 目录名称 新目录名称</code>：</strong> 修改目录的名称（改）。注意：mv 的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv 命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到 mv 命令的另一个用法。</li><li><strong><code>mv 目录名称 目录的新位置</code>：</strong> 移动目录的位置—剪切（改）。注意：mv 语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外 mv 与 cp 的结果不同，mv 好像文件“搬家”，文件个数并未增加。而 cp 对文件进行复制，文件个数增加了。</li><li><strong><code>cp -r 目录名称 目录拷贝的目标位置</code>：</strong> 拷贝目录（改），-r 代表递归拷贝 。注意：cp 命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r 递归。</li><li><strong><code>rm [-rf] 目录</code> :</strong> 删除目录（删）。注意：rm 不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用<code>rm -rf</code> 目录/文件/压缩包。</li></ul><h3 id="文件的操作命令-增删改查"><a href="#文件的操作命令-增删改查" class="headerlink" title="文件的操作命令(增删改查)"></a>文件的操作命令(增删改查)</h3><ul><li><strong><code>touch 文件名称</code>:</strong> 文件的创建（增）。</li><li><strong><code>cat/more/less/tail 文件名称</code></strong> ：文件的查看（查） 。命令 <code>tail -f 文件</code> 可以对某个文件进行动态监控，例如 tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 <code>tail -f catalina-2016-11-11.log</code> 监控 文 件的变化 。</li><li><strong><code>vim 文件</code>：</strong> 修改文件的内容（改）。vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤： <code>vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入：wq/q!</code> （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存）。</li><li><strong><code>rm -rf 文件</code>：</strong> 删除文件（删）。</li></ul><h3 id="压缩文件的操作命令"><a href="#压缩文件的操作命令" class="headerlink" title="压缩文件的操作命令"></a>压缩文件的操作命令</h3><p><strong>1）打包并压缩文件：</strong></p><p>Linux 中的打包文件一般是以.tar 结尾的，压缩的命令一般是以.gz 结尾的。而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令：<code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code> ，其中：</p><ul><li>z：调用 gzip 压缩命令进行压缩</li><li>c：打包文件</li><li>v：显示运行过程</li><li>f：指定文件名</li></ul><p>比如：假如 test 目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包 test 目录并指定压缩后的压缩包名称为 test.tar.gz 可以使用命令：**<code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code> 或 <code>tar -zcvf test.tar.gz /test/</code>**</p><p><strong>2）解压压缩包：</strong></p><p>命令：<code>tar [-xvf] 压缩文件</code></p><p>其中：x：代表解压</p><p>示例：</p><ul><li>将 /test 下的 test.tar.gz 解压到当前目录下可以使用命令：**<code>tar -xvf test.tar.gz</code>**</li><li>将 /test 下的 test.tar.gz 解压到根目录/usr 下:**<code>tar -xvf test.tar.gz -C /usr</code>**（- C 代表指定解压的位置）</li></ul><h3 id="Linux-的权限命令"><a href="#Linux-的权限命令" class="headerlink" title="Linux 的权限命令"></a>Linux 的权限命令</h3><p>操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在 Linux 中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。</p><p>通过 <strong><code>ls -l</code></strong> 命令我们可以 查看某个目录下的文件或目录的权限</p><p>示例：在随意某个目录下<code>ls -l</code></p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAk0AAADkBAMAAAB3WA1kAAAAElBMVEUAAACqqqoAAKoAqgD/AAAAqqr31TvxAAAKr0lEQVR42uycbZqjIBCEQ05A3SAPJ/HH3v9Mi72NJQMuhpDomK7dUQboGN/BD+ppvZlMJtO1hWqtq3f2tXAHxDVSG1D2SYu8sxTYVJFj4WA5PEPP18IR62MLtjo5cDt5ZyloU1Vg4WChmxPDG5yAtGA75rVywsc4wUE3K98DPmtqH3caxYMCwCoc2uQAv3FM5ZwgNdpZoYARK04ObHJzACCFRFj3C8CYg8d55RQFj7ypzUmjeFBgCdca/cK1cKlWhOQkC5H+wuYEQgCwiR+2jkwf9orIXDk5QHdKCkg7zsGwzelW5eR3cILC+R8nnrq5nHmBTQ4cu2tw8AM48W/kkcZT3tTizHXGieENTuyjYEtO2fGdcbqBTdDtl5HX4ITbfk5c6ee1OI0fTwDanLCXk/NVTijDGdXmxM5tTvKjv0lh0MUdPOi3r/soQxnFM0QsMXx1zoCvhGNuBzwjnO4f+6RvVXTmWV2jPKSQxpLidIffQJlMJpPJ9A16xX+i+v0nzlKW+xH4y/lPSf3+k9QwEFK4nP+U9Ir/VOF0Pf+JvkKn/yQR1/efFjhAn//EoSYsIZu5nv+08PS9/hPHE7fk/NX8p4VTt/9U53Q1/0nU7z9tcrqa/6R6wX9CldPF/KekLv+Jn1z64+Y/mUwmk8nUI/iXouE7/CeJgmchRuzxn6Tflv8UHrK8vUnOvxaMp3wVRsUFCwKr6T9pvw3/6X5iTlEdnKQDuKO8u236T27h5HyV03hxw3DgzFyNH/0iWVN93zv8p5ITnN/nP7mMk1tzCo95EYdUXAyWGjbIpkh+QYO8aZj/5BLLzL7Z7T8B9J94fro/ZjxhLowfWsl4Wr53wiNjIG+qx3f5T+ysBWCX/8TxpLg5ngTPuznxV+6jlNi0NZyavkqTk/Zq+wUlp9sxnHQ8qRzypmr4QZxYOIJT2k3uS950Q8kJz/tPzv86TnL+xfpM4LIzQdZU4dThP7Ema8Iu/8lt+0/3EOSi94+TyWQymUymvbpQ/tNXPH+XZM/f7eNkz9+9O/+JTQ7cluU/bT5/l08YLf+p9vxd8ZTi5Z6/G5H/hFvB6XLP3w3If6pxutzzd6ohz98x2PKf6s/fWf6TyWQymUy/N//pn9aXcYeND2Sfsob3ltSj2OgZ8nq68p84V+FtITY/kH3KGlfclN3PySmqmxNWnKRlEzzKWKWL2PAZTg6e/tMn8p8YKIBATmQiCEF2sijGmM8J3kOYfx5x8cb8J6HyqfwnDgnFR4ROoou3ySh41sD95BQpPeJ/LQyWAtLV+/OfKAgej/K9a9JETs5zyRrA/eQUQuJEjeREX+UT+U8U1EAq02S4kgI3zxr4glP8+RCnT+U/0QjJOOUZm6zhikXcDuIEwL8//6nkxAI56apxX1A/P4VYeGf+U1x9LP8phWhTNXUetJWYrJrXZMa9Xub0evc9MmfNOA0Rj0rTL9OfPk23L1PnDn8lJ/jnw07sP71FU99mpvP6T0kn43Q6/+k9mvr8p+mk/lOcroQw35LHwlAjaurzn6aT+k8zFUEUBNm4id7U5z9N5/Sf4j8ZRhFSuIcwcDo89flP00n9p5nMXTkJojAI1NTnP00n9Z8KTqOsqKnPf5pO6j+R0+jzU5//NJ3XfwqPIJzS9e768xY8H5JR+Zb5HZ6m9JWcnr/Nvq+ubt/D6VQyTubTJR2e/6RTW4z1n9rvf+JGGV7mqvBdNOFxaF4P5/mj/Kf+9z+RExUWYsdyoocwyH/a+/6nbOZJTlTB6cj8J3Ia6z+13/9ETjSiRJKustyGB72jumvNcflP3PWB/lP7+TtZ5EYUB07QaR05hftDag7Kf+LEfaT/1H7+jtukEVVwmhU4M5bUqGPyn1iFUf5T+3kpfmJuRLU5HZD/NJST7+fkPI2oJqcD85+kcZT/1M0JVU5SIidZHZT/RLdptP/Ufv+TgCmtqaBo+CIoOYc/wpdlRP1l7wqQ44SBGPgF7A8Y//+RPeylwnXbyRwbVkmkGRIfJBei5AzoJCEIgiAIOfoTVf94F5pq+zyCQn+i6R9fivNUvgtPwf3j4AmfgfT+ce/5MZb+8cZP8VNxIL1/3N1cxtI/fnndVexlfv94lyM3Y+kfP3hi7B8/ZVuW/vGDJ8b+8fMXZekfP3hi7B8/NjL1jx88MfaPn0c3lv7xpj+VH5e/EwRBEIQD6frTsm6h/qfvqj+dUhCX/4lPf1ptC83ffQ396Q3/kwuRUf6nWP2p1t3fOk/3P8GKFOF/itWf3FTg7oI0/xN4sqj8Xaz+1PJ3y2tpg5rZ/+TfFpa/C9Wf2vgsGEv0P4GEsPxdmK4CnjzTmel/Agkx/qd4njA/pfufOsVB/qdY/QnHOylSgiAIgvCA/oTrlqT8HS5p5qCdryHQVRrDq+Xk77Bp1lWAwsCTnx/m5e987X95otGfLDV/N/FUcT7e1xD0j2NPE/N3/sF5wtXc7yW/fxw8ZeXvXG2YeHqhVucpv38cu5ySv8NPnXg6xv7/RNA/Dp5y8ncf4Ymhfxw8BehPoTyVfeYpV38ys5T8HTZhn1x2QhHUItlJEARBEL7A/e8MJxEY3PE/OUodZQIGX8/b/ePQjQbD/T3/k4OUp7f8T4NuBJ7u+Z/A04j8/N2d/nHDxT54uul/ctkJRVCvEUP+7u3+cVCEiSrA/9RNT2VH0cpCkb+70z9uF64swv8EG0b9TJ7w8In73426rUX5n+r+FE+P3f/OhpdekP9pqU/x9Nj97wxfHMET5qeJp/z83Y3+cTNzfdwn4gD/E2xPXgQl7UkQBEEQHtKfjKZ//LVmbh0HcnWV1Wj6x8c/NBlPZjT942sUT/H+J7wWCPrHYX+q3qJdhiLyPP8TBCSG/vHx/uZ1r23YBm1Nrv/J+kLQPz7aDr3ftw1QO57kf8Imgv5xfwT9yWvsl77k+p9OLgj6xy/PWmeesv1PRtM/PsxPA0+Yn5L8TxCQOPrH8X5L6fNT2Y9jnmJ3giAIgvCI/gSsG03+7p9g8PXYRpO/+xNMPK220eTvJhDoTxdZhiV/V2r9i+xEkL/ra9P1p+Xif5plJ4L8nV9hseTvXH+ajAXp+TtfTZO/q/skp6TrT5cnoMnfzbJTvv50eQKW/J3rTz4AMvUngCd/dxzmJDv9aucMUiOGYSgqMN5XNzH0Itno/leprCp8MnJJxmqgNP4aPI40ZPHGScgHa2lpaenfqny+oUaP1SwnuBbzmu7/BGHLStp/qjlObcQJynBK9H+KfczT/pOMz36VE93JibOcsKUu6T+NOaFahksHmXNO0X+ypGUOJQqa7v8EYSdd0n8SEapCGjoSxJETafShj408o0c6J8uMOUX/yahooPS7++8iJ+Z0/ych5SSyVY3D6V85tWKcbNKoFZvYcf9d0xhziv6Tfbn/hFLQbP+nyIk/Mv4TOG1SwckXML9yIv/0pDIxRs6N2s+cBv6TzjmWgqb7GkVOWf8JnE7Xk4MxJHagw5ucmMHJ1xNK93Ga91XOOcX7ExmZ79gRXeIU/SdWkQZKQ/9pov/TnZwUEDjF553xcTL9Hr5z8owhAqf4VI7+E25Lh1LkNN3/KfaRyvd/quLrSWTwR4ITLr5iz7w9Q76eiJ7x3lK31HtLKw95v1ucrkkkxYnoIZyWr7L0d/UFD5a7hMwPx0AAAAAASUVORK5CYII=" alt="img"></p><p>第一列的内容的信息解释如下：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://javaguide.cn/assets/Linux%E6%9D%83%E9%99%90%E8%A7%A3%E8%AF%BB.7c1098a0.png" alt="img"></p><blockquote><p>下面将详细讲解文件的类型、Linux 中权限以及文件有所有者、所在组、其它组具体是什么？</p></blockquote><p><strong>文件的类型：</strong></p><ul><li>d： 代表目录</li><li>-： 代表文件</li><li>l： 代表软链接（可以认为是 window 中的快捷方式）</li></ul><p><strong>Linux 中权限分为以下几种：</strong></p><ul><li>r：代表权限是可读，r 也可以用数字 4 表示</li><li>w：代表权限是可写，w 也可以用数字 2 表示</li><li>x：代表权限是可执行，x 也可以用数字 1 表示</li></ul><p><strong>文件和目录权限的区别：</strong></p><p>对文件和目录而言，读写执行表示不同的意义。</p><p>对于文件：</p><table><thead><tr><th align="left">权限名称</th><th align="right">可执行操作</th></tr></thead><tbody><tr><td align="left">r</td><td align="right">可以使用 cat 查看文件的内容</td></tr><tr><td align="left">w</td><td align="right">可以修改文件的内容</td></tr><tr><td align="left">x</td><td align="right">可以将其运行为二进制文件</td></tr></tbody></table><p>对于目录：</p><table><thead><tr><th align="left">权限名称</th><th align="right">可执行操作</th></tr></thead><tbody><tr><td align="left">r</td><td align="right">可以查看目录下列表</td></tr><tr><td align="left">w</td><td align="right">可以创建和删除目录下文件</td></tr><tr><td align="left">x</td><td align="right">可以使用 cd 进入目录</td></tr></tbody></table><p>需要注意的是： <strong>超级用户可以无视普通用户的权限，即使文件目录权限是 000，依旧可以访问。</strong></p><p><strong>在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。</strong></p><ul><li><strong>所有者(u)</strong> ：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用 <code>ls ‐ahl</code> 命令可以看到文件的所有者 也可以使用 chown 用户名 文件名来修改文件的所有者 。</li><li><strong>文件所在组(g)</strong> ：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组用 <code>ls ‐ahl</code>命令可以看到文件的所有组也可以使用 chgrp 组名 文件名来修改文件所在的组。</li><li><strong>其它组(o)</strong> ：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</li></ul><blockquote><p>我们再来看看如何修改文件/目录的权限。</p></blockquote><p><strong>修改文件/目录的权限的命令：<code>chmod</code></strong></p><p>示例：修改/test 下的 aaa.txt 的权限为文件所有者有全部权限，文件所有者所在的组有读写权限，其他用户只有读的权限。</p><p><strong><code>chmod u=rwx,g=rw,o=r aaa.txt</code></strong> 或者 <strong><code>chmod 764 aaa.txt</code></strong></p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAg0AAAD2BAMAAACn/KlUAAAAD1BMVEUAAACqqqr/AACqAAAAqgDVR6mAAAAHP0lEQVR42uxdAZKbMAzEzQe8P+j0BZnh/3+r0UI3ruJe7QsTCNo7iCIhX7wRBjbOMQUCgUAgEAgEAoFAILAbANlEMm9mSMglAlhInjor4dEFy5hOAjzzpDyhrFKWt9ibD/IIoKv8FkvxD+ChPF6Lh5SRVfMA/vCwelLxmMGAgZ4qi/wB+aQ8TMjQe70yQx60g7AeFgO+QvAR9VCWJg/A3zwsi3iwWviQ/YJLqx6migf1jR4z8ME8mJk9DynXPMj6gPGh5iGp+4/jAxwPqLPOXQ+YEqpzpLQZm4e8IGsbgh5lleWRB6yeQCAQCAQ+B8kZyKsDpzn4vwBwRsqbI13o4B88GFAJCMBVeVjVJwkIZbnq+CAegBz1sBgpeLg6Dw8CwpV5SJXskO3ZFcfJQCAQeI5fQ/g5fRrGehQ8rFmtM4v8L4lDIn8xlgXNKRjgqs4y0ECHnLIrD8iTR4sd2FofFclopCVwZag2ppHQISPsyUPq50EbQEYjDeCqyrJHGtiDB32ayVSIbYb+tV8g1aVOt59QYRAFjgfWCNO3TtddgjIZ2uYhAWZITuEWQH89IEM8JOj9YajFAzdWqa9eP6HClQNISM2DrQg+UZgd9SFfW7AF3fXAeS5bKsBXT4OhzQCe8ZA9D25ChXvVXNPd5EFDo9aadOEHXgIsk24eRGLKaE17EjwPtngeJs8Dw1jNikrHQ9VzujwpIttlHpoHMKGTBz0oyfPwunoAvuBBsTYPeMoDt5YHPTwwSzygxQMXPqPRxQP5s/bcWQ1DnocEaOOHPXT1+gkVBgA5AWBIxQOOt+IBOgYwa9KIoNCWlUGDtbBxnBDn1XF9ETwED6E/BI6Cbv3BA8hj+gM9+oYHjYb+sC+69QePcf3BPP4ynoAz9kTal4e2/sCsHXjo0R+EAf3Bt5D69QdmmfUS/UHo0R+EEf3Bk48+/UFZYIhcgf0e0h+EXv2BGNEf/K6FTv2BWaqHWu4cud4Ueq67hZHrbj8Wold/YFabB2WeiAcLDegP+9TDkP4wDekPnodB/QENHvr1B2FIf5i69QcHhnr1B/0tr0/W+sOJvkEbCAQCgc/Ha/SH48x/OKX+wFCNS+oP8C1eUX8oIX8+eUH9wULuA9Pr6Q8WcrNArqg/YPI8XFF/eMbD9fQHhZR8Rf1hCYX+EAgEAoETYVh/0GFuXH+AUh1u05c4hP7wiu9fYGpjnr7AcfQH8jCkP/TwcHj9AcsPeRjTH/DQ6fl2n273xaBnXkzzr4zcyha34j6a/pBQfLZCHtMfRGzp4b0QMNMgEfRb9+lYw8fTH0qI7H13/gPf+dt8p0GPee/q+kzXAa+7uVcwND7/wWB9nc0QD0aBHHQdkweGxvSHdj20eZgPpz+44+bo/Ac/PnAHKKZ4KB6Gp/lo+sO68bfnP/jjBXeQ5bE8Z4FYucxlKavLIygwFoKHAg6jb8OvI2F6CU7/RZUfHdsGD/vc/4I86Iipp3siO4M8vO/+Fz+bl9w7Qid5r+WhPF6Lh5ff/8J4YGjxZHNrR2PbANjyyp2u+uuQTiOxtFSfhapRC1u7Zgg/3nD/C9UDQ2y5YG1HPFTyBa/eG6F68gwy/P8WkUM54uFN978QD1vLxbUWmOMhb22jFRIPivvrFBEDt1+84f4XPTwAG62wtEZIPGyF//QrB3qtjof33f+iox7KwiiY4kMkV6meh7F62P/+Fxof/osH2PhHLn3o/3jgopfqeHjP/S+240XaeGA7a5XLgEYn+2VWHWK1SdmQFKz//7DWwlbOyKc+r/7N3tmlKgwDYfQi2UC3cFeSh9n/mhxntEMJKKFRJuk5WhkJQfIRxf7leDjtya0r7l9sPuzL72fpxCcHhxwccnixzPGH/0zg38S/iX8T/yb+TfybBv5NB/+mgX8TAACgF/ybf3gnyWEH/+YT/JsG/k0D7yQ5HMC/GeDfBPgCt+mu5P8Ot+nOpBvk4JCDkyeHtP7NEsUPcsjr35QofpBDXv/miRz8bGYYFOLGh2dT2yuJf7NI1QGLF4bou1L1qUV3DrH+gz7ixoe9qe2Vxr8pupVqhSO2Sfd8OK7/oB8XNz406z9EryT+zSKPAUv1IoKR2p3Dcd0DreKC/72p7ZXEvyn6KLVUKxzxl5M5+Hz4nEMS/2aTw4j5oGixxY0PbQ7a5r2S+DePOfjm76zozCHWf/Ch+Adt0dTmkMS/WWzUVbzwufBIxp7C/2r2L8iBHMiBHLIcn8S/mcB/gX8T/yb+Tfyb+Dfxb+LfxL+JfxMAABYH/2aC4w/4N/Fv4t/Ev4l/E/8m/k38m/g3AQBgcfBv4t/Ev4l/E/8m/k38m/g38W/i37wKRIB/M4l/E2Byxvkv5l6lebz/Ys4TB2/9F9fKYbD/Ys4vxxj/xRLz4bT/YpHvxXn/xcI59PsvFvh9GOO/mHs+3Nu7YxoAABAGghrwbxYPhA5N7iT80LWv/xe9HQib1qXQAQAAuFqK6eakDZMsPAAAAABJRU5ErkJggg==" alt="img"></p><p><strong>补充一个比较常用的东西:</strong></p><p>假如我们装了一个 zookeeper，我们每次开机到要求其自动启动该怎么办？</p><ol><li>新建一个脚本 zookeeper</li><li>为新建的脚本 zookeeper 添加可执行权限，命令是:<code>chmod +x zookeeper</code></li><li>把 zookeeper 这个脚本添加到开机启动项里面，命令是：<code>chkconfig --add zookeeper</code></li><li>如果想看看是否添加成功，命令是：<code>chkconfig --list</code></li></ol><h3 id="Linux-用户管理"><a href="#Linux-用户管理" class="headerlink" title="Linux 用户管理"></a>Linux 用户管理</h3><p>Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p><strong>Linux 用户管理相关命令:</strong></p><ul><li><code>useradd 选项 用户名</code>:添加用户账号</li><li><code>userdel 选项 用户名</code>:删除用户帐号</li><li><code>usermod 选项 用户名</code>:修改帐号</li><li><code>passwd 用户名</code>:更改或创建用户的密码</li><li><code>passwd -S 用户名</code> :显示用户账号密码信息</li><li><code>passwd -d 用户名</code>: 清除用户密码</li></ul><p><code>useradd</code> 命令用于 Linux 中创建的新的系统用户。<code>useradd</code>可用来建立用户帐号。帐号建好之后，再用<code>passwd</code>设定帐号的密码．而可用<code>userdel</code>删除帐号。使用<code>useradd</code>指令所建立的帐号，实际上是保存在 <code>/etc/passwd</code>文本文件中。</p><p><code>passwd</code>命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p><h3 id="Linux-系统用户组的管理"><a href="#Linux-系统用户组的管理" class="headerlink" title="Linux 系统用户组的管理"></a>Linux 系统用户组的管理</h3><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对<code>/etc/group</code>文件的更新。</p><p><strong>Linux 系统用户组的管理相关命令:</strong></p><ul><li><code>groupadd 选项 用户组</code> :增加一个新的用户组</li><li><code>groupdel 用户组</code>:要删除一个已有的用户组</li><li><code>groupmod 选项 用户组</code> : 修改用户组的属性</li></ul><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><ul><li><p><strong><code>pwd</code>：</strong> 显示当前所在位置</p></li><li><p><code>sudo + 其他命令</code>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p></li><li><p><strong><code>grep 要搜索的字符串 要搜索的文件 --color</code>：</strong> 搜索命令，–color 代表高亮显示</p></li><li><p><strong><code>ps -ef</code>/<code>ps -aux</code>：</strong> 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：**<code>ps aux|grep redis</code>** （查看包括 redis 字符串的进程），也可使用 <code>pgrep redis -a</code>。</p><p>注意：如果直接用 ps（（Process Status））命令，会显示所有进程的状态，通常结合 grep 命令查看某进程的状态。</p></li><li><p><strong><code>kill -9 进程的pid</code>：</strong> 杀死进程（-9 表示强制终止。）</p><p>先用 ps 查找进程，然后用 kill 杀掉</p></li><li><p><strong>网络通信命令：</strong></p><ul><li>查看当前系统的网卡信息：ifconfig</li><li>查看与某台机器的连接情况：ping</li><li>查看当前系统的端口使用：netstat -an</li></ul></li><li><p><strong>net-tools 和 iproute2 ：</strong><code>net-tools</code>起源于 BSD 的 TCP/IP 工具箱，后来成为老版本 LinuxLinux 中配置网络功能的工具。但自 2001 年起，Linux 社区已经对其停止维护。同时，一些 Linux 发行版比如 Arch Linux 和 CentOS/RHEL 7 则已经完全抛弃了 net-tools，只支持<code>iproute2</code>。linux ip 命令类似于 ifconfig，但功能更强大，旨在替代它。更多详情请阅读<a target="_blank" rel="noopener" href="https://linoxide.com/linux-command/use-ip-command-linux">如何在 Linux 中使用 IP 命令和示例open in new window</a></p></li><li><p><strong><code>shutdown</code>：</strong> <code>shutdown -h now</code>： 指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定 5 分钟后关机，同时送出警告信息给登入用户。</p></li><li><p><strong><code>reboot</code>：</strong> <strong><code>reboot</code>：</strong> 重开机。**<code>reboot -w</code>：** 做个重开机的模拟（只有纪录并不会真的重开机）。</p></li></ul><h2 id="Linux-环境变量"><a href="#Linux-环境变量" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h2><p>在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的主目录（HOME）。</p><h3 id="环境变量分类"><a href="#环境变量分类" class="headerlink" title="环境变量分类"></a>环境变量分类</h3><p>按照作用域来分，环境变量可以简单的分成:</p><ul><li>用户级别环境变量 : <code>~/.bashrc</code>、<code>~/.bash_profile</code>。</li><li>系统级别环境变量 : <code>/etc/bashrc</code>、<code>/etc/environment</code>、<code>/etc/profile</code>、<code>/etc/profile.d</code>。</li></ul><p>上述配置文件执行先后顺序为：<code>/etc/enviroment</code> –&gt; <code>/etc/profile</code> –&gt; <code>/etc/profile.d</code> –&gt; <code>~/.bash_profile</code> –&gt; <code>/etc/bashrc</code> –&gt; <code>~/.bashrc</code></p><p>如果要修改系统级别环境变量文件，需要管理员具备对该文件的写入权限。</p><p>建议用户级别环境变量在 <code>~/.bash_profile</code>中配置，系统级别环境变量在 <code>/etc/profile.d</code> 中配置。</p><p>按照生命周期来分，环境变量可以简单的分成:</p><ul><li>永久的：需要用户修改相关的配置文件，变量永久生效。</li><li>临时的：用户利用 <code>export</code> 命令，在当前终端下声明环境变量，关闭 shell 终端失效。</li></ul><h3 id="读取环境变量"><a href="#读取环境变量" class="headerlink" title="读取环境变量"></a>读取环境变量</h3><p>通过 <code>export</code> 命令可以输出当前系统定义的所有环境变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前的环境变量值</span></span><br><span class="line"><span class="built_in">export</span> -p</span><br></pre></td></tr></table></figure><p>除了 <code>export</code> 命令之外， <code>env</code> 命令也可以列出所有环境变量。</p><p><code>echo</code> 命令可以输出指定环境变量的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出当前的PATH环境变量的值</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 输出当前的HOME环境变量的值</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$HOME</span></span><br></pre></td></tr></table></figure><h3 id="环境变量修改"><a href="#环境变量修改" class="headerlink" title="环境变量修改"></a>环境变量修改</h3><p>通过 <code>export</code>命令可以修改指定的环境变量。不过，这种方式修改环境变量仅仅对当前 shell 终端生效，关闭 shell 终端就会失效。修改完成之后，立即生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CLASSPATH=./JAVA_HOME/lib;<span class="variable">$JAVA_HOME</span>/jre/lib</span><br></pre></td></tr></table></figure><p>通过 <code>vim</code> 命令修改环境变量配置文件。这种方式修改环境变量永久有效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><p>如果修改的是系统级别环境变量则对所有用户生效，如果修改的是用户级别环境变量则仅对当前用户生效。</p><p>修改完成之后，需要 <code>source</code> 命令让其生效或者关闭 shell 终端重新登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h1 id="TypeScript★"><a href="#TypeScript★" class="headerlink" title="TypeScript★"></a>TypeScript★</h1><blockquote><p>考察公司：百度、华为</p></blockquote><h2 id="TS-vs-JS-★"><a href="#TS-vs-JS-★" class="headerlink" title="TS vs JS ★"></a>TS vs JS ★</h2><p>对比于JS，TS是JS的<strong>超集</strong>，简单的说就是在 <code>JavaScript</code> 的基础上加入了<strong>类型系统</strong>，让每个参数都有明确的意义，从而带来了更加<strong>智能</strong>的提示。</p><p>相对于<code>JS</code>而言，<code>TS</code>属于<strong>强类型</strong>语言，所以对于项目而言，会使代码更加规范，从而解决了大型项目代码的复杂性，其次，浏览器是不识别<code>TS</code>的，所以在编译的时候，<code>TS</code>文件会先编译为<code>JS</code>文件。</p><ol><li>TypeScript是JavaScript的<strong>超集</strong>。</li><li>它对JS进行了扩展，向JS中引入了<strong>类型</strong>的概念，并添加了许多新的特性。</li><li>TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。</li><li><strong>TS完全兼容JS</strong>，换言之，任何的JS代码都可以直接当成TS使用。</li><li>相较于JS而言，TS拥有了<strong>静态类型</strong>，更加严格的语法，更强大的功能；TS可以<strong>在代码执行前就完成代码的检查</strong>，减小了运行时异常的出现的几率；TS代码<strong>可以编译为任意版本的JS代码</strong>，可有效解决不同JS运行环境的兼容问题；同样的功能，<strong>TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS</strong>。</li></ol><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><table><thead><tr><th align="center">类型</th><th align="center">例子</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">number</td><td align="center">1, -33, 2.5</td><td align="center">任意数字</td></tr><tr><td align="center">string</td><td align="center">‘hi’, “hi”</td><td align="center">任意字符串</td></tr><tr><td align="center">boolean</td><td align="center">true、false</td><td align="center">布尔值true或false</td></tr><tr><td align="center">字面量</td><td align="center">其本身</td><td align="center">限制变量的值就是该字面量的值</td></tr><tr><td align="center">any</td><td align="center">*</td><td align="center">任意类型</td></tr><tr><td align="center">unknown</td><td align="center">*</td><td align="center">类型安全的any</td></tr><tr><td align="center">void</td><td align="center">空值（undefined）</td><td align="center">没有值（或undefined）</td></tr><tr><td align="center">never</td><td align="center">没有值</td><td align="center">不能是任何值</td></tr><tr><td align="center">object</td><td align="center">{name:’孙悟空’}</td><td align="center">任意的JS对象</td></tr><tr><td align="center">array</td><td align="center">[1,2,3]</td><td align="center">任意JS数组</td></tr><tr><td align="center">tuple</td><td align="center">[4,5]</td><td align="center">元组，TS新增类型，固定长度数组</td></tr><tr><td align="center">enum</td><td align="center">enum{A, B}</td><td align="center">枚举，TS中新增类型</td></tr></tbody></table><ul><li><p><strong>tuple</strong></p><ul><li><p>元组就是固定长度的数组</p></li><li><p>语法：<code>[类型, 类型, 类型]</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">x = [<span class="string">&quot;hello&quot;</span>, <span class="number">10</span>]; </span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>enum</strong></p><p>可以定义一些带名字的常量，这样可以<strong>清晰表达意图</strong>或<strong>创建一组有区别的用例</strong></p><p>注意：</p><ul><li>枚举的类型只能是 <code>string</code> 或 <code>number</code></li><li>定义的名称不能为<strong>关键字</strong></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color &#123;</span><br><span class="line">  Red,</span><br><span class="line">  Green,</span><br><span class="line">  Blue,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Color &#123;</span><br><span class="line">  Red = <span class="number">1</span>,</span><br><span class="line">  Green,</span><br><span class="line">  Blue,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Color &#123;</span><br><span class="line">  Red = <span class="number">1</span>,</span><br><span class="line">  Green = <span class="number">2</span>,</span><br><span class="line">  Blue = <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure></li></ul><p><strong>enum</strong></p><p>可以定义一些带名字的常量，这样可以<strong>清晰表达意图</strong>或<strong>创建一组有区别的用例</strong></p><p>注意：</p><ul><li>枚举的类型只能是 <code>string</code> 或 <code>number</code></li><li>定义的名称不能为<strong>关键字</strong></li></ul><p><strong>类型守卫</strong>：是<strong>可执行运行时检查的</strong>一种表达式，用于确保<strong>该类型在一定的范围内</strong>。</p><p>我个人的感觉是，类型守卫就是你可以设置多种类型，但我默认你是什么类型的意思</p><p>目前，常有的类型守卫共有4种：<strong>in关键字</strong>、<strong>typeof关键字</strong>、<strong>instanceof</strong>和<strong>类型谓词（is)</strong></p><p><strong>联合类型(Union Types)</strong>: 表示取值可以为多种类型中的一种,未赋值时联合类型上只能访问两个类型共有的属性和方法</p><h2 id="type-vs-interface-★"><a href="#type-vs-interface-★" class="headerlink" title="type vs interface  ★"></a>type vs interface ★</h2><p>类型别名（type）</p><p><strong>类型别名</strong>：也就是<code>type</code>，用来给一个类型起个新名字</p><p><strong>接口</strong>：<strong>在面向对象语言中表示行为抽象，也可以用来描述对象的形状</strong>。</p><p>使用<strong>interface</strong>关键字来定义接口</p><p><strong>继承</strong>：与类一样，接口也存在继承属性，也是使用<code>extends</code>字段</p><p>基础数据类型</p><ul><li><code>type</code>和<code>interface</code>都可以定义 <strong>对象</strong> 和 <strong>函数</strong></li><li><code>type</code>可以定义其他数据类型，如字符串、数字、元祖、联合类型等，而<code>interface</code>不行</li></ul><p>扩展</p><p><code>interface</code> 可以扩展 <code>type</code>，<code>type</code> 也可以扩展为 <code>interface</code>，但两者实现扩展的方式不同。</p><ul><li><code>interface</code> 是通过 <code>extends</code> 来实现</li><li><code>type</code> 是通过 <code>&amp;</code> 来实现</li></ul><p><code>interface</code> 可以多次被定义，并且会进行合并，但<code>type</code>不行</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>泛型</strong>：Generics，是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性</p><p>也就是说，泛型是<strong>允许同一个函数接受不同类型参数的一种模版</strong>，与<code>any</code>相比，使用泛型来创建可复用的组件要更好，因为<strong>泛型会保留参数类型</strong>（PS：泛型是整个TS的重点，也是难点，请多多注意～）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calcArray = &lt;T,U&gt;(name:T, age:U): &#123;name:T, age:U&#125; =&gt; &#123;</span><br><span class="line">    const res: &#123;name:T, age:U&#125; = &#123;name, age&#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const res = calcArray&lt;string, number&gt;(&#x27;小杜杜&#x27;, 7)</span><br><span class="line">console.log(res) // &#123;&quot;name&quot;: &quot;小杜杜&quot;, &quot;age&quot;: 7&#125;</span><br></pre></td></tr></table></figure><p>定义接口的时候，我们也可以使用泛型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A&lt;T&gt; &#123;</span><br><span class="line">    <span class="attr">data</span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Info: A&lt;<span class="built_in">string</span>&gt; = &#123;<span class="attr">data</span>: <span class="string">&#x27;1&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Info.data) <span class="comment">// &quot;1&quot;</span></span><br></pre></td></tr></table></figure><p>同样泛型也可以定义类</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clacArray</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> arr: T[] = [];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">value: T</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">    getValue(): T &#123;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="built_in">this</span>.arr[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.arr)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">new</span> clacArray()</span><br><span class="line"></span><br><span class="line">res.add(<span class="number">1</span>)</span><br><span class="line">res.add(<span class="number">2</span>)</span><br><span class="line">res.add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">res.getValue() <span class="comment">//[1, 2, 3] </span></span><br><span class="line"><span class="built_in">console</span>.log(res.getValue) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>泛型类型别名</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Info&lt;T&gt; = &#123;</span><br><span class="line">    name?: T</span><br><span class="line">    age?: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res:Info&lt;<span class="built_in">string</span>&gt; = &#123; <span class="attr">name</span>: <span class="string">&#x27;小杜杜&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> res1:Info&lt;<span class="built_in">number</span>&gt; = &#123; <span class="attr">age</span>: <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure><p>泛型默认参数</p><p>所谓默认参数，是指定类型，如默认值一样，从实际值参数中也无法推断出类型时，这个默认类型就会起作用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calcArray = <span class="xml"><span class="tag">&lt;<span class="name">T</span> = <span class="string">string,</span>&gt;</span>(data:T):T[] =&gt; &#123;</span></span><br><span class="line"><span class="xml">    let list:T[] = []</span></span><br><span class="line"><span class="xml">    for(let i = 0; i &lt; 3; i++)&#123;</span></span><br><span class="line"><span class="xml">        list.push(data)</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    return list</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>泛型常用字母</p><p>用常用的字母来表示一些变量的代表：</p><ul><li><strong>T</strong>：代表<strong>Type</strong>，定义泛型时通常用作第一个类型变量名称</li><li><strong>K</strong>：代表<strong>Key</strong>，表示对象中的<strong>键类型</strong>；</li><li><strong>V</strong>：代表<strong>Value</strong>，表示对象中的<strong>值类型</strong>；</li><li><strong>E</strong>：代表<strong>Element</strong>，表示的<strong>元素类型</strong>；</li></ul><h2 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h2><ul><li><p><strong>重写</strong>：子类重写继承自父类中的方法</p></li><li><p><strong>重载</strong>：指为同一个函数提供多个类型定义</p></li><li><p>示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">setName</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`我的名字叫<span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">setName</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`你的名字叫<span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yourName = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(yourName.setName(<span class="string">&#x27;小杜杜&#x27;</span>)) <span class="comment">// &quot;你的名字叫小杜杜&quot; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span></span>&#123;</span><br><span class="line">    setNameAge(name: <span class="built_in">string</span>):<span class="built_in">void</span>;</span><br><span class="line">    setNameAge(name: <span class="built_in">number</span>):<span class="built_in">void</span>;</span><br><span class="line">    <span class="function"><span class="title">setNameAge</span>(<span class="params">name:<span class="built_in">string</span> | <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> name === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`我的名字是<span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`我的年龄是<span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">new</span> Person1()</span><br><span class="line">res.setNameAge(<span class="string">&#x27;小杜杜&#x27;</span>) <span class="comment">// &quot;我的名字是小杜杜&quot; </span></span><br><span class="line">res.setNameAge(<span class="number">7</span>) <span class="comment">// &quot;我的年龄是7&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>使用 <strong>React.FunctionComponent</strong>，简写形式：<strong>React.FC:</strong></p><p><code>useState&lt;T&gt;</code> <code>useRef&lt;T&gt;</code></p><p>React.ReactNode // 一般情况下推荐使用，支持所有类型</p><p><strong>Promise<t></t></strong>是一个泛型类型，<strong>T</strong> 泛型变量用于确定 <strong>then</strong> 方法时接收的第一个回调函数的参数类型。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果在js中引入本地静态资源图片时使用<code>import img from &#39;./img/bd_logo1.png&#39;</code>这种写法是没有问题的，但是在typscript中是无法识别非代码资源的，所以会报错<code>TS2307: cannot find module &#39;.png&#39;</code>。</p><p>因此，我们需要主动的去声明这个module。</p><p>新建一个ts声明文件如：<code>images.d.ts</code>（如下）就可以了。这样ts就可以识别svg、png、jpg等等图片类型文件。</p><p>images.d.ts</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> module <span class="string">&#x27;*.svg&#x27;</span></span><br><span class="line"><span class="built_in">declare</span> module <span class="string">&#x27;*.png&#x27;</span></span><br><span class="line"><span class="built_in">declare</span> module <span class="string">&#x27;*.jpg&#x27;</span></span><br><span class="line"><span class="built_in">declare</span> module <span class="string">&#x27;*.jpeg&#x27;</span></span><br><span class="line"><span class="built_in">declare</span> module <span class="string">&#x27;*.gif&#x27;</span></span><br><span class="line"><span class="built_in">declare</span> module <span class="string">&#x27;*.bmp&#x27;</span></span><br><span class="line"><span class="built_in">declare</span> module <span class="string">&#x27;*.tiff&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="数据库★"><a href="#数据库★" class="headerlink" title="数据库★"></a>数据库★</h1><blockquote><p>考察公司：华为</p></blockquote><h1 id="Webpack★"><a href="#Webpack★" class="headerlink" title="Webpack★"></a>Webpack★</h1><blockquote><p>考察公司：字节、美团、百度、京东、腾讯</p></blockquote><h2 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><code>Webpack</code> 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源。</p><p>最早的时候，我们会通过文件划分的形式实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的<code>JS</code> 文件中。</p><p>约定每个文件是一个独立的模块，然后再将这些<code>js</code>文件引入到页面，一个<code>script</code>标签对应一个模块，然后调用模块化的成员。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;module-a.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;module-b.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>但这种模块弊端十分的明显，模块都是在<strong>全局</strong>中工作，大量模块成员污染了环境，模块与模块之间并<strong>没有依赖</strong>关系、维护困难、没有私有空间等问题。</p><p>项目一旦变大，上述问题会尤其明显</p><p>随后，就出现了命名空间方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载到这个对象中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.moduleA = &#123;</span><br><span class="line">  <span class="attr">method1</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;moduleA#method1&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式也并没有解决第一种方式的依赖等问题。</p><p>再后来，我们使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module-a.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;module-a&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">method1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name + <span class="string">&#x27;#method1&#x27;</span>)</span><br><span class="line">        $(<span class="string">&#x27;body&#x27;</span>).animate(&#123; <span class="attr">margin</span>: <span class="string">&#x27;200px&#x27;</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.moduleA = &#123;</span><br><span class="line">        <span class="attr">method1</span>: method1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(jQuery)</span><br></pre></td></tr></table></figure><p>上述的方式都是早期解决模块的方式，但是仍然存在一些没有解决的问题。例如，我们是用过<code>script</code>标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久维护起来也十分的麻烦。</p><p>理想的解决方式是，在页面中引入一个<code>JS</code>入口文件，其余用到的模块可以通过代码控制，按需加载进来。</p><p>除了模块加载的问题以外，还需要规定模块化的规范，如今流行的则是<code>CommonJS</code>、<code>ES Modules</code>。</p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>从后端渲染的<code>JSP</code>、<code>PHP</code>，到前端原生<code>JavaScript</code>，再到<code>jQuery</code>开发，再到目前的三大框架<code>Vue</code>、<code>React</code>、<code>Angular</code>。</p><p>开发方式，也从<code>javascript</code>到后面的<code>es5</code>、<code>es6、7、8、9、10</code>，再到<code>typescript</code>，包括编写<code>CSS</code>的预处理器<code>less</code>、<code>scss</code>等。</p><p>现代前端开发已经变得十分的复杂，所以我们开发过程中会遇到如下的问题：</p><ul><li>需要通过<strong>模块化</strong>的方式来开发。</li><li>使用一些高级的特性来加快我们的开发效率或者安全性，比如通过<code>ES6+</code>、<code>TypeScript</code>开发脚本逻辑，通过<code>sass</code>、<code>less</code>等方式来编写css样式代码。</li><li><strong>监听文件的变化</strong>来并且反映到浏览器上，提高开发的效率。</li><li>JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题。</li><li>开发完成后我们还需要将代码进行<strong>压缩</strong>、合并以及其他相关的优化。</li></ul><p>而<code>webpack</code>恰巧可以解决以上问题。</p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p><code>webpack</code> 是一个用于现代<code>JavaScript</code>应用程序的<strong>静态模块打包工具</strong>。</p><ul><li>静态模块</li></ul><p>这里的静态模块指的是开发阶段，可以被 <code>webpack</code> 直接引用的资源（可以直接被获取打包进<code>bundle.js</code>的资源）</p><p>当 <code>webpack</code>处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限<code>js</code>文件），并生成一个或多个<code>bundle</code>。</p><p><strong>webpack的能力：</strong></p><p><strong>编译代码能力</strong>，提高效率，解决<strong>浏览器兼容</strong>问题 。</p><p><strong>模块整合能力</strong>，提高性能，可维护性，解决<strong>浏览器频繁请求文件</strong>的问题 。</p><p><strong>万物皆可模块能力</strong>，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制。</p><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><p>OneOf 只能匹配上一个 loader, 剩下的就不匹配了</p><p>Cache：每次打包时 js 文件都要经过 Eslint 检查 和 Babel 编译，速度比较慢。</p><p>我们可以<strong>缓存之前的 Eslint 检查 和 Babel 编译结果</strong>，这样第二次打包时速度就会更快了。</p><p>thread：当项目越来越庞大时，打包速度越来越慢，甚至于需要一个下午才能打包出来代码。这个速度是比较慢的。</p><p>我们想要继续提升打包速度，其实就是要提升 js 的打包速度，因为其他文件都比较少。</p><p>而对 js 文件处理主要就是 eslint 、babel、Terser 三个工具，所以我们要提升它们的运行速度。</p><p>我们可以开启<strong>多进程</strong>同时处理 js 文件，这样速度就比之前的单进程打包更快了。</p><p>多进程打包：开启电脑的多个进程同时干一件事，速度更快。</p><p><strong>需要注意：请仅在特别耗时的操作中使用，因为每个进程启动就有大约为 600ms 左右开销。</strong></p><p><code>Tree Shaking</code> 是一个术语，通常<strong>用于描述移除 JavaScript 中的没有使用上的代码</strong>。</p><p><strong>注意：它依赖 <code>ES Module</code>。</strong>Webpack 已经默认开启了这个功能</p><p>Image Minimizer：开发如果项目中引用了较多图片，那么图片体积会比较大，将来请求速度比较慢。</p><p>我们可以对图片进行压缩，减少图片体积。</p><p><strong>注意：如果项目中图片都是在线链接，那么就不需要了。本地项目静态图片才需要进行压缩。</strong></p><p>Preload / Prefetch</p><p>我们前面已经做了代码分割，同时会使用 <strong>import 动态导入</strong>语法来进行<strong>代码按需加载</strong>（我们也叫<strong>懒加载</strong>，比如路由懒加载就是这样实现的）。</p><p>但是加载速度还不够好，比如：是用户点击按钮时才加载这个资源的，如果资源体积很大，那么用户会感觉到明显卡顿效果。</p><p>我们想在浏览器空闲时间，加载后续需要使用的资源。我们就需要用上 <code>Preload</code> 或 <code>Prefetch</code> 技术。</p><ul><li><p><code>Preload</code>：告诉浏览器<strong>立即</strong>加载资源。</p></li><li><p><code>Prefetch</code>：告诉浏览器<strong>在空闲时</strong>才开始加载资源。</p></li></ul><p>它们共同点：</p><ul><li>都只会<strong>加载</strong>资源，并<strong>不执行</strong>。</li><li>都有<strong>缓存</strong>。</li></ul><p>它们区别：</p><ul><li><code>Preload</code>加载优先级高，<code>Prefetch</code>加载优先级低。</li><li><code>Preload</code>只能加载<strong>当前</strong>页面需要使用的资源，<code>Prefetch</code>可以加载当前页面资源，也可以加载<strong>下一个</strong>页面需要使用的资源。</li></ul><p>总结：</p><ul><li>当前页面优先级高的资源用 <code>Preload</code> 加载。</li><li>下一个页面需要使用的资源用 <code>Prefetch</code> 加载。</li></ul><h2 id="webpack-核心概念"><a href="#webpack-核心概念" class="headerlink" title="webpack 核心概念"></a>webpack 核心概念</h2><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始。</p><p>进入入口起点后,webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p><p>每个依赖项随即被处理,最后输出到称之为 bundles 的文件中。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>output 属性告诉 webpack 在哪里输出它所创建的 bundles,以及如何命名这些文件,默认值为 ./dist。</p><p>基本上,整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。</p><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>模块,在 Webpack 里一切皆模块,一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</p><h3 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h3><p>代码块,一个 Chunk 由多个模块组合而成,用于代码合并与分割。</p><h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><p>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。</p><p>loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。</p><p>本质上,webpack loader 将所有类型的文件,转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p><h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h3><p>loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。</p><p>插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。</p><h3 id="Loader和Plugin的区别？"><a href="#Loader和Plugin的区别？" class="headerlink" title="Loader和Plugin的区别？"></a>Loader和Plugin的区别？</h3><p><code>Loader</code> 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。</p><p><code>Plugin</code> 就是插件，基于事件流框架 <code>Tapable</code>，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p><p><code>Loader</code> 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。</p><p><code>Plugin</code> 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。</p><h3 id="loader-执行顺序"><a href="#loader-执行顺序" class="headerlink" title="loader 执行顺序"></a>loader 执行顺序</h3><ol><li>分类</li></ol><ul><li>pre： 前置 loader</li><li>normal： 普通 loader</li><li>inline： 内联 loader</li><li>post： 后置 loader</li></ul><ol start="2"><li>执行顺序</li></ol><ul><li>4 类 loader 的执行优级为：<code>pre &gt; normal &gt; inline &gt; post</code> 。</li><li>相同优先级的 loader 执行顺序为：<code>从右到左，从下到上</code>。</li><li>可以使用 <code>enforce</code> 强制执行 <code>loader</code> 的作用顺序，<code>pre</code> 代表在所有正常 loader 之前执行，<code>post</code> 是所有 loader 之后执行。(inline 官方不推荐使用)</li></ul><h2 id="webpack-构建流程分析"><a href="#webpack-构建流程分析" class="headerlink" title="webpack 构建流程分析"></a>webpack 构建流程分析</h2><p><a target="_blank" rel="noopener" href="https://cloudimge.com/image/HCBr3"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://c2.im5i.com/2022/09/15/HCBr3.png" alt="HCBr3.png"></a></p><p><code>webpack</code> 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：首先会从配置文件和 <code>Shell</code> 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数；初始化完成后会调用<code>Compiler</code>的<code>run</code>来真正启动<code>webpack</code>编译构建过程，<code>webpack</code>的构建流程包括<code>compile</code>、<code>make</code>、<code>build</code>、<code>seal</code>、<code>emit</code>阶段，执行完这些阶段就完成了构建过程。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="entry-options-启动"><a href="#entry-options-启动" class="headerlink" title="entry-options 启动"></a>entry-options 启动</h4><p>从配置文件和 <code>Shell</code> 语句中读取与合并参数，得出最终的参数。</p><h4 id="run-实例化"><a href="#run-实例化" class="headerlink" title="run 实例化"></a>run 实例化</h4><p><code>compiler</code>：用上一步得到的参数初始化 <code>Compiler</code> 对象，加载所有配置的插件，执行对象的 <code>run</code> 方法开始执行编译</p><h3 id="编译构建"><a href="#编译构建" class="headerlink" title="编译构建"></a>编译构建</h3><h4 id="entry-确定入口"><a href="#entry-确定入口" class="headerlink" title="entry 确定入口"></a>entry 确定入口</h4><p>根据配置中的 <code>entry</code> 找出所有的入口文件</p><h4 id="make-编译模块"><a href="#make-编译模块" class="headerlink" title="make 编译模块"></a>make 编译模块</h4><p>从入口文件出发，调用所有配置的 <code>Loader</code> 对模块进行编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</p><h4 id="build-module-完成模块编译"><a href="#build-module-完成模块编译" class="headerlink" title="build module 完成模块编译"></a>build module 完成模块编译</h4><p>经过上面一步使用 <code>Loader</code> 编译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</p><h4 id="seal-输出资源"><a href="#seal-输出资源" class="headerlink" title="seal 输出资源"></a>seal 输出资源</h4><p>根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</p><h4 id="emit-输出完成"><a href="#emit-输出完成" class="headerlink" title="emit 输出完成"></a>emit 输出完成</h4><p>在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</p><h2 id="高级-1"><a href="#高级-1" class="headerlink" title="高级"></a>高级</h2><h3 id="source-map是什么？生产环境怎么用？"><a href="#source-map是什么？生产环境怎么用？" class="headerlink" title="source map是什么？生产环境怎么用？"></a>source map是什么？生产环境怎么用？</h3><p><strong>SourceMap（源代码映射）</strong>是一个用来<strong>生成源代码与构建后代码一一映射的文件</strong>的方案。</p><p>它会生成一个 xxx.map 文件，里面包含源代码和构建后代码每一行、每一列的映射关系。当构建后代码出错了，会通过 xxx.map 文件，从构建后代码出错位置找到映射后源代码出错位置，从而<strong>让浏览器提示源代码文件出错位置，帮助我们更快的找到错误根源</strong>。</p><p>map文件只要不打开开发者工具，浏览器是不会加载的。</p><p>线上环境一般有三种处理方案：</p><ul><li><code>hidden-source-map</code>：借助第三方错误监控平台 Sentry 使用</li><li><code>nosources-source-map</code>：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高</li><li><code>sourcemap</code>：通过 nginx 设置将 .map 文件只对白名单开放(公司内网)</li></ul><p>注意：避免在生产中使用 <code>inline-</code> 和 <code>eval-</code>，因为它们会增加 bundle 体积大小，并降低整体性能。</p><h3 id="Webpack-的热更新原理吧"><a href="#Webpack-的热更新原理吧" class="headerlink" title="Webpack 的热更新原理吧"></a>Webpack 的热更新原理吧</h3><p><code>Webpack</code> 的热更新又称热替换（<code>Hot Module Replacement</code>），缩写为 <code>HMR</code>。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p><p>HMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 <code>Websocket</code>，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。</p><p>客户端对比出差异后会向 WDS 发起 <code>Ajax</code> 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 <code>jsonp</code> 请求获取该chunk的增量更新。</p><p>后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 <code>HotModulePlugin</code> 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像<code>react-hot-loader</code> 和 <code>vue-loader</code> 都是借助这些 API 实现 HMR。</p><h3 id="如何优化-Webpack-的构建速度？"><a href="#如何优化-Webpack-的构建速度？" class="headerlink" title="如何优化 Webpack 的构建速度？"></a>如何优化 Webpack 的构建速度？</h3><ul><li>使用<strong>高版本</strong>的 Webpack 和 Node.js</li><li><strong>多进程/多实例</strong>构建：HappyPack(不维护了)、thread-loader</li><li><strong>压缩代码</strong><ul><li>多进程并行压缩<ul><li>webpack-paralle-uglify-plugin</li><li>uglifyjs-webpack-plugin 开启 parallel 参数 (不支持ES6)</li><li>terser-webpack-plugin 开启 parallel 参数</li></ul></li><li>通过 mini-css-extract-plugin 提取 Chunk 中的 CSS 代码到单独文件，通过 css-loader 的 minimize 选项开启 cssnano 压缩 CSS。</li></ul></li><li><strong>图片压缩</strong><ul><li>使用基于 Node 库的 imagemin (很多定制选项、可以处理多种图片格式)</li><li>配置 image-webpack-loader</li></ul></li><li><strong>缩小打包作用域</strong>：<ul><li><code>exclude/include</code> (确定 loader 规则范围)</li><li><code>resolve.modules</code> 指明第三方模块的绝对路径 (减少不必要的查找)</li><li>resolve.mainFields 只采用 main 字段作为入口文件描述字段 (减少搜索步骤，需要考虑到所有运行时依赖的第三方模块的入口文件描述字段)</li><li>resolve.extensions 尽可能减少后缀尝试的可能性</li><li><code>noParse</code> 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)</li><li><code>IgnorePlugin</code> (完全排除模块)</li><li>合理使用alias</li></ul></li><li>提取页面公共资源：<ul><li>基础包分离：<ul><li>使用 html-webpack-externals-plugin，将基础包通过 CDN 引入，不打入 bundle 中</li><li>使用 SplitChunksPlugin 进行(公共脚本、基础包、页面公共文件)分离(Webpack4内置) ，替代了 CommonsChunkPlugin 插件</li></ul></li></ul></li><li>DLL：<ul><li>使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。</li><li>HashedModuleIdsPlugin 可以解决模块数字id问题</li></ul></li><li><strong>充分利用缓存提升二次构建速度</strong>：<ul><li>babel-loader 开启缓存</li><li>terser-webpack-plugin 开启缓存</li><li>使用 cache-loader 或者 hard-source-webpack-plugin</li></ul></li><li><strong>Tree shaking</strong><ul><li>打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle中去掉(只能对ES6 Modlue生效) 开发中尽可能使用ES6 Module的模块，提高tree shaking效率</li><li>禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking</li><li>使用 PurifyCSS(不在维护) 或者 uncss 去除无用 CSS 代码<ul><li>purgecss-webpack-plugin 和 mini-css-extract-plugin配合使用(建议)</li></ul></li></ul></li><li>Scope hoisting<ul><li>构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突</li><li>必须是ES6的语法，因为有很多第三方库仍采用 CommonJS 语法，为了充分发挥 Scope hoisting 的作用，需要配置 mainFields 对第三方模块优先采用 jsnext:main 中指向的ES6模块化语法</li></ul></li><li>动态Polyfill<ul><li>建议采用 polyfill-service 只给用户返回需要的polyfill，社区维护。 (部分国内奇葩浏览器UA可能无法识别，但可以降级返回所需全部polyfill)</li></ul></li></ul><h3 id="代码分割的本质是什么？有什么意义呢？"><a href="#代码分割的本质是什么？有什么意义呢？" class="headerlink" title="代码分割的本质是什么？有什么意义呢？"></a>代码分割的本质是什么？有什么意义呢？</h3><p>代码分割的本质其实就是在<strong>源代码直接上线</strong>和<strong>打包成唯一脚本main.bundle.js</strong>这两种极端方案之间的一种更适合实际场景的中间状态。</p><p><strong>「用可接受的服务器性能压力增加来换取更好的用户体验。」</strong></p><p>源代码直接上线：虽然过程可控，但是http请求多，性能开销大。</p><p>打包成唯一脚本：一把梭完自己爽，服务器压力小，但是页面空白期长，用户体验不好。</p><h3 id="Babel原理"><a href="#Babel原理" class="headerlink" title="Babel原理"></a>Babel原理</h3><p>大多数JavaScript Parser遵循 <code>estree</code> 规范，Babel 最初基于 <code>acorn</code> 项目(轻量级现代 JavaScript 解析器) Babel大概分为三大部分：</p><ul><li>解析：将代码转换成 AST<ul><li>词法分析：将代码(字符串)分割为token流，即语法单元成的数组</li><li>语法分析：分析token流(上面生成的数组)并生成 AST</li></ul></li><li>转换：访问 AST 的节点进行变换操作生产新的 AST<ul><li>Taro就是利用 babel 完成的小程序语法转换</li></ul></li><li>生成：以新的 AST 为基础生成代码</li></ul><h2 id="模块化工具"><a href="#模块化工具" class="headerlink" title="模块化工具"></a>模块化工具</h2><p>模块化是一种处理复杂系统分解为更好的可管理模块的方式。</p><p>可以用来分割，组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体(<code>bundle</code>)。</p><p>在前端领域中，并非只有<code>webpack</code>这一款优秀的模块打包工具，还有其他类似的工具，例如<code>Rollup</code>、<code>Parcel</code>、<code>snowpack</code>，以及最近风头无两的<code>Vite</code>。</p><p>通过这些模块打包工具，能够提高我们的开发效率，减少开发成本。</p><h3 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h3><p><code>Rollup</code> 是一款 <code>ES Modules</code> 打包器，从作用上来看，<code>Rollup</code> 与 <code>Webpack</code> 非常类似。不过相比于 <code>Webpack</code>，<code>Rollup</code>要小巧的多。</p><p>现在很多我们熟知的库都都使用它进行打包，比如：<code>Vue</code>、<code>React</code>和<code>three.js</code>等</p><p><code>Rollup</code>的优点：</p><ul><li>代码效率更简洁、效率更高</li><li>默认支持<code>Tree-shaking</code> 移除 JavaScript 上下文中的未引用代码(dead-code)</li></ul><p>但缺点也十分明显，加载其他类型的资源文件或者支持导入 <code>CommonJS</code> 模块，又或是编译 <code>ES</code> 新特性，这些额外的需求 <code>Rollup</code>需要使用插件去完成。</p><p>综合来看，<code>rollup</code>并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用<code>CommonJs</code>方式导出成员，并且<code>rollup</code>不支持<code>HMR</code>，使开发效率降低。</p><p>但是在用于打包<code>JavaScript</code> 库时，<code>rollup</code>比 <code>webpack</code> 更有优势，因为其打包出来的代码更小、更快，其存在的缺点可以忽略。</p><h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><p>Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序</p><p><code>Parcel</code> 跟 <code>Webpack</code> 一样都支持以任意类型文件作为打包入口，但建议使用<code>HTML</code>文件作为入口，该<code>HTML</code>文件像平时一样正常编写代码、引用资源。</p><p>跟<code>webpack</code>类似，也支持模块热替换，但用法更简单。</p><p>同时，<code>Parcel</code>有个十分好用的功能：支持自动安装依赖，像<code>webpack</code>开发阶段突然使用安装某个第三方依赖，必然会终止<code>dev server</code>然后安装再启动。而<code>Parcel</code>则免了这繁琐的工作流程</p><p>同时，<code>Parcel</code>能够零配置加载其他类型的资源文件，无须像<code>webpack</code>那样配置对应的<code>loader</code>。</p><p>可以感受到，<code>Parcel</code>给开发者一种很大的自由度，只管去实现业务代码，其他事情用<code>Parcel</code>解决。</p><h3 id="Snowpack"><a href="#Snowpack" class="headerlink" title="Snowpack"></a>Snowpack</h3><p>Snowpack，是一种闪电般快速的前端构建工具，专为现代<code>Web</code>设计，较复杂的打包工具（如<code>Webpack</code>或<code>Parcel</code>）的替代方案，利用<code>JavaScript</code>的本机模块系统，避免不必要的工作并保持流畅的开发体验。</p><p>开发阶段，每次保存单个文件时，<code>Webpack</code>和<code>Parcel</code>都需要重新构建和重新打包应用程序的整个<code>bundle</code>。而<code>Snowpack</code>为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，<code>Snowpack</code>会重新构建该单个文件。</p><p>在重新构建每次变更时没有任何的时间浪费，只需要在浏览器中进行HMR更新。</p><h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><p>vite ，是一种新型前端构建工具，能够显著提升前端开发体验</p><p>它主要由两部分组成：</p><ul><li>一个开发服务器，它基于原生 ES 模块提供了丰富的内建功能，如速度快到惊人的模块热更新HMR</li><li>一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源</li></ul><p>其作用类似<code>webpack</code>+ <code>webpack-dev-server</code>，其特点如下：</p><ul><li>快速的冷启动</li><li>即时的模块热更新</li><li>真正的按需编译</li></ul><p><code>vite</code>会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快</p><p>利用现代浏览器支持<code>ES Module</code>的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间</p><p>在热模块<code>HMR</code>方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像<code>webpack</code>那样需要把该模块的相关依赖模块全部编译一次，效率更高。</p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>相比上述的模块化工具，<code>webpack</code>大而全，很多常用的功能做到开箱即用。有两大最核心的特点：<strong>一切皆模块</strong>和<strong>按需加载</strong></p><p>与其他构建工具相比，有如下优势：</p><ul><li>智能解析：对 CommonJS 、 AMD 、ES6 的语法做了兼容</li><li>万物模块：对 js、css、图片等资源文件都支持打包</li><li>开箱即用：HRM、Tree-shaking等功能</li><li>代码分割：可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间</li><li>插件系统，具有强大的 Plugin 接口，具有更好的灵活性和扩展性</li><li>易于调试：支持 SourceUrls 和 SourceMaps</li><li>快速运行：webpack 使用异步 IO 并具有多级缓存，这使得 webpack 很快且在增量编译上更加快</li><li>生态环境好：社区更丰富，出现的问题更容易解决</li></ul><h1 id="调试代码★"><a href="#调试代码★" class="headerlink" title="调试代码★"></a>调试代码★</h1><blockquote><p>考察公司：腾讯、华为</p></blockquote><p>如果你还是个前端小白，你最常用的调试方法应该是直接在代码中写下一个 <code>log</code>，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;调试信息，输出：&#x27;</span>, test)</span><br></pre></td></tr></table></figure><p>方法虽然简单粗暴，但是它是实用且简单的。然而，如果 <code>BUG</code> 十分复杂，涉及到跨组件甚至是源码，采用打 <code>log</code> 的方式就变得十分麻烦了； 而比较有经验的同学在遇到复杂问题的时候可能会采取以下方法来定位、调试：</p><ul><li><p>打断点</p><p>控制台/代码中加个 <code>debugger</code></p><ul><li>接口数据是否存在异常</li><li>代码是否已提交到现网环境</li></ul></li><li><p><code>charles</code> 抓包</p></li><li><p>右键可屏蔽请求网址，缩小范围</p></li></ul><h2 id="调试一般步骤"><a href="#调试一般步骤" class="headerlink" title="调试一般步骤"></a>调试一般步骤</h2><p>当出现异常时，按照这个基本逻辑排查，一般可以快速定位问题。</p><h3 id="检查控制台是否报错"><a href="#检查控制台是否报错" class="headerlink" title="检查控制台是否报错"></a>检查控制台是否报错</h3><p>可以快速确定页面不符合预期的原因</p><ul><li>是何种错误</li><li>当前页面是否需要请求获取数据</li></ul><h4 id="是何种错误"><a href="#是何种错误" class="headerlink" title="是何种错误"></a>是何种错误</h4><ul><li>安全错误：与后端协商解决</li><li>SyntaxError/ReferenceError/TypeError ：编译阶段一般不会放过太低级的书写错误，可以认为这类错误都是写错了 ，一般很容易发现，找到错误堆栈进行解决。</li><li>数据不符合预期引起的错误（TypeError 等）：访问不存在的属性得到了<code>undefined/null/NaN</code>等值之后，会引发后续的异常。要先从检查数据入手。</li></ul><h4 id="当前页面是否需要请求获取数据"><a href="#当前页面是否需要请求获取数据" class="headerlink" title="当前页面是否需要请求获取数据"></a>当前页面是否需要请求获取数据</h4><p>网络请求是不稳定因素之一，可能会带来难以预料的复杂情况，出现问题的时候检查<strong>网络请求和数据</strong>的优先级很高。</p><h4 id="网络请求是否成功发送"><a href="#网络请求是否成功发送" class="headerlink" title="网络请求是否成功发送"></a>网络请求是否成功发送</h4><p>检查开发者工具 Network/网络面板，查看需要获取数据的接口是否成功获取到数据。</p><p>取不到数据的原因有两类，一类是责任在前端，一类是后端。主要通过<strong>请求提交的内容是否合法</strong>，<strong>接口返回内容是否符合预期</strong>两个方面判断。</p><p>查看的关键点：</p><ul><li>方法是否正确</li><li>URL 是否正确</li><li>跨域</li><li>请求的 Content-Type 是符合要求</li><li>请求体格式是否符合要求（JSON/Form）</li><li>是否携带了身份信息</li></ul><p>合法请求没有得到预期返回，就找后端解决，请求与预期不符就是代码写错了，到错误地方查看代码。</p><ul><li>500 等不该出现的异常：500 大概可能是后端问题</li><li>404 URL 写错</li><li>权限问题:检查请求报文携带的身份信息</li></ul><h3 id="定位到代码应当执行的位置（大概即可）"><a href="#定位到代码应当执行的位置（大概即可）" class="headerlink" title="定位到代码应当执行的位置（大概即可）"></a>定位到代码应当执行的位置（大概即可）</h3><p>如果是控制台有错误信息的，利用 sourcemap 可以快速定位到问题出在哪一行。如果没有报错信息，就需要凭借当前页面的状态自己判断出问题的区域，按照代码执行的顺序排查。这一步可以利用的手段比较多，情况也更复杂，需要具体分析。</p><p>查看代码运行状态：</p><ul><li>按照预期执行顺序检查代码</li><li>检查渲染需要的数据是否与预期相同</li></ul><h3 id="按照预期执行顺序检查代码"><a href="#按照预期执行顺序检查代码" class="headerlink" title="按照预期执行顺序检查代码"></a>按照预期执行顺序检查代码</h3><p>通过<strong>断点</strong>、<strong>日志</strong>等手段判断程序有没有按照自己想要的顺序执行，简单来说就是排查。</p><h3 id="检查渲染需要的数据是否与预期相同"><a href="#检查渲染需要的数据是否与预期相同" class="headerlink" title="检查渲染需要的数据是否与预期相同"></a>检查渲染需要的数据是否与预期相同</h3><p>检查运行过程中每一步的数据变化，是否与预期的相同。</p><h3 id="异常代码一般分析方法"><a href="#异常代码一般分析方法" class="headerlink" title="异常代码一般分析方法"></a>异常代码一般分析方法</h3><ul><li><strong>代码注释法</strong> 利用二分法思想逐行去注释代码，直到定位问题</li><li><strong>类库异常，兼容问题</strong> 这种场景也会经常遇到，我们需要用可以调试页面异常的方式，如 <code>Safari</code>，<code>Whistle</code>，<code>vConsole</code> 查看异常日志，从而迅速定位类库位置，从而找寻替换或是兼容方案。</li><li><strong>try catch</strong> 如果你的项目没有异常监控，那么在可疑的代码片段中去 <code>Try Catch</code> 吧。</li><li><strong>ES6 语法兼容</strong> 一般我们都会通过 <code>Babel</code> 来编译 <code>ES6</code> ，但是额外的第三方类库如果有不兼容的语法，低版本的移动设备就会异常。所以，先用上文讲述的调试方法，确定异常，然后去增加 polyfill 来兼容吧。</li></ul><h2 id="console"><a href="#console" class="headerlink" title="console"></a>console</h2><p>如今，我们项目的开发通常会使用React、Vue等前端框架，前端调试也变得更加有难度，除了使用React Dev Tools，Vue Dev Tools等插件之外，我们使用最多的就是console.log()，当然多数情况下，console.log()就能满足我们的需求，但是当数据变得比较复杂时，console.log()就显得有些单一。</p><h3 id="基本打印"><a href="#基本打印" class="headerlink" title="基本打印"></a>基本打印</h3><h4 id="console-log"><a href="#console-log" class="headerlink" title="console.log()"></a>console.log()</h4><p>console.log()就是最基本、最常用的用法了。它可以用在JavaScript代码的任何地方，然后就可以浏览器的控制台中看到打印的信息。其基本使用方法如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;CUGGZ&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name)                    <span class="comment">// CUGGZ</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`my name is: <span class="subst">$&#123;name&#125;</span>`</span>)   <span class="comment">// my name is: CUGGZ</span></span><br><span class="line"><span class="built_in">console</span>.log(name, age)               <span class="comment">// CUGGZ 18</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;message:&quot;</span>, name, age)   <span class="comment">// message: CUGGZ 18</span></span><br></pre></td></tr></table></figure><p>除此之外，console.log()还支持下面这种输出方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;CUGGZ&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> height = <span class="number">180</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Name: %s, Age: %d&#x27;</span>, name, age)     <span class="comment">// Name: CUGGZ, Age: 18</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Age: %d, Height: %d&#x27;</span>, age, height) <span class="comment">// Age: 18, Height: 180</span></span><br></pre></td></tr></table></figure><p>这里将后面的变量赋值给了前面的占位符的位置，他们是一一对应的。这种写法在复杂的输出时，能保证模板和数据分离，结构更加清晰。不过如果是简单的输出，就没必要这样写了。在console.log中，支持的占位符格式如下：</p><ul><li>字符串：%s</li><li>整数：%d</li><li>浮点数：%f</li><li>对象：%o或%O</li><li>CSS样式：%c</li></ul><p>可以看到，除了最基本的几种类型之外，它还支持定义CSS样式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;CUGGZ&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;My Name is %cCUGGZ&#x27;</span>, <span class="string">&#x27;color: skyblue; font-size: 30px;&#x27;</span>) </span><br></pre></td></tr></table></figure><p>这个样式打印可能有用的地方就是打印图片，用来查看图片是否正确：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;%c &#x27;</span>,<span class="string">&#x27;background-image:url(&quot;http://iyeslogo.orbrand.com/150902Google/005.gif&quot;);background-size:120% 120%;background-repeat:no-repeat;background-position:center center;line-height:60px;padding:30px 120px;&#x27;</span>);</span><br></pre></td></tr></table></figure><p>严格地说，console.log()并不支持打印图片，但是可以使用CSS的背景图来打印图片，不过并不能直接打印，因为是不支持设置图片的宽高属性，所以就需要使用line-heigh和padding来撑开图片，使其可以正常显示出来。</p><h4 id="console-warn"><a href="#console-warn" class="headerlink" title="console.warn()"></a>console.warn()</h4><p>console.warn() 方法用于在控制台输出警告信息。它的用法和console.log是完全一样的，只是显示的样式不太一样，信息最前面加一个黄色三角，表示警告：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = [<span class="string">&quot;facebook&quot;</span>, <span class="string">&quot;google&quot;</span>, <span class="string">&quot;twitter&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.warn(app);</span><br></pre></td></tr></table></figure><h4 id="console-error"><a href="#console-error" class="headerlink" title="console.error()"></a>console.error()</h4><p>console.error()可以用于在控制台输出错误信息。它和上面的两个方法的用法是一样的，只是显示样式不一样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = [<span class="string">&quot;facebook&quot;</span>, <span class="string">&quot;google&quot;</span>, <span class="string">&quot;twitter&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.error(app);</span><br></pre></td></tr></table></figure><p>需要注意，console.exception() 是 console.error() 的别名，它们功能是相同的。</p><p>当然，<strong>console.error()还有一个console.log()不具备的功能，那就是打印函数的调用栈</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a();</span><br><span class="line">&#125;</span><br><span class="line">c();</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VM221:<span class="number">5</span> error</span><br><span class="line">b @ VM221:<span class="number">5</span></span><br><span class="line">a @ VM221:<span class="number">2</span></span><br><span class="line">c @ VM221:<span class="number">8</span></span><br><span class="line">（匿名） @ VM221:<span class="number">10</span></span><br></pre></td></tr></table></figure><p>可以看到，这里打印出来了函数函数调用栈的信息：b→a→c。</p><p>console对象提供了专门的方法来打印函数的调用栈（console.trace()），这个下面会介绍到。</p><h4 id="console-info"><a href="#console-info" class="headerlink" title="console.info()"></a>console.info()</h4><p>console.info()可以用来打印资讯类说明信息，它和console.log()的用法一致，打印出来的效果也是一样的。</p><h3 id="打印时间"><a href="#打印时间" class="headerlink" title="打印时间"></a>打印时间</h3><h4 id="console-time-amp-console-timeEnd"><a href="#console-time-amp-console-timeEnd" class="headerlink" title="console.time() &amp; console.timeEnd()"></a>console.time() &amp; console.timeEnd()</h4><p>如果我们想要获取一段代码的执行时间，就可以使用console对象的console.time() 和console.timeEnd()方法，来看下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.timeEnd();</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// default: 1001.9140625 ms</span></span><br></pre></td></tr></table></figure><p>它们都可以传递一个参数，该参数是一个字符串，用来标记唯一的计时器。如果页面只有一个计时器时，就不需要传这个参数 ，如果有多个计时器，就需要使用这个标签来标记每一个计时器：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">&quot;timer1&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&quot;timer2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.timeEnd(<span class="string">&quot;timer1&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.timeEnd(<span class="string">&quot;timer2&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// timer1: 1004.666259765625 ms</span></span><br><span class="line"><span class="comment">// timer2: 2004.654052734375 ms</span></span><br></pre></td></tr></table></figure><h4 id="console-timeLog"><a href="#console-timeLog" class="headerlink" title="console.timeLog()"></a>console.timeLog()</h4><p>这里的console.timeLog()上面的console.timeEnd()类似，但是也有一定的差别。他们都需要使用console.time()来启动一个计时器。然后console.timeLog()就是打印计时器<strong>当前的时间</strong>，而console.timeEnd()是打印计时器，直到结束的时间。下面来看例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">&quot;timer&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.timeLog(<span class="string">&quot;timer&quot;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.timeLog(<span class="string">&quot;timer&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// timer: 1002.80224609375 ms</span></span><br><span class="line"><span class="comment">// timer: 3008.044189453125 ms</span></span><br></pre></td></tr></table></figure><p>而使用console.timeEnd()时：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">&quot;timer&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">&quot;timer&quot;</span>)</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	    <span class="built_in">console</span>.timeLog(<span class="string">&quot;timer&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VM432:<span class="number">4</span> timer: <span class="number">1015.506103515625</span> ms</span><br><span class="line"><span class="attr">VM432</span>:<span class="number">6</span> Timer <span class="string">&#x27;timer&#x27;</span> does not exist</span><br></pre></td></tr></table></figure><p>可以看到，它会终止当前的计时器，所以里面的timeLog就无法在找到timer计数器了。 所以两者的区别就在于，是否会终止当前的计时。</p><h3 id="分组打印"><a href="#分组打印" class="headerlink" title="分组打印"></a>分组打印</h3><h4 id="console-group-amp-console-groupEnd"><a href="#console-group-amp-console-groupEnd" class="headerlink" title="console.group() &amp; console.groupEnd()"></a>console.group() &amp; console.groupEnd()</h4><p>这两个方法用于在控制台创建一个信息分组。 一个完整的信息分组以 console.group() 开始，console.groupEnd() 结束。来看下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.group();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;First Group&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.group();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Second Group&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.groupEnd();</span><br><span class="line"><span class="built_in">console</span>.groupEnd();</span><br></pre></td></tr></table></figure><p>再来看一个复杂点的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.group(<span class="string">&quot;Alphabet&quot;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.group(<span class="string">&quot;Numbers&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;One&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Two&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.groupEnd(<span class="string">&quot;Numbers&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.groupEnd(<span class="string">&quot;Alphabet&quot;</span>);</span><br></pre></td></tr></table></figure><p>可以看到，这些分组是可以嵌套的。当前我们需要调试一大堆调试输出，就可以选择使用分组输出，</p><h4 id="console-groupCollapsed"><a href="#console-groupCollapsed" class="headerlink" title="console.groupCollapsed()"></a>console.groupCollapsed()</h4><p>console.groupCollapsed()方法类似于console.group()，它们都需要使用console.groupEnd()来结束分组。不同的是，该方法默认打印的信息是折叠展示的，而group()是默认展开的。来对上面的例子进行改写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.groupCollapsed(<span class="string">&quot;Alphabet&quot;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.groupCollapsed(<span class="string">&quot;Numbers&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;One&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Two&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.groupEnd(<span class="string">&quot;Numbers&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.groupEnd(<span class="string">&quot;Alphabet&quot;</span>);</span><br></pre></td></tr></table></figure><p>可以看到，和上面方法唯一的不同就是，打印的结果被折叠了，需要手动展开来看。</p><h3 id="打印计次"><a href="#打印计次" class="headerlink" title="打印计次"></a>打印计次</h3><h4 id="console-count"><a href="#console-count" class="headerlink" title="console.count()"></a>console.count()</h4><p>可以使用使用console.count()来获取当前执行的次数。来看下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.count();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果如下</span></span><br><span class="line"><span class="attr">default</span>: <span class="number">1</span></span><br><span class="line"><span class="attr">default</span>: <span class="number">2</span></span><br><span class="line"><span class="attr">default</span>: <span class="number">3</span></span><br><span class="line"><span class="attr">default</span>: <span class="number">4</span></span><br><span class="line"><span class="attr">default</span>: <span class="number">5</span></span><br></pre></td></tr></table></figure><p>它也可以传一个参数来进行标记（如果为空，则为默认标签default）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.count(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果如下</span></span><br><span class="line"><span class="attr">hello</span>: <span class="number">1</span></span><br><span class="line"><span class="attr">hello</span>: <span class="number">2</span></span><br><span class="line"><span class="attr">hello</span>: <span class="number">3</span></span><br><span class="line"><span class="attr">hello</span>: <span class="number">4</span></span><br><span class="line"><span class="attr">hello</span>: <span class="number">5</span></span><br></pre></td></tr></table></figure><p>这个方法主要用于一些比较复杂的场景，有时候一个函数被多个地方调用，就可以使用这个方法来确定是否少调用或者重复调用了该方法。</p><h4 id="console-countReset"><a href="#console-countReset" class="headerlink" title="console.countReset()"></a>console.countReset()</h4><p>顾名思义，console.countReset()就是重置计算器，它会需要配合上面的console.count()方法使用。它有一个可选的参数label：</p><ul><li>如果提供了参数label，此函数会重置与label关联的计数，将count重置为0。</li><li>如果省略了参数label，此函数会重置默认的计数器，将count重置为0。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.count(); </span><br><span class="line"><span class="built_in">console</span>.count(<span class="string">&quot;a&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.count(<span class="string">&quot;b&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.count(<span class="string">&quot;a&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.count(<span class="string">&quot;a&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.count(); </span><br><span class="line"><span class="built_in">console</span>.count(); </span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.countReset(); </span><br><span class="line"><span class="built_in">console</span>.countReset(<span class="string">&quot;a&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.countReset(<span class="string">&quot;b&quot;</span>); </span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.count(); </span><br><span class="line"><span class="built_in">console</span>.count(<span class="string">&quot;a&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.count(<span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">a</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">b</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">a</span>:<span class="number">2</span></span><br><span class="line"><span class="attr">a</span>:<span class="number">3</span></span><br><span class="line"><span class="attr">default</span>:<span class="number">2</span></span><br><span class="line"><span class="attr">default</span>:<span class="number">3</span></span><br><span class="line"><span class="attr">default</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">a</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">b</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="其他打印"><a href="#其他打印" class="headerlink" title="其他打印"></a>其他打印</h3><h4 id="console-table"><a href="#console-table" class="headerlink" title="console.table()"></a>console.table()</h4><p>我们平时使用console.log较多，其实console对象还有很多属性可以使用，比如console.table()，使用它可以方便的打印数组对象的属性，打印结果是一个表格。console.table() 方法有两个参数，第一个参数是需要打印的对象，第二个参数是需要打印的表格的标题，这里就是数组对象的属性值。</p><p>需要注意，console.table() 只能处理最多1000行，因此它可能不适合所有数据集。但是也能适用于多数场景了。</p><h4 id="console-clear"><a href="#console-clear" class="headerlink" title="console.clear()"></a>console.clear()</h4><p>console.clear() 顾名思义就是清除控制台的信息。当清空控制台之后，会打印一句：“Console was clered”。</p><p>当然，我们完全可以使用控制台的清除键清除控制台。</p><h4 id="console-trace"><a href="#console-trace" class="headerlink" title="console.trace()"></a>console.trace()</h4><p>console.trace()方法可以用于打印当前执行的代码在堆栈中的调用路径。它和上面的console.error()的功一致，不过打印的样式就和console.log()是一样的了。来看下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.trace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a();</span><br><span class="line">&#125;</span><br><span class="line">c();</span><br></pre></td></tr></table></figure><h2 id="React-Devtools"><a href="#React-Devtools" class="headerlink" title="React Devtools"></a>React Devtools</h2><h2 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h2><p>与其他语言不同，在JavaScript中，每段代码都是表达式或语句。</p><p><strong>表达式总是返回一个值。语句始终返回未定义。</strong></p><p>从1997年开始的原始JavaScript规范中定义了什么是语句和什么是表达式。</p><p>例如，说这是我们的程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color =<span class="string">&quot;blue&quot;</span>;   </span><br><span class="line">color =<span class="string">&quot;red&quot;</span>;</span><br></pre></td></tr></table></figure><p>您会注意到，如果将此行逐行输入到控制台中，第一行将返回undefined，而第二行将返回” red “。</p><p>这是因为，正如您可能已经猜到的那样，变量声明(var something = something)是语句，而变量赋值(something = something)是表达式。<br>如果您感到好奇，请尝试阅读上面我链接的规范中”简单分配”部分下的11.13.1(第50页)中的JavaScript如何评估赋值。</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>从本质上来说，<strong>表达式是产生值的一段JavaScript代码</strong>。</p><p>下面所有的例子全部都是表达式：</p><ul><li><code>1</code> → 产生值为<code>1</code></li><li><code>&quot;hello&quot;</code> → 产生值为<code>&quot;hello&quot;</code></li><li><code>5 * 10</code> → 产生值为<code>50</code></li><li><code>num &gt; 100</code> → 产生值为<code>true</code>或者<code>false</code></li><li><code>isHappy ? &quot;🙂&quot; : &quot;🙁&quot;</code> → 产生值为一个emoji</li><li><code>[1, 2, 3].pop()</code> → 产生值为<code>3</code></li></ul><p>表达式可以包含其他表达式。举例来说，你觉得下面的JS代码中有多少个表达式？</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">5</span> + <span class="number">1</span>) * <span class="number">2</span></span><br></pre></td></tr></table></figure><p>答案是一共有5个表达式。</p><p>具体来说，分别是以下5个：</p><ol><li><code>(5 + 1) * 2</code> ，这段代码本身就是表达式，产生的值为<code>12</code></li><li><code>(5 + 1)</code> ，由于有括号，这个子表达式首先求值，并解析为<code>6</code>。</li><li><code>5</code>，单个数字本身就是表达式，因为它们产生一个值。这个表达式解析为<code>5</code>。</li><li><code>1</code>，同样的道理，这个表达式解析为<code>1</code>。</li><li><code>2</code>，这个数字形成最后的表达式，它解析为<code>2</code>。</li></ol><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p><strong>一个JavaScript程序是一连串的语句。每条语句都是计算机做某件事的指令。</strong></p><p>这里是有关JavaScript中语句的示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hi = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hi &gt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="comment">// 更多语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br></pre></td></tr></table></figure><p>关于语句和表达式，我是这么认为的：<strong>语句是支撑我们程序的刚性结构，而表达式则填充了细节</strong>。</p><p>语句中通常有表达式的 “插槽”。我们可以把任何我们喜欢的表达式放到这些插槽里。</p><p>举例来说，声明一个具有表达式插槽的变量可以这么做：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hi = <span class="comment">/* 表达式 */</span>;</span><br></pre></td></tr></table></figure><p>在这个插槽中，我们可以使用任何先前看到过的表达式：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hi = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> hi = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> hi = <span class="number">5</span> * <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> hi = num &gt; <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> hi = isHappy ? <span class="string">&quot;🙂&quot;</span> : <span class="string">&quot;🙁&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> hi = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].pop();</span><br></pre></td></tr></table></figure><p>就有效语法而言，表达式是可以互换的。如果一个语句有一个表达式插槽，我们可以把任何表达式放在那里，代码就会运行。并且我们不会得到语法报错。</p><p>也就是说，我们可能会遇到其他的问题。比如说，下面的代码在语法层面来说是有效的，但如果我们尝试运行就会让浏览器崩溃，因为它会导致死循环：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="string">&quot;hello&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 因为&quot;hello&quot;永不改变，因此循环会一遍又一遍的重复，直到脚本崩溃。</span></span><br><span class="line">    <span class="comment">// 语法上是有效的，但仍是有问题的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="便捷技巧"><a href="#便捷技巧" class="headerlink" title="便捷技巧"></a>便捷技巧</h3><p>想知道一段JS代码到底是语句还是表达式吗？试着将它打印出来吧！</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="comment">/* 这里是JS代码 */</span>);</span><br></pre></td></tr></table></figure><p>如果能够运行，该代码就是表达式。如果报错，那就是语句（当然，也有可能是非法JS）。</p><p>此外，我们甚至可以看到表达式的结果，因为会将结果打印到浏览器的控制台中。</p><p>这样可以凑效是因为任意函数的参数都必须是表达式。表达式会产生一个值，并将该值传递到函数中。语法并不会产生一个值，因此语句不能被用作函数的参数。</p><p>即使作为一个有经验的开发者，我也非常依赖<code>console.log</code>。它真的是一个好东西。</p><h3 id="表达式作为语句"><a href="#表达式作为语句" class="headerlink" title="表达式作为语句"></a>表达式作为语句</h3><p>这是一个表达式：<code>1 + 2 + 3</code> 。</p><p>如果我们创建一个只包括这个表达式的JS文件，会发生什么？让我们试想把下面的内容保存为<code>test.js</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span></span><br></pre></td></tr></table></figure><p>该文件中有多少个语句？0个还是1个？</p><p>事情是这样的：表达方式不能单独存在。它们总是语句的一部分。所以在这种情况下，我们有一个看起来像这样的语句：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 表达式插槽 */</span></span><br></pre></td></tr></table></figure><p>除了表达式插槽之外，该语句基本上是空的。表达式<code>1 + 2 + 3</code>填充了该插槽，那么语句也就生成了。</p><p>换句话说，以下所有行都是有效的语句：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语句 1:</span></span><br><span class="line"><span class="keyword">let</span> hi = <span class="comment">/* 表达式插槽 */</span>;</span><br><span class="line"><span class="comment">// 语句 2:</span></span><br><span class="line"><span class="keyword">return</span> <span class="comment">/* 表达式插槽 */</span>;</span><br><span class="line"><span class="comment">// 语句 3:</span></span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/* 表达式插槽 */</span>) &#123; &#125;</span><br><span class="line"><span class="comment">// 语句 4:</span></span><br><span class="line"><span class="comment">/* 表达式插槽 */</span></span><br></pre></td></tr></table></figure><p>通常情况下，某些教程会错误地指出，表达式就是语句，但这并不完全正确。表达式和语句是不同的东西。但是语句有可能在不提供任何额外字符的情况下包裹住表达式。这就好像用透明的保鲜膜包裹住一个三明治。</p><p>语句通常以分号结尾，它标志着语句的结束。对某些语句来说分号不是必须的，如<code>if</code>语句、<code>while</code>循环和函数声明。</p><h3 id="React中的实践"><a href="#React中的实践" class="headerlink" title="React中的实践"></a>React中的实践</h3><p>如果你曾使用过React，你可能知道大括号<code>&#123;</code>和<code>&#125;</code>允许我们在JSX中嵌入一些JavaScript，就像这样：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CountdownClock</span>(<span class="params">&#123; secondsRemaining &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      Time left:</span></span><br><span class="line"><span class="xml">      &#123;Math.round(secondsRemaining / 60)&#125; minutes!</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是React的神奇之处，它可以让我们拥有JavaScript的全部能力。</p><p>但有一个问题 — 我们不能在大括号里面放置任意JavaScript代码。具体来说，我们只能包括表达式，而不能包括语句。大括号本质上是在我们的JSX中创建一个表达式插槽。</p><p>如果我们尝试在大括号内嵌入一个语句，比如说<code>if/else</code>语句，我们会得到错误：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CountdownClock</span>(<span class="params">&#123; secondsRemaining &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 🚫 语法报错</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;if (secondsRemaining &gt; 0) &#123;</span></span><br><span class="line"><span class="xml">        `$&#123;secondsRemaining&#125; seconds left`</span></span><br><span class="line"><span class="xml">      &#125; else &#123;</span></span><br><span class="line"><span class="xml">        &quot;Time expired!&quot;</span></span><br><span class="line"><span class="xml">      &#125;&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为语句不会产生值，只有表达式才会产生值。如果我们想在JSX中嵌入<code>if/else</code>逻辑，我们需要使用一个三元操作符表达式：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CountdownClock</span>(<span class="params">&#123; secondsRemaining &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// ✅ 没问题</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;secondsRemaining &gt; 0</span></span><br><span class="line"><span class="xml">        ? `$&#123;secondsRemaining&#125; seconds left`</span></span><br><span class="line"><span class="xml">        : &quot;Time expired!&quot;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这似乎是一个诡异的JSX/React限制，但它实际上是一个JavaScript限制。</p><p>我想我们经常责怪React的一些看似武断的规则，比如组件必须返回一个顶层元素。但更多的时候，React只是在警告我们一个关于JavaScript的限制。</p><p>理解语句和表达式的区别是非常重要的。我们还需要了解JSX是如何编译成JavaScript的，以及React的调度与渲染周期是如何工作的……但是，这些话题已经超出了本篇文章的范围。</p><h1 id="输出题"><a href="#输出题" class="headerlink" title="输出题"></a>输出题</h1><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="this指向★"><a href="#this指向★" class="headerlink" title="this指向★"></a>this指向★</h3><blockquote><p>考察公司：小米、百度</p></blockquote><p>目的就是指向<strong>函数</strong>运行时（箭头函数除外）所在的环境。</p><p>总结了<code>this</code>的绑定规则总共是有下面5种：请记住一点：<strong>谁调用这个函数或方法,this关键字就指向谁。</strong></p><ul><li>默认绑定（严格/非严格模式）<ul><li>无论是否在严格模式下，在全局执行环境中（在任何函数体外部）<code>this</code> 都指向全局对象。</li><li>非严格模式，函数中 <code>this</code> 的值默认指向全局对象，浏览器中就是<code>window</code>。</li><li>严格模式（use strict）下，<code>this</code> 会保持为 <code>undefined</code>。</li><li>全局中用<strong>let</strong>和<strong>const</strong>声明的变量存在<strong>Script</strong>上，用<strong>var</strong>声明的存在<strong>Global</strong>上（浏览器一般用<strong>Window</strong>表示）</li></ul></li><li>隐式绑定<ul><li>当<strong>函数作为对象的属性</strong>存在，通过<strong>对象属性执行函数</strong>时，此时隐式绑定规则会将<code>this</code>绑定到对象上。</li><li>赋值或函数传参（隐式赋值），会丢失该this绑定。</li></ul></li><li>显式绑定<ul><li><strong>通过 <code>call</code> <code>apply</code> <code>bind</code>绑定</strong></li><li>如果<code>call、apply、bind</code>接收到的第一个参数是空或者<code>null、undefined</code>的话，则会忽略这个参数</li><li>在Javascript中，多次 <code>bind()</code> 是无效的。</li><li><code>forEach、map、filter</code>函数的第二个参数也是能显式绑定<code>this</code>的</li></ul></li><li>new绑定<ul><li>当一个函数用作<strong>构造函数</strong>时（使用<code>new</code>关键字），它的<code>this</code>被绑定到<strong>正在构造的新对象</strong>。</li><li>当构造函数<strong>返回值为对象</strong>时，直接返回这个对象；否则返回<strong>new创建的对象</strong>。</li><li><code>this</code> 在类中的表现与在函数中类似，在类的构造函数中，<code>this</code> 是一个常规对象。类中所有非静态的方法都会被添加到 <code>this</code> 的原型。静态方法不是 this 的属性，它们只是类自身的属性。</li><li>派生类的构造函数没有初始的 <code>this</code> 绑定。在构造函数中调用 <code>super()</code>会生成一个 <code>this</code> 绑定，并相当于获得基类的this。</li></ul></li><li>ES6箭头函数绑定<ul><li>通过<strong>作用域链</strong>查到<strong>外层作用域的 this</strong> ，且指向<strong>函数定义时的 this</strong> 而非执行时</li><li>作用域只有全局作用域<code>window</code>和局部作用域函数</li><li>字面量创建的对象，作用域是<code>window</code>，如果里面有箭头函数属性的话，<code>this</code>指向的是<code>window</code></li><li>构造函数创建的对象，作用域是可以理解为是这个构造函数，且这个构造函数的<code>this</code>是指向新建的对象的，因此<code>this</code>指向这个对象。</li><li>箭头函数的<code>this</code>是无法通过<code>bind、call、apply</code>来<strong>直接</strong>修改，但是可以通过改变作用域中<code>this</code>的指向来间接修改。</li></ul></li></ul><p>判断this指向顺序：<code>箭头函数、new、call/apply/bind、隐式绑定、默认绑定</code></p><h3 id="call、apply、bind★"><a href="#call、apply、bind★" class="headerlink" title="call、apply、bind★"></a>call、apply、bind★</h3><blockquote><p>考察公司：完美世界、小米</p></blockquote><ul><li>三者都可以改变函数的<code>this</code>对象指向</li><li>三者第一个参数都是<code>this</code>要指向的对象，如果如果没有这个参数或参数为<code>undefined</code>或<code>null</code>，则默认指向全局<code>window</code></li><li>三者都可以传参，但是<code>apply</code>是数组，而<code>call</code>是参数列表，且<code>apply</code>和<code>call</code>是一次性传入参数，而<code>bind</code>可以分为多次传入</li><li><code>bind</code>是返回绑定this之后的函数，<code>apply</code>、<code>call</code> 则是立即执行</li></ul><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><ul><li><strong>将函数设置为绑定对象的属性</strong></li><li>执行函数</li><li>删除对象的这个属性</li><li>将返回值返回</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓展Function原型，使用Rest操作符接收剩余参数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype._call = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg,...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 非严格模式下, 没有参数或为 null 和 undefined，自动指向全局对象</span></span><br><span class="line">    <span class="comment">// 值为原始值的会指向该原始值的自动包装对象(用 Object() 转换）</span></span><br><span class="line">    thisArg = thisArg ? <span class="built_in">Object</span>(thisArg) : <span class="built_in">window</span>; </span><br><span class="line">    <span class="comment">// _call由函数调用，此时的this指向函数，是一种隐式绑定</span></span><br><span class="line">    <span class="comment">// 将调用函数this设为绑定对象的属性fn</span></span><br><span class="line">    thisArg.fn = <span class="built_in">this</span>; </span><br><span class="line">    <span class="comment">// 执行该函数</span></span><br><span class="line">    <span class="keyword">const</span> res = thisArg.fn(...args); </span><br><span class="line">    <span class="comment">// 删除对象的这个属性</span></span><br><span class="line">    <span class="keyword">delete</span> thisArg.fn</span><br><span class="line">    <span class="comment">// 将返回值返回</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>跟call思路类似，主要是第二个参数是一个数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._apply = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg, arr</span>) </span>&#123;</span><br><span class="line">    thisArg = thisArg ? <span class="built_in">Object</span>(thisArg) : <span class="built_in">window</span>; </span><br><span class="line">    <span class="comment">// 将函数设为对象的属性</span></span><br><span class="line">    thisArg.fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 执行该函数</span></span><br><span class="line">    <span class="keyword">const</span> res = thisArg.fn(...arr);</span><br><span class="line">    <span class="comment">// 删除该函数  </span></span><br><span class="line">    <span class="keyword">delete</span> thisArg.fn</span><br><span class="line">    <span class="comment">// 将返回值返回</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>bind方法就是新创建一个与函数f具有相同函数体和作用域的函数，然后把新函数的this指向永久绑定为<code>bind</code>的第一个参数，无论新函数如何被调用的，新函数的this指向已永久绑定。</p><p>利用了闭包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._bind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args1</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 箭头函数不会生成自身作用域下的this，会从自己的作用域链的上一层继承this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args2</span>) =&gt;</span> &#123; </span><br><span class="line">        thisArg = thisArg ? <span class="built_in">Object</span>(thisArg) : <span class="built_in">window</span>;  </span><br><span class="line">        thisArg.fn = <span class="built_in">this</span>; <span class="comment">// 调用箭头函数时的this指向的是调用者也就是函数对象，将函数对象赋值给thisArg对象的一个属性</span></span><br><span class="line">        <span class="keyword">const</span> res = thisArg.fn(...args1, ...args2); <span class="comment">// 调用thisArg.fn时，fn中的this指针指向的是thisArg，并使用Spread操作符展开参数传参</span></span><br><span class="line">        <span class="keyword">delete</span> thisArg.fn; <span class="comment">// 删除thisArg对象的fn属性</span></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 将返回值返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a= <span class="number">1</span>; <span class="comment">// 定义一个全局变量</span></span><br><span class="line"><span class="keyword">const</span> obj =&#123;<span class="attr">a</span>:<span class="number">2</span>&#125;<span class="comment">// 定义一个对象用来绑定</span></span><br><span class="line"><span class="comment">// 定义一个函数用来执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">b,c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a,b,c)</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">// 直接执行，相当于window.fn(1, 2)，this绑定于window</span></span><br><span class="line">fn._call();<span class="comment">//无参this仍绑定于window</span></span><br><span class="line">fn._call(obj,<span class="number">5</span>,<span class="number">7</span>);<span class="comment">// 使用call将this绑定到obj对象</span></span><br><span class="line">fn._apply(obj,[<span class="number">7</span>,<span class="number">6</span>]);<span class="comment">// 使用apply将this绑定到obj对象</span></span><br><span class="line"><span class="keyword">const</span> func = fn._bind(obj,<span class="number">9</span>);<span class="comment">// 使用bind将this绑定到obj对象，bind方法返回一个原函数的拷贝，并拥有指定的this值和初始参数。</span></span><br><span class="line">func(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="变量提升和函数提升"><a href="#变量提升和函数提升" class="headerlink" title="变量提升和函数提升"></a>变量提升和函数提升</h3><ul><li><p><strong>所有的声明都会提升到作用域的最顶上去</strong>。</p></li><li><p>同一个变量只会<strong>声明一次</strong>，其他的会被忽略掉。</p></li><li><p><strong>函数声明的优先级高于变量声明的优先级</strong>，并且函数声明和函数定义的部分一起被提升。</p></li><li><p>用<code>let</code>和<code>const</code>声明的变量也会被提升，但与<code>var</code>不同，它们不会用默认值（<code>undefined</code>）初始化。如果在初始化之前读取了用<code>let</code>或<code>const</code>声明的变量，则会<strong>引发异常</strong>。</p></li><li><p>使用<strong>类声明</strong>定义的类被提升，这意味着JavaScript有对该类的引用。但是，该类在<strong>默认情况下不会初始化</strong>，因此在执行该类初始化的行之前使用该类的任何代码都将抛出<code>ReferenceError</code>。</p></li><li><p><strong>函数表达式和类表达式不被提升</strong>。</p><ul><li>这些表达式分别计算一个函数或类，它们<strong>通常被赋给一个变量</strong>。</li><li>在这种情况下，变量声明被挂起，表达式被初始化。因此，在执行相关行之前，不会对表达式求值。</li></ul></li></ul><h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><p>当函数中隐式声明一个变量时：</p><ul><li><p><strong>该变量和参数同名</strong>，该变量为<strong>局部变量</strong>。</p><p>函数传参相当于在内部声明了一个局部变量（<code>var param = param;</code>）</p><ul><li>实参如果是<strong>对象</strong>，就把该对象的<strong>地址</strong>赋给这个局部变量，可以通过地址<strong>修改外层对象的属性</strong>，但如果重新赋给该变量一个<strong>新的对象</strong>，不会覆盖外层对象</li><li>实参如果是<strong>原始类型</strong>就把值赋给该变量，<strong>修改该变量不会影响外层变量</strong>。</li></ul></li><li><p>函数<strong>没有参数</strong>，通过<strong>作用域链</strong>向外一直找到<strong>全局作用域</strong>。</p><ul><li>如果有该变量，说明该变量只是在其他地方进行了声明。</li><li>若没有找到，此时<strong>隐式声明了一个全局变量（window上）</strong>，且不会进行变量提升。</li></ul></li></ul><h3 id="同名问题"><a href="#同名问题" class="headerlink" title="同名问题"></a>同名问题</h3><h4 id="变量和函数"><a href="#变量和函数" class="headerlink" title="变量和函数"></a>变量和函数</h4><p><strong>变量</strong>a和<strong>函数</strong>a<strong>同名</strong>，区别在于<strong>变量a赋值了没</strong>。</p><p>var和funciotn声明会被提升，<strong>函数会首先被提升</strong>，注意：函数表达式不会被提升。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//function a() &#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//function a() &#123;&#125;</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//function a() &#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>JavaScript在代码执行前会进行预编译，创建了一个GO（Global Object）对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GO&#123;</span><br><span class="line">    <span class="attr">a</span> : <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述情况1，遇到var a，因变量a已存在，直接忽略。所以打印均为函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GO&#123;</span><br><span class="line">    <span class="attr">a</span> :<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况2，js引擎在执行遇到a = 1 时，就把原先变量a地址存放的指针替换，赋值为1。</p><h4 id="全局变量和函数内变量重名"><a href="#全局变量和函数内变量重名" class="headerlink" title="全局变量和函数内变量重名"></a>全局变量和函数内变量重名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//1</span></span><br><span class="line">    a;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>函数在执行的时候会生成函数作用域，该作用域在预编译时也会<strong>寻找var和函数声明</strong>的，若有则进行提升。</p><p>上述情况区别是函数内<strong>变量a有无进行var声明</strong>：</p><ul><li>没有var声明则不会被提升，所以在执行到console时，发现该函数作用域无变量a，则向上查找，找到变量a，它的值为1；</li><li>有var声明则会被提升，所以在执行到console时，发现该函数作用域有变量a，此时值为undefined。</li></ul><h4 id="局部变量、函数和函数形参重名"><a href="#局部变量、函数和函数形参重名" class="headerlink" title="局部变量、函数和函数形参重名"></a>局部变量、函数和函数形参重名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//function a() &#123;&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//function a() &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当fn函数调用时，创建函数执行上下文，形参相当于立刻执行了<code>var a = 1</code>,当进入函数体后</p><ul><li>情况一<code>var a = 2</code>相当于重新赋值，但变量赋值不会提升，在此之前，<code>a=1</code>，之后<code>a=2</code>。</li><li>情况一<code>function a() &#123;&#125;</code>会将声明和函数定义部分一同提升，原本形参中的1就被覆盖，在函数体任何地方a都是函数。</li><li>非严格模式下，arguments对象也会跟随变化，严格模式始终为实参，也就是不允许对arguments赋值，且arguments不再跟踪参数的变化。</li></ul><h2 id="事件循环★"><a href="#事件循环★" class="headerlink" title="事件循环★"></a>事件循环★</h2><blockquote><p>考察公司：完美世界、京东、百度</p></blockquote><h3 id="事件循环机制★"><a href="#事件循环机制★" class="headerlink" title="事件循环机制★"></a>事件循环机制★</h3><h4 id="JavaScript执行机制"><a href="#JavaScript执行机制" class="headerlink" title="JavaScript执行机制"></a>JavaScript执行机制</h4><p><strong>JavaScript是一种同步的、阻塞的、单线程的语言</strong>，在这种语言中，一次只能执行一个操作。</p><p>但web浏览器定义了函数和API，允许我们当某些事件发生时不是按照同步方式，而是<strong>异步地调用函数</strong>(比如，时间的推移，用户通过鼠标的交互，或者获取网络数据)。这意味着您的代码可以同时做几件事情，而不需要停止或阻塞主线程。</p><p>通过 <code>Web workers</code>可以把一些任务交给一个名为<code>worker</code>的单独的线程，这样就可以同时运行多个JavaScript代码块。</p><p>web workers有用但也有局限。如<strong>不能访问 DOM— 不能让一个worker直接更新UI</strong>。</p><p><strong>如何保证主线程, 有序并高效或非阻塞的处理呢? =&gt; 事件循环机制 Event Loop</strong></p><h4 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h4><p>异步callbacks 其实就是<strong>函数</strong>，只不过是作为<strong>参数</strong>传递给那些在后台执行的其他函数。</p><p>如：异步callback 就是<code>addEventListener()</code>第二个参数。</p><p>当我们把<strong>回调函数作为一个参数传递给另一个函数时，仅仅是把回调函数定义作为参数传递过去</strong> — <strong>回调函数并没有立刻执行，回调函数会在包含它的函数的某个地方异步执行，包含函数负责在合适的时候执行回调函数</strong>。</p><p>不是所有的回调函数都是异步的 — <strong>有一些是同步的</strong>。一个例子就是使用 <code>Array.prototype.forEach()</code>来遍历数组。</p><h4 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h4><blockquote><p>事件循环负责收集事件（包括用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。</p><p>循环执行等待中的宏任务和微任务，并开始下一次循环之前执行一些必要的渲染和绘制操作。</p></blockquote><p>任务的执行模式</p><ul><li><p>同步：连续性、阻塞</p></li><li><p>异步</p><ul><li><p>宏任务（Macrotask，Task，宿主（浏览器、Node）发起）：<code>script</code>（整体代码块）、事件触发的回调、<code>setTimeout</code>、<code>setInterval</code>、<code>requestAnimationFrame</code>（在浏览器环境是，而node环境不是）、</p><p><code>setImmediate</code>（node环境下是，而浏览器环境下不是）、<code>I/O</code></p><p>、 <code>UI-rendering</code></p></li><li><p>微任务（Microtask，Jobs， JS 自身发起）：<code>Promise.[ then/catch/finally ]</code>、<code>queueMicrotask</code></p></li></ul></li></ul><p>一个完整的 <strong>Event Loop</strong> 过程，可以概括为以下阶段：</p><ul><li><p>一开始<strong>执行栈空,<strong>我们可以把</strong>执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</strong>。<strong>微任务队列空</strong>，<strong>宏任务队列</strong>里有且只有一个 <strong>script 脚本（整体代码）</strong>。</p></li><li><p><strong>全局上下文（script 标签）被推入执行栈</strong>，<strong>同步代码执行</strong>。</p><ul><li>在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生<strong>新的宏任务与微任务</strong>，它们会分别被<strong>推入各自的任务队列</strong>里。</li><li>同步代码执行完了，script脚本会被<strong>移出宏任务队列</strong>。</li><li>这个过程本质上是<strong>队列的宏任务的执行和出队</strong>的过程。</li></ul></li><li><p>上一步我们出队的是一个<strong>宏任务</strong>，这一步我们处理的是微任务。</p><ul><li>当<strong>宏任务出队</strong>时，任务是<strong>一个一个</strong>执行的；</li><li>而<strong>微任务出队</strong>时，任务是<strong>一队一队</strong>执行的。</li><li>因此，我们处理微任务队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</li></ul></li><li><p><strong>执行渲染操作，更新界面</strong></p></li><li><p>检查是否存在<code>Web worker</code>任务，如果有，则对其进行处理</p></li><li><p>上述过程循环往复，直到两个队列都清空。</p></li></ul><p><strong>如何理解 script（整体代码块）是个宏任务呢</strong></p><p>同时存在两个script代码块，会首先在执行<strong>第一个 script 代码块中的同步代码</strong>，如果这个过程中创建了微任务并进入了微任务队列，第一个 script 同步代码执行完之后，会首先去<strong>清空微任务队列</strong>，再去开启<strong>第二个 script 代码块</strong>的执行。</p><p>首次执行<strong>宏队列中会有 script（整体代码块）任务</strong>，所以实际上就是 Js 解析完成后，在异步任务中，会<strong>先执行完所有的微任务</strong>。需要注意的是，<strong>新创建的微任务会立即进入微任务队列排队执行，不需要等待下一次轮回</strong>。</p><p>所谓任务，浅显来说就是<strong>代码块开始执行的入口</strong>(确切地说，是函数栈的入口)。</p><p>而在 <code>JS</code> 里，除了“<code>script</code>整体代码块”之外，<strong>所有代码块的入口都是“回调函数”</strong>，回调函数被注册到事件后不会马上被执行，而是保存在一个神秘的的地方，保存起来待执行的才能算“任务”，然后才有宏/微任务之分。</p><p>“<code>script</code>整体代码块”的特殊之处，在于<strong>它的入口不是回调函数</strong>，但是我们可以想象它被装在一个隐形的函数里，作为回调函数被注册到某个事件里（大概是它解析完成之后会触发的一个事件），这时候这个隐形的函数就成为了一个任务。</p><p>浏览器<code>UI</code>是多线程的，异步任务借助浏览器的线程和<code>JavaScript</code>的执行机制实现。</p><p><strong>queueMicrotask</strong></p><p><strong>可以安全的引入微任务而避免使用额外的技巧</strong>。由晦涩地使用 promise 去创建微任务而带来的风险就可以被避免了。举例来说，当使用 promise 创建微任务时，由回调抛出的异常被报告为 rejected promises 而不是标准异常。同时，创建和销毁 promise 带来了事件和内存方面的额外开销，这是正确入列微任务的函数应该避免的。</p><h3 id="Node事件循环"><a href="#Node事件循环" class="headerlink" title="Node事件循环"></a>Node事件循环</h3><p>在<code>Node</code>中，同样存在宏任务和微任务，与浏览器中的事件循环相似</p><p><strong>微任务</strong>对应有：</p><ul><li>next tick queue：<code>process.nextTick</code></li><li>other queue：<code>Promise的then回调</code>、<code>queueMicrotask</code></li></ul><p><strong>宏任务</strong>对应有：</p><ul><li>timer queue：<code>setTimeout、setInterval</code></li><li>poll queue：<code>IO事件</code></li><li>check queue：<code>setImmediate</code></li><li>close queue：<code>close事件</code></li></ul><p><strong>Node 10</strong>以前：</p><ul><li>执行完一个阶段的所有任务</li><li>执行完nextTick队列里面的内容</li><li>然后执行完微任务队列的内容</li></ul><p><strong>Node 11</strong>以后： 和浏览器的行为统一了，都是每执行一个宏任务就执行完微任务队列。</p><p>async声明的函数只是把该函数的return包装了，使得无论如何都会返回promise对象（非promise会转化为promise{resolve}），除此之外与普通函数没有不同，没有特殊待遇。</p><p>await声明只能用在async函数中。当执行async函数时，遇到await声明，会先将await后面的内容按照’平常的执行规则’执行完，执行完后立马跳出async函数，去执行主线程其他内容，等到主线程执行完再回到await处继续执行后面的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;resolve3&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  resolve(<span class="string">&#x27;resovle1&#x27;</span>);</span><br><span class="line">  resolve(<span class="string">&#x27;resolve2&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p1)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).finally(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;finally&#x27;</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">resovle1 </span><br><span class="line"><span class="keyword">finally</span> <span class="literal">undefined</span></span><br><span class="line">timer1</span><br><span class="line"><span class="built_in">Promise</span> &#123;&lt;fulfilled&gt;: <span class="literal">undefined</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用 ，Promise的状态一经改变就不能再改变。</li><li>finally不管Promise的状态是<code>resolved</code>还是<code>rejected</code>都会执行，且它的回调函数是接收不到Promise的结果的，所以finally()中的res是一个迷惑项。</li><li>最后一个定时器打印出的p1其实是<code>.finally</code>的返回值，我们知道<code>.finally</code>的返回值如果在没有抛出错误的情况下默认会是上一个Promise的返回值，而这道题中<code>.finally</code>上一个Promise是<code>.then()</code>，但是这个<code>.then()</code>并没有返回值，所以p1打印出来的Promise的值会是<code>undefined</code>，如果你在定时器的下面加上一个<code>return 1</code>，则值就会变成1。</li><li>finally<ul><li>.finally()方法不管Promise对象最后的状态如何都会执行</li><li>.finally()方法的回调函数不接受任何的参数，也就是说你在.finally()函数中是没法知道Promise最终的状态是resolved还是rejected的</li><li>它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> async1 = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;async1 success&#x27;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="number">2</span>)</span><br><span class="line">  .then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">  .catch(<span class="number">4</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">script start</span><br><span class="line">async1</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line"><span class="number">1</span></span><br><span class="line">timer2</span><br><span class="line">timer1</span><br></pre></td></tr></table></figure><p>需要注意的点：</p><ul><li>async函数中await的<code>new Promise</code>要是没有返回值的话，也就是它的状态始终是pending状态，因此相当于一直在await，所以在await之后的内容是不会执行的。</li><li>.then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传。</li><li>注意定时器的延迟时间。定时器谁先执行，你只需要关注谁先被调用的以及延迟时间是多少，如果延迟时间都是0，只要关注谁先被调用的。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="function">() =&gt;</span> (<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">            resolve(<span class="number">6</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(p)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">    p.then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;));</span><br><span class="line">first().then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="built_in">Promise</span> &#123;&lt;fulfilled&gt;: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>第一段代码定义的是一个函数，所以我们得看看它是在哪执行的，发现它在4之前，所以可以来看看first函数里面的内容了。</li><li>函数first返回的是一个<code>new Promise()</code>，因此先执行里面的同步代码3</li><li>接着又遇到了一个<code>new Promise()</code>，直接执行里面的同步代码7</li><li>执行完7之后，在p中，遇到了一个定时器，先将它放到下一个宏任务队列里不管它，接着向下走</li><li>碰到了<code>resolve(1)</code>，这里就把p的状态改为了resolved，且返回值为1，不过这里也先不执行</li><li>跳出p，碰到了<code>resolve(2)</code>，这里的<code>resolve(2)</code>，表示的是把first函数返回的那个Promise的状态改了，也先不管它。</li><li>然后碰到了<code>p.then</code>，将它加入本次循环的微任务列表，等待执行</li><li>跳出first函数，遇到了<code>first().then()</code>，将它加入本次循环的微任务列表(p.then的后面执行)</li><li>然后执行同步代码4</li><li>本轮的同步代码全部执行完毕，查找微任务列表，发现<code>p.then</code>和<code>first().then()</code>，依次执行，打印出1和2</li><li>本轮任务执行完毕了，发现还有一个定时器没有跑完，接着执行这个定时器里的内容，执行同步代码5</li><li>然后又遇到了一个resolve(6)，它是放在p里的，但是p的状态在之前已经发生过改变了，因此这里就不会再改变，也就是说resolve(6)相当于没任何用处，因此打印出来的p为<code>Promise&#123;&lt;resolved&gt;: 1&#125;</code>。</li></ul><h1 id="Git★"><a href="#Git★" class="headerlink" title="Git★"></a>Git★</h1><blockquote><p>考察公司：腾讯、小米</p></blockquote><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/XzxS6f"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/21/XzxS6f.png" alt="XzxS6f.png"></a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>版本库👉.git<ul><li>当我们使用git管理文件时，比如<strong>git init</strong>时，这个时候，会多一个**.git**文件，我们把这个文件称之为版本库。</li><li><strong>.git</strong>文件另外一个作用就是它在创建的时候，会自动创建<strong>master</strong>分支，并且将<strong>HEAD</strong>指针指向<strong>master</strong>分支。</li></ul></li><li>工作区<ul><li>本地项目存放文件的位置。</li><li>可以理解成图上的workspace。</li></ul></li><li>暂存区 (<code>Index/Stage</code>)<ul><li>顾名思义就是暂时存放文件的地方，通过是通过<strong>add</strong>命令将工作区的文件添加到缓冲区。</li></ul></li><li>本地仓库（<code>Repository</code>）<ul><li>通常情况下，我们使用<strong>commit</strong>命令可以将暂存区的文件添加到本地仓库。</li><li>通常而言，<strong>HEAD</strong>指针指向的就是<strong>master</strong>分支。</li></ul></li><li>远程仓库（<code>Remote</code>）<ul><li>举个例子，当我们使用<strong>GitHub</strong>托管我们项目时，它就是一个远程仓库。</li><li>通常我们使用<strong>clone</strong>命令将远程仓库代码拷贝下来，本地代码更新后，通过<strong>push</strong>托送给远程仓库。</li></ul></li></ul><h2 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVX50s"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVX50s.png" alt="jVX50s.png"></a></p><p><strong>master分支</strong></p><ul><li><strong>主分支</strong>，用于<strong>部署生产环境</strong>的分支，确保稳定性。</li><li>master分支一般由develop以及hotfix分支合并，任何情况下都不能直接修改代码。</li></ul><p><strong>develop 分支</strong></p><ul><li>develop为<strong>开发分支</strong>，通常情况下，保存最新完成以及bug修复后的代码。</li><li>开发新功能时，feature分支都是基于develop分支下创建的。</li></ul><p><strong>feature分支</strong></p><ul><li><strong>开发新功能</strong>，基本上以develop为基础创建feature分支。</li><li>分支命名：<strong>feature/ 开头</strong>的为特性分支， 命名规则: feature/user_module、 feature/cart_module。</li></ul><p><strong>release分支</strong></p><ul><li>release 为<strong>预上线分支</strong>，发布提测阶段，会release分支代码为基准提测。</li></ul><p><strong>hotfix分支</strong></p><ul><li><strong>hotfix/</strong> 开头的为<strong>修复分支</strong>，它的命名规则与 feature 分支类似。</li><li>线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支。</li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>有了上述的基本了解后，那么我们就来看看整体的一个流程吧。</p><ul><li><p>创建本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init  </span><br></pre></td></tr></table></figure></li><li><p>链接本地仓库与远端仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add  origin url</span><br><span class="line">origin默认是远端仓库别名  url 可以是可以使用https或者ssh的方式新建</span><br></pre></td></tr></table></figure></li><li><p>检查配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email  &quot;your_email&quot;</span><br></pre></td></tr></table></figure></li><li><p>生成SSH密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;这里换上你的邮箱&quot;</span><br><span class="line">cd ~/.ssh 里面有一个文件名为id_rsa.pub,把里面的内容复制到git库的我的SSHKEYs中</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></li><li><p>常看远端仓库信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li><li><p>远端仓库重新命名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename old new</span><br></pre></td></tr></table></figure></li><li><p>提交到缓存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add . 全部上传到缓存区</span><br><span class="line">git add 指定文件</span><br></pre></td></tr></table></figure></li><li><p>提交到本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;some message&#x27;</span><br></pre></td></tr></table></figure></li><li><p>提交远程仓库/从远程拉取合并</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">git pull origin dev //从远程dev 分支拉取到本地dev 分支  pull=fetch+merge</span><br></pre></td></tr></table></figure></li><li><p>查看分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li><p>创建新分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>切换分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建分支并切换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>删除分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>克隆仓库后切换分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone url //将远程仓库克隆下载到本地</span><br><span class="line">git checkout -b dev origin/dev // 克隆仓库后切换到dev 分支</span><br></pre></td></tr></table></figure></li><li><p>忽略文件 .gitignore</p><p>这个文件的作用，会去忽略一些不需要纳入Git管理这种，我们也不希望出现在未跟踪文件列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此行为注释 会被Git忽略 </span></span><br><span class="line"><span class="comment"># 忽略 node_modules/ 目录下所有的文件 </span></span><br><span class="line">node_modules </span><br><span class="line"><span class="comment"># 忽略所有.vscode结尾的文件 </span></span><br><span class="line">.vscode </span><br><span class="line"><span class="comment"># 忽略所有.md结尾的文件 </span></span><br><span class="line">.md </span><br><span class="line"><span class="comment"># 但README.md 除外 </span></span><br><span class="line">!README.md </span><br><span class="line"><span class="comment"># 会忽略 doc/something.txt 但不会忽略doc/images/arch.txt </span></span><br><span class="line">doc/.txt </span><br><span class="line"><span class="comment"># 忽略 doc/ 目录下所有扩展名为txt文件 </span></span><br><span class="line">doc/**/*.txt</span><br></pre></td></tr></table></figure></li><li><p>文件状态</p><p>通常我们需要查看一个文件的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status </span><br></pre></td></tr></table></figure><ul><li><p><strong>Changes not staged for commit</strong></p><p>大概就是工作区有该内容，但是缓存区没有，需要我们<strong>git add</strong></p></li></ul></li></ul><ul><li><p><strong>Changes to be committed</strong></p><p>这个时候，文件放在缓存区了，我们需要<strong>git commit</strong></p></li></ul><ul><li><p><strong>nothing to commit, working tree clean</strong></p><p>这个时候，我们将本地的代码推送到远端即可</p></li></ul><ul><li><p>查看历史操作记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></li><li><p>查看日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></li><li><p>差异比较</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure></li></ul><h2 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h2><p>GitLens</p><h2 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h2><p>假设我们刚刚完成软件的一个新特性，也许之前一直在特性分支中工作，因此下一步将是将其合并到主线分支(<code>master</code>分支或<code>main</code>分支)。</p><p>在某些情况下，比方说你是项目中唯一的开发人员，或者有足够的经验并确定团队成员不会提出异议，那么直接合并一点问题都没有。</p><p>不过如果代码变更稍微复杂一点，并且希望其他人能够检查这部分工作，该怎么办呢？这就是pull request的目的。有了pull request，可以邀请其他人来评论所作的工作并给出反馈。</p><p>一旦创建了pull request，就可以和其他开发人员讨论相关代码。</p><p>大多数Git托管平台允许其他用户在此过程中添加评论以及提出建议，当评审人员批准后，就可以将其合并到另一个分支中。</p><h2 id="约定式提交-1-0-0"><a href="#约定式提交-1-0-0" class="headerlink" title="约定式提交 1.0.0"></a><a target="_blank" rel="noopener" href="https://www.conventionalcommits.org/zh-hans/v1.0.0/">约定式提交 1.0.0</a></h2><p>提交说明包含了下面的结构化元素，以向类库使用者表明其意图：</p><ol><li><strong>fix:</strong> <em>类型</em> 为 <code>fix</code> 的提交表示在代码库中修复了一个 bug（这和语义化版本中的 <a target="_blank" rel="noopener" href="https://semver.org/lang/zh-CN/#%E6%91%98%E8%A6%81"><code>PATCH</code></a> 相对应）。</li><li><strong>feat:</strong> <em>类型</em> 为 <code>feat</code> 的提交表示在代码库中新增了一个功能（这和语义化版本中的 <a target="_blank" rel="noopener" href="https://semver.org/lang/zh-CN/#%E6%91%98%E8%A6%81"><code>MINOR</code></a> 相对应）。</li><li><strong>BREAKING CHANGE:</strong> 在脚注中包含 <code>BREAKING CHANGE:</code> 或 <code>&lt;类型&gt;(范围)</code> 后面有一个 <code>!</code> 的提交，表示引入了破坏性 API 变更（这和语义化版本中的 <a target="_blank" rel="noopener" href="https://semver.org/lang/zh-CN/#%E6%91%98%E8%A6%81"><code>MAJOR</code></a> 相对应）。 破坏性变更可以是任意 <em>类型</em> 提交的一部分。</li><li>除 <code>fix:</code> 和 <code>feat:</code> 之外，也可以使用其它提交 <em>类型</em> ，例如 <a target="_blank" rel="noopener" href="https://github.com/conventional-changelog/commitlint/tree/master/%40commitlint/config-conventional">@commitlint/config-conventional</a>（基于 <a target="_blank" rel="noopener" href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines">Angular 约定</a>）中推荐的 <code>build:</code>、<code>chore:</code>、 <code>ci:</code>、<code>docs:</code>、<code>style:</code>、<code>refactor:</code>、<code>perf:</code>、<code>test:</code>，等等。</li><li>脚注中除了 <code>BREAKING CHANGE: &lt;description&gt;</code> ，其它条目应该采用类似 <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-interpret-trailers">git trailer format</a> 这样的惯例。</li></ol><p>其它提交类型在约定式提交规范中并没有强制限制，并且在语义化版本中没有隐式影响（除非它们包含 BREAKING CHANGE）。 可以为提交类型添加一个围在圆括号内的范围，以为其提供额外的上下文信息。例如 <code>feat(parser): adds ability to parse arrays.</code>。</p><h2 id="Git-中的撤销"><a href="#Git-中的撤销" class="headerlink" title="Git 中的撤销"></a>Git 中的撤销</h2><p>撤销可能是使用过程中最需要的操作，你可能在任何时候都需要撤销。根据情况不同，撤销的命令也是不同的。</p><h3 id="撤销最近几次-commit"><a href="#撤销最近几次-commit" class="headerlink" title="撤销最近几次 commit"></a>撤销最近几次 commit</h3><p>要撤销最近几次的提交，可以使用 <code>git reset</code>，下面介绍它的三种模式：<code>soft</code>、<code>mixed</code> 和 <code>hard</code>。</p><p>假设目前分支情况如下，我们需要撤销到 <code>98c27</code> commit 上去。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVxvng"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVxvng.png" alt="jVxvng.png"></a></p><p><strong>1）soft 模式</strong></p><p>执行 <code>git reset --soft 98c27</code>，git 会首先修改 HEAD 的指向，它会连带修改 HEAD 所在分支的指向：</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVxXjS"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVxXjS.png" alt="jVxXjS.png"></a></p><p>如上图所示，现在的暂存区和 HEAD 是不同的，这个操作本质上撤销了 <code>2c9be</code> 这个 commit，如同回到了上次准备 commit 的时候。（git 中的时光机！）</p><p>此时你可以进行后悔操作，继续修改文件再 add，然后重新 commit，这时会提交一个新的 commit。</p><p><strong>2）mixed 模式</strong></p><p>回到一开始的时候，假如我们执行的是 <code>git reset --mixed 98c27</code>，它也会首先修改 HEAD 的指向，使得 HEAD 上的 commit 为 <code>98c27</code>。</p><p>但还不够，git 还会接着更新你的暂存区，如同回到了你准备 add 的时候。（时光机再向前！）</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVxL1f"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVxL1f.png" alt="jVxL1f.png"></a></p><p>对你来说可能更方便了，继续改就行，然后重新 add、commit。这实际上是 reset 的默认模式，等同于 <code>git reset 98c27</code>。</p><p><strong>3）hard 模式</strong></p><p>不用我多说你可能已经意识到 hard 是干什么用的了。这一次 git 摧枯拉朽，把你的 HEAD、暂存区、工作区全给干掉了：</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVxI7d"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVxI7d.png" alt="jVxI7d.png"></a></p><p>一下子回到了你开始写需求的时候。所以这个命令是 <strong>危险</strong> 的，除非你真的打算不要这些修改了，否则最好不要用。</p><p>不过即使你真的用了又后悔，那也是有办法的，在 git 里面，既然能回到过去，也能在过去穿越到未来。</p><p>使用 <code>git reflog</code> 可以查看你最近的修改，找到最前面的 commit id，可以继续使用 reset 穿回去。</p><h3 id="合并-commit"><a href="#合并-commit" class="headerlink" title="合并 commit"></a>合并 commit</h3><p>有时候你可能发现自己刚才提交的好几个 commit 其实都是中间状态，还不如把它们合并成一个。</p><p>根据上面的 reset，实际上就能完成这件事情。</p><p>比如下面的场景，我们多提交了一个 File V1.1 的中间版本，希望将其从 commit 历史中去掉：</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVxTAA"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVxTAA.png" alt="jVxTAA.png"></a></p><p>那其实可以直接 reset 到 v1 版本：</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVx4ne"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVx4ne.png" alt="jVx4ne.png"></a></p><p>然后重新进行 commit，这样就会将 v1 之后的修改都提交到了新的版本，如同移除了中间的版本。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVx7tI"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVx7tI.png" alt="jVx7tI.png"></a></p><p>当然，这个场景也能用 rebase 解决，之后会提到。</p><h3 id="挪动-commit"><a href="#挪动-commit" class="headerlink" title="挪动 commit"></a>挪动 commit</h3><p>在多个分支上切换开发的时候，有时候会忘记切换分支就开始开发。</p><p>当发现自己提交的 commit 放错分支怎么办呢？在 git 中，这也不算个事，通过 <code>git cherry-pick</code> 就能解决。</p><p>cherry-pick 可以将指定的 commit “摘到”当前的分支上面，git 会为你重新生成一个 commit，但内容与 pick 的 commit 一致。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVx50H"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVx50H.png" alt="jVx50H.png"></a></p><p>如果你要 pick 好几个 commit，它们之间有依赖关系，那需要根据先后顺序依次进行 cherry pick。</p><p>当发生冲突时，此时需要修改文件解决冲突，可以使用 <code>git cherry-pick --abort</code> 放弃此次 pick，或者解决完 add 进暂存区，然后使用 <code>git cherry-pick --continue</code>。注意这里并不是使用 <code>git commit</code>，如果你需要改变 commit 的信息，可以使用 commit，否则 git 会默认使用 pick 的 commit 的信息。</p><h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>单人基本不会冲突，主要是多人协作，而且对其他人代码或公共代码修改时才会冲突。</p><ul><li><strong>如果不是基于远程库的最新版所做的修改，不能推送，必须先拉取。</strong></li><li>拉取下来后如果进入冲突状态，根据产生冲突的地方检查并修改。</li><li>package-lock.json冲突<ul><li>统一node版本和npm版本(至少统一一个大的版本)，且在需要重新安装依赖的时候，使用npm ci的命令去安装。（强烈推荐,npm ci指的是根据package-lock.json去安装对应的版本，不对这个文件做改动）</li><li>使用git忽略package-lock.json（不推荐，这样子会导致不能根据安装依赖路径去安装包了）</li></ul></li></ul><h1 id="微前端★"><a href="#微前端★" class="headerlink" title="微前端★"></a>微前端★</h1><blockquote><p>考察公司：完美世界</p></blockquote><h2 id="微前端到底是什么？"><a href="#微前端到底是什么？" class="headerlink" title="微前端到底是什么？"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/96464401">微前端到底是什么？</a></h2><p>为了解决庞大的一整块后端服务带来的变更与扩展方面的限制，出现了<strong>微服务架构（Microservices）</strong>：</p><blockquote><p>微服务是面向服务架构（SOA）的一种变体，把应用程序设计成一系列松耦合的细粒度服务，并通过轻量级的通信协议组织起来<br>具体地，将应用构建成一组小型服务。这些服务都能够独立部署、独立扩展，每个服务都具有稳固的模块边界，甚至允许使用不同的编程语言来编写不同服务，也可以由不同的团队来管理。</p></blockquote><p>然而，越来越重的前端工程也面临同样的问题，自然地想到了将微服务思想应用（照搬）到前端，于是有了「微前端（micro-frontends）」的概念：</p><p>一种由独立交付的多个前端应用组成整体的架构风格。具体的，<strong>将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的小块，而在用户看来仍然是内聚的单个产品</strong>。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>简单来讲，微前端的理念类似于微服务。</p><p>将庞大的整体拆成可控的小块，并明确它们之间的依赖关系。关键优势在于：</p><ul><li>代码库更小，更内聚、可维护性更高。</li><li>松耦合、自治的团队可扩展性更好。</li><li><strong>渐进地升级、更新甚至重写部分前端功能成为了可能</strong>。</li></ul><h4 id="简单、松耦合的代码库"><a href="#简单、松耦合的代码库" class="headerlink" title="简单、松耦合的代码库"></a>简单、松耦合的代码库</h4><p>比起一整块的前端代码库，微前端架构下的代码库倾向于更小/简单、更容易开发。</p><p>此外，更重要的是避免模块间不合理的隐式耦合造成的复杂度上升。通过界定清晰的应用边界来降低意外耦合的可能性，增加子应用间逻辑耦合的成本，促使开发者明确数据和事件在应用程序中的流向。</p><h4 id="增量升级"><a href="#增量升级" class="headerlink" title="增量升级"></a>增量升级</h4><p>理想的代码自然是模块清晰、依赖明确、易于扩展、便于维护的……然而，实践中出于各式各样的原因：</p><ul><li>历史项目，祖传代码</li><li>交付压力，当时求快</li><li>就近就熟，当时求稳……</li></ul><p>总存在一些不那么理想的代码：</p><ul><li>技术栈落后，甚至强行混用多种技术栈</li><li>耦合混乱，不敢动，牵一发何止动全身</li><li>重构不彻底，重构-烂尾，换个姿势重构-又烂尾……</li></ul><p>而要对这些代码进行彻底重构的话，<strong>最大的问题是很难有充裕的资源去大刀阔斧地一步到位</strong>，在逐步重构的同时，既要确保中间版本能够平滑过渡，同时还要持续交付新特性。</p><p>所以，为了实施渐进式重构，我们需要一种增量升级的能力，先让新旧代码和谐共存，再逐步转化旧代码，直到整个重构完成。</p><p>这种增量升级的能力意味着我们能够<em>对产品功能进行低风险的局部替换</em>，包括升级依赖项、更替架构、UI 改版等。另一方面，也带来了技术选型上的灵活性，有助于新技术、新交互模式的实验性试错。</p><h4 id="独立部署"><a href="#独立部署" class="headerlink" title="独立部署"></a>独立部署</h4><p>独立部署的能力在微前端体系中至关重要，能够缩小变更范围，进而降低相关风险。</p><p>因此，每个微前端都应具备有自己的持续交付流水线（包括构建、测试并部署到生产环境），并且要能独立部署，不必过多考虑其它代码库和交付流水线的当前状态。</p><p>就算旧的系统是按固定周期季度发布或手动发布的，甚至隔壁团队误发布了一个半成品或有问题的特性也无关紧要。也就是说，如果一个微前端已经准备好发布了，它就应该随时可发布，并且只由开发维护它的团队来定。</p><h4 id="团队自治"><a href="#团队自治" class="headerlink" title="团队自治"></a>团队自治</h4><p>除代码库及发布周期上的解耦之外，微前端还有助于形成完全独立的团队，由不同团队各自负责一块产品功能从构思到发布的整个过程，团队能够完全拥有为客户提供价值所需的一切，从而快速高效地运转。</p><p>为此，<strong>应该围绕业务功能纵向组建团队，而不是基于技术职能划分</strong>。最简单的，可以根据最终用户所能看到的内容来划分，比如将应用中的每个页面作为一个微前端，并交给一个团队全权负责。与基于技术职能或横向关注点（如样式、表单、校验等）组织的团队相比，这种方式能够提升团队工作的凝聚力。</p><h3 id="实现方案-1"><a href="#实现方案-1" class="headerlink" title="实现方案"></a>实现方案</h3><h4 id="多-Bundle-集成"><a href="#多-Bundle-集成" class="headerlink" title="多 Bundle 集成"></a>多 Bundle 集成</h4><p>微前端架构中一般会有个<strong>容器应用（container application）</strong>将各子应用集成起来，职责如下：</p><ul><li>渲染公共的页面元素，比如 header、footer。</li><li>解决横切关注点（cross-cutting concerns），如身份验证和导航。</li><li>将各个微前端整合到一个页面上，并控制微前端的渲染区域和时机。</li></ul><p>集成方式分为 3 类：</p><ul><li>服务端集成：如 SSR 拼装模板。</li><li>构建时集成：如 Code Splitting。</li><li>运行时集成：如通过 iframe、JS、Web Components 等方式。</li></ul><h4 id="服务端集成"><a href="#服务端集成" class="headerlink" title="服务端集成"></a>服务端集成</h4><p>服务端集成的关键在于<em>如何保证各部分模板（各个微前端）能够独立发布</em>，必要的话，甚至可以在服务端也建立一套与前端相对应的结构。</p><p>每个子服务负责渲染并服务于对应的微前端，主服务向各个子服务发起请求。</p><h4 id="构建时集成"><a href="#构建时集成" class="headerlink" title="构建时集成"></a>构建时集成</h4><p>常见的构建时集成方式是将子应用发布成独立的 npm 包，共同作为主应用的依赖项，构建生成一个供部署的 JS Bundle。</p><p>然而，<strong>构建时集成最大的问题是会在发布阶段造成耦合</strong>，任何一个子应用有变更，都要整个重新编译，意味着对于产品局部的小改动也要发布一个新版本，因此，<strong>不推荐这种方式</strong>。</p><h4 id="运行时集成"><a href="#运行时集成" class="headerlink" title="运行时集成"></a>运行时集成</h4><p>将集成时机从构建时推迟到运行时，就能避免发布阶段的耦合。常见的运行时集成方式有：</p><ul><li>iframe</li><li>JS：比如前端路由</li><li>Web Components</li></ul><p>虽然直觉上用 iframe 好像不太好（性能、通信成本等），但在这里确实是个合理选项，因为 iframe 无疑是最简单的方式，还天然支持样式隔离以及全局变量隔离。</p><p>但这种<em>原生的隔离性，意味着很难把应用的各个部分联系到一起</em>，路由控制、历史栈管理、深度链接（deep-linking）、响应式布局等都变得异常复杂，因而限制了 iframe 方案的灵活性。</p><p><strong>另一种最常见的方式是前端路由</strong>，每个子应用暴露出渲染函数，主应用在启动时加载各个子应用的独立 Bundle，之后根据路由规则渲染相应的子应用。目前看来，是<em>最灵活的方式</em>。</p><p>还有一种类似的方式是<a href="https://link.zhihu.com/?target=http://www.ayqy.net/blog/web-components/">Web Components</a>，将每个子应用封装成自定义 HTML 元素（而不是前端路由方案中的渲染函数），以获得<a href="https://link.zhihu.com/?target=http://www.ayqy.net/blog/web-components/%23articleHeader6">Shadow DOM</a>带来的样式隔离等好处。</p><h4 id="影响隔离"><a href="#影响隔离" class="headerlink" title="影响隔离"></a>影响隔离</h4><p>子应用之间，以及子应用与主应用间的样式、作用域隔离是必须要考虑的问题，常见解决方案如下：</p><ul><li>样式隔离：开发规范（如<a href="https://link.zhihu.com/?target=http://www.ayqy.net/blog/bem-block-element-modifier/">BEM</a>）、CSS 预处理（如<a href="https://link.zhihu.com/?target=https://sass-lang.com/">SASS</a>）、模块定义（如<a href="https://link.zhihu.com/?target=https://github.com/css-modules/css-modules">CSS Module</a>）、用 JS 来写（<a href="https://link.zhihu.com/?target=https://mxstbr.com/thoughts/css-in-js/">CSS-in-JS</a>）、以及<a href="https://link.zhihu.com/?target=https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM">shadow DOM</a>特性</li><li>作用域隔离：各种模块定义（如<a href="https://link.zhihu.com/?target=http://www.ayqy.net/blog/es-module/%23articleHeader8">ES Module</a>、<a href="https://link.zhihu.com/?target=http://www.ayqy.net/blog/es-module/%23articleHeader5">AMD</a>、<a href="https://link.zhihu.com/?target=http://www.ayqy.net/blog/es-module/%23articleHeader6">Common Module</a>、<a href="https://link.zhihu.com/?target=http://www.ayqy.net/blog/es-module/%23articleHeader7">UMD</a>）</li></ul><h4 id="资源复用"><a href="#资源复用" class="headerlink" title="资源复用"></a>资源复用</h4><p>资源复用对于 UI 一致性和代码复用有重要意义，但<em>并非所有的可复用资源（如组件）都必须在一开始就提出来复用</em>，建议的做法是前期允许一定程度的冗余，各个 Bundle 在各自的代码库中创建组件，直到形成相对明确的组件 API 时再建立可供复用的公共组件。</p><p>另一方面，资源分为以下 3 类：</p><ul><li>基础资源：完全不含逻辑功能的图标、标签、按钮等。</li><li>UI 组件：含有一定 UI 逻辑的搜索框（如自动完成）、表格（如排序、筛选、分页）等。</li><li>业务组件：含有业务逻辑。</li></ul><p>其中，<strong>不建议跨子应用复用业务组件</strong>，因为会造成高度耦合，增加变更成本。</p><p>对于公共资源的归属和管理，一般有两种模式：</p><ul><li>公共资源归属于所有人，即没有明确归属。</li><li>公共资源归集中管理，由专人负责。</li></ul><p>从实践经验来看，前者很容易衍变成没有明确规范，且背离技术愿景的大杂烩，而后者会造成资源创建和使用的脱节，比较推荐的模式是<em>开源软件的管理模式</em>：</p><p>所有人都能补充公共资源，但要有人（或一个团队）负责监管，以保证质量、一致性以及正确性。</p><h4 id="应用间通信"><a href="#应用间通信" class="headerlink" title="应用间通信"></a>应用间通信</h4><p>通过自定义事件间接通信是一种避免直接耦合的常用方式，此外，React 的单向数据流模型也能让依赖关系更加明确，对应到微前端中，从容器应用向子应用传递数据与回调函数。</p><p>另外，路由参数除了能用于分享、书签等场景外，也可以作为一种通信手段，并且具有诸多优势：</p><ul><li>其结构遵从定义明确的开放标准</li><li>页面级共享，能够全局访问</li><li>长度限制促使只传递必要的少量数据</li><li>面向用户的，有助于依照领域建模</li><li>声明式的，语义上更通用（”this is where we are”, rather than “please do this thing”）</li><li>迫使子应用之间间接通信，而不直接依赖对方</li></ul><p>但原则上，无论采用哪种方式，都应该<em>尽可能减少子应用间的通信</em>，以避免大量弱依赖造成的强耦合。</p><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>每个子应用都应该有自己的全套测试方案，特殊之处在于，除单元测试、功能测试外，还要有<em>集成测试</em>：</p><ul><li>集成测试：保证子应用间集成的正确性，比如跨子应用的交互操作。</li><li>功能测试：保证页面组装的正确性。</li><li>单元测试：保证底层业务逻辑和渲染逻辑的正确性。</li></ul><p>自下而上形成一个金字塔结构，每一层只需验证在其下层覆盖不到的部分即可。</p><h3 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h3><p>当然，这种架构模式并非百益而无一害，一些问题也随之而来：</p><ul><li>导致依赖项冗余，增加用户的流量负担</li><li>团队自治程度的增加，可能会破坏协作</li></ul><h4 id="流量负担"><a href="#流量负担" class="headerlink" title="流量负担"></a>流量负担</h4><p>独立构建意味着公共资源的冗余，继而增加用户的流量负担。</p><p><strong>没有非常理想的解决办法</strong>，一种简单的方案是将公共依赖从（子应用的）构建产物中剔除，但又会引入构建时耦合。</p><h4 id="操作-管理上的复杂性"><a href="#操作-管理上的复杂性" class="headerlink" title="操作/管理上的复杂性"></a>操作/管理上的复杂性</h4><p>在采用微前端之前，先要考虑几个问题：</p><ul><li>现有的前端开发、测试、发布流程如何扩展支持很多个应用？</li><li>分散的，控制弱化的工具体系及开发实践是否可靠？</li><li>针对各式各样的前端代码库，如何建立质量标准？</li></ul><p>总之，与之前不同的是，微前端将产生一堆小的东西，因此需要考虑<em>是否具备采用这种方法所需的技术和组织成熟度</em>。</p><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>类似于微服务之于后端，前端业务在发展到一定规模之后，也需要一种用来分解复杂度的架构模式，于是出现了<em>微服务思想在前端领域的应用，即微前端</em>。主要目的在于：</p><ul><li>技术架构上进一步的扩展性（模块边界清晰、依赖明确）</li><li>团队组织上的自治权</li><li>开发流程上能独立开发、独立交付</li></ul><p>最大的意义在于解锁了<em>多技术栈并存的能力</em>，尤其适用于渐进式重构中架构升级过渡期。</p><p>允许低成本尝试新技术栈，甚至允许选用最合适的技术栈做不同的事情（类似于微服务中允许用不同的语言编写不同服务）。</p><h2 id="微前端的核心价值"><a href="#微前端的核心价值" class="headerlink" title="微前端的核心价值"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/95085796">微前端的核心价值</a></h2><p><strong>我认为微前端的核心价值在于 “技术栈无关”，这才是它诞生的理由，或者说这才是能说服我采用微前端方案的理由。</strong></p><p>我们去统计一下业界关于”微前端“发过声的公司，会发现 adopt 微前端的公司，基本上都是做 <strong>ToB 软件服务</strong>的，没有哪家 ToC 公司会有微前端的诉求（有也是内部的中后台系统），为什么会这样？很简单，因为很少有 ToC 软件活得过 3 年以上的。而对于 ToB 应用而言，3~5 年太常见了好吗！去看看阿里云最早的那些产品的控制台，去看看那些电信软件、银行软件，哪个不是 10 年+ 的寿命？企业软件的升级有多痛这个我就不多说了。所以大部分企业应用都会有一个核心的诉求，就是<strong>如何确保我的遗产代码能平滑的迁移，以及如何确保我在若干年后还能用上时下热门的技术栈？</strong></p><p>不论是 qiankun/OneX(蚂蚁基于qiankun打造的云应用接入平台) 最开始诞生的初衷，还是后续在于社区的交流过程中都发现，如何给遗产项目续命，才是我们对微前端最开始的诉求。阿里的同学们可能感受不深，毕竟那些一年挣不了几百万，没什么价值的项目要么是自己死掉了，要么是扔给外包团队维护了，但是要知道，对很多做 ToB 领域的中小企业而言，这样的系统可能是他们安身立命之本，不是能说扔就扔的，他们承担不了那么高的试错成本。</p><p>我认可的解决思路应该是，撒旦的归撒旦，耶稣的归耶稣。</p><p>我们只需要在主系统构造一个足够轻量的基座，然后让各子应用按照共同的协议去实现即可。这个协议可以包括，主应用应该如何加载子应用，以及子应用如何被主应用感知、调度，应用之间如何通信等。这个协议不应该包括，子应用要如何确保隔离性、安全性，也就是子应用除了实现一些较为简单的协议之外，跟开发一个正常的 spa 应用应该没有任何差别，包括不应该有 开发、构建、发布 等流程上的侵入。只要子应用实现了这几个协议，其他的东西怎么玩，我们都不需要关心或干预。</p><p>这样的话，其实整个系统就变成了一个真正的、基于运行时的插件平台了。</p><p>有一个非常合适的例子，我们通常是怎么看待可视化搭建平台的？我想大部分 pro code 玩家都是不太敢轻易尝试这个方式去开发自己的核心产品的，原因是什么呢？很简单，不可控。我的产品的上限由平台决定而不是我自己的 coding 能力决定，这就很要命了。尤其是一些核心模块，后面我想做一些个性性的改造可能都支持不了。但是如果有了微前端机制呢，只需要搭建平台去实现相关的协议，平台产出的页面就能很轻易的被集成到我们自己的应用里了。我们开发时可以选择需要强控制的页面自己写，边缘页面用可视化生成即可，完全没有任何心理负担。</p><p>我们听到了很多不同团队的分享中，关于微前端带来的各种业务提升、产品提升的价值。比如产品的自由组合能力，比如以 widget 这种可视化方式直接输出产品的能力等等，将这些价值视作微前端诞生的理由。</p><p>但我对此一直保持的观点是，<strong>微前端首先解决的，是如何解构巨石应用</strong>，从而解决巨石应用随着技术更迭、产品升级、人员流动带来的工程上的问题。解构之后还需要再重组，重组的过程中我们就会碰到各种 隔离性、依赖去重、通信、应用编排 等问题。在解决了这些问题之后，才是产品的自由组合、widget 输出等能力。同时由于有了前者能力的铺垫和加持，这些产品上的价值提升也就变得很自然和容易。</p><p>不论是 OneX 还是阿里云的同学，都在反复强调微前端带来的业务价值及产品价值，比如产品的组合能力，widget 的产品输出能力（<strong>这些能力在我们的产品域确实很重要也很有价值，但并不是所有的控制台产品都一定需要的能力</strong>）。从分享中我们也能看到，云产品对于微前端的诉求是基本相同的，包括背后的 管控、编码 能力等。但我们需要清楚一件事，并不是只有云产品才需要微前端，也并不是所有采用微前端方案的公司都是做云产品的。</p><p>大果提的问题非常我认为有探讨价值：「widget 级别的微前端应用跟业务组件有什么区别？」</p><p><strong>我的观点：有没有区别在于你的实现是不是技术栈无关。</strong></p><p>以大果提到的淘宝吊顶 js 为例（这是一个非常贴切的举例，蚂蚁也有类似的 js 组件），它具备独立发布、固定地址自动升级等特点，我猜也不会限制调用方的技术栈，调用方使用时跟用一个普通的 library 一样，区别在于普通的 library 是通过 npm 包引入，但是这个 library 我们是通过 <code>script</code> 标签引入的。</p><p>但是考察是否技术栈无关不能简单看这些 api 设计，还要看是否存在一些隐性耦合。</p><p>比如是否要求调用方的 react 版本、是否要求调用方必须提前构造好一些上下文环境才能完成调用。</p><p>如果这些回答都是否，那么我认为这也是一种微前端的实现方式。</p><p>克军提到：</p><blockquote><p>如果微前端只存在工程上的价值是不值得大张旗鼓去做的。</p></blockquote><p>微前端的初衷应该还是来解决工程问题的，带来的产品价值在不同的领域可大可小。 比如在阿里云这种典型的云产品控制台的场景下，它带来的产品价值就会很可观。因为阿里云作为提供 IAAS 服务的云平台，它需要的就是平台、产品的被集成能力，在这种场景下，微前端能力能非常好的契合这个诉求。但需要强调的是，并不是所有采用微前端的客户，都是阿里云这种 IAAS 平台产品。很多中小型控制台大多没有产品自由组合能力的诉求。产品能力只能算是微前端的能力的一种延伸。</p><p>玉伯提到：</p><blockquote><p>今天看各 BU 的业务问题，微前端的前提，还是得有主体应用，然后才有微组件或微应用，解决的是可控体系下的前端协同开发问题（含空间分离带来的协作和时间延续带来的升级维护）</p></blockquote><p>总结的很精确。「空间分离带来的协作问题」是在一个规模可观的应用的场景下会明显出现的问题，而「时间延续带来的升级维护」几乎是所有年龄超过 3 年的 web 应用都会存在的问题。</p><p>既然「技术栈无关」是微前端的核心价值，那么整个架构方案的实现上，都应该秉持这一原则，任何违背这一原则的做法都应该被摒弃。</p><p>「技术栈无关」是架构上的准绳，具体到实现时，对应的就是：<strong>应用之间不应该有任何直接或间接的技术栈、依赖、以及实现上的耦合。</strong></p><p>比如我们不能要求子应用、主应用必须使用某一版本的技术栈实现。</p><p>比如在通信机制的设计与选择上，尽量基于浏览器原生的 CustomEvent api，而不是自己搞的 pub/sub。</p><p>比如子应用是否具备不依赖宿主环境独立运行的能力，衡量标准是是否能一行代码不改，或者只改很少的配置，就能达成这一目标。</p><p>所以我认为正确的微前端方案的目标应该是：方案上跟使用 iframe 做微前端一样简单，同时又解决了 iframe 带来的各种体验上的问题。</p><p>理想状态下，以此为目标的微前端应用，是自动具备流通能力的，且这个流通能力不会因为主应用的实现升级而丧失（也就是说在 19 年能接入主应用的微前端应用，到了 2025 年也应该能正常接入正常运行，并同样保有在不同主应用间流通的能力）。</p><p><a href="https://link.zhihu.com/?target=https://github.com/umijs/qiankun">qiankun</a> 正是以此为准则设计的。</p><p>如果说阿里的企业使命是：「让天下没有难做的生意」。</p><p>那么微前端的使命我认为是：「<strong>让天下没有短命的控制台</strong>」。</p><blockquote><p><strong>事实上如果所有的 web 技术栈能做到统一，所有 library 的升级都能做到向下兼容，我们确实就不需要微前端了。</strong></p></blockquote><h2 id="steamer"><a href="#steamer" class="headerlink" title="steamer"></a>steamer</h2><h3 id="前端行业当下面临的规模问题"><a href="#前端行业当下面临的规模问题" class="headerlink" title="前端行业当下面临的规模问题"></a>前端行业当下面临的规模问题</h3><ul><li><p>表现：<strong>更大规模的前端代码</strong>（数百 KB -&gt; 数十 MB，几十模块 -&gt; 数万的模块）</p></li><li><p>组织形态：<strong>更专业细分的分工</strong>（组件库、数据可视化、图表、VR、工程化…）</p></li></ul><p><strong>现有的前端研发模式</strong></p><p>一个项目包含整体功能、作为开发、测试、发布的最小粒度 （PS: 虽然也有部分解决方案可以将项目中局部功能动态切换，但仍耦合在项目中）</p><p><strong>在巨大规模下，人和机器都可能遇到瓶颈</strong></p><ul><li><p>机器</p><ul><li><p>编译过慢，甚至可能 OOM</p></li><li><p>发布时间长</p></li><li><p>编译产物大，对于用户浏览器压力大（加载慢，白屏多）</p></li><li><p>…</p></li></ul></li><li><p>人</p><ul><li><p>功能实现中代码耦合多，难以协作，维护困难</p></li><li><p>代码规模大，关联问题定位困难</p></li><li><p>…</p></li></ul></li></ul><p>SaaS 业务特点是：</p><ul><li><p><strong>用标准化产品难以满足碎片化需求，大KA跟中小企业需求是割裂的；</strong></p></li><li><p><strong>周期长，真实需求需要深入探索，改动多；</strong></p></li></ul><p>在 SaaS 业务特点下，带来的终端技术<strong>问题</strong>是：</p><ul><li>定制化需求多，没有沉淀之前，很难去复用相关能力，但沉淀需要时间积累跟验证；</li><li>业务需求开发压力大，一波又一波的业务需求导致开发埋头干活，不能抬头看路；</li><li>需求改变多且不可抗力，团队的成就感缺失；</li></ul><p>参照现实的工厂作业方式，建立属于前端研发领域的<strong>流水线作业研发流程，核心体现在三点：</strong></p><ol><li><p><strong>标准化开发</strong></p></li><li><p><strong>标准化品控</strong></p></li><li><p><strong>自动化测试</strong></p></li></ol><p>我们认为<strong>微前端</strong>的思想作为当下环境中前端 “工业化” 的基础概念是比较匹配的，可以作为下一个阶段前端工程化的建设重点。</p><p>同时常规的前端工程化以及微前端的框架等主要关注在前端项目的开发以及运行环节，在整体研发流程衔接等关注和着力点有限，所以还需要结合 <strong>DevOps</strong> 理念。</p><h3 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h3><p><strong>一个中大型项目</strong> = <strong>多个独立功能模块组合</strong></p><p>趋势：整体项目集中式 -&gt; 项目内组件化 -&gt; 独立组件化</p><ul><li><p>更快的页面加载速度</p><ul><li><p>所有业务 vendor + 一个业务异步chunk vs 宿主容器 + 一个业务模块的依赖；</p></li><li><p>举例：进入首页时可能不需要加载 echart</p></li></ul></li><li><p>更小规模的前端代码，维护成本更低</p><ul><li>大型项目 -&gt; 一组小型模块（数十 MB -&gt; 数百 KB，数万的模块 -&gt; 几十模块）</li></ul></li><li><p>更专业的分工，支持多个团队并行开发多个独立维护的模块</p><ul><li>例如（订单管理、仓储管理、人员管理… 等功能模块分离，独立维护）</li></ul></li></ul><p><strong>微前端结合 DevOps 的一站式研发解决方案是不错的选择</strong></p><p><strong>微前端 = 研发标准 + 研发工具 + 微前端框架 + 研发平台</strong></p><p><strong>DevOps = 持续集成 + 质量管控 + 版本产物 + 发布工具 +运营工具</strong></p><p><strong>微前端 + DevOps = Steamer</strong></p><p>终端端研发方案 + 终端端研发流程平台 = 一站式研发解决方案</p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>应用：</strong></p><p>一个应用对应一个<strong>单页应用（SPA）</strong>，如一个运营后台系统就是一个应用。</p><p><strong>业务模块：</strong></p><p>一个业务模块相当于单页应用中的一个页面（目前是<strong>页面</strong>，以后可能会细化成为页面中的<strong>组件</strong>）。</p><p>是 Steamer 中的最小单元，它可以独立迭代发布。基本形态是一个组件，对标 React/Vue 等主流框架中的组件。</p><p>由于组件的灵活度范围较大，在业务可以根据业务场景扩展支持子应用（多页面）、单一路由页面、局部组件 3 种场景。</p><p>业务模块在平台中独立存在，所以在<strong>代码隔离</strong>和组织形态上可以有比较高的灵活度：</p><ul><li>业务模块独立 Git</li><li>按照业务相关程度多个业务模块再统一 Git</li></ul><p>微前端方案中的基本独立维护单元，可以是业务组件、页面路由或者是一个独立子应用；一般推荐粒度为页面路由。</p><p><strong>服务模块（Service）：</strong></p><p>在一个业务模块中可能会使用到一些公共的业务组件或者公共方法，由于这些组件和方法可能并不会被所有的业务模块所引用，在steamer的技术框架中，它们就被抽象成了一个个的服务模块来被业务模块引用。</p><p>简而言之，<strong>服务模块是被部分业务模块所共用的组件、方法等</strong>。</p><p><strong>宿主容器模板（简称模板）：</strong></p><p><strong>宿主模板对业务模块进行路由管理，并提供业务模块间共享的功能。</strong></p><p><strong>宿主容器</strong> 作为承载业务模块的容器（类似于 App与操作系统），我们将 <strong>宿主容器</strong>分为两个部分，Container 是提供基础 UI 布局、前端框架、路由等基础现代前端应用的视图骨架容器；Runtime 是一个动态组件执行和挂载的渲染执行 SDK，内部也会集成模块网络通信、数据存储 API、性能和异常监控、执行沙盒隔离等基础能力。</p><p><strong>Steamer DevOps</strong></p><p>是一个通过线上化、标准化和自动化手段来串联终端研发过程的终端DevOps工作台，目标用户包括餐饮SaaS技术部终端研发者、业务需求技术主R、团队管理者等。</p><p><strong>功能特点：</strong></p><ul><li><p><strong>线上化：</strong> 团队研发流程线上化，所用即最新；</p></li><li><p><strong>标准化：</strong> 通过应用类型收敛相似架构的应用的研发流程，统一采用一套标准化的研发流程进行业务推进；</p></li><li><p><strong>自动化：</strong> 研发流程中的动作尽可能自动化执行，提高推进效率。</p></li></ul><p>Steamer 平台的流水线引擎基于 Talos 开发，在上层设计了灵活的插件系统和更加灵活的流程控制和数据回收能力，基于这套插件系统提供了针对微前端模块、组件库、MRN（规划中）等场景的支持。</p><p>其中集成式的<strong>质量管控</strong>和<strong>产物标准化</strong>是 Steamer 流水线的主要特性。</p><ul><li><strong>质量管控：</strong> 我们针对微前端场景，定制了由 ESLint 规范、依赖分析、代码分析组成的<strong>SteamerLint</strong> 前端代码质量分析阶段，可以从安全性、最佳实践、重复度等多个维度统计，分析每一个业务模块的代码质量数据，并可以支持从个人、团队、项目维护分析。（vscode插件：Prettier ESLint）</li><li><strong>产物标准化：</strong> 通过标准发布工具 CLI 与发布环节，实现业务模块的每一次构建产物都会被标记符合 semver 规范的唯一版本，这些版本产物将在 ABtest、灰度、回滚等分发环节作为精确编排控制的基础。</li></ul><h3 id="微前端模式仍然存在挑战"><a href="#微前端模式仍然存在挑战" class="headerlink" title="微前端模式仍然存在挑战"></a>微前端模式仍然存在挑战</h3><ul><li><p>管理成本</p><ul><li><p>一个项目 vs 多个模块（子项目）</p><ul><li>git 仓库、开发文档、talos 发布项</li></ul></li></ul></li><li><p>建设成本</p><ul><li><p>微前端方案</p><ul><li><p>开发：微前端化如何与现有开发模式兼容</p></li><li><p>发布：模块粒度独立迭代后，如何做好版本控制</p></li><li><p>运行：</p><ul><li><p>动态模块如何做到安全隔离</p></li><li><p>依赖重复</p></li></ul></li></ul></li></ul></li></ul><h1 id="请求封装★"><a href="#请求封装★" class="headerlink" title="请求封装★"></a>请求封装★</h1><blockquote><p>考察公司：小米</p></blockquote><p>列一下我想要这个通用请求能达到什么样的效果</p><ul><li><p>正常请求该有的（<strong>跨域携带cookie，token，超时设置</strong>）</p></li><li><p>请求响应拦截器</p><ul><li><p>请求成功，业务状态码200，解析result给我，我不想一层一层的去判断拿数据</p></li><li><p><strong>http请求200， 业务状态码非200，说明逻辑判断这是不成功的，那就全局message提示服务端的报错</strong></p></li><li><p><strong>http请求非200， 说明http请求都有问题，也全局message提示报错</strong></p></li><li><p>http请求或者业务状态码<code>401</code>都做<strong>注销</strong>操作</p></li></ul></li><li><p>全局的loading配置, 默认开启，可配置关闭（由于后端的问题，经常会让前端加防抖节流或者loading不让用户在界面上疯狂乱点，行吧行吧，你们的问题前端帮你们解决，你的规矩就是规矩是吧）</p></li><li><p>统一文件下载处理 （不要再去各写各的下载了，你写一个，他写一个，一个项目就是这样整的跟屎一样）</p></li></ul><h2 id="index-tsx"><a href="#index-tsx" class="headerlink" title="index.tsx"></a>index.tsx</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @FilePath: /e.data-product-steamer-client/packages/service-request/src/request/index.tsx</span></span><br><span class="line"><span class="comment"> * @Description: 请求封装：axios 全局loading 下载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> axios, &#123; AxiosInstance, AxiosRequestConfig, AxiosResponse &#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; downloadFile &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.less&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; message, Loading &#125; = <span class="built_in">window</span>.steamer.services.mtd</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Config <span class="keyword">extends</span> AxiosRequestConfig &#123;</span><br><span class="line">  loading?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Response <span class="keyword">extends</span> AxiosResponse &#123;</span><br><span class="line">  <span class="attr">config</span>: Config</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前正在请求的数量</span></span><br><span class="line"><span class="keyword">let</span> requestCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示loading</span></span><br><span class="line"><span class="keyword">const</span> addLoading = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  requestCount++</span><br><span class="line">  <span class="comment">// requestCount为1，才创建loading, 避免重复创建</span></span><br><span class="line">  <span class="keyword">if</span> (requestCount === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    dom.setAttribute(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;loading&#x27;</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(dom)</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Loading</span> <span class="attr">direction</span>=<span class="string">&quot;vertical&quot;</span> <span class="attr">message</span>=<span class="string">&quot;正在加载中&quot;</span> <span class="attr">size</span>=<span class="string">&quot;normal&quot;</span> /&gt;</span></span>,</span><br><span class="line">      dom,</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏loading</span></span><br><span class="line"><span class="keyword">const</span> hideLoading = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> loading = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;loading&#x27;</span>)</span><br><span class="line">  requestCount--</span><br><span class="line">  <span class="comment">// 取消loading 如果pending请求数量等于0，关闭loading</span></span><br><span class="line">  <span class="keyword">if</span> (requestCount === <span class="number">0</span> &amp;&amp; loading) &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(loading)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createAxiosByinterceptors = (</span><br><span class="line">  config?: AxiosRequestConfig,</span><br><span class="line">): <span class="function"><span class="params">AxiosInstance</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    <span class="comment">// timeout: 1000, //超时配置</span></span><br><span class="line">    <span class="comment">// withCredentials: true,  //跨域携带cookie</span></span><br><span class="line">    ...config, <span class="comment">// 自定义配置覆盖基本配置</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加请求拦截器</span></span><br><span class="line">  instance.interceptors.request.use(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">config: Config</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">      <span class="comment">//  显示loading</span></span><br><span class="line">      <span class="keyword">const</span> &#123; loading = <span class="literal">true</span> &#125; = config</span><br><span class="line">      <span class="keyword">if</span> (loading) addLoading()</span><br><span class="line">      <span class="comment">// console.log(&#x27;config:&#x27;, config)</span></span><br><span class="line">      <span class="keyword">return</span> config</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// function (error) &#123;</span></span><br><span class="line">    <span class="comment">//   // 对请求错误做些什么</span></span><br><span class="line">    <span class="comment">//   return Promise.reject(error)</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加响应拦截器</span></span><br><span class="line">  instance.interceptors.response.use(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">response: Response</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">      <span class="comment">// 隐藏loading</span></span><br><span class="line">      <span class="keyword">const</span> &#123; loading = <span class="literal">true</span> &#125; = response.config</span><br><span class="line">      <span class="keyword">if</span> (loading) hideLoading()</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;response:&#x27;</span>, response)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// const &#123; code, data, msg, message: errormsg &#125; = response.data</span></span><br><span class="line">      <span class="comment">// config设置responseType为blob 处理文件下载</span></span><br><span class="line">      <span class="keyword">if</span> (response.data <span class="keyword">instanceof</span> Blob) &#123;</span><br><span class="line">        <span class="keyword">return</span> downloadFile(response)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.data?.code === <span class="number">0</span> || response.data?.code === <span class="number">17</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response.data?.data</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        message.error(&#123; <span class="attr">message</span>: response.data?.msg || response.data?.message &#125;)</span><br><span class="line">        <span class="comment">// return Promise.reject(response.data)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">      <span class="keyword">const</span> &#123; loading = <span class="literal">true</span> &#125; = error.config</span><br><span class="line">      <span class="keyword">if</span> (loading) hideLoading()</span><br><span class="line">      <span class="comment">// console.log(&#x27;error-response:&#x27;, error.response)</span></span><br><span class="line">      message.error(&#123; <span class="attr">message</span>: error.message || <span class="string">&#x27;服务端异常&#x27;</span> &#125;)</span><br><span class="line">      <span class="comment">// return Promise.reject(error)</span></span><br><span class="line">    &#125;,</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="index-less"><a href="#index-less" class="headerlink" title="index.less"></a>index.less</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#loading</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// background: rgba(231, 231, 231, 0.25);</span></span><br><span class="line">    <span class="attribute">background</span>: transparent;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">9999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @FilePath: /e.data-product-steamer-client/packages/service-mtd/src/request/utils/index.ts</span></span><br><span class="line"><span class="comment"> * @Description: 下载文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AxiosResponse &#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; saveAs &#125; <span class="keyword">from</span> <span class="string">&#x27;file-saver&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; message &#125; = <span class="built_in">window</span>.steamer.services.mtd</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> downloadFile = (response: AxiosResponse): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;response.data.type:&#x27;</span>, response.data.type)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fileReader = <span class="keyword">new</span> FileReader()</span><br><span class="line">    fileReader.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;result:&#x27;</span>, <span class="built_in">this</span>.result)</span><br><span class="line">        <span class="keyword">const</span> jsonData = <span class="built_in">JSON</span>.parse((<span class="built_in">this</span> <span class="keyword">as</span> <span class="built_in">any</span>).result) <span class="comment">// 成功 说明是普通对象数据</span></span><br><span class="line">        <span class="built_in">console</span>.log(jsonData)</span><br><span class="line">        <span class="keyword">if</span> (jsonData?.code !== <span class="number">200</span>) &#123;</span><br><span class="line">          message.error(&#123; <span class="attr">message</span>: jsonData?.msg ?? <span class="string">&#x27;请求失败&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line">          reject(jsonData)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 解析成对象失败，说明是正常的文件流</span></span><br><span class="line">        <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([response.data])</span><br><span class="line">        <span class="comment">// 本地保存文件</span></span><br><span class="line">        <span class="comment">// const url = URL.createObjectURL(blob);</span></span><br><span class="line">        <span class="comment">// const link = document.createElement(&quot;a&quot;);</span></span><br><span class="line">        <span class="comment">// link.href = url;</span></span><br><span class="line">        <span class="keyword">const</span> filename = response?.headers?.[<span class="string">&#x27;content-disposition&#x27;</span>]</span><br><span class="line">          ?.split(<span class="string">&#x27;filename*=&#x27;</span>)?.[<span class="number">1</span>]</span><br><span class="line">          ?.substr(<span class="number">7</span>)</span><br><span class="line">        <span class="comment">// link.setAttribute(&quot;download&quot;, decodeURI(filename));</span></span><br><span class="line">        <span class="comment">// document.body.appendChild(link);</span></span><br><span class="line">        <span class="comment">// link.click();</span></span><br><span class="line">        <span class="comment">// resolve(response.data);</span></span><br><span class="line">        <span class="comment">// URL.revokeObjectURL(url) // 下载完成释放URL 对象</span></span><br><span class="line">        <span class="comment">// document.body.removeChild(link)// 移除a标签</span></span><br><span class="line">        saveAs(blob, filename)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fileReader.readAsText(response.data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装请求"><a href="#封装请求" class="headerlink" title="封装请求"></a>封装请求</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @FilePath: /e.data-product-steamer-client/packages/mbr-frontpages/src/api/index.ts</span></span><br><span class="line"><span class="comment"> * @Description: 请求方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// import &#123; createAxiosByinterceptors &#125; from &quot;./request&quot;;</span></span><br><span class="line"><span class="keyword">const</span> &#123; createAxiosByinterceptors &#125; = <span class="built_in">window</span>.steamer.services.request</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = createAxiosByinterceptors(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;/api/v1/m/mbr&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 请求方法：获取节点目录接口 get</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reqNodeTree = (): <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt; =&gt; request.get(<span class="string">&#x27;/node/tree&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 请求方法：页面数据详情接口 post</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">month</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">pageId</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reqPageDataDetails = (</span><br><span class="line">  month: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">pageId</span>: <span class="built_in">number</span>,</span><br><span class="line">): <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt; =&gt;</span><br><span class="line">  request.post(</span><br><span class="line">    <span class="string">&#x27;/page/data/details&#x27;</span>,</span><br><span class="line">    &#123; month, pageId &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">onUploadProgress</span>: <span class="function">(<span class="params">progress: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;progress&#x27;</span>, progress)</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">          <span class="string">&#x27;progress2&#x27;</span>,</span><br><span class="line">          ((progress.loaded / progress.total) * <span class="number">100</span>).toFixed(),</span><br><span class="line">        )</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 请求方法：数据解读（卡片）接口 post</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">pageId</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">cardId</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">format</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">month</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">textContent</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">updateTime</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reqPageDataExplainCard = (</span><br><span class="line">  pageId: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">cardId</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">month</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">textContent</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">updateDataTime</span>: <span class="built_in">string</span>,</span><br><span class="line">): <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt; =&gt;</span><br><span class="line">  request.post(</span><br><span class="line">    <span class="string">&#x27;/page/data/explain/card&#x27;</span>,</span><br><span class="line">    &#123; pageId, cardId, month, textContent, updateDataTime &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loading</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 请求方法：页面数据下载接口 get</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">month</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reqPageDataDownload = (month: <span class="built_in">number</span>): <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt; =&gt;</span><br><span class="line">  request.get(<span class="string">&#x27;/page/data/download&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123; month &#125;,</span><br><span class="line">    <span class="attr">loading</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// responseType: &#x27;blob&#x27;,</span></span><br><span class="line">    <span class="attr">onDownloadProgress</span>: <span class="function">(<span class="params">progress: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;progress&#x27;</span>, progress)</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">&#x27;下载进度&#x27;</span>,</span><br><span class="line">        ((progress.loaded / progress.total) * <span class="number">100</span>).toFixed(),</span><br><span class="line">      )</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 请求方法：Excel文件信息列表 get</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reqPageDataExcelList = (): <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt; =&gt;</span><br><span class="line">  request.get(<span class="string">&#x27;/page/data/excel/list&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="发请求"><a href="#发请求" class="headerlink" title="发请求"></a>发请求</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取页面数据</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> getPageDataDetails = <span class="keyword">async</span> (</span><br><span class="line">      month: <span class="built_in">number</span>,</span><br><span class="line">      <span class="attr">pageId</span>: <span class="built_in">number</span>,</span><br><span class="line">    ): <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt; =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result: IResult = <span class="keyword">await</span> reqPageDataDetails(month, pageId)</span><br><span class="line">      <span class="comment">// result.userMis=[&#x27;xxggx&#x27;,&#x27;ghchg&#x27;]</span></span><br><span class="line">      <span class="comment">//   console.log(&#x27;pagedetails:&#x27;, result)</span></span><br><span class="line">      <span class="keyword">if</span> (result.userMis) &#123;</span><br><span class="line">        setPermission(<span class="string">&#x27;1001&#x27;</span>)</span><br><span class="line">        setUserMis(result.userMis)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setData(result)</span><br><span class="line">        setPermission(result.authority)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mth &amp;&amp; id) &#123;</span><br><span class="line">      getPageDataDetails(<span class="built_in">parseInt</span>(mth.replace(<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;&#x27;</span>)), <span class="built_in">parseInt</span>(id))</span><br><span class="line">      <span class="comment">// getPageDataDetails(202206, 1)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [mth, id])</span><br></pre></td></tr></table></figure><h2 id="全局loading"><a href="#全局loading" class="headerlink" title="全局loading"></a>全局loading</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.loading-page &#123;</span><br><span class="line">    <span class="attr">position</span>: fixed;</span><br><span class="line">    top: <span class="number">0</span>;</span><br><span class="line">    left: <span class="number">0</span>;</span><br><span class="line">    right: <span class="number">0</span>;</span><br><span class="line">    bottom: <span class="number">0</span>;</span><br><span class="line">    background: rgba(<span class="number">231</span>, <span class="number">231</span>, <span class="number">231</span>, <span class="number">0.25</span>);</span><br><span class="line">    <span class="comment">// background: transparent;</span></span><br><span class="line">    display: flex;</span><br><span class="line">    align-items: center;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    z-index: <span class="number">9999</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; Loading &#125; = <span class="built_in">window</span>.steamer.services.mtd</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> GlobalLoading: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;loading-page&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Loading</span> <span class="attr">direction</span>=<span class="string">&quot;vertical&quot;</span> <span class="attr">message</span>=<span class="string">&quot;正在加载中&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> GlobalLoading</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">false</span>)</span><br><span class="line">setLoading(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">const</span> result: IResult = <span class="keyword">await</span> reqPageDataDetails(month, pageId)</span><br><span class="line">setPageData(result)</span><br><span class="line"><span class="function"><span class="title">setLoading</span>(<span class="params"><span class="literal">false</span></span>)</span></span><br><span class="line">&#123;loading &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">GlobalLoading</span> /&gt;</span></span>&#125;      </span><br><span class="line">      </span><br></pre></td></tr></table></figure><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="概要-2"><a href="#概要-2" class="headerlink" title="概要"></a>概要</h2><h3 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h3><p>官方解释一点就是 : 模式是一种可复用的解决方案，用于解决软件设计中遇到的常见问题。</p><p>说白了，就是<strong>套路</strong>，举个 🌰，我们玩<code>贪玩蓝月</code>，你第一关用了半小时，第二关用了一小时，第三关用了两小时….</p><p>好了，你最强，你花了一个月练到了满级，于是你开始练第二个号，这时候呢，其实你已经知道，每一关的捷径、好的装备在哪里，所以你按照这个<code>套路</code>，很快的，20 天又练满了一个号。</p><p>身边有好友问你怎么这么快的又练了一个号，于是你为了造福大众，你写了一本 <code>闯关攻略</code> ~</p><p>我举的这个例子，你应该知道，什么是设计模式了吧？引用修言老哥的一句话 : <em>烹饪有菜谱，游戏有攻略，干啥都有一些能够让我们达到目标的“套路”，在程序世界，编程的“套路”就是设计模式。</em></p><p>当然，如果真要给你个定义 : 我认为，设计模式就是在软件设计、开发过程中，针对特定问题、场景的更优解决方案。</p><h3 id="为什么会有设计模式？"><a href="#为什么会有设计模式？" class="headerlink" title="为什么会有设计模式？"></a>为什么会有设计模式？</h3><p>就还是上边的 🌰，鲁迅先生说过 : “希望是本无所谓有，无所谓无的。这正如地上的路；其实地上本没有路，走的人多了，也便成了路”，设计模式是前辈们针对开发中遇到的问题，提出大家公认且有效的解决方案。</p><h3 id="为什么需要设计模式？"><a href="#为什么需要设计模式？" class="headerlink" title="为什么需要设计模式？"></a>为什么需要设计模式？</h3><p>可能有小伙伴确实没有用过，或者说用了但不知道这就是设计模式。那么为什么我们需要呢？是因为在我们遇到相似的问题、场景时，能快速找到更优的方式解决</p><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><p>在 JS 设计模式中，<strong>最核心的思想——封装变化</strong>，怎么理解，比如我们写一个东西，这个东西在初始 <code>v1.0</code> 的时候是这 B 样，到了 <code>v5.0</code>、<code>v10.0</code> 甚至 <code>v99.0</code>、<code>v100.0</code> 还是这 B 样，那 ojbk，你爱怎么写就怎么写，你只要实现就可以了。</p><blockquote><p>设计模式的核心操作是去观察你整个逻辑里面的变与不变，然后将变与不变分离，达到使变化的部分灵活、不变的地方稳定的目的。</p></blockquote><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>我们先来做一个题，很简单的，大家肯定都做过 <code>权限逻辑</code> 判断吧？</p><p><strong>需求 : 只用当用户满足以下条件（掘金用户、掘金等级大于 1 级、前端开发、吃瓜群众），才能看阿宽的这篇文章</strong></p><p>给大家 <code>3min</code>，代码怎么写？ <strong>“ 呵，你这不是看不起老夫吗？老夫拿起键盘，就是 <code>if-else</code> 梭哈，直接带走，下一个 ! ”</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAuth</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data.role !== <span class="string">&#x27;juejin&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;不是掘金用户&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (data.grade &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;掘金等级小于 1 级&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (data.job !== <span class="string">&#x27;FE&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;不是前端开发&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (data.type !== <span class="string">&#x27;eat melons&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;不是吃瓜群众&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信这段代码，大家都会写，那么这么写，有什么问题 ？</p><ul><li>checkAuth 函数会爆炸 💥</li><li>策略项无法复用</li><li>违反开闭原则（不知道开放封闭原则的自行百度）</li></ul><p>聪明的小伙伴已经知道这里要讲的是什么模式了，对头！这里讲的就是 <code>策略模式</code>。那么什么是策略模式呢 ？</p><h4 id="策略模式-1"><a href="#策略模式-1" class="headerlink" title="策略模式"></a>策略模式</h4><p>定义 : 要实现某一个功能，有多种方案可以选择。我们定义策略，把它们一个个封装起来，并且使它们可以相互转换。</p><p><strong>策略 + 组合，绝配啊，老哥！</strong></p><p>我们用策略模式来改造以下这段逻辑 👇</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 维护权限列表</span></span><br><span class="line"><span class="keyword">const</span> jobList = [<span class="string">&#x27;FE&#x27;</span>, <span class="string">&#x27;BE&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略</span></span><br><span class="line"><span class="keyword">var</span> strategies = &#123;</span><br><span class="line">  <span class="attr">checkRole</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value === <span class="string">&#x27;juejin&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">checkGrade</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">checkJob</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jobList.indexOf(value) &gt; <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">checkEatType</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value === <span class="string">&#x27;eat melons&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们已经写完了策略，接下来要做的就是验证了~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 校验规则</span></span><br><span class="line"><span class="keyword">var</span> Validator = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.cache = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加策略事件</span></span><br><span class="line">  <span class="built_in">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">value, method</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.cache.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategies[method](value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查</span></span><br><span class="line">  <span class="built_in">this</span>.check = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.cache.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> valiFn = <span class="built_in">this</span>.cache[i];</span><br><span class="line">      <span class="keyword">var</span> data = valiFn(); <span class="comment">// 开始检查</span></span><br><span class="line">      <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时，小彭同学需要进行权限验证的条件为 :</p><ul><li>掘金用户</li><li>掘金等级 1 级以上</li></ul><p>那么代码就可以这么写 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小彭使用策略模式进行操作</span></span><br><span class="line"><span class="keyword">var</span> compose1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> validator = <span class="keyword">new</span> Validator();</span><br><span class="line">  <span class="keyword">const</span> data1 = &#123;</span><br><span class="line">    <span class="attr">role</span>: <span class="string">&#x27;juejin&#x27;</span>,</span><br><span class="line">    <span class="attr">grade</span>: <span class="number">3</span></span><br><span class="line">  &#125;;</span><br><span class="line">  validator.add(data1.role, <span class="string">&#x27;checkRole&#x27;</span>);</span><br><span class="line">  validator.add(data1.grade, <span class="string">&#x27;checkGrade&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> result = validator.check();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后另一个小伙伴阿宽，他可能需要进行权限验证的条件为 :</p><ul><li>掘金用户</li><li>前端工程师</li></ul><p>那么代码就可以这么写 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阿宽使用策略模式进行操作</span></span><br><span class="line"><span class="keyword">var</span> compose2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> validator = <span class="keyword">new</span> Validator();</span><br><span class="line">  <span class="keyword">const</span> data2 = &#123;</span><br><span class="line">    <span class="attr">role</span>: <span class="string">&#x27;juejin&#x27;</span>,</span><br><span class="line">    <span class="attr">job</span>: <span class="string">&#x27;FE&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  validator.add(data2.role, <span class="string">&#x27;checkRole&#x27;</span>);</span><br><span class="line">  validator.add(data2.job, <span class="string">&#x27;checkJob&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> result = validator.check();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是不是比一直疯狂写 <code>if-else</code> 好太多了呢？还有什么例子？表单验证啊 ~ 对于表单字段（名称、密码、邮箱、….）我们可以使用策略模式去设计优化它，想啥呢，赶紧动手试一下！我都已经手把手教你到这了~</p><h4 id="什么时候用策略模式？"><a href="#什么时候用策略模式？" class="headerlink" title="什么时候用策略模式？"></a>什么时候用策略模式？</h4><p>当你负责的模块，基本满足以下情况时</p><ul><li>各判断条件下的策略相互独立且可复用</li><li>策略内部逻辑相对复杂</li><li>策略需要灵活组合</li></ul><h3 id="发布订阅★"><a href="#发布订阅★" class="headerlink" title="发布订阅★"></a>发布订阅★</h3><blockquote><p>考察公司：完美世界、百度</p></blockquote><p>前面还逼逼一下，这里直接给需求了 👇</p><p><strong>需求 : 申请成功后，需要触发对应的订单、消息、审核模块对应逻辑</strong></p><p>机智如我，我会如何做呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applySuccess</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通知消息中心获取最新内容</span></span><br><span class="line">  MessageCenter.fetch();</span><br><span class="line">  <span class="comment">// 更新订单信息</span></span><br><span class="line">  Order.update();</span><br><span class="line">  <span class="comment">// 通知相关方审核</span></span><br><span class="line">  Checker.alert();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不就这样写吗，还想咋滴！！！是的，这么写没得毛病，但是呢，我们来思考几个问题</p><p>比如 <code>MessageCenter.fetch()</code> 是小彭写的，<strong>他大姨夫来了，心情不爽</strong>，把模块的方法名改了，现在叫 <code>MessageCenter.request()</code>，你咋办，你这块逻辑改呗~</p><p>再比如，你和阿宽并行开发的，阿宽负责订单模块，你一气呵成写下这段代码，然后一运行，报错了，一询问，发现，<strong>原来阿宽昨晚去蹦迪了</strong>，原本今天应该完成的订单模块<code>Order.update()</code>，延迟一天，那你就只能先注释代码，等依赖的模块开发完了，你再回来添加这段逻辑咯~</p><p>更可怕的是，你可能不只是涉及到这三个模块，maybe 还有很多模块，比如你申请成功，现在还需要上报申请日志，你总不能这样写吧？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applySuccess</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通知消息中心获取最新内容</span></span><br><span class="line">  MessageCenter.fetch();</span><br><span class="line">  <span class="comment">// 更新订单信息</span></span><br><span class="line">  Order.update();</span><br><span class="line">  <span class="comment">// 通知相关方审核</span></span><br><span class="line">  Checker.alert();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// maybe 更多</span></span><br><span class="line">  Log.write();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们的 <code>发布-订阅模式</code> 要按捺不住了。</p><h4 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h4><p>发布-订阅是一种消息范式，消息的发布者，不会将消息直接发送给特定的<code>订阅者</code>，而是通过消息通道广播出去，然后呢，订阅者通过订阅获取到想要的消息。</p><p>我们用 发布-订阅模式 修改以下上边的代码 👇</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.events = &#123;&#125;;</span><br><span class="line">  <span class="built_in">this</span>.on = <span class="function"><span class="keyword">function</span>(<span class="params">name, cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.events[name]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.events[name].push(cb);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.events[name] = [cb];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">this</span>.trigger = <span class="function"><span class="keyword">function</span>(<span class="params">name, ...arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.events[name]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.events[name].forEach(<span class="function"><span class="params">eventListener</span> =&gt;</span> &#123;</span><br><span class="line">        eventListener(...arg);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上边我们写好了一个 <code>EventEmit</code>，然后我们的业务代码可以改成这样 ~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> event = <span class="keyword">new</span> EventEmit();</span><br><span class="line">event.trigger(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line"></span><br><span class="line">MessageCenter.fetch() &#123;</span><br><span class="line">  event.on(<span class="string">&#x27;success&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;更新消息中心&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">Order.update() &#123;</span><br><span class="line">  event.on(<span class="string">&#x27;success&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;更新订单信息&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">Checker.alert() &#123;</span><br><span class="line">  event.on(<span class="string">&#x27;success&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;通知管理员&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样就没问题了吗？其实还是有弊端的，比如说，过多的使用发布订阅，就会导致难以维护调用关系。所以，还是看大家的设计吧，这里只是让大家知道，发布订阅模式是个啥~</p><h4 id="什么时候用发布-订阅模式？"><a href="#什么时候用发布-订阅模式？" class="headerlink" title="什么时候用发布-订阅模式？"></a>什么时候用发布-订阅模式？</h4><p>当你负责的模块，基本满足以下情况时</p><ul><li>各模块相互独立</li><li>存在一对多的依赖关系</li><li>依赖模块不稳定、依赖关系不稳定</li><li>各模块由不同的人员、团队开发</li></ul><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><h4 id="装饰器模式-1"><a href="#装饰器模式-1" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><blockquote><p>个人理解 : 是为了给一个函数赋能，增强它的某种能力，它能动态的添加对象的行为，也就是我传入的就是一个对象</p></blockquote><blockquote><p>在 JS 世界中，世间万物，皆为对象</p></blockquote><p>大家过年，都会买桔子树吧（不买的统一带走），意味“大吉大利”嘛，那么我们买了桔子树之后，都会往上边挂一些红包，摇身一变，“红包桔子树”，牛掰！这个的红包就是<strong>装饰器</strong>，它不对桔子树原有的功能产生影响。</p><p>再举个 🌰，我现在写的这边文章，我只会写中文，但是各位看官中有英国小伙伴，那我不会写英文啊，所以我需要通过装饰器来赋予我写英文的能力</p><p>你这不是在真实写代码中的啊，能不能举一个日常开发的 🌰，ok，那我来举一个，React 中的高阶组件 HOC</p><p>了解 React 的都知道，高阶组件其实就是一个函数，接收一个组件作为参数，然后返回一个新的组件。</p><p>那么我们现在写一个高阶组件 HOC，用它来装饰 <code>Target Component</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yellowHOC = <span class="function"><span class="params">WrapperComponent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">backgroundColor:</span> &#x27;<span class="attr">yellow</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">WrapperComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> yellowHOC;</span><br></pre></td></tr></table></figure><p>定义了一个带有装饰黄色背景的高阶组件，我们用它来装饰目标组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> yellowHOC <span class="keyword">from</span> <span class="string">&#x27;./yellowHOC&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetComponent</span> <span class="keyword">extends</span> <span class="title">Reac</span>.<span class="title">Compoment</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>66666<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> yellowHOC(TargetComponent);</span><br></pre></td></tr></table></figure><p>你看，我们这不就用到了装饰器模式了嘛？什么，你还听不懂？那我最后再举一个例子，不知道这个例子，能不能帮助你们理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> kuanWrite = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.writeChinese = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我只会写中文&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过装饰器给阿宽加上写英文的能力</span></span><br><span class="line"><span class="keyword">const</span> Decorator = <span class="function"><span class="keyword">function</span>(<span class="params">old</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.oldWrite = old.writeChinese;</span><br><span class="line">  <span class="built_in">this</span>.writeEnglish = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;给阿宽赋予写英文的能力&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">this</span>.newWrite = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.oldWrite();</span><br><span class="line">    <span class="built_in">this</span>.writeEnglish();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> oldKuanWrite = <span class="keyword">new</span> kuanWrite();</span><br><span class="line"><span class="keyword">const</span> decorator = <span class="keyword">new</span> Decorator(oldKuanWrite);</span><br><span class="line">decorator.newWrite();</span><br></pre></td></tr></table></figure><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><blockquote><p>个人理解，为了解决我们不兼容的问题，把一个类的接口换成我们想要的接口。</p></blockquote><p>举个 🌰 , 我想听歌的时候，我发现我没带耳机，我的手机是 iphone 的，而现在我只有一个 Type-C 的耳机，为了能够听歌，我用了一个转换器（也就是适配器），然后我就可以开心的听歌了。</p><p>我举个真实业务中的例子，前段时间需要做一个需求，是这样的。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e863ff0e86244439aafdf8c3d3d9ca3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>看这个图，图中红色方框区域是一个资源列表展示组件，该列表数据，有<strong>三处来源</strong>：本地上传、资源列表添加、后台返回资源。</p><p>怎么理解呢？可以看到图中，该流程主要是：</p><ul><li>右边的“资源概况”是调接口，返回的一个 MaterialsList ，可以从右边点击 “+” 添加进来</li><li>也可以通过选择本地文件上传</li><li>如果是编辑场景下，还有后台接口返回的数据</li></ul><p>由于历史原因和之前后台接口返回的数据结构问题，这三个数据格式是不同的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地资源文件上传之后的数据结构</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ResourceLocalFileType &#123;</span><br><span class="line">  <span class="attr">uuid</span>: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">number</span>;</span><br><span class="line">  created: <span class="built_in">number</span>;</span><br><span class="line">  lastModified: <span class="built_in">number</span>;</span><br><span class="line">  resourceType: <span class="built_in">number</span>;</span><br><span class="line">  cancel: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  status: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 资源概况接口返回的数据结构</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ResourcePackageFileType &#123;</span><br><span class="line">  <span class="attr">uuid</span>: <span class="built_in">string</span>;</span><br><span class="line">  materialName: <span class="built_in">string</span>;</span><br><span class="line">  materialLink: <span class="built_in">string</span>;</span><br><span class="line">  materialType: <span class="built_in">number</span>;</span><br><span class="line">  uid?: <span class="built_in">string</span>;</span><br><span class="line">  ext?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原先数据后台返回的数据接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ResourceBackendFileType &#123;</span><br><span class="line">  <span class="attr">uuid</span>: <span class="built_in">string</span>;</span><br><span class="line">  resourceName: <span class="built_in">string</span>;</span><br><span class="line">  resourceLink: <span class="built_in">string</span>;</span><br><span class="line">  resourceType: <span class="built_in">number</span>;</span><br><span class="line">  version: <span class="built_in">string</span>;</span><br><span class="line">  ext: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很蛋疼，三个数据来源，三种时候数据结构，我们的资源列表组件是只能接收一种数据格式的列表，我不想破坏纯展示型组件的内部逻辑，<strong>想保持该组件的职责：展示！</strong></p><p>那该怎么处理？<strong>采用适配器模式，将不同的数据结构适配成展示组件所能接受的数据结构</strong></p><p>首先，定义一个统一的数据格式：AdapterResourceFileType</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AdapterResourceType &#123;</span><br><span class="line">  <span class="attr">uuid</span>: <span class="built_in">string</span>;</span><br><span class="line">  created: <span class="built_in">number</span>;</span><br><span class="line">  fileNo: <span class="built_in">number</span>;</span><br><span class="line">  fileName: <span class="built_in">string</span>;</span><br><span class="line">  fileOrigin: <span class="built_in">string</span>;</span><br><span class="line">  fileStatus: <span class="built_in">string</span>;</span><br><span class="line">  fileInfo: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="built_in">number</span>;</span><br><span class="line">    size?: <span class="built_in">number</span>;</span><br><span class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 本地图片额外操作</span></span><br><span class="line">  action?: &#123;</span><br><span class="line">    cancel?: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过适配器模块，适配成我们需要的接口API。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7e962936607400bb152a3d49a46cd26~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>在数据进行组件列表展示时，将来源不同的数据经过适配器处理，进行整合，然后传递给展示组件，以达到我们的目的</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be9b40b244fb434ba3d03ea8b895becd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dffc52d3ed041b4a9c82e95f0f8518e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>可能有人觉得，这就是适配器？你在逗我？我想说 : _________</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>我们再来讲一个叫做 <strong>代理模式</strong>，说到代理哈，我脑海里第一个浮现的词语 : “事件委托、事件代理”，这算吗？算哒。我举些 🌰，让大家知道代理模式是个啥玩意</p><p>作为程序员嘛，女朋友比较难找，就算找到了，咱这么瘦弱，怕是保护不了啊，所以我花钱找了个保镖来保护我，稳妥。这就是代理模式。</p><p>你翻qiang吗？你能 google 吗？老实人哪会什么翻qiang，我是不会的，会我也说我不会。其实正常来讲，我们直接访问 google 是无响应的。那怎么办呢，通过第三方代理服务器。小飞机？懂 ？</p><p>要说初中非主流三大巨头，莫过于 <code>许嵩、徐良、汪苏泷</code>了，去年想去看许嵩演唱会，好家伙，这个演唱会的门票都被抢光了，无奈之下，只能找黄牛，这里，黄牛就起了代理的作用，懂？</p><p>程序世界的代理者也是如此，我们不直接操作原有对象，而是委托代理者去进行。代理者的作用，就是对我们的请求预先进行处理或转接给实际对象。</p><blockquote><p>代理模式是为其它对象提供一种代理以<strong>控制</strong>这个对象的访问，具体执行的功能还是这个对象本身，就比如说，我们发邮件，通过代理模式，那么代理者可以控制，决定发还是不发，但具体发的执行功能，是外部对象所决定，而不是代理者决定。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发邮件，不是qq邮箱的拦截</span></span><br><span class="line"><span class="keyword">const</span> emailList = [<span class="string">&#x27;qq.com&#x27;</span>, <span class="string">&#x27;163.com&#x27;</span>, <span class="string">&#x27;gmail.com&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理</span></span><br><span class="line"><span class="keyword">const</span> ProxyEmail = <span class="function"><span class="keyword">function</span>(<span class="params">email</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (emailList.includes(email)) &#123;</span><br><span class="line">    <span class="comment">// 屏蔽处理</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 转发，进行发邮件</span></span><br><span class="line">    SendEmail.call(<span class="built_in">this</span>, email);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SendEmail = <span class="function"><span class="keyword">function</span>(<span class="params">email</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 发送邮件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部调用代理</span></span><br><span class="line">ProxyEmail(<span class="string">&#x27;cvte.com&#x27;</span>);</span><br><span class="line">ProxyEmail(<span class="string">&#x27;ojbk.com&#x27;</span>);</span><br></pre></td></tr></table></figure><p>下边再来举一个例子，来至 《JavaScript 设计模式与开发实践》</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本体</span></span><br><span class="line"><span class="keyword">var</span> domImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> imgEle = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(imgEle);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">setSrc</span>: <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">      imgEle.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理</span></span><br><span class="line"><span class="keyword">var</span> proxyImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    domImage.setSrc(<span class="built_in">this</span>.src); <span class="comment">// 图片加载完设置真实图片src</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">setSrc</span>: <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">      domImage.setSrc(<span class="string">&#x27;./loading.gif&#x27;</span>); <span class="comment">// 预先设置图片src为loading图</span></span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部调用</span></span><br><span class="line">proxyImage.setSrc(<span class="string">&#x27;./product.png&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="什么时候用代理模式？"><a href="#什么时候用代理模式？" class="headerlink" title="什么时候用代理模式？"></a>什么时候用代理模式？</h4><p>当你负责的模块，基本满足以下情况时</p><ul><li>模块职责单一且可复用</li><li>两个模块间的交互需要一定限制关系</li></ul><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>需求 ：如图所示，我们申请设备之后，接下来要选择收货地址，然后选择责任人，而且必须是上一个成功，才能执行下一个~</p><p>小伙伴们惊讶了，这不简单嘛？奥力给！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyDevice</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理巴拉巴拉...</span></span><br><span class="line">  <span class="keyword">let</span> devices = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> nextData = <span class="built_in">Object</span>.assign(&#123;&#125;, data, devices);</span><br><span class="line">  <span class="comment">// 执行选择收货地址</span></span><br><span class="line">  selectAddress(nextData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectAddress</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理巴拉巴拉...</span></span><br><span class="line">  <span class="keyword">let</span> address = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> nextData = <span class="built_in">Object</span>.assign(&#123;&#125;, data, address);</span><br><span class="line">  <span class="comment">// 执行选择责任人</span></span><br><span class="line">  selectChecker(nextData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectChecker</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理巴拉巴拉...</span></span><br><span class="line">  <span class="keyword">let</span> checker = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> nextData = <span class="built_in">Object</span>.assign(&#123;&#125;, data, checker);</span><br><span class="line">  <span class="comment">// 还有更多</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看，这不就完事了，有啥难的，然后过了第二天，你又接了两个新的流程需求，可能一个就两步骤，一个可能多了“检查库存”这个步骤</p><p>你不由惊了，哎呀妈呀，<strong>老夫聊发少年狂，键盘伺候，Ctrl C + Ctrl V</strong>，直接copy然后改一下逻辑？？</p><p>这里就是要讲的责任链模式。</p><h4 id="责任链模式-1"><a href="#责任链模式-1" class="headerlink" title="责任链模式"></a>责任链模式</h4><p>什么是责任链模式呢？我给你们找了个定义 : 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Chain = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.fn = fn;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">this</span>.setNext = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> applyDevice = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> chainApplyDevice = <span class="keyword">new</span> Chain(applyDevice);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> selectAddress = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> chainSelectAddress = <span class="keyword">new</span> Chain(selectAddress);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> selectChecker = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> chainSelectChecker = <span class="keyword">new</span> Chain(selectChecker);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运用责任链模式实现上边功能</span></span><br><span class="line">chainApplyDevice.setNext(chainSelectAddress).setNext(chainSelectChecker);</span><br><span class="line">chainApplyDevice.run();</span><br></pre></td></tr></table></figure><p>这样的好处是啥？首先是解耦了各节点关系，之前的方式是 A 里边要写 B，B 里边写 C，但是这里不同了，你可以在 B 里边啥都不写。</p><p>其次，各节点灵活拆分重组，正如上边你接的两个新需求。比如两个步骤的你就只需要这么写完事</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> applyLincense = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> chainApplyLincense = <span class="keyword">new</span> Chain(applyLincense);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> selectChecker = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> chainSelectChecker = <span class="keyword">new</span> Chain(selectChecker);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运用责任链模式实现上边功能</span></span><br><span class="line">chainApplyLincense.setNext(chainSelectChecker);</span><br><span class="line">chainApplyLincense.run();</span><br></pre></td></tr></table></figure><h4 id="什么时候使用责任链模式？"><a href="#什么时候使用责任链模式？" class="headerlink" title="什么时候使用责任链模式？"></a>什么时候使用责任链模式？</h4><p>当你负责的模块，基本满足以下情况时</p><ul><li>你负责的是一个完整流程，或你只负责流程中的某个环节</li><li>各环节可复用</li><li>各环节有一定的执行顺序</li><li>各环节可重组</li></ul><h1 id="Node-js★"><a href="#Node-js★" class="headerlink" title="Node.js★"></a>Node.js★</h1><blockquote><p>考察公司：美团</p></blockquote><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p><code>Node.js</code> 是一个开源与跨平台的 <code>JavaScript</code> 运行时环境。</p><p>在<strong>浏览器外</strong>运行 V8 JavaScript 引擎（Google Chrome 的内核），利用事件驱动、非阻塞和异步输入输出模型等技术提高性能。</p><p>可以理解为 <code>Node.js</code> 就是一个服务器端的、非阻塞式I/O的、事件驱动的<code>JavaScript</code>运行环境。</p><h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><p>在浏览器 <code>JavaScript</code> 中，通常<code>window</code> 是全局对象， 而 <code>Nodejs</code>中的全局对象是 <code>global</code>。</p><p><strong>变量</strong></p><ul><li><p>在<code>NodeJS</code>里，是<strong>不可能在最外层定义一个变量</strong>，因为所有的用户代码都是当前模块的，只在当前模块里可用，但可以通过<code>exports</code>对象的使用将其传递给模块外部。</p></li><li><p>所以，在<code>Node.js</code>中，用<code>var/let/const</code>声明的变量并<strong>不属于全局的变量，只在当前模块生效</strong>。</p></li><li><p>但<strong>不声明的变量</strong>会自动放入<code>global</code>上。</p></li></ul><p><strong>this</strong></p><ul><li><strong>非严格模式</strong>，函数中 <code>this</code> 的值默认指向<strong>全局对象</strong>，即<code>global</code>，但<strong>函数外</strong>的<code>this</code>指向一个<strong>空对象</strong>。</li><li>严格模式，函数中 <code>this</code> 为<code>undefined</code>。<strong>函数外</strong>的<code>this</code>仍指向一个<strong>空对象</strong>。</li></ul><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>I/O密集：反复去读写磁盘文件。</p><p>CPU密集：大量计算。</p><p><strong>优点</strong></p><ul><li>处理<strong>高并发</strong>场景性能更佳</li><li>适合<strong>I/O密集型</strong>应用，值的是应用在运行极限时，CPU占用率仍然比较低，大部分时间是在做 I/O硬盘内存读写操作</li></ul><p>因为<code>Nodejs</code>是单线程，带来的<strong>缺点</strong>有：</p><ul><li><strong>不适合CPU密集型</strong>应用</li><li>只支持<strong>单核CPU</strong>，不能充分利用CPU</li><li><strong>可靠性低</strong>，一旦代码某个环节崩溃，整个系统都崩溃</li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>借助<code>Nodejs</code>的特点和弊端，其应用场景分类如下：</p><ul><li>善于<code>I/O</code>，不善于计算。因为Nodejs是一个单线程，如果计算（同步）太多，则会阻塞这个线程</li><li>大量并发的I/O，应用程序内部并不需要进行非常复杂的处理</li><li>与 <code>websocket</code> 配合，开发<strong>长连接的实时交互</strong>应用程序</li></ul><p>具体场景可以表现为如下：</p><ul><li>第一大类：用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的web应用程序</li><li>第二大类：基于web、canvas等多人联网游戏</li><li>第三大类：基于web的多人实时聊天客户端、聊天室、图文直播</li><li>第四大类：单页面浏览器应用程序</li><li>第五大类：操作数据库、为前端和移动端提供基于<code>json</code>的API</li></ul><p>其实，<code>Nodejs</code>能实现几乎一切的应用，只考虑适不适合使用它。</p><h1 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h1><h2 id="npm-yarn-常用命令"><a href="#npm-yarn-常用命令" class="headerlink" title="npm/yarn 常用命令"></a>npm/yarn 常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 设置淘宝镜像</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">yarn config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line"><span class="comment">## 初始化项目:</span></span><br><span class="line">yarn init -y</span><br><span class="line">npm init -y</span><br><span class="line"><span class="comment">## 下载项目的所有声明的依赖:</span></span><br><span class="line">yarn </span><br><span class="line">npm install</span><br><span class="line"><span class="comment">## 下载指定的运行时依赖包:</span></span><br><span class="line">yarn add webpack@3.2.1</span><br><span class="line">npm install webpack@3.2.1 -S</span><br><span class="line"><span class="comment">## 下载指定的开发时依赖:</span></span><br><span class="line">yarn add webpack@3.2.1 -D</span><br><span class="line">npm install webpack@3.2.1 -D</span><br><span class="line"><span class="comment">## 全局下载指定包:</span></span><br><span class="line">yarn global add webpack</span><br><span class="line">npm install webpack -g</span><br><span class="line"><span class="comment">## 删除依赖包:</span></span><br><span class="line">yarn remove webpack</span><br><span class="line">npm remove webpack -S</span><br><span class="line">yarn global remove webpack</span><br><span class="line">npm remove webpack -g</span><br><span class="line"><span class="comment">## 运行项目中配置的script:</span></span><br><span class="line">yarn run xxx</span><br><span class="line">npm run xxx</span><br><span class="line"><span class="comment">## 查看某个包的信息:</span></span><br><span class="line">yarn info xxx</span><br><span class="line">npm info xxx</span><br></pre></td></tr></table></figure><h2 id="npm-yarn区别★"><a href="#npm-yarn区别★" class="headerlink" title="npm yarn区别★"></a>npm yarn区别★</h2><blockquote><p>考察公司：百度</p></blockquote><h3 id="早期的npm"><a href="#早期的npm" class="headerlink" title="早期的npm"></a>早期的npm</h3><p>其实在最早期的<code>npm</code>版本(npm v2)，<code>npm</code>的设计可以说是非常的简单,在安装依赖的时候会将依赖放到<code>node_modules</code>文件中;</p><p>同时,如果某个直接依赖A依赖于其他的依赖包B,那么依赖B会作为间接依赖,安装到依赖A的文件夹<code>node_modules</code>中,然后可能多个包之间也会有出现同样的依赖递归的,如果项目一旦过大,那么必然会形成一棵巨大的依赖树，依赖包会出现重复,形成<code>嵌套地狱</code>。</p><p>那么我们如何去理解”嵌套地狱”呢？</p><ul><li>首先,项目的依赖树的层级过于深，如果有问题不利于排查和调试</li><li>在依赖的分支中,可能会出现同样版本的相互依赖的问题</li></ul><p>那么这样的重复问题会带来什么后果呢？</p><ul><li>首先,会使得安装的结果占据了大量的空间资源,造成了资源的浪费</li><li>同时,因为安装的依赖重复,会造成在安装依赖时,安装时间过长</li><li>甚至是,因为目录层级过深,导致文件路径过长,会在<code>windows</code>系统下删除<code>node_modules</code>文件,出现删除不掉的情况</li></ul><p>那么, 后面的版本是如何一步步进行优化的呢？后面会陆续的揭晓。</p><h3 id="npm的安装机制和核心原理"><a href="#npm的安装机制和核心原理" class="headerlink" title="npm的安装机制和核心原理"></a>npm的安装机制和核心原理</h3><p>我们可以先来看看 npm 的核心目标</p><p>Bring the best of open source to you, your team and your company.</p><p>意思是给你和你的团队、你的公司带来最好的开源库和依赖。 通过这句话,我们可以了解到 npm 最重要的一点就是安装和维护依赖。</p><h4 id="npm的安装机制"><a href="#npm的安装机制" class="headerlink" title="npm的安装机制"></a>npm的安装机制</h4><p>下面我们会通过一个流程图来具体学习<code>npm install</code>的安装机制</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fbc0e4e27c14500a2a9e4fcf4757fae~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p><code>npm install</code>执行之后, 首先会检查和获取 <code>npm的配置</code>,这里的优先级为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目级的.npmrc文件 &gt; 用户级的 .npmrc文件 &gt; 全局级的 .npmrc &gt; npm内置的 .npmrc 文件</span><br></pre></td></tr></table></figure><p>然后检查项目中是否有 <code>package-lock.json</code>文件</p><ul><li>如果有, 检查 <code>package-lock.json</code>和 <code>package.json</code>声明的依赖是否一致：<ul><li>一致, 直接使用<code>package-lock.json</code>中的信息,从网络或者缓存中加载依赖</li><li>不一致, 根据上述流程中的不同版本进行处理</li></ul></li><li>如果没有, 那么会根据<code>package.json</code>递归构建依赖树,然后就会根据构建好的依赖去下载完整的依赖资源,在下载的时候,会检查有没有相关的资源缓存:<ul><li>存在, 直接解压到<code>node_modules</code>文件中</li><li>不存在, 从npm远端仓库下载包,校验包的完整性,同时添加到缓存中,解压到 <code>node_modules</code>中</li></ul></li></ul><p>最后, 生成 <code>package-lock.json</code> 文件</p><p>其实, 在我们实际的项目开发中，使用npm作为团队的最佳实践: <code>同一个项目团队,应该保持npm 版本的一致性</code>。</p><p>从上面的安装流程,不知道大家注意到了一点没有,在实际的项目开发中,如果每次都去安装对应依赖时,如果相关的依赖包体积过大或者是依赖于网络,无疑会增加安装的时间成本;那么,缓存在这里的就是一个解决问题的好办法,后面我们会做具体的介绍。</p><h3 id="yarn的出现"><a href="#yarn的出现" class="headerlink" title="yarn的出现"></a>yarn的出现</h3><p>yarn 是一个由<code>Facebook</code>、<code>Google</code>、<code>Exponent</code>和<code>Tilde</code>构建的新的JavaScript包管理器。它的出现是为了解决历史上<code>npm</code>的某些不足(比如npm对于依赖的完整性和一致性的保证,以及npm安装过程中速度很慢的问题)</p><p>当npm还处于<code>v3</code>时期的时候,一个叫<code>yarn</code>的包管理工具横空出世.在2016年, npm还没有package-lock.json文件,安装的时候速度很慢,稳定性很差,<code>yarn</code>的出现很好的解决了一下的一些问题:</p><ul><li><strong>确定性:</strong> 通过yarn.lock等机制,即使是不同的安装顺序,相同的依赖关系在任何的环境和容器中,都可以以相同的方式安装。(那么,此时的npm v5之前,并没有package-lock.json机制,只有默认并不会使用 <a href="https://link.juejin.cn/?target=https://docs.npmjs.com/cli/v8/commands/npm-shrinkwrap">npm-shrinkwrap.json</a>)</li><li><strong>采用模块扁平化的安装模式:</strong> 将不同版本的依赖包,按照一定的策略，归结为单个版本;以避免创建多个版本造成工程的冗余(目前版本的npm也有相同的优化)</li><li><strong>网络性能更好:</strong> <code>yarn</code>采用了请求排队的理念,类似于并发池连接,能够更好的利用网络资源;同时也引入了一种安装失败的重试机制</li><li><strong>采用缓存机制,实现了离线模式</strong> (目前的npm也有类似的实现)</li></ul><p>我们可以来看一下 <code>yarn.lock</code>的结构:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;@babel/cli@^7.1.6&quot;</span>, <span class="string">&quot;@babel/cli@^7.5.5&quot;</span>:</span><br><span class="line">  version <span class="string">&quot;7.8.4&quot;</span></span><br><span class="line">  resolved <span class="string">&quot;http://npm.in.zhihu.com/@babel%2fcli/-/cli-7.8.4.tgz#505fb053721a98777b2b175323ea4f090b7d3c1c&quot;</span></span><br><span class="line">  integrity sha1-UF+wU3IamHd7KxdTI+pPCQt9PBw=</span><br><span class="line">  dependencies:</span><br><span class="line">    commander <span class="string">&quot;^4.0.1&quot;</span></span><br><span class="line">    convert-source-map <span class="string">&quot;^1.1.0&quot;</span></span><br><span class="line">    fs-readdir-recursive <span class="string">&quot;^1.1.0&quot;</span></span><br><span class="line">    glob <span class="string">&quot;^7.0.0&quot;</span></span><br><span class="line">    lodash <span class="string">&quot;^4.17.13&quot;</span></span><br><span class="line">    make-dir <span class="string">&quot;^2.1.0&quot;</span></span><br><span class="line">    slash <span class="string">&quot;^2.0.0&quot;</span></span><br><span class="line">    source-map <span class="string">&quot;^0.5.0&quot;</span></span><br><span class="line">  optionalDependencies:</span><br><span class="line">    chokidar <span class="string">&quot;^2.1.8&quot;</span></span><br></pre></td></tr></table></figure><p>熟悉npm的<code>package-lock.json</code>文件的朋友,可能一眼就看到了一些不同; <code>package-lock.json</code>采用的是<code>JSON</code>的结构,而<code>yarn</code>并没有采用这种结构,而是一种自定义的标记方式;我们可以看出新的自定义的方式,也同样保持了高度的可读性。</p><p><strong>相比于npm,Yarn另一个显著的区别就是yarn.lock的子依赖的版本不是固定的版本</strong>。这其实就说明了一个问题: 一个单独的<code>yarn.lock</code>的问题并不能确定✅<code>node-modules</code>的文件结构,还需要<code>package.json</code>的配合。</p><p>其实到了这里,我会有一个问题,如何实现 <code>npm 到 yarn 的切换呢？</code></p><p>这里 我了解到有一个专门的工具<a href="https://link.juejin.cn/?target=https://github.com/imsnif/synp">synp</a>,它可以将<code>yarn.lock</code>转换为<code>package-lock.json</code>，反之亦然。</p><p>这里可以顺带提一嘴,<code>yarn</code>默认采用的是<code>perfer-online</code>模式,即优先使用网络资源。如果网络资源请求失败,再去请求缓存数据。</p><p>到这里我们应该对<code>yarn</code>有了初步的了解,那我们继续去看一下它的安装机制</p><h4 id="yarn的安装机制"><a href="#yarn的安装机制" class="headerlink" title="yarn的安装机制"></a>yarn的安装机制</h4><p>上面一小节我们对npm的安装机制有了一些基本的了解,现在让我们先来简单的看一下<code>Yarn</code>的安装理念。</p><p>简单来说, <code>Yarn</code>的安装大致分为5个步骤:</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a25fa69736e4f0aacee1372476ece5c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>检测(checking) —&gt; 解析包(Resolving Packages) —&gt; 获取包(Fetching) —&gt; 链接包(Linking Packages) —&gt; 构建包(Building Packages)</p><p>那么接下来我们要开始具体分析这些过程中都做了哪些事情:</p><p><strong>检测包</strong></p><p>这一步，最主要的目的就是检测我们的项目中是否存在npm相关的文件,比如<code>package-lock.json</code>等;如果有,就会有相关的提示用户注意：这些文件可能会存在冲突。在这一步骤中 也会检测系统OS, CPU等信息。</p><p><strong>解析包</strong></p><p>这一步会解析依赖树中的每一个包的信息:</p><p>首先呢,获取到<code>首层依赖</code>: 也就是我们当前所处的项目中的<code>package.json</code>定义的<code>dependencies</code>、<code>devDependencies</code>、<code>optionalDependencies</code>的内容。</p><p>紧接着<strong>会采用遍历首层依赖的方式来获取包的依赖信息</strong>,以及递归查找每个依赖下嵌套依赖的版本信息，并将解析过的包和正在进行解析包呢<code>用Set数据结构进行存储</code>,这样就可以保证<code>同一版本范围内的包</code>不会进行重复的解析:</p><p>举个例子</p><ul><li>对于没有解析过的包A, 首次尝试从 <code>yarn.lock</code>中获取版本信息,并且标记为已解析</li><li>如果在<code>yarn.lock</code>中没有找到包A， 则向<code>Registry</code>发起请求获取满足版本范围内的已知的最高版本的包信息,获取之后将该包标记为已解析。</li></ul><p>总之，经过解析包这一步之后呢,我们就已经确定了解析包的具体版本信息和包的下载地址。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc863afc75f84c4784627a8e4f7cbd71~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p><strong>获取包</strong></p><p>这一步首先我们会检查缓存中是否有当前依赖的包,同时呢将缓存中不存在的包下载到缓存的目录中。但是这里有一个小问题需要大家思考一下:</p><p>比如: 如何去判断缓存中有当前的依赖包呢？</p><p><strong>其实呢,在Yarn中会根据 cacheFolder+<a href="https://link.juejin.cn/?target=https://github.com/Trott/slug">slug</a>+node_modules+pkg.name 生成一个路径;判断系统中是否存在该path,如果存在证明已经有缓存,不用重新下载。这个path也就是依赖包缓存的具体路径。</strong></p><p>那么对于没有命中的缓存包呢？在 <code>Yarn</code> 中存在一个Fetch队列,按照具体的规则进行网络请求。如果下载的包是一个file协议,或者是相对路径,就说明指向一个本地目录,此时会调用Fetch From Local从离线缓存中获取包;否则调用 Fetch From External 获取包,最终获取的结果使用 fs.createWriteStream 写入到缓存目录。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b43405f73284e37a23c59b725ea1f9c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p><strong>链接包</strong></p><p>我们上一步已经把依赖放到了缓存目录,那么下一步,我们应该要做什么事情呢？是不是应该把项目中的依赖复制到<code>node_modules</code>目录下呢,没错;只不过此时需要遵循一个扁平化的原则。复制依赖之前, <code>Yarn</code>会先解析 <code>peerDepdencies</code>，如果找不到符合要求的<code>peerDepdencies</code>的包,会有 <code>warning</code>提示，并最终拷贝依赖到项目中。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/825e548b1f9d41059efa5f2080d0c155~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"> <strong>构建包</strong></p><p>如果依赖包中存在二进制包需要进行编译，那么会在这一步进行。</p><p><code>千呼万唤始出来</code>,这里要插一句话,感谢大家的捧场。 <code>为伊消得人憔悴</code>,最近想的事情比较多,一直拖着实在是不好意思。那我们大家继续来一起整理:</p><p>其实, 从大家的评论中我去认真讨论和学到了一些新的东西<a href="https://link.juejin.cn/?target=https://www.pnpm.cn/">pnmp</a>和<a href="https://link.juejin.cn/?target=https://www.lernajs.cn/">Lerna</a>;之后如果时间充裕的话,我也会去研究研究和大伙一起讨论的,感谢大家伙的支持 💗。</p><h4 id="npm的缓存机制"><a href="#npm的缓存机制" class="headerlink" title="npm的缓存机制"></a>npm的缓存机制</h4><p>回归正题,接下来让我们看来一下 <code>npm</code>的对于<strong>同一个版本的依赖包是如何进行本地化缓存的</strong></p><p>这是npm查看本地缓存的命令:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get cache</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7516838fcf2c42639f6bd2cfd77e9617~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>从图中我们可以看出npm配置缓存的位置在 <code>/Users/zhaoxxxx/.npm</code>（mac os 的默认的缓存的位置）当中。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b2ab2ca967c4c4fa2d26a534c0bf09a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>其实你也看到了<code>_cacache</code>的目录有三个文件:</p><ul><li>content-v2</li><li>index-v5</li><li>tmp</li></ul><p>其中, content-v2里面存放的是一些二进制的文件。为了使二进制的文件可读,我把文件做了压缩和解压缩处理。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5585e524462c415cbaebc26595fc7878~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>然后把下面的文件进行解压处理就可以得到我们想要的npm的具体的资源:</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b22e36004c14999a7242c2cd4ba83e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p><strong>压缩结果</strong></p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be31ba842d6e451383a78e531664b401~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>这里推荐一个 <code>the unarchiver</code> 解压缩工具,支持更多的格式,强力推荐。</p><p>而在 index-v5文件中呢, 我们使用和刚才一样的操作可以得到一些描述性的文件。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68b5fd8a42aa4d26b6dc9f4ca064efdb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>事实上这些内容就是 content-v2 文件的索引。</p><p><strong>那么这里我也有一个问题这里的缓存是如何存储并且被利用的呢？</strong></p><p>这里就要提一下 <code>npm install</code>的安装机制, 当 npm 执行的时候,通过 <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/pacote">pacote</a> 把相应的包解压到对应的 <code>node_modules</code>下面。(这里顺嘴提一句 <a href="https://link.juejin.cn/?target=https://github.com/npm/pacote/blob/2ddf67f7c4/lib/index.js">pacote</a>感兴趣的可以来一起研究一下细节,我目前有点不太能看懂; 大概的思路是结合网络请求和文件读写配置进行本地的缓存写入和生成对应的压缩文件,<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903785018425351#heading-4">这里通过对一位大佬文章学习有所得</a>)</p><p>npm主要有会有三个地方用到 <code>pacote</code>:</p><ul><li>当你执行 npm install xxx (这时候会通过 <code>pacote.extract</code> 把对应的包解压到对应的<code>node_modules</code> 下面, <code>pacote</code>源码地址: <a href="https://link.juejin.cn/?target=https://github.com/zkat/pacote/blob/latest/extract.js%23L19">extract.js</a>)</li><li>当你执行 npm cache add xxx (这时候会通过 <code>pacote.tarball 下的 tarballStream</code>往我们之前看到的 <code>_cacache</code>文件下去添加缓存, <code>pacote</code>源码地址: <a href="https://link.juejin.cn/?target=https://github.com/npm/pacote/blob/2ddf67f7c4e084ffec315f94e30bb24f944403e3/lib/fetcher.js%23L292">tarballStream</a>）</li><li>当你执行 <a href="https://link.juejin.cn/?target=https://docs.npmjs.com/cli/v8/commands/npm-pack">npm pack xxx</a> 通过 <code>pacote.tarball 下的 _toFile</code>在当前路径生成对应的压缩文件, 源码地址:<a href="https://link.juejin.cn/?target=https://github.com/npm/pacote/blob/2ddf67f7c4e084ffec315f94e30bb24f944403e3/lib/fetcher.js%23L383">_toFile</a> )</li></ul><p>当<code>npm</code>下载依赖的时候, 先下载到缓存当中,再解压到我们的项目的 <code>node_modules</code>中。 其实 <code>pacote</code>是依赖<a href="https://link.juejin.cn/?target=https://github.com/npm/npm-registry-fetch%23npm-registry-fetch"> npm-registry-fetch</a>来下载包, npm-registry-fetch 可以通过设置 cache 字段进行相关的缓存工作。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51732648a8224aa48ffca18540911f22~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>紧接着呢, 我们在每次去安装资源的时候,会根据<code>package-lock.json</code>中的</p><ul><li>integrity</li><li>verison</li><li>name</li></ul><p>integrity、verison、name 相关信息会生成一个唯一的key;这个key 就能够对应上 index-v5 目录下的缓存记录; 如果发现有缓存资源,就会去找到 tar 包对应的<code>hash</code>值. 根据 <code>hash</code>再去找缓存中的<code>tar</code>包,然后再次通过 <code>pacote</code>将二进制文件解压缩进我们项目的 <code>node_modules</code>目录中，这样就省去了资源下载的网络开销。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/729870ff041e4f36ae2965dbd481d076~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p><strong>这里需要注意的是, 这里的缓存策略是在 npm v5开始的,那么在 v5之前呢, 每个缓存模块是在我们之前提到的 ~./npmrc 文件中以模块名的格式直接存储的</strong></p><p><strong>存储的格式:</strong><code>&#123;cache&#125;&#123;name&#125;&#123;version&#125;</code>。</p><h3 id="npm-or-yarn-开发中的一点疑惑"><a href="#npm-or-yarn-开发中的一点疑惑" class="headerlink" title="npm or yarn 开发中的一点疑惑"></a>npm or yarn 开发中的一点疑惑</h3><p>你在实际的开发会不会出现这样的一些情况</p><ol><li>当你项目依赖出现问题的时候, 我们会不会是直接删除<code>node_modules 和 lockfiles</code>依赖, 再重新 <code>npm install</code>,删除大法是否真的好用?这样的使用方案会不会带来什么问题？</li><li>把所有的依赖包都安装到<code>dependencies</code>中,对<code>devDependencies</code> 不区分会不会有问题?</li><li>一个项目中, 你使用 <code>yarn</code>, 我使用<code>npm</code>，会不会有问题呢？</li><li>还有一个问题, <code>lockfiles 文件</code> 我们提交代码的时候需不需要提交到仓库中呢？</li></ol><p>其实,我对于上面提出的问题也是出于一种一知半解的状态。</p><p>所以,世界这么大, 我想去看看这两个兄弟之间到底是有什么关系呢？</p><h4 id="为什么要lockfiles-要不要提交lockfiles到仓库？"><a href="#为什么要lockfiles-要不要提交lockfiles到仓库？" class="headerlink" title="为什么要lockfiles,要不要提交lockfiles到仓库？"></a>为什么要lockfiles,要不要提交lockfiles到仓库？</h4><p>npm 从<code>v5</code>开始, 增加了<code>package-lock.json</code> 文件。那么 <code>package-lock.json</code>文件的作用是什么呢？</p><p><strong>锁定依赖的安装结构</strong>, 这么做的目的是为了保证在任意的机器上我们去执行<code>npm install</code> 都会得到完全相同的 <code>node_modules</code>安装结果。</p><p>这里其实我是有一个疑问的？为啥单一的 <code>package.json</code> 不能确定唯一的依赖树呢？</p><ul><li>首先是不同版本的npm的安装依赖的策略和算法可能是不一样的</li><li><strong>npm install</strong> 将根据 <code>package.json</code> 中的 <a href="https://link.juejin.cn/?target=https://docs.npmjs.com/cli/v6/using-npm/semver">semver-range version</a> 更新依赖，可能某些依赖自上次安装以后,己经发布了新的版本。</li></ul><p>因此, <code>保证能够完整准确的还原项目依赖</code> 就是<strong>lockfiles</strong>出现的原因。</p><p>首先我们这里需要了解一下 <code>package-lock.json</code>的作用机制。 举个例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;@babel/core&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;7.2.0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;integrity&quot;</span>: <span class="string">&quot;sha1-pN04FJAZmOkzQPAIbphn/voWOto=&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;dev&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;requires&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;@babel/code-frame&quot;</span>: <span class="string">&quot;^7.0.0&quot;</span>,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;@babel/generator&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;7.2.0&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;resolved&quot;</span>: <span class="string">&quot;http://www.npm.com/@babel%2fgenerator/-/generator-7.2.0.tgz&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;integrity&quot;</span>: <span class="string">&quot;sha1-6vOCH6AwHZ1K74jmPUvMGbc7oWw=&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;dev&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;requires&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;@babel/types&quot;</span>: <span class="string">&quot;^7.2.0&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;jsesc&quot;</span>: <span class="string">&quot;^2.5.1&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;lodash&quot;</span>: <span class="string">&quot;^4.17.10&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;source-map&quot;</span>: <span class="string">&quot;^0.5.0&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;trim-right&quot;</span>: <span class="string">&quot;^1.0.1&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么, 通过上面的示例, 我们可以看到: 一个 <strong>package-lock.json</strong> 的 dependency 主要是有以下的几部分组成的:</p><ul><li>Version: 依赖包的版本号</li><li>Resolved: 依赖包的安装源(其实就是可以理解为下载地址)</li><li>Intergrity: 表明完整性的 Hash 值</li><li>Dev: 表示该模块是否为顶级模块的开发依赖或者是一个的传递依赖关系</li><li>requires: 依赖包所需要的所有依赖项,对应依赖包 <strong>package.json</strong> 里 dependencices 中的依赖项</li><li>dependencices: 依赖包 node_modeles 中依赖的包(特殊情况下才存在)</li></ul><p>事实上, 并不是所有的子依赖都有 <code>dependencies</code> 属性,只有子依赖的依赖和当前已安装在根目录的 <code>node_modules</code>中的依赖冲突之后, 才会有这个属性。 这可能涉及嵌套情况的依赖管理，大家找些资料看看。</p><p>至于我们要不要提交 <strong>lockfiles</strong> 到仓库中？ 这个就需要看我们具体的项目的定位了。</p><ul><li>如果是开发一个应用, 我的理解是 <code>package-lock.json</code>文件提交到代码版本仓库.这样可以保证项目中成员、运维部署成员或者是 CI 系统, 在执行 <code>npm install</code>后, 保证在不同的节点能得到完全一致的依赖安装的内容</li><li>如果你的目标是开发一个给外部环境用的库，那么就需要认真考虑一下了, 因为<strong>库文件一般都是被其他项目依赖的，在不使用 package-lock.json的情况下，就可以复用主项目已经加载过的包，减少依赖重复和体积</strong></li><li>如果说我们开发的库依赖了一个精确版本号的模块， 那么在我们去提交 lockfiles 到仓库中可能就会出现, 同一个依赖被不同版本都被下载的情况。如果我们作为一个库的开发者， 其实如果真的使用到某个特定的版本依赖的需求, 那么定义<strong>peerDependencies</strong> 是一个更好的选择。</li></ul><p>所以, 我个人比较推荐的一个做法是:<code>把 package-lock.json一起提交到仓库中去, 不需要 ignore. 但是在执行 npm publish 命令的时候,也就是发布一个库的时候, 它其实应该是被忽略的不应该被发布出去的。</code></p><p>当然,我这里了解到对 <code>lockfiles</code>的处理,可能需要一个更加细颗粒度的理解，这里我会推荐大家去结合<a target="_blank" rel="noopener" href="https://juejin.cn/post/7060844948316225572#heading-3">前文</a>去理解。</p><ol><li>在npm早期所用到的锁定版本的方式是通过使用 <code>npm-shrinkwrap.json</code>， 它与之前我们提到的 <code>package-lock.json</code> 最大的不同之处在于: npm 包发布的时候默认是将 <code>npm-shrinkwrap.json</code> 发布的, 因此类库和组件需要慎重。</li><li>我们在可以使用到 <code>package-lock.json</code> 是在 npm v5.x版本新增的特性,而在 npm v5.6之后才趋于逐步稳定的状态, 在 5.0 - 5.6中间, 其实是对 <code>package-lock.json</code> 的处理逻辑进行过几次更新。</li><li>在 npm v5.0.x版本中, npm install 时都会根据 package-lock.json 文件下载，不管你的 <code>package.json</code>的内容究竟是什么。</li><li>npm v5.1.0 版本到 npm v5.4.2, <strong>npm install</strong> 会无视 <code>package-lock.json</code> 文件下载的, 会去下载最新版本的 npm 包，并且会更新 <code>package-lock.json</code>.</li><li>npm 5.4.2 版本之后呢，我们继续细化分析:<ul><li>如果在我们的实际开发的项目中， 只有<code>package.json</code>文件时, <strong>npm install</strong> 之后, 会根据它生成一个 <code>package-lock.json</code> 文件</li><li>如果在项目中存在了 <code>package.json</code> 和 <code>package-lock.json</code> 文件, 同时 <code>package.json</code> 的<strong>semver-range</strong> 版本 和 <code>package-lock.json</code> 中版本兼容，即使此时会有新的适用的版本， <code>npm install</code> 还是会根据 <code>package-lock.json</code>下载的</li><li>如果在项目中存在了 <code>package.json</code> 和 <code>package-lock.json</code> 文件, 同时 <code>package.json</code> 的<strong>semver-range</strong> 版本 和 <code>package-lock.json</code> 中版本不兼容，<code>npm install</code> 会把 <code>package-lock.json</code> 更新到兼容 <code>package.json</code>的版本。</li><li>如果 <code>package-lock.json</code> 和 <code>npm-shrinkwrap.json</code> 同时存在于项目的根目录中的时候, <code>package-lock.json</code> 将会被忽略的。</li></ul></li></ol><p>对于上面的过程分析,我之前的文章中做了一个过程的流程图的分析,大家可以结合<a target="_blank" rel="noopener" href="https://juejin.cn/post/7060844948316225572#heading-3">前文</a>做一个更加精细化的理解</p><p>那么，下面我们继续来看下一个问题, 我们不管是使用 <strong>npm</strong> 或 <strong>yarn</strong> 都有可能会把包依赖安装到不同的依赖模块中, 你有没有去思考为什么会这样做呢？这么做会有什么必要关系和我们之后的开发和发布？</p><h4 id="为什么会有-xxxDependencies"><a href="#为什么会有-xxxDependencies" class="headerlink" title="为什么会有 xxxDependencies?"></a>为什么会有 xxxDependencies?</h4><p>其实, npm 设计了以下的几种依赖类型声明:</p><ul><li>dependencies 项目依赖</li><li>devDependencies 开发依赖</li><li>peerDependencies 同版本的依赖</li><li>bundledDependencies 捆绑依赖</li><li>optionalDependencies 可选依赖</li></ul><p>它们起到的作用和声明意义是各不相同的。下面我们来具体介绍一下:</p><p><strong>dependencies</strong> 表示项目依赖，这些依赖都会成为你的线上生产环境中的代码组成的部分。当 它关联到 <strong>npm</strong> 包被下载的时候,<code>dependencies下的模块也会作为依赖, 一起被下载。</code></p><p><code>devDependencies表示开发依赖, 不会被自动下载的。</code>因为 <strong>devDependencies</strong> 一般是用于开发阶段起作用或是只能用于开发环境中被用到的。 比如说我们用到的 <code>Webpack</code>，预处理器 <code>babel-loader</code>、<code>scss-loader</code>，测试工具<code>E2E</code>等， 这些都相当于是辅助的工具包, 无需在生产环境被使用到的。</p><p>这里有一点还是需要我去啰嗦一下的，<code>并不是只有在dependencies中的模块才会被一起打包, 而是在 devDependencies 中的依赖一定不会被打包的。</code> 实际上, 依赖是否是被打包,<strong>完全是取决你的项目里的是否是被引入了该模块</strong>。</p><p><strong>peerDependencies</strong> 表示同版本的依赖, 简单一点说就是: 如果你已经安装我了, 那么你最好也安装我对应的依赖。 这里举个小例子: 加入我们需要开发一个<strong>react-ui</strong> 就是一个基于<code>react</code> 开发的UI组件库， 它本身是会需要一个宿主环境去运行的, 这个宿主环境还需要指定的 <code>react</code>版本来搭配使用的， 所以需要我们去 <code>package.json</code>中去配置:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;peerDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;React&quot;</span>: <span class="string">&quot;^17.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bundledDependencies</strong> 和 <strong>npm pack</strong> 打包命令有关。假设我们在 <code>package.json</code>中有如下的配置:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dep&quot;</span>: <span class="string">&quot;^0.0.2&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">&quot;devD1&quot;</span>: <span class="string">&quot;^1.0.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;bundledDependencies&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;bundleD1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;bundleD2&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们此时执行 <code>npm pack</code>的时候, 就会生成一个 <code>test-1.0.0.tgz</code>的压缩包, 在该压缩包中还包含了 <code>bundleD1</code>和 <code>bundleD2</code> 两个安装包。 实际使用到 这个压缩包的时候</p><p><code>npm install test-1.0.0.tgz</code> 的命令时, <code>bundleD1</code>和 <code>bundleD2</code> 也会被安装的。</p><p>这里其实也有需要注意的是: <code>在 bundledDependencies 中指定的依赖包, 必须先在dependencies 和 devDependencies 声明过, 否则 npm pack 阶段是会报错的。</code></p><p><code>optionalDependencies</code>表示可选依赖，就是说当你安装对应的依赖项安装失败了, 也不会对整个安装过程有影响的。一般我们很少会用到它, <strong>这里我是 不建议大家去使用, 可能会增加项目的不确定性和复杂性。</strong></p><p>到现在为止，大家是不是已经对 npm 规范中相关依赖声明的含义了呢？ 接下来我想和大家去聊一聊版本的规范， 我们一起来看一下解析依赖库锁版本的行为。</p><h4 id="版本规范——依赖库锁版本行为解析"><a href="#版本规范——依赖库锁版本行为解析" class="headerlink" title="版本规范——依赖库锁版本行为解析"></a>版本规范——依赖库锁版本行为解析</h4><p>首先, npm 遵循的是 <code>SemVer</code>版本规范, 至于具体的内容这个链接供大家学习<a href="https://link.juejin.cn/?target=https://semver.org/lang/zh-CN/">语义化版本</a>我就不去啰嗦了。 我们会主要针对一个细节点—- 依赖库锁版本的行为。</p><p><a href="https://link.juejin.cn/?target=https://vue-loader.vuejs.org/zh/guide/%23%E6%89%8B%E5%8A%A8%E8%AE%BE%E7%BD%AE">vue 官方有这样的内容：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个 vue 包的新版本发布时，一个相应版本的 vue-template-compiler 也会随之发布。编译器的版本必须和基本的 vue 包保持同步，这样 vue-loader 就会生成兼容运行时的代码。这意味着你每次升级项目中的 vue 包时，也应该匹配升级 vue-template-compiler。</span><br></pre></td></tr></table></figure><p>根据上面说的意思, 我们如果作为一个库的开发者需要考虑的是： 如何去保证依赖包之间的强制的最低版本的要求？</p><p>其实我们可以去借鉴一下 <code>create-react-app</code>的做法, 在 <code>create-react-app</code>的核心 <code>react-script</code> 中, 它利用了<code>verifyPackageTree</code>方法, 对业务项目中的依赖进行了一系列的对比和限制的工作。 我们可以去看一下<a href="https://link.juejin.cn/?target=https://github.com/facebook/create-react-app/blob/37712374bcaa6ccb168eeaf4fe8bd52d120dbc58/packages/react-scripts/scripts/utils/verifyPackageTree.js%23L19">源码</a>:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">function verifyPackageTree() &#123;</span><br><span class="line">  const <span class="attr">depsToCheck</span> = [</span><br><span class="line">    <span class="string">&#x27;babel-eslint&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;babel-jest&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;eslint&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;jest&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;webpack&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;webpack-dev-server&#x27;</span>,</span><br><span class="line">  ]<span class="comment">;</span></span><br><span class="line">  const <span class="attr">getSemverRegex</span> = () =&gt;</span><br><span class="line">    /\bv?(?:0|<span class="section">[1-9]</span>\d*)\.(?:0|<span class="section">[1-9]</span>\d*)\.(?:0|<span class="section">[1-9]</span>\d*)(?:-<span class="section">[\da-z-]</span>+(?:\.<span class="section">[\da-z-]</span>+)*)?(?:\+<span class="section">[\da-z-]</span>+(?:\.<span class="section">[\da-z-]</span>+)*)?\b/gi<span class="comment">;</span></span><br><span class="line">  const <span class="attr">ownPackageJson</span> = require(<span class="string">&#x27;../../package.json&#x27;</span>)<span class="comment">;</span></span><br><span class="line">  const <span class="attr">expectedVersionsByDep</span> = &#123;&#125;<span class="comment">;</span></span><br><span class="line">  depsToCheck.forEach(<span class="attr">dep</span> =&gt; &#123;</span><br><span class="line">    const <span class="attr">expectedVersion</span> = ownPackageJson.dependencies[dep]<span class="comment">;</span></span><br><span class="line">    if (!expectedVersion) &#123;</span><br><span class="line">      throw new Error(&#x27;This dependency list is outdated, fix it.&#x27;)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    if (!getSemverRegex().test(expectedVersion)) &#123;</span><br><span class="line">      throw new Error(</span><br><span class="line">        `The $&#123;dep&#125; package should be pinned, instead got version $&#123;expectedVersion&#125;.`</span><br><span class="line">      )<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    expectedVersionsByDep<span class="section">[dep]</span> = expectedVersion<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  let <span class="attr">currentDir</span> = __dirname<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  while (true) &#123;</span><br><span class="line">    const <span class="attr">previousDir</span> = currentDir<span class="comment">;</span></span><br><span class="line">    <span class="attr">currentDir</span> = path.resolve(currentDir, <span class="string">&#x27;..&#x27;</span>)<span class="comment">;</span></span><br><span class="line">    if (<span class="attr">currentDir</span> === previousDir) &#123;</span><br><span class="line">      // We&#x27;ve reached the root.</span><br><span class="line">      break<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    const <span class="attr">maybeNodeModules</span> = path.resolve(currentDir, <span class="string">&#x27;node_modules&#x27;</span>)<span class="comment">;</span></span><br><span class="line">    if (!fs.existsSync(maybeNodeModules)) &#123;</span><br><span class="line">      continue<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    depsToCheck.forEach(<span class="attr">dep</span> =&gt; &#123;</span><br><span class="line">      const <span class="attr">maybeDep</span> = path.resolve(maybeNodeModules, dep)<span class="comment">;</span></span><br><span class="line">      if (!fs.existsSync(maybeDep)) &#123;</span><br><span class="line">        return<span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line">      const <span class="attr">maybeDepPackageJson</span> = path.resolve(maybeDep, <span class="string">&#x27;package.json&#x27;</span>)<span class="comment">;</span></span><br><span class="line">      if (!fs.existsSync(maybeDepPackageJson)) &#123;</span><br><span class="line">        return<span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line">      const <span class="attr">depPackageJson</span> = JSON.parse(</span><br><span class="line">        fs.readFileSync(maybeDepPackageJson, &#x27;utf8&#x27;)</span><br><span class="line">      )<span class="comment">;</span></span><br><span class="line">      const <span class="attr">expectedVersion</span> = expectedVersionsByDep[dep]<span class="comment">;</span></span><br><span class="line">      if (!semver.satisfies(depPackageJson.version, expectedVersion)) &#123;</span><br><span class="line">        console.error(//...)<span class="comment">;</span></span><br><span class="line">        process.exit(1)<span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我们去看这一段代码的时候, <code>create-react-app</code>会对项目中的<strong>babel-eslint</strong>、 <strong>babel-jest</strong>、<strong>babel-loader</strong>、<strong>eslint</strong>、<strong>jest</strong>、<strong>webpack</strong>、<strong>webpack-dev-server</strong> 这些核心的依赖都会去进行检索的 — 是否是符合 create-react-app 对于这些核心模块依赖的版本要求。<code>如果不符合依赖版本要求, 那么 create-react-app 的构建过程会直接报错并退出的</code>。</p><p>那么为啥 <code>create-react-app</code>这么做的理由是什么呢？</p><p>我的理解是:<strong>需要上述依赖项的某些确定的版本, 以保障 create-react-app 源码相关的功能稳定</strong></p><p>不知道你对于这样的一种处理方式会不会有一些思考呢？</p><p>那么最好我想去分享一些,自己在对npm实操的一些小建议, 大家伙可以来讨论一下是不是可行的</p><h4 id="或许是最佳的实操建议"><a href="#或许是最佳的实操建议" class="headerlink" title="或许是最佳的实操建议"></a>或许是最佳的实操建议</h4><p>下面我会给出具体的实操的建议, 供大家来参考：</p><ol><li>优先去使用 <strong>npm</strong> 官方已经稳定的支持的版本, 以保证 <strong>npm</strong> 的最基本先进性和稳定性</li><li>当我们的项目第一次去搭建的时候, 使用 <code>npm install</code> 安装依赖包, 并去提交 <code>package.json、package-lock.json</code>, 至于<code>node_moduled</code>目录是不用提交的。</li><li>当我们作为项目的新成员的时候, <code>checkout/clone</code>项目的时候, 执行一次 <code>npm install</code> 去安装依赖包。</li><li>当我们出现了需要升级依赖的需求的时候:<ul><li>升级小版本的时候, 依靠 <strong>npm update</strong></li><li>升级大版本的时候, 依靠 **npm install@ **</li><li>当然我们也有一种方法, 直接去修改 <strong>package.json</strong> 中的版本号, 并去执行 <strong>npm install</strong> 去升级版本</li><li>当我们本地升级新版本后确认没有问题之后, 去提交新的 <strong>package.json</strong> 和 **package-lock.json **文件。</li></ul></li><li>对于降级的依赖包的需求： 我们去执行<strong>npm install @</strong> 命令后，验证没有问题之后, 是需要提交新的 <strong>package.json</strong> 和 <strong>package-lock.json</strong> 文件。</li><li>删除某些依赖的时候:<ul><li>当我们执行 <strong>npm uninstall</strong> 命令后， 需要去验证，提交新的 package.json 和 package-lock.json 文件。</li><li>或者是更加暴力一点, 直接操作 <code>package.json</code>, 删除对应的依赖, 执行 <strong>npm install</strong> 命令, 需要去验证，提交新的<strong>package.json</strong> 和 <strong>package-lock.json</strong> 文件。</li></ul></li><li>当你把更新后的<strong>package.json</strong> 和 <strong>package-lock.json</strong>提交到代码仓库的时候, 需要通知你的团队成员, 保证其他的团队成员拉取代码之后, 更新依赖可以有一个更友好的开发环境保障持续性的开发工作。</li><li>任何时候我们都不要去修改 <strong>package-lock.json</strong>，这是交过智商税的。</li><li>如果你的 <strong>package-lock.json</strong> 出现冲突或问题, 我的建议是将本地的 <strong>package-lock.json</strong>文件删掉, 然后去找远端没有冲突的 <strong>package.json</strong> 和 <strong>package-lock.json</strong>, 再去执行 <code>npm install</code> 命令。</li></ol><h2 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h2><p>回想下 npm3 和 yarn 为什么要做 node_modules 扁平化？不就是因为同样的依赖会复制多次，并且路径过长在 windows 下有问题么？</p><p>那如果不复制呢，比如通过 link。</p><p>首先介绍下 link，也就是软硬连接，这是操作系统提供的机制，硬连接就是同一个文件的不同引用，而软链接是新建一个文件，文件内容指向另一个路径。当然，这俩链接使用起来是差不多的。</p><p>如果不复制文件，只在全局仓库保存一份 npm 包的内容，其余的地方都 link 过去呢？</p><p>这样不会有复制多次的磁盘空间浪费，而且也不会有路径过长的问题。因为路径过长的限制本质上是不能有太深的目录层级，现在都是各个位置的目录的 link，并不是同一个目录，所以也不会有长度限制。</p><p>没错，pnpm 就是通过这种思路来实现的。</p><p>再把 node_modules 删掉，然后用 pnpm 重新装一遍，执行 pnpm install。</p><p>你会发现它打印了这样一句话：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b2d51d9a17743a4bafc42f1bbfd310c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>包是从全局 store 硬连接到虚拟 store 的，这里的虚拟 store 就是 node_modules/.pnpm。</p><p>我们打开 node_modules 看一下：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b4dc807ca6e4ae7a955c8dd6385cb46~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>确实不是扁平化的了，依赖了 express，那 node_modules 下就只有 express，没有幽灵依赖。</p><p>展开 .pnpm 看一下：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65a69589bd534fdd97bdbeb6e3e1024c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>所有的依赖都在这里铺平了，都是从全局 store 硬连接过来的，然后包和包之间的依赖关系是通过软链接组织的。</p><p>比如 .pnpm 下的 expresss，这些都是软链接，</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c50d8dc8a2a4466ba9e5eccd5c15614e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>也就是说，所有的依赖都是从全局 store 硬连接到了 node_modules/.pnpm 下，然后之间通过软链接来相互依赖。</p><p>官方给了一张原理图，配合着看一下就明白了：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/326a2090786e4d16b2d6fce25e876680~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>这就是 pnpm 的实现原理。</p><p>那么回过头来看一下，pnpm 为什么优秀呢？</p><p>首先，最大的优点是节省磁盘空间呀，一个包全局只保存一份，剩下的都是软硬连接，这得节省多少磁盘空间呀。</p><p>其次就是快，因为通过链接的方式而不是复制，自然会快。</p><p>这也是它所标榜的优点：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ba8815b36b3498ea4a3c2248d192bd6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>相比 npm2 的优点就是不会进行同样依赖的多次复制。</p><p>相比 yarn 和 npm3+ 呢，那就是没有幽灵依赖，也不会有没有被提升的依赖依然复制多份的问题。</p><p>这就已经足够优秀了，对 yarn 和 npm 可以说是降维打击。</p><blockquote><p>总结</p></blockquote><p>pnpm 最近经常会听到，可以说是爆火。本文我们梳理了下它爆火的原因：</p><p>npm2 是通过嵌套的方式管理 node_modules 的，会有同样的依赖复制多次的问题。</p><p>npm3+ 和 yarn 是通过铺平的扁平化的方式来管理 node_modules，解决了嵌套方式的部分问题，但是引入了幽灵依赖的问题，并且同名的包只会提升一个版本的，其余的版本依然会复制多次。</p><p>pnpm 则是用了另一种方式，不再是复制了，而是都从全局 store 硬连接到 node_modules/.pnpm，然后之间通过软链接来组织依赖关系。</p><p>这样不但节省磁盘空间，也没有幽灵依赖问题，安装速度还快，从机制上来说完胜 npm 和 yarn。</p><p>pnpm 就是凭借这个对 npm 和 yarn 降维打击的。</p><h1 id="前端发展"><a href="#前端发展" class="headerlink" title="前端发展"></a>前端发展</h1><h2 id="基础框架-工程化"><a href="#基础框架-工程化" class="headerlink" title="基础框架/工程化"></a>基础框架/工程化</h2><p>随着 jQuery.js 渐渐淡出人们的视野，前端开发框架成为了开发人员必不可少的工具，也成为大家最为关注的东西。</p><h3 id="mv-框架"><a href="#mv-框架" class="headerlink" title="mv* 框架"></a>mv* 框架</h3><ul><li>React（Next.js）</li><li>Vue（nuxt.js）</li><li>Svelte</li><li>Angular。</li></ul><p>React 即将发布18版本，vue3 成为vue默认版本，Svelte异军突起。</p><h3 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h3><ul><li><p>传统：Webpack, Rollup, Parcel, Esbuild</p></li><li><p>ESM相关：Snowpack, Vite；</p><p>ESM（ECMAScript modules）的实现：在开发环境编译时，使用 Server 动态编译 + 浏览器的 ESM，基本上实现了“开发环境 0 编译”的功能。而生产环境编译时，则会调用其他编译工具来完成（如 Vite 使用 Rollup）。</p></li></ul><h3 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h3><ul><li>Babel</li><li>Prettier</li><li>ESLint</li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul><li>Tailwind CSS（原子类）</li></ul><h3 id="web3D"><a href="#web3D" class="headerlink" title="web3D"></a>web3D</h3><ul><li>Three.js</li><li>Oasis Engine</li></ul><h3 id="跨端"><a href="#跨端" class="headerlink" title="跨端"></a>跨端</h3><ul><li>React Native</li><li>Flutter</li><li>Weex</li><li>uni-app</li><li>taro</li></ul><h3 id="桌面端"><a href="#桌面端" class="headerlink" title="桌面端"></a>桌面端</h3><ul><li>Tauri（Webview + Rust/.Net/Go）</li><li>electron（Chromium + Nodejs）</li></ul><h3 id="微前端-1"><a href="#微前端-1" class="headerlink" title="微前端"></a>微前端</h3><ul><li>qiankun</li><li>single-spa</li><li>micro-app</li></ul><h3 id="E2E-测试"><a href="#E2E-测试" class="headerlink" title="E2E 测试"></a>E2E 测试</h3><ul><li>cypress（node服务，与程序一起运行）</li><li>puppeteer（无头浏览器）</li></ul><h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>阿特伍德定律：任何可以用 JavaScript 来写的应用，最终都将用 JavaScript 来写。</p><p>随着前端应用大型化、复杂化，TypeScript 肯定会越来越普及。 未来，TypeScript 是否能得到浏览器和 Node.js 原生支持呢？我们一起期待吧。</p><p>前端的同学如果有想学习其他语言的，有如下推荐：</p><ul><li>Rust 是 JS 基础设施的未来 - Lee Robinson</li><li>全栈 —— Go</li><li>AI —— Python</li><li>Flutter —— Dart</li></ul><h2 id="行业趋势"><a href="#行业趋势" class="headerlink" title="行业趋势"></a>行业趋势</h2><h3 id="前端智能化"><a href="#前端智能化" class="headerlink" title="前端智能化"></a>前端智能化</h3><h4 id="低代码（LowCode）"><a href="#低代码（LowCode）" class="headerlink" title="低代码（LowCode）"></a>低代码（LowCode）</h4><p>其实就是早期的搭建系统、组件平台等（宜搭、微搭），这个概念2014年被著名的研究机构Forrester提出。低代码平台的门槛在逐步降低，从专业的技术人员向业务人员进行转变，中国低代码行业比较分散。 <img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dd2669683414107b15822ad63efaee1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="低代码.png"> <img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43da527e12f344adad57672e1d70d9ca~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="低代码1.png"> <img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec2a9071eb684a32b14acad58149fca5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="低代码四象限.jpg"></p><ul><li>其中，OutSystems、Mendix、微软Salesforce、ServiceNow 被评为行业领导者。</li><li>Appian、Oracle 和 Pega 被评为挑战者。</li><li>Creatio、Kintone、Newgen 和 Quickbase 被评为利基（niche）市场参与者。</li><li>今年没有厂商被评为远见者。</li></ul><p>Gartner 预测： “到 2023 年，超过 70% 的企业将采用低代码（LCAP）作为他们发展战略的关键目标之一”。到 2025 年，整体 LCAP（低代码开发平台）市场规模将达到 290 亿美元，年复合增长率超过 20%；其中，LCAP 的细分市场预计将在 2020——2025 年之间，从 44.5 亿美元增长至 143.8 亿美元，复合年增长率为 26.4%。</p><h4 id="代码自动生成"><a href="#代码自动生成" class="headerlink" title="代码自动生成"></a>代码自动生成</h4><p><code>Sketch2Code</code>，AI 将手绘稿子 转换为 html 代码。</p><p><code>imgcook</code>，将Sketch/PSD/图片 转换为 React、Vue、Flutter、小程序等代码。</p><h3 id="大前端（泛前端）"><a href="#大前端（泛前端）" class="headerlink" title="大前端（泛前端）"></a>大前端（泛前端）</h3><p>从切图仔、写 HTML 模板的“石器时代”，到前后端分离、大前端的“工业时代”，再到现在跨端技术、低代码的“电气时代”。前端研发的职责一直在改变，同时前端研发需要掌握的技术也在迭代更新。- 字节前端</p><h4 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h4><p>Serverless 是一种基于云计算的简化方式，基本可以理解为 FaaS（函数即服务）+ BaaS（后端即服务），在 BaaS 层进行存储与计算，在 FaaS 层提供云函数。</p><p>在 Serverless 的赋能之下，前端工程师能够将页面交互、业务逻辑、数据处理等全部掌控在自己的手中，实现了真正全栈的可能。</p><h4 id="全栈"><a href="#全栈" class="headerlink" title="全栈"></a>全栈</h4><p>“全栈开发者”是指“同时掌握前端、后端以及其他网站开发相关技能的开发者”。</p><p>一个“全栈开发者”可能会使用以下技能点：</p><p>前端：JavaScript、H5、CSS3、sass、less、React、Vue、webpack、jest。</p><p>后端：Nodejs/Deno、Go、Java、Spring、Gin、Kafka、Hadoop。</p><p>数据库：MySQL、mongoDB、redis、clickhouse。</p><p>运维：网络协议、CDN、Nginx、ZooKeeper、Docker、Kubernetes。</p><p>值得注意的是，一个优秀的工程师并不是以“栈”数取胜，而取决于你解决了什么层次的问题。</p><blockquote><p>“全栈”或者“专家”仅仅是实现目标的过程状态。吴军在《硅谷来信》中，将工程师划分成五个等级：<img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5426b5c30f5446ee8f10774f39d05266~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="工程师5个等级.png">从工程师能力模型来看，第一级需要集“天时地利人和”大成，是工程师的最高荣誉。普通人或许可以将目标聚焦在第二、三级。优秀的工程师并不是以“栈”数取胜，更重要的是拥有产品观、全局思维、沟通能力、学习能力、解决问题能力等。<a target="_blank" rel="noopener" href="https://juejin.cn/post/7062617190981173278">来源：《来自未来，2022 年的前端人都在做什么?》</a></p></blockquote><h4 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h4><p>DevOps（Development 和 Operations 的组合词）是一种重视“软件开发人员（Dev）”和“IT 运维技术人员（OPS）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。在开发、测试、部署、运维等多个领域进行了共建。</p><p>与 Kubernetes 相结合：Kubernetes 是一种开源容器编排系统，容器技术的日益普及是 DevOps 出现的因素之一。使用 Kubernetes DevOps，软件开发人员和运维团队可以快速实时地相互交换大量的应用程序，大大提高了生产力。 <img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/934be27077824dd2a88ba423479dc6ce~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="DevOps.png"></p><h4 id="微前端-2"><a href="#微前端-2" class="headerlink" title="微前端"></a>微前端</h4><p>微服务架构：微服务架构可以将一个应用分成若干个更小的服务，这让整个开发过程具有很高的敏捷性和可拓展性。</p><p>常用的微前端框架包括 qiankun、single-spa、micro-app</p><blockquote><p>微前端我觉得它其实没有太多的趋势。首先微前端就不是一个大家都要用的。微前端沾了微服务的光，但是微服务是所有后端基本上都要往架构上迁， 微前端很明显不是这样的。它更多的是单页应用并有多框架隔离的需求，然后做出微前端这样一个技术方案。我觉得说实话，微前端就不该这么热，包括很多学生都会问我微前端，我反问你有没有看过微前端解决什么样的问题？如果非要往这上边靠的话，就相当于没有困难创造困难也要上，举个例子，公司一共有四五个前端，就非要用微前端架构，四五个人都可以用不同框架，这其实是没必要的。- 程劭非（winter）</p></blockquote><p>我比较赞同老师说的，我认为一切技术都为了解决某个问题，关键在于我们有没有找准那个关键的问题，是否在解决这个问题。</p><h4 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h4><p>根据winter老师的看法，小程序只是一个前端的技术实现方案，并无大的难点和技术创新，更重要的是看商业模式上的考量。</p><p>解决小程序的跨平台开发问题可以采用框架转换：uni-app（Vue）、taro（React）。</p><h4 id="5G时代"><a href="#5G时代" class="headerlink" title="5G时代"></a>5G时代</h4><p>5G 时代到来，5G将与超高清视频、VR、AR、消费级云计算、智能家居、智慧城市、车联网、物联网、智能制造等产生深度融合，这些都将为前端技术的发展带来新的增长和机遇。WebGL、WebGPU等技术也将迎来一波发展的机会。</p><ul><li><p>Web 3D</p><p>3D 类的 H5 小游戏、在线看房、电子商务、在线教育等，对于技术而言这无疑是一片沃土。随着 5G 技术发展，视频加载速度会非常快，简单的实时渲染会被视频直接替代。复杂的可以通过服务器渲染，将画面传回网页中，只要传输够快，手机的性能就不再是问题。</p><p>相关的一些库：</p><p><code>Three.js</code>、<code>Oasis Engine</code>、<code>Babylon.js</code>、<code>PlayCanvas.js</code></p></li><li><p>WebRTC (Web Real-Time Communications)</p><p>传统的技术包括：XMLHttpRequest，WebSocket，未来：WebRTC 会在点对点私密传输、娱乐领域，元宇宙领域，低延迟领域大放异彩。</p></li></ul><h2 id="底层演进"><a href="#底层演进" class="headerlink" title="底层演进"></a>底层演进</h2><h3 id="前端历年大事件"><a href="#前端历年大事件" class="headerlink" title="前端历年大事件"></a><em>前端历年大事件</em></h3><p><em><code>2021 JavaScript大事件 ↓</code></em></p><p><strong>JavaScript</strong></p><p>8.24： TypeScript 新官网上线</p><p>12.4： JavaScript 26 岁了</p><p><strong>Node.js</strong></p><p>2.2： npm 7.0 正式可用</p><p>3.29： Deno 公司成立</p><p>4.21： Node.js 16 发布</p><p>7.20： Node-RED 2.0 发布，低代码编程工具</p><p>9.20： Node.js 发布 Corepack，用于管理npm、yarn、pnpm、cnpm</p><p>10.19： Node.js 17 发布</p><p><strong>Vue</strong></p><p>8.3： Vue.js 被选作维基百科的前端框架</p><p>8.5： Vue 3.2 发布</p><p>11.24： Pinia 正式成为 vuejs 的一员</p><p><strong>React</strong></p><p>5.28： React 18 alpha 发布</p><p>10.5： React 全新文档发布</p><p>11.27： Next.js 12 发布</p><p>12.14： Create React App 5.0 发布</p><p><strong>打包工具</strong></p><p>2021.1.6 Snowpack 3.0 发布</p><p>2021.2.17 Vite 2.0 发布</p><p>2021.10.13 Parcel v2 发布</p><p><strong>其他</strong></p><p>2021.3.6 jQuery 3.6.0 发布</p><p>2021.3.17 Chrome V8 9.0 发布</p><p>2021.10.7 jQuery Mobile 弃用</p><p>2021.11.4 Angular v13 发布</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>Chrome 一家独大，IE 浏览器将于 2022 年 6 月 15 日正式停用。</p><h3 id="HTML6-0"><a href="#HTML6-0" class="headerlink" title="HTML6.0"></a>HTML6.0</h3><p>支持原生模式、没有 JavaScript 的单页应用程序、自由调整图像大小、专用库、微格式、自定义菜单、增强身份验证、集成摄像头。</p><h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h3><p>WebAssembly 简称 Wasm，是一种可在 Web 中运行的全新语言格式，同时兼具体积小、性能高、可移植性强等特点，在底层上类似 Web 中的 JavaScript，同时也是 W3C 承认的 Web 中的第 4 门语言。</p><p>在前端的游戏、音乐、视频等领域大放异彩，目前很多桌面软件也纷纷通过编译成 Wasm 的形式搬进了浏览器中。</p><p>2022 年 Wasm 功能将会不断完善，同时也会有越来越多的传统 PC 软件推出 Web 版本。</p><h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><p>首次被列入十四五规划，2021年，中国企业积极构建开源平台。根据GitHub统计，中国开发者已成为全球最大规模的开发者群体。</p><h3 id="元宇宙"><a href="#元宇宙" class="headerlink" title="元宇宙"></a>元宇宙</h3><p>游戏、VR/AR、区块链数字资产等等概念的整合。</p><h3 id="web-3-0"><a href="#web-3-0" class="headerlink" title="web 3.0"></a>web 3.0</h3><p>web1.0: 单向信息，只读；web 2.0的标志：User Generated Content（用户生成内容，例如微博、Facebook）；web3.0: 人和网络以及网络与人的沟通。</p><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>在工业4.0的大背景下，随着人工智能、云计算、大数据、物联网、区块链等互联网潮流技术的不断推进，互联网行业走向工业化和智能化。全球疫情的常态化，越来越多的公司选择或者不得不居家办公（WFH），必然给前端行业带来更多的机会。</p><p>2023 年底全球软件开发人员达到 2770万，中国将占6％至8％，前端预计30万左右，而JavaScript 在全球目前约有 1400 万开发者。</p><p>2005左右才出现前端的岗位，变化非常快，目前还是处在发展期（好事儿），只有把握底层变化，不断思辨和学习，才能把焦虑控制在一定范围内。</p><blockquote><p>另外说到“卷”，还是上进心导致的，对吧？真想躺的话，能躺的办法还是挺多的。如果想要进前端的领域，从学习的角度来讲，我推荐 hard way。也就是说，我们看起来最难的那条路反而是最简单的，那些看起来简单的路，它有可能反而是更绕。你想往山顶上走，肯定选择最陡峭的，你想走下坡路，肯定选择最远的那条路。这个道理是是我想今天传达给大家的，原因还是在于看到太多的同学们想走捷径，或者说想走简单的路，结果反而越走越远，最后绕回来的话反而消耗更大。- 程劭非（winter）</p></blockquote><p>最后，小厂前端团队押宝押什么? 押技术落地，押Vue3.0、TS、Three.js，押年轻人！</p><h1 id="实验室"><a href="#实验室" class="headerlink" title="实验室"></a>实验室</h1><p>我的研究方向是自由空间光通信分集接收技术的研究与设计。</p><p><strong>背景</strong></p><p>近年来，自由空间光通信系统因其免频谱许可证、高带宽、低功耗、易部署、高安全性和高指向性等优点被认为是高速宽带连接的下一个前沿领域。由于传统的无线微波通信技术已经不能满足目前卫星通信的需要，加上FSO链路的数据传输速率有了很大的提高，FSO技术在卫星通信系统特别是近地轨道(LEO)卫星对地通信中得到了广泛的关注和应用。然而，它们的性能仍然很大程度上取决于大气通道的连接条件;特别是大气湍流引起的光强闪烁和相位波动会降低接收信号的完整性，导致错误概率增加，限制链路性能，严重时可能导致链路中断。基于强度调制直接探测(IM/DD)的无中继星地激光通信系统由于探测方式的原因，接收机灵敏度较低，当信息速率高达40 Gbps甚至100 Gbps时，接收机灵敏度随着速率和带宽的增加而下降。相干光通信系统由于信号光和本振(LO)光的混合，通常比IM/DD光通信系统具有超过20 dB的额外灵敏度，这是实现LEO卫星对地高速通信的有效手段。然而，由于无中继空间信道的严重损耗，特别是在中等和强湍流下，相干接收系统的功率预算保证非常具有挑战性。因此，以经济有效的方式减少大气湍流效应和提高相干光通信系统的接收机灵敏度是低轨道卫星对地通信的关键目标之一。</p><p>孔径平均可以通过增大接收机孔径大小，自适应光学，信道编码。空间分集利用多个发射/接收分支增加空间自由度，显著降低了深度衰落概率，有效提高了系统性能;然而，这里的主要缺点是系统复杂性的增加。</p><p><strong>创新点</strong></p><p>分集可以有效抑制大气湍流，但会增加系统复杂性，同时相位不同步引起的相对相位差会降低分集系统的性能。 因此，本文提出了基于最优分支块相位校正的空间分集接收，并通过仿真和实验验证，以提高分集增益，有效降低分集系统的复杂度和中断概率。 该方案有望应用于高速近地轨道星地通信。</p><p>大气通道中的湍流以相位波动和振幅畸变(即闪烁)的形式在传播场中引起时变畸变。因此，合并前的一个关键步骤是不同分支之间的相位校正。传统的方案是对每个接收支路进行DSP处理，然后进行合并，对各支路的频率偏移和相位噪声进行补偿，并消除合并前支路之间的rpd。但DSP算法复杂度普遍较高，如果每个分支都需要采用DSP，分集系统的整体复杂度会非常高。假设DSP只考虑频率偏移和相位噪声的估计和补偿。在频偏估计和补偿方面，该方案与传统方案相比没有明显改进。而在传统方案中，相位估计和补偿需要进行M次，其中M为分支数。该方案只需要在obo - bpc后进行一次相位估计和补偿。由于仿真中调制格式为16QAM，因此采用传统的QPSK分割作为相位估计算法进行对比分析，其复杂度在[25]中有提及。对于OB-BPC算法，因为我们只对相位感兴趣，所以在实际操作中，Eq.(14)中的平均值可以用求和来代替，所以每次对相对相位差的估计都需要4B实乘法和4B−2实加法。B为OB-BPC或QPSK分区算法中的块长度。每个arctan(·)可以被认为是一个只读内存(ROM)访问。如表1所示，比较了两种方案相位估计的硬件复杂度。</p><p><strong>仿真</strong></p><p>40 Gbps PM-CO-16QAM FSO空间分集接收仿真平台如图3所示。optilux工具包。</p><p>首先，利用MATLAB软件生成16QAM信号。然后，利用偏振分束器(PBS)将线宽为50 kHz的外腔激光器(ECL)分成两个正交偏振光信号;然后用两个双平行马赫-曾德调制器对两个正交偏振光信号进行调制，生成的四个离散数据信号分别对应X和Y偏振态的实部和虚部。利用偏振光束组合器将两种偏振态的光信号合成为单个信号光束，并集成到计算机模拟的自由空间湍流通道中。</p><p>在模拟中，采用基于傅里叶变换的相位屏模型模拟大气湍流。</p><p>在接收端，光信号被多个接收望远镜接收并耦合到单模光纤中，然后被提供给每个相干接收分支，每个接收望远镜的孔径设置为0.45 m。在相干接收机中，接收到的光场与LO激光混合，利用平衡光电二极管(bpd)完成光电转换过程。LO激光器的输出功率为14 dBm。LO激光器的线宽设置为50 kHz，频率偏移设置为100 MHz。但是，不同支路相干接收机的频率偏移和线宽引入的相位噪声是不一样的。由于频率偏移是一个随时间变化的累积值，线宽引入的相位噪声也随时间变化。在仿真过程中，对不同时刻携带相同信号的不同支路加上由频率偏移和线宽引入的相位噪声，可以生成支路之间的rpd。光电二极管的响应率为0.8 A/W。这里还考虑了炮丸噪声和热噪声。最后，利用ADC对信号进行数字化处理，并在脱机DSP模块中进行处理，包括定时同步、频偏预补偿、obb - bpc、MRC、极化解复用、相位噪声估计、DD-LMS、QAM解映射和误码率计数。</p><p><strong>实验</strong></p><p>为了进一步研究所提出的OB-BPC方案的性能，在不同湍流信道下进行了16QAM时分集接收的离线实验，如图7所示;本文采用PLUTO-2空间光调制器(SLM)模拟湍流通道。由于目前市面上的SLMs对偏振非常敏感，在实验中很难实现偏振复用。此外，大气湍流造成的极化损伤非常小，一般可以通过信道均衡来补偿，这样分集增益与极化无关。首先，使用仿真中使用的相同DSP程序生成16QAM符号，并将实部和虚部对应的I和Q信号发送到最大采样率为12 GSa/s的安捷伦任意波形发生器(WG) M8190A产生基带电信号。这些信号用于驱动光IQ调制器，其中线宽小于100 kHz的激光与光调制器集成在一起;激光载流子中心频率设置为193.400太赫兹。随后，调制器的输出信号光通过望远镜发射到自由空间。</p><p>空间光调制器常被用于模拟大气湍流[31,32]，在原理上，当使用足够数量的平板时，可以准确模拟真实的湍流场景。PLUTO-2 SLM将灰度转换为相位级数据，这些数据反映在光的波前相位中，从而模拟大气湍流效应。</p><p>由于空间分集的实验系统不易建立，提出的方案在时间分集上进行了验证。注意，这里的时间分集是空间分集的等效实现，即M个接收器，只有一个信号传输可以等价于一个接收器，M个重复信号传输，只确保M个分支经历独立衰落。在实验中，每次更新大气湍流灰度图时，接收机接收到一个独立的衰落信号。接收望远镜接收并将信号光耦合到标准单模光纤(SSMF)中，然后使用可变光衰减器(VOA)来调整接收到的光功率。LO激光器工作在193.400太赫兹，线宽小于100 kHz。实验采用富士通FIM24706相干接收机进行相干接收，采用40GSa/s实时采样示波器对光电检测后的信号进行数字化处理，用于离线DSP算法应用。同时同步A WG和示波器的时钟源。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leslie Waong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesliewaong.top/posts/186242d5.html">https://lesliewaong.top/posts/186242d5.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lesliewaong.top" target="_blank">Leslie Waong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/8.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Leslie Waong</div><div class="author-info__description">BUPT</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">122</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lesliewaong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lesliewaong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1138964397&amp;website=www.qtxml.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">红雨漂泊泛起了回忆怎么潜</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML-amp-CSS"><span class="toc-text">HTML&amp;CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%8C%96%E2%98%85"><span class="toc-text">语义化★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#H5%E6%96%B0%E7%89%B9%E6%80%A7%E2%98%85"><span class="toc-text">H5新特性★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E7%9B%92%E6%A8%A1%E5%9E%8B-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E3%80%81%E5%9D%97%E5%85%83%E7%B4%A0%E2%98%85"><span class="toc-text">CSS盒模型 &#x2F; 行内元素、块元素★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E7%9B%92%E5%AD%90-block-box-%E5%92%8C%E5%86%85%E8%81%94%E7%9B%92%E5%AD%90-block-box"><span class="toc-text">块级盒子 (block box) 和内联盒子(block box)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inline%EF%BC%8Cblock%EF%BC%8Cinline-block"><span class="toc-text">inline，block，inline-block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">CSS盒模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%92%8CIE%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-text">标准盒模型和IE盒子模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFC-%E6%B6%88%E9%99%A4%E6%B5%AE%E5%8A%A8%E2%98%85"><span class="toc-text">BFC&#x2F;消除浮动★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E5%86%85%E9%83%A8%E6%B5%AE%E5%8A%A8"><span class="toc-text">包含内部浮动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E9%99%A4%E5%A4%96%E9%83%A8%E6%B5%AE%E5%8A%A8"><span class="toc-text">排除外部浮动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%BE%B9%E8%B7%9D%E9%87%8D%E5%8F%A0"><span class="toc-text">外边距重叠</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flex%E2%98%85"><span class="toc-text">Flex★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-text">容器属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="toc-text">元素属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%E2%98%85"><span class="toc-text">居中布局★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD"><span class="toc-text">水平居中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-text">垂直居中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-text">水平垂直居中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#position%E5%AE%9A%E4%BD%8D-%E2%98%85"><span class="toc-text">position定位 ★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#margin%E4%B8%8Epadding-%E5%8C%85%E5%90%AB%E5%9D%97-%E2%98%85"><span class="toc-text">margin与padding 包含块 ★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7%E2%98%85"><span class="toc-text">CSS选择器优先级★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E6%9D%A1-%E2%98%85"><span class="toc-text">滚动条 ★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E5%8A%A8%E7%94%BB%E2%98%85"><span class="toc-text">CSS动画★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transform"><span class="toc-text">transform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#animation"><span class="toc-text">animation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#keyframes"><span class="toc-text">@keyframes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-duration"><span class="toc-text">animation-duration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-timing-function"><span class="toc-text">animation-timing-function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-delay"><span class="toc-text">animation-delay</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-iteration-count"><span class="toc-text">animation-iteration-count</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-direction"><span class="toc-text">animation-direction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-fill-mode"><span class="toc-text">animation-fill-mode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E5%AD%90"><span class="toc-text">轮子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E2%98%85"><span class="toc-text">自适应布局&#x2F;移动端适配★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%8F%A3"><span class="toc-text">视口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1px%E8%BE%B9%E6%A1%86"><span class="toc-text">1px边框</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#meta%E6%A0%87%E7%AD%BE"><span class="toc-text">meta标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transform-scale-%E7%BC%A9%E6%94%BE"><span class="toc-text">transform: scale()缩放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E5%8D%95%E4%BD%8D"><span class="toc-text">自适应单位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#px"><span class="toc-text">px</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BE%E5%88%86%E6%AF%94"><span class="toc-text">百分比%</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rem"><span class="toc-text">rem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vw%EF%BC%8Cvh"><span class="toc-text">vw，vh</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80"><span class="toc-text">媒体查询&#x2F;响应式布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3"><span class="toc-text">最佳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#min-width-max-width"><span class="toc-text">min-width&#x2F;max-width</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#grid"><span class="toc-text">grid</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%89%87"><span class="toc-text">图片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE"><span class="toc-text">图片缩放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E4%BF%9D%E6%8C%81%E5%8E%9F%E5%A7%8B%E6%AF%94%E4%BE%8B"><span class="toc-text">图片保持原始比例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E4%BC%B8%E7%BC%A9"><span class="toc-text">窗口伸缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%94%B6%E7%BC%A9"><span class="toc-text">侧边栏收缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rgba-vs-opacity-%E2%98%85"><span class="toc-text">rgba vs opacity ★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#opacity"><span class="toc-text">opacity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#background"><span class="toc-text">background</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E6%88%AA%E6%96%AD%E7%9C%81%E7%95%A5%E2%98%85"><span class="toc-text">文本溢出截断省略★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9C%81%E7%95%A5"><span class="toc-text">单行文本溢出省略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9C%81%E7%95%A5%EF%BC%88%E6%8C%89%E8%A1%8C%E6%95%B0%EF%BC%89"><span class="toc-text">多行文本溢出省略（按行数）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%AF-CSS-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-text">纯 CSS 实现方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-JavaScript-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-text">基于 JavaScript 的实现方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85-%E8%BD%AE%E5%AD%90"><span class="toc-text">封装&#x2F;轮子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%AE%9A%E5%AE%BD%E9%AB%98%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E2%98%85"><span class="toc-text">实现一个不定宽高的正方形★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BD%E9%AB%98%E8%AE%BE%E7%BD%AE%E4%B8%BAvw%EF%BC%8Cvh"><span class="toc-text">宽高设置为vw，vh</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%9E%82%E7%9B%B4%E6%96%B9%E5%90%91%E7%9A%84-padding-%E6%92%91%E5%BC%80%E5%AE%B9%E5%99%A8"><span class="toc-text">设置垂直方向的 padding 撑开容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84-margin-padding-top"><span class="toc-text">伪元素的 margin(padding)-top</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lt-img-gt-%E7%9A%84title%E5%92%8Calt%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">&lt;img&gt;的title和alt有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E4%B8%ADlink%E5%92%8C-import%E5%8C%BA%E5%88%AB"><span class="toc-text">CSS中link和@import区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8Bsrc%E4%B8%8Ehref%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">简述一下src与href的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E5%BC%B9%E5%87%BA%E6%A1%86"><span class="toc-text">原生实现弹出框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iframe%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">iframe优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOCTYPE"><span class="toc-text">DOCTYPE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0"><span class="toc-text">CSS隐藏页面元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#less"><span class="toc-text">less</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80"><span class="toc-text">三栏布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E5%8A%A8"><span class="toc-text">浮动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D"><span class="toc-text">绝对定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flexbox%E5%B8%83%E5%B1%80"><span class="toc-text">Flexbox布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80table"><span class="toc-text">表格布局table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80-grid"><span class="toc-text">网格布局 grid</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E6%A1%86"><span class="toc-text">边框</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#border%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-text">border画三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#border-radius"><span class="toc-text">border-radius</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#box-shadow"><span class="toc-text">box-shadow</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%B1%E7%A6%BB%E6%96%87%E6%A1%A3%E6%B5%81"><span class="toc-text">脱离文档流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB-%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-text">伪类&#x2F;伪元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB"><span class="toc-text">伪类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-text">伪元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-meta-%E5%85%83%E7%B4%A0"><span class="toc-text">常用的 meta 元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">页面生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">常见数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-text">树结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-text">队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E2%98%85"><span class="toc-text">递归★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%88%E7%BC%BA%E7%82%B9%EF%BC%89"><span class="toc-text">问题（缺点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BE%E9%80%92%E5%BD%92"><span class="toc-text">尾递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memoization"><span class="toc-text">Memoization</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E2%98%85"><span class="toc-text">数组排序★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E8%87%AA%E5%B8%A6%E6%8E%92%E5%BA%8F"><span class="toc-text">JS自带排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%85%E6%95%B0%E5%AD%97"><span class="toc-text">仅数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">数字&#x2F;字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-%E2%98%85"><span class="toc-text">快速排序 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-text">希尔排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%98%85"><span class="toc-text">动态规划★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-text">斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF-%E2%98%85"><span class="toc-text">爬楼梯 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-text">最大子数组和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">最长递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">打家劫舍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-text">二分法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="toc-text">x 的平方根</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%96%87"><span class="toc-text">回文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-text">最长回文子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E6%95%B0"><span class="toc-text">回文数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E2%98%85"><span class="toc-text">双指针★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E2%98%85"><span class="toc-text">无重复字符的最长子串 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">合并两个有序数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-text">比较版本号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0-%E2%98%85"><span class="toc-text">字符串相加 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-text">最长公共前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%A0%E5%80%92%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-text">颠倒字符串中的单词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-text">移动零</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E2%98%85"><span class="toc-text">栈★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-text">有效的括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">有效的括号字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-text">删除字符串中的所有相邻重复项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E2%98%85"><span class="toc-text">队列★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E2%98%85"><span class="toc-text">哈希★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">两数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II"><span class="toc-text">存在重复元素 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E2%98%85"><span class="toc-text">链表★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E9%93%BE%E8%A1%A8"><span class="toc-text">封装链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-text">环形链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">合并两个有序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text">链表中倒数第k个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E9%9A%8F%E6%9C%BA%E8%8A%82%E7%82%B9-%E2%98%85"><span class="toc-text">链表随机节点 ★</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E2%98%85"><span class="toc-text">树★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E6%A0%91"><span class="toc-text">封装树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的前序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E2%98%85"><span class="toc-text">二叉树的中序遍历 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-text">路径总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="toc-text">求根节点到叶节点数字之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88BFS-%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-text">二叉树的层序遍历（BFS 队列）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88BFS%EF%BC%89"><span class="toc-text">二叉树的最大深度（BFS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%89%8D%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-%E2%98%85"><span class="toc-text">从中序和前序构造二叉树 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-text">二叉树的右视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="toc-text">二叉搜索树的第k大节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-text">买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="toc-text">买卖股票的最佳时机 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-1"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%83%E4%BD%8D%E5%88%86%E9%9A%94%E6%95%B0"><span class="toc-text">千位分隔数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">只出现一次的数字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-text">螺旋矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-text">数组中的第K个最大元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-text">括号生成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%8C%E6%AD%BB%E6%8A%93%E4%B8%89%E7%82%B9"><span class="toc-text">回溯算法，死抓三点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%85%E5%88%86%E5%89%AA%E6%9E%9D%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">充分剪枝的好处</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-text">岛屿数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="toc-text">搜索二维矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU-%E7%BC%93%E5%AD%98%E2%98%85"><span class="toc-text">LRU 缓存★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E6%84%8F"><span class="toc-text">题意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-text">双向链表、哈希表，各自的角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-ListNode-%E8%8A%82%E7%82%B9"><span class="toc-text">定义 ListNode 节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-LRUCache"><span class="toc-text">定义 LRUCache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1-dummyHead-%E5%92%8C-dummyTail-%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">设计 dummyHead 和 dummyTail 的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">get 方法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#put-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">put 方法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81"><span class="toc-text">整体代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E2%98%85"><span class="toc-text">子集★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D%E5%8E%8B%E7%BC%A9%E2%98%85"><span class="toc-text">重复字母压缩★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86"><span class="toc-text">前缀和与差分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E4%B8%BA-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">和为 K 的子数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">计算机网络和浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E2%98%85"><span class="toc-text">计算机网络体系结构★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-text">OSI七层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP"><span class="toc-text">TCP&#x2F;IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BD%91%E7%BB%9C%E8%A6%81%E5%88%86%E5%B1%82%EF%BC%9F"><span class="toc-text">为什么网络要分层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-text">网络通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E2%98%85"><span class="toc-text">URL输入到页面展现★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URL"><span class="toc-text">URL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E8%A7%A3%E6%9E%90"><span class="toc-text">DNS解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E2%98%85"><span class="toc-text">TCP三次握手 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E2%98%85"><span class="toc-text">TCP四次挥手 ★</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%98%85"><span class="toc-text">性能优化★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B"><span class="toc-text">性能检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%B5%84%E6%BA%90%E6%9B%B4%E5%BF%AB%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%EF%BC%9F"><span class="toc-text">如何保证资源更快的加载速度？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-dns-prefetch-%E5%87%8F%E5%B0%91-DNS-%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%97%B6%E9%97%B4"><span class="toc-text">使用 dns-prefetch 减少 DNS 的查询时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-preconnect-%E6%8F%90%E5%89%8D%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-text">使用 preconnect 提前建立连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E8%B5%84%E6%BA%90%E4%BD%93%E7%A7%AF"><span class="toc-text">压缩资源体积</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP-%E5%8E%8B%E7%BC%A9"><span class="toc-text">HTTP 压缩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Webpack-%E5%8E%8B%E7%BC%A9"><span class="toc-text">Webpack 压缩</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%91-http-%E8%AF%B7%E6%B1%82%E6%95%B0%E9%87%8F"><span class="toc-text">减少 http 请求数量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#webpack%E5%AF%B9%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="toc-text">webpack对图片资源进行优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84-cookie"><span class="toc-text">减少不必要的 cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CDN-%E6%89%98%E7%AE%A1%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90-HTTP-%E7%BC%93%E5%AD%98"><span class="toc-text">CDN 托管静态资源 + HTTP 缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E5%8D%87%E7%BA%A7%E4%B8%BA-Http2-0"><span class="toc-text">协议升级为 Http2.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">预加载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%A7%86%E5%9B%BE%E6%9B%B4%E5%BF%AB%E7%9A%84%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BA%A4%E4%BA%92%EF%BC%9F"><span class="toc-text">如何保证视图更快的渲染和交互？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%B1%82%E9%9D%A2"><span class="toc-text">渲染层面</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E9%98%BB%E5%A1%9E%E6%B8%B2%E6%9F%93%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-text">减少阻塞渲染的因素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">懒加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%99%BD%E5%B1%8F%E4%BC%98%E5%8C%96"><span class="toc-text">白屏优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%88server-side-rendering%EF%BC%89"><span class="toc-text">服务端渲染（server-side rendering）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E6%B8%B2%E6%9F%93%EF%BC%88prerender%EF%BC%89"><span class="toc-text">预渲染（prerender）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%B1%82%E9%9D%A2"><span class="toc-text">交互层面</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E5%9B%9E%E6%B5%81-%E9%87%8D%E7%BB%98"><span class="toc-text">减少回流&#x2F;重绘</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81"><span class="toc-text">防抖&#x2F;节流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Web-Worker"><span class="toc-text">Web Worker</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8"><span class="toc-text">虚拟列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0"><span class="toc-text">大文件分片上传</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Excel-%E5%AF%BC%E5%85%A5-%E5%AF%BC%E5%87%BA"><span class="toc-text">Excel 导入&#x2F;导出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BC%98%E5%8C%96-%E2%98%85"><span class="toc-text">React项目的优化 ★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E9%87%8D%E6%96%B0render"><span class="toc-text">尽量避免重新render</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8PureComponent"><span class="toc-text">使用PureComponent</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ShouldComponentUpdate"><span class="toc-text">使用ShouldComponentUpdate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8React-memo"><span class="toc-text">使用React.memo</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8useMemo%E7%BC%93%E5%AD%98%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C"><span class="toc-text">使用useMemo缓存计算结果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8useCallback%E6%9D%A5%E7%BC%93%E5%AD%98%E5%87%BD%E6%95%B0"><span class="toc-text">使用useCallback来缓存函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E6%9D%A5%E9%81%BF%E5%85%8D%E4%B8%AD%E9%97%B4%E7%BB%84%E4%BB%B6%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%B8%B2%E6%9F%93"><span class="toc-text">使用发布订阅模式来避免中间组件不必要的渲染</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E5%B0%86%E7%8A%B6%E6%80%81%E6%94%BE%E5%88%B0%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%EF%BC%88%E7%8A%B6%E6%80%81%E4%B8%8B%E6%96%B9%EF%BC%89"><span class="toc-text">尽量将状态放到子组件中（状态下方）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E7%9A%84%E6%AF%8F%E4%B8%AAitem%E5%8A%A0%E4%B8%8Akey%E5%B1%9E%E6%80%A7"><span class="toc-text">列表的每个item加上key属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E5%87%8F%E5%B0%91%E8%A6%81%E6%B8%B2%E6%9F%93%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">尽量减少要渲染的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">组件懒加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8"><span class="toc-text">使用虚拟列表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%B7%BB%E5%8A%A0%E9%A2%9D%E5%A4%96%E7%9A%84DOM"><span class="toc-text">避免添加额外的DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8React-fragment%E6%9D%A5%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84div"><span class="toc-text">使用React.fragment来避免不必要的div</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E2%98%85"><span class="toc-text">HTTP&#x2F;浏览器缓存★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B"><span class="toc-text">缓存类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98%E3%80%81%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-text">强缓存、协商缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%8F%91%E5%B1%95"><span class="toc-text">缓存发展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E6%96%B0"><span class="toc-text">刷新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E2%98%85"><span class="toc-text">浏览器解析渲染★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#script%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7%E2%98%85"><span class="toc-text">script标签属性★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#async"><span class="toc-text">async</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer"><span class="toc-text">defer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%BB%98-%E5%9B%9E%E6%B5%81%E2%98%85"><span class="toc-text">重绘&#x2F;回流★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%B5%81-%E9%87%8D%E6%8E%92reflow"><span class="toc-text">回流&#x2F;重排reflow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BB%98Repaint"><span class="toc-text">重绘Repaint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81-%E9%87%8D%E7%BB%98"><span class="toc-text">避免回流&#x2F;重绘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#display%EF%BC%9Anone%E5%92%8Cvisibility%EF%BC%9Ahidden%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">display：none和visibility：hidden的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-UDP%E2%98%85"><span class="toc-text">TCP UDP★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-text">TCP 协议如何保证可靠传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">TCP 如何实现流量控制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">TCP 的拥塞控制是怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARQ-%E5%8D%8F%E8%AE%AE%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-text">ARQ 协议了解吗?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85-ARQ-%E5%8D%8F%E8%AE%AE"><span class="toc-text">停止等待 ARQ 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD-ARQ-%E5%8D%8F%E8%AE%AE"><span class="toc-text">连续 ARQ 协议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E2%98%85"><span class="toc-text">HTTP★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81-%E2%98%85"><span class="toc-text">HTTP状态码 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E6%96%B9%E6%B3%95"><span class="toc-text">HTTP方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GET-%E4%B8%8E-POST-%E2%98%85"><span class="toc-text">GET 与 POST ★</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F"><span class="toc-text">参数传递方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E4%B8%8D%E5%90%8C"><span class="toc-text">参数长度限制不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%92%8C%E5%B9%82%E7%AD%89"><span class="toc-text">安全和幂等</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8D%E5%90%8C%EF%BC%88%E4%BC%A0%E8%BE%93%E7%9A%84%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="toc-text">安全性不同（传输的角度）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%B8%8D%E5%90%8C"><span class="toc-text">缓存机制不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%B6%88%E8%80%97%E4%B8%8D%E5%90%8C"><span class="toc-text">时间消耗不同</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HEAD"><span class="toc-text">HEAD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUT"><span class="toc-text">PUT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DELETE"><span class="toc-text">DELETE</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%A4%B4%E9%83%A8"><span class="toc-text">HTTP头部</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Accept"><span class="toc-text">Accept</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Connection"><span class="toc-text">Connection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Keep-Alive"><span class="toc-text">Keep-Alive</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%89%B9%E6%80%A7"><span class="toc-text">HTTP特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS-%E2%98%85"><span class="toc-text">HTTP和HTTPS ★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E4%BC%98%E7%82%B9"><span class="toc-text">HTTPS优点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86"><span class="toc-text">混合加密</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-text">数字证书</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95"><span class="toc-text">摘要算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E8%BF%9E%E6%8E%A5"><span class="toc-text">HTTPS连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="toc-text">中间人攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81ca%E8%AF%81%E4%B9%A6%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7"><span class="toc-text">浏览器如何验证ca证书的有效性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1%E3%80%81HTTP-2%E3%80%81HTTP-3%E6%BC%94%E5%8F%98-%E2%98%85"><span class="toc-text">HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3演变 ★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-1"><span class="toc-text">HTTP&#x2F;1.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-2"><span class="toc-text">HTTP&#x2F;2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-3"><span class="toc-text">HTTP&#x2F;3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HSTS"><span class="toc-text">HSTS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%8A%AB%E6%8C%81"><span class="toc-text">中间人劫持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E7%94%A8-HSTS"><span class="toc-text">启用 HSTS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#307-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">307 状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HSTS-%E5%AD%98%E5%9C%A8%E7%9A%84%E5%9D%91"><span class="toc-text">HSTS 存在的坑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AB%AF%E5%8F%A3%E5%8F%B7%E6%9C%80%E5%A4%A7%E4%B8%BA65535%EF%BC%9F%E2%98%85"><span class="toc-text">为什么端口号最大为65535？★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E2%98%85"><span class="toc-text">跨域通信★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90-%E8%B7%A8%E5%9F%9F"><span class="toc-text">同源&#x2F;跨域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">跨域解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSONP%EF%BC%88JSON-with-Padding%EF%BC%89"><span class="toc-text">JSONP（JSON with Padding）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS"><span class="toc-text">CORS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-text">简单请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82"><span class="toc-text">复杂请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ECORS%E7%9A%84-cookie-%E9%97%AE%E9%A2%98"><span class="toc-text">关于CORS的 cookie 问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CORS%E5%AE%8C%E6%95%B4%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">CORS完整复杂请求的例子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86"><span class="toc-text">代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Node%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-text">Node中间件代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#React%E4%B8%AD%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86"><span class="toc-text">React中配置代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">Nginx反向代理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocket"><span class="toc-text">WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90"><span class="toc-text">简单例子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#postMessage"><span class="toc-text">postMessage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90-1"><span class="toc-text">简单例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie%E3%80%81sessionStorage%E3%80%81localStorage%E2%98%85"><span class="toc-text">Cookie、sessionStorage、localStorage★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie"><span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#localStorage-amp-amp-sessionStorage"><span class="toc-text">localStorage &amp;&amp; sessionStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IndexedDB"><span class="toc-text">IndexedDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT"><span class="toc-text">Cookie、Session、Token、JWT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XSS%E5%92%8CCSRF"><span class="toc-text">XSS和CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS"><span class="toc-text">XSS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%98%B2%E8%8C%83%E6%96%B9%E6%B3%95"><span class="toc-text">常用防范方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#csp%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5"><span class="toc-text">csp内容安全策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF"><span class="toc-text">CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CSRF%E4%B8%8E-XSS-%E5%8C%BA%E5%88%AB"><span class="toc-text">CSRF与 XSS 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1"><span class="toc-text">防御</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%81%E8%AE%B8%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E8%B5%84%E6%BA%90%E6%95%B0%E2%98%85"><span class="toc-text">浏览器允许的并发请求资源数★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E5%AE%9A%E6%9C%9F%E5%90%91%E5%89%8D%E7%AB%AF%E6%8E%A8%E9%80%81%E6%95%B0%E6%8D%AE%E2%98%85"><span class="toc-text">后端定期向前端推送数据★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E2%98%85"><span class="toc-text">浏览器多个标签之间通信★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#localStorage%E5%AE%9E%E7%8E%B0%E9%80%9A%E4%BF%A1"><span class="toc-text">localStorage实现通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8websocket"><span class="toc-text">使用websocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SharedWorker"><span class="toc-text">SharedWorker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8cookie-setInterval"><span class="toc-text">使用cookie + setInterval</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ping%E2%98%85"><span class="toc-text">Ping★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E2%98%85"><span class="toc-text">服务端渲染★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B2%E6%9F%93"><span class="toc-text">什么是渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-text">传统的服务端渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">实现原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-text">客户端渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E5%8C%96%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-text">现代化的服务端渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">分析优缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%EF%BC%9A"><span class="toc-text">相关技术：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#JacaScript"><span class="toc-text">JacaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OOP%E2%98%85"><span class="toc-text">OOP★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AF%94"><span class="toc-text">其他语言对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB-vs-%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-text">基于类 vs 基于原型的语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-text">构造函数模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B-%E7%B1%BB-%E6%A8%A1%E5%BC%8F"><span class="toc-text">原型(类)模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%B8%B8%E7%94%A8%E4%BD%9C%E5%B0%81%E8%A3%85%E7%B1%BB%EF%BC%89"><span class="toc-text">混合模式（常用作封装类）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E2%98%85"><span class="toc-text">继承★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-text">原型链继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">借用构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-text">寄生组合式继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES6%E7%B1%BB%E7%BB%A7%E6%89%BFextends"><span class="toc-text">ES6类继承extends</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E2%98%85"><span class="toc-text">原型与原型链★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Js%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88%E2%98%85"><span class="toc-text">Js中的堆栈★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%8C%BA"><span class="toc-text">栈区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%8C%BA"><span class="toc-text">堆区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E2%98%85"><span class="toc-text">垃圾回收★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-text">引用计数算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">标记清除算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V8%E5%AF%B9GC%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">V8对GC的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%83%85%E5%86%B5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">常见内存泄露情况及解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E5%A4%96%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">意外的全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dom"><span class="toc-text">dom</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-text">事件监听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">解决内存泄漏的数据结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%98%85"><span class="toc-text">数据类型★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1"><span class="toc-text">7+1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-text">类型判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof"><span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceof"><span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-prototype-toString-call-toString-call"><span class="toc-text">Object.prototype.toString.call()&#x2F;toString.call()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84"><span class="toc-text">判断数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#amp-%E2%98%85"><span class="toc-text">&#x3D;&#x3D;&#x3D; &amp; &#x3D;&#x3D;★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-is"><span class="toc-text">Object.is()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E2%98%85"><span class="toc-text">数组★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E2%98%85"><span class="toc-text">JS数组常用方法总结★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-text">实例属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-text">实例方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E5%8F%8A%E6%89%8B%E5%86%99%E2%98%85"><span class="toc-text">常见遍历方法及手写★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E3%80%81for%E2%80%A6in%E5%92%8Cfor%E2%80%A6of%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">for、for…in和for…of有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forEach"><span class="toc-text">forEach</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map"><span class="toc-text">map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#filter"><span class="toc-text">filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#some"><span class="toc-text">some</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find"><span class="toc-text">find</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reduce"><span class="toc-text">reduce</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-text">性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E2%98%85"><span class="toc-text">数组去重★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BA%A4-%E5%B9%B6%E9%9B%86%E2%98%85"><span class="toc-text">数组交&#x2F;并集★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%B1%E5%BA%A6%E2%98%85"><span class="toc-text">求数组的深度★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%E2%98%85"><span class="toc-text">如何实现数组扁平化★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flat-depth"><span class="toc-text">flat(depth)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%95%B0%E7%BB%84-set%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84"><span class="toc-text">类数组&#x2F;set转化为数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84shuffle%E2%98%85"><span class="toc-text">随机打乱数组shuffle★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">获取数组最大值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E5%AF%B9%E8%B1%A1%E2%98%85"><span class="toc-text">Object对象★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-text">查询对象上的属性和遍历对象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">查询对象上的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#in"><span class="toc-text">in</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hasOwnProperty-NaN"><span class="toc-text">hasOwnProperty()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Js%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1"><span class="toc-text">Js遍历对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#for-in"><span class="toc-text">for in</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Object-keys"><span class="toc-text">Object.keys</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Object-getOwnPropertyNames"><span class="toc-text">Object.getOwnPropertyNames</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Object-getOwnPropertySymbols"><span class="toc-text">Object.getOwnPropertySymbols</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Reflect-ownKeys"><span class="toc-text">Reflect.ownKeys</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-assign"><span class="toc-text">Object.assign</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-create"><span class="toc-text">Object.create</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-defineProperties"><span class="toc-text">Object.defineProperties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-defineProperty"><span class="toc-text">Object.defineProperty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-freeze"><span class="toc-text">Object.freeze</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-is-1"><span class="toc-text">Object.is</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E2%98%85"><span class="toc-text">String★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BF%E9%97%AE"><span class="toc-text">字符访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">基本字符串和字符串对象的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E6%96%87%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">长文字字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F-%E2%98%85"><span class="toc-text">模板字面量 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F"><span class="toc-text">拼接字符串？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-%E8%BF%90%E7%AE%97%E7%AC%A6%E6%9D%A5%E6%8B%BC%E6%8E%A5"><span class="toc-text">使用+运算符来拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8concat-%E6%96%B9%E6%B3%95"><span class="toc-text">使用concat()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Array-join-%E6%96%B9%E6%B3%95"><span class="toc-text">使用Array.join()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E7%89%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88Template-literals%EF%BC%89"><span class="toc-text">使用模版字符串（Template literals）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E4%B8%80%E4%B8%8B%E6%80%A7%E8%83%BD"><span class="toc-text">比较一下性能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93%E2%98%85"><span class="toc-text">DOM事件总结★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BA%A7%E5%88%AB"><span class="toc-text">DOM事件的级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B-%E6%8D%95%E8%8E%B7-%E5%86%92%E6%B3%A1"><span class="toc-text">DOM事件模型 捕获&#x2F;冒泡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81-api-%E6%96%B9%E6%B3%95"><span class="toc-text">Event对象的常见 api 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%BB%A3%E7%90%86%EF%BC%89"><span class="toc-text">事件委托（代理）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E4%BA%8B%E4%BB%B6"><span class="toc-text">常用事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax%E2%98%85"><span class="toc-text">Ajax★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9FAjax"><span class="toc-text">原生Ajax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fetch"><span class="toc-text">Fetch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%E2%98%85"><span class="toc-text">作用域与闭包★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81-%E2%98%85"><span class="toc-text">防抖&#x2F;节流 ★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%8A%96"><span class="toc-text">防抖</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E7%AB%8B%E5%8D%B3%E9%98%B2%E6%8A%96"><span class="toc-text">非立即防抖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E9%98%B2%E6%8A%96"><span class="toc-text">立即防抖</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E6%B5%81"><span class="toc-text">节流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text">时间戳</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8-1"><span class="toc-text">定时器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%AF%E9%87%8C%E5%8C%96-%E2%98%85"><span class="toc-text">柯里化 ★</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD%E2%98%85"><span class="toc-text">下载功能★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-text">实现方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%A1%88"><span class="toc-text">其他方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#form%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4"><span class="toc-text">form表单提交</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#open%E6%88%96location-href"><span class="toc-text">open或location.href</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-3"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#a%E6%A0%87%E7%AD%BE%E7%9A%84download"><span class="toc-text">a标签的download</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-4"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Blob%E5%AF%B9%E8%B1%A1"><span class="toc-text">利用Blob对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-5"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-4"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8base64"><span class="toc-text">利用base64</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-6"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-5"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-text">关于文件名</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Content-Disposition"><span class="toc-text">Content-Disposition</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89header"><span class="toc-text">自定义header</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D"><span class="toc-text">重命名</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E5%A4%A7%E6%96%87%E4%BB%B6"><span class="toc-text">下载大文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#function%E4%B8%8E%E6%84%9F%E5%8F%B9%E5%8F%B7"><span class="toc-text">function与感叹号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C1%E2%80%9D-%E2%80%9D2%E2%80%9D-%E2%80%9D3%E2%80%9D-map-parseInt-%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-text">[“1”,”2”,”3”].map(parseInt)的输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Number"><span class="toc-text">Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Js%E4%B8%ADDate%E5%AF%B9%E8%B1%A1"><span class="toc-text">Js中Date对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON%E6%95%B0%E6%8D%AE%E5%B1%95%E7%A4%BA"><span class="toc-text">JSON数据展示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4"><span class="toc-text">复制粘贴</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#react"><span class="toc-text">react</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F"><span class="toc-text">原生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E5%BA%93"><span class="toc-text">第三方的库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC-1"><span class="toc-text">事件监听</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#copy-%E4%BA%8B%E4%BB%B6"><span class="toc-text">copy 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cut-%E4%BA%8B%E4%BB%B6"><span class="toc-text">cut 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#paste-%E4%BA%8B%E4%BB%B6"><span class="toc-text">paste 事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#innerText%E3%80%81textContent%E5%92%8CinnerHTML"><span class="toc-text">innerText、textContent和innerHTML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Node-textContent"><span class="toc-text">Node.textContent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8EinnerText%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与innerText的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8EinnerHTML%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与innerHTML的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Js%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-text">Js选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#getElementById"><span class="toc-text">getElementById</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getElementsByClassName"><span class="toc-text">getElementsByClassName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getElementsByName"><span class="toc-text">getElementsByName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getElementsByTagName"><span class="toc-text">getElementsByTagName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#querySelector"><span class="toc-text">querySelector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#querySelectorAll"><span class="toc-text">querySelectorAll</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arguments"><span class="toc-text">arguments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eval"><span class="toc-text">eval</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">创建正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8"><span class="toc-text">常用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">正则表达式的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">字符串和正则相关的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-text">严格模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AST-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91"><span class="toc-text">AST 抽象语法树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES6"><span class="toc-text">ES6+</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E2%98%85"><span class="toc-text">模块化★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let%E3%80%81const%E5%92%8Cvar%E2%98%85"><span class="toc-text">let、const和var★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#var"><span class="toc-text">var</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#let"><span class="toc-text">let</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-text">const</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class%E4%B8%8E%E7%BB%A7%E6%89%BF%E2%98%85"><span class="toc-text">Class与继承★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B0%83%E7%94%A8"><span class="toc-text">类定义与调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">严格模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="toc-text">构造函数与方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-%E5%AD%97%E6%AE%B5"><span class="toc-text">属性&#x2F;字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set-Map-%E2%98%85"><span class="toc-text">Set&#x2F;Map ★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakSet"><span class="toc-text">WeakSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakMap"><span class="toc-text">WeakMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E2%98%85"><span class="toc-text">Promise★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise%E6%A6%82%E5%BF%B5"><span class="toc-text">Promise概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E6%97%A7%E5%BC%8F%E5%9B%9E%E8%B0%83%E7%9B%B8%E6%AF%94"><span class="toc-text">与旧式回调相比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81-%E8%AF%AD%E6%B3%95"><span class="toc-text">状态&#x2F;语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">原型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#then-onFulfilled-onRejected"><span class="toc-text">then(onFulfilled, onRejected)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#catch-onRejected"><span class="toc-text">catch(onRejected)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finally-onFinally"><span class="toc-text">finally(onFinally)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-all-iterable-%E2%98%85"><span class="toc-text">Promise.all(iterable) ★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-race-iterable"><span class="toc-text">Promise.race(iterable)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-resolve-value"><span class="toc-text">Promise.resolve(value)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-reject-reason"><span class="toc-text">Promise.reject(reason)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-allSettled-iterable"><span class="toc-text">Promise.allSettled(iterable)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Async-await-%E2%98%85"><span class="toc-text">Async&#x2F;await ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promiseTimeout-%E2%98%85"><span class="toc-text">promiseTimeout ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E5%AE%9E%E7%8E%B0-sleep-%E5%87%BD%E6%95%B0"><span class="toc-text">js实现 sleep 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%89%88"><span class="toc-text">普通版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8-2"><span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-%E7%89%88%E6%9C%AC"><span class="toc-text">Promise 版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Async-Await-%E7%89%88%E6%9C%AC"><span class="toc-text">Async&#x2F;Await 版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E5%BF%98%E4%BA%86%E5%BC%80%E6%BA%90%E7%9A%84%E5%8A%9B%E9%87%8F"><span class="toc-text">不要忘了开源的力量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95%E3%80%81%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-text">展开语法、剩余参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-text">解构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigInt"><span class="toc-text">BigInt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol"><span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">Iterator 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator%E5%87%BD%E6%95%B0"><span class="toc-text">Generator函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-text">实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E4%BD%A0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AA%E8%83%BD%E8%A2%ABnew%E8%B0%83%E7%94%A8%EF%BC%8C%E8%80%8C%E4%B8%8D%E8%83%BD%E8%A2%AB%E6%99%AE%E9%80%9A%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-text">如何确保你的构造函数只能被new调用，而不能被普通调用？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%8E%E7%A1%AE%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%8C%E9%87%8D%E7%94%A8%E9%80%94"><span class="toc-text">明确函数的双重用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-instanceof-%E5%AE%9E%E7%8E%B0"><span class="toc-text">使用 instanceof 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E7%BB%91%E5%AE%9A-%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A"><span class="toc-text">new 绑定&#x2F; 默认绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-target"><span class="toc-text">new.target</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ES6-Class"><span class="toc-text">使用ES6 Class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-target-%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">new.target 实现抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%AE%9E%E7%8E%B0"><span class="toc-text">抽象类实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81"><span class="toc-text">手写代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E2%98%85"><span class="toc-text">深拷贝★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E9%93%BA%E6%95%B0%E7%BB%84-lt-gt-%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E2%98%85"><span class="toc-text">平铺数组&lt;&#x3D;&gt;树形结构★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E2%98%85"><span class="toc-text">new★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setTimeout%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0setInterval-%E2%98%85"><span class="toc-text">setTimeout模拟实现setInterval ★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Event-Bus%EF%BC%88%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%EF%BC%89%E2%98%85"><span class="toc-text">Event Bus（事件总线）★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95"><span class="toc-text">简单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6"><span class="toc-text">进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%97%B6%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-text">1. 如何在发送消息时传递参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%A2%E9%98%85%E5%90%8E%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85"><span class="toc-text">2. 订阅后如何取消订阅</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%8F%AA%E8%AE%A2%E9%98%85%E4%B8%80%E6%AC%A1"><span class="toc-text">3. 如何只订阅一次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E6%9F%90%E4%B8%AA%E4%BA%8B%E4%BB%B6%E6%88%96%E8%80%85%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6"><span class="toc-text">4. 如何清除某个事件或者所有事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0-1-add-2-add-3-%E2%98%85"><span class="toc-text">手写实现(1).add(2).add(3) ★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-create-1"><span class="toc-text">Object.create()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof-1"><span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9F%A5%E7%9C%8B%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9"><span class="toc-text">树的遍历查看祖先节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">树的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%9A%84%E7%88%B6%E8%8A%82%E7%82%B9"><span class="toc-text">查看所有的父节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9%E7%9A%84%E6%89%80%E6%9C%89%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9"><span class="toc-text">查找某个指定节点的所有祖先节点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React%E2%98%85"><span class="toc-text">React★</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E5%A5%BD%E5%A4%84"><span class="toc-text">框架好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-vs-Vue-%E2%98%85"><span class="toc-text">React vs Vue ★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#immutable"><span class="toc-text">immutable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#immutable-js"><span class="toc-text">immutable.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8React%E4%B8%AD%E5%BA%94%E7%94%A8"><span class="toc-text">在React中应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E2%98%85"><span class="toc-text">函数式编程 ★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%98%AF%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91"><span class="toc-text">函数是一等公民</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-text">声明式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E5%92%8C%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-text">无状态和数据不可变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-text">没有副作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E5%87%BD%E6%95%B0"><span class="toc-text">纯函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1-%E2%98%85"><span class="toc-text">设计 ★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E8%AE%BE%E8%AE%A1%E5%A5%BD%E7%9A%84-UI-%E5%88%92%E5%88%86%E4%B8%BA%E7%BB%84%E4%BB%B6%E5%B1%82%E7%BA%A7"><span class="toc-text">将设计好的 UI 划分为组件层级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-React-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E7%89%88%E6%9C%AC"><span class="toc-text">用 React 创建一个静态版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A-UI-state-%E7%9A%84%E6%9C%80%E5%B0%8F%EF%BC%88%E4%B8%94%E5%AE%8C%E6%95%B4%EF%BC%89%E8%A1%A8%E7%A4%BA"><span class="toc-text">确定 UI state 的最小（且完整）表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A-state-%E6%94%BE%E7%BD%AE%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">确定 state 放置的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%8F%8D%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-text">添加反向数据流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84-HTML"><span class="toc-text">语义化的 HTML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2"><span class="toc-text">代码分割</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8C%85"><span class="toc-text">打包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2-1"><span class="toc-text">代码分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#import"><span class="toc-text">import()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-lazy"><span class="toc-text">React.lazy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%85%9C%E5%BA%95"><span class="toc-text">避免兜底</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E8%BE%B9%E7%95%8C%EF%BC%88Error-boundaries%EF%BC%89"><span class="toc-text">异常捕获边界（Error boundaries）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2"><span class="toc-text">基于路由的代码分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E5%AF%BC%E5%87%BA%EF%BC%88Named-Exports%EF%BC%89"><span class="toc-text">命名导出（Named Exports）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Context"><span class="toc-text">Context</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-Context"><span class="toc-text">何时使用 Context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Context-%E4%B9%8B%E5%89%8D%E7%9A%84%E8%80%83%E8%99%91"><span class="toc-text">使用 Context 之前的考虑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E8%BE%B9%E7%95%8C"><span class="toc-text">错误边界</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E8%BE%B9%E7%95%8C%EF%BC%88Error-Boundaries%EF%BC%89"><span class="toc-text">错误边界（Error Boundaries）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E8%BE%B9%E7%95%8C%E5%BA%94%E8%AF%A5%E6%94%BE%E7%BD%AE%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="toc-text">错误边界应该放置在哪？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF%EF%BC%88Uncaught-Errors%EF%BC%89%E7%9A%84%E6%96%B0%E8%A1%8C%E4%B8%BA"><span class="toc-text">未捕获错误（Uncaught Errors）的新行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-try-catch-%EF%BC%9F"><span class="toc-text">关于 try&#x2F;catch ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">关于事件处理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-Render-Props"><span class="toc-text">高阶组件 &#x2F; Render Props</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E9%95%BF%E5%88%97%E8%A1%A8"><span class="toc-text">虚拟化长列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E8%B0%83%E5%81%9C"><span class="toc-text">避免调停</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%97%E6%8E%A7%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-text">受控与非受控组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-text">受控组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-text">非受控组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-text">合成事件&#x2F;事件处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSX"><span class="toc-text">JSX</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM-%E2%98%85"><span class="toc-text">虚拟DOM ★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0"><span class="toc-text">原生实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-Fiber"><span class="toc-text">React Fiber</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Fiber-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%9A%84"><span class="toc-text">Fiber 如何解决问题的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fiber-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">Fiber 实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diff-%E7%AE%97%E6%B3%95-%E5%8D%8F%E8%B0%83"><span class="toc-text">diff 算法&#x2F;协调</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Keys"><span class="toc-text">Keys</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E7%BB%84%E4%BB%B6%E2%98%85"><span class="toc-text">两种组件★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F"><span class="toc-text">函数式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%BC%8F"><span class="toc-text">类式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-text">条件渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#State-%E2%98%85"><span class="toc-text">State ★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9-State"><span class="toc-text">不要直接修改 State</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#State%E6%9B%B4%E6%96%B0%E5%8F%AF%E8%83%BD%E5%BC%82%E6%AD%A5"><span class="toc-text">State更新可能异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#State%E6%9B%B4%E6%96%B0%E4%BC%9A%E5%90%88%E5%B9%B6"><span class="toc-text">State更新会合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%91%E4%B8%8B%E6%B5%81%E5%8A%A8%E7%9A%84"><span class="toc-text">数据是向下流动的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Refs"><span class="toc-text">Refs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B-1"><span class="toc-text">声明式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ref%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">Ref使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ref%E7%94%A8%E6%B3%95"><span class="toc-text">Ref用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Refs"><span class="toc-text">创建 Refs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-Refs"><span class="toc-text">访问 Refs</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">React组件通信如何实现?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E2%98%85"><span class="toc-text">React 生命周期 ★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hooks-%E7%BB%84%E4%BB%B6"><span class="toc-text">Hooks 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">单个组件的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD"><span class="toc-text">挂载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0"><span class="toc-text">更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD"><span class="toc-text">卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-text">常用的生命周期方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#constructor-props"><span class="toc-text">constructor(props)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#componentDidMount"><span class="toc-text">componentDidMount()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#componentDidUpdate-prevProps-prevState-snapshot"><span class="toc-text">componentDidUpdate(prevProps, prevState, snapshot)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#componentWillUnmount"><span class="toc-text">componentWillUnmount()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-text">不常用的生命周期方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#shouldComponentUpdate-nextProps-nextState"><span class="toc-text">shouldComponentUpdate(nextProps, nextState)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hook%E2%98%85"><span class="toc-text">Hook★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E2%98%85"><span class="toc-text">优势★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook-%E8%A7%84%E5%88%99"><span class="toc-text">Hook 规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E5%9C%A8%E6%9C%80%E9%A1%B6%E5%B1%82%E4%BD%BF%E7%94%A8-Hook"><span class="toc-text">只在最顶层使用 Hook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E5%9C%A8-React-%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8-Hook"><span class="toc-text">只在 React 函数中调用 Hook</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useState-%E2%98%85"><span class="toc-text">useState ★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%A6%81"><span class="toc-text">概要</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%83%BD%E7%94%A8%E5%85%B6%E4%BB%96%E7%8A%B6%E6%80%81%E8%AE%A1%E7%AE%97%E5%87%BA%E6%9D%A5%E5%B0%B1%E4%B8%8D%E7%94%A8%E5%8D%95%E7%8B%AC%E5%A3%B0%E6%98%8E%E7%8A%B6%E6%80%81-%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%94%AF%E4%B8%80"><span class="toc-text">能用其他状态计算出来就不用单独声明状态 &#x2F; 保证数据源唯一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#useState-%E9%80%82%E5%BD%93%E5%90%88%E5%B9%B6"><span class="toc-text">useState 适当合并</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%9B%B4%E6%96%B0"><span class="toc-text">函数式更新</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B-state"><span class="toc-text">惰性初始 state</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%B3%E8%BF%87-state-%E6%9B%B4%E6%96%B0"><span class="toc-text">跳过 state 更新</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useEffect-%E2%98%85"><span class="toc-text">useEffect ★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E9%9C%80%E6%B8%85%E9%99%A4%E7%9A%84-effect"><span class="toc-text">无需清除的 effect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B8%85%E9%99%A4%E7%9A%84-effect"><span class="toc-text">需要清除的 effect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-1"><span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA-Effect-%E5%AE%9E%E7%8E%B0%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB"><span class="toc-text">使用多个 Effect 实现关注点分离</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%B7%B3%E8%BF%87-Effect-%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">通过跳过 Effect 进行性能优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E7%9A%84-effect-%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A2%91%E7%B9%81%E5%8F%98%E5%8C%96%EF%BC%8C%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">如果我的 effect 的依赖频繁变化，我该怎么办？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%90%86%E8%A7%A3"><span class="toc-text">自己理解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useRef-%E2%98%85"><span class="toc-text">useRef ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useCallback-%E2%98%85"><span class="toc-text">useCallback ★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">关于使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useMemo-%E2%98%85"><span class="toc-text">useMemo ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useImperativeHandle"><span class="toc-text">useImperativeHandle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useContext-%E2%98%85"><span class="toc-text">useContext ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useReducer"><span class="toc-text">useReducer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89hook"><span class="toc-text">自定义hook</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-memo"><span class="toc-text">React.memo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#React-PureComponent"><span class="toc-text">React.PureComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-memo-1"><span class="toc-text">React.memo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS-%E2%98%85"><span class="toc-text">CSS ★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BB%84%E4%BB%B6%E5%86%85%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8"><span class="toc-text">在组件内直接使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%BC%95%E5%85%A5css%E6%96%87%E4%BB%B6"><span class="toc-text">组件中引入css文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%BC%95%E5%85%A5-module-css-%E6%96%87%E4%BB%B6"><span class="toc-text">组件中引入 .module.css 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-in-JS"><span class="toc-text">CSS in JS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React-Router%E2%98%85"><span class="toc-text">React-Router★</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#v5-vs-v6-%E2%98%85"><span class="toc-text">v5 vs v6 ★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SPA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">SPA的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-text">基础使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">路由参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#param%E5%8F%82%E6%95%B0"><span class="toc-text">param参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#search%E5%8F%82%E6%95%B0-amp-sate%E5%8F%82%E6%95%B0"><span class="toc-text">search参数&amp;sate参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v5-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E2%98%85"><span class="toc-text">v5 底层原理 ★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#react-router-dom%E5%92%8Creact-router%E5%92%8Chistory%E5%BA%93%E4%B8%89%E8%80%85%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-text">react-router-dom和react-router和history库三者什么关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-text">两种模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#history%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-text">history模式原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E8%B7%AF%E7%94%B1"><span class="toc-text">改变路由</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E8%B7%AF%E7%94%B1"><span class="toc-text">监听路由</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-text">hash模式原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E8%B7%AF%E7%94%B1-1"><span class="toc-text">改变路由</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E8%B7%AF%E7%94%B1-1"><span class="toc-text">监听路由</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Router%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F-%E2%98%85"><span class="toc-text">Router两种模式 ★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Router%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86"><span class="toc-text">Router内部原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BrowserRouter"><span class="toc-text">BrowserRouter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashRouter"><span class="toc-text">HashRouter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v6%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">v6底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%89%88-Route-%E8%AE%BE%E8%AE%A1"><span class="toc-text">新版 Route 设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E5%B1%82%E5%AE%B9%E5%99%A8%EF%BC%8C%E6%9B%B4%E6%96%B0%E6%BA%90%E6%B3%89-BrowserRouter-HashRouter-%EF%BD%9C-Router"><span class="toc-text">外层容器，更新源泉 BrowserRouter | HashRouter ｜ Router</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%EF%BC%8CRoutes-%E5%92%8C-branch-%E6%A6%82%E5%BF%B5"><span class="toc-text">原理深入，Routes 和 branch 概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Route-%E5%92%8C-Routes-%E5%BD%A2%E6%88%90%E8%B7%AF%E7%94%B1%E7%BB%93%E6%9E%84"><span class="toc-text">Route 和 Routes 形成路由结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Routes-%E5%92%8C-useRoutes"><span class="toc-text">Routes 和 useRoutes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#matchRoutes-%E5%92%8C-renderMatches-%E6%B8%B2%E6%9F%93%E8%B7%AF%E7%94%B1%E5%88%86%E6%94%AF"><span class="toc-text">matchRoutes 和 _renderMatches 渲染路由分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%9B%B4%E6%96%B0%E5%88%B0%E5%AF%B9%E5%BA%94%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%B1%95%E7%A4%BA%E6%B5%81%E7%A8%8B"><span class="toc-text">路由更新到对应组件渲染展示流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v5-%E5%92%8C-v6-%E5%8C%BA%E5%88%AB"><span class="toc-text">v5 和 v6 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%8B%A6%E6%88%AA%E2%98%85"><span class="toc-text">路由拦截★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%EF%BC%88%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-text">登录拦截（简单实现）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prompt"><span class="toc-text">prompt</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%BD%A2%E5%BC%8F"><span class="toc-text">简单形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Prompt%E7%9A%84message%E7%9A%84function%E5%BD%A2%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%8F%90%E7%A4%BA%E6%A0%B7%E5%BC%8F"><span class="toc-text">使用Prompt的message的function形式实现自定义的提示样式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Router%E7%9A%84getUserConfirmation%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%90%E7%A4%BA%E6%A0%B7%E5%BC%8F"><span class="toc-text">使用Router的getUserConfirmation实现自定义提示样式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redux%E2%98%85"><span class="toc-text">Redux★</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redux"><span class="toc-text">redux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">工作流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">三个核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#action"><span class="toc-text">action</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reducer"><span class="toc-text">reducer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#store"><span class="toc-text">store</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android%E8%AF%8D%E5%85%B8"><span class="toc-text">Android词典</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E7%88%AC%E5%8F%96"><span class="toc-text">单词数据的爬取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1"><span class="toc-text">界面设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API%E6%88%96SDK"><span class="toc-text">API或SDK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM"><span class="toc-text">MVVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-MVC"><span class="toc-text">Android MVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-MVVM"><span class="toc-text">Android MVVM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%9A%E5%AE%A2"><span class="toc-text">博客</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E2%98%85"><span class="toc-text">商城后台管理系统★</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E5%B7%A5%E7%A8%8B%E5%8C%96-%E2%98%85"><span class="toc-text">模块化、组件化、工程化 ★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">工程化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="toc-text">组件化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2"><span class="toc-text">界面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2"><span class="toc-text">登录界面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB"><span class="toc-text">预加载动画</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Antd-v3%E5%8D%87%E7%BA%A7%E6%88%90v4"><span class="toc-text">Antd v3升级成v4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%BB%E9%99%A4-Form-create"><span class="toc-text">去除 Form.create</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E6%8E%A7%E5%88%B6%E8%B0%83%E6%95%B4"><span class="toc-text">表单控制调整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onFinish-%E6%9B%BF%E4%BB%A3-onSubmit"><span class="toc-text">onFinish 替代 onSubmit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-text">数据可视化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-text">功能实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E2%98%85"><span class="toc-text">用户登录和权限管理★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%A1%E9%AA%8C"><span class="toc-text">输入校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E5%92%8CAjax"><span class="toc-text">跨域和Ajax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E9%80%9A%E4%BF%A1"><span class="toc-text">父子通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83"><span class="toc-text">发布</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GitHub-Pages%E5%8F%91%E5%B8%83%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2"><span class="toc-text">GitHub Pages发布静态页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96"><span class="toc-text">项目优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89hook%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E9%98%B2%E6%8A%96"><span class="toc-text">自定义hook实现搜索防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E5%90%8E%E7%88%B6%E7%BA%A7%E8%8F%9C%E5%8D%95%E7%9A%84%E5%B1%95%E5%BC%80%E9%97%AE%E9%A2%98"><span class="toc-text">刷新后父级菜单的展开问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HR%E9%9D%A2"><span class="toc-text">HR面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D%E3%80%81%E9%9A%BE%E7%82%B9%E3%80%81%E6%94%B6%E8%8E%B7"><span class="toc-text">项目介绍、难点、收获</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9"><span class="toc-text">难点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%E4%B8%8E%E4%B8%8D%E8%B6%B3"><span class="toc-text">收获与不足</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E5%88%92"><span class="toc-text">规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E7%9A%84%E5%9B%B0%E9%9A%BE"><span class="toc-text">遇到的困难</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B-%E6%88%90%E7%BB%A9-%E8%8E%B7%E5%A5%96%E6%83%85%E5%86%B5-%E7%AB%9E%E8%B5%9B"><span class="toc-text">课程&#x2F;成绩&#x2F;获奖情况&#x2F;竞赛</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E7%BB%8F%E5%8E%86%E7%9A%84%E6%9C%80%E5%A4%A7%E6%8C%AB%E6%8A%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">你经历的最大挫折是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-%E7%AB%9E%E4%BA%89%E5%8A%9B"><span class="toc-text">优缺点 竞争力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-7"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-6"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E5%B9%B3%E6%97%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%9A%84%EF%BC%9F"><span class="toc-text">你平时是怎么学习的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%8E%A5%E8%A7%A6%E5%89%8D%E7%AB%AF%E7%9A%84-%E4%B8%BA%E5%95%A5%E5%AD%A6%E5%89%8D%E7%AB%AF"><span class="toc-text">你什么时候接触前端的&#x2F;为啥学前端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%97%A0%E6%84%8F%E5%90%91offer"><span class="toc-text">有无意向offer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%83%85%E5%95%86%E8%B7%9F%E8%81%8C%E5%95%86"><span class="toc-text">情商跟职商</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%8E%E5%B8%82"><span class="toc-text">城市</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B1%E5%A5%BD"><span class="toc-text">爱好</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%85%AC%E5%8F%B8%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%9F%E4%B8%BA%E5%95%A5%E9%80%89"><span class="toc-text">对公司的了解？为啥选</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C"><span class="toc-text">完美世界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E7%AB%99"><span class="toc-text">B站</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8E%E4%B8%BA"><span class="toc-text">华为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BD%E5%AE%B6%E7%94%B5%E6%8A%95"><span class="toc-text">国家电投</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%85%B4"><span class="toc-text">中兴</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%9F%E6%9C%9B%E8%96%AA%E8%B5%84"><span class="toc-text">期望薪资</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BE%8E%E5%9B%A2"><span class="toc-text">美团</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8E%E4%B8%BA-1"><span class="toc-text">华为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b%E7%AB%99"><span class="toc-text">b站</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%85%B4-1"><span class="toc-text">中兴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E"><span class="toc-text">完美</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B6%E5%BA%AD-%E5%8D%95%E8%BA%AB"><span class="toc-text">家庭&#x2F;单身</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%9F%E6%9C%9B%E7%9A%84%E5%9B%A2%E9%98%9F"><span class="toc-text">期望的团队</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E7%8F%AD"><span class="toc-text">加班</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85-toB-%E4%B8%8E-toC"><span class="toc-text">如何看待 toB 与 toC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E9%97%AE"><span class="toc-text">反问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF"><span class="toc-text">技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E7%AE%A1%E9%9D%A2%E5%8F%8D%E9%97%AE"><span class="toc-text">主管面反问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E9%9D%A2%E5%8F%8D%E9%97%AE"><span class="toc-text">技术面反问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HR"><span class="toc-text">HR</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SaaS%E3%80%81IaaS%E3%80%81PaaS%E3%80%81iPaaS%E5%92%8CaPaaS"><span class="toc-text">SaaS、IaaS、PaaS、iPaaS和aPaaS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SaaS%E3%80%81IaaS%E3%80%81PaaS"><span class="toc-text">SaaS、IaaS、PaaS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iPaaS%E5%92%8CaPaaS"><span class="toc-text">iPaaS和aPaaS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E8%87%AA%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-text">各自功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%81%8F%E9%87%8D%E7%82%B9%EF%BC%9A"><span class="toc-text">技术偏重点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-text">使用对象：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E2%98%85"><span class="toc-text">进程和线程★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B"><span class="toc-text">进程、线程和协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84"><span class="toc-text">浏览器是多进程的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">进程间通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E2%98%85"><span class="toc-text">虚拟内存★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%81%E2%98%85"><span class="toc-text">常见的锁★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%9A%E8%B0%81%E6%9B%B4%E8%BD%BB%E6%9D%BE%E8%87%AA%E5%A6%82%EF%BC%9F"><span class="toc-text">互斥锁与自旋锁：谁更轻松自如？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%9A%E8%AF%BB%E5%92%8C%E5%86%99%E8%BF%98%E6%9C%89%E4%BC%98%E5%85%88%E7%BA%A7%E5%8C%BA%E5%88%86%EF%BC%9F"><span class="toc-text">读写锁：读和写还有优先级区分？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9A%E5%81%9A%E4%BA%8B%E7%9A%84%E5%BF%83%E6%80%81%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">乐观锁与悲观锁：做事的心态有何不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux"><span class="toc-text">Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E5%8D%95%E5%88%86%E7%B1%BB"><span class="toc-text">操作系统简单分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows"><span class="toc-text">Windows</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unix"><span class="toc-text">Unix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-1"><span class="toc-text">Linux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mac-OS"><span class="toc-text">Mac OS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E6%A0%B8%EF%BC%88Kernel%EF%BC%89"><span class="toc-text">操作系统的内核（Kernel）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88CPU%EF%BC%8CCentral-Processing-Unit%EF%BC%89"><span class="toc-text">中央处理器（CPU，Central Processing Unit）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-vs-Kernel-%E5%86%85%E6%A0%B8"><span class="toc-text">CPU vs Kernel(内核)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E6%8E%A2-Linux"><span class="toc-text">初探 Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E7%AE%80%E4%BB%8B"><span class="toc-text">Linux 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E8%AF%9E%E7%94%9F"><span class="toc-text">Linux 诞生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81-Linux-%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">常见 Linux 发行版本有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A7%88"><span class="toc-text">Linux 文件系统概览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B"><span class="toc-text">Linux 文件系统简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inode-%E4%BB%8B%E7%BB%8D"><span class="toc-text">inode 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-text">Linux 文件类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E7%9B%AE%E5%BD%95%E6%A0%91"><span class="toc-text">Linux 目录树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">Linux 基本命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E5%88%87%E6%8D%A2%E5%91%BD%E4%BB%A4"><span class="toc-text">目录切换命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-text">目录的操作命令(增删改查)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-text">文件的操作命令(增删改查)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">压缩文件的操作命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E7%9A%84%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4"><span class="toc-text">Linux 的权限命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="toc-text">Linux 用户管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E7%BB%84%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-text">Linux 系统用户组的管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">其他常用命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">Linux 环境变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%88%86%E7%B1%BB"><span class="toc-text">环境变量分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">读取环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%BF%AE%E6%94%B9"><span class="toc-text">环境变量修改</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript%E2%98%85"><span class="toc-text">TypeScript★</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-vs-JS-%E2%98%85"><span class="toc-text">TS vs JS ★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-text">类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-vs-interface-%E2%98%85"><span class="toc-text">type vs interface ★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-text">重写和重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React"><span class="toc-text">React</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E2%98%85"><span class="toc-text">数据库★</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Webpack%E2%98%85"><span class="toc-text">Webpack★</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-1"><span class="toc-text">概要</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-text">背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-1"><span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7"><span class="toc-text">高级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">webpack 核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Entry"><span class="toc-text">Entry</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Output"><span class="toc-text">Output</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Module"><span class="toc-text">Module</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chunk"><span class="toc-text">Chunk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Loader"><span class="toc-text">Loader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Plugin"><span class="toc-text">Plugin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Loader%E5%92%8CPlugin%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Loader和Plugin的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loader-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">loader 执行顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack-%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">webpack 构建流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#entry-options-%E5%90%AF%E5%8A%A8"><span class="toc-text">entry-options 启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#run-%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">run 实例化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%9E%84%E5%BB%BA"><span class="toc-text">编译构建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#entry-%E7%A1%AE%E5%AE%9A%E5%85%A5%E5%8F%A3"><span class="toc-text">entry 确定入口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#make-%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9D%97"><span class="toc-text">make 编译模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#build-module-%E5%AE%8C%E6%88%90%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91"><span class="toc-text">build module 完成模块编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#seal-%E8%BE%93%E5%87%BA%E8%B5%84%E6%BA%90"><span class="toc-text">seal 输出资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#emit-%E8%BE%93%E5%87%BA%E5%AE%8C%E6%88%90"><span class="toc-text">emit 输出完成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7-1"><span class="toc-text">高级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#source-map%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">source map是什么？生产环境怎么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack-%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86%E5%90%A7"><span class="toc-text">Webpack 的热更新原理吧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-Webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%EF%BC%9F"><span class="toc-text">如何优化 Webpack 的构建速度？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89%E5%91%A2%EF%BC%9F"><span class="toc-text">代码分割的本质是什么？有什么意义呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Babel%E5%8E%9F%E7%90%86"><span class="toc-text">Babel原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="toc-text">模块化工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Rollup"><span class="toc-text">Rollup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parcel"><span class="toc-text">Parcel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Snowpack"><span class="toc-text">Snowpack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vite"><span class="toc-text">Vite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack"><span class="toc-text">webpack</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81%E2%98%85"><span class="toc-text">调试代码★</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4"><span class="toc-text">调试一般步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%98%AF%E5%90%A6%E6%8A%A5%E9%94%99"><span class="toc-text">检查控制台是否报错</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BD%95%E7%A7%8D%E9%94%99%E8%AF%AF"><span class="toc-text">是何种错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E8%AF%B7%E6%B1%82%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">当前页面是否需要请求获取数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F%E5%8F%91%E9%80%81"><span class="toc-text">网络请求是否成功发送</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E5%88%B0%E4%BB%A3%E7%A0%81%E5%BA%94%E5%BD%93%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%88%E5%A4%A7%E6%A6%82%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-text">定位到代码应当执行的位置（大概即可）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E9%A2%84%E6%9C%9F%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81"><span class="toc-text">按照预期执行顺序检查代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%B8%B2%E6%9F%93%E9%9C%80%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E4%B8%8E%E9%A2%84%E6%9C%9F%E7%9B%B8%E5%90%8C"><span class="toc-text">检查渲染需要的数据是否与预期相同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BB%A3%E7%A0%81%E4%B8%80%E8%88%AC%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-text">异常代码一般分析方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#console"><span class="toc-text">console</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%89%93%E5%8D%B0"><span class="toc-text">基本打印</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#console-log"><span class="toc-text">console.log()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#console-warn"><span class="toc-text">console.warn()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#console-error"><span class="toc-text">console.error()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#console-info"><span class="toc-text">console.info()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%97%B6%E9%97%B4"><span class="toc-text">打印时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#console-time-amp-console-timeEnd"><span class="toc-text">console.time() &amp; console.timeEnd()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#console-timeLog"><span class="toc-text">console.timeLog()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E6%89%93%E5%8D%B0"><span class="toc-text">分组打印</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#console-group-amp-console-groupEnd"><span class="toc-text">console.group() &amp; console.groupEnd()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#console-groupCollapsed"><span class="toc-text">console.groupCollapsed()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E8%AE%A1%E6%AC%A1"><span class="toc-text">打印计次</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#console-count"><span class="toc-text">console.count()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#console-countReset"><span class="toc-text">console.countReset()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%89%93%E5%8D%B0"><span class="toc-text">其他打印</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#console-table"><span class="toc-text">console.table()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#console-clear"><span class="toc-text">console.clear()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#console-trace"><span class="toc-text">console.trace()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-Devtools"><span class="toc-text">React Devtools</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-text">控制台</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5"><span class="toc-text">语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%BF%E6%8D%B7%E6%8A%80%E5%B7%A7"><span class="toc-text">便捷技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%9C%E4%B8%BA%E8%AF%AD%E5%8F%A5"><span class="toc-text">表达式作为语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5"><span class="toc-text">React中的实践</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E9%A2%98"><span class="toc-text">输出题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-text">this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%8C%87%E5%90%91%E2%98%85"><span class="toc-text">this指向★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call%E3%80%81apply%E3%80%81bind%E2%98%85"><span class="toc-text">call、apply、bind★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#call"><span class="toc-text">call</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#apply"><span class="toc-text">apply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bind"><span class="toc-text">bind</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87"><span class="toc-text">变量提升和函数提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82"><span class="toc-text">函数传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E5%90%8D%E9%97%AE%E9%A2%98"><span class="toc-text">同名问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-text">变量和函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E5%86%85%E5%8F%98%E9%87%8F%E9%87%8D%E5%90%8D"><span class="toc-text">全局变量和函数内变量重名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E9%87%8D%E5%90%8D"><span class="toc-text">局部变量、函数和函数形参重名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E2%98%85"><span class="toc-text">事件循环★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%98%85"><span class="toc-text">事件循环机制★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">JavaScript执行机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83"><span class="toc-text">异步回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Event-Loop"><span class="toc-text">Event Loop</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-text">Node事件循环</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Git%E2%98%85"><span class="toc-text">Git★</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E5%91%BD%E5%90%8D"><span class="toc-text">分支命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VSCode"><span class="toc-text">VSCode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pull-Request"><span class="toc-text">Pull Request</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E5%AE%9A%E5%BC%8F%E6%8F%90%E4%BA%A4-1-0-0"><span class="toc-text">约定式提交 1.0.0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-%E4%B8%AD%E7%9A%84%E6%92%A4%E9%94%80"><span class="toc-text">Git 中的撤销</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E6%9C%80%E8%BF%91%E5%87%A0%E6%AC%A1-commit"><span class="toc-text">撤销最近几次 commit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6-commit"><span class="toc-text">合并 commit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%AA%E5%8A%A8-commit"><span class="toc-text">挪动 commit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3"><span class="toc-text">冲突解决</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E2%98%85"><span class="toc-text">微前端★</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">微前端到底是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E3%80%81%E6%9D%BE%E8%80%A6%E5%90%88%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BA%93"><span class="toc-text">简单、松耦合的代码库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%8D%87%E7%BA%A7"><span class="toc-text">增量升级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E9%83%A8%E7%BD%B2"><span class="toc-text">独立部署</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%A2%E9%98%9F%E8%87%AA%E6%B2%BB"><span class="toc-text">团队自治</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88-1"><span class="toc-text">实现方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A-Bundle-%E9%9B%86%E6%88%90"><span class="toc-text">多 Bundle 集成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9B%86%E6%88%90"><span class="toc-text">服务端集成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%97%B6%E9%9B%86%E6%88%90"><span class="toc-text">构建时集成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%9B%86%E6%88%90"><span class="toc-text">运行时集成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%B1%E5%93%8D%E9%9A%94%E7%A6%BB"><span class="toc-text">影响隔离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%A4%8D%E7%94%A8"><span class="toc-text">资源复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">应用间通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-7"><span class="toc-text">缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E8%B4%9F%E6%8B%85"><span class="toc-text">流量负担</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C-%E7%AE%A1%E7%90%86%E4%B8%8A%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="toc-text">操作&#x2F;管理上的复杂性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC"><span class="toc-text">微前端的核心价值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#steamer"><span class="toc-text">steamer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E8%A1%8C%E4%B8%9A%E5%BD%93%E4%B8%8B%E9%9D%A2%E4%B8%B4%E7%9A%84%E8%A7%84%E6%A8%A1%E9%97%AE%E9%A2%98"><span class="toc-text">前端行业当下面临的规模问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF"><span class="toc-text">微前端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">相关概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%BC%8F%E4%BB%8D%E7%84%B6%E5%AD%98%E5%9C%A8%E6%8C%91%E6%88%98"><span class="toc-text">微前端模式仍然存在挑战</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85%E2%98%85"><span class="toc-text">请求封装★</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#index-tsx"><span class="toc-text">index.tsx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#index-less"><span class="toc-text">index.less</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="toc-text">下载文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E8%AF%B7%E6%B1%82"><span class="toc-text">封装请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E8%AF%B7%E6%B1%82"><span class="toc-text">发请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80loading"><span class="toc-text">全局loading</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-2"><span class="toc-text">概要</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">什么是设计模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">为什么会有设计模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">为什么需要设计模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">如何使用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-text">设计模式分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">什么时候用策略模式？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E2%98%85"><span class="toc-text">发布订阅★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">发布-订阅模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">什么时候用发布-订阅模式？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">装饰器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">装饰器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">适配器模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">什么时候用代理模式？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-text">责任链模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">责任链模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">什么时候使用责任链模式？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Node-js%E2%98%85"><span class="toc-text">Node.js★</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"><span class="toc-text">全局对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-text">应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-text">包管理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#npm-yarn-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">npm&#x2F;yarn 常用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#npm-yarn%E5%8C%BA%E5%88%AB%E2%98%85"><span class="toc-text">npm yarn区别★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A9%E6%9C%9F%E7%9A%84npm"><span class="toc-text">早期的npm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#npm%E7%9A%84%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E5%92%8C%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-text">npm的安装机制和核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#npm%E7%9A%84%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6"><span class="toc-text">npm的安装机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yarn%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="toc-text">yarn的出现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#yarn%E7%9A%84%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6"><span class="toc-text">yarn的安装机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#npm%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-text">npm的缓存机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#npm-or-yarn-%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%B8%80%E7%82%B9%E7%96%91%E6%83%91"><span class="toc-text">npm or yarn 开发中的一点疑惑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81lockfiles-%E8%A6%81%E4%B8%8D%E8%A6%81%E6%8F%90%E4%BA%A4lockfiles%E5%88%B0%E4%BB%93%E5%BA%93%EF%BC%9F"><span class="toc-text">为什么要lockfiles,要不要提交lockfiles到仓库？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-xxxDependencies"><span class="toc-text">为什么会有 xxxDependencies?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E8%A7%84%E8%8C%83%E2%80%94%E2%80%94%E4%BE%9D%E8%B5%96%E5%BA%93%E9%94%81%E7%89%88%E6%9C%AC%E8%A1%8C%E4%B8%BA%E8%A7%A3%E6%9E%90"><span class="toc-text">版本规范——依赖库锁版本行为解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%96%E8%AE%B8%E6%98%AF%E6%9C%80%E4%BD%B3%E7%9A%84%E5%AE%9E%E6%93%8D%E5%BB%BA%E8%AE%AE"><span class="toc-text">或许是最佳的实操建议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pnpm"><span class="toc-text">pnpm</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95"><span class="toc-text">前端发展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6-%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">基础框架&#x2F;工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mv-%E6%A1%86%E6%9E%B6"><span class="toc-text">mv* 框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7"><span class="toc-text">打包工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83"><span class="toc-text">语法规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS"><span class="toc-text">CSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web3D"><span class="toc-text">web3D</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E7%AB%AF"><span class="toc-text">跨端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%8C%E9%9D%A2%E7%AB%AF"><span class="toc-text">桌面端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF-1"><span class="toc-text">微前端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E2E-%E6%B5%8B%E8%AF%95"><span class="toc-text">E2E 测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80"><span class="toc-text">语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF"><span class="toc-text">行业趋势</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%99%BA%E8%83%BD%E5%8C%96"><span class="toc-text">前端智能化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8E%E4%BB%A3%E7%A0%81%EF%BC%88LowCode%EF%BC%89"><span class="toc-text">低代码（LowCode）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90"><span class="toc-text">代码自动生成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%89%8D%E7%AB%AF%EF%BC%88%E6%B3%9B%E5%89%8D%E7%AB%AF%EF%BC%89"><span class="toc-text">大前端（泛前端）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Serverless"><span class="toc-text">Serverless</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E6%A0%88"><span class="toc-text">全栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DevOps"><span class="toc-text">DevOps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF-2"><span class="toc-text">微前端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="toc-text">小程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5G%E6%97%B6%E4%BB%A3"><span class="toc-text">5G时代</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%BC%94%E8%BF%9B"><span class="toc-text">底层演进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%8E%86%E5%B9%B4%E5%A4%A7%E4%BA%8B%E4%BB%B6"><span class="toc-text">前端历年大事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">浏览器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML6-0"><span class="toc-text">HTML6.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebAssembly"><span class="toc-text">WebAssembly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%BA%90"><span class="toc-text">开源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E5%AE%87%E5%AE%99"><span class="toc-text">元宇宙</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web-3-0"><span class="toc-text">web 3.0</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%AE%A4"><span class="toc-text">实验室</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/66c016fb.html" title="JVM"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/10.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="JVM"></a><div class="content"><a class="title" href="/posts/66c016fb.html" title="JVM">JVM</a><time datetime="2022-10-07T06:46:20.000Z" title="发表于 2022-10-07 14:46:20">2022-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ff54bd4f.html" title="JS垃圾回收"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/3.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="JS垃圾回收"></a><div class="content"><a class="title" href="/posts/ff54bd4f.html" title="JS垃圾回收">JS垃圾回收</a><time datetime="2022-10-07T03:01:02.000Z" title="发表于 2022-10-07 11:01:02">2022-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f7ede91d.html" title="Java基础"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/2.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="Java基础"></a><div class="content"><a class="title" href="/posts/f7ede91d.html" title="Java基础">Java基础</a><time datetime="2022-10-01T08:46:40.000Z" title="发表于 2022-10-01 16:46:40">2022-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f0caaae4.html" title="TS中那些奇怪的符号"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/2.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="TS中那些奇怪的符号"></a><div class="content"><a class="title" href="/posts/f0caaae4.html" title="TS中那些奇怪的符号">TS中那些奇怪的符号</a><time datetime="2022-07-10T03:12:48.000Z" title="发表于 2022-07-10 11:12:48">2022-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6155a9d6.html" title="Axios"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/1.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="Axios"></a><div class="content"><a class="title" href="/posts/6155a9d6.html" title="Axios">Axios</a><time datetime="2022-07-05T08:42:42.000Z" title="发表于 2022-07-05 16:42:42">2022-07-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Leslie Waong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:""},null))},e=()=>{twikoo.getCommentsCount({envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))},n=(n=!1)=>{"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})};btf.loadComment(document.getElementById("twikoo-wrap"),n)})()</script></div><div class="aplayer no-destroy" data-id="6995412795" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="auto" data-autoplay="true" muted></div><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":0,"vOffset":0},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body></html>