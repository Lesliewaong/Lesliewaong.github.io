<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>农发行 | Leslie Waong</title><meta name="keywords" content="前端 Java 空间光通信"><meta name="author" content="Leslie Waong"><meta name="copyright" content="Leslie Waong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="农发行自我介绍面试官们好，我叫王吉晨，是北京邮电大学一名研三的学生，预计今年六月份毕业。下面我就介绍一下我的项目、实习和科研经历。 本科时，我基于Android平台实现了一个电子词典APP，其中词典的离线数据使用Python爬取并保存在SQLite数据库中，并基于Android Studio完成界面设计和功能实现，主要开发语言是Java，通过这个项目主要是积累了开发经验。 后来研究生阶段利用空闲时"><meta property="og:type" content="article"><meta property="og:title" content="农发行"><meta property="og:url" content="https://lesliewaong.top/posts/afb4a817.html"><meta property="og:site_name" content="Leslie Waong"><meta property="og:description" content="农发行自我介绍面试官们好，我叫王吉晨，是北京邮电大学一名研三的学生，预计今年六月份毕业。下面我就介绍一下我的项目、实习和科研经历。 本科时，我基于Android平台实现了一个电子词典APP，其中词典的离线数据使用Python爬取并保存在SQLite数据库中，并基于Android Studio完成界面设计和功能实现，主要开发语言是Java，通过这个项目主要是积累了开发经验。 后来研究生阶段利用空闲时"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/3.webp"><meta property="article:published_time" content="2023-01-01T08:46:41.000Z"><meta property="article:modified_time" content="2023-02-23T12:12:58.820Z"><meta property="article:author" content="Leslie Waong"><meta property="article:tag" content="前端 Java 空间光通信"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/3.webp"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg"><link rel="canonical" href="https://lesliewaong.top/posts/afb4a817"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"一年之内的产物",messageNext:"技术可能存在过期"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Leslie Waong",link:"链接: ",source:"来源: Leslie Waong",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"农发行",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-02-23 20:12:58"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px");const a=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};a(),document.addEventListener("pjax:complete",a)})(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Leslie Waong" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">122</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li><li><a class="site-page child" href="/item/test/"><i class="fa-fw fa fa-star"></i><span> test</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/3.webp)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leslie Waong</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li><li><a class="site-page child" href="/item/test/"><i class="fa-fw fa fa-star"></i><span> test</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">农发行</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-01T08:46:41.000Z" title="发表于 2023-01-01 16:46:41">2023-01-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-23T12:12:58.820Z" title="更新于 2023-02-23 20:12:58">2023-02-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%9E%E6%8A%80%E6%9C%AF%E9%9D%A2/">非技术面</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">66.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>204分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="农发行"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="农发行"><a href="#农发行" class="headerlink" title="农发行"></a>农发行</h1><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>面试官们好，我叫王吉晨，是北京邮电大学一名研三的学生，预计今年六月份毕业。下面我就介绍一下我的项目、实习和科研经历。</p><p>本科时，我基于Android平台实现了一个电子词典APP，其中词典的离线数据使用Python爬取并保存在SQLite数据库中，并基于Android Studio完成界面设计和功能实现，主要开发语言是Java，通过这个项目主要是积累了开发经验。</p><p>后来研究生阶段利用空闲时间系统学习了前端的相关知识，框架主要是学习了React。基于React自己做了一个后台管理系统的项目，通过这个项目熟悉了前后端分离的开发模式，以及模块化、组件化、工程化的开发理念。</p><p>去年暑期时在美团实习，基于组内的微前端研发平台，实现MBR报表的线上化，通过这个项目熟悉了整个开发流程，从需求分析、方案设计、代码开发，再到联调测试，主要工作是实现MBR产品的前台页面和管理后台的展示与交互功能。</p><p>实验室的研究方向为自由空间光通信系统空间分集接收方案研究与设计，通过Matlab搭建了自由空间光通信分集接收仿真平台，并进行了离线实验验证，在该方向下成功发表了一篇二区SCI，凭借这篇论文也是获得了去年的研究生国奖。</p><p>我认为我的优势一是技术视野开阔，喜欢钻研，具有良好的学习能力；二是注重团队合作，有着强烈的责任心和高度执行力，力争每次都能按时保质地交付手中的任务；另外具备一定抗压能力，应对实验室或公司中时间紧任务重的情况，能够从容进行任务的分级与梳理，积极沟通协调，同时调整生活和工作上的平衡。</p><p>我的自我介绍就是这样。希望有机会能够加入贵公司!谢谢！</p><h2 id="科研"><a href="#科研" class="headerlink" title="科研"></a>科研</h2><p>我的研究方向是自由空间光通信分集接收技术的研究与设计，主要包括以下三点内容：</p><ul><li>针对FSO通信系统中大气湍流带来的光纤耦合损耗问题，对空间光耦合进单模光纤进行理论分析，结合相位屏理论搭建基于光纤耦合的空间信道仿真模型，并从湍流强度、传输距离和接收孔径等方面对光纤耦合空间分集系统性能进行仿真研究。</li><li>针对FSO空间分集各支路存在相对相位差的问题，提出一种基于最优支路的分块相位校正算法，能够有效地补偿支路间的相对相位差，降低系统整体复杂度并易于实现。通过40 Gbps PM-16QAM-FSO空间分集接收系统仿真和5GBaud 16QAM离线实验，完成对所提方案在FSO通信中的有效性和可靠性验证。</li><li>常用的频偏估计算法与FSO空间分集系统结合使用时整体复杂度较高，同时帧同步对各支路合并及基于训练序列的频偏估计算法也至关重要，基于上述问题提出一种基于帧同步训练序列的两级载波频偏估计算法，保证帧同步准确性的前提下完成频偏估计，在训练序列长度较小的情况下也能获得较高的估偏精度，同时相比常用算法复杂度较低。通过PM-MQAM-FSO空间分集仿真系统，完成所提算法的有效性和可靠性验证。</li></ul><p><strong>背景</strong></p><p>自由空间光（FSO）通信系统，因其高带宽、低功耗、易部署、安全性高、指向性强等特点，被认为是高速宽带连接的下一个前沿领域。目前，由于传统的无线微波通信技术已经不能满足卫星通信的需要，而且FSO链路的数据传输速率已经大大提高，因此，FSO技术在卫星通信系统，尤其是低地球轨道（LEO）卫星对地通信中，获得了广泛关注和应用。但其性能很大程度上取决于大气信道的链路状况，特别是大气湍流引起的光强闪烁和相位起伏会降低接收信号的完整性，导致错误概率增加并限制链路性能，严重时可能会导致链路中断。基于强度调制直接检测(IM/DD)的光通信系统，因其检测方式决定了接收机灵敏度较低，相干光通信系统由于采用信号光与本振光的混频，使接收机灵敏度相比IM/DD光通信系统获得极大提高，成为实现高速FSO通信的有效技术手段。但是，由于无中继空间信道损耗严重，特别是在中度和强湍流下，相干接收系统功率预算的保证仍极具挑战性。因此，如何成本有效地抑制大气湍流效应并提高相干光通信系统的接收机灵敏度是高速FSO通信的关键技术之一。</p><p>由于传输过程中大气湍流的影响，使得接收到的信号光的空间相干性受到破坏，接收到的信号光束的波前相位和振幅发生随机起伏，其中波前相位畸变会降低聚焦场与单模光纤模场的匹配程度，直接后果就是导致了耦合损耗并影响通信质量。另外，目前地面通信网络的主干网大多采用光纤通信，基于光纤耦合的空间光通信系统可以更好使空间光通信系统与光纤通信系统相结合，并能更加便利地利用在光纤通信中应用已经比较成熟的光电器件。因此深入研究大气湍流引起的波前畸变对空间光耦合进单模光纤的影响并进行合理建模尤为重要。</p><p>文献中提出了许多抑制大气湍流影响的方法。孔径平均、自适应光学、信道编码、空间分集利用多个发射/接收分支增加空间自由度，使得深度衰减的概率显著降低，因此可以有效地提高系统的性能，但缺点是系统复杂度的提高。</p><p>在这些技术中，空间分集作为一种强大的湍流抑制技术被广泛应用于FSO通信系统。空间分集不会产生功率的额外损失，也不会以频率或者传输速率的牺牲为代价，它所需要付出的代价是增加设备的成本和复杂性，但这些成本（特别是硬件）是可以不断降低的，而其他的天然资源却是不可再生的。因此，从整体性能和发展趋势上看，空间分集具有其他分集（时间、频率等）技术的优势而避免了它们的劣势，在目前而言是最为可取的。空间分集由于不同的分支在空间上经历了相互独立的大气信道，为接收系统提供了承载相同信号的多个副本，所有副本同时出现深度衰落的概率非常小，在接收端以适当的方式进行合并，就可以提高FSO通信系统的性能。但不同支路间的相对相位差会影响合并从而降低分集增益[18]，拟提出一种基于最优支路的分块相位校正算法，预期能够有效地补偿支路间的相对相位差，整体系统易于实现且复杂度较低。但是，不同支路在空间中经历不同的大气信道，产生的相对相位差降低了分集增益。在[18][19]中，通过共享本振光源解决了这个问题。该方案虽然系统复杂度较低，但需要不同支路之间的频率偏移和激光线宽引入的相位噪声分量相同，应用范围有限。因此，拟提出了一种基于最优支路分块相位校正的空间分集接收方案，以补偿不同支路之间的由大气湍流、激光频率偏移和激光线宽引入的相对相位差，提高分集增益。</p><h2 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>MBR系统开发，支撑MBR平台一期需求页面搭建</strong></p><p>平台：基于微前端一体化研发平台，支撑MBR（Monthly Business Reviews）产品一期需求页面搭建，主要对其前后台页面展示及交互能力的可用性负责，技术栈为React+TypeScript+MTD。</p><p>产品定位：面向B-Team以及管理层，实现餐饮SaaS MBR报表线上化，实现商分提效。</p><p>短期目标：MBR平台一期前后台页面开发上线，实现MBR核心指标线上化。</p><p>工作成果及收获：</p><ul><li><p>完成MBR前台和管理后台页面需求开发，主要完成页面整体布局、文件下载、目录树维护（增删改节点、节点关联页面等）、路由拦截和页面埋点等功能实现，并在泳道环境和ST环境的部署与发布。第一次参与较大型且周期较长的业务项目开发，熟悉了整个开发流程，从需求分析、方案设计、代码开发，再到联调测试，同时能够独立地进行方案设计与开发实现；沟通、合作和抗压等软实力得到提高，能与产品、后端及组内同事保持良好沟通，共同完成项目的开发。</p><ul><li><p>参与MBR三端评审，针对MBR平台一期需求完成方案调研与设计，主要对富文本编辑器和树形控件进行调研与选型，并对PRD中的各项需求进行分析设计。</p></li><li><p>完成MBR前后台页面需求开发，基于steamer平台将MBR前台和管理后台分别创建一个业务模块进行开发。前台页面主要完成页面整体布局、目录树导航（翻页、面包屑关联等）开发、页面动态渲染、页面部分组件（负责人卡片、富文本组件、无权限页面、文件下载页面等）开发；后台页面主要完成页面整体布局、目录树维护（增删改节点、节点关联页面、不同类型节点的功能区分等）、路由拦截等。</p></li><li><p>将请求发送、UI组件库这类公共服务（组件）发布为服务模块供业务模块使用，并在Shepherd网关编写mock接口进行本地测试。</p></li><li><p>前后台业务模块与服务模块的联调、构建与发布，并协助指导外包同学进行开发。</p></li><li><p>页面埋点、前后端联调、泳道环境和ST环境的部署与发布。</p></li></ul></li></ul><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p><strong>业务方面：</strong></p><ul><li><strong>第一次从零开始做团队项目，不知道如何下手以及估算排期。</strong></li></ul><p>解决：在mentor引导下，针对需求进行方案调研与设计，确定好可以实现需求的合适的组件库。对于开发流程，首先对整个开发过程进行拆分例如这个项目，前台展示页面更重要优先级最高，再针对页面UI进行组件层级的拆分，每一个组件下又可以根据不同的功能点确定拆分成更小组件还是组件内通过写一个函数来实现等等，整个开发还是以先实现静态页面，再通过state等实现数据展示交互功能，这样从整体到部分再到细节，就能梳理出大致的开发流程以及估算合适排期。</p><ul><li><strong>产品对需求进行变更或提出了新需求，导致延期风险。</strong></li></ul><p>解决：与产品、后端及组内同事积极沟通，协调需求变更。首先对所提需求进行分类，对于必须实现的需求，如管理后台目录树的编辑与页面关联的需求必须实现，但前期PRD对这方面描述不完善且设计不合理，经过积极与后端、产品讨论对齐尽快提出可行的方案并加以实现；对于非必须实现且不合理的需求，与产品说明需求的不合理性及实现成本，尽可能取消这类需求或进行更改。</p><p><strong>技术方面：</strong></p><ul><li><p><strong>功能性问题</strong>：开发经验、博客论坛、谷歌搜索等</p><ul><li><p>目录树维护（增删改节点、节点关联页面、不同类型节点的功能区分等）：UI库的树组件一般不支持可编辑，因此需要二次开发，另外项目要求对不同层级的节点编辑要求有区别，比如有子节点父节点不能删除、父节点不能挂页面等，除此之外，编辑完后怎么像后端发请求保存。我的做法是封装一个递归遍历所有节点的函数，根据传参实现对节点不同的操作，弹出框和编辑按钮也可以根据不同的类型进行一部分的复用，向后端传参这里有两种方式，一种每进行一次操作发请求保存，但由于设计到拖拽节点等操作，我需要时刻拿到对应节点的位置，后端也需要对拿到数据进行处理，另外，每更改一次前台页面的数据就相当于变化一次；另一种方案，不管增删改还是关联页面，只要不点击保存就不向后端请求，点击保存，将整棵树的数据传给后端，点击取消则重新获取上一次的数据，为了防止不保存就离开或关闭页面，还要进行路由拦截。</p></li><li><p>无刷新修改url：需求是点击某个节点或翻页，内容区局部刷新，路由地址也要变化，最早想到是用路由的param参数，但内容区组件其实是固定的，只是根据请求的数据进行渲染，用路由意义不大；因为内容区可以根据react的重新渲染机制，只要state或props变更就进行对比和重渲染，路由地址可以直接用History.pushState()/replaceState()来更改。但这里面要注意react的浅比较和key的使用。</p></li><li><p>请求封装、下载</p><ul><li><p>请求响应拦截器</p><ul><li><p>请求成功，业务状态码200，解析result给我，我不想一层一层的去判断拿数据</p></li><li><p><strong>http请求200， 业务状态码非200，说明逻辑判断这是不成功的，那就全局message提示服务端的报错</strong></p></li><li><p><strong>http请求非200， 说明http请求都有问题，也全局message提示报错</strong></p></li><li><p>http请求或者业务状态码<code>401</code>都做<strong>注销</strong>操作</p></li></ul></li><li><p>全局的loading配置, 默认开启，可配置关闭</p></li><li><p>两个请求接口实现异步下载</p><p>由于要下载的数据，经常会改动，所以每次下载都要重新生成文件。</p><p>第一个请求接口用来生成对应excel。</p><p>第二个请求接口用来获取下载列表，含有文件信息、下载地址，以及文件当前状态等。</p><p>通过轮询的方式，判断所有文件状态并在前端更新渲染，下载中的用loading，下载完成显示下载按钮（a标签）</p></li></ul></li><li><p>展示 滚动条、图片、grid</p></li></ul></li><li><p>平台基建/团队技术栈问题</p><ul><li><p>echarts等引起的ST环境导航切换白屏（removeChild） 错误边界 部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，不会渲染那些发生崩溃的子组件树，捕获错误，由于我们的bug是在路由跳转才会产生，因此错误边界组件捕获到错误可能立刻被卸载，因此并没有输出错误原因，而是直接让这个错误消失了。</p></li><li><p>组内的开发平台不熟悉，导致开发中经常遇到瓶颈，如样式不生效、构建发布失败和服务模块没有成功引入等。</p><p>解决：一方面，学习组内的wiki文档或者去学城搜索，很多问题别人已经遇到并解决过，同时可以结合之前别人的代码进行比对，排查原因并解决；另一方面，多向mentor和组内同事请教，他们的开发经验可以帮助快速定位问题并找到解决方案，甚至有些问题别人一两句话就能搞定，靠自己则会浪费过多时间。因此需要权衡问题的紧急程度，争取在不耽误项目排期的情况下快速定位问题并解决。</p></li><li><p>新技术栈如TypeScript不熟悉。</p><p>解决：首先集中时间对TypeScript的基础进行整体学习，同时结合组内之前的代码学习TypeScript在React的使用方式，在后续开发中不断完善编码规范，遇到报错可以去StackOverflow等网站查询他人的解决方法。</p></li></ul></li></ul><h3 id="收获与不足"><a href="#收获与不足" class="headerlink" title="收获与不足"></a>收获与不足</h3><p>通过上述项目与工作的锻炼，以及与mentor及组内同事的交流和学习，我得到了以下收获：</p><p><strong>业务方面：</strong></p><ul><li>对于业务理解有了提升，逐渐开始理解新需求的背景和目标，并能针对业务需求进行任务拆分。</li><li>第一次参与较大型且周期较⻓的业务项目开发，熟悉了整个开发流程，从需求分析、方案设计、代码开发，再到现在的联调测试，同时能够独立地进行方案设计与开发实现。</li></ul><p><strong>技术方面：</strong></p><ul><li><p>对Git常用命令、分支和冲突等方面有了进一步的学习和认识。</p></li><li><p>学习了新的技术栈TypeScript，同时对React、React Hook和React Router等有了进一步学习和更深的理解。</p></li><li><p>学习了新的UI组件库的使用，也尝试在项目中使用一些实用性轮子，同时对富文本编辑器、下载导出Excel等进行了调研学习与开发。</p></li><li><p>对公司和组内的各项基建更加熟悉，例如Shepherd、Ocean、steamer等，对steamer平台的使用有了一定了解，如业务模块和服务模块的构建与发布。</p></li><li><p>代码能力得到了成长，能够独立完成需求的开发以及BUG的定位与修复。同时，代码编程风格得到优化，代码格式逐渐统一与规范。</p></li></ul><p><strong>软实力：</strong></p><ul><li><p>沟通能力得到了提高，从最开始不好意思开口问，到现在可以有不懂的地方及时发问，并能快速对齐需求，与产品、后端及组内同事保持良好沟通，共同完成项目的开发。</p></li><li><p>合作意识提高，由于第一次参与团队项目，从最开始只顾自己开发，到现在能够及时沟通进度与存在问题，并互相帮助并提供解决方案。</p></li><li><p>抗压能力得到提升。</p></li></ul><p>反思不足：</p><p><strong>业务方面：</strong></p><ul><li>业务理解还停留于表层，经常被动接受并消化产品传递来的信息而无法很好的反馈。</li><li>对业务的远瞻性和敏感度不足，相对模糊的需求没有尽早明确，导致对开发耗时及排期估算不准确。</li><li>方案设计不够完善，例如组件库的选择只考虑是否能够完成相应需求以及当前是否在维护，没有与组内通用的组件库保持一致，导致后续重构的风险。</li></ul><p><strong>技术方面：</strong></p><ul><li>技术涉猎单一且固定，代码编写水平依然需要进一步提高，同时对React等技术栈底层原理还不够深入。</li><li>技术设计水平还有待提高，在开发过程中出现过设计不够合理的情况，导致代码需要重构。</li><li>对组内平台的底层原理不够了解，遇到样式或功能bug不能及时定位。</li></ul><p><strong>软实力：</strong></p><ul><li>当多任务并行时，心态会比较急躁，时间安排不合理，导致某段时间过于疲劳。</li><li>沟通表达能力还是有所欠缺。</li><li>写文档的能力有待提高，同时由于时间安排不合理，有时做了很多事情，来不及总结与整理。</li></ul><h3 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h3><p><strong>一个中大型项目</strong> = <strong>多个独立功能模块组合</strong></p><p>趋势：整体项目集中式 -&gt; 项目内组件化 -&gt; 独立组件化</p><ul><li><p>更快的页面加载速度</p><ul><li><p>所有业务 vendor + 一个业务异步chunk vs 宿主容器 + 一个业务模块的依赖；</p></li><li><p>举例：进入首页时可能不需要加载 echart</p></li></ul></li><li><p>更小规模的前端代码，维护成本更低</p><ul><li>大型项目 -&gt; 一组小型模块（数十 MB -&gt; 数百 KB，数万的模块 -&gt; 几十模块）</li></ul></li><li><p>更专业的分工，支持多个团队并行开发多个独立维护的模块</p><ul><li>例如（订单管理、仓储管理、人员管理… 等功能模块分离，独立维护）</li></ul></li></ul><p><strong>微前端结合 DevOps 的一站式研发解决方案是不错的选择</strong></p><p><strong>微前端 = 研发标准 + 研发工具 + 微前端框架 + 研发平台</strong></p><p><strong>DevOps = 持续集成 + 质量管控 + 版本产物 + 发布工具 +运营工具</strong></p><p><strong>微前端 + DevOps = Steamer</strong></p><p>终端端研发方案 + 终端端研发流程平台 = 一站式研发解决方案</p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>应用：</strong></p><p>一个应用对应一个<strong>单页应用（SPA）</strong>，如一个运营后台系统就是一个应用。</p><p><strong>业务模块：</strong></p><p>一个业务模块相当于单页应用中的一个页面（目前是<strong>页面</strong>，以后可能会细化成为页面中的<strong>组件</strong>）。</p><p>是 Steamer 中的最小单元，它可以独立迭代发布。基本形态是一个组件，对标 React/Vue 等主流框架中的组件。</p><p>由于组件的灵活度范围较大，在业务可以根据业务场景扩展支持子应用（多页面）、单一路由页面、局部组件 3 种场景。</p><p>业务模块在平台中独立存在，所以在<strong>代码隔离</strong>和组织形态上可以有比较高的灵活度：</p><ul><li>业务模块独立 Git</li><li>按照业务相关程度多个业务模块再统一 Git</li></ul><p>微前端方案中的基本独立维护单元，可以是业务组件、页面路由或者是一个独立子应用；一般推荐粒度为页面路由。</p><p><strong>服务模块（Service）：</strong></p><p>在一个业务模块中可能会使用到一些公共的业务组件或者公共方法，由于这些组件和方法可能并不会被所有的业务模块所引用，在steamer的技术框架中，它们就被抽象成了一个个的服务模块来被业务模块引用。</p><p>简而言之，<strong>服务模块是被部分业务模块所共用的组件、方法等</strong>。</p><p><strong>宿主容器模板（简称模板）：</strong></p><p><strong>宿主模板对业务模块进行路由管理，并提供业务模块间共享的功能。</strong></p><p><strong>宿主容器</strong> 作为承载业务模块的容器（类似于 App与操作系统），我们将 <strong>宿主容器</strong>分为两个部分，Container 是提供基础 UI 布局、前端框架、路由等基础现代前端应用的视图骨架容器；Runtime 是一个动态组件执行和挂载的渲染执行 SDK，内部也会集成模块网络通信、数据存储 API、性能和异常监控、执行沙盒隔离等基础能力。</p><p><strong>Steamer DevOps</strong></p><p>是一个通过线上化、标准化和自动化手段来串联终端研发过程的终端DevOps工作台，目标用户包括餐饮SaaS技术部终端研发者、业务需求技术主R、团队管理者等。</p><p><strong>功能特点：</strong></p><ul><li><p><strong>线上化：</strong> 团队研发流程线上化，所用即最新；</p></li><li><p><strong>标准化：</strong> 通过应用类型收敛相似架构的应用的研发流程，统一采用一套标准化的研发流程进行业务推进；</p></li><li><p><strong>自动化：</strong> 研发流程中的动作尽可能自动化执行，提高推进效率。</p></li></ul><p>Steamer 平台的流水线引擎基于 Talos 开发，在上层设计了灵活的插件系统和更加灵活的流程控制和数据回收能力，基于这套插件系统提供了针对微前端模块、组件库、MRN（规划中）等场景的支持。</p><p>其中集成式的<strong>质量管控</strong>和<strong>产物标准化</strong>是 Steamer 流水线的主要特性。</p><ul><li><strong>质量管控：</strong> 我们针对微前端场景，定制了由 ESLint 规范、依赖分析、代码分析组成的<strong>SteamerLint</strong> 前端代码质量分析阶段，可以从安全性、最佳实践、重复度等多个维度统计，分析每一个业务模块的代码质量数据，并可以支持从个人、团队、项目维护分析。（vscode插件：Prettier ESLint）</li><li><strong>产物标准化：</strong> 通过标准发布工具 CLI 与发布环节，实现业务模块的每一次构建产物都会被标记符合 semver 规范的唯一版本，这些版本产物将在 ABtest、灰度、回滚等分发环节作为精确编排控制的基础。</li></ul><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="Android词典"><a href="#Android词典" class="headerlink" title="Android词典"></a>Android词典</h3><p>本文使用Java编程实现一款基于Android平台的电子词典，词典数据借助Python的Requests库和XPath进行内容的获取。</p><p>该电子词典主要实现五大功能：注册登录、单词功能、句子功能、学习功能和娱乐功能。单词功能实现主要借助SQLite数据库进行单词释义等内容的查询；句子功能主要通过调用API或SDK实现；学习功能主要指生词本和内嵌网页，生词本功能使用了MVVM的架构模式；娱乐功能则是影视金句的轮播图。制作一款电子词典APP不但具有重要的实用价值，而且对提高自己的编程能力、分析和解决问题的能力具有重要作用。</p><p>基于Android的电子词典设计</p><p>离线情况和有网络的情况。</p><h4 id="单词数据的爬取"><a href="#单词数据的爬取" class="headerlink" title="单词数据的爬取"></a>单词数据的爬取</h4><blockquote><p>借助Python的Requests库和lxml库</p></blockquote><ul><li><p>Requests构建HTTP的请求头<strong>伪装成浏览器与词典网站进行通信</strong>，<strong>发起请求</strong>和<strong>获取响应内容</strong>，对应的方法为<strong>get</strong>方法。主要是获得相应url对应的html。</p></li><li><p>XPath，全称 XML Path Language，即<strong>XML路径语言</strong>,以<strong>XML树结构</strong>为基础，能够在数据的结构树中查找各类节点，比如属性节点、文本节点和元素节点等等。在检查元素中右键即可复制它的XPath路径，分析规律并且结合XPath的表达式语法，就可获取相关文本内容。</p></li><li><p>本项目使用<code>Multiprocessing</code>的<code>Pool</code>方法设置一定进程数量的进程池，将所有需要爬虫的单词异步执行，也就是非阻塞的方式。</p></li><li><p>当时遇到的问题<strong>多进程爬取的数据无法同时向SQLite数据库中保存</strong>，因此先爬取内容到<code>TXT</code>，再保存到数据库中。</p></li></ul><h4 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h4><p>使用<strong>布局编辑器</strong>构建界面。</p><ul><li><p>根布局就是<code>DrawerLayout</code>，在根布局之后又主要分为两大部分，第一部分就是我们主界面的内容，第二部分是左边滑出的布局，这里用NavitationView来代替。</p></li><li><p>线性布局（<code>LinearLayout</code>）和相对布局（<code>RelativeLayout</code>）实现。</p><ul><li>线性布局是将界面中的全部控件按照<strong>水平</strong>或<strong>竖直</strong>方向进行排列，同时它也是最基本的布局方式。</li><li>相对布局则是通过控件之间的<strong>相对位置</strong>关系实现控件的摆放，有利于适配不同屏幕大小的手机，因此使用更为普遍。</li></ul></li><li><p>一般布局都是用<code>dp</code>，字体用<code>sp</code>（手机字体调大了，APP的字体会随之变大）来布局的，用来<strong>适配移动端分辨率</strong>。</p></li></ul><h4 id="API或SDK"><a href="#API或SDK" class="headerlink" title="API或SDK"></a>API或SDK</h4><p>调用百度API实现句子翻译的功能。调用讯飞开放平台的SDK实现语音输入的功能。</p><ul><li><p>API 全称 Application Programming Interface，即<strong>「应用程序接口」</strong>。一般是指一些预先定义的<strong>函数</strong>，目的是供应用程序与开发人员基于某软件或硬件得以访问一组程序的能力，而又无需访问源码，或理解内部工作机制的细节。</p></li><li><p>SDK 全称 Software Development Kit，<strong>软件开发工具包</strong>。通俗来讲就是<strong>第三方服务商提供的实现产品软件某项功能的工具包</strong>。例如 JDK 就是一种 SDK。</p></li><li><p><strong>API 在更多场合下更像是 SDK 的一个子集</strong>，他们的区别如下：</p><ul><li><p>API 通常是一个<strong>函数</strong>，有特定的功能；而 SDK 是一个很多功能函数的<strong>集合体</strong>，更像是一个<strong>工具包</strong>。</p></li><li><p>API 通常扮演<strong>数据接口</strong>的形象，SDK 相当于一个<strong>工具环境</strong>，通常是需要在 SDK 的环境下调用 APl。</p></li><li><p><strong>SDK 相较于 API 封装层次更高</strong>。</p></li></ul></li></ul><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过<strong>分离关注点</strong>的方式来组织代码结构，优化我们的开发效率。</p><h5 id="Android-MVC"><a href="#Android-MVC" class="headerlink" title="Android MVC"></a>Android MVC</h5><ul><li><p><strong>View：</strong>XML布局文件。</p></li><li><p><strong>Model：</strong>实体模型（数据的获取、存储、数据状态变化）。</p></li><li><p><strong>Controller：</strong>对应于Activity，处理数据、业务和UI。</p></li></ul><p>从上面这个结构来看，Android本身的设计还是符合MVC架构的，但是<strong>Android中纯粹作为View的XML视图功能太弱，我们大量处理View的逻辑只能写在Activity中，这样Activity就充当了View和Controller两个角色</strong>，直接导致Activity中的代码大爆炸。相信大多数Android开发者都遇到过一个Acitivty数以千行的代码情况吧！所以，更贴切的说法是，这个MVC结构最终其实只是一个<strong>Model-View（Activity:View&amp;Controller）</strong>的结构。</p><h5 id="Android-MVVM"><a href="#Android-MVVM" class="headerlink" title="Android MVVM"></a>Android MVVM</h5><p>**View: **对应于Activity和XML，负责View的绘制以及与用户交互。</p><p>**Model: **实体模型。</p><p><strong>ViewModel: <strong>负责完成View与Model间的交互，负责</strong>业务逻辑</strong>。</p><p>Android为此提供了一套<strong>架构组件</strong>，主要有LiveData、ViewModel 和Room。</p><ul><li>LiveData是用来构建数据对象，当基础数据库改变时会通知视图；</li><li>ViewModel是用来<strong>存储和管理与界面相关的数据</strong>，这些数据在应用跳转时不会被销毁；</li><li>Room是一个SQLite对象映射库，它可以轻松地将SQLite表数据转换为Java对象，主要负责底层数据库的处理，本文调用其中的Dao接口来执行数据库增删改查等操作，利用 Database创建和管理数据库。同时，Room可以为SQLite语句提供编译时检查，并能够返回RxJava、Flowable和LiveData可观察对象。</li><li>Repository是一个仓库类，介于视图层与数据映射层（数据访问层）之间。它的作用是让视图层感觉不到数据访问层的存在，提供了一个类似集合的接口给视图层进行访问。</li></ul><p>采用MVVM模式最大的优点就是编写代码是思路明确，<strong>视图层与模型层完全解耦</strong>，方便后期的管理与维护，数据库相关的操作非常方便。</p><p>MVVM 模式中的VM，通过双向的数据绑定，<strong>将 View 和 Model 的同步更新给自动化了</strong>。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如vue是通过使用数据劫持和发布订阅者模式来实现的这一功能。</p><h3 id="商城后台管理系统★"><a href="#商城后台管理系统★" class="headerlink" title="商城后台管理系统★"></a>商城后台管理系统★</h3><p>One Piece商城后台管理系统</p><ol><li>此项目为一个<strong>前后台分离</strong>的<strong>后台管理的 SPA</strong>（单页面应用）, 包括前端 PC 应用和后端应用</li><li>包括<strong>用户管理</strong> / <strong>商品管理</strong> / <strong>权限管理</strong>等功能模块</li><li>前端: 使用 <strong>React 全家桶（函数式组件、react-router V6）</strong> + <strong>Antd（v4）</strong> + <strong>Axios</strong> + <strong>ES6</strong> + <strong>Webpack</strong> 等技术</li><li>后端: 使用 <strong>Node</strong> + <strong>Express</strong> + <strong>Mongodb</strong> 等技术</li><li>采用<strong>模块化</strong>、<strong>组件化</strong>、<strong>工程化</strong>的模式开发</li></ol><p>使用<code>create-react-app</code>(脚手架)搭建项目。</p><p><code>create-react-app</code> 是react 官方提供的用于搭建基于<code>react</code>+<code>webpack</code>+<code>es6</code> 的脚手架</p><p><code>antd</code> 是基于 Ant Design 设计体系的 <strong>React UI 组件库</strong>，主要用于研发企业级中后台产品。</p><p><code>craco</code>一个对 create-react-app 进行<strong>自定义配置</strong>的社区解决方案</p><h4 id="模块化、组件化、工程化-★"><a href="#模块化、组件化、工程化-★" class="headerlink" title="模块化、组件化、工程化 ★"></a>模块化、组件化、工程化 ★</h4><h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h5><p>后端：<strong>CommonJS</strong> :<code>module.exports</code>、<code>require</code>方法用于加载模块。</p><p>前端：<strong>ES6</strong> 模块化语法：export 和 import；</p><h5 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h5><p><code>webpack</code>最热门的前端资源模块化管理和打包工具、</p><p><code>create-react-app</code> 脚手架初始化react 项目开发、</p><p><code>ESLint</code> 插件化的 JavaScript 代码检测工具</p><h5 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h5><p>其中以React的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。</p><p>理解:<strong>用来实现局部功能效果的代码和资源的集合(html/css/js/img等等)</strong></p><p>为什么要用组件:一个界面的功能复杂</p><p>作用:<strong>复用编码,简化项目编码,提高运行效率</strong></p><p>当应用是以多组件的方式实现,这个应用就是组件化的应用。</p><h4 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h4><h5 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h5><blockquote><p>气泡背景原理：</p></blockquote><p><strong>background</strong>可以设置多个，默认地，每个背景图像在水平和垂直方向上<strong>重复</strong>。因此，通过设置多个背景图像的<strong>位置</strong>和<strong>大小</strong>产生重叠效果。</p><p>气泡：<code>radial-gradient</code>+<code>rgba</code></p><p>开始和结束的透明度都设为0。通过两个确定位置的固定色值（有一定透明度的白色），实现渐变效果。</p><p><code>radial-gradient(rgba(255,255,255,0) 0, rgba(255,255,255,.15) 30%, rgba(255,255,255,.3) 32%, rgba(255,255,255,0) 33%)</code></p><blockquote><p>边框</p></blockquote><p><code>box-shadow</code> 内外阴影效果。</p><blockquote><p>背景毛玻璃</p></blockquote><p><code>backdrop-filter: blur(5px);</code></p><p>该属性可以让你为一个元素后面区域添加图形效果（如模糊或颜色偏移）。 因为它适用于元素背后的所有元素，为了看到效果，必须使元素或其背景至少部分透明。</p><blockquote><p>头像旋转</p></blockquote><p><code>animation</code>+<code>transform: rotate</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">animation</span>: spin <span class="number">0.5s</span> linear <span class="number">0s</span> forwards;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">        <span class="attribute">animation</span>: spin <span class="number">1s</span> linear forwards infinite;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> spin &#123;</span><br><span class="line">    <span class="selector-tag">100%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotate(<span class="number">360deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="预加载动画"><a href="#预加载动画" class="headerlink" title="预加载动画"></a>预加载动画</h5><p>在index.html中的<code>div root</code>中先填充加载元素，通过css设置样式</p><p>多个<code>span</code> <code>animation</code> <code>animation-delay</code> <code>opacity</code> <code>background</code> 无限循环</p><p><strong>等react组件加载完成后就会覆盖</strong>。</p><h4 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h4><h5 id="用户登录和权限管理★"><a href="#用户登录和权限管理★" class="headerlink" title="用户登录和权限管理★"></a>用户登录和权限管理★</h5><p>默认使用最高级管理员登录，该管理员名称和密码为默认值，且拥有最高权限。</p><p>通过向后端发送<strong>用户名和密码</strong>，后端返回<strong>用户信息</strong>，其中<strong>密码</strong>在后端使用<strong>md5</strong>加密格式返回，然后将用户信息保存在内存和<code>localStorage</code>中（store.js），每次打开该网站时就从localStorage中读取数据到内存，实现登录功能。</p><p>权限管理则是通过事先准备一个菜单列表的数组，该数组是一个树形结构，每一个菜单下可能有子菜单，每一个菜单对象存储左侧导航的相关信息，图标、名称和key。</p><p>通过对菜单列表的数组<strong>递归（map）</strong>返回antd里的菜单组件，生成左侧导航栏。</p><p>上述过程的一开始加入权限管理的功能，本地保存的用户信息中包含权限信息，前端渲染前先进行检查是否拥有展示权限。</p><p>由于只是一个简单的后台管理系统，后端并没有保存登录状态。</p><p>在自己的权限内，所有用户都可以对数据库进行权限内的操作，所以后端不需要记录用户。</p><h5 id="输入校验"><a href="#输入校验" class="headerlink" title="输入校验"></a>输入校验</h5><p><strong>正则</strong></p><p><code>/^[a-zA-Z0-9_]+$/</code>用户名必须是英文,数字和下划线组成</p><p><code>/^[a-zA-Z0-9_]+$/.test(value)</code></p><h5 id="跨域和Ajax"><a href="#跨域和Ajax" class="headerlink" title="跨域和Ajax"></a>跨域和Ajax</h5><p>React中配置代理</p><p>在<code>package.json</code>中追加如下配置 :<code>&quot;proxy&quot;:http://localhost:5000</code></p><p><strong>Promise封装axios</strong></p><p>axios是一个基于<code>promise</code>的<code>HTTP</code>库，可以用在<code>浏览器</code>或者<code>node.js</code>中。</p><p>axios是通过promise实现对ajax技术的一种封装。</p><ul><li>对get和post请求进行封装</li><li>请求成功该方法返回一个以<code>response.data</code>值解析后的Promise对象</li><li>请求失败了，不调用<code>reject(reason)</code>，而是统一处理异常，结合antd的message组件提示错误信息</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; message &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url,data=&#123;&#125;,type=<span class="string">&#x27;GET&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> promise;</span><br><span class="line">        <span class="comment">// 执行异步ajax请求</span></span><br><span class="line">        <span class="keyword">if</span>(type===<span class="string">&#x27;GET&#x27;</span>)&#123;<span class="comment">//发GET请求</span></span><br><span class="line">            promise=axios.get(url,&#123;</span><br><span class="line">                <span class="attr">params</span>:data</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//发POST请求</span></span><br><span class="line">            promise=axios.post(url,data)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果请求成功了，调用resolve(value)</span></span><br><span class="line">        <span class="comment">// 该方法返回一个以response.data值解析后的Promise对象</span></span><br><span class="line">        promise.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(response.data)</span><br><span class="line">            <span class="comment">// console.log(response.data)</span></span><br><span class="line">        <span class="comment">// 如果请求失败了，不调用reject(reason)，而是提示异常信息（统一处理异常）   </span></span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            message.error(<span class="string">&#x27;请求出错了：&#x27;</span>+error.message)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有的请求函数封装在一个文件中</p><p>ajax第二个参数必须是对象 当属姓名和值相同时可以简写</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BASE = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">// 登陆 ajax第二个参数必须是对象，username:username =&gt; username 匹配请求参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reqLogin = <span class="function">(<span class="params">username, password</span>) =&gt;</span> ajax(BASE+<span class="string">&#x27;/login&#x27;</span>, &#123; username, password &#125;, <span class="string">&#x27;POST&#x27;</span>)</span><br><span class="line"><span class="comment">// 天气</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reqWeather = <span class="function">(<span class="params">key, location</span>) =&gt;</span> ajax(<span class="string">&#x27;https://devapi.qweather.com/v7/weather/now&#x27;</span>, &#123; key, location &#125;)</span><br><span class="line"><span class="comment">// 更新分类 传一个对象 解构 外部传的时候名字要一致</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reqUpdateCateGories = <span class="function">(<span class="params">&#123; categoryName, categoryId &#125;</span>) =&gt;</span> ajax(BASE+<span class="string">&#x27;/manage/category/update&#x27;</span>, &#123; categoryName, categoryId &#125;, <span class="string">&#x27;POST&#x27;</span>)</span><br></pre></td></tr></table></figure><p>登录组件中发送请求</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onFinish = <span class="keyword">async</span> values =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username, password &#125; = values;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> reqLogin(username, password);<span class="comment">//发送AJAX</span></span><br><span class="line">    <span class="keyword">if</span> (result.status === <span class="number">0</span>) &#123; <span class="comment">// 登陆成功</span></span><br><span class="line">        message.success(<span class="string">&#x27;登陆成功&#x27;</span>)</span><br><span class="line">        <span class="comment">// 保存user            </span></span><br><span class="line">        <span class="keyword">const</span> user = result.data</span><br><span class="line">        <span class="built_in">console</span>.log(user)</span><br><span class="line">        memoryUtils.user = user <span class="comment">// 保存在内存中</span></span><br><span class="line">        storageUtils.saveUser(user) <span class="comment">// 保存到local中</span></span><br><span class="line">        <span class="comment">// 跳转到管理界面 (不需要再回退回到登陆)</span></span><br><span class="line">        navigate(<span class="string">&#x27;/&#x27;</span>, &#123; <span class="attr">replace</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        message.error(result.msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h5><p><strong>props</strong></p><ul><li><p>【父组件】给【子组件】传递数据：通过<code>props</code>传递</p></li><li><p>【子组件】给【父组件】传递数据：通过<code>props</code>传递，<strong>要求父提前给子传递一个函数</strong>。</p><p>此props为<strong>作用域为父组件自身的函数</strong>，子组件调用该函数，将子组件想要传递的信息，作为参数，<strong>传递到父组件的作用域中</strong>。该项目中将<code>useState</code>的更新函数传给子组件。</p></li><li><p>【子组件】给【父组件】传递函数/方法</p><ul><li><code>useRef</code>: 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 ref 对象在组件的整个生命周期内持续存在。一个常见的用例便是命令式地访问子组件。</li><li><code>useImperativeHandle</code>:可以让你在使用 <code>ref</code> 时<strong>自定义暴露给父组件的实例值</strong>。比如暴露子组件的某个方法。<code>useImperativeHandle</code> 应当与<code>React.forwardRef</code> 一起使用。</li></ul></li></ul><h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><p>因为是静态站点，所以完全是<strong>客户端部分</strong>，使用<strong>Hash</strong>路由跳转会没有任何问题。因为<strong>BrowserRouter依赖于服务端支持</strong>，使用它的话访问会出现404 not Found/405.</p><h5 id="GitHub-Pages发布静态页面"><a href="#GitHub-Pages发布静态页面" class="headerlink" title="GitHub Pages发布静态页面"></a>GitHub Pages发布静态页面</h5><p><code>package.json</code> 打包好的build文件夹上传gh-pages分支</p><h4 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h4><h5 id="自定义hook实现搜索防抖"><a href="#自定义hook实现搜索防抖" class="headerlink" title="自定义hook实现搜索防抖"></a>自定义hook实现搜索防抖</h5><p><strong>Input</strong> <code>event.target.value</code> 获取输入值 ，<strong>useState</strong> 更新此时的搜索状态 。</p><p>自定义 hook <strong>useDebounce</strong></p><p>debounce一般使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lodash</span></span><br><span class="line"><span class="keyword">import</span> debounce <span class="keyword">from</span> <span class="string">&#x27;lodash/debounce&#x27;</span></span><br><span class="line">debounce(<span class="function">()=&gt;</span>search(value), <span class="number">500</span>)</span><br><span class="line"><span class="comment">// 自定义</span></span><br><span class="line"><span class="keyword">const</span> debounceFn =<span class="function">(<span class="params">fn, wait=<span class="number">1000</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(fn, wait);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [value, setValue] = useState(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&lt;!--搜索函数--&gt;</span><br><span class="line"><span class="keyword">const</span> search = <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">    &lt;!--调用接口--&gt;</span><br><span class="line">&#125;</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    debounceFn(<span class="function">()=&gt;</span>search(value),<span class="number">500</span>)</span><br><span class="line">&#125;, [value])</span><br></pre></td></tr></table></figure><p>测试发现这一套在useEffect里是行不通的，<strong>每次组件重新渲染，都会创建新的定时器，定时器无法按规定清除</strong>，这样debounce高阶函数里面的timer就不能起到缓存的作用。timer不可靠，debounce的核心就被破坏了。</p><p>使用useCallback返回回调函数的 memoized 版本，<strong>该回调函数仅在某个依赖项改变时才会更新</strong>，通过设置空数组，使debounce高阶函数里面的timer唯一。</p><p>也可以借助useEffect自定义useDebounce ，关键<strong>React 会在执行当前 effect 之前对上一个effect进行清除</strong>。</p><p>当首次渲染时，执行effect延时后执行一次搜索操作，可以通过给value赋初值跳过这次搜索请求，之后每当输入时，value就会变化，每次变化先清除上一次effect的timer，然后建立新的timer等待执行，当输入停止后搜索函数在延时后就会发送请求，实现防抖。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理方案四 useEffect自定义hooks</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDebounce</span>(<span class="params">fn, delay, dep=[]</span>) </span>&#123;</span><br><span class="line">   useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> timer;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(fn, delay);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">()=&gt;</span><span class="built_in">clearTimeout</span>(timer); <span class="comment">// 这里用到useEffect清除的能力 类似于componentWillUnmount</span></span><br><span class="line">   &#125;, [...dep]</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useDebounce</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">useDebounce(<span class="function">()=&gt;</span>search(value), <span class="number">500</span>, [value])</span><br></pre></td></tr></table></figure><p>使用useRef保证<strong>多次渲染之间保证唯一值的纽带</strong>。将timer通过<code>useRef</code>创建。</p><p>useRef 会在所有的 render 中保持对返回值的唯一引用。因为所有对<code>ref</code>的赋值和取值拿到的都是最终的状态，并不会因为不同的 render 中存在不同的隔离。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理方案五 useRef自定义hooks</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDebounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = useRef(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer.current);</span><br><span class="line">        timer.current = <span class="built_in">setTimeout</span>(fn, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useDebounce</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">const</span> debounceSearch = useDebounce(<span class="function">() =&gt;</span> handleParams(params), <span class="number">500</span>)</span><br><span class="line">useEffect(<span class="function">()=&gt;</span>debounceSearch(),[value]</span><br></pre></td></tr></table></figure><p>关于useEffect还有一个问题，除了在依赖数组变化时会执行，初始渲染也会执行，但输入搜索显然不希望在初始进行搜索。</p><p>可以设置依赖值的初值，在请求函数中跳过请求。</p><h2 id="HR"><a href="#HR" class="headerlink" title="HR"></a>HR</h2><h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><p>可以大体从三方面讲：</p><p><strong>业务方面：</strong></p><ul><li>尽快熟悉业务脉络和逻辑，加深组内平台和常用工具的理解与使用，快速融入工作氛围并适应工作节奏。</li><li>多关注业务的发展，弄清楚为何这么做，如何做的更好。视野不只停留在业务的开发上，更要对业务的落地、性能、效益进行思考。</li><li>对于接到手中的需求，提高方案调研与设计的能力，不要总是被动地接收和消化。</li></ul><p><strong>技术方面：</strong></p><ul><li>能力不只停留在已有的技术上，更要对新知识保持热情与追求，不断拓展技术的广度并持续钻研技术的深度，提升自己的行业竞争力。</li><li>如果有编写代码相关工作的话，提升编写代码的鲁棒性和可靠性，当出现BUG时，能快速定位问题，主动担责，并尽快修复。</li></ul><p><strong>软实力：</strong></p><ul><li>协调好生活与工作的平衡，合理安排时间，确保工作有序无误地开展，培养自己的耐心并提高自己的抗压能力。</li><li>提升多方协作能力，能够对项目需求合理拆解，协调多人保质按时交付任务。</li><li>不要总是埋头做事，沟通表达能力要多加练习，平时注意反思总结，每天/周抽出时间进行个人的沉淀与记录。</li></ul><h3 id="时间紧任务重-压力"><a href="#时间紧任务重-压力" class="headerlink" title="时间紧任务重/压力"></a>时间紧任务重/压力</h3><p>下面我要讲的是我实习期间的项目吧，由于当时公司有人离职，有个比较大的项目交到了我所在的组，组内人手又不够，虽然作为实习生，但我也要尽快进入项目。应对这种时间紧任务重的情况，首先应该从容进行任务的分级与梳理，积极沟通协调，同时调整生活<br>和工作上的平衡。</p><p>为了项目顺利完成，我先用一周时间自学Typescript和微前端的基础知识，并通过参加对齐会议了解大体工作内容。</p><p>在mentor引导下，针对需求进行方案调研与设计，从整体到部分到细节拆分开发流程，估算排期。</p><p>平时工作中，与产品、后端及组内同事积极沟通，协调需求变更。</p><p>在开发过程中遇到的问题，一方面，通过自己上网搜索，排查原因并解决；另一方面，多向组内同事请教，他们的开发经验可以帮助快速定位问题并找到解决方案。因此需要权衡问题的紧急程度，争取在不耽误项目排期的情况下快速定位问题并解决。</p><p>最后，我们团队也在预期时间完成了工作，也得到了领导的认可。</p><h3 id="合作"><a href="#合作" class="headerlink" title="合作"></a>合作</h3><p>下面我要讲的是我实习期间的项目吧，由于当时公司有人离职，有个比较大的项目交到了我所在的组，组内人手又不够，虽然作为实习生，但我也要尽快进入项目。整个项目基本就是由我和另一个实习生负责，同时还要带领外包同学共同完成任务。</p><p>对于这种团队项目，一个是要进行合理分工，针对不同人掌握的技能或个人特点安排不同的工作内容，争取发挥每个人的优势；另一个就是要和团队成员多加沟通，避免矛盾和冲突产生。</p><p>对于我跟另一个实习生来说。我的优点在于比较细心，容易看到别人忽略的细节，但缺点在于宏观角度上视野不够开阔，有的时候思维容易局限；他的优点在于思维敏捷，点子多，缺点在于比较跳脱，容易在交流过程中跑题。因此我会更多地关注项目要求与细节，提出自己的计划；鼓励另一个实习生去发散性思考，发挥创造力，而站在宏观角度上思考整体计划的可行性则交给项目总负责人去定夺。经过合理的分工，每个人都能发挥自己的优势，通过我们的通力合作，我们的项目得以顺利进展。</p><h3 id="打破常规，新颖的想法"><a href="#打破常规，新颖的想法" class="headerlink" title="打破常规，新颖的想法"></a>打破常规，新颖的想法</h3><p>下面我想讲的是我研究生刚入学做实验的事情。</p><p>由于我本科专业是电子信息，研究生入学后的方向是光通信相关，所以我的基础是有欠缺的，而且我的老师让我去通过实验验证一位博士提出的方案，然而这位博士在我入学前就毕业了，所涉及的OFDM方向也没有多少人熟悉，所以我的实验进展非常不顺利。</p><p>后来我就转换思路，老师真正想让我验证的是通信算法的有效性，而OFDM只是一个应用场景，因此我决定把这个方法转移到实验室更多人熟悉的单载波系统上，一方面很多问题我可以请教师兄师姐，另一方面它确实比OFDM要容易实现。因此我就针对单载波系统对算法进行改进和验证。在这个过程中，还遇到的一个问题，原方案使用的空间分集搭建非常复杂，而且实验器材也不够，我就从原理上分析，通过时间分集对空间分集进行等效，可以获得相同的效果。最终经过我的不断改进与尝试后，完成了这个实验。凭借这个实验，我也成功发表了一篇二区SCI论文，并获得研究生国奖。</p><p>有成就感的事</p><h3 id="原有计划发生重大变化的经历。"><a href="#原有计划发生重大变化的经历。" class="headerlink" title="原有计划发生重大变化的经历。"></a>原有计划发生重大变化的经历。</h3><p>这个我讲一下实习过程中的经历吧。在离测试前一两周的时候，我们项目的产品经理对需求进行一些重大的变更，还提出了新需求，导致有延期风险。</p><p>当得知这些事情后，我首先与产品、后端及组内同事积极沟通，协调需求变更。</p><p>对所提需求进行了分类，对于必须实现的需求，比如管理后台目录树的编辑与页面关联的需求必须实现，但前期PRD对这方面描述不完善且设计不合理，经过积极与后端、产品讨论对齐尽快提出可行的方案并加以实现；</p><p>对于非必须实现且不合理的需求，与产品说明需求的不合理性及实现成本，尽可能取消这类需求或进行更改。</p><p>最后在我们大家的共同努力下，如期完成了工作。</p><h3 id="出现分歧"><a href="#出现分歧" class="headerlink" title="出现分歧"></a>出现分歧</h3><p>工作中遇到分歧的是在所难免的。</p><p>我会尽量站在对方的⻆度去理解这个问题，首先审视一下自己的认识有没有局限。</p><p>如果发现我的观点没有问题，那我会在坚持我最主要原则的前提下，多通过一些策略性的沟通方式，比如，多对对方的观点、付出的努力、观点的价值表示认可，然后阐述我自己考虑问题的出发点是什么，以此来争取对方的理解和支持。</p><p><strong>一句话总结：理解分歧，坚持底线，柔性解决。记住，体现态度！</strong></p><h3 id="面临的复杂问题，如何快速定位问题、提出解决思路的。"><a href="#面临的复杂问题，如何快速定位问题、提出解决思路的。" class="headerlink" title="面临的复杂问题，如何快速定位问题、提出解决思路的。"></a>面临的复杂问题，如何快速定位问题、提出解决思路的。</h3><p>这里我以实习中项目遇到的问题为例。</p><p>像我们做开发的经常会遇到代码bug，这里一般有两种思路去解决。第一个是功能性的问题，比如当时我需要做一个目录树维护（增删改节点、节点关联页面、不同类型节点的功能区分等）：UI库的树组件一般不支持可编辑，因此需要二次开发。这种问题一是我们需要不断提高自己的技术水平，另一方面也需要借助搜索引擎、博客论坛等借鉴他人的解决方案。还有一种平台基建问题，当时我们做的系统有ST环境导航切换白屏的问题，通过请教组内同事，才发现这是组内微前端平台导致的，像这种使用公司内部平台出现问题时，一定多向组内同事请教，他们的开发经验可以帮助快速定位问题并找到解决方案，甚至有些问题别人一两句话就能搞定，靠自己则会浪费过多时间。</p><h3 id="遇到的困难"><a href="#遇到的困难" class="headerlink" title="遇到的困难"></a>遇到的困难</h3><p>STAR原则，什么情景，发生了什么事情，你怎么处理的，最终的结果是什么</p><p>研究生</p><p>实验论文</p><p>转换思路</p><p>耐心 不放弃</p><p>与人沟通 跟实验室博士、老师、甚至器材维修人员都有所接触</p><h3 id="课程-成绩-获奖情况-竞赛"><a href="#课程-成绩-获奖情况-竞赛" class="headerlink" title="课程/成绩/获奖情况/竞赛"></a>课程/成绩/获奖情况/竞赛</h3><p>研究生 通信网理论基础 86 光网络技术 88 研究生课程很多不进行考试 主要重点在实验室项目或课题</p><p>本科 高等数学 98 复变函数与积分变换 100 计算机程序设计（C语言） 93 信号与系统 96 电路 99</p><p>计算机二级、三级 GET4、6 普通话二级乙等</p><p>北邮 山科校一等奖学金 三好学生 优秀共青团员 优秀学生标兵等</p><p>第八届山东省大学生数学竞赛（非数学类）——省一等奖</p><p>山东省大学生物理竞赛——省三等奖</p><p>2019年全国大学生电子设计竞赛——省二等奖</p><p>2017年第十届“认证杯”数学建模网络挑战赛——省二等奖</p><p>2017年APMCM亚太地区大学生数学建模竞赛——省三等奖</p><p>2020-09～至今，研究自由空间光通信中的分集接收方案，并通过Matlab和Optilux实现40Gbps PM-CO-16QAM FSO空间分集接收仿真平台搭建，并进行了离线实验验证。成功发表一篇二区（Optics Express）SCI（导师一作、本人二作）：Performance analysis of a spatial diversity coherent free-space optical communication system based on optimal branch block phase correction.</p><p>研究生国家奖学金、优秀研究生</p><h3 id="你经历的最大挫折是什么？"><a href="#你经历的最大挫折是什么？" class="headerlink" title="你经历的最大挫折是什么？"></a>你经历的最大挫折是什么？</h3><p>高考对我来说就是挺大的挫折吧，高中时期其实我成绩还算不错，当时正常发挥考上211应该不成问题，但最后因为考试心态等问题，考的相比平时差了不少，本科专业因为调剂也不想学，但后来也是慢慢调整自己，在本科期间换了专业，参加各类比赛等等，最终考研来到了北邮，现在看来高考失利也只是人生路上的一个小插曲，未来路还很长，还是要一直充满希望的。</p><h3 id="优缺点-竞争力"><a href="#优缺点-竞争力" class="headerlink" title="优缺点 竞争力"></a>优缺点 竞争力</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>乐观开朗，乐于助人，适应能力强，不管学校还是公司，都能够与身边的人愉快相处。</p><p>技术视野开阔，喜欢钻研，具有良好的学习能力，热爱编程，对业界新技术敏感，开拓创新意识强，能保持不断进取的精神。像平时经常会在B站看一些学习或者技术类的视频，也会经常浏览知乎、掘金、包括一些个人的博客论坛网站，丰富自己的视野，如果是比较新的技术，可能直接去看一些国外的网站或文章会收获更多。</p><p>注重团队合作，有着强烈的责任心和高度执行力。</p><p>抗压能力还算可以，应对实验室或公司中时间紧任务重的情况，能够从容进行任务的分级与梳理，积极沟通协调，同时调整生活<br>和工作上的平衡，力争每次都能按时保质地交付手中的任务。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>沟通能力还是需要进一步提高，在之前实习过程中，从最开始不好意思开口问，到后来有不懂的地方及时发问，并能与产品、后端及组内同事保持良好沟通，共同完成项目的开发。但沟通交流本身就是一门学问，需要不断磨练与提高，自己在这方面还是有很长的路要走。</p><p>提升多方协作能力，能够对项目需求合理拆解，协调多人保质按时交付任务。尽量提高自己的一个管理或者领导能力，树立大局观，不要总是埋头做事，平时注意反思总结，每天/周抽出时间进行个人的沉淀与记录，这样之后才能走得更远。</p><h3 id="你平时是怎么学习的？"><a href="#你平时是怎么学习的？" class="headerlink" title="你平时是怎么学习的？"></a>你平时是怎么学习的？</h3><p>基础学习：</p><p>B站、MDN（建议英文，中译有误）和官网（React、React Router）</p><p>知识拓展：</p><p>掘金/知乎/segmentfault思否/CSDN、阮一峰博客</p><p>bug：</p><p>Stack overflow</p><h3 id="你什么时候接触前端的-为啥学前端"><a href="#你什么时候接触前端的-为啥学前端" class="headerlink" title="你什么时候接触前端的/为啥学前端"></a>你什么时候接触前端的/为啥学前端</h3><p>本科时候做词典APP，里面离线数据是通过爬虫获取的，所以对html有了一些了解，包括安卓开发的XML布局，其实也跟前端比较类似。在我看来，学习前端是一件很有意思的一件事，随着我学习进度的增加，慢慢的，我发现了前端所做的都是用户可以最直观感受和体验的，也是最能让开发者感受到成就感的。</p><p>当然最早学前端，也因为它入门更容易，但随着学习深入就会发现现在的前端已经不是原先的切图仔，如果把前端狭义的理解为做页面，那天花板当然低了，但对应的，后端也可以被理解为 CRUD，天花板也很低。这时候如果把数据库 AI 这些扯进后端范畴，那么广义的前端也应该包含一切和交互相关的内容，比如网络资源优化、自动化部署、交互体验研究、设计和开发协作、跨平台渲染引擎、字符排版、甚至浏览器本身就是前端范畴。</p><p>当然，前端也不是归宿，后端语言像nodejs或其他也要学习，语言永远只是工具，重要的是开发的思想。另一方面，技术是需要给业务赋能，所以想走的更远，只学技术也不够。</p><p>前端的工程体系难就难在庞杂，链路长，环节多，而且和许多其他领域有交叉（比如网络、运维、编译器、图形学、人机交互理论、PL/DSL 设计），吃透一个环节的难度确实不难，但作为大厂的前端负责人需要规划整合这些东西，我是觉得天花板一点也不低。</p><h3 id="有无意向offer"><a href="#有无意向offer" class="headerlink" title="有无意向offer"></a>有无意向offer</h3><p>秋招时暂时接了B站的offer，虽然待遇还可以，但今年互联网整体形势确实比较差，裁员也经常发生，所以还是倾向于找一个稍微稳定些的国企，目前学校也开始受理毁约的办理。</p><h3 id="情商跟职商"><a href="#情商跟职商" class="headerlink" title="情商跟职商"></a>情商跟职商</h3><p>举几个例子：</p><p>1.你和同事意见相左怎么办？</p><p>2.你和老板意见出现分歧，而你比较笃定你的想法是正确的。这时你会怎么做？</p><p>3.领导如果让你做假账，你做不做？</p><p>4.上司分配给你的任务，并不是你喜欢的，这个时候你应该怎么做？</p><p>5.如果你的leader和boss意见冲突，都要求你完成一个紧急任务，该怎么办？</p><p><strong>比如第一个问题，“你和同事意见相左怎么办？”我们不妨可以这样回答。</strong></p><p><strong>答：</strong>工作中遇到分歧的是在所难免的。</p><p>我会尽量站在对方的⻆度去理解这个问题，首先审视一下自己的认识有没有局限。</p><p>如果发现我的观点没有问题，那我会在坚持我最主要原则的前提下，多通过一些策略性的沟通方式，比如，多对对方的观点、付出的努力、观点的价值表示认可，然后阐述我自己考虑问题的出发点是什么，以此来争取对方的理解和支持。</p><p><strong>一句话总结：理解分歧，坚持底线，柔性解决。记住，体现态度！</strong></p><h3 id="城市"><a href="#城市" class="headerlink" title="城市"></a>城市</h3><p>我的家乡是山东济南，济南作为山东省会，又是一座历史悠久的文化古城，同时风景优美，有大明湖、千佛山、趵突泉等著名景点，其中泉水最为出名，因此又叫做泉城。另外，济南的气候也非常宜人，老舍也曾写下济南的冬天，并在语文课本中为大家熟知。济南人也非常厚道淳朴、热情好客，非常欢迎大脚来济南做客。这就是我的家乡济南。</p><p>像北京这种大城市虽然生活成本偏高；但对个人来讲，无论是薪资水平、发展和上升空间相较于小城市和县城还是高不少。另外，很多曾经包括现在的同学都留在了北京，没事还能一起聚餐玩一玩，生活圈子可能会更广一些。</p><p>大城市就是工作机会多、发展好等等，小城市就是离家近、消费低等等。</p><p>北上深仍旧是薪资高地，杭州紧随其后，硕士平均薪资杭州甚至排第二。</p><p>值得注意的是，<strong>西安是北方城市里北京以外唯一上榜城市</strong>，虽然时不时被唱衰，但如果想留在北方，又觉得北京生活压力大，西安确实是个不错的选择。</p><p>合肥离济南</p><h3 id="爱好"><a href="#爱好" class="headerlink" title="爱好"></a>爱好</h3><p>关于爱好的话，我平时会和朋友们一起打篮球、打羽毛球，这样不仅会锻炼身体，也能促进和朋友们的感情；当我独自一个人的时候，喜欢看动漫、影视剧、听音乐或打游戏等来放松下自己，有时候也会跟网上的一些美食博主学习做饭；还有就是，本科阶段我也做过B站的up主，上传过一些自己剪辑的视频，在娱乐的同时也相当于增加了一项技能。</p><h3 id="期望薪资"><a href="#期望薪资" class="headerlink" title="期望薪资"></a>期望薪资</h3><p>总包 月薪 年终奖 其他补贴 当地消费水平</p><p>希望总包30+</p><h3 id="家庭-单身"><a href="#家庭-单身" class="headerlink" title="家庭/单身"></a>家庭/单身</h3><p>家是在一个普通小县城，感觉相比大城市的工作机遇和发展前景还是差很多，因此想在大城市工作感受下；家里父母都是普通打工人，但家庭氛围很和睦，也很重视教育，父母也都支持我的决定。目前没有女朋友，但我觉得对找工作可能不是一件坏事，我可以只考虑自身情况去选择工作地点等等。</p><h3 id="期望的团队"><a href="#期望的团队" class="headerlink" title="期望的团队"></a>期望的团队</h3><p>和谐愉快地相处、平时工作上可以互相帮助，下班有时间也能一起玩耍。团队做的项目期望是一些核心或者能对个人有所提升的项目，当然也不是除此之外的项目就不做了。</p><h3 id="加班"><a href="#加班" class="headerlink" title="加班"></a>加班</h3><p>坦诚的讲，没有人喜欢加班。但总会有主观或客观因素造成了加班，主观因素，比如自己有段时间工作不积极，导致项目临近上线很多工作还没做，这种加班也是自己找的，就需要提高工作效率，反思自己问题。如果外界客观因素导致，偶尔加班也无妨，如果加班过多，可以尝试跟leader或相关人员协调沟通。</p><h2 id="云"><a href="#云" class="headerlink" title="云"></a>云</h2><p><strong>云：</strong>云是网络、互联网的一种比喻说法。</p><p><strong>平台：</strong>即操作系统、数据库和一些中间件都可称为软件平台。</p><p><strong>云计算：</strong>使用互联网接入存储或者运行在远程服务器端的应用，数据，或者服务。</p><p><strong>云平台：</strong>可以理解为存在于互联网中，能够扩展、向其他用户提供基础服务、数据、中间件、数据服务、软件的提供商。</p><p>例如：云服务器空间租用产品，与直接购买服务器存在很大的区别：</p><ul><li>一台服务器主机和存储设备被虚拟化技术分割成N份虚拟主机开放成按月租用。</li><li>云计算厂商搞IDC机房、电力、机柜、走线，还要购买网络路由设备、网络带宽资源、销售网络带宽、运维防止网络抖动，相比过去一次性几百万卖服务器主机、存储设备、网络设备，相当于拆分服务。</li><li>销售服务器主机是一次性的收费，云平台服务是按月收费。</li><li>一次性购买服务器主机，如果服务器/存储/网络设备有磨损，客户要再次购买，而用云平台服务不用考虑这些问题。</li><li>购买服务器主机后，企业要按License购买N份操作系统、中间件、数据库、大数据平台软件。而租用云主机客户按月租用，License还是一份，不是多个。</li></ul><h3 id="云平台的三种服务类型"><a href="#云平台的三种服务类型" class="headerlink" title="云平台的三种服务类型"></a>云平台的三种服务类型</h3><p>我们传统开发一个软件，需要9个东西：</p><p><a target="_blank" rel="noopener" href="https://imgse.com/i/vXwRDs"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/09/12/vXwRDs.png" alt="vXwRDs.png"></a></p><p>作为使用软件的人，左边的【应用】和【数据】，是<strong>离我们最近的部分。</strong></p><blockquote><p>比如最常见的：我们在某软件里提交了报销申请，其实我们就是上传了自己的报销数据到应用中。</p></blockquote><p>最右边的【虚拟化】、【服务器】、【存储】、【网络】是制作一个软件的基础条件，除了虚拟化技术其他都是硬件，所以在云计算领域中，这块被称为基础设施。</p><blockquote><p>它们在机房都能看到。</p></blockquote><p>而中间的这些，就是<strong>利用最右边</strong>的基础设施搭建出的平台，从而<strong>承载最左边</strong>的【应用】和【数据】。</p><p>所以说，从右到左就是一个硬件逐渐软化（软件开发）的过程，IT技术在这个过程中扮演了必要角色：</p><p>但！</p><p><strong>不是所有企业都具有独立开发一个软件的资本</strong>（钱、人、力缺哪个都不行）。</p><p>所以，云服务产生了。</p><p>大大小小企业，财力不同、问题不同，因此对于软件的开发，总有形形色色的需求。</p><p><strong>经过演变，云服务逐渐分为三类：</strong></p><blockquote><p>第一种，云服务提供基础设施，我们可能听过某某说“租了哪里的服务器，准备自己搞个软件……”，其实就是Iaas。<br>第二种，云服务提供一个平台，企业自己设计应用，数据也由自己保管。这就是Paas。<br>第三种，云服务提供现成的软件，数据也全部上云。这就是SaaS。</p></blockquote><p>如图：</p><p><a target="_blank" rel="noopener" href="https://imgse.com/i/vXw55V"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/09/12/vXw55V.png" alt="vXw55V.png"></a></p><p>从Iaas到SaaS的过程，企业需要付出的成本越来越小，云化的程度也越来越高。</p><p><strong>IaaS（Infrastructureas a Service）</strong></p><p>消费者通过Internet 可以从完善的计算机基础设施获得服务。这类服务称为基础设施即服务。即通过软件平台将大量硬件资源集中管理，根据用户请求按需分配存储空间、计算能力、内存大小、防火墙、操作系统、网络环境等基础设施，以满足用户需求。</p><p>其优点在于基础设施可以动态扩展，根据需求升级而增加基础设施的配置和容量。用户只为自己使用到的部分付费，降低运营成本。付费后可以立即获取需要的升级，无须等待较长时间。缺点是安全性、稳定性不确定。如果服务提供商网络环境出问题，用户则不能访问其提供的基础设施，同时运行在基础设施上的Paas、Saas产品也无法提供服务。</p><p><strong>Paas（Platform-as-a-Service）</strong></p><p>把服务器平台作为一种服务提供的商业模式。通过网络进行程序提供的服务称之为SaaS(Software as a Service)。</p><p>云计算时代将“服务器平台”或“开发环境”作为服务的产品，被称为PaaS(Platform as a Service)。 例如企业购买了Iaas虚拟硬件，需要部署一个ERP系统，ERP系统需要大量的服务、数据作为业务支撑，比如采购人员需要知道行业材料价格最新数据，需要知道招投标信息及结果，而PaaS提供商的服务API接口就可以获取到这些数据。</p><p>另外Paas系统还保证ERP系统随着使用量增加可能出现的性能瓶颈，利用企业服务总线、云存储、云缓存解决服务负载均衡、缓存、存储问题，让其运行在基础设施上。 解决专业、公共、非功能性问题的服务，不属于业务部分，放入Paas平台，利用云的扩展性，分担业务系统的性能压力。代表产品有ESB、Hadoop等。</p><p>PaaS的价值在于提供独特的价值能力，这些服务大多是对稀有资源的包装，通过Open API的方式供第三方调用。这些资源包括业务数据、业务服务、计算能力、存储能力等。</p><p><strong>Saas</strong></p><p>随着互联网技术的发展和应用软件的成熟， 在21世纪开始兴起的一种完全创新的软件应用模式。</p><p>与“on-demand software”（按需软件)，theapplication service provider(ASP，应用服务提供商)，hosted software(托管软件)具有相似的含义。</p><p>它是一种通过Internet提供软件的模式，厂商将应用软件统一部署在自己的服务器上，客户根据自己实际需求，通过互联网向厂商定购所需的应用软件服务，按定购的服务多少和时间长短向厂商支付费用，并通过互联网获得厂商提供的服务。</p><p>用户不用购买软件，向提供商租用基于Web的软件，来管理企业经营活动，且无需对软件进行维护，服务提供商会全权管理和维护软件，软件厂商在向客户提供互联网应用的同时，也提供软件的离线操作和本地数据存储，让用户随时随地都可以使用其定购的软件和服务。</p><p>对于许多小型企业来说，SaaS是使用先进技术的最好途径，它消除了企业购买、构建和维护基础设施和应用程序的需要。 为降低企业运营成本，企业通过购买Saas平台的软件直接使用达到软件目标，而不必购买服务器、部署在自己人服务器上的软件、专人的维护。只需要按照次数或者使用量来付费。代表模式：多租户。</p><p>其优点在于使用方便，运营成本低。缺点是除了稳定性、安全性外，软件定制开发、升级、与其他软件整合，都需要Saas提供商的支持。</p><h3 id="两类云产品：公有云-amp-私有云"><a href="#两类云产品：公有云-amp-私有云" class="headerlink" title="两类云产品：公有云&amp;私有云"></a>两类云产品：公有云&amp;私有云</h3><p>云产品和云平台越来越多，对于企业来说，企业首要面对的第一个问题是选择公有云还是私有云。</p><p><strong>私有云</strong></p><p>为单个客户构建，对数据、安全和服务质量提供最有效的控制。公司拥有基础设施并控制如何在其上部署应用程序。</p><p>私有云可以部署在企业数据中心的防火墙内或安全的托管位置。</p><p>私有云可以由公司自己的IT组织或云提供商构建。</p><p>“托管专用”模式中，此类云计算提供商可以安装、配置和操作基础设施，以支持企业数据中心内的专用云。</p><p>这种模式使公司能够高度控制云资源的使用，同时带来构建和运行环境所需的专业知识。</p><p><strong>公共云</strong></p><p>公共云通常指由第三方供应商提供供用户使用的云。</p><p>公共云可以通过互联网使用，可能是免费或低成本的，在开放公共网]络中使用。</p><p>外部用户通过互联网访问服务，不拥有云计算资源。能够以低价为终端用户提供有吸引力的服务，创造新的商业价值，将公共云作为一个支持平台，并整合上游服务（如增值业务、广告）提供商和下游终端用户，建立新的价值链和生态系统。</p><h3 id="iPaaS和aPaaS"><a href="#iPaaS和aPaaS" class="headerlink" title="iPaaS和aPaaS"></a>iPaaS和aPaaS</h3><p><strong>ipaas和apaas的产生，是因为企业在使用软件过程中，又遇到了难以解决的问题：</strong></p><p>1、<strong>对于很多企业来说，SaaS都是固定功能的软件，</strong>对于自己需要个性化的需求难以满足，虽然软件开发能灵活满足自己的需求，但是无论是自研还是托管，开发和运维费用都极其高昂</p><p>3、一个软件解决不了所有问题，那就多堆几个软件，<strong>导致一个企业可能用了五六个软件，但都互相独立，无论是功能还是数据，都不能连起来</strong></p><p>本来想通过信息化提高效率、解决数据难题的，却使得数据壁垒越来越厚、事情越做越多。</p><p><strong>这可不行。</strong></p><p><strong>所以ipaas和apaas产生了。</strong></p><p><strong>首先，是企业的个性化问题。</strong></p><p>堵死一大批企业的，其实就是软件开发的门槛过高。要找到懂开发又懂业务的IT太难了，业务人员为了开发去学编程也不是朝夕就能实现。</p><p>怎么才能提供一种框架，让业务人员不需要学代码就能自己设计出一个管理软件呢？这种模式就是apaas，从应用和数据层面入手，设计搭建工具与逻辑，实现零代码开发。</p><p>而apaas从<strong>应用和数据层面入手</strong>，就足以看出，它趋向于PaaS和SaaS之间。</p><p><strong>其次，就是打通企业内部的各个软件问题。</strong></p><p>由于企业堆叠的各种SaaS软件，用着不同的主机和数据库，怎么将这些软件集成起来？这就需要一种技术，也就是iPaaS。</p><p>它从<strong>虚拟主机和数据库层面</strong>入手，创建一个中心生态系统来查看、管理和修改所有数据、基础设施和操作。从而轻松打通各个系统的数据与功能。</p><p>可以看出，iPaaS则趋向于IaaS和PaaS之间。</p><h4 id="各自功能："><a href="#各自功能：" class="headerlink" title="各自功能："></a>各自功能：</h4><ul><li>解决企业里各个软件造成的壁垒问题，减轻IT任务量——ipaas</li><li>满足企业追求的灵活但要性价比高的软件开发，降低开发门槛——apaas</li></ul><h4 id="技术偏重点："><a href="#技术偏重点：" class="headerlink" title="技术偏重点："></a>技术偏重点：</h4><ul><li>ipaas偏向IaaS</li><li>apaas偏向SaaS</li></ul><h4 id="使用对象："><a href="#使用对象：" class="headerlink" title="使用对象："></a>使用对象：</h4><ul><li>ipaas：IT人员</li><li>apaas：所有人</li></ul><h2 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><h4 id="React-vs-Vue-★"><a href="#React-vs-Vue-★" class="headerlink" title="React vs Vue ★"></a>React vs Vue ★</h4><p><strong>设计理念不同</strong></p><ul><li>react整体上是<strong>函数式编程</strong>思想，组件使用<code>jsx</code>语法，all in js，将html与css全都融入javaScript中，jsx语法相对来说更加灵活。</li><li>vue的整体思想，是拥抱经典的<code>html(结构)+css(表现)+js(行为)</code>的形式，使用template模板，并提供指令供开发者使用，如v-if、v-show、v-for等，开发时有结构、表现、行为分离的感觉。</li></ul><p><strong>数据是否可变</strong></p><ul><li>vue的思想是<strong>响应式</strong>的，通过<code>Object.defineproperty</code>或<code>proxy</code>代理实现数据监听，每一个属性添加一个<code>dep</code>对象（用来存储对应的<code>watcher</code>），当属性变化的时候，通知对应的<code>watcher</code>发生改变。</li><li>react推崇的是<strong>数据不可变</strong>，react使用的是<strong>浅比较</strong>，如果对象和数据的引用地址没有变，react认为该对象没有变化，所以react变化时一般都是新创建一个对象。</li></ul><p><strong>更新渲染方式不同</strong></p><ul><li>当组件的状态发生变化时，vue是响应式，通过对应的watcher自动找到对应的组件重新渲染。</li><li>react需要更新组件时，会重新走渲染的流程，通过从根节点开始遍历，dom diff找到需要变更的节点，更新任务还是很大，需要使用到 Fiber，将大任务分割为多个小任务，可以中断和恢复，不阻塞主进程执行高优先级的任务。</li></ul><p><strong>各自的优势不同</strong></p><ul><li>vue的优势包括：框架内部封装的多，更容易上手，简单的语法及项目创建， 更快的渲染速度和更小的体积。</li><li>react的优势包括： react更灵活，更接近原生的js、可操控性强，对于能力强的人，更容易造出更个性化的项目。</li></ul><p><strong>React优势</strong></p><ul><li><strong>灵活的结构和可扩展性</strong>。</li><li><strong>丰富的JavaScript库</strong>。</li><li>发展： React得到了<code>Facebook</code>专业开发人员的支持，他们不断寻找改进方法。</li><li>Web或移动平台： React提供<code>React Native</code>平台，可通过相同的React组件模型为<code>iOS</code>和<code>Android</code>开发本机呈现的应用程序。</li></ul><p><code>react</code>在中后台项目中由于在<strong>处理复杂的业务逻辑或组件的复用问题</strong>比<code>vue</code>优雅而被人认可，但这种优雅是要有成本代价的，它更需要团队技术整体比较给力，领头大佬的设计与把关能力要更优秀，因此开发成本更大。</p><p><code>vue</code><strong>更友好更易上手</strong>的写法著称，渐进式的框架、更友好的api、更亲民的设计让开发成本大大下降而效率大大提升。</p><p><code>vue</code>与<code>react</code>在发展长河中越发成熟，深思熟虑后觉得<strong>两者不管在移动端或大型中后台都是非常可行的</strong>，其实框架本无好坏之分，我们更应该思考的是团队想要用什么技术栈、自己喜欢与擅长什么技术栈。</p><h4 id="模块化、组件化、工程化"><a href="#模块化、组件化、工程化" class="headerlink" title="模块化、组件化、工程化"></a>模块化、组件化、工程化</h4><h5 id="模块化-1"><a href="#模块化-1" class="headerlink" title="模块化"></a>模块化</h5><p>后端：<strong>CommonJS</strong> :<code>module.exports</code>、<code>require</code>方法用于加载模块。</p><p>前端：<strong>ES6</strong> 模块化语法：export 和 import；</p><h5 id="工程化-1"><a href="#工程化-1" class="headerlink" title="工程化"></a>工程化</h5><p><code>webpack</code>最热门的前端资源模块化管理和打包工具、</p><p><code>create-react-app</code> 脚手架初始化react 项目开发、</p><p><code>ESLint</code> 插件化的 JavaScript 代码检测工具</p><h5 id="组件化-1"><a href="#组件化-1" class="headerlink" title="组件化"></a>组件化</h5><p>其中以React的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。</p><p>理解:<strong>用来实现局部功能效果的代码和资源的集合(html/css/js/img等等)</strong></p><p>为什么要用组件:一个界面的功能复杂</p><p>作用:<strong>复用编码,简化项目编码,提高运行效率</strong></p><p>当应用是以多组件的方式实现,这个应用就是组件化的应用。</p><h4 id="框架好处"><a href="#框架好处" class="headerlink" title="框架好处"></a>框架好处</h4><ol><li><strong>组件化</strong>: 其中以 React 的组件化最为彻底,甚至可以到<strong>函数级</strong>别的原子组件,高度的组件化可以是我们的工程<strong>易于维护、易于组合拓展</strong>。</li><li><strong>天然分层</strong>: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。</li><li><strong>生态</strong>: 现在主流前端框架都<strong>自带生态</strong>,不管是<strong>数据流管理架构</strong>还是 <strong>UI 库</strong>都有成熟的解决方案。</li><li><strong>开发效率</strong>: 现代前端框架都默认<strong>自动更新DOM</strong>,而非我们手动操作,解放了开发者的手动DOM成本,提高开发效率,从根本上解决了UI 与状态同步问题。</li></ol><p>常见框架：<strong>Angular React Vue Svelte</strong></p><h3 id="计算机网络和浏览器"><a href="#计算机网络和浏览器" class="headerlink" title="计算机网络和浏览器"></a>计算机网络和浏览器</h3><h4 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h4><h5 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h5><p><strong>物理层（Physical Layer）</strong></p><ul><li><p>网路的物理层面确保原始的数据可在各种物理媒体上传输。</p></li><li><p>功能</p><ul><li>为数据端设备提供传送数据通路</li><li>传输数据</li></ul></li><li><p>设备：</p><ul><li>光纤、CAT-5/6/7线 <strong>双绞线</strong></li><li>RJ-45接头 双绞线与网卡，双绞线与集线器的接口，俗称<strong>水晶头</strong>。</li><li>集线器 Ethernet <strong>hub</strong></li><li>串口 Universal Serial Bus（通用串行总线）、并口</li></ul></li></ul><p><strong>数据链路层（Data Link Layer）</strong></p><ul><li><p>在广播式多路访问链路中（局域网），由于可能存在介质争用，它还可以细分成介质访问控制（MAC）子层和逻辑链路控制（LLC）子层，介质访问控制（MAC）子层专职处理介质访问的争用与冲突问题。</p></li><li><p>功能</p><ul><li><p>在两个网络实体之间提供数据链路连接的创建、维持和释放管理。构成数据链路数据单元（frame：数据帧或帧），并对帧定界、同步、收发顺序的控制。并且包括传输过程中的网络流量控制、差错检测和差错控制等方面。</p></li><li><p>只提供导线的一端到另一端（本质是点到点）的数据传输。</p></li><li><p>数据链路层会在 frame 尾端置放检查码（parity，sum，CRC）以检查实质内容，将物理层提供的可能出错的物理连接改造成逻辑上无差错的数据链路，并对物理层的原始数据进行数据封装。</p></li><li><p>数据链路层中的数据封装是指：封装的数据信息中，包含了地址段和数据段等。地址段含有点对点]发送节点和接收节点的地址（如MAC），控制段用来表示数格连接帧的类型，数据段包含实际要传输的数据。</p></li></ul></li><li><p>协议：<strong>点对点协议</strong>（英语：<strong>P</strong>oint-to-<strong>P</strong>oint <strong>P</strong>rotocol，缩写：<strong>PPP</strong>）、以太网Ethernet（IEEE 802.3）、Wi-Fi（IEEE 802.11）</p></li><li><p>设备：</p><ul><li>网卡（物理层和数据链路层的MAC子层）</li><li>交换机是本层设备。而集线器是物理层设备，不是数据链路层设备。</li><li>桥接器（又称网桥）</li></ul></li></ul><p><strong>网络层（Network Layer）</strong></p><ul><li><p>提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。相当于发送邮件时需要地址一般重要。由于TCP/IP协议体系中的网络层功能由IP协议规定和实现，故又称IP层。</p></li><li><p><strong>功能</strong></p><ul><li>寻址：对网络层而言使用IP地址来唯一标识互联网上的各个寻址，网络层依靠IP地址进行相互通信（类似于MAC地址）。</li><li>路由：在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间相互通信则必须借助路由器等三层设备。</li></ul></li><li><p><strong>虚电路和数据报网络</strong></p><ul><li>在传输层每个应用可以被提供两个服务：无连接的UDP和有链接的TCP，在网络层也能为主机之间提供无连接和有链接的服务。</li></ul><ul><li>在网络层中这些服务（无论是有链接还是无连接）都是提供<strong>主机到主机</strong>的服务，在传输层中提供的则是提供<strong>应用层进程</strong>之间的服务。</li><li>在至今为止的所有的主要计算机网络结构体系中（因特网、ATM、帧中继等），网络层提供了主机到主机无连接或者有连接服务，而不同时提供两种服务。仅提供无连接的的网络称为数据报网络(Datagram Network)，仅提供有连接的网络称为虚电路网络（Virtual-Circuit，VC）。</li></ul></li><li><p><strong>协议</strong>：IP （V4、V6）、ICMP（V4、V6）、OSPF</p></li><li><p><strong>设备</strong>：路由器、三层交换机（具有部分路由器功能的交换机）</p></li></ul><p><strong>传输层（英语：Transport Layer）</strong></p><ul><li><p>该层的协议为应用进程提供端到端的通信服务。</p></li><li><p>最著名的TCP/IP传输协议是传输控制协议（TCP）, 它的名称借用自整个包的名称。它用于面向连接的传输，而无连接的用户数据报协议（UDP）用于简单消息传输。TCP是更复杂的协议，因为它的状态性设计结合了可靠传输和数据流服务。这个协议组中其他重要协议有数据拥塞控制协议（DCCP）与流控制传输协议（SCTP）。</p></li></ul><h5 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h5><p><strong>TCP/IP</strong>体系结构相当于将<strong>OSI</strong>体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p><p>教学时经常把TCP/IP体系结构的<strong>网络接口层</strong>分成了<strong>物理层</strong>和<strong>数据链路层</strong>。</p><ul><li><p><strong>应用层，负责向用户提供一组应用程序</strong></p><ul><li>HTTP 协议（超文本传输协议，网页浏览常用的协议）</li><li>DHCP 协议（动态主机配置）</li><li>DNS 系统原理（域名系统）</li><li>FTP 协议（文件传输协议）</li><li>Telnet协议（远程登陆协议）</li><li>电子邮件协议等（SMTP、POP3、IMAP）</li></ul></li><li><p><strong>传输层，负责端到端的通信，比如 TCP、UDP 等</strong>；</p></li><li><p><strong>网络层，负责网络包的封装、分片、路由、转发</strong></p><ul><li>IP 协议（TCP/IP 协议的基础，分为 IPv4 和 IPv6）</li><li>ARP 协议（地址解析协议，用于解析 IP 地址和 MAC 地址之间的映射）</li><li>ICMP 协议（控制报文协议，用于发送控制消息）</li><li>NAT 协议（网络地址转换协议）</li><li>RIP 协议、OSPF 协议、BGP 协议（路由选择协议）</li></ul></li><li><p><strong>网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等</strong>；</p><ul><li>差错检测技术</li><li>多路访问协议（信道复用技术）</li><li>CSMA/CD 协议</li><li>MAC 协议</li><li>以太网技术</li></ul></li></ul><h5 id="为什么网络要分层？"><a href="#为什么网络要分层？" class="headerlink" title="为什么网络要分层？"></a>为什么网络要分层？</h5><ul><li><strong>各层之间相互独立</strong></li><li><strong>提高了整体灵活性</strong> 高内聚，低耦合</li><li><strong>大问题化小</strong></li></ul><h5 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h5><ul><li>两台电脑可以通过一根<strong>网线</strong>直接连接，进行通信。</li><li>机器一多，可以把网线都接到<strong>集线器</strong>（<strong>物理层</strong>）上，但是集线器会不管三七二十一进行<strong>广播</strong>。</li><li>不想广播，可以用（二层）<strong>交换机</strong>（<strong>数据链路层</strong>），又叫多端口网桥，它比较聪明，会自我学习生产<strong>MAC地址表</strong>，知道消息发到哪，那就<strong>不需要广播</strong>啦。</li><li><strong>互联网</strong>电脑这么多，交换机MAC地址表总不能全放下吧。改用<strong>路由器</strong>（<strong>网络层</strong>），也叫<strong>三层交换机</strong>，通过网段的方式定位要把消息转发到哪，就不需要像交换机那样苦哈哈一条条记录MAC地址啦（具有<strong>MAC地址</strong>和<strong>IP地址</strong>）。</li><li>路由器和光猫之间是好搭档，<strong>光猫</strong>负责把光纤里的光信号转换成电信号给路由器。</li><li>现在一般情况下，家里已经不用集线器和交换机了，<strong>大部分路由器也支持交换机的功能</strong>。所以可以看到，家里的台式机电脑一般就连到一个路由器，再连个光猫就够能快乐上网了。</li></ul><h4 id="URL输入到页面展现"><a href="#URL输入到页面展现" class="headerlink" title="URL输入到页面展现"></a>URL输入到页面展现</h4><p>总体来说分为以下几个过程:</p><ul><li>浏览器查找当前URL是否存在<strong>缓存</strong>，并比较缓存是否过期。（先判断HTTP请求浏览器是否已缓存）<ul><li><strong>有缓存</strong><ul><li>如为<strong>强制缓存</strong>，通过<code>Expires</code>或<code>Cache-Control：max-age</code>判断该缓存是否过期，未过期，直接使用该资源；Expires和max-age，如果两者同时存在，则被Cache-Control的max-age覆盖。</li><li>如为<strong>协商缓存</strong>，请求头部带上相关信息如<code>if-none-match（Etag）</code>与<code>if-modified-since(last-modified)</code>，验证缓存是否有效，若有效则返回状态码为<code>304</code>，若无效则重新返回资源，状态码为<code>200</code></li></ul></li></ul></li></ul><ul><li><p><strong>解析URL并生成HTTP请求报文</strong></p></li><li><p><strong>DNS 解析</strong>：将<strong>域名</strong>解析成<strong>IP地址</strong></p></li><li><p><strong>TCP 三次握手</strong>建立连接、<strong>TLS三次握手</strong> =》在<strong>HTTPS</strong>上建立安全连接</p></li><li><p>将HTTP报文添加TCP头部（源、目标端口、序号、窗口大小和状态位）生成<strong>TCP报文</strong></p></li><li><p>添加<strong>IP包头</strong>（源、目标IP）和<strong>MAC包头</strong>（收发MAC地址）将数据封装成<strong>网络包</strong></p></li><li><p><strong>网卡驱动</strong>从IP模块获取到包之后，再次封装。</p></li><li><p><strong>网卡</strong>会将包转为<strong>电信号</strong>（光纤传输的话可能还有电光转换）。</p></li><li><p>网络包经过<strong>交换机</strong>和<strong>路由器</strong>转发到达<strong>服务器</strong></p></li><li><p>服务器将<strong>MAC、IP、TCP、HTTP头部一层层解析处理</strong>，<strong>将网页放入HTTP响应报文中</strong>，<strong>穿上TCP、IP、MAC头部返回</strong></p></li><li><p>浏览器拿到HTTP响应报文后，将<strong>HTML和CSS解析出DOM 树和 CSS 规则树</strong>（<strong>CSSOM</strong>），两者生成<strong>渲染树</strong>，之后进行<strong>页面布局与绘制</strong></p><ul><li>如果遇到 script 标签，则判断是否含有 <code>defer</code> 或者 <code>async</code> 属性，如果有，异步去下载该资源；如果没有设置，暂停dom的解析，去加载script的资源，然后执行该js代码（<strong>script标签加载和执行会阻塞页面的渲染</strong>）</li></ul></li><li><p>断开TCP连接 ：<strong>TCP四次挥手</strong></p></li></ul><h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><p>统一资源定位符，URI是统一资源标志符</p><p><strong>URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</strong></p><p>URL遵守以下的语法规则：<code>scheme://host.domain:port/path/filename</code></p><ul><li><strong>scheme</strong> - 定义因特网服务的类型。常见的协议有 <strong>http、https、ftp、file</strong>，其中最常见的类型是 http，而 <strong>https 则是进行加密的网络传输</strong>。</li><li><strong>host</strong> - 定义域主机（http 的默认主机是 <strong>www</strong>）</li><li><strong>domain</strong> - 定义因特网<strong>域名</strong>，比如 <code>w3school.com.cn</code></li><li><strong>port</strong> - 定义主机上的<strong>端口号</strong>（http 的默认端口号是 80）</li><li><strong>path</strong> - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</li><li><strong>filename</strong> - 定义文档/资源的名称</li></ul><p>当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是<code>/index.html</code>或者<code>/default.html</code>这些文件，这样就不会发生混乱了。</p><h5 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h5><p>委托操作系统将消息发送给Web服务器，<strong>需要查询服务器域名对应的IP地址。</strong></p><p>DNS服务器就<strong>专门保存了Web服务器域名与IP的对应关系</strong>。</p><p><strong>查询过程</strong></p><ul><li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li><li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器<strong>缓存</strong>中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li><li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li><li>本地DNS服务器向<strong>顶级域名服务器（.com）</strong>发送请求，返回相关的下一级的权威域名服务器的地址</li><li>本地DNS服务器向**权威域名服务器(.baidu.com)**发送请求，域名服务器返回对应的结果(<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>)</li><li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li><li>本地DNS服务器将返回结果返回给浏览器</li></ul><p>DNS解析是一个包含<strong>迭代</strong>查询和<strong>递归</strong>查询的过程。</p><ul><li>一般<strong>我们向本地 DNS 服务器</strong>发送请求的方式就是<strong>递归查询</strong>，因为我们只需要发出<strong>一次请求</strong>，然后<strong>本地 DNS 服务器返回给我们最终的请求结果</strong>。</li><li>而<strong>本地 DNS 服务器向其他域名服务器</strong>请求的过程是<strong>迭代查询</strong>的过程，因为<strong>每一次域名服务器只返回单次查询的结果，下一级的查询由本地 DNS 服务器自己进行</strong>。</li></ul><p><strong>DNS预解析</strong></p><p>DNS Prefetch 是一种DNS 预解析技术，当你浏览网页时，浏览器会在对网页中的域名进行解析缓存，这样当页面中需要加载该域名的资源时就无需解析，减少用户等待时间，提高用户体验。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//hhh.images.test.com.cn&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="TCP三次握手-★"><a href="#TCP三次握手-★" class="headerlink" title="TCP三次握手 ★"></a>TCP三次握手 ★</h4><p>TCP连接的建立，通常称为三次握手。</p><p>这个所谓的「连接」，只是双方计算机里<strong>维护一个状态机</strong>。</p><p><strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小，称为连接。</strong></p><ul><li><strong>Socket</strong>:由<strong>IP地址</strong>和<strong>端口号</strong>组成</li><li><strong>序列号</strong>:用来解决乱序问题等</li><li><strong>窗口大小</strong>:用来做流量控制</li></ul><p><strong>三次握手</strong></p><ul><li>一开始，客户端和服务端都处于关闭状态。先是服务端<strong>主动监听某个端口</strong>。</li><li>客户端把第一个发送报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，其中包含<strong>客户端序列号</strong>（<code>client_isn</code> ），并且<code>SYN</code> 标志位置为<code>1</code>。</li><li>服务端收到客户端的<code>SYN</code>报文后，发送应答报文给客户端，该报文也不包含应用层数据，包含<strong>服务端序列号</strong>（<code>server_isn</code>）、<strong>确认序列</strong>（<code>client_isn +1</code>）、并且<code>SYN</code>和<code>ACK</code>置1。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，其中包含<strong>确认序列</strong>（<code>server_isn +1</code>），并且<code>ACK</code>置1。这次报文<strong>可以携带客户到服务器的数据</strong>，之后客户端处于建立连接状态。</li><li>服务器收到客户端的应答报文后，也进入建立连接状态。</li></ul><p><strong>为什么三次？</strong></p><p><strong>因为三次握手才能保证双方具有接收和发送的能力</strong>。</p><p><strong>序列号能够保证数据包不重复、不丢弃和按序传输。</strong></p><p><strong>通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。</strong></p><p>不使用<strong>两次握手</strong>和<strong>四次握手</strong>的原因:</p><ul><li>两次握手︰<strong>无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号</strong>;</li><li>四次握手︰三次握手就已经<strong>理论上最少可靠连接建立</strong>，所以不需要使用更多的通信次数。</li></ul><h4 id="TCP四次挥手-★"><a href="#TCP四次挥手-★" class="headerlink" title="TCP四次挥手 ★"></a>TCP四次挥手 ★</h4><p><strong>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</strong></p><ul><li>客户端打算关闭连接，此时会发送<code>FIN</code>报文（<code>FIN</code>置1），之后客户端进入<code>FIN_WAIT_1</code>状态。</li><li>服务端收到该报文后，就向客户端发送<code>ACK</code>应答报文，接着服务端进入<code>CLOSED_WAIT</code>状态；客户端收到服务端的<code>ACK</code>应答报文后，之后进入<code>FIN_WAIT_2</code>状态。</li><li>等待<strong>服务端处理完数据后</strong>，也向客户端发送<code>FIN</code> 报文，之后服务端进入<code>LAST_ACK</code>状态。</li><li>客户端收到服务端的<code>FIN</code> 报文后，回一个<code>ACK</code>应答报文，之后进入<code>TIME_WAIT</code>状态。</li><li>服务器收到了<code>ACK</code>应答报文后，就完成连接的关闭。</li><li>客户端在经过<code>2MSL</code>一段时间后，自动进入关闭状态。</li></ul><p><strong>为什么挥手需要四次</strong>?</p><p>再来回顾下四次挥手双方发FIN 包的过程，就能理解为什么需要四次了。</p><ul><li>关闭连接时，客户端向服务端发送<code>FIN</code> 时，仅仅表示<strong>客户端不再发送数据了但是还能接收数据</strong>。</li><li>服务器收到客户端的<code>FIN</code>报文时，先回一个<code>ACK</code>应答报文，而服务端可能还有数据需要处理和发送，等<br>服务端不再发送数据时，才发送<code>FIN</code>报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，<strong>服务端通常需要等待完成数据的发送和处理</strong>，所以服务端的<code>ACK</code>和 <code>FIN</code>一般都会分开发送，从而比三次握手导致多了一次。</p><p><strong>主动关闭连接的，才有TIME_WAIT状态</strong>。</p><p><code>MSL</code>是<code>Maximum Segment Lifetime</code>，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><ul><li>保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，如果服务端没有收到，服务端会重发一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</li><li>防止“已经失效的连接请求报文段”出现在本连接中</li></ul><p>客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的所产生的所有报文都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><p>经过<code>2MSL</code>这个时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><p><code>TIME-WAIT</code>更重要的作用是<strong>等待足够的时间以确保最后的ACK能让被动关闭方接收，从而帮助其正常关闭</strong>。</p><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>HTTP：<strong>超文本传输协议</strong>。</p><p><strong>HTTP是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><p><strong>请求报文包括：</strong></p><ul><li><strong>请求行</strong>：包括<strong>请求方法</strong>、<strong>请求的URL</strong>、<strong>HTTP协议及版本</strong>。</li><li><strong>请求头</strong>：一大堆的键值对。</li><li><strong>空行</strong>指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。</li><li><strong>请求体</strong>：数据部分。</li></ul><p>响应报文包括：</p><ul><li><strong>状态行</strong>：<strong>HTTP协议及版本</strong>、<strong>状态码</strong>及<strong>状态描述</strong>。</li><li><strong>响应头</strong></li><li><strong>空行</strong></li><li><strong>响应体</strong></li></ul><h5 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h5><p><strong>1xx</strong>类状态码属于<strong>提示信息</strong>，是协议处理中的一种<strong>中间状态</strong>，实际用到的比较少。</p><p><strong>2xx</strong>类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li><strong>200 OK</strong> 是最常见的成功状态码，表示一切正常。</li></ul><p><strong>3xx</strong>类状态码表示客户端请求的资源发送了变动，需要客户端用新的URL重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li><p><strong>301 Moved Permanently</strong> 表示<strong>永久重定向</strong>，说明请求的资源已经不存在了，需改用新的URL再次访问。</p></li><li><p><strong>302 Found</strong> 表示<strong>临时重定向</strong>，说明请求的资源还在，但暂时需要用另一个URL来访问。</p><ul><li><strong>301</strong>和<strong>302</strong>都会在响应头里使用字段<strong>Location</strong>，指明后续要跳转的URL，浏览器会自动重定向新的URL。</li></ul></li><li><p><strong>304 Not Modified</strong> 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称<strong>缓存重定向</strong>，用于缓存控制。</p></li></ul><p><strong>4xx</strong>类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是<strong>错误码</strong>的含义。</p><ul><li><strong>400 Bad Request</strong> 表示客户端请求的报文有错误，但只是个笼统的错误</li><li><strong>403 Forbidden</strong> 表示<strong>服务器禁止访问资源</strong>，并不是客户端的请求出错。</li><li><strong>404 Not Found</strong> 表<strong>示请求的资源在服务器上不存在或未找到</strong>，所以无法提供给客户端。</li></ul><p><strong>5xx</strong>类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于<strong>服务器端的错误码</strong>。</p><p>项目静态网页状态码 <code>404 &amp; 405</code></p><p><strong>405 Method Not Allowed</strong>表明服务器禁止了使用当前 HTTP 方法的请求。绝大多数web服务器，都不允许静态文件响应POST请求。</p><h5 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h5><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><p><strong>根据场景合理使用各个方法，可以起到优化性能、增加网络安全的效果。</strong></p><h6 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h6><p>与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将不传回资源的本文部分，只返回<strong>头部消息</strong>。</p><p>HEAD 方法的使用场景</p><ul><li>在不获取资源的情况下，了解资源的一些信息，比如资源类型；</li><li>通过查看响应中的状态码，可以确定资源是否存在；</li><li>通过查看首部，测试资源是否被修改。</li></ul><h6 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h6><p>PUT 方法用于将数据发送到服务器来创建/更新资源。</p><p>PUT 与 POST 方法的区别在于，<strong>PUT 方法是幂等的</strong>：<strong>调用一次与连续调用多次是等价的（即没有副作用）</strong>。</p><h6 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h6><p>DELETE 方法就是请求服务器删除指定 URL 所对应的资源。</p><h5 id="GET-与-POST-★"><a href="#GET-与-POST-★" class="headerlink" title="GET 与 POST ★"></a>GET 与 POST ★</h5><p><code>GET</code>方法的含义是<strong>请求从服务器获取资源</strong>，这个资源可以是静态的文本、页面、图片视频等。</p><p>而<code>POST</code>方法则是相反操作，它向<code>URI</code>指定的资源提交数据，数据就放在报文的<code>body</code>里。</p><h6 id="参数传递方式"><a href="#参数传递方式" class="headerlink" title="参数传递方式"></a>参数传递方式</h6><ul><li>GET 的参数一般是通过 <code>?</code> 跟在 URL 后面的，多个参数通过 <code>&amp;</code> 连接</li><li>POST 的参数一般是包含在请求体中。</li></ul><h6 id="参数长度限制不同"><a href="#参数长度限制不同" class="headerlink" title="参数长度限制不同"></a>参数长度限制不同</h6><p>GET 和 POST 传递参数的长度不同：</p><ul><li>get传送的数据量较小，不能大于2KB。</li><li>post传送的数据量较大，一般被默认为不受限制。</li></ul><p>在这里我们要明确一点：<strong>HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。</strong></p><p>服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。</p><h6 id="安全和幂等"><a href="#安全和幂等" class="headerlink" title="安全和幂等"></a>安全和幂等</h6><ul><li>在HTTP 协议里，<strong>所谓的「安全」是指请求方法不会「破坏」服务器上的资源</strong>。</li><li><strong>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</strong></li></ul><p>那么很明显<strong>GET方法就是安全且幂等</strong>的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</p><p><strong>POST</strong>因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等的</strong>。</p><h6 id="安全性不同（传输的角度）"><a href="#安全性不同（传输的角度）" class="headerlink" title="安全性不同（传输的角度）"></a>安全性不同（传输的角度）</h6><p>因为参数传递方式的不同，所以 GET 和 POST 的安全性不同：GET 比 POST 更不安全，因为参数直接暴露在URL上，所以 GET 不能用来传递敏感信息。</p><blockquote><p>从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上抓包，就能完整地获取数据报文，要想安全传输，就只有加密，也就是 HTTPS。</p></blockquote><h6 id="缓存机制不同"><a href="#缓存机制不同" class="headerlink" title="缓存机制不同"></a>缓存机制不同</h6><p>这个需要从以下几点来说明：</p><ul><li>GET 请求会<strong>被浏览器主动cache</strong>，而 POST 不会，除非手动设置。</li><li>GET 请求参数<strong>会被完整保留在浏览器历史记录里</strong>，而 POST 中的参数不会被保留。</li><li>GET 在<strong>浏览器回退时是无害的</strong>，而 POST 会再次提交请求。</li></ul><h6 id="时间消耗不同"><a href="#时间消耗不同" class="headerlink" title="时间消耗不同"></a>时间消耗不同</h6><p>GET 和 POST 请求时间的不同主要是因为：</p><ul><li>GET 产生<strong>一个</strong> TCP 数据包；</li><li>POST 产生<strong>两个</strong> TCP 数据包。</li></ul><p>对于 GET 方式的请求，浏览器会把 <strong>header 和 data</strong> 一并发送出去，服务器响应 200（返回数据）；而对于 POST，浏览器先发送 <strong>header</strong>，服务器响应 <strong>100 continue</strong>，浏览器再发送 <strong>data</strong>，服务器响应 200 ok（返回数据）。</p><p>在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，<strong>两次包的TCP在验证数据包完整性上，有非常大的优点</strong>。</p><h5 id="HTTP头部"><a href="#HTTP头部" class="headerlink" title="HTTP头部"></a>HTTP头部</h5><p><strong><code>Keep-Alive</code></strong> 是一个通用消息头，允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数。</p><p><strong>备注：</strong> 需要将 <code>Connection</code>]首部的值设置为 “keep-alive” 这个首部才有意义。同时需要注意的是，在 HTTP/2 协议中， <code>Connection</code>和<code>Keep-Alive</code> 是被忽略的；在其中采用其他机制来进行连接管理。</p><p><em>parameters</em></p><p>一系列用逗号隔开的参数，每一个参数由一个标识符和一个值构成，并使用等号 (<code>&#39;=&#39;</code>) 隔开。下述标识符是可用的：</p><ul><li><code>timeout</code>：指定了一个空闲连接需要保持打开状态的最小时长（以秒为单位）。需要注意的是，如果没有在传输层设置 keep-alive TCP message 的话，大于 TCP 层面的超时设置会被忽略。</li><li><code>max</code>：在连接关闭之前，在此连接可以发送的请求的最大值。在非管道连接中，除了 0 以外，这个值是被忽略的，因为需要在紧跟着的响应中发送新一次的请求。HTTP 管道连接则可以用它来限制管道的使用。</li></ul><p>keep-alive 又叫持久连接，它通过重用一个 TCP 连接来发送/接收多个 HTTP请求，来减少创建/关闭多个 TCP 连接的开销，启用Keep-Alive模式性能更高。</p><ul><li>在 HTTP1.1 协议中默认开启，可以在请求头上看到Connection: keep-alive 开启的标识。</li><li>在HTTP1.0 中非KeepAlive模式时，每次请求都要新建一个TCP请求，请求结束后，要关闭 TCP 连接。效率很低。</li></ul><p>注意：持久连接采用阻塞模式，下次请求必须等到上次响应返回后才能发起，如果上次的请求还没返回响应内容，下次请求就只能等着（就是常说的线头阻塞）。</p><h5 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h5><ul><li>HTTP是<strong>超文本传输协议</strong>，信息是<strong>明文传输</strong>，存在安全风险的问题。HTTPS则解决HTTP不安全的缺陷，<strong>在TCP和HTTP之间加入了SSL/TLS安全协议</strong>，使得报文能够<strong>加密</strong>传输。</li><li>HTTP 连接建立相对简单，<strong>TCP三次握手</strong>之后便可进行HTTP的报文传输。而 HTTPS在<strong>TCP三次握手</strong>之后，还需进行<strong>SSL/TLS的握手</strong>过程，才可进入加密报文传输。</li><li>HTTP的端口号是<strong>80</strong>，HTTPS的端口号是<strong>443</strong>。</li><li>HTTPS 协议需要<strong>向CA(证书权威机构）申请数字证书</strong>，来保证服务器的身份是可信的。</li></ul><blockquote><p>SSL和TLS？</p></blockquote><p>这两实际上是一个东西。很多相关的文章都把这两者并列称呼(SSL/TLS)，因为这两者可以视作<strong>同一个东西的不同阶段</strong>。</p><h5 id="HTTPS优点"><a href="#HTTPS优点" class="headerlink" title="HTTPS优点"></a>HTTPS优点</h5><h6 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h6><p>HTTPS采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的<strong>混合加密</strong>方式，保证信息的<strong>机密性</strong>，解决了窃听的风险:</p><ul><li>在<strong>通信建立前</strong>采用<strong>非对称加密</strong>的方式<strong>交换</strong>「会话秘钥」，后续就不再使用非对称加密。</li><li>在<strong>通信过程中</strong>全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul><p>采用「混合加密」的方式的原因:</p><blockquote><p>对称加密：加密和解密使用的是同一个密钥。</p><p>RSA（非对称加密算法）：双方必须协商一对密钥，一个私钥一个公钥。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。</p></blockquote><p>对称加密运算速度快，但最开始仍可能被拦截，发送信息依然不安全，非对称加密足够安全，但运算速度慢。</p><p><strong>使用非对称加密的方法将加密算法的对称密钥发送过去</strong>，之后就可以使用使用这个密钥，利用<strong>对称密钥</strong>来通信了。</p><h6 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h6><p><strong>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</strong></p><p><strong>如何保证公钥不被篡改和信任度?</strong></p><p>所以这里就需要借助第三方权威机构<code>CA</code>(数字证书认证机构)﹐将<strong>服务器公钥放在数字证书</strong>（由数字证书认证机构颁发)中，只要证书是可信的，公钥就是可信的。</p><h6 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h6><p><strong>摘要算法</strong>用来实现<strong>完整性</strong>，能够为数据生成独一无二的<strong>指纹</strong>﹐用于校验数据的完整性，解决了<strong>篡改</strong>的风险。</p><p>客户端在发送明文之前会通过<strong>摘要算法</strong>算出明文的<strong>指纹</strong>，发送的时候把<strong>指纹＋明文</strong>一同加密成密文后，发送给服务器，服务器解密后，用<strong>相同的摘要算法</strong>算出发送过来的明文，通过比较客户端携带的<strong>指纹</strong>和当前算出的<strong>指纹</strong>做比较，若<strong>指纹</strong>相同，说明数据是完整的。</p><h5 id="HTTPS连接"><a href="#HTTPS连接" class="headerlink" title="HTTPS连接"></a>HTTPS连接</h5><p><strong>https采用非对称加密+对称加密，非对称加密来传递密钥；对称加密来加密内容</strong></p><ul><li>客户端使用https的url访问web服务器，要求与服务器建立ssl连接</li><li>服务器收到客户端请求后, 会将**网站的证书(包含公钥)**传送一份给客户端</li><li>客户端收到网站证书后会检查证书的<strong>颁发机构以及过期时间</strong>, 如果没有问题就<strong>随机产生一个秘钥</strong></li><li>客户端利用<strong>公钥将会话秘钥加密</strong>, 并传送给服务端</li><li>服务端利用自己的<strong>私钥</strong>解密出会话秘钥，之后服务器与客户端使用秘钥加密传输</li></ul><p>整个SSL/TLS的握手阶段全部结束后，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用<strong>会话秘钥加密内容。</strong></p><p>SSL/TLS 1.2需要4次握手，SSL/TLS 1.3优化了过程，<strong>只需要3次握手</strong>。</p><h5 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h5><p><strong>中间人攻击过程如下：</strong></p><p>1）客户端向服务器发送建立连接的请求<br>2）服务器向客户端发送<strong>公钥</strong><br>3）<strong>攻击者截获公钥</strong>，保留在自己手上<br>4）然后攻击者自己生成一个<strong>【伪造的】公钥</strong>，发给客户端<br>5）客户端收到伪造的公钥后，生成加密的秘钥值发给服务器<br>6）攻击者获得加密秘钥，用自己的私钥解密获得秘钥<br>7）同时生成假的加密秘钥，发给服务器<br>8）服务器用私钥解密获得假秘钥<br>9）服务器用假秘钥加密传输信息</p><p><strong>防范方法：</strong></p><p>服务端在发送浏览器的<strong>公钥中加入CA证书</strong>，<strong>浏览器可以验证CA证书的有效性</strong>。</p><h5 id="浏览器如何验证ca证书的有效性"><a href="#浏览器如何验证ca证书的有效性" class="headerlink" title="浏览器如何验证ca证书的有效性"></a>浏览器如何验证ca证书的有效性</h5><p>浏览器读取证书中的证书所有者、有效期等信息进行校验</p><p>1）校验证书的网站域名是否与证书颁发的<strong>域名一致</strong>。</p><p>2）校验证书是否在<strong>有效期</strong>内。</p><p>3）浏览器查找<strong>操作系统中已内置的受信任的证书发布机构</strong>，与服务器发来的证书中的颁发者做比对，用于校验证书是否为合法机构颁发。</p><h5 id="HTTP-1-1、HTTP-2、HTTP-3演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3演变" class="headerlink" title="HTTP/1.1、HTTP/2、HTTP/3演变"></a>HTTP/1.1、HTTP/2、HTTP/3演变</h5><h6 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h6><p>HTTP/1.1相比HTTP/1.0性能上的改进︰</p><ul><li>使用TCP<strong>长连接</strong>的方式改善了<strong>HTTP/1.0短连接</strong>造成的性能开销。<ul><li><strong>减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载</strong>。</li><li><strong>只要任意一端没有明确提出断开连接，则保持TCP连接状态。</strong></li></ul></li><li>支持<strong>管道（pipeline)网络传输</strong>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li><li>缓存<code>Etag</code></li></ul><p>但HTTP/1.1还是有性能瓶颈︰</p><ul><li><strong>请求/响应头部(Header)未经压缩就发送</strong>，首部信息越多延迟越大。只能压缩<code>Body</code>的部分;</li><li><strong>服务器是按请求的顺序响应的</strong>，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>;</li><li><strong>没有请求优先级控制</strong>;</li><li>请求只能从客户端开始，<strong>服务器只能被动响应</strong>。</li></ul><h6 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h6><p><strong>HTTP/2协议是大多基于HTTPS的，所以HTTP/2的安全性也是有保障的。</strong></p><p>那HTTP/2相比HTTP/1.1 性能上的改进︰</p><ul><li><strong>头部压缩</strong>（HPACK算法）</li><li><strong>二进制格式</strong> 增加了数据传输的效率</li><li><strong>数据流</strong><ul><li>HTTP/2的数据包<strong>不是按顺序发送的</strong>，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</li><li>每个请求或回应的所有数据包，称为一个数据流（<strong>Stream</strong> )。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。</li><li>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</li></ul></li><li><strong>多路复用</strong><ul><li>HTTP/2是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。</li><li>移除了HTTP/1.1中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。</li></ul></li><li><strong>服务器推送</strong><ul><li>HTTP/2还在一定程度上改善了传统的「请求-应答」工作模式，服务不再是被动地响应，<strong>也可以主动向客户端发送消息</strong>。</li><li>举例来说，在浏览器刚请求HTML的时候，就提前把可能会用到的JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送(<strong>Server Push</strong>，也叫<strong>Cache Push</strong>)。</li></ul></li></ul><h6 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h6><p>HTTP/2主要的问题在于，<strong>多个HTTP请求在复用一个TCP连接</strong>，下层的TCP协议是不知道有多少个HTTP请求的。</p><p>所以<strong>一旦发生了丢包现象，就会触发TCP的重传机制</strong>，这样在一个TCP连接中的<strong>所有的HTTP请求都必须等待这个丢了的包被重传回来</strong>。</p><ul><li>HTTP/1.1中的管道（pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了。</li><li>HTTP/2多个请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的HTTP请求。</li></ul><p>这都是<strong>基于TCP传输层</strong>的问题，所以<strong>HTTP/3把HTTP下层的TCP协议改成了UDP</strong>!</p><p>UDP是<strong>不管顺序，也不管丢包的</strong>，所以<strong>不会出现HTTP/1.1的队头阻塞和HTTP/2的一个丢包全部重传问题</strong>。</p><p>大家都知道UDP是不可靠传输的，但<strong>基于UDP的QUIC协议可以实现类似TCP的可靠性传输</strong>。</p><ul><li>QUIC有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，<strong>其他流不会受到影响</strong>。</li><li>TLS3升级成了最新的<strong>1.3</strong>版本，头部压缩算法也升级成了<strong>QPack</strong> 。</li><li>HTTPS要建立一个连接，要花费6次交互，先是建立三次握手，然后是TLS/1.3的三次握手。QUIC直接把以往的TCP和 TLS/1.3的6次交互<strong>合并成了3次，减少了交互次数</strong>。</li></ul><p>所以，QUIC是一个在UDP之上的<strong>伪</strong>TCP+ TLS+ HTTP/2的多路复用的协议。</p><p>QUIC是新协议，对于很多网络设备，根本不知道什么是QUIC，只会当做UDP，这样会出现新的问题。所以HTTP/3现在普及的进度非常的缓慢，不知道未来UDP是否能够逆袭TCP。</p><p>QUIC 全称：Quick UDP Internet Connections，是一种基于 UDP 的传输层协议。由 Google 自研，2012 年部署上线，2013 年提交 IETF，2021 年 5 月，IETF 推出标准版 RFC9000。</p><p>从协议栈可以看出：QUIC = HTTP/2 + TLS + UDP</p><h4 id="跨域通信"><a href="#跨域通信" class="headerlink" title="跨域通信"></a>跨域通信</h4><h5 id="同源-跨域"><a href="#同源-跨域" class="headerlink" title="同源/跨域"></a>同源/跨域</h5><p><strong>同源策略</strong>：用于隔离潜在恶意文件的安全机制。</p><p>同源是指”<strong>协议</strong>+<strong>域名</strong>+<strong>端口</strong>“三者相同，<strong>即便两个不同的域名指向同一个ip地址，也非同源</strong>。</p><p><strong>同源策略限制内容有：</strong></p><ul><li><code>Cookie</code>、<code>LocalStorage</code>、<code>IndexedDB</code> 等存储性内容</li><li><code>DOM</code> 节点</li><li><code>AJAX</code> 请求</li></ul><p>但是有的标签是允许跨域加载资源：</p><ul><li><code>&lt;img src=XXX&gt;</code></li><li><code>&lt;link href=XXX&gt;</code></li><li><code>&lt;script src=XXX&gt;</code></li></ul><p>当协议、域名、端口号中任意一个不相同时，都算作不同域。</p><p><strong>不同域之间相互请求资源，就算作“跨域”</strong>。</p><p>跨域并<strong>不是请求发不出去</strong>，请求能发出去，服务端能收到请求并正常返回结果，只是结果<strong>被浏览器拦截</strong>了。</p><h5 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h5><h6 id="JSONP（JSON-with-Padding）"><a href="#JSONP（JSON-with-Padding）" class="headerlink" title="JSONP（JSON with Padding）"></a>JSONP（JSON with Padding）</h6><p>JS函数包裹JSON数据。</p><p>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。</p><p>JSONP请求一定需要对方的服务器做支持才可以。</p><p><code>&lt;script&gt;</code> 标签中type的默认属性是<code>text/javascript</code>,<strong>会把收到的文本内容当成JS代码进行执行</strong>。</p><p>优点：简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。</p><p>缺点：仅支持<code>get</code>方法；不安全，可能会遭受<code>XSS</code>攻击。</p><p><strong>JSONP的实现流程</strong></p><ul><li>声明一个回调函数，将函数名(如<code>handle</code>)当做参数值传递给跨域请求数据的服务器，函数形参为要获取的目标数据(服务器返回的<code>data</code>)。</li><li>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给<code>&lt;script&gt;</code>的<code>src</code>，还要在这个地址中向服务器传递该函数名（可以通过问号传参:<code>?callback=handle</code>）。</li><li>服务器接收到请求后，需要进行特殊的处理：把<strong>传递进来的函数名</strong>和它需要给你的<strong>数据</strong>拼接成一个<strong>字符串</strong>（模板字符串）。</li><li>最后服务器把该字符串返回给客户端，客户端接收到后相当于执行之前声明的回调函数（<code>handle</code>），对返回的数据进行操作。</li></ul><h6 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h6><p>CORS（Cross-Origin Resource Sharing），跨域资源共享。</p><p>CORS是官方的跨域解决方案，需要浏览器和后端同时支持。</p><p>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 CORS。</p><p>该属性表示哪些域名可以访问资源，如果设置通配符<code>*</code>则表示所有网站都可以访问资源。</p><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><p><strong>简单请求</strong></p><ul><li>请求方法是 <code>HEAD</code>、<code>GET</code>、<code>POST</code> 三种之一；</li><li>HTTP 头信息不超过右边着几个字段：<ul><li><code>Accept</code>、</li><li><code>Accept-Language</code>、</li><li><code>Content-Language</code>、</li><li><code>Last-Event-ID</code></li><li><code>Content-Type</code> 只限于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>；</li></ul></li></ul><p>需要这些条件是为了<strong>兼容表单</strong>，因为历史上表单一直可以跨域。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。</p><p>凡是不同时满足上面两个条件，就属于非简单请求。</p><p>浏览器直接发出<strong>CORS请求</strong>，具体来说就是在头信息中增加<code>Origin</code>字段，表示请求来源来自哪个域(协议+域名+端口)，服务器根据这个值决定是否同意请求。如果同意，返回的响应会多出以下响应头信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//juejin.com // 和 Orign 一致  这个字段是必须的</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span> <span class="comment">// 表示是否允许发送 Cookie  这个字段是可选的</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar <span class="comment">// 指定返回其他字段的值   这个字段是可选的</span></span><br></pre></td></tr></table></figure><p>在简单请求中服务器至少需要设置：<code>Access-Control-Allow-Origin</code> 字段。</p><p><strong>复杂请求</strong></p><ul><li><p>不符合以上条件的请求，比如请求方法是 <code>PUT</code> 或 <code>DELETE</code>，或 <code>Content-Type</code> 值为 <code>application/json</code>。</p></li><li><p>浏览器会在正式通信之前，发送一次 <strong>HTTP 预检</strong> <code>OPTIONS</code> 请求，先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 请求方法和头信息字段（服务器返回的响应头会包含允许的域名、方法等）。只有得到肯定答复，浏览器才会发出正式的 <code>XHR</code> 请求，否则报错。</p></li><li><p>预检请求的方法是<code>OPTIONS</code>，它的头信息中有几个字段</p><ul><li><code>Origin</code>: 表示请求来自哪个域，这个字段是必须的</li><li><code>Access-Control-Request-Method</code>：列出CORS请求会用到哪些HTTP方法，这个字段是必须的</li><li><code>Access-Control-Request-Headers</code>： 指定CORS请求会额外发送的头信息字段，用逗号隔开</li></ul></li><li><p>OPTIONS请求次数过多也会损耗性能，所以要尽量减少OPTIONS请求，可以让服务器在请求返回头部添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Max-Age: <span class="built_in">Number</span> <span class="comment">// 数字 单位是秒</span></span><br></pre></td></tr></table></figure><p>表示<strong>预检请求的返回结果可以被缓存多久</strong>，在这个时间范围内再请求就不需要预检了。不过这个缓存只对完全一样的URL才会生效。</p></li></ul><p><strong>关于CORS的 cookie 问题</strong></p><p>想要传递 <code>cookie</code> 需要满足 3 个条件</p><ul><li>web 请求设置<code>withCredentials</code></li></ul><p>这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 <code>withCredentials</code> 来进行传递 <code>cookie</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 xml 的设置方式</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// axios 设置方式</span></span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li><code>Access-Control-Allow-Credentials</code> 为 <code>true</code></li><li><code>Access-Control-Allow-Origin</code>为<strong>非</strong> <code>*</code></li></ul><h5 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h5><p>简单的说，一般给<strong>客户端</strong>做代理的都是正向代理，给<strong>服务器</strong>做代理的就是反向代理。</p><h6 id="Node中间件代理"><a href="#Node中间件代理" class="headerlink" title="Node中间件代理"></a>Node中间件代理</h6><p>同源策略是<strong>浏览器</strong>需要遵循的标准，而如果是<strong>服务器向服务器</strong>请求就无需遵循同源策略。</p><p>代理的思路为，<strong>利用服务端请求不会跨域的特性，让接口和当前站点同域</strong>。</p><h6 id="React中配置代理"><a href="#React中配置代理" class="headerlink" title="React中配置代理"></a>React中配置代理</h6><p>在<code>package.json</code>中追加如下配置 :<code>&quot;proxy&quot;:http://localhost:5000</code></p><p>setupProxy.js <code>http-proxy-middleware</code> 配置多个代理，可以灵活的控制请求是否走代理。</p><h6 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h6><p>配置一个代理服务器向服务器请求，再将数据返回给客户端，实质和CORS跨域原理一样，也需要配置请求响应头Access-Control-Allow-Origin等字段，只不过是在代理服务器配置。</p><h5 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h5><h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><p><code>WebSocket</code>是<code>HTML5</code>的一个持久化的协议，它实现了<strong>浏览器与服务器的全双工通信</strong>，同时也是跨域的一种解决方案。</p><p><code>WebSocket</code>和<code>HTTP</code>都是<strong>应用层协议</strong>，都基于 <code>TCP</code> 协议。</p><p>但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。</p><p>同时，<code>WebSocket</code> 在建立连接时需要借助 <code>HTTP</code> 协议，连接建立好了之后 <code>client</code> 与 <code>server</code> 之间的双向通信就与 <code>HTTP</code> 无关了。</p><h4 id="Cookie、sessionStorage、localStorage"><a href="#Cookie、sessionStorage、localStorage" class="headerlink" title="Cookie、sessionStorage、localStorage"></a>Cookie、sessionStorage、localStorage</h4><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是<strong>服务器发送到用户浏览器</strong>并<strong>保存在本地的一小块数据</strong>，它会在<strong>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</strong>。</p><p>通常，它用于告知服务端两个请求是否来自同一浏览器，如<strong>保持用户的登录状态</strong>。Cookie 使基于<strong>无状态</strong>的HTTP协议记录稳定的状态信息成为了可能。<strong>HTTP本质是无状态的，使用Cookies可以创建有状态的会话。</strong></p><h5 id="localStorage-amp-amp-sessionStorage"><a href="#localStorage-amp-amp-sessionStorage" class="headerlink" title="localStorage &amp;&amp; sessionStorage"></a>localStorage &amp;&amp; sessionStorage</h5><blockquote><p>Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在，而Web Storage仅仅是为了在本地“存储”数据而生。</p><p>即<code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p></blockquote><h5 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h5><p>IndexedDB 是一种底层 API，用于在客户端<strong>存储大量的结构化数据</strong>（也包括文件/二进制大型对象（blobs））。该 API 使用索引实现对数据的高性能搜索。虽然Web Storage在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><table><thead><tr><th align="center">特性</th><th align="center">cookie</th><th align="center">localStorage</th><th align="center">sessionStorage</th><th align="center">indexDB</th></tr></thead><tbody><tr><td align="center">数据生命周期</td><td align="center">一般由服务器生成，会话期 Cookie/持久性 Cookie可以设置过期时间</td><td align="center">除非被清理，否则一直存在</td><td align="center">页面关闭就清理</td><td align="center">除非被清理，否则一直存在</td></tr><tr><td align="center">数据存储大小</td><td align="center">4K(数量20+，取决于浏览器)</td><td align="center">5M</td><td align="center">5M</td><td align="center">无限</td></tr><tr><td align="center">与服务端通信</td><td align="center">每次都会携带在header中，对于请求性能影响</td><td align="center">不参与</td><td align="center">不参与</td><td align="center">不参与</td></tr></tbody></table><p>Cookie <strong>曾一度用于客户端数据的存储</strong>，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。</p><h4 id="Cookie、Session、Token、JWT"><a href="#Cookie、Session、Token、JWT" class="headerlink" title="Cookie、Session、Token、JWT"></a>Cookie、Session、Token、JWT</h4><p>Cookie是<strong>服务器发送到用户浏览器</strong>并<strong>保存在本地的一小块数据</strong>，它会在<strong>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</strong>。</p><p>通常，它用于告知服务端两个请求是否来自同一浏览器，如<strong>保持用户的登录状态</strong>。Cookie 使基于<strong>无状态</strong>的HTTP协议记录稳定的状态信息成为了可能。</p><p>Cookie 主要用于以下三个方面：</p><ul><li><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li><strong>个性化设置</strong>（如用户自定义设置、主题等）</li><li><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</li></ul><p><strong>Session 是另一种记录服务器和客户端会话状态的机制</strong>，<strong>使服务端有状态化，可以记录会话信息</strong>。</p><p><strong>Session</strong> 是基于<code>cookie</code> 实现的<strong>，session 存储在服务器端</strong>，<code>sessionId</code> 会被<strong>存储到客户端的cookie 中</strong>。</p><p>第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个<code>Session ID</code>，以后每次请求把这个<code>Session ID</code>发送到服务器，服务器就知道你是谁了。</p><p>Token 是<strong>令牌</strong>，<strong>访问资源接口（API）时所需要的资源凭证</strong>。Token <strong>使服务端无状态化，不会存储会话信息。</strong></p><p><strong>JWT</strong> （JSON Web Token）</p><p>结构：<code>头部（Header）</code>、<code>载荷（Payload）</code>、<code>签名（Signature）</code>，并以<code>.</code>进行拼接。</p><p>其中头部和载荷都是以<code>JSON</code>格式存放数据，只是进行了编码。</p><p>签名是对头部和载荷内容进行签名，加密后存储于客户端，服务端只需要使用密钥解密进行校验即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</p><h4 id="XSS和CSRF"><a href="#XSS和CSRF" class="headerlink" title="XSS和CSRF"></a>XSS和CSRF</h4><h5 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h5><p><code>Cross-Site Scripting</code>（跨站脚本攻击）简称 XSS，是一种<strong>代码注入攻击</strong>。</p><p>攻击者通过在<strong>目标网站</strong>上注入<strong>恶意脚本</strong>，使之在用户的<strong>浏览器</strong>上运行。</p><p>利用这些恶意脚本，攻击者可获取用户的敏感信息如<code>Cookie</code>、<code>SessionID</code> 等，进而危害数据安全。</p><p>简单来说,任何可以输入的地方都有可能引起,包括<strong>URL</strong>!</p><p>根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。</p><ul><li>XSS 的恶意代码存在数据库里，浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>用户点击<code>http://xxx/search?keyword=&quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code>，前端直接从url中将keyword后的参数取出来，并显示到页面上，但是没有做转义，就造成了XSS攻击。</li><li>常见于带有用户提交数据的网站功能，如填写基本信息、论坛发帖、商品评论等；在可输入内容的地方提交如<code>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>之类的代码。</li></ul><h6 id="常用防范方法"><a href="#常用防范方法" class="headerlink" title="常用防范方法"></a>常用防范方法</h6><ul><li><strong>httpOnly:</strong> 在 <code>cookie</code> 中设置 <code>HttpOnly</code> 属性后，js脚本将无法读取到 cookie 信息。</li><li><strong>输入过滤:</strong> 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。不仅仅是<strong>前端</strong>负责，<strong>后端</strong>也要做相同的过滤检查。因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。</li><li><strong>转义 HTML:</strong> 如果拼接 HTML 是必要的，就需要对于<strong>引号</strong>，<strong>尖括号</strong>，斜杠进行转义,但这还不是很完善。</li><li><strong>白名单:</strong> 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</li></ul><ul><li><strong>预防 DOM 型 XSS 攻击</strong><ul><li>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript代码本身不够严谨，把不可信的数据当作代码执行了。</li><li>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>（<strong>文本不会被解析为HTML</strong>）、<code>.setAttribute()</code> 等。</li><li>如果用 Vue/React 技术栈，尽量不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患。必须使用时尽量加上HTML净化工具（<a target="_blank" rel="noopener" href="https://github.com/cure53/DOMPurify">DOMPurify</a>）。</li><li>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能<strong>把字符串作为代码运行</strong>。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</li></ul></li></ul><h5 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h5><p>跨站请求伪造（Cross-site request forgery），通常缩写为 CSRF 或者 XSRF， 是一种<strong>挟制用户在当前已登录的 Web 应用程序上执行非本意的操作</strong>的攻击方法。</p><h6 id="CSRF与-XSS-区别"><a href="#CSRF与-XSS-区别" class="headerlink" title="CSRF与 XSS 区别"></a>CSRF与 XSS 区别</h6><ul><li><strong>通常来说 CSRF 是由 XSS 实现的。</strong></li><li>本质上讲，XSS 是代码注入问题，<strong>CSRF 是 HTTP 问题。</strong> XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。<strong>CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(Token验证可以避免)。</strong></li></ul><h6 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h6><ul><li><strong>验证码</strong>；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 CSRF，但是用户体验比较差。</li><li><strong>token 验证的 CSRF 防御机制是公认最合适的方案。</strong>若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。</li></ul><h4 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP UDP"></a>TCP UDP</h4><blockquote><p>考察公司：美团、腾讯、完美世界</p></blockquote><h5 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h5><ul><li>在传送数据之前<strong>不需要先建立连接</strong>，远地主机在收到 UDP 报文后，<strong>不需要给出任何确认</strong>。</li><li>一般用于<strong>即时通信</strong>，比如： QQ 语音、 QQ 视频 、直播等等</li><li>基于<strong>UDP的QUIC</strong>协议可以实现类似TCP的可靠性传输</li></ul><h5 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h5><ul><li>提供<strong>面向连接</strong>的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li>TCP 在传递数据之前，会有<strong>三次握手</strong>来建立连接，而且在数据传递时，有<strong>确认</strong>、<strong>窗口</strong>、<strong>重传</strong>、<strong>拥塞控制</strong>机制，在数据传完后，还会<strong>断开连接</strong>用来节约系统资源</li><li>由于 TCP 要提供可靠的，面向连接的传输服务，这难以避免增加了许多开销。</li><li>TCP 一般用于<strong>文件传输、发送和接收邮件、远程登录</strong>等场景。</li></ul><h5 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h5><ul><li><p><strong>基于数据块传输</strong> ：应用数据被<strong>分割</strong>成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</p></li><li><p><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个<strong>序列号</strong>，有了序列号能够将接收到的数据根据序列号排序，并且<strong>去掉重复序列号</strong>的数据就可以实现数据包去重。</p></li><li><p><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是<strong>检测数据在传输过程中的任何变化</strong>。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p></li><li><p><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在<strong>合理的往返时延（RTT）</strong>内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传。</p></li><li><p><strong>流量控制</strong> : TCP 连接的每一方都有<strong>固定大小的缓冲空间</strong>，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能<strong>提示发送方降低发送的速率</strong>，防止包丢失。TCP 使用的流量控制协议是<strong>可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）</strong>。</p></li><li><p><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</p></li></ul><h5 id="TCP-如何实现流量控制？"><a href="#TCP-如何实现流量控制？" class="headerlink" title="TCP 如何实现流量控制？"></a>TCP 如何实现流量控制？</h5><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong></p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><p><strong>为什么需要流量控制?</strong> 这是因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 <strong>接收缓冲区(Receiving Buffers)</strong> 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p><p>这里需要注意的是（常见误区）：</p><ul><li>发送端不等同于客户端</li><li>接收端不等同于服务端</li></ul><p>TCP 为<strong>全双工(Full-Duplex, FDX)通信</strong>，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是服务端。</p><p>因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。</p><p>接收窗口大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。</p><p>通信双方的发送窗口和接收窗口的要求相同。</p><p><strong>接收窗口的大小是根据接收端处理数据的速度动态调整的。</strong> 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。另外，这里的滑动窗口大小只是为了演示使用，实际窗口大小通常会远远大于这个值。</p><h5 id="TCP-的拥塞控制是怎么实现的？"><a href="#TCP-的拥塞控制是怎么实现的？" class="headerlink" title="TCP 的拥塞控制是怎么实现的？"></a>TCP 的拥塞控制是怎么实现的？</h5><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。</p><p>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。</p><p>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p><p><strong>拥塞控制</strong>是一个<strong>全局性</strong>的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。</p><p>相反，<strong>流量控制</strong>往往是<strong>点对点通信量的控制，是个端到端的问题</strong>。</p><p>流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。</p><p>拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。</p><p>发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。</p><p>在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><ul><li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li><li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.</li><li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li></ul><h5 id="ARQ-协议了解吗"><a href="#ARQ-协议了解吗" class="headerlink" title="ARQ 协议了解吗?"></a>ARQ 协议了解吗?</h5><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。</p><p>它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息（Acknoledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。</p><p>ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p><h4 id="浏览器允许的并发请求资源数"><a href="#浏览器允许的并发请求资源数" class="headerlink" title="浏览器允许的并发请求资源数"></a>浏览器允许的并发请求资源数</h4><p>首先，是基于端口数量和线程切换开销的考虑，浏览器不可能无限量的并发请求，因此衍生出来了并发限制和HTTP/1.1的Keep alive。</p><p>而随着技术的发展，负载均衡和各类NoSQL的大量应用，基本已经足以应对C10K的问题。</p><p>但却并不是每个网站都懂得利用domain hash也就是多域名来加速访问。</p><p>因此，新的浏览器加大了并发数的限制，但却仍<strong>控制在8以内</strong>。</p><p>浏览器即使放弃保护自己，将所有请求一起发给服务器，也很可能会引发服务器的并发阈值控制而被BAN，而另外一个控制在8以内的原因也是keep alive技术的存在使得浏览器复用现有连接和服务器通信比创建新连接的性能要更好一些。</p><p>所以，浏览器的并发数其实并不仅仅只是良知的要求，而是双方都需要保护自己的默契，并在可靠的情况下提供更好的性能。</p><ul><li><p>按照普通设计，当网站cookie信息有1 KB、网站首页共150个资源时，用户在请求过程中需要发送150 KB的cookie信息，在512 Kbps的常见上行带宽下，需要长达3秒左右才能全部发送完毕。 尽管这个过程可以和页面下载不同资源的时间并发，但毕竟对速度造成了影响。 而且这些信息在js/css/images/flash等静态资源上，几乎是没有任何必要的。 解决方案是<strong>启用和主站不同的域名来放置静态资源，也就是cookie free</strong>。跨域默认不带cookie</p></li><li><p>将css放置在页面最上方应该是很自然的习惯，但第一个css内引入的图片下载是有可能堵塞后续的其他js的下载的。而在目前普遍过百的整页请求数的前提下，浏览器提供的仅仅数个并发，对于进行了良好优化甚至是前面有CDN的系统而言，是极大的性能瓶颈。 这也就衍生了<strong>domain hash</strong>技术来使用多个域名加大并发量（因为浏览器是基于domain的并发控制，而不是page），不过过多的散布会导致DNS解析上付出额外的代价，所以一般也是控制在2-4之间。 这里常见的一个性能小坑是没有机制去确保URL的哈希一致性（即同一个静态资源应该被哈希到同一个域名下），而导致资源被多次下载。</p></li><li><p>再怎么提速，页面上过百的总资源数也仍然是很可观的，如果能将其中一些很多页面都用到的元素如常用元素如按钮、导航、Tab等的背景图，指示图标等等合并为一张大图，并利用css background的定位来使多个样式引用同一张图片，那也就可以大大的减少总请求数了，这就是<code>css sprites</code>雪碧图的由来。</p></li><li><p>全站的js/css原本并不多，其合并技术的产生却是有着和图片不同的考虑。 由于css/js通常可能对dom布局甚至是内容造成影响，在浏览器解析上，不连贯的载入是会造成多次重新渲染的。因此，在网站变大需要保持模块化来提高可维护性的前提下，<code>js/css combine</code>也就自然衍生了，同时也是<code>minify、compress</code>等对内容进行多余空格、空行、注释的整理和压缩的技术出现的原因。</p></li><li><p>随着cookie free和domain hash的引入，网站整体的打开速度将会大大的上一个台阶。 这时我们通常看到的问题是大量的请求由于全站公有header/footer/nav等关系，其对应文件早已在本地缓存里存在了，但为了确保这个内容没有发生修改，浏览器还是需要请求一次服务器，拿到一个304 Not Modified才能放心。 一些比较大型的网站在建立了比较规范的发布制度后，会将大部分静态资源的有效期设置为最长，也就是Cache-Control max-age为10年。 这样设置后，浏览器就再也不会在有缓存的前提下去确认文件是否有修改了。 超长的有效期可以让用户在访问曾访问过的网站或网页时，获得最佳的体验。 带来的复杂性则体现在每次对静态资源进行更新时，必须发布为不同的URL来确保用户重新加载变动的资源。</p></li><li><p>即使是这样做完，仍然还存在着一个很大的优化空间，那就是很多页面浏览量很大，但其实用户直接很大比例直接就跳走了，第一屏以下的内容用户根本就不感兴趣。 对于超大流量的网站如淘宝、新浪等，这个问题尤其重要。 这个时候一般是通过将图片的src标签设置为一个loading或空白的样式，在用户翻页将图片放入可见区或即将放入可见区时再去载入。 不过这个优化其实和并发资源数的关系就比较小了，只是对一些散布不合理，或第一页底部的资源会有一定的帮助。 主要意图还是降低带宽费用。</p></li></ul><p>总的来说，各类技术都是为了<strong>能让用户更快的看到页面进行下一步操作，但却不必将宝贵的资源浪费在没有必要的重复请求、不看的内容上</strong>。</p><p><strong>浏览器的并发请求数目限制是针对同一域名的</strong>。</p><p>意即，同一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。</p><h4 id="后端定期向前端推送数据"><a href="#后端定期向前端推送数据" class="headerlink" title="后端定期向前端推送数据"></a>后端定期向前端推送数据</h4><p>sse是后端向前端发信息的单向通道，客户端发送一个请求，服务端保持足够连接直到有新消息发送回客户端，仍然保持着连接，这样连接就可以消息再次发送，由服务器单向发送给客户端。</p><p><a target="_blank" rel="noopener" href="https://imgse.com/i/vxXAyV"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/09/15/vxXAyV.png" alt="vxXAyV.png"></a></p><h4 id="浏览器多个标签之间通信"><a href="#浏览器多个标签之间通信" class="headerlink" title="浏览器多个标签之间通信"></a>浏览器多个标签之间通信</h4><table><thead><tr><th align="left">实现方式</th><th align="left">优缺点</th></tr></thead><tbody><tr><td align="left">localStorage</td><td align="left"><strong>优点：</strong> 操作简单，易于理解。<strong>缺点：</strong> 存储大小限制只能监听非己页面跨域不共享 （<strong>总体来说较为推荐</strong>）</td></tr><tr><td align="left">websocket</td><td align="left"><strong>优点：</strong> 理论上可是实现任何数据共享跨域共享 <strong>缺点：</strong> 需要服务端配合增加服务器压力上手不易 （<strong>总体不推荐</strong>）</td></tr><tr><td align="left">sharedWorker</td><td align="left"><strong>优点：</strong> 理论上可以实现任何数据共享性能较好 <strong>缺点：</strong> 跨域不共享调试不方便兼容性不好 （<strong>总体推荐一般</strong>）</td></tr><tr><td align="left">cookie</td><td align="left"><strong>优点：</strong> 兼容性好易于上手和理解 <strong>缺点：</strong> 有存储大小限制轮询消耗性能发请求会携带cookie （<strong>总体不推荐</strong>）</td></tr></tbody></table><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>因为页面自身还是在 GitHub Pages 托管，有时候首个请求还是会挺久才返回。</p><h5 id="性能检测"><a href="#性能检测" class="headerlink" title="性能检测"></a>性能检测</h5><ul><li><p><code>Network</code>面板是一个常被用到的工具，通过它可以<strong>获取到网站所有资源的请求情况</strong>，包括<strong>加载时间</strong>，<strong>资源大小</strong>，优先级设置、<strong>瀑布图</strong>以及<code>HTTP</code>缓存等信息。可以帮助开发者发现可能由于未进行有效压缩而导致资源尺寸过大的问题，未配置缓存策略导致二次请求加载时间过长的问题。</p></li><li><p><code>Lighthouse</code>是谷歌开发并开源的<code>web</code>性能测试工具，用于改进网络应用的质量，可以将其作为一个<code>Chrome</code>扩展程序运行，或从命令行运行。在浏览器的调试工具中默认就存在<code>lighthouse</code>选项，只需要切换至<code>lighthouse</code>，在右侧的选项区选中需要的选项。点击生成报告。</p></li><li><p>使用<code>Performance</code>面板主要对网站应用的运行时性能表现进行检测和分析，包括页面的每秒帧数，<code>CPU</code>的消耗和各种请求花费的时间。</p></li></ul><h5 id="如何保证资源更快的加载速度？"><a href="#如何保证资源更快的加载速度？" class="headerlink" title="如何保证资源更快的加载速度？"></a>如何保证资源更快的加载速度？</h5><ul><li><p>使用 <code>dns-prefetch</code> 减少 DNS 的查询时间</p></li><li><p>使用 <code>preconnect</code> 提前建立连接</p></li><li><p>压缩资源体积</p><ul><li>HTTP 压缩 <code>gzip</code>，它是一种优秀的压缩算法，可对 <code>http</code> 请求中的一些文件资源进行压缩处理，一般来讲是要在服务端处理的，可通过在响应头中设置 <code>Content-encoding: gzip</code> 表示当前资源使用的压缩方式（如：<code>gzip、deflate、br</code> 等），便于客户端使用正确的方式解压。</li><li>Webpack 压缩 首先必须要明确的是压缩的过程本身就是会消耗时间的，如果所有资源都等到被访问的时候再由服务端进行压缩，在压缩完成之前客户端还是得处于等待状态，即仍 <strong>不能保证资源以最快的速度到达客户端</strong>。那么优化方案就是将压缩资源的时间放到打包构建中，毕竟只有真正需要发布线上生产环境时才需要执行一系列的打包优化的操作，而这相比于 <strong><code>http</code></strong> 的 <strong>请求/响应</strong> 速度，稍微延长产物打包时间没有什么大问题。</li></ul></li><li><p>减少 http 请求数量</p><p><strong>不同协议</strong> 下 <strong>请求数量</strong> 仍然可能成为 <strong>请求/响应</strong> 慢的原因：</p><ul><li>合并公共资源，如 雪碧图 等</li><li>内置模块资源，如 生成 <code>base64</code> 图片、通过 <code>symbol</code> 引用 <code>svg</code> 等</li><li>合并代码块，如构建工具分包策略配合公共组件封装、组件复用逻辑抽离 等</li><li>按需加载资源，如 路由懒加载、图片懒加载、上拉加载、分页加载 等</li></ul></li><li><p>减少不必要的 cookie 不必要的 <code>cookie</code> 来回传输会造成带宽浪费：</p><ul><li><p>减少 <code>cookie</code> 存储的内容</p></li><li><p>对于静态资源采用 <code>CDN</code> 托管（即非同域），不同域名默认不携带 <code>cookie</code></p></li></ul></li></ul><ul><li>CDN 托管静态资源 + HTTP 缓存</li></ul><p>性能优化的第一定律就是：优先考虑使用缓存。</p><p>缓存的主要手段有：浏览器缓存、CDN。</p><p><strong><code>CDN</code> 加速的本质是缓存加速</strong>，将服务器上存储的静资源容缓存在 <code>CDN</code> 节点上，当后续访问这些静态内容时，无需访问服务器源站，选择就近访问 <code>CDN</code> 节点即可，从而达到加速的效果，同时减轻服务器源站的压力。</p><p>主要用在博客的图片上面。但图片存在了Github仓库，所以性能还是有影响。</p><p>CDN是“去中心化的”。</p><p>静态资源是指在<strong>不同请求中访问到的数据都相同的静态文件</strong>。例如：<strong>图片、视频、网站中的文件（html、css、js）</strong>、软件安装包、apk文件、压缩包文件等。</p><p>动态资源是指在<strong>不同请求中访问到的数据不相同的动态内容</strong>。例如：网站中的文件（asp、jsp、php、perl、cgi）、<strong>API接口、数据库交互请求</strong>等。</p><ul><li>预加载</li></ul><p>使用<code>link</code>的<code>preload</code>属性预加载一个资源。webpack也可配置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>as属性可以指定预加载的类型，除了style还支持很多类型，常用的一般是<code>style</code>和<code>script</code>，<code>css</code>和<code>js</code>。</p><blockquote><p>【<strong>注意</strong>】<code>as</code> 属性一定要设置，除了设置优先级外，还涉及到浏览识别的问题：如果没有设置 <code>as</code> 属性，后续遇到该请求就会被作为一个 <code>XHR</code> 请求，把意味着资源预加载的功能可能会失效，因为可能会每次都发起新的请求获取</p></blockquote><p><code>preload</code> 是对资源的预加载，它虽提前加载但只在需要执行时执行，即这个资源一定是当前页面所需要的资源，如果是需要为下一个页面提前加载资源，那么应该使用 <code>prefetch</code>，它会在 <strong>浏览器空闲时</strong> 下载资源。。webpack也可配置。</p><h5 id="如何保证视图更快的渲染和交互？"><a href="#如何保证视图更快的渲染和交互？" class="headerlink" title="如何保证视图更快的渲染和交互？"></a>如何保证视图更快的渲染和交互？</h5><h6 id="渲染层面"><a href="#渲染层面" class="headerlink" title="渲染层面"></a>渲染层面</h6><ul><li><p>减少阻塞渲染的因素 真正渲染视图之前，必然要生成 <strong><code>DOM Tree</code></strong> 和 **<code>CSSOM</code>**，因此必须保证 <strong>HTML 解释器</strong> 和 <strong>CSS 解释器</strong> 都尽早处理完成，同时 <strong><code>JavaScript</code></strong> 的加载和执行可能会阻塞这个过程：</p><ul><li><p><code>HTML</code> 文档中首次渲染的节点数量要尽量少，避免深层次的嵌套结构，避免大量使用慢标签（如：<code>iframe</code>）等。</p></li><li><p><code>CSS</code> 资源放文档头部，降低 <code>CSS</code> 复杂度，比如 合理使用 <code>CSS</code> 选择器。</p></li><li><p><code>JavaScript</code> 资源放文档底部，合理使用 <code>defer、async</code> 的加载方式。</p></li></ul></li></ul><ul><li><p>懒加载 懒加载主要是针对数量大、资源加载慢的情况，比如图片资源、大量列表数据展示等：</p><ul><li><p><strong>图片资源</strong>：优先加载在可视区范围内的图片，可视区外的图片 **<code>延后加载</code>**，或者说当移入的可视区时再加载。</p></li><li><p><strong>列表数据</strong>：列表数据通常数据里量大，不可能一次渲染完所有数据，一般通过 <strong><code>分页加载、上拉加载</code></strong> 等方式分批次渲染。</p></li></ul></li></ul><ul><li><p>白屏优化 白屏是由于 <code>SPA</code> 应用需要等待 <code>JavaScript</code> 加载并执行完成后才会生成具体的页面结构内容导致的，即初始化模板中没有任何有意义需要被渲染的 <code>HTML</code> 结构：</p><ul><li><p>添加 **白屏 <code>loading</code>**，可在模板中添加默认的 <code>loading</code> 效果，等到真正页面内容被渲染就可以替换 <code>loading</code> 内容。</p></li><li><p>添加 <strong>骨架屏</strong>，和上述方案一致，在真正页面内容展示出来之前，先展示默认的视图内容，避免白屏。</p></li></ul></li></ul><ul><li><p>服务端渲染（server-side rendering）现代框架默认是属于客户端应用框架，即组件的代码会在浏览器中运行，然后向页面输出 <strong>DOM</strong> 元素，也叫 <strong>客户端渲染（client-side rendering，CSR）</strong>：</p><ul><li><p>优点</p><ul><li>**<code>用户体验更好</code>**，基于 <strong>前端路由</strong> 的方式并不会真正进行 <strong>页面跳转</strong>，即不会使页面重新刷新、加载，带来更高的流畅度。</li><li><strong><code>占用服务端资源少</code><strong>，</strong>CSR 渲染</strong> 是交由客户端进行处理，服务端不需要关心渲染计算的过程，减轻了服务端的压力。</li></ul></li><li><p>缺点</p><ul><li>**<code>&quot;白屏&quot; 时间较长</code>**，主要是因为 <strong>CSR</strong> 渲染需要 <code>*.js</code> 的支持，而 <code>*.js</code> 又必须保证 <code>*.html</code> 被接收和解析， <code>*.html</code> 又强依赖于当前的 <strong>网络环境</strong>，因此，在差网环境下回导致 <strong>白屏时间过长</strong>，特别是在移动网络环境下。</li><li>**<code>对 SEO 的支持不友好</code>**，因为 <strong>白屏时间较长</strong> 导致在一段时间内没有重要的内容能够交由 <strong>搜索引擎</strong> 进行分析、分类、打标签等，并且 <strong>搜索引擎</strong> 并不会等待页面渲染完成，因此对 <strong>SEO</strong> 优化并不友好。</li></ul></li></ul></li></ul><p><strong>服务端渲染（server-side rendering，SSR）</strong> 可将相同组件在服务渲染成相应的 <code>HTML</code> 字符串，并发送给浏览器进行渲染，即客户端不需要等待所有的 <strong>JavaScript</strong> 都被下载并执行之后才显示，所以用户可以更快看到完整的渲染好的内容。</p><ul><li><p>预渲染（prerender）上述 <strong>服务端渲染（server-side rendering，SSR）</strong> 虽然能够解决一些客户端存在的问题，但它也带来了别的问题：</p><ul><li><p>**<code>需要保证开发一致性</code>**，比如 <strong>服务端</strong> 和 <strong>客户端</strong> 能够执行的组件生命周期钩子不同，一些外部库在 <strong>服务端渲染</strong> 应用中可能需要经过特殊处理。</p></li><li><p>**<code>需要更多的构建设定和部署要求</code>**，一个完全静态的 <strong>SPA</strong> 可以部署在任意的静态文件服务器，但服务端渲染应用需要一个能够运行 <strong>Node.js</strong> 服务器的环境。</p></li><li><p>**<code>更多的服务端负载</code>**，在 <strong>Node.js</strong> 中渲染一个完整的应用，会比仅供应静态文件产生更密集的 <strong>CPU</strong> 运算，并且需要考虑访问流量过大的情况等。</p></li></ul></li></ul><p>因此，并不是所有应用都合适 <strong>服务端渲染</strong>，如果只是希望通过 <strong>SSR</strong> 来改善一些 <strong>推广页面</strong> (如 <code>/</code>、<code>/about</code>、<code>/contact</code> 等) 的 <strong>SEO</strong>，那么应该优先考虑 <strong>预渲染</strong> 的方式：</p><p><strong>预渲染</strong> 是在打包构建过程中（离屏状态），针对对应的 <code>routes</code> 路由预先生成对应的页面内容。</p><p><strong>预渲染</strong> 需要和 <strong>打包构建工具（webpack、rollup 等）</strong> 进行配合，如 **<code>webpack</code>**，就可通过 <strong><code>prerender-spa-plugin</code></strong> 来支持 <strong>预渲染</strong>。</p><h6 id="交互层面"><a href="#交互层面" class="headerlink" title="交互层面"></a>交互层面</h6><ul><li><p>减少回流/重绘</p><p><strong>重绘</strong>：页面中元素样式的改变并不影响它在文档流中的位置时（如：<code>color、background-color、visibility</code> 等），浏览器会将新样式赋予给元素并 <strong>重新绘制</strong>.</p><p><strong>回流</strong>：当 <code>Render Tree</code> 中部分或全部元素的 <strong>尺寸、结构、某些属性</strong> 发生改变时，浏览器 <strong>重新渲染</strong> 部分或全部文档。</p><ul><li><p>减少对 <code>DOM</code> 进行频繁操作。</p></li><li><p>使经常变动的元素脱离文档流，如具有持续性的动画效果，会一直触发回流和重绘。</p></li><li><p>避免访问或减少访问会导致浏览器强制刷新队列的属性，如：<code>offsetTop、offsetLeft、offsetWidth</code>等</p><ul><li>【<strong>扩展</strong>】浏览器的渲染队列机制会通过 <strong>队列</strong> 将会触发 <strong>回流或重绘</strong> 的操作进行存储，等到一定的时间或一定的数量时再执行这些操作。</li></ul></li><li><p>避免对 <code>css</code> 进行单个修改，如在 <code>JavaScript</code> 修改多个样式时，尽量使用 <code>css</code> 选择器实现样式的集中变更。</p></li><li><p>使用 <code>will-change</code> 开启 <code>GPU</code> 加速，<code>will-change</code> 指定的属性使得浏览器可在元素属性真正发生变化之前提前做好对应的优化。</p></li><li><p>预先设定图片尺寸，避免图片资源加载完成后引发回流。</p></li></ul></li></ul><ul><li>防抖/节流</li></ul><p><strong>防抖</strong>：多次频繁触发执行操作，以 <strong>最后一次</strong> 为准，忽略中间过程。</p><p><strong>节流</strong>：在指定的时间间隔内，<strong>只允许</strong> 执行一次对应的操作。</p><p>合理使用 <strong><code>防抖/节流</code></strong> 优化应用中的操作，比如 <strong><code>节流</code></strong> 可用于优化滚动事件、模糊搜索等，**<code>防抖</code>** 可用于优化一些按钮点击操作等。</p><ul><li>Web Worker</li></ul><p><code>JavaScript</code> 是单线程的，如果存在需要大量计算的场景（如视频解码），<code>UI</code> 线程就会被阻塞，甚至浏览器直接卡死。</p><p><code>Web Worker</code> 可以使脚本运行在新的线程中，它们独立于主线程，可以进行大量的计算活动，而不会影响主线程的 <code>UI</code> 渲染，但不能滥用 <code>Web Worker</code> 。</p><ul><li>虚拟列表</li></ul><p>最常用的还是 <strong>分页加载</strong> 的方式：</p><ul><li>基于 <code>table</code> 表格的渲染，只会渲染固定数量的 <code>DOM</code></li><li>基于 <code>上拉加载</code> 列表的渲染，随着加载数据的增多，对应的 <code>DOM</code> 节点也会增多，达到某个限制页面一定会发生卡顿</li></ul><p><strong>虚拟列表</strong> 核心就是固定渲染的 <strong><code>DOM</code></strong> 数，通过动态切换数据内容实现视图的更新，并保证文档中真实 <strong><code>DOM</code></strong> 的数量不随着数据量增大而增大（其实和 <code>table</code> 分页很像，但它支持滚动）。</p><ul><li>大文件分片上传</li></ul><p>大部分的项目总少不了文件上传功能，但对大文件的上传还是有必要进行优化，所谓的 <strong>断点续传</strong>、<strong>秒传</strong> 都要基于 <strong>分片上传</strong> 这个核心功能。</p><ul><li>Excel 导入/导出</li></ul><p>针对 <strong>Excel 导入/导出</strong> 的功能相信很多人第一印象是后端的活，但大多数情况下，后端接口的处理速度会受各种影响，导致速度方面不是很理想，有时候也是需要前端来进行优化处理的，比如导入时前端不发送文件只发送解析后的 <code>JSON</code> 数据，导出时不需要单独发送额外接口，直接使用当前展示数据实现导出等。</p><h5 id="React项目的优化-★"><a href="#React项目的优化-★" class="headerlink" title="React项目的优化 ★"></a>React项目的优化 ★</h5><h6 id="尽量避免重新render"><a href="#尽量避免重新render" class="headerlink" title="尽量避免重新render"></a>尽量避免重新render</h6><ul><li>使用PureComponent</li></ul><p>React.PureComponent中<strong>浅层对比</strong>了<code>props</code>和<code>state</code>来避免重新渲染，但是假如props和state的属性值是对象的情况下，并不能阻止不必要的渲染，因为只是比较了地址，所以在使用PureComponent的时候要确保数据类型是值的类型，如果是引用类型，最好不要有深层次的变化。</p><ul><li>使用ShouldComponentUpdate</li></ul><p>这个函数可以决定是否要重新渲染组件，也属于一个生命周期函数，如果props更改或者调用setState这个函数会返回一个布尔值，true表示会重新渲染，如果为false则不会重新渲染。</p><ul><li>使用React.memo</li></ul><p>如果组件在相同的props的情况下渲染结果相同时，可以通过将其包装在React.memo中，React将跳过渲染组件并直接复用最近一次渲染的结果。</p><p>React.memo对比的是<code>props</code>的变化，如果一个组件被这个钩子函数包裹，但是其内部有useState或者useReducer之类的，仍会进行重新渲染，这个也是进行的浅层比较，如果想要控制对比的过程，可以将自定义的函数通过第二个参数进行传递。</p><ul><li>使用useMemo缓存计算结果</li></ul><p>如果一个组件中有一个计算量比较大的函数，重新渲染每次都调用比较消耗性能，所以我们可以使用useMemo来缓存这个函数的计算结果，这样只有传入的参数发生变化才会重新进行计算。</p><ul><li>使用useCallback来缓存函数</li></ul><p>假如一个组件中有一个函数，只要状态发生变化，这个函数就会被重新定义，使用useCallback可以进行缓存。</p><ul><li>使用发布订阅模式来避免中间组件不必要的渲染</li></ul><p>如果组件的嵌套层级比较深，可能造成中间组件不必要的渲染，可能中间组件只是传递了props，这种情况我们可以通过发布订阅模式，让只关心某个状态的组件去更新，可以借助一些类似的第三方库：redux。</p><ul><li>尽量将状态放到子组件中（状态下方）</li></ul><p>如果一个状态只是某部分子组件在使用，可以将其提取为一个组件，然后状态定义到这个组件中，避免中间组件不必要的渲染。</p><ul><li>列表的每个item加上key属性</li></ul><p>通过添加key属性可以更好的辅助Diff算法进行虚拟DOM计算，避免不必要的渲染。</p><h6 id="尽量减少要渲染的节点"><a href="#尽量减少要渲染的节点" class="headerlink" title="尽量减少要渲染的节点"></a>尽量减少要渲染的节点</h6><ul><li>组件懒加载</li></ul><p>组件懒加载实现的效果是让真正需要真是这个组件的时候才渲染，主要是通过<code>React.lazy</code>和<code>React.Suspense</code>这两个组件来进行组件懒加载。</p><p>主要是使用<code>React.lazy</code>来定义一个动态加载的组件，<code>React.Suspense</code>主要是用来包裹要懒加载的组件的。</p><ul><li>使用虚拟列表</li></ul><p>虚拟列表可以根据滚动容器的元素的高度来渲染长列表的数据，尤其是在一些没有直接分页的场景，主要是使用第三方库：r<code>eact-window</code>、<code>react-virtualized</code>。</p><h6 id="避免添加额外的DOM"><a href="#避免添加额外的DOM" class="headerlink" title="避免添加额外的DOM"></a>避免添加额外的DOM</h6><p>使用React.fragment来避免不必要的div</p><p>因为React规定一个组件只能有一个父元素，我们可以通过<code>React.Fragment</code>或<code>&lt;&gt;&lt;/&gt;</code>来代替不必要的div。</p><h4 id="HTTP-浏览器缓存"><a href="#HTTP-浏览器缓存" class="headerlink" title="HTTP/浏览器缓存"></a>HTTP/浏览器缓存</h4><p>浏览器缓存(Brower Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力。</p><h5 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h5><ul><li><code>200 form memory cache</code> :不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。<strong>浏览器关闭后，数据将不存在（资源被释放掉了）</strong>，再次打开相同的页面时，不会出现from memory cache。</li><li><code>200 from disk cache</code>：不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，<strong>关闭浏览器后，数据依然存在</strong>，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。</li><li>优先访问<code>memory cache</code>,其次是<code>disk cache</code>，最后是<strong>请求网络资源</strong></li></ul><p>http缓存机制主要在<strong>http响应头</strong>中设定，响应头中相关字段为<code>Expires</code>、<code>Cache-Control</code>、<code>Last-Modified</code>、<code>Etag</code>。</p><h5 id="强缓存、协商缓存"><a href="#强缓存、协商缓存" class="headerlink" title="强缓存、协商缓存"></a>强缓存、协商缓存</h5><p>在第一次请求时，没有缓存，直接向服务器发送请求，服务器可能会将一些关于缓存的字段放入响应头。</p><p>第二次浏览器请求某一资源时：</p><ul><li>强缓存 <code>Cache-Control</code>（max-age,优先级高）、<code>Expires</code>(GMT）=&gt; 判断<strong>是否过期</strong><ul><li>没过期则直接从缓存中获取资源信息，<strong>不会与服务器进行通信</strong>。</li><li>如果两者同时存在，以 <code>Cache-Control</code> 为准。</li><li><code>Cache-Control:max-age=3600</code>，代表着资源的有效期是3600秒。除了该字段外，还有下面几个比较常用的设置值：<ul><li><code>no-cache</code>：<strong>不使用本地缓存</strong>。需要使用<strong>协商缓存</strong>。</li><li><code>no-store</code>：直接<strong>禁止游览器缓存数据</strong>，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</li><li><code>public</code>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</li><li><code>private</code>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</li><li><code>max-age</code> 为 0 可以近似理解为与 <code>no-cache</code> 等效。</li></ul></li></ul></li></ul><ul><li><p>协商缓存 <strong>由服务器来确定缓存资源是否可用</strong></p><ul><li><p><code>Last-Modified + If-Modified-Since http1.0</code></p><ul><li><p>Last-Modified：浏览器向服务器发送资源最后的修改时间。</p></li><li><p>If-Modified-Since：</p><p>当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有<code>Last-Modified</code>声明，则再次向服务器请求时带上头<code>If-Modified-Since</code>，表示请求时间。服务器收到请求后发现有<code>If-Modified-Since</code>则与被请求资源的最后修改时间进行对比（<code>Last-Modified</code>）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，<code>HTTP 200 OK</code>;若最后修改时间较旧（小），说明资源无新修改，响应<code>HTTP 304</code> 走缓存。</p></li></ul></li><li><p><code>Etag+ If-None-Match HTTP 1.1</code></p><ul><li><p>Etag是属于HTTP 1.1属性，它是由服务器（Apache或者其他工具）生成返回给前端，用来帮助服务器控制Web端的缓存验证。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</p></li><li><p>If-None-Match：当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头If-None-Match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304。</p></li><li><p>如果同时设了 <code>ETag</code> 和 <code>Last-Modified</code>，那么必须<strong>同时满足条件才会 304</strong>，不存在谁更优先就使用谁一说。</p><p>但一般分布式环境下（比如 CDN）很少使用 <code>ETag</code>，因为 <code>ETag</code> 依赖 Web Server 的哈希算法，不同 Web Server、不同版本、不同的配置，都会导致同样的文件 <code>ETag</code> 可能是不相等的。当然了，如果你能限制上述信息都一样，也可以使用 <code>ETag</code>，并不绝对。</p></li></ul></li></ul></li></ul><h5 id="缓存发展"><a href="#缓存发展" class="headerlink" title="缓存发展"></a>缓存发展</h5><p>强缓存有缺点，比如说，设置了<code>expires</code>，<code>GMT</code>格式，但是可能客户端与服务器时间不一致，或者网络延迟导致时间不准确，因此就通过<code>cache-control</code>返回一个<strong>相对时间</strong>来。</p><p>但是假如说<strong>资源并没有更新</strong>，但是强缓存时间过期了，那就需要重新拉去资源，因此就有了<code>Last-Modified</code>。</p><p>但是<code>last-modified</code>的时间单位是<code>s</code>，当1s内有资源修改，那浏览器返回的最后修改时间和上次的修改时间相同，那就不会重新拉取资源，还有可能**内容并不改变(仅仅改变的修改时间)**。</p><p>因此推出了<code>Etag</code>，通过<strong>比对资源内容</strong>来判断是否修改。</p><h5 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h5><ul><li><p><strong>浏览器地址栏中写入URL，回车 / 普通刷新F5</strong></p><p>不同浏览器和不同类型资源缓存方式不同，个人理解：</p><ul><li>返回200，并显示从缓存中获取，则为强缓存（虽然没有发出真实的 http 请求）。</li><li>返回304，说明是协商缓存命中走<strong>缓存</strong>。</li></ul></li><li><p><strong>强制刷新Ctrl+F5</strong> 删除缓存，重新请求。</p></li></ul><h4 id="浏览器解析渲染"><a href="#浏览器解析渲染" class="headerlink" title="浏览器解析渲染"></a>浏览器解析渲染</h4><p>请求回来的文档数据先保存在网络进程。在提交文档阶段，浏览器进程将网络进程接收到的HTML数据提交给渲染进程。</p><ul><li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</li><li>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；</li><li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li></ul><p>浏览器解析渲染页面分为以下步骤：</p><ul><li>根据 HTML 解析出 DOM 树<ul><li><strong>图片/CSS不会影响解析</strong></li><li><code>&lt;script&gt;</code><strong>阻塞渲染并停止HTML的解析</strong>（因为它可能操作dom）</li><li><strong>预加载</strong>在后台检索资源，可以减少阻塞</li><li>display:none被隐藏的节点也会在dom树上</li></ul></li><li>根据 CSS 解析生成 CSS 规则树（<strong>CSSOM</strong>）</li><li>结合 DOM 树和 CSS 规则树，生成渲染树<ul><li><code>&lt;head&gt;</code>和它的<strong>子节点</strong>以及任何具有<code>display: none</code>样式的结点，不会出现在Render树上</li><li><code>visibility: hidden</code>的节点会出现在Render树上</li><li><code>display: none</code> 会引起页面的<strong>回流</strong>(重排)以及<strong>重绘</strong>，而<code>visibility: hidden</code>只会引起<strong>重绘</strong></li></ul></li><li>根据渲染树计算每一个节点的信息</li><li>根据计算好的信息绘制页面<ul><li>第一次确定节点的大小和位置称为布局。</li><li>随后对节点大小和位置的重新计算称为<strong>回流</strong>，不改变大小位置的样式改变为<strong>重绘</strong>。</li><li>对布局树进行分层，并生成分层树，为每个图层生成绘制列表，并将其提交到合成线程。</li><li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li><li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程，浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</li><li>可以将内容提升到GPU上的层（而不是CPU上的主线程）可以提高绘制和重新绘制性能。<ul><li>有一些特定的属性和元素可以<strong>实例化一个层</strong>，包括<code>&lt;video&gt;</code>和<code>&lt;canvas&gt;</code>，任何CSS属性为<code>opacity</code>、3D <code>transform</code>等</li><li>分层确实可以提高重绘速度，但是它以<strong>内存管理</strong>为代价。</li></ul></li></ul></li></ul><h4 id="script标签属性"><a href="#script标签属性" class="headerlink" title="script标签属性"></a>script标签属性</h4><h5 id="async"><a href="#async" class="headerlink" title="async"></a>async</h5><p>async标记告诉浏览器在等待js下载期间可以去干其他事，当js下载完成后会<strong>立即(尽快)执行</strong>，<strong>多条js可以并行下载</strong>。</p><p>async的好处是让多条js不会互相等待，<strong>下载期间浏览器会去干其他事(继续解析HTML等)<strong>，</strong>异步下载，异步执行</strong>。</p><h5 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h5><p>与async一样，defer标记告诉浏览器在等待js下载期间可以去干其他事，<strong>多条js可以并行下载</strong>，不过当js下载完成之后<strong>不会立即执行</strong>，而是会等待解析完整个HTML之后在开始执行，而且多条defer标记的js会<strong>按照顺序执行</strong>。</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>如果两个script之间<strong>没有依赖关系</strong>并且<strong>无需等待页面解析</strong>的更加适合使用<code>async</code>，反之如果两个script之间<strong>有依赖关系</strong>，或者希望<strong>优先解析HTML</strong>，则<code>defer</code>更加适合。</p><p>defer脚本会在文档渲染完毕后，<code>DOMContentLoaded</code>事件调用前执行。</p><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><p>HTML用于控制网页的结构，CSS用于控制网页的外观，JavaScript控制的是网页的行为。</p><h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><h5 id="其他语言对比"><a href="#其他语言对比" class="headerlink" title="其他语言对比"></a>其他语言对比</h5><p><strong>解释代码 vs 编译代码</strong></p><ul><li><p>在<strong>解释型</strong>语言中，代码<strong>自上而下</strong>运行，且<strong>实时返回运行结果</strong>。代码将直接以<strong>文本格式（text form）</strong>被接收和处理。解释型语言代表有：JS、MATLAB、Python和Java。</p></li><li><p>相对的，<strong>编译型</strong>语言需要先将代码<strong>转化（编译）</strong>成另一种形式才能运行。比如 C/C++ 先被<strong>编译成汇编语言</strong>，然后才能由计算机运行。程序将以<strong>二进制</strong>的格式运行，这些二进制内容是由程序源代码产生的。</p></li><li><p>编译性语言不如解释性语言跨平台性好，也就是说不同平台的兼容性有区别，所以才有了两种语言。用c语言开发了程序后，需要通过编译器把程序编译成机器语言（即计算机识别的二进制文件，因为不同的操作系统计算机识别的二进制文件是不同的），所以c语言程序进行移植后，要重新编译。（如windows编译成ext文件，linux编译成erp文件）。java程序首先通过编译器编译成class文件，如果在windows平台上运行，则通过windows平台上的java虚拟机（VM）进行解释。如果运行在linux平台上，则通过linux平台上的java虚拟机进行解释执行。所以说能跨平台，前提是平台上必须要有相匹配的java虚拟机。如果没有java虚拟机，则不能进行跨平台。</p></li><li><p><strong>JavaScript 是轻量级解释型语言</strong>。</p><ul><li>浏览器接受到JavaScript代码，并以代码自身的文本格式运行它。</li><li>技术上，几乎所有 JavaScript 转换器都运用了一种叫做<strong>即时编译（just-in-time compiling）</strong>的技术；</li><li>当 JavaScript 源代码被执行时，它会被编译成<strong>二进制</strong>的格式，使代码<strong>运行速度更快</strong>。</li><li>尽管如此，JavaScript 仍然是一门解释型语言，因为<strong>编译过程发生在代码运行中，而非之前</strong>。</li></ul></li><li><p><strong>编译型与解释型的共同点</strong></p><p>他们都要弄成二进制代码才能执行，两类编程语言的源代码都是英文，但是我们的计算机并不认识英文，所以都要转化成二进制才能执行。区别就在于“转化的方式”不一样。</p></li><li><p><strong>编译型与解释型的不同点</strong></p><ul><li><p>从运行效果上来看。编译型语言要等全部写完后通过编译器去生成一个类似<code>*.exe</code>的二进制文件，然后双击这个文件才可以看到效果。而解释型语言并没生成<code>*.exe</code>文件，而是直接生成效果。</p></li><li><p>运行的时候是否需要编译器的伴随。编译型语言运行的是最终生成的二进制代码，所以不需要编译器伴随。而解释型语言则一边解释一边运行，所以运行的时候很可能还有部分代码没有解释好，所以需要编译器伴随（解释型语言把该工具叫做解释器）。</p><p>举个例子，网页的解释器就在浏览器中，所以要看HTML的效果必须用浏览器或者有编译工具在内的其他工具打开，比如：模拟浏览器的工具。</p></li><li><p>执行的速度对比。编译型语言运行的已经是完全的二进制内容，运行起来十分干净利落，所以速度很快。而解释型语言运行的不一定是完全的二进制内容，因为它是一边解释成二进制一边运行。</p></li><li><p>可移植性对比。编译型语言是运行二进制内容，所以一旦CPU指令系统改变，那么之前的二进制文件可能运行不了。比如，如果到其他硬件平台上运行，就可能出现错误，就需要根据该平台重新编译出新的二进制文件。所以可移植性、平台兼容性比价差。而解释型语言则没有弄成什么二进制内容，而是在需要的时候才开始编译、运行。所以它自然具有可移植性，即在任何平台都可以马上运行起来。</p><p>要注意的是它的解释工具如：浏览器，本身就是编译型语言解释出来的二进制代码，所以浏览器本身不具备可移植性，是需要针对不同的平台弄出对应的浏览器最终二进制文件的，这里可别混淆。</p></li><li><p>升级上对比。编译型语言弄出来的二进制文件若要升级，自然要重新下载一个新的二进制文件。所以重新下载、安装、覆盖是最大的特点。而解释型的语言只要重新写好源代码即可，用户想要最新的效果，只要刷新一下即可，所以体验性好。比如：某网站平台升级了，用户只要重新刷新一下。</p></li><li><p>应用领域，编译型语言应用领域通常是那些安装软件，例如桌面上的安装软件。解释型的语言的应用领域通常是互联网、网站等那种刷新了一下就可以看到最新效果的领域。</p></li></ul></li></ul><p><strong>服务器端代码 vs 客户端代码</strong></p><ul><li><p>客户端代码是在用户的电脑上运行的代码，在浏览一个网页时，它的客户端代码就会被下载，然后由浏览器来运行并展示。</p></li><li><p>而服务器端代码在服务器上运行，运行结果由浏览器下载并展示出来。</p><ul><li>流行的服务器端 web 语言包括：PHP、Python、Ruby、ASP.NET 以及…… JavaScript！</li><li><strong>JavaScript 也可用作服务器端语言</strong>，比如现在流行的 Node.js 环境。</li></ul></li></ul><p><strong>强类型 Vs. 弱类型</strong></p><ul><li>强和弱是一个相对的概念，强是指倾向于将<strong>未定义的行为</strong>视作错误（Java、Python），弱是指倾向于进行<strong>隐式的转换</strong>、忽略类型相关的错误（JavaScript）。<strong>如果语言经常隐式地转换变量的类型</strong>，那这个语言就是弱类型语言，如果很少会这样做，那就是强类型语言。</li><li>很多设计得不够严谨的语言，虽然大多数情况下（或者我们通常鼓励大家这么做）是强类型的，但也有弱类型的部分（PHP）</li><li>还有的语言因为提供的抽象能力很弱，我们不得不去用弱类型的部分（C）</li><li>鸭子类型（duck typing）是强弱类型的一个折中（常见于动态类型中，例如 Python），兼顾了灵活性和严谨性。</li><li>我们认为弱类型是为了方便，而强类型是为了尽早发现错误。</li></ul><p><strong>动态类型 Vs. 静态类型</strong></p><ul><li>静态类型的变量的类型是在编译时确定的（C++、Java）；动态类型的类型是在运行时确定的（JavaScript、Python），例如你可以在一个 if 的两个分支里给一个变量赋值不同的类型。</li><li>有的动态类型语言也会添加编译期的类型检查（TypeScript、Python），但因为语言本身的动态性，这些检查仅能覆盖一部分情况。</li><li>在动态类型的语言中因为类型不那么重要，所以很多时候甚至没有提供指定类型的语法（隐含了运行时的自动推导）；而在静态类型语言里通常需要为变量指定类型，所以才有了编译期自动类型推导来提供便利，而动态类型语言则做不到这一点（因为不能在编译期确定类型，更无从推导）。</li><li>我们认为静态类型有助于在编译时发现有关类型的错误，确定的类型也给了编译期更多的优化空间；而动态类型给了开发者更高的灵活度。</li></ul><p><strong>虚拟机 VS. 本地代码</strong></p><ul><li>虚拟机是指在语言和 CPU 之间还有一个用于进行翻译的层次（JavaScript、Java）；无虚拟机是指编译器直接生成本地代码给 CPU 执行（C/C++、Golang）。</li><li>虚拟机也提供了更为复杂的运行时的动态特性，但这些特性有的时候也可以在没有虚拟机的情况下实现（例如 C++ 的运行时类型识别、Go 的 GC）。</li><li>虚拟机可以以解释的方式执行（Python，将代码视作一种数据指令来执行），也可以即时编译（JIT）的方式来执行（V8，先将代码编译到本地代码然后执行），有时也会混合这两种方式（为了更快的启动速度）。</li><li>我们认为无虚拟机的语言可以在更低的层次和其他程序交互，同时也天然地有着更好的性能；而有虚拟机的语言则可以轻松地跨平台，针对特定的架构在运行时即时编译出更高性能的代码。</li></ul><h5 id="基于类-vs-基于原型的语言"><a href="#基于类-vs-基于原型的语言" class="headerlink" title="基于类 vs 基于原型的语言"></a>基于类 vs 基于原型的语言</h5><p><strong>基于类的面向对象语言</strong>，比如 Java 和 C++，是构建在两个不同实体之上的：类和实例。</p><ul><li>一个<strong>类(class)<strong>定义了</strong>某一对象集合所具有的特征性属性</strong>（可以将 Java 中的方法和域以及 C++ 中的成员都视作属性）。<strong>类是抽象的，而不是其所描述的对象集合中的任何特定的个体。</strong></li><li>另一方面，<strong>一个实例(instance)是一个类的实例化</strong>。<strong>实例具有和其父类完全一致的属性</strong>。</li></ul><p><strong>基于原型的语言（如 JavaScript）</strong>并不存在这种区别：它<strong>只有对象</strong>。</p><p>基于原型的语言具有所谓**原型对象(prototypical object)**的概念。</p><p><strong>原型对象可以作为一个模板，新对象可以从中获得原始的属性。</strong></p><p>任何对象都可以指定其自身的属性，既可以是创建时也可以在运行时创建。</p><p><strong>任何对象都可以作为另一个对象的原型(prototype)，从而允许后者共享前者的属性</strong>。</p><table><thead><tr><th align="left">基于类的（Java）</th><th align="left">基于原型的（JavaScript）</th></tr></thead><tbody><tr><td align="left">类和实例是不同的事物。</td><td align="left">所有对象均为实例。</td></tr><tr><td align="left">通过类定义来定义类；通过构造器方法来实例化类。</td><td align="left">通过构造器函数来定义和创建一组对象。</td></tr><tr><td align="left">通过 <code>new</code> 操作符创建单个对象。</td><td align="left">相同。</td></tr><tr><td align="left">通过类定义来定义现存类的子类，从而构建对象的层级结构。</td><td align="left">指定一个对象作为原型并且与构造函数一起构建对象的层级结构</td></tr><tr><td align="left">遵循类链继承属性。</td><td align="left">遵循原型链继承属性。</td></tr><tr><td align="left">类定义指定类的所有实例的<strong>所有</strong>属性。无法在运行时动态添加属性。</td><td align="left">构造器函数或原型指定实例的<strong>初始</strong>属性集。允许动态地向单个的对象或者整个对象集中添加或移除属性。</td></tr></tbody></table><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>面向对象是把构成问题事务分解成各个对象，<strong>建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</strong></p><p>万事万物皆对象。面向对象的思想主要是以对象为主，将一个问题抽象出具体的对象，并且将抽象出来的对象和对象的属性和方法封装成一个类。</p><ul><li><strong>面向过程</strong>的特点在于<strong>逻辑性强</strong>，符合思维方式和解决问题的流程。</li><li><strong>面向对象</strong>的特点就是<strong>可扩展性更强</strong>一些，解决了<strong>代码重用性</strong>的问题。</li></ul><p>js中对象，对象下的方法和属性，都是储存在<strong>内存</strong>中的，调用的时候，是可以随时拿到这些属性和方法的。</p><p>在编程中使用OOP就是为了<strong>提高代码的复用性</strong>，而提高代码复用性的根本原因是为了<strong>降低内存的使用率</strong>。</p><p>面向对象程序设计的<strong>目的</strong>是在编程中促进更好的<strong>灵活性和可维护性</strong>，在大型软件工程中广为流行。即代码各部分相对独立，耦合性低，且功能明确，遇到bug或者更改需求，都可以直接针对特定的对象进行修改，便于维护。另外，面向对象凭借其对<strong>模块化</strong>的重视，面向对象的代码开发更简单，更容易理解，相比非模块化编程方法 , 它能更直接地分析, 编码和理解复杂的情况和过程。</p><p><strong>面向对象有三大特性，封装、继承和多态</strong></p><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p><strong>封装主要实现的功能就是将数据隐藏，只暴露出有限的接口。</strong></p><p>在js中万物皆对象，字符串、数值、数组、函数都属于Object。因此js基本的创建对象的方法有两种：</p><ul><li><p><strong>对象字面量法</strong></p></li><li><p><strong>new对象</strong></p></li></ul><p><strong>但这两种方法都会产生大量重复代码，基于面向对象思想，我们使用新的方式创建对象。</strong></p><h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>工厂模式如同它的名字一般，将对象从原料加工、制作、最后出厂，可实现大批量的功能相似产品对象！</p><p><strong>工厂模式的优缺点</strong>：虽然解决了创建相似对象的问题，但是却没有解决对象识别问题（即怎样知道一个对象的类型）。</p><h5 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h5><p>构造函数其实就是普通的函数，只不过有以下的特点：</p><ul><li><strong>首字母大写</strong>（建议构造函数首字母大写，即使用大驼峰命名，非构造函数首字母小写）</li><li>内部使用this</li><li>使用 new生成实例</li></ul><p><strong>构造函数模式的优缺点</strong>：</p><ul><li>优点：创建自定义函数意味着将来可以将它的实例标识为一种特定的类型，这是构造函数胜过工厂模式的地方.</li><li>缺点：每个方法都要在每个实例上重新创建一遍.</li></ul><h5 id="原型-类-模式"><a href="#原型-类-模式" class="headerlink" title="原型(类)模式"></a>原型(类)模式</h5><p><strong>原型模式的优缺点：</strong></p><ul><li>优点：可以让所有的对象实例共享它所包含的属性和方法</li><li>缺点：原型中是所有属性都是<strong>共享</strong>的，但是实例一般都是要有自己的单独属性的。所以一般很少单独使用原型模式。</li></ul><h5 id="混合模式（常用作封装类）"><a href="#混合模式（常用作封装类）" class="headerlink" title="混合模式（常用作封装类）"></a>混合模式（常用作封装类）</h5><p>通过构造函数模式定义实例（私有）属性，而原型模式用于定义方法和共享的属性。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>引入继承性的好处</p><ul><li>减少了代码的冗余，提高了代码的复用性</li><li>便于功能的扩展</li><li>为之后多态性的使用，提供了前提</li></ul><h5 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h5><p>通过将<strong>子类的原型对象指向父类的实例</strong>，实现继承访问父类属性方法等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line">SubType.prototype.constructor = SubType; <span class="comment">// 修复constructor使符合原型链规定</span></span><br></pre></td></tr></table></figure><p>原型链方案存在的缺点：</p><ul><li>由于所有SubType实例原型都指向同一个SuperType实例, 因此<strong>对某个SubType实例的来自父类的引用类型变量修改会影响所有的SubType实例</strong>。</li><li>在创建子类实例时无法向父类构造传参, 即没有实现super()的功能。</li></ul><h5 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h5><p>构造函数继承，即在<strong>子类的构造函数中执行父类的构造函数，并为其绑定子类的this</strong>，让父类的构造函数把成员属性和方法都挂到子类的this上去，这样既<strong>能避免实例之间共享一个原型实例，又能向父类构造方法传参</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承自SuperType</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用<code>SuperType</code>构造函数，于是<code>SubType</code>的每个实例都会将<code>SuperType</code>中的属性复制一份。</p><p>缺点：</p><ul><li>只能继承父类的<strong>实例</strong>属性和方法，不能继承<strong>原型</strong>属性/方法</li><li>无法实现复用，每个子类实际上是调用父类来生成的实例</li></ul><h5 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h5><p>组合上述两种方法就是组合继承。用原型链实现对<strong>原型</strong>属性和方法的继承，用借用构造函数技术来实现<strong>实例</strong>属性的继承。</p><p>缺点：</p><ul><li>第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性<code>name</code>，<code>color</code>。</li><li>第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性<code>name</code>，<code>color</code>。</li></ul><p>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象<code>SubType.prototype</code>的两个同名属性。所以，组合模式的缺点就是在<strong>使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</strong></p><h5 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h5><p><strong>解决构造函数被执行两次</strong>的问题, 我们将<strong>指向父类实例改为指向父类原型</strong>, 减去一次构造函数的执行。</p><p>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code> 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code> 和<code>isPrototypeOf()</code></p><p><strong>这是最成熟的方法，也是现在库实现的方法</strong>。</p><h5 id="ES6类继承extends"><a href="#ES6类继承extends" class="headerlink" title="ES6类继承extends"></a>ES6类继承extends</h5><p><code>extends</code>关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中<code>constructor</code>表示构造函数，一个类中只能有一个构造函数，有多个会报出<code>SyntaxError</code>错误,如果没有显式指定构造方法，则会添加默认的 <code>constructor</code>方法，使用例子如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(length, length);   </span><br><span class="line">    <span class="comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Square&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p><strong>多态</strong>（Polymorphism）按字面的意思就是“多种状态”,在面向对象语言中，接口的多种不同的实现方式即为多态。</p><p><strong>可以解释为：</strong>同样的操作作用于不同对象上面，可以产生不同的解释和不同的运行结果。换句话说，给不同对象发送统一消息的时候，这些对象会根据这个信息分别给出不同的反馈。</p><p>JavaScript的多态的思想实际上就是把“做什么”和“谁去做”分离开来，要实现这一点，归根结底就是解耦。</p><p><strong>区分方法的重写和重载？</strong></p><ul><li><p>二者的概念：</p><ul><li><p>方法的重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.</p></li><li><p>方法的重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p></li></ul></li><li><p>重载：不表现为多态性。 重写：表现为多态性。</p></li></ul><h4 id="Js中的堆栈"><a href="#Js中的堆栈" class="headerlink" title="Js中的堆栈"></a>Js中的堆栈</h4><p>堆<code>heap</code>是<strong>动态分配</strong>的内存，<strong>大小不定</strong>也<strong>不会自动释放</strong>，栈<code>stack</code>为<strong>自动分配</strong>的内存空间，在代码执行过程中<strong>自动释放</strong>。</p><h5 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h5><p>在栈内存中提供一个供<code>Js</code>代码执行的环境，关于<strong>作用域</strong>以及<strong>函数的调用</strong>都是栈内存中执行的。</p><p><code>Js</code>中基本数据类型<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Null</code>、<code>Undefined</code>、<code>Symbol</code>、<code>BigInt</code>，</p><ul><li><strong>占用空间小且大小固定</strong>，<strong>值直接保存在栈内存中，是按值访问</strong>，</li><li>对于<code>Object</code>引用类型，其<strong>指针放置于栈内存中</strong>，<strong>指向堆内存的实际地址</strong>，是通过<strong>引用</strong>访问。</li></ul><p>关于调用栈，每调用一个函数，解释器就会把该函数添加进调用栈并开始执行；</p><p>正在调用栈中执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行；</p><p>当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码；</p><p>当分配的调用栈空间被占满时，会引发<strong>堆栈溢出</strong>错误。</p><h5 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h5><p>引用类型<code>Object</code>的变量<strong>占据空间大且大小不固定</strong>，堆内存中存储<strong>实际对象</strong>，在栈内存中存储对象的指针。</p><p>对于对象的访问是按引用访问的，在堆区的内存不会随着程序的运行而自动释放，这就需要实现<strong>垃圾回收机制</strong><code>GC</code>。</p><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><p>内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存。</p><p>并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存。</p><p>对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><h5 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h5><p>需要注意的是在<code>Js</code>中没有类似于<code>C</code>中的<code>free()</code>函数去手动释放内存，对于堆区内存回收全部需要通过<code>Js</code>的垃圾回收机制去实现。<br>在<strong>栈</strong>区中执行的变量等是通过值访问，当其<strong>作用域销毁后变量也就随之销毁</strong>，</p><p>而使用引用访问的堆区变量，在一个作用域消失后还可能在外层作用域或者其他作用域仍然<strong>存在引用</strong>，不能直接销毁，</p><p>此时就需要通过算法计算该堆区变量是否属于不再需要的变量，从而决定是否需要进行内存回收，</p><p>在<code>Js</code>中主要有<strong>引用计数</strong>与<strong>标记清除</strong>两种垃圾回收算法。</p><h5 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h5><p>对于引用计数垃圾回收算法，把对象是否不再需要简化定义为<strong>该对象有没有其他变量或对象引用到它</strong>，如果没有引用指向该对象，该对象将被垃圾回收机制回收。</p><p>在这里，对象的概念不仅特指<code>JavaScript</code>对象，还包括函数作用域或者全局词法作用域。</p><p>引用计数垃圾回收算法使用比较少，主要是在<code>IE6</code>与<code>IE7</code>等低版本<code>IE</code>浏览器中使用。</p><p>但是对于引用计数垃圾回收算法有个限制，当对象<strong>循环引用</strong>时，就会造成<strong>内存泄漏</strong>，也就是引用计数垃圾回收算法无法处理循环引用的对象。</p><h5 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h5><p>对于标记清除垃圾回收算法，把对象是否不再需要简化定义为<strong>该对象是否可以获得</strong>。</p><p>该算法设置一个叫做根<code>root</code>的对象，在<code>Javascript</code>里根是全局对象，垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象，以此不断向下查找。</p><p><strong>从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象</strong>，这样便解决了循环引用的问题。</p><p>所有现代浏览器都使用了标记清除垃圾回收算法，所有对<code>JavaScript</code>垃圾回收算法的改进都是基于标记清除算法的改进。</p><ul><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都<strong>加上标记</strong>。</li><li>然后，它会<strong>去掉</strong>运行环境中的变量以及被环境中变量所引用的变量的标记。</li><li>此后，<strong>依然有标记</strong>的变量就被视为准备删除的变量，原因是<strong>在运行环境中已经无法访问到这些变量了</strong>。</li><li>最后，垃圾收集器完成内存清除工作，<strong>销毁那些带标记的值并回收它们所占用的内存空间</strong>。</li></ul><h5 id="常见内存泄露情况及解决方法"><a href="#常见内存泄露情况及解决方法" class="headerlink" title="常见内存泄露情况及解决方法"></a>常见内存泄露情况及解决方法</h5><h6 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    bar = <span class="string">&quot;this is a hidden global variable&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种意外的全局变量可能由 <code>this</code> 创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.variable = <span class="string">&quot;potential accidental global&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 调用自己，this 指向了全局对象（window）</span></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上述使用<strong>严格模式</strong>，可以避免意外的全局变量。</p><h6 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h6><p>定时器也常会造成内存泄露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = getData();</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;Node&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        <span class="comment">// 处理 node 和 someResource</span></span><br><span class="line">        node.innerHTML = <span class="built_in">JSON</span>.stringify(someResource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>如果<code>id</code>为Node的元素从<code>DOM</code>中移除，该定时器仍会存在，同时，因为回调函数中包含对<code>someResource</code>的引用，定时器外面的<code>someResource</code>也不会被释放。</p><h6 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h6><p>包括我们之前所说的闭包，维持函数内局部变量，使其得不到释放。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">document</span>.createElement(<span class="string">&#x27;XXX&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj, <span class="string">&#x27;闭包内引用obj obj不会被释放&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  obj = <span class="literal">null</span>; <span class="comment">// 解决方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="dom"><a href="#dom" class="headerlink" title="dom"></a>dom</h6><p>没有清理对<code>DOM</code>元素的引用同样造成内存泄露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refA = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;refA&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.removeChild(refA); <span class="comment">// dom删除了</span></span><br><span class="line"><span class="built_in">console</span>.log(refA, <span class="string">&#x27;refA&#x27;</span>); <span class="comment">// 但是还存在引用能console出整个div 没有被回收</span></span><br><span class="line">refA = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(refA, <span class="string">&#x27;refA&#x27;</span>); <span class="comment">// 解除引用</span></span><br></pre></td></tr></table></figure><h6 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h6><p>包括使用事件监听<code>addEventListener</code>监听的时候，在不监听的情况下使用<code>removeEventListener</code>取消对事件监听。</p><h6 id="解决内存泄漏的数据结构"><a href="#解决内存泄漏的数据结构" class="headerlink" title="解决内存泄漏的数据结构"></a>解决内存泄漏的数据结构</h6><p>WeakSet WeakMap</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><blockquote><p>JavaScript 是一种<strong>弱类型</strong>、<strong>动态</strong>语言。</p><p><strong>不用提前声明变量的类型</strong>，在程序<strong>运行</strong>过程中，<strong>类型会被自动确定</strong>。</p><p>可以使用<strong>同一个变量保存不同类型的数据</strong>。</p></blockquote><h5 id="7-1"><a href="#7-1" class="headerlink" title="7+1"></a>7+1</h5><ul><li>原始类型(值不可变，栈)：<code>Undefined</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>BigInt</code>、<code>Symbol</code>、<code>Null</code></li><li>引用数据类型（堆，地址：栈）：<code>Object</code>（几乎所有通过 <code>new</code> 创建的东西：Array、Set、Date）</li></ul><h4 id="作用域与闭包★"><a href="#作用域与闭包★" class="headerlink" title="作用域与闭包★"></a>作用域与闭包★</h4><p><strong>作用域</strong>是当前的执行上下文，值和表达式在其中“可见”或可被访问。如果一个变量或表达式不在当前的作用域中，那么它是不可用的。作用域也可以堆叠成层次结构，子作用域可以访问父作用域，反过来则不行。</p><p>JavaScript 的作用域分以下三种：</p><ul><li>全局作用局：脚本模式运行所有代码的默认作用域</li><li>模块作用域：模块模式中运行代码的作用域</li><li>函数作用域：由函数创建的作用域</li></ul><p>此外，用 <code>let</code> 或 <code>const</code> 声明的变量属于额外的作用域：</p><ul><li>块级作用域：用一对花括号（一个代码块）创建出来的作用域</li></ul><p>由于函数会创建作用域，因而在函数中定义的变量无法从该函数外部访问，也无法从其他函数内部访问。</p><p><strong>一个函数</strong>和其<strong>词法环境</strong>的<strong>引用</strong>捆绑在一起，这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）。</p><p><strong>每当创建一个函数，闭包就会在函数创建的同时被创建出来。</strong>闭包让你可以在一个<strong>内层函数</strong>中<strong>访问到其外层函数的作用域</strong>。</p><p>内部函数对外部函数中定义的<strong>所有变量和函数</strong>有完全访问权，以及<strong>外部函数可以访问的所有其他变量和函数</strong>，这样就形成了<strong>作用域链</strong>。</p><p><strong>当内部函数以某种方式于外部函数之外的任何作用域执行时</strong>，就会看到一个<strong>可观察的闭包</strong>，此时<strong>外部函数中定义的变量和函数的存活时间就可以长于外部函数的执行时间</strong>。</p><p>本质就是<strong>上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放</strong>。导致上级作用域内的变量，<strong>等到下级作用域执行完以后才正常得到释放</strong>。</p><p><strong>总结</strong>：（对内保护，对外引用）</p><ul><li><p>闭包是函数执行形成私有作用域，对内，对于私有作用域内的私有变量，起到保护作用，外界无法直接对其进行访问和操作；</p></li><li><p>对外，私有作用域可以通过作用域链查找，对外部作用域进行访问查找。</p></li><li><p>如果形成对外部作用域引用，则会阻止引擎的垃圾回收器释放当前被引用的内存空间。</p></li><li><p>因此，可能会导致内存泄漏，需要特别关注。</p></li></ul><p><strong>优点</strong></p><ul><li>可以<strong>从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用</strong>。</li><li><strong>避免使用全局变量</strong>。</li><li>把变量存到独立的作用域，作为<strong>私有成员</strong>存在。</li></ul><p><strong>缺点</strong></p><ul><li>对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以<strong>使用不当会导致内存泄漏</strong>。</li><li>对处理速度具有负面影响。<strong>闭包的层级决定了引用的外部变量在查找时经过的作用域链长度</strong>。</li></ul><p><strong>应用</strong></p><ul><li><p><strong>用闭包模拟私有方法</strong> 模块模式：将共享环境创建于一个立即执行的匿名函数体内。这个环境中包含私有项无法在这个匿名函数外部直接访问，必须通过匿名函数返回的公共函数通过闭包机制访问。</p></li><li><p><strong>在循环中创建闭包</strong>：在<code>for</code>循环并未具备局部作用域，因此内层函数中的循环变量i都是外层函数的一个局部变量，循环结束后该变量是一个唯一值，可以使用<strong>立即执行匿名函数</strong>再创建一个闭包，将循环变量保存；或者使用<strong>let</strong>形成块作用域来保存每次的循环变量。</p></li><li><p><strong>高阶函数与柯里化</strong></p><p>简单来说，高阶函数是一个接收函数作为参数或将函数作为输出返回的函数。</p><p>柯里化是指一个函数，它接收函数 A，并且能返回一个新的函数，这个新的函数能够处理函数 A 的剩余参数。函数传入的参数相当于在函数内声明一个变量并赋值，所以这里也是利用了闭包机制。</p></li><li><p><strong>节流与防抖</strong></p></li></ul><h4 id="防抖-节流-★"><a href="#防抖-节流-★" class="headerlink" title="防抖/节流 ★"></a>防抖/节流 ★</h4><p>作用都是为了<strong>防止函数被高频调用。</strong></p><p>当函数会进行<code>DOM</code>操作或者具有<strong>请求服务器</strong>等行为并且作为高频事件，就需要进行<strong>事件处理函数执行频率的控制</strong>，否则会造成大量的<strong>资源浪费</strong>致使<strong>性能下降</strong>，当然无论是防抖与节流实质上并没有减少事件触发次数，而是通过<strong>减少事件处理函数的执行次数</strong>从而提高性能。</p><p><strong>应用场景</strong></p><ul><li><p>防抖</p><ul><li><p>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。</p></li><li><p>window触发<code>resize</code>的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次。</p><p><code>resize</code> CSS 属性允许你控制一个元素的可调整大小性。</p></li></ul></li><li><p>节流</p><ul><li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li><li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li></ul></li></ul><h5 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h5><h6 id="非立即防抖"><a href="#非立即防抖" class="headerlink" title="非立即防抖"></a>非立即防抖</h6><p>当持续触发事件的时候，事件处理函数是完全不执行的，等<strong>最后一次触发结束的一段时间之后，再去执行</strong>。</p><p>最常见的例子就是<strong>搜索</strong>建议功能，当用户进行持续输入时，并不会请求服务器进行搜索建议的计算，直至用户输入完成后的<code>N</code>毫秒后才会将数据传输至后端并返回搜索建议。<br>实现思路：<strong>每次触发事件时都取消之前的延时调用方法并重设定时器</strong>。</p><h6 id="立即防抖"><a href="#立即防抖" class="headerlink" title="立即防抖"></a>立即防抖</h6><p>当持续触发事件的时候，事件处理函数会<strong>立即执行</strong>，然后不再执行事件处理函数，直至<strong>最后一次事件触发之后的一段时间后才允许再次执行事件处理函数</strong>。<br>实现思路：<strong>判断是否存在定时器，没有则执行事件处理函数，然后无论是否已经存在定时器都需要重设定时器</strong>。</p><h5 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h5><p>当事件持续触发时，节流操作可以稀释事件处理函数执行频率，假设在<code>1s</code>内<code>onmousemove</code>事件触发了<code>100</code>次，通过节流就可以使得<code>onmousemove</code>事件的事件处理函数每<code>100ms</code>触发一次，也就是在<code>1s</code>内<code>onmousemove</code>事件的事件处理函数只执行<code>10</code>次。</p><h6 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h6><p>实现思路：通过<strong>时间戳</strong>记录上次事件处理函数执行时间，事件触发时若时间差大于执行周期则执行事件处理函数并赋值执行时间为当前时间戳。</p><h6 id="定时器-1"><a href="#定时器-1" class="headerlink" title="定时器"></a>定时器</h6><p>实现思路：判断是否存在定时器，没有则执行事件处理函数并重设定时器。</p><h5 id="柯里化-★"><a href="#柯里化-★" class="headerlink" title="柯里化 ★"></a>柯里化 ★</h5><p>柯里化是什么：是指这样一个函数，它接收函数 A，并且能返回一个新的函数，这个新的函数能够处理函数 A 的剩余参数</p><h4 id="let、const和var★"><a href="#let、const和var★" class="headerlink" title="let、const和var★"></a>let、const和var★</h4><h5 id="var"><a href="#var" class="headerlink" title="var"></a>var</h5><ul><li><p>存在<strong>变量提升</strong>，即变量可以在声明之前调用，值为<code>undefined</code>。</p></li><li><p>可以<strong>重复声明</strong>，第一次用来声明，后面只是重新赋值。</p></li><li><p>在<strong>函数</strong>中使用var声明变量的时候，该变量是<strong>局部</strong>的；对于声明在任何函数外（<strong>特别注意if和for中</strong>）的变量来说是<strong>全局</strong>的。</p></li></ul><h5 id="let"><a href="#let" class="headerlink" title="let"></a>let</h5><ul><li><p>let声明变量前，该变量不能使用（<strong>暂时性死区</strong>）。</p></li><li><p>在<strong>块级作用域</strong>内有效。</p></li><li><p>let不允许在<strong>相同作用域</strong>中重复声明，注意是相同作用域，不同作用域有重复声明不会报错。</p></li></ul><h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><ul><li><p><strong>暂时性死区</strong>。</p></li><li><p><strong>存在块级作用域</strong>。</p></li><li><p><strong>同一作用域不允许重复声明变量</strong>。</p></li><li><p>const声明创建对值的<strong>只读引用</strong>。这并不意味着它持有的值是不可变的，只是变量标识符不能被重新分配。例如，在内容是<strong>对象</strong>的情况下，这意味着可以更改对象的内容（例如，其属性）</p></li></ul><blockquote><p>全局中用<strong>let</strong>和<strong>const</strong>声明的变量存在<strong>Script</strong>上，用<strong>var</strong>声明的存在<strong>Global</strong>上（浏览器一般用<strong>Window</strong>表示）</p></blockquote><h4 id="this指向★"><a href="#this指向★" class="headerlink" title="this指向★"></a>this指向★</h4><p>目的就是指向<strong>函数</strong>运行时（箭头函数除外）所在的环境。</p><p>总结了<code>this</code>的绑定规则总共是有下面5种：请记住一点：<strong>谁调用这个函数或方法,this关键字就指向谁。</strong></p><ul><li>默认绑定（严格/非严格模式）<ul><li>无论是否在严格模式下，在全局执行环境中（在任何函数体外部）<code>this</code> 都指向全局对象。</li><li>非严格模式，函数中 <code>this</code> 的值默认指向全局对象，浏览器中就是<code>window</code>。</li><li>严格模式（use strict）下，<code>this</code> 会保持为 <code>undefined</code>。</li><li>全局中用<strong>let</strong>和<strong>const</strong>声明的变量存在<strong>Script</strong>上，用<strong>var</strong>声明的存在<strong>Global</strong>上（浏览器一般用<strong>Window</strong>表示）</li></ul></li><li>隐式绑定<ul><li>当<strong>函数作为对象的属性</strong>存在，通过<strong>对象属性执行函数</strong>时，此时隐式绑定规则会将<code>this</code>绑定到对象上。</li><li>赋值或函数传参（隐式赋值），会丢失该this绑定。</li></ul></li><li>显式绑定<ul><li><strong>通过 <code>call</code> <code>apply</code> <code>bind</code>绑定</strong></li><li>如果<code>call、apply、bind</code>接收到的第一个参数是空或者<code>null、undefined</code>的话，则会忽略这个参数</li><li>在Javascript中，多次 <code>bind()</code> 是无效的。</li><li><code>forEach、map、filter</code>函数的第二个参数也是能显式绑定<code>this</code>的</li></ul></li><li>new绑定<ul><li>当一个函数用作<strong>构造函数</strong>时（使用<code>new</code>关键字），它的<code>this</code>被绑定到<strong>正在构造的新对象</strong>。</li><li>当构造函数<strong>返回值为对象</strong>时，直接返回这个对象；否则返回<strong>new创建的对象</strong>。</li><li><code>this</code> 在类中的表现与在函数中类似，在类的构造函数中，<code>this</code> 是一个常规对象。类中所有非静态的方法都会被添加到 <code>this</code> 的原型。静态方法不是 this 的属性，它们只是类自身的属性。</li><li>派生类的构造函数没有初始的 <code>this</code> 绑定。在构造函数中调用 <code>super()</code>会生成一个 <code>this</code> 绑定，并相当于获得基类的this。</li></ul></li><li>ES6箭头函数绑定<ul><li>通过<strong>作用域链</strong>查到<strong>外层作用域的 this</strong> ，且指向<strong>函数定义时的 this</strong> 而非执行时</li><li>作用域只有全局作用域<code>window</code>和局部作用域函数</li><li>字面量创建的对象，作用域是<code>window</code>，如果里面有箭头函数属性的话，<code>this</code>指向的是<code>window</code></li><li>构造函数创建的对象，作用域是可以理解为是这个构造函数，且这个构造函数的<code>this</code>是指向新建的对象的，因此<code>this</code>指向这个对象。</li><li>箭头函数的<code>this</code>是无法通过<code>bind、call、apply</code>来<strong>直接</strong>修改，但是可以通过改变作用域中<code>this</code>的指向来间接修改。</li></ul></li></ul><p>判断this指向顺序：<code>箭头函数、new、call/apply/bind、隐式绑定、默认绑定</code></p><h4 id="call、apply、bind"><a href="#call、apply、bind" class="headerlink" title="call、apply、bind"></a>call、apply、bind</h4><ul><li>三者都可以改变函数的<code>this</code>对象指向</li><li>三者第一个参数都是<code>this</code>要指向的对象，如果如果没有这个参数或参数为<code>undefined</code>或<code>null</code>，则默认指向全局<code>window</code></li><li>三者都可以传参，但是<code>apply</code>是数组，而<code>call</code>是参数列表，且<code>apply</code>和<code>call</code>是一次性传入参数，而<code>bind</code>可以分为多次传入</li><li><code>bind</code>是返回绑定this之后的函数，<code>apply</code>、<code>call</code> 则是立即执行</li></ul><h4 id="事件循环★"><a href="#事件循环★" class="headerlink" title="事件循环★"></a>事件循环★</h4><p>JavaScript执行机制</p><p><strong>JavaScript是一种同步的、阻塞的、单线程的语言</strong>，在这种语言中，一次只能执行一个操作。</p><p>但web浏览器定义了函数和API，允许我们当某些事件发生时不是按照同步方式，而是<strong>异步地调用函数</strong>(比如，时间的推移，用户通过鼠标的交互，或者获取网络数据)。这意味着您的代码可以同时做几件事情，而不需要停止或阻塞主线程。</p><p>通过 <code>Web workers</code>可以把一些任务交给一个名为<code>worker</code>的单独的线程，这样就可以同时运行多个JavaScript代码块。</p><p>web workers有用但也有局限。如<strong>不能访问 DOM— 不能让一个worker直接更新UI</strong>。</p><p><strong>如何保证主线程, 有序并高效或非阻塞的处理呢? =&gt; 事件循环机制 Event Loop</strong></p><p>异步回调</p><p>异步callbacks 其实就是<strong>函数</strong>，只不过是作为<strong>参数</strong>传递给那些在后台执行的其他函数。</p><p>如：异步callback 就是<code>addEventListener()</code>第二个参数。</p><p>当我们把<strong>回调函数作为一个参数传递给另一个函数时，仅仅是把回调函数定义作为参数传递过去</strong> — <strong>回调函数并没有立刻执行，回调函数会在包含它的函数的某个地方异步执行，包含函数负责在合适的时候执行回调函数</strong>。</p><p>不是所有的回调函数都是异步的 — <strong>有一些是同步的</strong>。一个例子就是使用 <code>Array.prototype.forEach()</code>来遍历数组。</p><p>Event Loop</p><blockquote><p>事件循环负责收集事件（包括用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。</p><p>循环执行等待中的宏任务和微任务，并开始下一次循环之前执行一些必要的渲染和绘制操作。</p></blockquote><p>任务的执行模式</p><ul><li><p>同步：连续性、阻塞</p></li><li><p>异步</p><ul><li><p>宏任务（Macrotask，Task，宿主（浏览器、Node）发起）：<code>script</code>（整体代码块）、事件触发的回调、<code>setTimeout</code>、<code>setInterval</code>、<code>requestAnimationFrame</code>（在浏览器环境是，而node环境不是）、</p><p><code>setImmediate</code>（node环境下是，而浏览器环境下不是）、<code>I/O</code></p><p>、 <code>UI-rendering</code></p></li><li><p>微任务（Microtask，Jobs， JS 自身发起）：<code>Promise.[ then/catch/finally ]</code>、<code>queueMicrotask</code></p></li></ul></li></ul><p>一个完整的 <strong>Event Loop</strong> 过程，可以概括为以下阶段：</p><ul><li><p>一开始<strong>执行栈空,<strong>我们可以把</strong>执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</strong>。<strong>微任务队列空</strong>，<strong>宏任务队列</strong>里有且只有一个 <strong>script 脚本（整体代码）</strong>。</p></li><li><p><strong>全局上下文（script 标签）被推入执行栈</strong>，<strong>同步代码执行</strong>。</p><ul><li>在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生<strong>新的宏任务与微任务</strong>，它们会分别被<strong>推入各自的任务队列</strong>里。</li><li>同步代码执行完了，script脚本会被<strong>移出宏任务队列</strong>。</li><li>这个过程本质上是<strong>队列的宏任务的执行和出队</strong>的过程。</li></ul></li><li><p>上一步我们出队的是一个<strong>宏任务</strong>，这一步我们处理的是微任务。</p><ul><li>当<strong>宏任务出队</strong>时，任务是<strong>一个一个</strong>执行的；</li><li>而<strong>微任务出队</strong>时，任务是<strong>一队一队</strong>执行的。</li><li>因此，我们处理微任务队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</li></ul></li><li><p><strong>执行渲染操作，更新界面</strong></p></li><li><p>检查是否存在<code>Web worker</code>任务，如果有，则对其进行处理</p></li><li><p>上述过程循环往复，直到两个队列都清空。</p></li></ul><p><strong>如何理解 script（整体代码块）是个宏任务呢</strong></p><p>同时存在两个script代码块，会首先在执行<strong>第一个 script 代码块中的同步代码</strong>，如果这个过程中创建了微任务并进入了微任务队列，第一个 script 同步代码执行完之后，会首先去<strong>清空微任务队列</strong>，再去开启<strong>第二个 script 代码块</strong>的执行。</p><p>首次执行<strong>宏队列中会有 script（整体代码块）任务</strong>，所以实际上就是 Js 解析完成后，在异步任务中，会<strong>先执行完所有的微任务</strong>。需要注意的是，<strong>新创建的微任务会立即进入微任务队列排队执行，不需要等待下一次轮回</strong>。</p><p>所谓任务，浅显来说就是<strong>代码块开始执行的入口</strong>(确切地说，是函数栈的入口)。</p><p>而在 <code>JS</code> 里，除了“<code>script</code>整体代码块”之外，<strong>所有代码块的入口都是“回调函数”</strong>，回调函数被注册到事件后不会马上被执行，而是保存在一个神秘的的地方，保存起来待执行的才能算“任务”，然后才有宏/微任务之分。</p><p>“<code>script</code>整体代码块”的特殊之处，在于<strong>它的入口不是回调函数</strong>，但是我们可以想象它被装在一个隐形的函数里，作为回调函数被注册到某个事件里（大概是它解析完成之后会触发的一个事件），这时候这个隐形的函数就成为了一个任务。</p><p>浏览器<code>UI</code>是多线程的，异步任务借助浏览器的线程和<code>JavaScript</code>的执行机制实现。</p><p><strong>queueMicrotask</strong></p><p><strong>可以安全的引入微任务而避免使用额外的技巧</strong>。由晦涩地使用 promise 去创建微任务而带来的风险就可以被避免了。举例来说，当使用 promise 创建微任务时，由回调抛出的异常被报告为 rejected promises 而不是标准异常。同时，创建和销毁 promise 带来了事件和内存方面的额外开销，这是正确入列微任务的函数应该避免的。</p><h3 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML/CSS"></a>HTML/CSS</h3><h4 id="语义化★"><a href="#语义化★" class="headerlink" title="语义化★"></a>语义化★</h4><p>语义化，指<strong>选择合乎语义的标签</strong></p><ul><li>使<strong>文本内容的结构化</strong>，</li><li>便于<strong>开发者阅读</strong>、<strong>维护和写出更优雅的代码，</strong></li><li>同时让浏览器的<strong>爬虫和辅助技术</strong>更好的解析。</li></ul><p><strong>常用的一些语义化标签</strong></p><ul><li><code>&lt;h1&gt;~&lt;h6&gt;</code> ，标题</li><li><code>&lt;p&gt;</code> 段落</li><li><code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>，无序、有序列表</li><li><code>&lt;table&gt;</code>、<code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;td&gt;</code>、<code>&lt;th&gt;</code>、<code>&lt;caption&gt;</code>， 表格</li></ul><p><strong>HTML5新增</strong></p><ul><li><code>header</code>：头部,包裹目录部分、搜索框、一个nav或者任何相关的logo</li><li><code>main</code>：主体,唯一的，其后代元素常常包括<code>&lt;article&gt;</code></li><li><code>nav</code>：导航,一般和<code>ul</code>、<code>li</code>配合做导航栏</li><li><code>footer</code>：底部,通常包含作者、版权信息或者相关链接等</li><li><code>aside</code>：侧边栏,作为主要内容的附属信息，如索引，词条列表</li><li><code>article</code>：独立文章,通常带有标题，当article内嵌article时，里外层的内容应该是相关的</li><li><code>section</code>：独立区块,它是整体的一部分，或者是文章的一节，一般来说section也会带有标题</li><li><code>div</code>：作为一个没有任何语义，仅仅是用来构建结构的元素，是<strong>最适合做容器的标签。</strong></li></ul><p><strong>滥用的语义化</strong></p><ul><li><p><code>p</code>：不要用来增加额外的空白段落，应使用<code>CSS</code>的<code>margin/padding</code>来实现；</p></li><li><p><code>&lt;h1&gt;~&lt;h6&gt;</code>：该标签可以使文本字体变大，变粗，但如果文本<strong>并非是标题</strong>，应该使用<code>CSS font-weight font-size</code>；</p></li><li><p>不要将<code>&lt;b&gt;</code>元素与 <code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>或<code>&lt;mark&gt;</code>元素混淆。</p><ul><li><code>&lt;strong&gt;</code>用来对一个句子的部分增加<strong>重要性</strong>。（<strong>粗体</strong>）</li><li><code>&lt;em&gt;</code>用于改变一个句子的意思，<strong>强调</strong>某些文本。（<em>斜体</em>）</li><li><code>&lt;mark&gt;</code>表示上下文的<strong>关联性</strong>。（高亮）</li><li><code>&lt;b&gt;</code>用于<strong>吸引读者的注意</strong>到该元素的内容上，仅在没有其他合适的元素时使用它，如摘要中的关键字（<strong>粗体</strong>）</li></ul><p>如果不是出于语义目的而使用 <code>&lt;b&gt;</code> 元素，那么让文本显示粗体更好的方式是使用将 CSS 的 <code>font-weight</code> 属性设置为 <code>&quot;bold&quot;</code>。</p></li></ul><h4 id="H5新特性★"><a href="#H5新特性★" class="headerlink" title="H5新特性★"></a>H5新特性★</h4><ul><li><p>新增<strong>语义化</strong>标签。</p></li><li><p>H5提供了<code>sessionStorage</code>、<code>localStorage</code>和<code>indexedDB</code>加强本地存储。</p></li><li><p>input标签新增属性:</p><ul><li><p>placeholder属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>autofocus属性，页面只能有一个,自动获得焦点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">autofocus</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>canvas</code> 是 HTML5 新定义的标签，通过使用脚本（通常是 JavaScript）绘制图形。<code>&lt;canvas&gt;</code> 标签只是图形容器，相当于一个画布，<code>canvas</code> 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成，相当于使用画笔在画布上画画。</p><p>默认情况下，<code>&lt;canvas&gt;</code> 没有边框和内容。默认是一个 300*150 的画布，所以我们创建了 <code>&lt;canvas&gt;</code> 之后要对其设置宽高。</p><p>我们可以通过html属性<code>width</code>，<code>height</code>来设置canvas的宽高，不可以通过 css 属性来设置宽高。因为通过 css 属性设置的宽高会使 canvas 内的图像按照 300*150 时的比例放大或缩小。</p></li><li><p>地理(<code>Geolocation</code>) API</p></li><li><p>音频、视频API(<code>audio</code>、<code>video</code>)</p></li><li><p><code>webworker</code>, <code>websocket</code></p><ul><li><p><code>webworker</code>是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过<code>postMessage</code>传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。</p><p>双方都使用<code>postMessage()</code>方法发送各自的消息，使用<code>onmessage</code>事件处理函数来响应消息（消息被包含在<code>Message</code>事件的data属性中）。这个过程中数据并不是被共享而是被复制。</p><p><strong>但不能访问 DOM</strong>— 不能让一个worker直接更新UI。</p></li><li><p><code>WebSocket</code>是HTML5的一个持久化的协议，它实现了<strong>浏览器与服务器的全双工通信</strong>，同时也是跨域的一种解决方案。</p><p><code>WebSocket</code>和<code>HTTP</code>都是<strong>应用层协议</strong>，都基于 <code>TCP</code> 协议。</p><p>但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。</p><p>同时，<code>WebSocket</code> 在建立连接时需要借助 <code>HTTP</code> 协议，连接建立好了之后 <code>client</code> 与 <code>server</code> 之间的双向通信就与 <code>HTTP</code> 无关了。</p></li></ul></li></ul><h4 id="CSS盒模型-行内元素、块元素★"><a href="#CSS盒模型-行内元素、块元素★" class="headerlink" title="CSS盒模型 / 行内元素、块元素★"></a>CSS盒模型 / 行内元素、块元素★</h4><h5 id="块级盒子-block-box-和内联盒子-block-box"><a href="#块级盒子-block-box-和内联盒子-block-box" class="headerlink" title="块级盒子 (block box) 和内联盒子(block box)"></a>块级盒子 (block box) 和内联盒子(block box)</h5><p>块级盒子 (block box)：</p><ul><li><strong>在绝大数情况下意味着盒子会和父容器一样宽</strong></li><li>每个盒子都会<strong>换行</strong></li><li><code>width</code>和 <code>height</code> 属性可以发挥作用</li><li>内边距（<code>padding</code>）, 外边距（<code>margin</code>） 和 边框（<code>border</code>） 会将其他元素从当前盒子周围“推开”</li><li>除非特殊指定，诸如标题(<code>&lt;h1&gt;</code>等)、段落(<code>&lt;p&gt;</code>)和<code>div</code>默认情况下都是块级的盒子。</li></ul><p>内联盒子(block box) ：</p><ul><li>盒子<strong>不会产生换行</strong>。</li><li><code>width</code>和 <code>height</code> 属性将不起作用。</li><li><strong>垂直方向的内边距、外边距以及边框</strong>会被应用但是<strong>不会</strong>把其他处于 <code>inline</code> 状态的盒子推开。<ul><li>无内容<ul><li>垂直<code>padding</code>和<code>border</code>单独设置不会生效。</li><li>水平垂直<code>padding</code>和<code>border</code>同时设置，垂直<code>padding</code>和<code>border</code>会覆盖其他元素。</li></ul></li><li>有内容<ul><li>垂直<code>padding</code>和<code>border</code>会覆盖其他元素。</li></ul></li><li>不论有无内容，垂直<code>margin</code>不生效</li></ul></li><li><strong>水平方向的内边距、外边距以及边框</strong>会被应用且<strong>会</strong>把其他处于 <code>inline</code> 状态的盒子推开。</li><li>用做链接的 <code>&lt;a&gt;</code> 元素、 <code>&lt;span&gt;</code>、 <code>&lt;em&gt;</code> 以及 <code>&lt;strong&gt;</code> 都是默认处于 <code>inline</code> 状态的。</li></ul><p>我们通过对盒子<code>display</code> 属性的设置，比如 <code>inline</code> 或者 <code>block</code> ，来控制盒子的外部显示类型。</p><h5 id="inline，block，inline-block"><a href="#inline，block，inline-block" class="headerlink" title="inline，block，inline-block"></a>inline，block，inline-block</h5><blockquote><p>HTML 标准中块级元素和行内元素的区别至高出现在 4.01 标准中。</p><p>在 HTML5，这种区别被一个更复杂的内容类别代替。</p><p>”块级“类别大致相当于 HTML5 中的<code>Flow content(流内容)</code>类别，</p><p>而”行内“类别相当于 HTML5 中的<code>Phrasing content(短语内容)</code>类别，不过除了这两个还有其他类别。</p></blockquote><p>同块级盒子（块级元素）和内联盒子（行内元素）。</p><p>行内元素：</p><ul><li>一般情况下<strong>只能包含数据和其他行内元素</strong>。</li><li>一般是<strong>内容的容器</strong>。</li></ul><p>块级元素：</p><ul><li><strong>包含行内元素和其他块级元素</strong>。</li><li>适合做<strong>布局</strong>。</li></ul><p><strong>行内块元素</strong></p><ul><li><strong>既可以设置宽高，又可以和其他行内元素并排</strong>。</li><li><code>inline-block</code>的<code>margin、padding</code>会生效，而且<strong>不会发生外边距重叠</strong>。</li><li><code>inline</code>和<code>inline-block</code>会引起<strong>间距</strong>。这个间距是有<strong>空格</strong>或<strong>换行</strong>导致的。解决方法一：<strong>将空格直接删除，放到一行</strong></li></ul><p><strong>转换</strong></p><ul><li><strong>float:</strong> 行内=&gt;块。</li><li><strong>position:</strong> <code>position:absolute/fixed</code>，行内=&gt;块。</li><li><strong>display:</strong><ul><li><code>display:inline;</code></li><li><code>display:block;</code></li><li><code>display:inline-block;</code></li></ul></li></ul><h5 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h5><p>完整的 CSS 盒模型应用于<strong>块级盒子</strong>，<strong>内联盒子只使用盒模型中定义的部分内容</strong>。</p><ul><li><code>margin</code> 外边距</li><li><code>border</code> 边框</li><li><code>padding</code> 内边距</li><li><code>content</code> 内容区</li></ul><h5 id="标准盒模型和IE盒子模型"><a href="#标准盒模型和IE盒子模型" class="headerlink" title="标准盒模型和IE盒子模型"></a>标准盒模型和IE盒子模型</h5><p>CSS标准盒模型和IE盒模型的区别：</p><ul><li><p>在 <strong>标准盒子模型</strong>中，<strong>width 和 height 指的是内容区域</strong>的宽度和高度。</p></li><li><p><strong>IE盒子模型</strong>中，<strong>width 和 height 指的是内容区域+padding+border</strong>的宽度和高度。</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置当前盒子为 标准盒模型（默认） */</span></span><br><span class="line"><span class="attribute">box-sizing</span>: content-box;</span><br><span class="line"><span class="comment">/* 设置当前盒子为 IE盒模型 */</span></span><br><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br></pre></td></tr></table></figure><h4 id="BFC-消除浮动★"><a href="#BFC-消除浮动★" class="headerlink" title="BFC/消除浮动★"></a>BFC/消除浮动★</h4><blockquote><p>考察公司：字节、百度、b站</p></blockquote><p><strong>块级格式化上下文（Block Formatting Context，BFC）</strong>是 Web 页面的可视 CSS 渲染的一部分，是块级盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p><p>可以看作是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。</p><p><strong>生成</strong></p><ul><li>根元素（<code>&lt;html&gt;</code>）</li><li>浮动元素（<code>float</code>值不为 <code>none</code>）</li><li>绝对定位元素（<code>position</code>值为 <code>absolute</code> 或 <code>fixed</code>）</li><li><code>overflow</code>值不为 <code>visible</code>、<code>clip</code> 的块元素</li><li>行内块元素（<code>display</code>值为 <code>inline-block</code>）</li><li>表格单元格（<code>display</code>值为 <code>table-cell</code>，HTML 表格单元格默认值）</li><li>表格标题（<code>display</code>值为 <code>table-caption</code>，HTML 表格标题默认值）</li><li>匿名表格单元格元素（<code>display</code>值为 <code>table</code>、<code>table-row</code>、 <code>table-row-group</code>、<code>table-header-group</code>、<code>table-footer-group</code>（分别是 HTML table、tr、tbody、thead、tfoot 的默认值）或 <code>inline-table</code>）</li><li><code>display</code>]值为 <code>flow-root</code> 的元素</li><li><code>contain</code> 值为 <code>layout</code>、<code>content</code> 或 <code>paint</code> 的元素</li><li>弹性元素（<code>display</code> 值为 <code>flex</code> 或 <code>inline-flex</code> 元素的直接子元素），如果它们本身既不是 flex、grid 也不是 table 容器</li><li>网格元素（<code>display</code>值为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素），如果它们本身既不是 flex、grid也不是 table容器</li><li>多列容器（<code>column-count</code> 或 <code>column-width</code> 值不为 <code>auto</code>，包括<code>column-count</code> 为 <code>1</code>）</li><li><code>column-span</code> 值为 <code>all</code> 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中 (<a target="_blank" rel="noopener" href="https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51">规范变更</a>, <a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/chromium/issues/detail?id=709362">Chrome bug</a>)</li></ul><p>格式化上下文影响布局，通常，我们会为定位和清除浮动创建新的 BFC，而不是更改布局，因为它将：</p><ul><li><strong>包含内部浮动</strong></li><li><strong>排除外部浮动</strong></li><li><strong>阻止外边距重叠</strong></li></ul><p><strong>备注：</strong> flex/grid 容器（<code>display：flex/grid/inline-flex/inline-grid</code>）建立新的 flex/grid 格式上下文，除布局之外，它与块格式上下文类似。<strong>flex/grid 容器中没有可用的浮动子级，但排除外部浮动和阻止外边距重叠仍然有效。</strong> 在flex/grid容器中，<code>float</code>属性被忽略。</p><h5 id="包含内部浮动"><a href="#包含内部浮动" class="headerlink" title="包含内部浮动"></a>包含内部浮动</h5><p><strong>让浮动内容和周围的内容等高</strong>。</p><p>子元素浮动带来的高度塌陷：</p><ul><li><strong>父元素不设置高度默认是被子元素撑开的</strong>，当<strong>子元素浮动</strong>后，其会完全<strong>脱离文档流</strong>。</li><li>子元素从文档流中脱离，将会无法撑起父元素的高度，<strong>导致父元素的高度丢失</strong>。父元素高度丢失以后，其下的元素会自动上移，导致<strong>页面的布局混乱</strong>。</li></ul><p><strong>解决方案：</strong></p><ul><li><p><strong>使用 <code>overflow: auto</code></strong></p><ul><li>在创建包含浮动元素的 BFC 时，通常的做法是设置父元素 <code>overflow: auto</code> 或者其它除默认的 <code>overflow: visible</code> 以外的值。父元素变成布局中的迷你布局，<strong>任何子元素都会被包含进去</strong>。</li><li>使用 <code>overflow</code> 创建新的 BFC，是因为 <code>overflow</code> 属性会告诉浏览器应该<strong>怎样处理溢出的内容</strong>。</li><li>如果使用它仅仅为了创建 BFC，你<strong>可能会遇到不希望出现的滚动条或阴影</strong>，需要注意。另外，对于后续的开发者，可能不清楚当时为什么使用 <code>overflow</code>，所以最好添加一些注释来解释为什么这样做。</li></ul></li><li><p><strong>使用 <code>display: flow-root</code></strong></p><ul><li>一个新的 <code>display</code> 属性的值，它可以创建<strong>无副作用的 BFC</strong>。在父级块中使用 <code>display: flow-root</code> 可以创建新的 BFC。</li><li>给 <code>&lt;div&gt;</code> 元素设置 <code>display: flow-root</code> 属性后，<code>&lt;div&gt;</code> 中的所有内容都会参与 BFC，浮动的内容不会从底部溢出。</li><li>你可以从 <code>flow-root</code> 这个值的名字上看出来，它创建一个新的用于流式布局的上下文，类似于浏览器的根（<code>html</code>）元素。</li></ul></li><li><p>给父亲设置高度。正所谓<strong>有高度的盒子，才能关住浮动</strong>。</p></li><li><p><strong>伪元素+clear</strong></p><ul><li><p><code>clear</code> 属性指定一个元素是否必须移动(清除浮动后)到<strong>在它之前的浮动元素下面</strong>。</p></li><li><p><strong>要被清除的相关浮动元素</strong>指的是在相同<strong>块级格式化上下文</strong>中的<strong>前置浮动</strong>。</p></li><li><p>具体方法：</p><ul><li>给<strong>浮动元素的容器</strong>添加一个<code>clearfix</code>的class。</li><li>然后给这个class添加一个<code>::after</code>(用来创建一个伪元素，作为已选中元素的最后一个子元素)，</li><li>内容为空即没有高度看不到，但<code>display: block;</code>宽度仍然占满父元素，方便判断之前的左右浮动以清理。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.father</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: pink;</span></span><br><span class="line"><span class="css">        <span class="comment">/* overflow: hidden; */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* display: flow-root; */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* 注意 flex容器中不包含可用的浮动子级，也就是子元素浮动属性会失效 */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* display: flex; */</span></span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.son</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 确保该元素是一个块级元素 */</span></span></span><br><span class="line"><span class="css">        <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="css">        <span class="comment">/*清除浮动*/</span></span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;father clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">        hello son</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="排除外部浮动"><a href="#排除外部浮动" class="headerlink" title="排除外部浮动"></a>排除外部浮动</h5><p>我们可以使用 <code>display: flow-root</code> 和浮动实现双列布局，因为<strong>正常文档流中建立的 BFC 不得与元素本身所在的块格式化上下文中的任何浮动的外边距重叠</strong>。</p><p>flexbox 是在现代 CSS 中实现多列布局的更有效的方法。</p><h5 id="外边距重叠"><a href="#外边距重叠" class="headerlink" title="外边距重叠"></a>外边距重叠</h5><ul><li><p>解决margin重叠（父子、兄弟元素）</p><ul><li><strong>标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin</strong>(水平方向的margin是可以叠加的）。</li><li>且<strong>只会发生在块级元素</strong>，行内元素和行内块元素不会出现。</li><li><strong>儿子和父亲在竖直方向上为一个margin</strong>。</li><li>解决办法：<strong>给子元素或父元素（兄弟元素）创建BFC</strong>。</li></ul></li><li><p>同一层相邻元素之间</p><ul><li>相邻的两个元素之间的外边距重叠，除非后一个元素加上<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear">clear-fix 清除浮动</a>。</li></ul></li><li><p>没有内容将父元素和后代元素分开</p><ul><li>如果没有边框<code>border</code>，内边距<code>padding</code>，行内内容，也没有创建块级格式上下文或清除浮动来分开一个块级元素的上边界<code>margin-top</code>与其内一个或多个后代块级元素的上边界<code>margin-top</code>；</li><li>或没有边框，内边距，行内内容，高度<code>height</code>，最小高度<code>min-height</code>或 最大高度<code>max-height</code>来分开一个块级元素的下边界<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-bottom"><code>margin-bottom</code></a>与其内的一个或多个后代块元素的下边界<code>margin-bottom</code>，</li><li>则就会出现父块元素和其内后代块元素外边界重叠，重叠部分最终会溢出到父级块元素外面。</li></ul></li></ul><ul><li><p>空的块级元素</p><ul><li>当一个块元素上边界<code>margin-top</code> 直接贴到元素下边界<code>margin-bottom</code>时也会发生边界折叠。</li><li>这种情况会发生在一个块元素<strong>完全没有</strong>设定边框<code>border</code>、内边距<code>padding</code>、高度<code>height</code>、最小高度<code>min-height</code> 、最大高度<code>max-height</code>、内容设定为 inline 或是加上clear-fix的时候。</li></ul></li><li><p>一些需要注意的地方：</p><ul><li>上述情况的组合会产生更复杂的外边距折叠。</li><li>即使某一外边距为 0，这些规则仍然适用。因此就算<strong>父元素的外边距是 0</strong>，第一个或最后一个子元素的外边距仍然会“溢出”到父元素的外面。</li><li>如果参与折叠的外边距中包含<strong>负值</strong>，折叠后的外边距的值为<strong>最大的正边距与最小的负边距（即绝对值最大的负边距）的和</strong>；也就是说如果有 -13px 8px 100px 叠在一起，边界范围的技术就是 100px -13px 的 87px。</li><li>如果所有参与折叠的外边距<strong>都为负</strong>，折叠后的外边距的值为<strong>最小的负边距的值</strong>。这一规则适用于相邻元素和嵌套元素。</li></ul><p>以上这些内容都是发生在 Block-Level 的元素，设定 <code>floating</code> 和 <code>absolutely positioned</code> 的元素完全不用担心边界重叠的问题。</p></li></ul><h4 id="Flex★"><a href="#Flex★" class="headerlink" title="Flex★"></a>Flex★</h4><blockquote><p>考察公司：完美世界、字节</p></blockquote><p>Flex是Flexible Box的缩写，翻译成中文就是“<strong>弹性盒子</strong>”，用来为盒模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。</p><p>采用Flex布局的元素，被称为**Flex容器(flex container)**，简称“容器”。</p><p>其所有子元素自动成为容器成员，成为**Flex项目(Flex item)**，简称“项目”。</p><p>容器默认存在两根轴：<strong>水平方向</strong>主轴(main axis)和垂直方向交叉轴(cross axis)，<strong>默认项目按主轴排列</strong>。</p><h5 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h5><ul><li><p><strong>flex-flow</strong></p><ul><li><code>flex-direction</code>（主轴的方向） 默认<code>row</code>（水平）</li><li><code>flex-wrap</code>（换行），默认<code>nowrap</code>（不换行）</li></ul></li><li><p><strong>justify-content</strong></p><ul><li>定义项目在<strong>主轴上的对齐方式</strong>。</li><li><code>justify-content:center</code> 默认用作<strong>水平居中</strong>。</li></ul></li><li><p><strong>align-items</strong></p><ul><li>定义在<strong>交叉轴上的对齐方式</strong></li><li><code>align-items:center</code> 默认用作<strong>垂直居中</strong>。</li></ul></li><li><p><strong>align-content</strong></p><ul><li>定义<strong>多根轴线的对齐方式</strong></li><li>必须通过<code>flex-wrap</code>先有多根轴线</li></ul></li></ul><h5 id="元素属性"><a href="#元素属性" class="headerlink" title="元素属性"></a>元素属性</h5><ul><li><p><strong>align-self</strong></p><p>定义<strong>单个项目的对齐方式</strong>，常用于<strong>居中布局</strong>。</p></li><li><p><strong>flex</strong></p><p><strong>flex-grow，flex-shrink和flex-basis的简写</strong></p><p>默认值为<code>0 1 auto</code>，<strong>第一个属性必须</strong>，后两个属性可选。</p><ul><li><code>flex-grow</code>定义项目的放大比例<ul><li><strong>容器宽度&gt;元素总宽度</strong>时如何伸展，按比例分配<strong>剩余空间</strong>增加给各元素</li></ul></li></ul></li><li><p><code>flex-shrink</code>定义了项目的缩小比例</p><ul><li><strong>容器宽度&lt;元素总宽度</strong>时如何收缩</li><li>默认为1，即如果空间不足，该项目将缩小。</li><li>赋予<strong>更大的数值</strong>可以比赋予小数值的同级元素<strong>收缩程度更大</strong></li><li>在分配<strong>负空间</strong>时，<strong>收缩系数乘以元素尺寸</strong>。这将<strong>按项目能够收缩的大小比例分配负空间</strong>，因此，例如，一个小项目不会在一个较大的项目显著减少之前收缩为零。</li></ul></li><li><p><code>flex-basis</code>定义在分配多余空间之前，项目占据的主轴空间。</p><ul><li>flex容器里除了元素所占的空间以外的富余空间就是<strong>可用空间</strong> 。</li><li>该属性的默认值是 <code>auto</code> 。此时，浏览器会检测这个元素是否具有确定的尺寸。</li><li>如果没有给元素设定尺寸，<code>flex-basis</code> 的值采用元素<strong>内容的尺寸</strong>。</li><li>所以我们给只要给Flex元素的父元素声明 <code>display: flex</code> ，所有子元素就会排成一行，且自动分配小大以充分展示元素的内容。</li></ul></li><li><p>常见一些属性有：</p><ul><li><p><code>flex: 1</code> = <code>flex: 1 1 0</code>，常用作<strong>自适应布局</strong>。</p></li><li><p><code>flex: 2</code> = <code>flex: 2 1 0</code></p></li><li><p><code>flex: auto</code> = <code>flex: 1 1 auto</code></p></li><li><p><code>flex: none</code> = <code>flex: 0 0 auto</code>，常用于<strong>固定尺寸不伸缩</strong></p></li></ul></li><li><p><code>flex:1</code> 和 <code>flex:auto</code> 的区别，可以归结于<code>flex-basis:0</code>和<code>flex-basis:auto</code>的区别。</p><ul><li><p>当设置为<code>0</code>时（绝对弹性元素），伸缩时不考虑元素尺寸。</p></li><li><p>当设置为<code>auto</code>时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑。</p></li></ul></li></ul><ul><li><p><strong>order</strong></p><p>定义项目的<strong>排列顺序</strong>。<strong>数值越小，排列越靠前</strong>，默认为0，可以是负值。</p></li></ul><h4 id="居中布局★"><a href="#居中布局★" class="headerlink" title="居中布局★"></a>居中布局★</h4><h5 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h5><ul><li><p><code>text-align: center</code></p><ul><li>设置<strong>块元素或表格单元格</strong>中<strong>内容</strong>的水平对齐方式。</li><li><strong>不能直接用于行内元素</strong> 。</li><li>另外，这个内容不一定是行内元素，块元素中有h1(块元素)一样可以实现效果。</li></ul></li><li><p><code>margin: 0 auto</code></p><ul><li>计算元素对应方向上应该获得的<strong>剩余空间</strong>大小。</li><li>因为块级元素设置宽度后仍占据一行空间，<code>margin: 0 auto</code>会将这一行的剩余空间平均分配给左右外边距。</li><li><code>margin:auto</code> 能使<strong>块级元素</strong>水平居中，但是不能垂直居中，因为<strong>垂直方向上默认没有剩余的空间</strong>。</li><li><code>margin:auto</code> <strong>行内元素</strong>既不能水平居中也不能垂直居中，因为行内元素<strong>水平垂直方向上默认都没有剩余的空间</strong>。</li></ul></li></ul><h5 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h5><ul><li><code>line-height: 父元素高度</code> 适合文本。</li></ul><h5 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h5><ul><li><p><code>flex + justify-content + align-items</code></p><ul><li>但对<strong>子元素图片、文字</strong>都有时，<strong>竖直方向</strong>的对齐会有差异</li><li><strong>父元素开启Flex布局</strong>。</li><li>图片子元素设置<code>align-self: center;</code></li><li>文字子元素使用<code>line-height: 父元素高度</code>。</li></ul></li><li><p><code>absolute + transform</code></p><ul><li><code>top,left</code>跟根据<strong>父元素的宽和高</strong>偏移的。<code>top: 50%;left: 50%;</code> 元素左上角居中。</li><li><code>transform: translate(-50%, -50%);</code>是根据<strong>自身的宽高</strong>偏移的。</li><li>这个<strong>计算的元素自身不包含margin</strong>，用此方法要注意设置<code>margin: 0;</code></li><li>也可以<code>margin</code>和<code>absolute</code>结合实现居中布局<ul><li><code>absolute(top:50%;left:50%;) + 负margin</code></li><li><code>absolute(top:0;left:0;right:0;bottom:0;)+margin:auto</code></li></ul></li></ul></li><li><p><strong>网格布局（Grid）</strong></p></li></ul><h4 id="position定位-★"><a href="#position定位-★" class="headerlink" title="position定位 ★"></a>position定位 ★</h4><ul><li><p><strong>Static</strong></p><ul><li>元素的默认定位方式，元素出现在<strong>正常的文档流</strong>中，会<strong>占用页面空间</strong>。</li><li>该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。</li><li>此时 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 和 <code>z-index</code> 属性无效。</li></ul></li><li><p><strong>Relative</strong></p><ul><li>相对定位方式，<strong>相对于其父级元素</strong>（无论父级元素此时为何种定位方式）进行定位。</li><li>准确地说是<strong>相对于其父级元素所剩余的未被占用的空间进行定位</strong>（在父元素有多个相对定位的子元素时可以看出），且<strong>会占用该元素在文档中初始的页面空间</strong>，即在使用top，bottom，left，right进行移动位置之后依旧<strong>不会改变其所占用空间的位置</strong>。</li><li>元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此<strong>会在此元素未添加定位时所在位置留下空白</strong>）。</li><li>可以使用<code>z-index</code>进行在z轴方向上的移动。</li></ul></li><li><p><strong>Absolute</strong></p><ul><li>绝对定位方式，<strong>脱离文档流，不会占用页面空间</strong>。</li><li><strong>以最近的不是static定位的父级元素</strong>作为参考进行定位，如果其所有的父级元素都是static定位，那么此元素最终则是以<strong>当前窗口</strong>作为参考进行定位。</li><li>可以使用top，bottom，left，right进行位置移动，亦可使用<code>z-index</code>在z轴上面进行移动。</li><li>当元素为此定位时，如果该元素为<strong>内联元素</strong>，则会变为<strong>块级元素</strong>，即可以直接设置其宽和高的值；</li><li>如果该元素为块级元素，则其宽度会由初始的<code>100%</code>变为<code>auto</code>。</li><li>注意：当元素设置为绝对定位时，在没有指定top，bottom，left，right的值时，他们的值并<strong>不是0</strong>，这几个值是有默认值的，默认值就是<strong>该元素设置为绝对定位前所处的正常文档流中的位置</strong>。</li><li>绝对定位的元素可以设置外边距（margins），且<strong>不会与其他边距合并</strong>。</li></ul></li><li><p><strong>Fixed</strong></p><ul><li>绝对定位方式，直接以<strong>浏览器视口</strong>作为参考进行定位。其它特性同absolute定位。</li></ul></li><li><p><strong>sticky</strong></p><ul><li>粘性定位，可以简单理解为relative和fixed布局的混合。</li><li>当粘性约束矩形在可视范围内为relative，反之，则为fixed粘性定位元素。</li><li>如果和它的父元素一样高，则垂直滚动的时候，粘性定位效果是不会出现的，它的定位效果完全受限于父级元素们。</li><li>如果父元素的overflow属性设置了scroll，auto,overlay值，那么，粘性定位将会失效。</li><li>同一容器中多个粘贴定位元素独立偏移，因此可能重叠；位置上下靠在一起的不同容器中的粘贴定位元素则会鸠占鹊巢，挤开原来的元素，形成依次占位的效果。</li></ul></li><li><p>补充</p><ul><li><code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>这四个属性要生效的话,必须得设置<strong>相对定位/绝对定位</strong>。</li><li>子绝父相就是：子元素为绝对定位(<code>position：absolute;</code>)，父元素为相对定位<code>position：relative;</code>。</li><li>当元素祖先的 <code>transform</code>, <code>perspective</code> 或 <code>filter</code> 属性非 <code>none</code> 时，绝对定位（absolute/fixed）参考元素就会变为该祖先。</li></ul></li></ul><h4 id="margin与padding-包含块-★"><a href="#margin与padding-包含块-★" class="headerlink" title="margin与padding 包含块 ★"></a>margin与padding 包含块 ★</h4><p><code>margin</code>控制的是<strong>元素外部空出的空间</strong>。相反，<code>padding</code>操作<strong>元素内部空出的空间</strong>。</p><p>设置百分比都是相对于<strong>包含块</strong>的<strong>宽度</strong>。</p><p>一个元素的尺寸和位置经常受其**包含块 (containing block)**的影响。</p><p>大多数情况下，<strong>包含块就是这个元素最近的祖先块元素的内容区</strong>，但也不是总是这样。</p><p>对于一些属性，例如 <code>width</code>, <code>height</code>, <code>padding</code>, <code>margin</code>，绝对定位元素的偏移值（比如 <code>position</code> 被设置为 <code>absolute</code> 或 <code>fixed</code>），当我们对其赋予百分比值时，这些值的计算值，就是通过元素的包含块计算得来。</p><p>确定一个元素的包含块的过程完全依赖于这个元素的<code>position</code> 属性：</p><ol><li>如果 position 属性为 <strong><code>static</code><strong>、</strong><code>relative</code></strong> <strong>或 <code>sticky</code><strong>，包含块可能由它的最近的祖先</strong>块元素</strong>（比如说 inline-block, block 或 list-item 元素）的内容区的边缘组成，也可能会建立格式化上下文 (比如说 a table container, flex container, grid container, 或者是 the block container 自身)。</li><li>如果 position 属性为 <strong><code>absolute</code></strong> ，包含块就是由它的最近的 position 的值不是 <code>static</code> （也就是值为<code>fixed</code>, <code>absolute</code>, <code>relative</code> 或 <code>sticky</code>）的祖先元素的内边距区的边缘组成。</li><li>如果 position 属性是 <strong><code>fixed</code><strong>，在连续媒体的情况下 (continuous media) 包含块是</strong>视口</strong> ,在分页媒体 (paged media) 下的情况下包含块是分页区域 (page area)。</li><li>如果 position 属性是<code>absolute</code>或<code>fixed</code>，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：<ol><li><code>transform</code>或 <code>perspective</code>的值不是 <code>none</code></li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change"><code>will-change</code></a> 的值是 <code>transform</code> 或 <code>perspective</code></li><li><code>filter</code> 的值不是 <code>none</code> 或 <code>will-change</code> 的值是 <code>filter</code>(只在 Firefox 下生效).</li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain"><code>contain</code></a> 的值是 <code>paint</code> (例如: <code>contain: paint;</code>)</li></ol></li></ol><p><strong>备注：</strong> 根元素 (<code>&lt;html&gt;</code>) 所在的包含块是一个被称为<strong>初始包含块</strong>的矩形。他的尺寸是视口(for continuous media) 或分页媒体 page media (for paged media).</p><p>如上所述，<strong>如果某些属性被赋予一个百分值的话，它的计算值是由这个元素的包含块计算而来的。这些属性包括盒模型属性和偏移属性：</strong></p><ol><li>要计算 <code>height</code> <code>top</code>及 <code>bottom</code>中的百分值，是通过包含块的 <code>height</code> 的值。如果包含块的 <code>height</code> 值会根据它的内容变化，而且包含块的 <code>position</code> 属性的值被赋予 <code>relative</code> 或 <code>static</code> ，那么，这些值的计算值为 auto（由浏览器为元素计算并选择一个高度。）。</li><li>要计算 <code>width</code>, <code>left</code>, <code>right</code>, <code>padding</code>, <code>margin</code>这些属性由包含块的 <code>width</code> 属性的值来计算它的百分值。</li></ol><blockquote><p>补充：</p></blockquote><p><code>perspective</code>指定了观察者与 z=0 平面的距离，使具有三维位置变换的元素产生透视效果。</p><p><code>will-change</code> 为 web 开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。</p><p>用好这个属性并不是很容易：</p><ul><li><strong>不要将 will-change 应用到太多元素上</strong>：浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与 <code>will-change</code> 结合在一起的话，有可能会消耗很多机器资源，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源。</li><li><strong>有节制地使用：</strong>通常，当元素恢复到初始状态时，浏览器会丢弃掉之前做的优化工作。但是如果直接在样式表中显式声明了 <code>will-change</code> 属性，则表示目标元素可能会经常变化，浏览器会将优化工作保存得比之前更久。所以最佳实践是当元素变化之前和之后通过脚本来切换 <code>will-change</code> 的值。</li><li><strong>不要过早应用 will-change 优化：</strong>如果你的页面在性能方面没什么问题，则不要添加 <code>will-change</code> 属性来榨取一丁点的速度。 <code>will-change</code> 的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题。过度使用 <code>will-change</code> 会导致大量的内存占用，并会导致更复杂的渲染过程，因为浏览器会试图准备可能存在的变化过程。这会导致更严重的性能问题。</li><li><strong>给它足够的工作时间：</strong>这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上 <code>will-change 属性。</code></li></ul><p><code>filter</code> 将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像、背景和边框的渲染。</p><p><code>contain</code>属性允许开发者声明当前元素和它的内容尽可能的<em>独立</em>于 DOM 树的其他部分。这使得浏览器在重新计算布局、样式、绘图、大小或这四项的组合时，只影响到有限的 DOM 区域，而不是整个页面，可以有效改善性能。</p><p>这个属性在包含大量独立组件的页面非常实用，它可以防止某个小部件的 CSS 规则改变对页面上的其他东西造成影响。</p><p><strong>备注：</strong>如果应用（具有值：<code>paint</code>，<code>strict</code>或<code>content</code>），此属性创建：</p><ol><li>一个新的包含块（对于<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的后代）。</li><li>一个新的堆叠上下文。</li><li>一个新的块格式化上下文。</li></ol><h4 id="CSS选择器优先级★"><a href="#CSS选择器优先级★" class="headerlink" title="CSS选择器优先级★"></a>CSS选择器优先级★</h4><p>CSS 中的权重，指的是<strong>选择器的优先级</strong>。</p><p>对同一HTML元素设置样式时，不同选择器的优先级不同，<strong>优先级低的样式将被高优先级的样式层叠掉</strong>。</p><p>CSS 权重优先级顺序简单表示为：</p><ul><li><code>!important</code></li><li>内联样式(<code>style=&quot;&quot;</code>)</li><li>类(<code>.class属性值</code>)、伪类(<code>:nth-child()</code>)、属性(<code>[属性名]</code>)</li><li>ID (<code>#id属性值</code>)</li><li>标签名(<code>p&#123;&#125;</code>)、伪元素(<code>::after</code>)</li><li>通配符(<code>*</code>)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.red</span> <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: red;&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.green</span> <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: green;&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;green&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>p: 颜色<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>.red p</code>和<code>.green p</code>的选择器权重相同，那么<strong>谁在后面，最后就应用谁</strong>。所以最后是绿色。</p><p>如果<code>red</code>换成id选择器或者添加<code>!important</code>，就会变成红色。</p><p>对于同一个元素设置<strong>z-index不会对选择器权重产生影响</strong>，另外<code>z-index</code> 属性设定了一个<strong>定位元素及其后代元素</strong>或 <strong>flex 项目</strong>的 z-order。 当元素之间重叠的时候， z-index 较大的元素会覆盖较小的元素在上层进行显示。</p><p><strong>继承样式</strong></p><ul><li><strong>继承得到的样式的优先级是最低的</strong>，在任何时候，只要元素本身有同属性的样式定义，就可以覆盖掉继承值。</li><li>在存在多个继承样式时，层级关系距离当前元素最近的父级元素的继承样式，具有相对最高的优先级。</li></ul><h4 id="滚动条-★"><a href="#滚动条-★" class="headerlink" title="滚动条 ★"></a>滚动条 ★</h4><p>问题：苹果电脑设置始终显示滚动条，会使得页面中设置了滚动条的部分显示滚动条背景色</p><p><strong>CSS 滚动条选择器</strong></p><p>你可以使用以下伪元素选择器去修改<strong>基于 webkit 的浏览器</strong>的滚动条样式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">::<span class="selector-tag">-webkit-scrollbar</span>        		<span class="comment">// 整个滚动条。</span></span><br><span class="line">::<span class="selector-tag">-webkit-scrollbar-button</span> 		<span class="comment">// 滚动条上的按钮（上下箭头）。</span></span><br><span class="line">::<span class="selector-tag">-webkit-scrollbar-thumb</span>  		<span class="comment">// 滚动条上的滚动滑块。</span></span><br><span class="line">::<span class="selector-tag">-webkit-scrollbar-track</span>  		<span class="comment">// 滚动条轨道。</span></span><br><span class="line">::<span class="selector-tag">-webkit-scrollbar-track-piece</span> <span class="comment">// 滚动条没有滑块的轨道部分。</span></span><br><span class="line">::<span class="selector-tag">-webkit-scrollbar-corner</span>      <span class="comment">// 当同时有垂直滚动条和水平滚动条时交汇的部分。通常是浏览器窗口的右下角。</span></span><br><span class="line">::<span class="selector-tag">-webkit-resizer</span>               <span class="comment">// 出现在某些元素底角的可拖动调整大小的滑块。</span></span><br></pre></td></tr></table></figure><p>上述内容不兼容Firefox，火狐64位目前只提供了部分自定义滚动条的属性：</p><ul><li><code>scrollbar-width</code>：该属性可取值：</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrollbar-<span class="attribute">width</span>: auto; <span class="comment">// 默认值</span></span><br><span class="line">scrollbar-<span class="attribute">width</span>: thin; <span class="comment">// 比默认滚动条窄</span></span><br><span class="line">scrollbar-<span class="attribute">width</span>: none; <span class="comment">// 不显示滚动条，但是仍可以滚动 </span></span><br></pre></td></tr></table></figure><ul><li><code>scrollbar-color</code>： 其可填写的值有：</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scrollbar-<span class="attribute">color</span>: auto; <span class="comment">// 默认值</span></span><br><span class="line">scrollbar-<span class="attribute">color</span>: dark;</span><br><span class="line">scrollbar-<span class="attribute">color</span>: light;</span><br><span class="line">scrollbar-<span class="attribute">color</span>: red green; <span class="comment">// 第一个滚轮颜色，第二个滚动条背景色 </span></span><br></pre></td></tr></table></figure><blockquote><p>其中<code>dark</code>和<code>light</code>并没有实现。</p></blockquote><p>使用插件或者自己DIY</p><p>比较好用的插件：</p><ul><li><p><a target="_blank" rel="noopener" href="https://github.com/malihu/malihu-custom-scrollbar-plugin">JQuery Custom Scrollbar</a></p></li><li><p><a target="_blank" rel="noopener" href="https://github.com/mdbootstrap/perfect-scrollbar">Perfect Scrollbar</a> ： 只有6K大小。</p></li></ul><p>隐藏滚动条</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">    scrollbar-<span class="attribute">width</span>: none;</span><br><span class="line">&#125;</span><br><span class="line">::<span class="selector-tag">-webkit-scrollbar</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">color</span>: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><h4 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h4><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>常见的数组定义：<strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p><p><strong>JavaScript 数组的长度和元素类型都是非固定的。</strong></p><p>因为数组的<strong>长度可随时改变</strong>，并且其数据<strong>在内存中也可以不连续</strong>（存储相同类型元素内存连续）。</p><p><strong>优点</strong>：可以通过下标值访问，效率高；</p><p><strong>缺点</strong>：查找数据时需要先对数据进行排序，生成有序数组，才能提高查找效率；并且在插入和删除元素时，需要大量的位移操作；</p><h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><p>链表是一种通过<strong>指针</strong>串联在一起的线性结构，每一个节点由两部分组成，一个是<strong>数据域</strong>一个是<strong>指针域</strong>（存放指向下一个节点的指针），<strong>最后一个节点的指针域指向null</strong>（空指针的意思）。链接的入口节点称为链表的头结点也就是<code>head</code>。</p><p><strong>单链表</strong>：单链表中的节点只能指向节点的下一个节点。</p><p><strong>双链表</strong>：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p><p><strong>双链表既可以向前查询也可以向后查询</strong>。</p><p><strong>循环链表</strong>，就是链表首尾相连。</p><p>链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><p>链表的增添和删除都是O(1)操作，也不会影响到其他节点。</p><p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p><p>链表的长度可以是不固定的，并且可以动态增删， <strong>适合数据量不固定，频繁增删，较少查询的场景</strong>。</p><p><strong>优点</strong>：数据的插入和删除操作效率都很高；</p><p><strong>缺点</strong>：查找效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。</p><h5 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h5><blockquote><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p></blockquote><p>其实<strong>数组就是一张哈希表</strong>。哈希表中关键码就是数组的索引下表，然后通过下表直接访问数组中的元素。</p><p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><p>我们一般会选择如下三种数据结构：</p><ul><li><strong>数组</strong></li><li><strong>set（集合）</strong></li><li><strong>map（映射）</strong></li></ul><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><p><strong>优点</strong>：哈希表的插入/查询/删除效率都非常高；</p><p><strong>缺点</strong>：空间利用率不高，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是无序的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中最大值或最小值这些特殊值。</p><h5 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h5><p>常用术语：</p><ul><li>节点的度（Degree）：<strong>节点的子树个数</strong>，比如节点 B 的度为 2；</li><li>树的度：<strong>树的所有节点中最大的度数</strong>，如上图树的度为 2；</li><li>叶节点（Leaf）：<strong>度为 0 的节点（也称为叶子节点）</strong>，如上图的 H，I 等；</li><li>父节点（Parent）：<strong>度不为 0 的节点称为父节点</strong>，如上图节点 B 是节点 D 和 E 的父节点；</li><li>子节点（Child）：若 B 是 D 的父节点，那么 D 就是 B 的子节点；</li><li>兄弟节点（Sibling）：具有同一父节点的各节点彼此是兄弟节点，比如上图的 B 和 C，D 和 E 互为兄弟节点；</li><li>路径和路径长度：<strong>路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长</strong>度，比如 A-&gt;H 的路径长度为 3；</li><li>节点的层次（Level）：规定根节点在 1 层，其他任一节点的层数是其父节点的层数加 1。如 B 和 C 节点的层次为 2；</li><li>树的深度（Depth）：<strong>树种所有节点中的最大层次是这棵树的深度</strong>，如上图树的深度为 4；</li></ul><p>如果树中的每一个节点最多只能由两个子节点，这样的树就称为<strong>二叉树</strong></p><p><strong>二叉树的种类</strong></p><ul><li><p><strong>满二叉树</strong>：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p><p>也可以说深度为k，有2^k-1个节点的二叉树。</p></li><li><p><strong>完全二叉树</strong>：除了最<strong>底层节点可能没填满外</strong>，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层<strong>最左边的若干位置</strong>。若最底层为第 h 层，则该层包含 1~ 2^h -1 个节点。</p></li></ul><p><strong>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</strong></p><p>二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵<strong>空树</strong>或它的<strong>左右两个子树的高度差的绝对值不超过1</strong>，并且<strong>左右两个子树都是一棵平衡二叉树</strong>。</p><p><strong>二叉树的存储方式</strong></p><ul><li>链式存储 通过<strong>指针</strong>把分布在散落在各个地址的节点串联一起</li><li>顺序存储 数组 在内存是连续分布的</li></ul><p><strong>二叉树的遍历方式</strong></p><ul><li><strong>深度优先遍历</strong>：先往深走，遇到叶子节点再往回走。前中后，其实指的就是根节点的遍历顺序<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li><strong>广度优先遍历</strong>：一层一层的去遍历。<ul><li>层次遍历（迭代法，队列）</li></ul></li></ul><p><strong>前端应用</strong>：DOM树、CSS规则树、虚拟DOM、AST语法树</p><p><strong>优点</strong>：树结构综合了上述三种结构的优点，同时也弥补了它们存在的缺点（虽然效率不一定都比它们高），比如树结构中数据都是有序的，查找效率高；空间利用率高；并且可以快速获取最大值和最小值等。</p><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>栈（stack）是一种运算受限的线性表。特点：<strong>先进后出</strong>。</p><blockquote><p>程序中的栈结构</p></blockquote><ul><li>函数调用栈：A(B(C(D())))：<br>即 A 函数中调用 B，B 调用 C，C 调用 D；在 A 执行的过程中会将 A 压入栈，随后 B 执行时 B 也被压入栈，函数 C 和 D 执行时也会被压入栈。所以当前栈的顺序为：A-&gt;B-&gt;C-&gt;D（栈顶）；函数 D 执行完之后，会弹出栈被释放，弹出栈的顺序为 D-&gt;C-&gt;B-&gt;A;</li><li>递归：<br>为什么没有停止条件的递归会造成栈溢出？比如函数 A 为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数 A 压入栈，最后造成栈溢出（Queue Overfloat）。</li></ul><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>队列（Queue）是一种运算受限的线性表，特点：<strong>先进先出</strong>。</p><p>事件循环中的宏任务和微任务队列。</p><p><strong>优先队列</strong></p><ul><li>每个元素不再只是一个数据，还包含优先级。</li><li>在添加元素过程中，根据优先级放入到正确位置。</li></ul><h4 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h4><h5 id="递归★"><a href="#递归★" class="headerlink" title="递归★"></a>递归★</h5><p>递归就是把规模较大的一个问题，分解成规模较小的多个子问题去解决，而每一个子问题又可以继续拆分成多个更小的子问题。</p><p>递归就是<strong>一个函数在它的函数体内调用它自身</strong>。</p><p>执行递归函数]将反复调用其自身，每调用一次就进入新的一层。递归函数必须有<strong>结束条件</strong>。</p><p>我一般处理递归的思路主要注意以下两点：</p><ul><li>先处理一小步（先处理最简情况）,然后自己调自己</li><li>找到退出条件</li></ul><p>迭代：迭代是重复反馈过程的活动。每一次对过程的重复称为一次“迭代”，每一次迭代得到的结果会作为下一次迭代的初始值。</p><p>递归中有迭代，但迭代中不一定有递归，大部分可以相互转换；</p><p>相比较而言，能用迭代就不要用递归，递归不断调用函数，浪费空间，也容易引起堆栈溢出。</p><p>优点</p><ul><li>简洁</li><li>在树的前序，中序，后序遍历算法中，递归的实现明显要比循环简单得多。</li></ul><p>问题（缺点）</p><ul><li><strong>性能</strong>：假设传入的参数值特别大，那么这个调用栈将会非常之大，最终可能超出调用栈的缓存大小而崩溃导致程序执行失败。每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。</li><li>效率：<ul><li>递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址以及临时变量，而往栈中压入数据和弹出数据都需要时间。</li><li>递归中很多计算都是重复的，由于其本质是把一个问题分解成两个或者多个小问题，多个小问题存在相互重叠的部分，则存在<strong>重复计算</strong>，如fibonacci斐波那契数列的递归实现。</li></ul></li></ul><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><h6 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h6><ul><li>冒泡排序只会操作<strong>相邻的两个数据</strong>。</li><li>外层需要n-1次排序，第n次比较是多余的，每一次结束后，未排序部分的最大值冒泡到最后。（从后向前）</li><li>内层循环不断对<strong>未排序部分</strong>两两比较交换。</li><li>每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。</li><li>一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</li></ul><p>冒泡的过程只涉及相邻数据的交换操作，空间复杂度为 O(1)，是一个<code>原地</code>排序算法。</p><p>为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换， 所以冒泡排序是<code>稳定</code>的排序算法。</p><p>时间复杂度：最佳：<code>T(n) = O(n)</code>，正序。 最差：<code>T(n) = O(n^2)</code>，反序。 平均：<code>T(n) = O(n^2)</code>。</p><h6 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h6><p>我们通常说的插入排序是指直接插入排序。</p><p>插入排序的工作原理：<strong>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</strong>。</p><p><strong>步骤</strong></p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中<strong>从后向前</strong>扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤 2 ~ 5。</li></ul><p>插入排序算法的运行不需要额外的存储空间，空间复杂度是 O(1)，是一个<code>原地</code>排序算法。</p><p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是<code>稳定</code>的排序算法。</p><p>时间：最佳：<code>T(n) = O(n)</code>，正序。 最差：<code>T(n) = O(n^2)</code>，反序。 平均：<code>T(n) = O(n^2)</code>。</p><h6 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h6><p>选择排序<strong>每次会从未排序区间中找到最大（小）的元素，将其放到已排序区间的末尾。</strong></p><p>选择排序空间复杂度为 O(1)，是一种<code>原地</code>排序算法。</p><p>选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，破坏了稳定性。</p><p>无论是正序还是逆序，选择排序都会遍历 <code>T = （n-1)）+ （n -2）+（n - 3）.... + 1; ===&gt;&gt; T = [n*(n-1) ] / 2；</code> 次来排序，所以，最佳、最差和平均的复杂度是一样的。 <code>T(n) = O(n^2)</code>。</p><h6 id="快速排序-★"><a href="#快速排序-★" class="headerlink" title="快速排序 ★"></a>快速排序 ★</h6><ul><li>先找到一个基准点（一般指数组的中部<code>midIndex</code>或随机数），然后数组被该基准点分为两部分，依次与该基准点数据<code>mid</code>比较，如果比它小，放左边；反之，放右边。</li><li>左右分别用一个空数组去存储比较后的数据。</li><li>最后递归执行上述操作，直到数组长度 &lt;= 1;</li></ul><p>缺点：<strong>需要另外声明两个数组，浪费了内存空间资源</strong>。</p><p>优化</p><p>优化的算法进行分区时，不需要很多额外的内存空间，所以快排是<code>原地排序</code>算法。</p><p>快速排序每次交换的元素都有可能不是相邻的，因此它有可能打破原来值为相同的元素之间的顺序。因此，快速排序并<code>不稳定</code>。</p><p>极端的例子：如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为基准点，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n / 2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n^2)。<strong>快排时间复杂度与基准点的选取有关，一般取中部或随机最优。</strong></p><p>时间：最佳：<code>T(n) = O(nlogn)</code>。 最差：<code>T(n) = O(n^2)</code>。 平均：<code>T(n) = O(nlogn)</code>。</p><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><p>英文：Dynamic Programming，简称<strong>DP</strong>，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的。</p><blockquote><p>动态规划问题五步曲</p></blockquote><ol><li>确定<strong>dp数组（dp table）</strong>以及<strong>下标</strong>的含义</li><li>确定<strong>递推公式</strong></li><li>dp数组如何<strong>初始化</strong></li><li>确定<strong>遍历顺序</strong></li><li><strong>举例</strong>推导dp数组</li></ol><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p><p><strong>刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心</strong>。</p><h5 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h5><h5 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h5></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leslie Waong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesliewaong.top/posts/afb4a817.html">https://lesliewaong.top/posts/afb4a817.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lesliewaong.top" target="_blank">Leslie Waong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/3.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Leslie Waong</div><div class="author-info__description">BUPT</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">122</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lesliewaong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lesliewaong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1138964397&amp;website=www.qtxml.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">红雨漂泊泛起了回忆怎么潜</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%9C%E5%8F%91%E8%A1%8C"><span class="toc-text">农发行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%91%E7%A0%94"><span class="toc-text">科研</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%B9%A0"><span class="toc-text">实习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9"><span class="toc-text">难点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%E4%B8%8E%E4%B8%8D%E8%B6%B3"><span class="toc-text">收获与不足</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF"><span class="toc-text">微前端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">相关概念</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE"><span class="toc-text">项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android%E8%AF%8D%E5%85%B8"><span class="toc-text">Android词典</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E7%88%AC%E5%8F%96"><span class="toc-text">单词数据的爬取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1"><span class="toc-text">界面设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#API%E6%88%96SDK"><span class="toc-text">API或SDK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVVM"><span class="toc-text">MVVM</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Android-MVC"><span class="toc-text">Android MVC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Android-MVVM"><span class="toc-text">Android MVVM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E2%98%85"><span class="toc-text">商城后台管理系统★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E5%B7%A5%E7%A8%8B%E5%8C%96-%E2%98%85"><span class="toc-text">模块化、组件化、工程化 ★</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">模块化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">工程化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="toc-text">组件化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2"><span class="toc-text">界面</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2"><span class="toc-text">登录界面</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB"><span class="toc-text">预加载动画</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-text">功能实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E2%98%85"><span class="toc-text">用户登录和权限管理★</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%A1%E9%AA%8C"><span class="toc-text">输入校验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E5%92%8CAjax"><span class="toc-text">跨域和Ajax</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E9%80%9A%E4%BF%A1"><span class="toc-text">父子通信</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83"><span class="toc-text">发布</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#GitHub-Pages%E5%8F%91%E5%B8%83%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2"><span class="toc-text">GitHub Pages发布静态页面</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96"><span class="toc-text">项目优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89hook%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E9%98%B2%E6%8A%96"><span class="toc-text">自定义hook实现搜索防抖</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HR"><span class="toc-text">HR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%92"><span class="toc-text">规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%B4%A7%E4%BB%BB%E5%8A%A1%E9%87%8D-%E5%8E%8B%E5%8A%9B"><span class="toc-text">时间紧任务重&#x2F;压力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E4%BD%9C"><span class="toc-text">合作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E7%A0%B4%E5%B8%B8%E8%A7%84%EF%BC%8C%E6%96%B0%E9%A2%96%E7%9A%84%E6%83%B3%E6%B3%95"><span class="toc-text">打破常规，新颖的想法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E6%9C%89%E8%AE%A1%E5%88%92%E5%8F%91%E7%94%9F%E9%87%8D%E5%A4%A7%E5%8F%98%E5%8C%96%E7%9A%84%E7%BB%8F%E5%8E%86%E3%80%82"><span class="toc-text">原有计划发生重大变化的经历。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E5%88%86%E6%AD%A7"><span class="toc-text">出现分歧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E4%B8%B4%E7%9A%84%E5%A4%8D%E6%9D%82%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E3%80%81%E6%8F%90%E5%87%BA%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E7%9A%84%E3%80%82"><span class="toc-text">面临的复杂问题，如何快速定位问题、提出解决思路的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E7%9A%84%E5%9B%B0%E9%9A%BE"><span class="toc-text">遇到的困难</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B-%E6%88%90%E7%BB%A9-%E8%8E%B7%E5%A5%96%E6%83%85%E5%86%B5-%E7%AB%9E%E8%B5%9B"><span class="toc-text">课程&#x2F;成绩&#x2F;获奖情况&#x2F;竞赛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E7%BB%8F%E5%8E%86%E7%9A%84%E6%9C%80%E5%A4%A7%E6%8C%AB%E6%8A%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">你经历的最大挫折是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-%E7%AB%9E%E4%BA%89%E5%8A%9B"><span class="toc-text">优缺点 竞争力</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%B9%B3%E6%97%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%9A%84%EF%BC%9F"><span class="toc-text">你平时是怎么学习的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%8E%A5%E8%A7%A6%E5%89%8D%E7%AB%AF%E7%9A%84-%E4%B8%BA%E5%95%A5%E5%AD%A6%E5%89%8D%E7%AB%AF"><span class="toc-text">你什么时候接触前端的&#x2F;为啥学前端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%97%A0%E6%84%8F%E5%90%91offer"><span class="toc-text">有无意向offer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%95%86%E8%B7%9F%E8%81%8C%E5%95%86"><span class="toc-text">情商跟职商</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%8E%E5%B8%82"><span class="toc-text">城市</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B1%E5%A5%BD"><span class="toc-text">爱好</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%9F%E6%9C%9B%E8%96%AA%E8%B5%84"><span class="toc-text">期望薪资</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B6%E5%BA%AD-%E5%8D%95%E8%BA%AB"><span class="toc-text">家庭&#x2F;单身</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%9F%E6%9C%9B%E7%9A%84%E5%9B%A2%E9%98%9F"><span class="toc-text">期望的团队</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E7%8F%AD"><span class="toc-text">加班</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%91"><span class="toc-text">云</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E5%B9%B3%E5%8F%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9C%8D%E5%8A%A1%E7%B1%BB%E5%9E%8B"><span class="toc-text">云平台的三种服务类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%B1%BB%E4%BA%91%E4%BA%A7%E5%93%81%EF%BC%9A%E5%85%AC%E6%9C%89%E4%BA%91-amp-%E7%A7%81%E6%9C%89%E4%BA%91"><span class="toc-text">两类云产品：公有云&amp;私有云</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iPaaS%E5%92%8CaPaaS"><span class="toc-text">iPaaS和aPaaS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E8%87%AA%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-text">各自功能：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%81%8F%E9%87%8D%E7%82%B9%EF%BC%9A"><span class="toc-text">技术偏重点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-text">使用对象：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E8%82%A1"><span class="toc-text">八股</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6"><span class="toc-text">框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#React-vs-Vue-%E2%98%85"><span class="toc-text">React vs Vue ★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">模块化、组件化、工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96-1"><span class="toc-text">模块化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E5%8C%96-1"><span class="toc-text">工程化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96-1"><span class="toc-text">组件化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E5%A5%BD%E5%A4%84"><span class="toc-text">框架好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">计算机网络和浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">计算机网络体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-text">OSI七层模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP-IP"><span class="toc-text">TCP&#x2F;IP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BD%91%E7%BB%9C%E8%A6%81%E5%88%86%E5%B1%82%EF%BC%9F"><span class="toc-text">为什么网络要分层？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-text">网络通信</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0"><span class="toc-text">URL输入到页面展现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#URL"><span class="toc-text">URL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DNS%E8%A7%A3%E6%9E%90"><span class="toc-text">DNS解析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E2%98%85"><span class="toc-text">TCP三次握手 ★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E2%98%85"><span class="toc-text">TCP四次挥手 ★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP"><span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">HTTP状态码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP%E6%96%B9%E6%B3%95"><span class="toc-text">HTTP方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#HEAD"><span class="toc-text">HEAD</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#PUT"><span class="toc-text">PUT</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#DELETE"><span class="toc-text">DELETE</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GET-%E4%B8%8E-POST-%E2%98%85"><span class="toc-text">GET 与 POST ★</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F"><span class="toc-text">参数传递方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E4%B8%8D%E5%90%8C"><span class="toc-text">参数长度限制不同</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%92%8C%E5%B9%82%E7%AD%89"><span class="toc-text">安全和幂等</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8D%E5%90%8C%EF%BC%88%E4%BC%A0%E8%BE%93%E7%9A%84%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="toc-text">安全性不同（传输的角度）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%B8%8D%E5%90%8C"><span class="toc-text">缓存机制不同</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%B6%88%E8%80%97%E4%B8%8D%E5%90%8C"><span class="toc-text">时间消耗不同</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP%E5%A4%B4%E9%83%A8"><span class="toc-text">HTTP头部</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS"><span class="toc-text">HTTP和HTTPS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTPS%E4%BC%98%E7%82%B9"><span class="toc-text">HTTPS优点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86"><span class="toc-text">混合加密</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-text">数字证书</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95"><span class="toc-text">摘要算法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTPS%E8%BF%9E%E6%8E%A5"><span class="toc-text">HTTPS连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="toc-text">中间人攻击</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81ca%E8%AF%81%E4%B9%A6%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7"><span class="toc-text">浏览器如何验证ca证书的有效性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP-1-1%E3%80%81HTTP-2%E3%80%81HTTP-3%E6%BC%94%E5%8F%98"><span class="toc-text">HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3演变</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#HTTP-1-1"><span class="toc-text">HTTP&#x2F;1.1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#HTTP-2"><span class="toc-text">HTTP&#x2F;2</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#HTTP-3"><span class="toc-text">HTTP&#x2F;3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1"><span class="toc-text">跨域通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%BA%90-%E8%B7%A8%E5%9F%9F"><span class="toc-text">同源&#x2F;跨域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">跨域解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#JSONP%EF%BC%88JSON-with-Padding%EF%BC%89"><span class="toc-text">JSONP（JSON with Padding）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CORS"><span class="toc-text">CORS</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%90%86"><span class="toc-text">代理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Node%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-text">Node中间件代理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#React%E4%B8%AD%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86"><span class="toc-text">React中配置代理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">Nginx反向代理</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WebSocket"><span class="toc-text">WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie%E3%80%81sessionStorage%E3%80%81localStorage"><span class="toc-text">Cookie、sessionStorage、localStorage</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Cookie"><span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#localStorage-amp-amp-sessionStorage"><span class="toc-text">localStorage &amp;&amp; sessionStorage</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IndexedDB"><span class="toc-text">IndexedDB</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT"><span class="toc-text">Cookie、Session、Token、JWT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XSS%E5%92%8CCSRF"><span class="toc-text">XSS和CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#XSS"><span class="toc-text">XSS</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%98%B2%E8%8C%83%E6%96%B9%E6%B3%95"><span class="toc-text">常用防范方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CSRF"><span class="toc-text">CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#CSRF%E4%B8%8E-XSS-%E5%8C%BA%E5%88%AB"><span class="toc-text">CSRF与 XSS 区别</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1"><span class="toc-text">防御</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-UDP"><span class="toc-text">TCP UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#UDP"><span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP"><span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-text">TCP 协议如何保证可靠传输</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">TCP 如何实现流量控制？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">TCP 的拥塞控制是怎么实现的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ARQ-%E5%8D%8F%E8%AE%AE%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-text">ARQ 协议了解吗?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%81%E8%AE%B8%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E8%B5%84%E6%BA%90%E6%95%B0"><span class="toc-text">浏览器允许的并发请求资源数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E5%AE%9A%E6%9C%9F%E5%90%91%E5%89%8D%E7%AB%AF%E6%8E%A8%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-text">后端定期向前端推送数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">浏览器多个标签之间通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B"><span class="toc-text">性能检测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%B5%84%E6%BA%90%E6%9B%B4%E5%BF%AB%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%EF%BC%9F"><span class="toc-text">如何保证资源更快的加载速度？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%A7%86%E5%9B%BE%E6%9B%B4%E5%BF%AB%E7%9A%84%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BA%A4%E4%BA%92%EF%BC%9F"><span class="toc-text">如何保证视图更快的渲染和交互？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%B1%82%E9%9D%A2"><span class="toc-text">渲染层面</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%B1%82%E9%9D%A2"><span class="toc-text">交互层面</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#React%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BC%98%E5%8C%96-%E2%98%85"><span class="toc-text">React项目的优化 ★</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E9%87%8D%E6%96%B0render"><span class="toc-text">尽量避免重新render</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E5%87%8F%E5%B0%91%E8%A6%81%E6%B8%B2%E6%9F%93%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">尽量减少要渲染的节点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%B7%BB%E5%8A%A0%E9%A2%9D%E5%A4%96%E7%9A%84DOM"><span class="toc-text">避免添加额外的DOM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="toc-text">HTTP&#x2F;浏览器缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B"><span class="toc-text">缓存类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98%E3%80%81%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-text">强缓存、协商缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%8F%91%E5%B1%95"><span class="toc-text">缓存发展</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%B7%E6%96%B0"><span class="toc-text">刷新</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93"><span class="toc-text">浏览器解析渲染</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#script%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7"><span class="toc-text">script标签属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#async"><span class="toc-text">async</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#defer"><span class="toc-text">defer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-text">使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS"><span class="toc-text">JS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80"><span class="toc-text">语言</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AF%94"><span class="toc-text">其他语言对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB-vs-%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-text">基于类 vs 基于原型的语言</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-text">构造函数模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B-%E7%B1%BB-%E6%A8%A1%E5%BC%8F"><span class="toc-text">原型(类)模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%B8%B8%E7%94%A8%E4%BD%9C%E5%B0%81%E8%A3%85%E7%B1%BB%EF%BC%89"><span class="toc-text">混合模式（常用作封装类）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-text">原型链继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">借用构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-text">寄生组合式继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ES6%E7%B1%BB%E7%BB%A7%E6%89%BFextends"><span class="toc-text">ES6类继承extends</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Js%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88"><span class="toc-text">Js中的堆栈</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E5%8C%BA"><span class="toc-text">栈区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%E5%8C%BA"><span class="toc-text">堆区</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">垃圾回收机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-text">引用计数算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">标记清除算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%83%85%E5%86%B5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">常见内存泄露情况及解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%84%8F%E5%A4%96%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">意外的全局变量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#dom"><span class="toc-text">dom</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-text">事件监听</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">解决内存泄漏的数据结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1"><span class="toc-text">7+1</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%E2%98%85"><span class="toc-text">作用域与闭包★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81-%E2%98%85"><span class="toc-text">防抖&#x2F;节流 ★</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%B2%E6%8A%96"><span class="toc-text">防抖</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%9E%E7%AB%8B%E5%8D%B3%E9%98%B2%E6%8A%96"><span class="toc-text">非立即防抖</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E9%98%B2%E6%8A%96"><span class="toc-text">立即防抖</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8A%82%E6%B5%81"><span class="toc-text">节流</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text">时间戳</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8-1"><span class="toc-text">定时器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%AF%E9%87%8C%E5%8C%96-%E2%98%85"><span class="toc-text">柯里化 ★</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#let%E3%80%81const%E5%92%8Cvar%E2%98%85"><span class="toc-text">let、const和var★</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#var"><span class="toc-text">var</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#let"><span class="toc-text">let</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#const"><span class="toc-text">const</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E6%8C%87%E5%90%91%E2%98%85"><span class="toc-text">this指向★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call%E3%80%81apply%E3%80%81bind"><span class="toc-text">call、apply、bind</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E2%98%85"><span class="toc-text">事件循环★</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML-CSS"><span class="toc-text">HTML&#x2F;CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%8C%96%E2%98%85"><span class="toc-text">语义化★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#H5%E6%96%B0%E7%89%B9%E6%80%A7%E2%98%85"><span class="toc-text">H5新特性★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS%E7%9B%92%E6%A8%A1%E5%9E%8B-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E3%80%81%E5%9D%97%E5%85%83%E7%B4%A0%E2%98%85"><span class="toc-text">CSS盒模型 &#x2F; 行内元素、块元素★</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E7%9B%92%E5%AD%90-block-box-%E5%92%8C%E5%86%85%E8%81%94%E7%9B%92%E5%AD%90-block-box"><span class="toc-text">块级盒子 (block box) 和内联盒子(block box)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#inline%EF%BC%8Cblock%EF%BC%8Cinline-block"><span class="toc-text">inline，block，inline-block</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CSS%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">CSS盒模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%92%8CIE%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-text">标准盒模型和IE盒子模型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFC-%E6%B6%88%E9%99%A4%E6%B5%AE%E5%8A%A8%E2%98%85"><span class="toc-text">BFC&#x2F;消除浮动★</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E5%86%85%E9%83%A8%E6%B5%AE%E5%8A%A8"><span class="toc-text">包含内部浮动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E9%99%A4%E5%A4%96%E9%83%A8%E6%B5%AE%E5%8A%A8"><span class="toc-text">排除外部浮动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%96%E8%BE%B9%E8%B7%9D%E9%87%8D%E5%8F%A0"><span class="toc-text">外边距重叠</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Flex%E2%98%85"><span class="toc-text">Flex★</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-text">容器属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="toc-text">元素属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%E2%98%85"><span class="toc-text">居中布局★</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD"><span class="toc-text">水平居中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-text">垂直居中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-text">水平垂直居中</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#position%E5%AE%9A%E4%BD%8D-%E2%98%85"><span class="toc-text">position定位 ★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#margin%E4%B8%8Epadding-%E5%8C%85%E5%90%AB%E5%9D%97-%E2%98%85"><span class="toc-text">margin与padding 包含块 ★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7%E2%98%85"><span class="toc-text">CSS选择器优先级★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E6%9D%A1-%E2%98%85"><span class="toc-text">滚动条 ★</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-text">数据结构与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">常见数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-text">树结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-text">队列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-text">常见算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E2%98%85"><span class="toc-text">递归★</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-%E2%98%85"><span class="toc-text">快速排序 ★</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-text">二分法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">双指针</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/66c016fb.html" title="JVM"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/7.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="JVM"></a><div class="content"><a class="title" href="/posts/66c016fb.html" title="JVM">JVM</a><time datetime="2022-10-07T06:46:20.000Z" title="发表于 2022-10-07 14:46:20">2022-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ff54bd4f.html" title="JS垃圾回收"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/14.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="JS垃圾回收"></a><div class="content"><a class="title" href="/posts/ff54bd4f.html" title="JS垃圾回收">JS垃圾回收</a><time datetime="2022-10-07T03:01:02.000Z" title="发表于 2022-10-07 11:01:02">2022-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f7ede91d.html" title="Java基础"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/16.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="Java基础"></a><div class="content"><a class="title" href="/posts/f7ede91d.html" title="Java基础">Java基础</a><time datetime="2022-10-01T08:46:40.000Z" title="发表于 2022-10-01 16:46:40">2022-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f0caaae4.html" title="TS中那些奇怪的符号"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/4.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="TS中那些奇怪的符号"></a><div class="content"><a class="title" href="/posts/f0caaae4.html" title="TS中那些奇怪的符号">TS中那些奇怪的符号</a><time datetime="2022-07-10T03:12:48.000Z" title="发表于 2022-07-10 11:12:48">2022-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6155a9d6.html" title="Axios"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/8.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="Axios"></a><div class="content"><a class="title" href="/posts/6155a9d6.html" title="Axios">Axios</a><time datetime="2022-07-05T08:42:42.000Z" title="发表于 2022-07-05 16:42:42">2022-07-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By Leslie Waong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:""},null))},e=()=>{twikoo.getCommentsCount({envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))},n=(n=!1)=>{"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})};btf.loadComment(document.getElementById("twikoo-wrap"),n)})()</script></div><div class="aplayer no-destroy" data-id="6995412795" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="auto" data-autoplay="true" muted></div><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":0,"vOffset":0},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body></html>