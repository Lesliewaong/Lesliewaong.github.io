<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>央视 | Leslie Waong</title><meta name="keywords" content="前端 Java 空间光通信"><meta name="author" content="Leslie Waong"><meta name="copyright" content="Leslie Waong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="央视自我介绍面试官们好，我叫王吉晨，现在就读于北京邮电大学，是一名研三的学生，预计今年六月份毕业。下面我就介绍一下我的项目、实习和科研经历。 本科时，我基于Android平台实现了一个电子词典APP，其中词典的离线数据使用Python爬取并保存在SQLite数据库中，并基于Android Studio完成界面设计和功能实现，主要开发语言是Java，通过这个项目主要是积累了开发经验。 后来研究生阶段"><meta property="og:type" content="article"><meta property="og:title" content="央视"><meta property="og:url" content="https://lesliewaong.top/posts/9d34f1d1.html"><meta property="og:site_name" content="Leslie Waong"><meta property="og:description" content="央视自我介绍面试官们好，我叫王吉晨，现在就读于北京邮电大学，是一名研三的学生，预计今年六月份毕业。下面我就介绍一下我的项目、实习和科研经历。 本科时，我基于Android平台实现了一个电子词典APP，其中词典的离线数据使用Python爬取并保存在SQLite数据库中，并基于Android Studio完成界面设计和功能实现，主要开发语言是Java，通过这个项目主要是积累了开发经验。 后来研究生阶段"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/4.jpg"><meta property="article:published_time" content="2023-01-01T08:46:41.000Z"><meta property="article:modified_time" content="2023-03-21T14:58:51.026Z"><meta property="article:author" content="Leslie Waong"><meta property="article:tag" content="前端 Java 空间光通信"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/4.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg"><link rel="canonical" href="https://lesliewaong.top/posts/9d34f1d1"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"一年之内的产物",messageNext:"技术可能存在过期"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Leslie Waong",link:"链接: ",source:"来源: Leslie Waong",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"央视",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-03-21 22:58:51"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px");const a=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};a(),document.addEventListener("pjax:complete",a)})(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Leslie Waong" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">122</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li><li><a class="site-page child" href="/item/test/"><i class="fa-fw fa fa-star"></i><span> test</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/4.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leslie Waong</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li><li><a class="site-page child" href="/item/test/"><i class="fa-fw fa fa-star"></i><span> test</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">央视</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-01T08:46:41.000Z" title="发表于 2023-01-01 16:46:41">2023-01-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-21T14:58:51.026Z" title="更新于 2023-03-21 22:58:51">2023-03-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%9E%E6%8A%80%E6%9C%AF%E9%9D%A2/">非技术面</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>72分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="央视"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="央视"><a href="#央视" class="headerlink" title="央视"></a>央视</h1><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>面试官们好，我叫王吉晨，现在就读于北京邮电大学，是一名研三的学生，预计今年六月份毕业。下面我就介绍一下我的项目、实习和科研经历。</p><p>本科时，我基于Android平台实现了一个电子词典APP，其中词典的离线数据使用Python爬取并保存在SQLite数据库中，并基于Android Studio完成界面设计和功能实现，主要开发语言是Java，通过这个项目主要是积累了开发经验。</p><p>后来研究生阶段利用空闲时间系统学习了前端的相关知识，框架主要是学习了React。基于React自己做了一个后台管理系统的项目，通过这个项目熟悉了前后端分离的开发模式，以及模块化、组件化、工程化的开发理念。</p><p>去年暑期的时候，我在美团进行了实习，主要工作是基于组内的微前端研发平台，实现MBR报表的线上化，也就是负责实现MBR产品的前后台页面的展示与交互功能，通过这个项目熟悉了整个开发流程，包括需求分析、方案设计、代码开发，再到联调测试。</p><p>我的实验室的研究方向是自由空间光通信系统中，空间分集接收方案的研究与设计，主要是通过理论分析、仿真评估和离线实验相结合的方式对所提方案算法的有效性和可靠性进行验证，在这个方向下成功发表了一篇二区SCI，凭借这篇论文也是获得了去年的研究生国家奖学金。</p><p>我所投递的岗位是新媒体技术岗，因为我的专业是通信相关，并且学习和实践过一些计算机软件相关的工作，对于技术岗而言，不管是开发、运维还是其他工作，我应该都可以尽快地学习和上手；另外，本科的时候我也做过一些较为简单的视频剪辑并在平台上发布过，也算对自媒体有些了解。</p><p>我的经历大概就是这样。希望有机会能够加入贵公司!谢谢！</p><h2 id="HR"><a href="#HR" class="headerlink" title="HR"></a>HR</h2><h3 id="央视-1"><a href="#央视-1" class="headerlink" title="央视"></a>央视</h3><p>中央广播电视总台是中国全国性的媒体平台，也是全球最大的电视平台之一。中央广播电视总台下设多个电视台、广播电台和新闻网站，覆盖全国多个省市和地区，拥有丰富的新闻、文化、娱乐节目资源。在中国媒体行业中地位重要，其新闻报道具有权威性和影响力，同时也是推广和传播中国文化和价值观的重要平台。此外，中央广播电视总台还积极参与国际交流，推动中国文化走向世界。</p><p>在技术方面，中央广播电视总台也在不断创新和发展，尤其是在数字化技术、高清电视和移动多媒体传播方面取得了重要进展。在全球范围内，中央广播电视总台也是一流的现代化媒体机构之一。</p><h3 id="节目"><a href="#节目" class="headerlink" title="节目"></a>节目</h3><p>我认为，中央广播电视总台出品的节目大都具有很高的品质和水准，不仅展现了国内各个领域的最新发展和成就，也能够反映社会中各类人群的需求和关切，同时也能够展示中国传统文化的魅力和特色。</p><p>例如，中央广播电视总台策划制作的《舌尖上的中国》系列纪录片系列，真实地展现了中国各地美食的文化底蕴和历史背景，充分展现了中国独特的饮食文化和饮食哲学，获得了广大观众的热烈关注和好评。同时，中央广播电视总台还推出了一系列有深度、有温度、有影响力的新闻、财经和文化节目，这些节目不仅具有优秀的制作品质，也能够反映出中央广播电视总台在新闻报道、文化传承和社会服务等方面的专业水平和影响力。</p><p>当然，每个节目都无法做到完美，中央广播电视总台也存在着一些问题和挑战，例如在内容创新、观众群体覆盖、市场竞争中等方面的压力。但是我相信，中央广播电视总台具有强大的生产能力、专业的团队和丰富的资源，一定会不断推陈出新，为观众提供更多优秀的节目。</p><h3 id="新媒体技术"><a href="#新媒体技术" class="headerlink" title="新媒体技术"></a>新媒体技术</h3><p>我了解到，新媒体技术是当今信息化社会发展的重要趋势和方向，包括互联网、移动通信和数字电视等技术，能够帮助用户实现信息获取、娱乐等多种功能。在传媒领域，新媒体技术已经成为一个不可或缺的部分，与传统媒体技术相比，更加灵活、互动性更强、更加个性化和多元化，也提供了更多创新和发展机遇。</p><p>中央广播电视总台在新媒体技术的应用方面日益重视，在多个领域都开展了相关尝试，例如通过自建移动 App、微信公众号、微博等新媒体平台将优秀节目推向观众，并通过网上视频互动等形式增强观众参与感和娱乐性。同时，中央广播电视总台在直播、短视频、VR/AR等方面的探索也在不断深入。</p><p>另外，诸如5G等通信技术的发展也为新媒体技术做出重大贡献，相比3G和4G技术提供了更高的速度和更低的延迟，可以支持超高清视频传输和超大容量的数据传输，更好支持虚拟现实和增强现实等等。我所研究的自由空间光通信，在没有光纤等物理传输媒介的情况下，实现高速、高带宽、低延迟的数据传输，也可以在某些特定领域促进新媒体技术的发展。</p><p>新媒体技术不仅是互联网时代的产物，也是传统媒体发展的趋势。中央广播电视总台需要不断关注新的技术和媒体形式的发展，积极运用新媒体技术，满足观众的多元需求，强化自身的竞争力和影响力。</p><p>5G的基本原理是，它使用多种技术来实现更快的数据传输。这包括使用毫米波等电磁谱的较高频率，以增加在给定时间内可传输的数据量。此外，5G网络使用先进技术，如波束形成和MIMO，来提高信噪比，从而提供更可靠的连接。 5G还使用先进技术，如网络分片和载波聚合，以提高数据传输效率。这些技术使5G网络能够在同一时间内传输更多数据，从而实现更快的数据速率。</p><p>人工智能（AI）对新媒体技术有着重要的影响。AI可以更有效地处理大量的数据，从而使新媒体技术更加智能化。它可以分析出用户的偏好并实现更加精确的个性化推荐。此外，AI还可以提升用户的视觉体验，改善用户界面设计，增强语音识别功能等等。</p><p>GPT（Generative Pre-trained Transformer）是一种大型语言模型，它可以分析出新媒体技术中的大量数据，并根据这些数据生成人类语言模式，进而实现更加精确的个性化推荐。GPT可以更有效地分析新闻文章、社交媒体帖子和用户行为，从而帮助新媒体技术更好地满足用户的需求。它还可以改善用户界面设计，增强语音识别功能并提升用户的视觉体验等等。</p><h3 id="新媒体技术岗"><a href="#新媒体技术岗" class="headerlink" title="新媒体技术岗"></a>新媒体技术岗</h3><p>新媒体技术岗位主要负责开发和维护与新媒体相关的软件、平台和系统，以满足不断增长的数字化媒体需求。新媒体技术岗位是一个又新又潮流、技巧要求高、信息量大的职位。具体工作上需要与设计师、产品经理、运营人员等不同职能部门协同合作，并根据不同的业务需求进行不断的学习、创新及技术提升，提高编码效率，提高团队的协作，加强对于整个新媒体产品体系的理解和掌握，以便通过对媒体行业的相关理解，更好地实现常规业务需求和新技术应用。</p><p>新媒体技术岗需要具备以下能力素质：</p><ol><li>技能素质：具备扎实的技术基础，熟练掌握新媒体平台相关技术及工具，如网页设计、UI设计、PS、AI等，熟悉前后端技术，能够独立完成网站建设和维护，熟悉SEO等网络推广方法及实现。</li><li>内容创作能力：拥有良好的文学素养和敏锐的观察能力，能够快速理解项目需求，能够根据要求撰写高质量、有吸引力和富有感染力的文案和视觉内容，具备创意和营销思维，能够出色地完成宣传和推广任务。</li><li>团队协作能力：具备优秀的沟通能力和协作能力，能够与其他团队成员高效协作，善于解决问题、分享想法，能够快速适应项目组的工作流程和工作环境。</li><li>数据分析能力：能够熟练运用各种数据工具进行数据分析，了解用户行为，掌握市场趋势，根据数据结果调整和优化相关运营策略。</li><li>学习能力和创新思维：新媒体产业发展迅速，需要时刻更新学习、跟进新技术趋势，不断提升自身技能和能力；具备创新思维，在解决问题和开展业务过程中，能够发掘新的创意和想法，创新能力和思维能力都要强。</li></ol><p>总之，新媒体技术岗需要具备技能素质、内容创作能力、团队协作能力、数据分析能力以及学习创新能力等多方面的能力素质。</p><h3 id="B站和央视"><a href="#B站和央视" class="headerlink" title="B站和央视"></a>B站和央视</h3><p>B站和央视是两个面向不同用户群的组织，两者的优缺点也有所不同。</p><p>首先，从规模和影响力角度来看，央视是国内最大的传媒平台之一，而B站则是中国最大的弹幕视频分享网站之一，拥有庞大而忠实的年轻用户基础，主要以年轻一族为主。</p><p>从优点方面来看，央视的优势在于内容丰富、覆盖面广、权威性强。央视拥有国内最丰富的新闻、纪录片和传统文化节目资源，并与国内各大电视台和机构紧密合作，可以提供高质量、多样化的内容，受到全国观众的广泛喜爱。然而，央视的受众群体以年长用户为主，与青少年年轻化娱乐需求欠缺相符的内容。</p><p>而B站的优势在于面向年轻人、内容生态化和社交化。B站的用户规模极大，拥有大量的年轻用户，这些用户主要是年轻人和高校学生。B站聚集了大量的原创视频创作者，内容主题涵盖了各种兴趣爱好，从动画、游戏到互动娱乐等多领域内容，能够满足不同年龄段和兴趣爱好的用户。同时，B站鼓励创作者与用户进行共创、交流和互动，形成了一个良好的社区氛围，很好的发挥了社交媒体的优势。</p><p>当然，不同组织也有各自的缺点。央视拥有大量经典的文化资料，但是他的内容限制在对年长观众对艺术文化类题材的品味。B站虽然面向年轻人，但也有视频时长短、质量不高、涉黄涉恶等一系列问题。</p><p>总之，B站和央视都是各有特色的优秀传媒平台，各有其独特的优势和限制。我们可以从中学习到各种成功和失败的经验教训，不断优化和改进自己的工作模式和流程，提升组织实力和竞争力。</p><h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><p>短期规划可以大体从三方面讲：</p><p><strong>业务方面：</strong></p><ul><li>尽快熟悉业务脉络和逻辑，加深组内平台和常用工具的理解与使用，快速融入工作氛围并适应工作节奏。</li><li>多关注业务的发展，弄清楚为何这么做，如何做的更好。视野不只停留在业务的开发上，更要对业务的落地、性能、效益进行思考。</li></ul><p><strong>技术方面：</strong></p><ul><li>能力不只停留在已有的技术上，更要对新知识保持热情与追求，不断拓展技术的广度并持续钻研技术的深度，提升自己的行业竞争力。</li><li>如果有编写代码相关工作的话，提升编写代码的鲁棒性和可靠性，当出现BUG时，能快速定位问题，主动担责，并尽快修复。</li></ul><p><strong>软实力：</strong></p><ul><li>不要总是埋头做事，沟通表达能力要多加练习，平时注意反思总结，每天/周抽出时间进行个人的沉淀与记录。</li><li>提升多方协作能力，能够对项目需求合理拆解，协调多人保质按时交付任务。</li><li>协调好生活与工作的平衡，合理安排时间，确保工作有序无误地开展，培养自己的耐心并提高自己的抗压能力。</li></ul><p>从长远来看，我觉得需要对所处行业和工作内容有了一定了解和认知后，再来结合自身情况进行合理规划。</p><h3 id="时间紧任务重-压力"><a href="#时间紧任务重-压力" class="headerlink" title="时间紧任务重/压力"></a>时间紧任务重/压力</h3><p>下面我要讲的是我实习期间的项目吧，由于当时公司有人离职，有个比较大的项目交到了我所在的组，组内人手又不够，虽然作为实习生，但我也要尽快参与到项目的开发实现上。应对这种时间紧任务重的情况，我采取了以下措施：</p><ol><li>制定计划：首先，我会评估任务的复杂程度和完成时间，并制定一个详细的计划，确保按照最紧密的时间表按时交付任务。</li><li>优先级排序：针对任务的紧急程度和重要性，我会优先完成最紧急和最重要的任务。这能确保在有限的时间内完成重要的工作。</li><li>增加工作时间：如果必要的话，我会增加工作时间，同时调整生活和工作的平衡，以确保任务及时交付。</li><li>寻求协助：如果在任务的处理过程中遇到困难，无法独立完成任务，我会主动请求协助，与同事和上级领导沟通合作，以共同完成任务。很多前辈的经验可以帮助快速定位问题并找到解决方案。</li><li>进行迭代：在完成任务的过程中，我会进行适时的迭代，并根据实际情况调整进度和修改计划，以应对随时发生的事情并确保按时交付。</li></ol><p>最后，我们团队也在预期时间完成了工作，也得到了领导的认可。</p><h3 id="合作"><a href="#合作" class="headerlink" title="合作"></a>合作</h3><p>下面我要讲的是我实习期间的项目吧，由于当时公司有人离职，有个比较大的项目交到了我所在的组，组内人手又不够，虽然作为实习生，但我也要尽快参与到项目的开发实现上。为了确保项目能够高质量、高效地完成，我们团队内部进行了充分的沟通和协调，并与相关部门建立了紧密的协作关系。</p><p>在项目的前期阶段，我们首先收集并分析了外部需求和内部能力的情况，制定了一个详细的计划和时间表，便于不同部门协调和合作。</p><p>在项目的中期，由于需求变更和其他外部要素，我们需要及时调整计划和时间表，并在各方之间积极沟通协调，使得项目能够顺利推进，并没有影响到项目的进度和质量。并且对于新要素的出现，我们也对团队进行了相应的加强和拓展，确保能够满足新的需求并达到预期效果。</p><p>最终，由于团队内部的密切合作和跨部门的良好协作，项目高质量、高效地完成，并获得了领导的认可和好评。</p><h3 id="打破常规，新颖的想法-有成就感的事"><a href="#打破常规，新颖的想法-有成就感的事" class="headerlink" title="打破常规，新颖的想法 / 有成就感的事"></a>打破常规，新颖的想法 / 有成就感的事</h3><p>下面我想讲的是我研究生刚入学做实验的事情。</p><p>由于我本科专业是电子信息，研究生入学后的方向是光通信相关，所以我的基础是有欠缺的，而且我的老师让我去通过实验验证一位博士提出的方案，然而这位博士在我入学前就毕业了，所涉及的OFDM方向也没有多少人熟悉，所以我的实验进展非常不顺利。</p><p>后来我就转换思路，老师真正想让我验证的是通信算法的有效性，而OFDM只是一个应用场景，因此我决定把这个方法转移到实验室更多人熟悉的单载波系统上，一方面很多问题我可以请教师兄师姐，另一方面它确实比OFDM要容易实现。因此我就针对单载波系统对算法进行改进和验证。在这个过程中，还遇到的一个问题，原方案使用的空间分集搭建非常复杂，而且实验器材也不够，我就从原理上分析，通过时间分集对空间分集进行等效，可以获得相同的效果。最终经过我的不断改进与尝试后，完成了这个实验。凭借这个实验，我也成功发表了一篇二区SCI论文，并获得研究生国奖。</p><h3 id="原有计划发生重大变化的经历。"><a href="#原有计划发生重大变化的经历。" class="headerlink" title="原有计划发生重大变化的经历。"></a>原有计划发生重大变化的经历。</h3><p>这个我讲一下实习过程中的经历吧。在离测试前一两周的时候，我们项目的产品经理对需求进行一些重大的变更，还提出了新需求，导致有延期风险。</p><p>当得知这些事情后，我首先与产品、后端及组内同事积极沟通，协调需求变更。</p><p>对所提需求进行了分类，对于必须实现的需求，比如管理后台目录树的编辑与页面关联的需求必须实现，但前期PRD对这方面描述不完善且设计不合理，经过积极与后端、产品讨论对齐尽快提出可行的方案并加以实现；</p><p>对于非必须实现且不合理的需求，与产品说明需求的不合理性及实现成本，尽可能取消这类需求或进行更改。</p><p>最后在我们大家的共同努力下，如期完成了工作。</p><h3 id="出现分歧"><a href="#出现分歧" class="headerlink" title="出现分歧"></a>出现分歧</h3><p>工作中遇到分歧的是在所难免的。</p><p>我会尽量站在对方的⻆度去理解这个问题，首先审视一下自己的认识有没有局限。</p><p>如果发现我的观点没有问题，那我会在坚持我最主要原则的前提下，多通过一些策略性的沟通方式，比如，多对对方的观点、付出的努力、观点的价值表示认可，然后阐述我自己考虑问题的出发点是什么，以此来争取对方的理解和支持。</p><p><strong>一句话总结：理解分歧，坚持底线，柔性解决。记住，体现态度！</strong></p><h3 id="面临的复杂问题，如何快速定位问题、提出解决思路的。"><a href="#面临的复杂问题，如何快速定位问题、提出解决思路的。" class="headerlink" title="面临的复杂问题，如何快速定位问题、提出解决思路的。"></a>面临的复杂问题，如何快速定位问题、提出解决思路的。</h3><p>这里我以实习中项目遇到的问题为例。</p><p>像我们做开发的经常会遇到代码bug，当时我们做的系统有ST环境导航切换白屏的问题，首先了解问题的全貌。明确问题是什么，问题的原因和影响，以及目前存在的限制因素等相关信息。这样可以让我们更清楚地理解问题，并避免在解决问题时走弯路。接下来就是将更大的问题划分为更小的部分，形成一个更清晰的问题列表。这可以帮助我们更好地理解问题的复杂性，便于我们更快地找到解决方案。然后我就将问题定位到echarts可视化图标库上。</p><p>收集问题相关的所有信息，并与相关人员沟通交流。将收集到的信息综合起来，形成一个完整的问题概述。以此为基础，进行创新思考，寻找解决问题的思路。这时我们可以运用各种专业知识和实际经验，寻找相关解决办法。最后，我们可以针对感觉可行的思路进行方案的评估和优化。通过请教组内同事，才发现可视化图标库在组内微前端平台上不兼容导致，通过查阅资料和实践，我们发现这个问题只会在切换页面时触发，因此可以通过错误边界组件捕获到错误可将原组件卸载，最终解决了这个问题。</p><h3 id="优缺点-竞争力"><a href="#优缺点-竞争力" class="headerlink" title="优缺点 竞争力"></a>优缺点 竞争力</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>乐观开朗，乐于助人，适应能力强，不管学校还是公司，都能够与身边的人愉快相处。</p><p>技术视野开阔，喜欢钻研，具有良好的学习能力，热爱编程，对业界新技术敏感，开拓创新意识强，能保持不断进取的精神。像平时经常会在B站看一些学习或者技术类的视频，也会经常浏览知乎、掘金、包括一些个人的博客论坛网站，丰富自己的视野，如果是比较新的技术，可能直接去看一些国外的网站或文章会收获更多。</p><p>注重团队合作，有着强烈的责任心和高度执行力。</p><p>抗压能力还算可以，应对实验室或公司中时间紧任务重的情况，能够从容进行任务的分级与梳理，积极沟通协调，同时调整生活<br>和工作上的平衡，力争每次都能按时保质地交付手中的任务。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>沟通能力还是需要进一步提高，在之前实习过程中，从最开始不好意思开口问，到后来有不懂的地方及时发问，并能与产品、后端及组内同事保持良好沟通，共同完成项目的开发。但沟通交流本身就是一门学问，需要不断磨练与提高，自己在这方面还是有很长的路要走。</p><p>提升多方协作能力，能够对项目需求合理拆解，协调多人保质按时交付任务。尽量提高自己的一个管理或者领导能力，树立大局观，不要总是埋头做事，平时注意反思总结，每天/周抽出时间进行个人的沉淀与记录，这样之后才能走得更远。</p><h3 id="你什么时候接触前端的-为啥学前端"><a href="#你什么时候接触前端的-为啥学前端" class="headerlink" title="你什么时候接触前端的/为啥学前端"></a>你什么时候接触前端的/为啥学前端</h3><p>本科时候做词典APP，里面离线数据是通过爬虫获取的，所以对html有了一些了解，包括安卓开发的XML布局，其实也跟前端比较类似。在我看来，学习前端是一件很有意思的一件事，随着我学习进度的增加，慢慢的，我发现了前端所做的都是用户可以最直观感受和体验的，也是最能让开发者感受到成就感的。</p><p>当然最早学前端，也因为它入门更容易，但随着学习深入就会发现现在的前端已经不是原先的切图仔，如果把前端狭义的理解为做页面，那天花板当然低了，但对应的，后端也可以被理解为 CRUD，天花板也很低。这时候如果把数据库 AI 这些扯进后端范畴，那么广义的前端也应该包含一切和交互相关的内容，比如网络资源优化、自动化部署、交互体验研究、设计和开发协作、跨平台渲染引擎、字符排版、甚至浏览器本身就是前端范畴。</p><p>当然，前端也不是归宿，后端语言像nodejs或其他也要学习，语言永远只是工具，重要的是开发的思想。另一方面，技术是需要给业务赋能，所以想走的更远，只学技术也不够。</p><p>前端的工程体系难就难在庞杂，链路长，环节多，而且和许多其他领域有交叉（比如网络、运维、编译器、图形学、人机交互理论、PL/DSL 设计），吃透一个环节的难度确实不难，但作为大厂的前端负责人需要规划整合这些东西，我是觉得天花板一点也不低。</p><h3 id="城市"><a href="#城市" class="headerlink" title="城市"></a>城市</h3><p>我的家乡是山东济南，济南作为山东省会，又是一座历史悠久的文化古城，同时风景优美，有大明湖、千佛山、趵突泉等著名景点，其中泉水最为出名，因此又叫做泉城。另外，济南的气候也非常宜人，老舍也曾写下济南的冬天，并在语文课本中为大家熟知。济南人也非常厚道淳朴、热情好客，非常欢迎大脚来济南做客。这就是我的家乡济南。</p><p>像北京这种大城市虽然生活成本偏高；但对个人来讲，无论是薪资水平、发展和上升空间相较于小城市和县城还是高不少。另外，很多曾经包括现在的同学都留在了北京，没事还能一起聚餐玩一玩，生活圈子可能会更广一些。</p><p>大城市就是工作机会多、发展好等等，小城市就是离家近、消费低等等。</p><p>北上深仍旧是薪资高地，杭州紧随其后，硕士平均薪资杭州甚至排第二。</p><p>值得注意的是，<strong>西安是北方城市里北京以外唯一上榜城市</strong>，虽然时不时被唱衰，但如果想留在北方，又觉得北京生活压力大，西安确实是个不错的选择。</p><h3 id="爱好"><a href="#爱好" class="headerlink" title="爱好"></a>爱好</h3><p>关于爱好的话，我平时会和朋友们一起打篮球、打羽毛球，这样不仅会锻炼身体，也能促进和朋友们的感情；本科阶段我也做过B站的up主，上传过一些自己剪辑的视频，在娱乐的同时也相当于增加了一项技能；当我独自一个人的时候，喜欢看动漫、影视剧、听音乐或打游戏等来放松下自己，有时候也会跟网上的一些美食博主学习做饭。</p><h3 id="家庭-单身"><a href="#家庭-单身" class="headerlink" title="家庭/单身"></a>家庭/单身</h3><p>家是在一个普通小县城，感觉相比大城市的平台、工作机遇和发展前景还是差很多，因此想在大城市工作感受下；家里父母都是普通打工人，但家庭氛围很和睦，也很重视教育，父母也都支持我的决定。目前没有女朋友，但我觉得对找工作可能不是一件坏事，我可以只考虑自身情况去选择工作地点等等。</p><h3 id="加班"><a href="#加班" class="headerlink" title="加班"></a>加班</h3><p>对于加班，我的个人看法是需要视具体情况而定。如果加班是因为紧急情况、业务需求或临时意外事件，那么我认为在必要的情况下可以适当加班来保证项目进度和质量。但是，如果加班成为一种常态，不仅影响员工身心健康，还会降低工作效率和创造力，甚至导致员工过度劳累和职业倦怠，从而不利于团队整体发展。因此，对于加班，我认为应该采取有效的措施来避免或减少加班的情况，比如合理规划工作计划，提高工作效率，合理分配工作任务，并保证员工能够获得充分的休息和放松时间。这样不仅有助于员工的身心健康，也可以提高员工的积极性和工作效率，从而为公司创造更多的价值。</p><h2 id="科研"><a href="#科研" class="headerlink" title="科研"></a>科研</h2><p>随着全球信息化的快速发展，人们对高速率、大容量和高安全性的无线通信的需求不断提高。相比传统的射频（Radio-frequency, RF）通信系统，自由空间光（Free-space Optical, FSO）通信系统凭借其高带宽、低功耗和免频谱许可等优势受到广泛关注。但FSO通信系统的性能受不可预测的大气条件影响，如大气吸收、散射和湍流等。其中，大气湍流引起的光强闪烁、相位波动和光纤耦合效率起伏等影响会严重恶化链路性能，并可能导致链路中断。分集作为一种强大的湍流抑制技术被广泛应用于FSO通信系统中。</p><p>面向未来FSO通信系统的发展趋势，针对FSO通信系统中大气湍流导致的通信质量恶化、功率预算紧张等问题，并结合大气信道特点，设计基于空间分集技术的PM-MQAM-FSO通信系统方案和相关DSP损伤补偿算法，来抑制大气湍流效应并提高接收机灵敏度。本文采用理论分析推导、数值仿真评估和离线实验验证相结合的方法，对所提系统方案和相关的DSP损伤补偿算法进行了全面的可行性和有效性验证。</p><p>PM-MQAM-FSO空间分集接收系统性能研究。该章节首先介绍FSO通信系统链路中的各种损耗并进行估算，并对模拟大气湍流效应的两种模型进行了分析和仿真对比。最终采用相位屏模型搭建了基于光纤耦合的PM-MQAM-FSO空间分集接收系统，并从合并方式、湍流强度、传输距离和接收孔径等方面对光纤耦合空间分集接收系统的性能进行了仿真研究，验证了空间分集接收技术的有效性和可靠性。</p><p>PM-16QAM-FSO空间分集接收系统中分集支路相位校正算法研究。首先对空间分集接收方案进行信噪比的理论分析，提出了基于最优支路分块相位校正算法以补偿支路间的相对相位差，并对所提方案的计算复杂度进行了分析比较。通过40Gbps PM-16QAM-FSO空间分集接收仿真平台对所提方案进行了全面的数值仿真分析与讨论，同时在离线实验平台上对所提方案进行了验证。</p><p>PM-MQAM-FSO空间分集接收系统中帧同步与频偏估计联合处理算法研究。首先介绍了训练序列的结构设计，以及帧同步和频偏估计联合处理算法的原理阐述，并对所提算法的复杂度进行分析和对比。通过搭建10Gbaud PM-MQAM-FSO空间分集接收仿真系统对所提方案的有效性和可靠性进行了验证。</p><h2 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>MBR系统开发，支撑MBR平台一期需求页面搭建</strong></p><p>平台：基于微前端一体化研发平台，支撑MBR（Monthly Business Reviews）产品一期需求页面搭建，主要对其前后台页面展示及交互能力的可用性负责，技术栈为React+TypeScript+MTD。</p><p>产品定位：面向B-Team以及管理层，实现餐饮SaaS MBR报表线上化，实现商分提效。</p><p>短期目标：MBR平台一期前后台页面开发上线，实现MBR核心指标线上化。</p><p>工作成果及收获：</p><ul><li><p>完成MBR前台和管理后台页面需求开发，主要完成页面整体布局、文件下载、目录树维护（增删改节点、节点关联页面等）、路由拦截和页面埋点等功能实现，并在泳道环境和ST环境的部署与发布。第一次参与较大型且周期较长的业务项目开发，熟悉了整个开发流程，从需求分析、方案设计、代码开发，再到联调测试，同时能够独立地进行方案设计与开发实现；沟通、合作和抗压等软实力得到提高，能与产品、后端及组内同事保持良好沟通，共同完成项目的开发。</p><ul><li><p>参与MBR三端评审，针对MBR平台一期需求完成方案调研与设计，主要对富文本编辑器和树形控件进行调研与选型，并对PRD中的各项需求进行分析设计。</p></li><li><p>完成MBR前后台页面需求开发，基于steamer平台将MBR前台和管理后台分别创建一个业务模块进行开发。前台页面主要完成页面整体布局、目录树导航（翻页、面包屑关联等）开发、页面动态渲染、页面部分组件（负责人卡片、富文本组件、无权限页面、文件下载页面等）开发；后台页面主要完成页面整体布局、目录树维护（增删改节点、节点关联页面、不同类型节点的功能区分等）、路由拦截等。</p></li><li><p>将请求发送、UI组件库这类公共服务（组件）发布为服务模块供业务模块使用，并在Shepherd网关编写mock接口进行本地测试。</p></li><li><p>前后台业务模块与服务模块的联调、构建与发布，并协助指导外包同学进行开发。</p></li><li><p>页面埋点、前后端联调、泳道环境和ST环境的部署与发布。</p></li></ul></li></ul><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p><strong>业务方面：</strong></p><ul><li><strong>第一次从零开始做团队项目，不知道如何下手以及估算排期。</strong></li></ul><p>解决：在mentor引导下，针对需求进行方案调研与设计，确定好可以实现需求的合适的组件库。对于开发流程，首先对整个开发过程进行拆分例如这个项目，前台展示页面更重要优先级最高，再针对页面UI进行组件层级的拆分，每一个组件下又可以根据不同的功能点确定拆分成更小组件还是组件内通过写一个函数来实现等等，整个开发还是以先实现静态页面，再通过state等实现数据展示交互功能，这样从整体到部分再到细节，就能梳理出大致的开发流程以及估算合适排期。</p><ul><li><strong>产品对需求进行变更或提出了新需求，导致延期风险。</strong></li></ul><p>解决：与产品、后端及组内同事积极沟通，协调需求变更。首先对所提需求进行分类，对于必须实现的需求，如管理后台目录树的编辑与页面关联的需求必须实现，但前期PRD对这方面描述不完善且设计不合理，经过积极与后端、产品讨论对齐尽快提出可行的方案并加以实现；对于非必须实现且不合理的需求，与产品说明需求的不合理性及实现成本，尽可能取消这类需求或进行更改。</p><p><strong>技术方面：</strong></p><ul><li><p><strong>功能性问题</strong>：开发经验、博客论坛、谷歌搜索等</p><ul><li><p>目录树维护（增删改节点、节点关联页面、不同类型节点的功能区分等）：UI库的树组件一般不支持可编辑，因此需要二次开发，另外项目要求对不同层级的节点编辑要求有区别，比如有子节点父节点不能删除、父节点不能挂页面等，除此之外，编辑完后怎么像后端发请求保存。我的做法是封装一个递归遍历所有节点的函数，根据传参实现对节点不同的操作，弹出框和编辑按钮也可以根据不同的类型进行一部分的复用，向后端传参这里有两种方式，一种每进行一次操作发请求保存，但由于设计到拖拽节点等操作，我需要时刻拿到对应节点的位置，后端也需要对拿到数据进行处理，另外，每更改一次前台页面的数据就相当于变化一次；另一种方案，不管增删改还是关联页面，只要不点击保存就不向后端请求，点击保存，将整棵树的数据传给后端，点击取消则重新获取上一次的数据，为了防止不保存就离开或关闭页面，还要进行路由拦截。</p></li><li><p>无刷新修改url：需求是点击某个节点或翻页，内容区局部刷新，路由地址也要变化，最早想到是用路由的param参数，但内容区组件其实是固定的，只是根据请求的数据进行渲染，用路由意义不大；因为内容区可以根据react的重新渲染机制，只要state或props变更就进行对比和重渲染，路由地址可以直接用History.pushState()/replaceState()来更改。但这里面要注意react的浅比较和key的使用。</p></li><li><p>请求封装、下载</p><ul><li><p>请求响应拦截器</p><ul><li><p>请求成功，业务状态码200，解析result给我，我不想一层一层的去判断拿数据</p></li><li><p><strong>http请求200， 业务状态码非200，说明逻辑判断这是不成功的，那就全局message提示服务端的报错</strong></p></li><li><p><strong>http请求非200， 说明http请求都有问题，也全局message提示报错</strong></p></li><li><p>http请求或者业务状态码<code>401</code>都做<strong>注销</strong>操作</p></li></ul></li><li><p>全局的loading配置, 默认开启，可配置关闭</p></li><li><p>两个请求接口实现异步下载</p><p>由于要下载的数据，经常会改动，所以每次下载都要重新生成文件。</p><p>第一个请求接口用来生成对应excel。</p><p>第二个请求接口用来获取下载列表，含有文件信息、下载地址，以及文件当前状态等。</p><p>通过轮询的方式，判断所有文件状态并在前端更新渲染，下载中的用loading，下载完成显示下载按钮（a标签）</p></li></ul></li><li><p>展示 滚动条、图片、grid</p></li></ul></li><li><p>平台基建/团队技术栈问题</p><ul><li><p>echarts等引起的ST环境导航切换白屏（removeChild） 错误边界 部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，不会渲染那些发生崩溃的子组件树，捕获错误，由于我们的bug是在路由跳转才会产生，因此错误边界组件捕获到错误可能立刻被卸载，因此并没有输出错误原因，而是直接让这个错误消失了。</p></li><li><p>组内的开发平台不熟悉，导致开发中经常遇到瓶颈，如样式不生效、构建发布失败和服务模块没有成功引入等。</p><p>解决：一方面，学习组内的wiki文档或者去学城搜索，很多问题别人已经遇到并解决过，同时可以结合之前别人的代码进行比对，排查原因并解决；另一方面，多向mentor和组内同事请教，他们的开发经验可以帮助快速定位问题并找到解决方案，甚至有些问题别人一两句话就能搞定，靠自己则会浪费过多时间。因此需要权衡问题的紧急程度，争取在不耽误项目排期的情况下快速定位问题并解决。</p></li><li><p>新技术栈如TypeScript不熟悉。</p><p>解决：首先集中时间对TypeScript的基础进行整体学习，同时结合组内之前的代码学习TypeScript在React的使用方式，在后续开发中不断完善编码规范，遇到报错可以去StackOverflow等网站查询他人的解决方法。</p></li></ul></li></ul><h3 id="收获与不足"><a href="#收获与不足" class="headerlink" title="收获与不足"></a>收获与不足</h3><p>通过上述项目与工作的锻炼，以及与mentor及组内同事的交流和学习，我得到了以下收获：</p><p><strong>业务方面：</strong></p><ul><li>对于业务理解有了提升，逐渐开始理解新需求的背景和目标，并能针对业务需求进行任务拆分。</li><li>第一次参与较大型且周期较⻓的业务项目开发，熟悉了整个开发流程，从需求分析、方案设计、代码开发，再到现在的联调测试，同时能够独立地进行方案设计与开发实现。</li></ul><p><strong>技术方面：</strong></p><ul><li>学习了各种新的技术栈，对公司和组内的各项基建更加熟悉。</li><li>代码能力得到了成长，能够独立完成需求的开发以及BUG的定位与修复。同时，代码编程风格得到优化，代码格式逐渐统一与规范。</li></ul><p><strong>软实力：</strong></p><ul><li><p>沟通能力得到了提高，从最开始不好意思开口问，到现在可以有不懂的地方及时发问，并能快速对齐需求，与产品、后端及组内同事保持良好沟通，共同完成项目的开发。</p></li><li><p>合作意识提高，由于第一次参与团队项目，从最开始只顾自己开发，到现在能够及时沟通进度与存在问题，并互相帮助并提供解决方案。</p></li><li><p>抗压能力得到提升。</p></li></ul><p>反思不足：</p><p><strong>业务方面：</strong></p><ul><li>业务理解还停留于表层，经常被动接受并消化产品传递来的信息而无法很好的反馈。</li><li>对业务的远瞻性和敏感度不足，相对模糊的需求没有尽早明确，导致对开发耗时及排期估算不准确。</li><li>方案设计不够完善，例如组件库的选择只考虑是否能够完成相应需求以及当前是否在维护，没有与组内通用的组件库保持一致，导致后续重构的风险。</li></ul><p><strong>技术方面：</strong></p><ul><li>技术涉猎单一且固定，代码编写水平依然需要进一步提高，同时对React等技术栈底层原理还不够深入。</li><li>技术设计水平还有待提高，在开发过程中出现过设计不够合理的情况，导致代码需要重构。</li><li>对组内平台的底层原理不够了解，遇到样式或功能bug不能及时定位。</li></ul><p><strong>软实力：</strong></p><ul><li>当多任务并行时，心态会比较急躁，时间安排不合理，导致某段时间过于疲劳。</li><li>沟通表达能力还是有所欠缺。</li><li>写文档的能力有待提高，同时由于时间安排不合理，有时做了很多事情，来不及总结与整理。</li></ul><h3 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h3><p><strong>一个中大型项目</strong> = <strong>多个独立功能模块组合</strong></p><p>趋势：整体项目集中式 -&gt; 项目内组件化 -&gt; 独立组件化</p><ul><li><p>更快的页面加载速度</p><ul><li><p>所有业务 vendor + 一个业务异步chunk vs 宿主容器 + 一个业务模块的依赖；</p></li><li><p>举例：进入首页时可能不需要加载 echart</p></li></ul></li><li><p>更小规模的前端代码，维护成本更低</p><ul><li>大型项目 -&gt; 一组小型模块（数十 MB -&gt; 数百 KB，数万的模块 -&gt; 几十模块）</li></ul></li><li><p>更专业的分工，支持多个团队并行开发多个独立维护的模块</p><ul><li>例如（订单管理、仓储管理、人员管理… 等功能模块分离，独立维护）</li></ul></li></ul><p><strong>微前端结合 DevOps 的一站式研发解决方案是不错的选择</strong></p><p><strong>微前端 = 研发标准 + 研发工具 + 微前端框架 + 研发平台</strong></p><p><strong>DevOps = 持续集成 + 质量管控 + 版本产物 + 发布工具 +运营工具</strong></p><p><strong>微前端 + DevOps = Steamer</strong></p><p>终端端研发方案 + 终端端研发流程平台 = 一站式研发解决方案</p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>应用：</strong></p><p>一个应用对应一个<strong>单页应用（SPA）</strong>，如一个运营后台系统就是一个应用。</p><p><strong>业务模块：</strong></p><p>一个业务模块相当于单页应用中的一个页面（目前是<strong>页面</strong>，以后可能会细化成为页面中的<strong>组件</strong>）。</p><p>是 Steamer 中的最小单元，它可以独立迭代发布。基本形态是一个组件，对标 React/Vue 等主流框架中的组件。</p><p>由于组件的灵活度范围较大，在业务可以根据业务场景扩展支持子应用（多页面）、单一路由页面、局部组件 3 种场景。</p><p>业务模块在平台中独立存在，所以在<strong>代码隔离</strong>和组织形态上可以有比较高的灵活度：</p><ul><li>业务模块独立 Git</li><li>按照业务相关程度多个业务模块再统一 Git</li></ul><p>微前端方案中的基本独立维护单元，可以是业务组件、页面路由或者是一个独立子应用；一般推荐粒度为页面路由。</p><p><strong>服务模块（Service）：</strong></p><p>在一个业务模块中可能会使用到一些公共的业务组件或者公共方法，由于这些组件和方法可能并不会被所有的业务模块所引用，在steamer的技术框架中，它们就被抽象成了一个个的服务模块来被业务模块引用。</p><p>简而言之，<strong>服务模块是被部分业务模块所共用的组件、方法等</strong>。</p><p><strong>宿主容器模板（简称模板）：</strong></p><p><strong>宿主模板对业务模块进行路由管理，并提供业务模块间共享的功能。</strong></p><p><strong>宿主容器</strong> 作为承载业务模块的容器（类似于 App与操作系统），我们将 <strong>宿主容器</strong>分为两个部分，Container 是提供基础 UI 布局、前端框架、路由等基础现代前端应用的视图骨架容器；Runtime 是一个动态组件执行和挂载的渲染执行 SDK，内部也会集成模块网络通信、数据存储 API、性能和异常监控、执行沙盒隔离等基础能力。</p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="Android词典"><a href="#Android词典" class="headerlink" title="Android词典"></a>Android词典</h3><p>本文使用Java编程实现一款基于Android平台的电子词典，词典数据借助Python的Requests库和XPath进行内容的获取。</p><p>该电子词典主要实现五大功能：注册登录、单词功能、句子功能、学习功能和娱乐功能。单词功能实现主要借助SQLite数据库进行单词释义等内容的查询；句子功能主要通过调用API或SDK实现；学习功能主要指生词本和内嵌网页，生词本功能使用了MVVM的架构模式；娱乐功能则是影视金句的轮播图。制作一款电子词典APP不但具有重要的实用价值，而且对提高自己的编程能力、分析和解决问题的能力具有重要作用。</p><h4 id="单词数据的爬取"><a href="#单词数据的爬取" class="headerlink" title="单词数据的爬取"></a>单词数据的爬取</h4><blockquote><p>借助Python的Requests库和lxml库</p></blockquote><ul><li><p>Requests构建HTTP的请求头<strong>伪装成浏览器与词典网站进行通信</strong>，<strong>发起请求</strong>和<strong>获取响应内容</strong>，对应的方法为<strong>get</strong>方法。主要是获得相应url对应的html。</p></li><li><p>XPath，全称 XML Path Language，即<strong>XML路径语言</strong>,以<strong>XML树结构</strong>为基础，能够在数据的结构树中查找各类节点，比如属性节点、文本节点和元素节点等等。在检查元素中右键即可复制它的XPath路径，分析规律并且结合XPath的表达式语法，就可获取相关文本内容。</p></li><li><p>本项目使用<code>Multiprocessing</code>的<code>Pool</code>方法设置一定进程数量的进程池，将所有需要爬虫的单词异步执行，也就是非阻塞的方式。</p></li><li><p>当时遇到的问题<strong>多进程爬取的数据无法同时向SQLite数据库中保存</strong>，因此先爬取内容到<code>TXT</code>，再保存到数据库中。</p></li></ul><h4 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h4><p>使用<strong>布局编辑器</strong>构建界面。</p><ul><li><p>根布局就是<code>DrawerLayout</code>，在根布局之后又主要分为两大部分，第一部分就是我们主界面的内容，第二部分是左边滑出的布局，这里用NavitationView来代替。</p></li><li><p>线性布局（<code>LinearLayout</code>）和相对布局（<code>RelativeLayout</code>）实现。</p><ul><li>线性布局是将界面中的全部控件按照<strong>水平</strong>或<strong>竖直</strong>方向进行排列，同时它也是最基本的布局方式。</li><li>相对布局则是通过控件之间的<strong>相对位置</strong>关系实现控件的摆放，有利于适配不同屏幕大小的手机，因此使用更为普遍。</li></ul></li><li><p>一般布局都是用<code>dp</code>，字体用<code>sp</code>（手机字体调大了，APP的字体会随之变大）来布局的，用来<strong>适配移动端分辨率</strong>。</p></li></ul><h4 id="API或SDK"><a href="#API或SDK" class="headerlink" title="API或SDK"></a>API或SDK</h4><p>调用百度API实现句子翻译的功能。调用讯飞开放平台的SDK实现语音输入的功能。</p><ul><li><p>API 全称 Application Programming Interface，即<strong>「应用程序接口」</strong>。一般是指一些预先定义的<strong>函数</strong>，目的是供应用程序与开发人员基于某软件或硬件得以访问一组程序的能力，而又无需访问源码，或理解内部工作机制的细节。</p></li><li><p>SDK 全称 Software Development Kit，<strong>软件开发工具包</strong>。通俗来讲就是<strong>第三方服务商提供的实现产品软件某项功能的工具包</strong>。例如 JDK 就是一种 SDK。</p></li><li><p><strong>API 在更多场合下更像是 SDK 的一个子集</strong>，他们的区别如下：</p><ul><li><p>API 通常是一个<strong>函数</strong>，有特定的功能；而 SDK 是一个很多功能函数的<strong>集合体</strong>，更像是一个<strong>工具包</strong>。</p></li><li><p>API 通常扮演<strong>数据接口</strong>的形象，SDK 相当于一个<strong>工具环境</strong>，通常是需要在 SDK 的环境下调用 APl。</p></li><li><p><strong>SDK 相较于 API 封装层次更高</strong>。</p></li></ul></li></ul><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过<strong>分离关注点</strong>的方式来组织代码结构，优化我们的开发效率。</p><h5 id="Android-MVC"><a href="#Android-MVC" class="headerlink" title="Android MVC"></a>Android MVC</h5><ul><li><p><strong>View：</strong>XML布局文件。</p></li><li><p><strong>Model：</strong>实体模型（数据的获取、存储、数据状态变化）。</p></li><li><p><strong>Controller：</strong>对应于Activity，处理数据、业务和UI。</p></li></ul><p>从上面这个结构来看，Android本身的设计还是符合MVC架构的，但是<strong>Android中纯粹作为View的XML视图功能太弱，我们大量处理View的逻辑只能写在Activity中，这样Activity就充当了View和Controller两个角色</strong>，直接导致Activity中的代码大爆炸。相信大多数Android开发者都遇到过一个Acitivty数以千行的代码情况吧！所以，更贴切的说法是，这个MVC结构最终其实只是一个<strong>Model-View（Activity:View&amp;Controller）</strong>的结构。</p><h5 id="Android-MVVM"><a href="#Android-MVVM" class="headerlink" title="Android MVVM"></a>Android MVVM</h5><p>**View: **对应于Activity和XML，负责View的绘制以及与用户交互。</p><p>**Model: **实体模型。</p><p><strong>ViewModel: <strong>负责完成View与Model间的交互，负责</strong>业务逻辑</strong>。</p><p>Android为此提供了一套<strong>架构组件</strong>，主要有LiveData、ViewModel 和Room。</p><ul><li>LiveData是用来构建数据对象，当基础数据库改变时会通知视图；</li><li>ViewModel是用来<strong>存储和管理与界面相关的数据</strong>，这些数据在应用跳转时不会被销毁；</li><li>Room是一个SQLite对象映射库，它可以轻松地将SQLite表数据转换为Java对象，主要负责底层数据库的处理，本文调用其中的Dao接口来执行数据库增删改查等操作，利用 Database创建和管理数据库。同时，Room可以为SQLite语句提供编译时检查，并能够返回RxJava、Flowable和LiveData可观察对象。</li><li>Repository是一个仓库类，介于视图层与数据映射层（数据访问层）之间。它的作用是让视图层感觉不到数据访问层的存在，提供了一个类似集合的接口给视图层进行访问。</li></ul><p>采用MVVM模式最大的优点就是编写代码是思路明确，<strong>视图层与模型层完全解耦</strong>，方便后期的管理与维护，数据库相关的操作非常方便。</p><p>MVVM 模式中的VM，通过双向的数据绑定，<strong>将 View 和 Model 的同步更新给自动化了</strong>。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如vue是通过使用数据劫持和发布订阅者模式来实现的这一功能。</p><h3 id="商城后台管理系统★"><a href="#商城后台管理系统★" class="headerlink" title="商城后台管理系统★"></a>商城后台管理系统★</h3><p>One Piece商城后台管理系统</p><ol><li>此项目为一个<strong>前后台分离</strong>的<strong>后台管理的 SPA</strong>（单页面应用）, 包括前端 PC 应用和后端应用</li><li>包括<strong>用户管理</strong> / <strong>商品管理</strong> / <strong>权限管理</strong>等功能模块</li><li>前端: 使用 <strong>React 全家桶（函数式组件、react-router V6）</strong> + <strong>Antd（v4）</strong> + <strong>Axios</strong> + <strong>ES6</strong> + <strong>Webpack</strong> 等技术</li><li>后端: 使用 <strong>Node</strong> + <strong>Express</strong> + <strong>Mongodb</strong> 等技术</li><li>采用<strong>模块化</strong>、<strong>组件化</strong>、<strong>工程化</strong>的模式开发</li></ol><p>使用<code>create-react-app</code>(脚手架)搭建项目。</p><p><code>create-react-app</code> 是react 官方提供的用于搭建基于<code>react</code>+<code>webpack</code>+<code>es6</code> 的脚手架</p><p><code>antd</code> 是基于 Ant Design 设计体系的 <strong>React UI 组件库</strong>，主要用于研发企业级中后台产品。</p><p><code>craco</code>一个对 create-react-app 进行<strong>自定义配置</strong>的社区解决方案</p><p>父子通信：</p><p><strong>props</strong></p><ul><li><p>【父组件】给【子组件】传递数据：通过<code>props</code>传递</p></li><li><p>【子组件】给【父组件】传递数据：通过<code>props</code>传递，<strong>要求父提前给子传递一个函数</strong>。</p><p>此props为<strong>作用域为父组件自身的函数</strong>，子组件调用该函数，将子组件想要传递的信息，作为参数，<strong>传递到父组件的作用域中</strong>。该项目中将<code>useState</code>的更新函数传给子组件。</p></li><li><p>【子组件】给【父组件】传递函数/方法</p><ul><li><code>useRef</code>: 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 ref 对象在组件的整个生命周期内持续存在。一个常见的用例便是命令式地访问子组件。</li><li><code>useImperativeHandle</code>:可以让你在使用 <code>ref</code> 时<strong>自定义暴露给父组件的实例值</strong>。比如暴露子组件的某个方法。<code>useImperativeHandle</code> 应当与<code>React.forwardRef</code> 一起使用。</li></ul></li></ul><h1 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h1><h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><h3 id="其他语言对比"><a href="#其他语言对比" class="headerlink" title="其他语言对比"></a>其他语言对比</h3><p><strong>解释代码 vs 编译代码</strong></p><ul><li><p>在<strong>解释型</strong>语言中，代码<strong>自上而下</strong>运行，且<strong>实时返回运行结果</strong>。代码将直接以<strong>文本格式（text form）</strong>被接收和处理。解释型语言代表有：JS、MATLAB、Python和Java。</p></li><li><p>相对的，<strong>编译型</strong>语言需要先将代码<strong>转化（编译）</strong>成另一种形式才能运行。比如 C/C++ 先被<strong>编译成汇编语言</strong>，然后才能由计算机运行。程序将以<strong>二进制</strong>的格式运行，这些二进制内容是由程序源代码产生的。</p></li><li><p>编译性语言不如解释性语言跨平台性好。</p></li><li><p><strong>JavaScript 是轻量级解释型语言</strong>。</p><ul><li>浏览器接受到JavaScript代码，并以代码自身的文本格式运行它。</li><li>技术上，几乎所有 JavaScript 转换器都运用了一种叫做<strong>即时编译（just-in-time compiling）</strong>的技术；</li><li>当 JavaScript 源代码被执行时，它会被编译成<strong>二进制</strong>的格式，使代码<strong>运行速度更快</strong>。</li><li>尽管如此，JavaScript 仍然是一门解释型语言，因为<strong>编译过程发生在代码运行中，而非之前</strong>。</li></ul></li></ul><p><strong>服务器端代码 vs 客户端代码</strong></p><ul><li><p>客户端代码是在用户的电脑上运行的代码，在浏览一个网页时，它的客户端代码就会被下载，然后由浏览器来运行并展示。</p></li><li><p>而服务器端代码在服务器上运行，运行结果由浏览器下载并展示出来。</p><ul><li>流行的服务器端 web 语言包括：PHP、Python、Ruby、ASP.NET 以及…… JavaScript！</li><li><strong>JavaScript 也可用作服务器端语言</strong>，比如现在流行的 Node.js 环境。</li></ul></li></ul><p><strong>强类型 Vs. 弱类型</strong></p><ul><li>强和弱是一个相对的概念，强是指倾向于将<strong>未定义的行为</strong>视作错误（Java、Python），弱是指倾向于进行<strong>隐式的转换</strong>、忽略类型相关的错误（JavaScript）。<strong>如果语言经常隐式地转换变量的类型</strong>，那这个语言就是弱类型语言，如果很少会这样做，那就是强类型语言。</li></ul><p><strong>动态类型 Vs. 静态类型</strong></p><ul><li>静态类型的变量的类型是在编译时确定的（C++、Java）；动态类型的类型是在运行时确定的（JavaScript、Python），例如你可以在一个 if 的两个分支里给一个变量赋值不同的类型。</li><li>有的动态类型语言也会添加编译期的类型检查（TypeScript、Python），但因为语言本身的动态性，这些检查仅能覆盖一部分情况。</li></ul><p><strong>虚拟机 VS. 本地代码</strong></p><ul><li>虚拟机是指在语言和 CPU 之间还有一个用于进行翻译的层次（JavaScript、Java）；无虚拟机是指编译器直接生成本地代码给 CPU 执行（C/C++、Golang）。</li></ul><h3 id="基于类-vs-基于原型的语言"><a href="#基于类-vs-基于原型的语言" class="headerlink" title="基于类 vs 基于原型的语言"></a>基于类 vs 基于原型的语言</h3><p><strong>基于类的面向对象语言</strong>，比如 Java 和 C++，是构建在两个不同实体之上的：类和实例。</p><ul><li>一个<strong>类(class)<strong>定义了</strong>某一对象集合所具有的特征性属性</strong>（可以将 Java 中的方法和域以及 C++ 中的成员都视作属性）。<strong>类是抽象的，而不是其所描述的对象集合中的任何特定的个体。</strong></li><li>另一方面，<strong>一个实例(instance)是一个类的实例化</strong>。<strong>实例具有和其父类完全一致的属性</strong>。</li></ul><p><strong>基于原型的语言（如 JavaScript）</strong>并不存在这种区别：它<strong>只有对象</strong>。</p><p>基于原型的语言具有所谓**原型对象(prototypical object)**的概念。</p><p><strong>原型对象可以作为一个模板，新对象可以从中获得原始的属性。</strong></p><p>任何对象都可以指定其自身的属性，既可以是创建时也可以在运行时创建。</p><p><strong>任何对象都可以作为另一个对象的原型(prototype)，从而允许后者共享前者的属性</strong>。</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向对象是把构成问题事务分解成各个对象，<strong>建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</strong></p><p>万事万物皆对象。面向对象的思想主要是以对象为主，将一个问题抽象出具体的对象，并且将抽象出来的对象和对象的属性和方法封装成一个类。</p><ul><li><strong>面向过程</strong>的特点在于<strong>逻辑性强</strong>，符合思维方式和解决问题的流程。</li><li><strong>面向对象</strong>的特点就是<strong>可扩展性更强</strong>一些，解决了<strong>代码重用性</strong>的问题。</li></ul><p>js中对象，对象下的方法和属性，都是储存在<strong>内存</strong>中的，调用的时候，是可以随时拿到这些属性和方法的。</p><p>在编程中使用OOP就是为了<strong>提高代码的复用性</strong>，而提高代码复用性的根本原因是为了<strong>降低内存的使用率</strong>。</p><p>面向对象程序设计的<strong>目的</strong>是在编程中促进更好的<strong>灵活性和可维护性</strong>，在大型软件工程中广为流行。即代码各部分相对独立，耦合性低，且功能明确，遇到bug或者更改需求，都可以直接针对特定的对象进行修改，便于维护。另外，面向对象凭借其对<strong>模块化</strong>的重视，面向对象的代码开发更简单，更容易理解，相比非模块化编程方法 , 它能更直接地分析, 编码和理解复杂的情况和过程。</p><p><strong>面向对象有三大特性，封装、继承和多态</strong></p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>封装主要实现的功能就是将数据隐藏，只暴露出有限的接口。</strong></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>引入继承性的好处</p><ul><li>减少了代码的冗余，提高了代码的复用性</li><li>便于功能的扩展</li><li>为之后多态性的使用，提供了前提</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>多态</strong>（Polymorphism）按字面的意思就是“多种状态”,在面向对象语言中，接口的多种不同的实现方式即为多态。</p><p><strong>可以解释为：</strong>同样的操作作用于不同对象上面，可以产生不同的解释和不同的运行结果。换句话说，给不同对象发送统一消息的时候，这些对象会根据这个信息分别给出不同的反馈。</p><p>JavaScript的多态的思想实际上就是把“做什么”和“谁去做”分离开来，要实现这一点，归根结底就是解耦。</p><h2 id="Js中的堆栈"><a href="#Js中的堆栈" class="headerlink" title="Js中的堆栈"></a>Js中的堆栈</h2><p>堆<code>heap</code>是<strong>动态分配</strong>的内存，<strong>大小不定</strong>也<strong>不会自动释放</strong>，栈<code>stack</code>为<strong>自动分配</strong>的内存空间，在代码执行过程中<strong>自动释放</strong>。</p><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>在栈内存中提供一个供<code>Js</code>代码执行的环境，关于<strong>作用域</strong>以及<strong>函数的调用</strong>都是栈内存中执行的。</p><p><code>Js</code>中基本数据类型<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Null</code>、<code>Undefined</code>、<code>Symbol</code>、<code>BigInt</code>，</p><ul><li><strong>占用空间小且大小固定</strong>，<strong>值直接保存在栈内存中，是按值访问</strong>，</li><li>对于<code>Object</code>引用类型，其<strong>指针放置于栈内存中</strong>，<strong>指向堆内存的实际地址</strong>，是通过<strong>引用</strong>访问。</li></ul><p>关于调用栈，每调用一个函数，解释器就会把该函数添加进调用栈并开始执行；</p><p>正在调用栈中执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行；</p><p>当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码；</p><p>当分配的调用栈空间被占满时，会引发<strong>堆栈溢出</strong>错误。</p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>引用类型<code>Object</code>的变量<strong>占据空间大且大小不固定</strong>，堆内存中存储<strong>实际对象</strong>，在栈内存中存储对象的指针。</p><p>对于对象的访问是按引用访问的，在堆区的内存不会随着程序的运行而自动释放，这就需要实现<strong>垃圾回收机制</strong><code>GC</code>。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存。</p><p>并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存。</p><p>对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>需要注意的是在<code>Js</code>中没有类似于<code>C</code>中的<code>free()</code>函数去手动释放内存，对于堆区内存回收全部需要通过<code>Js</code>的垃圾回收机制去实现。<br>在<strong>栈</strong>区中执行的变量等是通过值访问，当其<strong>作用域销毁后变量也就随之销毁</strong>，</p><p>而使用引用访问的堆区变量，在一个作用域消失后还可能在外层作用域或者其他作用域仍然<strong>存在引用</strong>，不能直接销毁，</p><p>此时就需要通过算法计算该堆区变量是否属于不再需要的变量，从而决定是否需要进行内存回收，</p><p>在<code>Js</code>中主要有<strong>引用计数</strong>与<strong>标记清除</strong>两种垃圾回收算法。</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>对于引用计数垃圾回收算法，把对象是否不再需要简化定义为<strong>该对象有没有其他变量或对象引用到它</strong>，如果没有引用指向该对象，该对象将被垃圾回收机制回收。</p><p>引用计数垃圾回收算法使用比较少，主要是在<code>IE6</code>与<code>IE7</code>等低版本<code>IE</code>浏览器中使用。</p><p>但是对于引用计数垃圾回收算法有个限制，当对象<strong>循环引用</strong>时，就会造成<strong>内存泄漏</strong>，也就是引用计数垃圾回收算法无法处理循环引用的对象。</p><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>对于标记清除垃圾回收算法，把对象是否不再需要简化定义为<strong>该对象是否可以获得</strong>。</p><p>该算法设置一个叫做根<code>root</code>的对象，在<code>Javascript</code>里根是全局对象，垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象，以此不断向下查找。</p><p><strong>从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象</strong>，这样便解决了循环引用的问题。</p><p>所有现代浏览器都使用了标记清除垃圾回收算法，所有对<code>JavaScript</code>垃圾回收算法的改进都是基于标记清除算法的改进。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote><p>JavaScript 是一种<strong>弱类型</strong>、<strong>动态</strong>语言。</p><p><strong>不用提前声明变量的类型</strong>，在程序<strong>运行</strong>过程中，<strong>类型会被自动确定</strong>。</p><p>可以使用<strong>同一个变量保存不同类型的数据</strong>。</p></blockquote><h3 id="7-1"><a href="#7-1" class="headerlink" title="7+1"></a>7+1</h3><ul><li>原始类型(值不可变，栈)：<code>Undefined</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>BigInt</code>、<code>Symbol</code>、<code>Null</code></li><li>引用数据类型（堆，地址：栈）：<code>Object</code>（几乎所有通过 <code>new</code> 创建的东西：Array、Set、Date）</li></ul><h2 id="模块化、组件化、工程化"><a href="#模块化、组件化、工程化" class="headerlink" title="模块化、组件化、工程化"></a>模块化、组件化、工程化</h2><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>后端：<strong>CommonJS</strong> :<code>module.exports</code>、<code>require</code>方法用于加载模块。</p><p>前端：<strong>ES6</strong> 模块化语法：export 和 import；</p><p><strong>将 JavaScript 程序拆分为可按需导入的单独模块的机制</strong>。</p><ul><li><strong>避免命名冲突(减少命名空间污染)</strong></li><li><strong>更好的分离, 按需加载</strong></li><li><strong>更高复用性</strong></li><li><strong>高可维护性</strong></li></ul><h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><p><code>webpack</code>最热门的前端资源模块化管理和打包工具、</p><p><code>create-react-app</code> 脚手架初始化react 项目开发、</p><p><code>ESLint</code> 插件化的 JavaScript 代码检测工具</p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>其中以React的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。</p><p>理解:<strong>用来实现局部功能效果的代码和资源的集合(html/css/js/img等等)</strong></p><p>为什么要用组件:一个界面的功能复杂</p><p>作用:<strong>复用编码,简化项目编码,提高运行效率</strong></p><p>当应用是以多组件的方式实现,这个应用就是组件化的应用。</p><h2 id="框架好处"><a href="#框架好处" class="headerlink" title="框架好处"></a>框架好处</h2><ol><li><strong>组件化</strong>: 其中以 React 的组件化最为彻底,甚至可以到<strong>函数级</strong>别的原子组件,高度的组件化可以是我们的工程<strong>易于维护、易于组合拓展</strong>。</li><li><strong>天然分层</strong>: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。</li><li><strong>生态</strong>: 现在主流前端框架都<strong>自带生态</strong>,不管是<strong>数据流管理架构</strong>还是 <strong>UI 库</strong>都有成熟的解决方案。</li><li><strong>开发效率</strong>: 现代前端框架都默认<strong>自动更新DOM</strong>,而非我们手动操作,解放了开发者的手动DOM成本,提高开发效率,从根本上解决了UI 与状态同步问题。</li></ol><p>常见框架：<strong>Angular React Vue Svelte</strong></p><h2 id="TS-vs-JS"><a href="#TS-vs-JS" class="headerlink" title="TS vs JS"></a>TS vs JS</h2><p>对比于JS，TS是JS的<strong>超集</strong>，简单的说就是在 <code>JavaScript</code> 的基础上加入了<strong>类型系统</strong>，让每个参数都有明确的意义，从而带来了更加<strong>智能</strong>的提示。</p><p>相对于<code>JS</code>而言，<code>TS</code>属于<strong>强类型</strong>语言，所以对于项目而言，会使代码更加规范，从而解决了大型项目代码的复杂性，其次，浏览器是不识别<code>TS</code>的，所以在编译的时候，<code>TS</code>文件会先编译为<code>JS</code>文件。</p><p>相较于JS而言，TS拥有了<strong>静态类型</strong>，更加严格的语法，更强大的功能；TS可以<strong>在代码执行前就完成代码的检查</strong>，减小了运行时异常的出现的几率；TS代码<strong>可以编译为任意版本的JS代码</strong>，可有效解决不同JS运行环境的兼容问题；同样的功能，<strong>TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS</strong>。</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/XzxS6f"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/21/XzxS6f.png" alt="XzxS6f.png"></a></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>版本库👉.git<ul><li>当我们使用git管理文件时，比如<strong>git init</strong>时，这个时候，会多一个**.git**文件，我们把这个文件称之为版本库。</li><li><strong>.git</strong>文件另外一个作用就是它在创建的时候，会自动创建<strong>master</strong>分支，并且将<strong>HEAD</strong>指针指向<strong>master</strong>分支。</li></ul></li><li>工作区<ul><li>本地项目存放文件的位置。</li><li>可以理解成图上的workspace。</li></ul></li><li>暂存区 (<code>Index/Stage</code>)<ul><li>顾名思义就是暂时存放文件的地方，通过是通过<strong>add</strong>命令将工作区的文件添加到缓冲区。</li></ul></li><li>本地仓库（<code>Repository</code>）<ul><li>通常情况下，我们使用<strong>commit</strong>命令可以将暂存区的文件添加到本地仓库。</li><li>通常而言，<strong>HEAD</strong>指针指向的就是<strong>master</strong>分支。</li></ul></li><li>远程仓库（<code>Remote</code>）<ul><li>举个例子，当我们使用<strong>GitHub</strong>托管我们项目时，它就是一个远程仓库。</li><li>通常我们使用<strong>clone</strong>命令将远程仓库代码拷贝下来，本地代码更新后，通过<strong>push</strong>托送给远程仓库。</li></ul></li></ul><h3 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h3><p><strong>master分支</strong></p><ul><li><strong>主分支</strong>，用于<strong>部署生产环境</strong>的分支，确保稳定性。</li><li>master分支一般由develop以及hotfix分支合并，任何情况下都不能直接修改代码。</li></ul><p><strong>develop 分支</strong></p><ul><li>develop为<strong>开发分支</strong>，通常情况下，保存最新完成以及bug修复后的代码。</li><li>开发新功能时，feature分支都是基于develop分支下创建的。</li></ul><p><strong>feature分支</strong></p><ul><li><strong>开发新功能</strong>，基本上以develop为基础创建feature分支。</li><li>分支命名：<strong>feature/ 开头</strong>的为特性分支， 命名规则: feature/user_module、 feature/cart_module。</li></ul><p><strong>release分支</strong></p><ul><li>release 为<strong>预上线分支</strong>，发布提测阶段，会以release分支代码为基准提测。</li></ul><p><strong>hotfix分支</strong></p><ul><li><strong>hotfix/</strong> 开头的为<strong>修复分支</strong>，它的命名规则与 feature 分支类似。</li><li>线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支。</li></ul><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>要撤销最近几次的提交，可以使用 <code>git reset</code>，下面介绍它的三种模式：<code>soft</code>、<code>mixed</code> 和 <code>hard</code>。</p><h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><p>单人基本不会冲突，主要是多人协作，而且对其他人代码或公共代码修改时才会冲突。</p><ul><li><strong>如果不是基于远程库的最新版所做的修改，不能推送，必须先拉取。</strong></li><li>拉取下来后如果进入冲突状态，根据产生冲突的地方检查并修改。</li><li>package-lock.json冲突<ul><li>统一node版本和npm版本(至少统一一个大的版本)，且在需要重新安装依赖的时候，使用npm ci的命令去安装。（强烈推荐,npm ci指的是根据package-lock.json去安装对应的版本，不对这个文件做改动）</li><li>使用git忽略package-lock.json（不推荐，这样子会导致不能根据安装依赖路径去安装包了）</li></ul></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一种基本的线性数据结构，可以在连续的内存空间中分配一组相同的数据类型，是一种静态的数据结构，存储大小固定，且在内存中布局连续。数组的每个元素都有一个唯一的下标，表示元素在数组中的位置。数组的访问时间复杂度为O(1)，支持随机访问元素。</p><p><strong>JavaScript 数组的长度和元素类型都是非固定的。</strong></p><p>因为数组的<strong>长度可随时改变</strong>，并且其数据<strong>在内存中也可以不连续</strong>（存储相同类型元素内存连续）。</p><p><strong>优点：</strong></p><ul><li>访问速度很快，时间复杂度为O(1)</li><li>内存地址是连续的，所以在内存中存储的效率很高</li></ul><p><strong>缺点：</strong></p><ul><li>插入、删除速度比较慢，因为需要移动其他元素</li><li>数组大小固定，需要预先分配内存</li></ul><p><strong>应用场景：</strong></p><ul><li>当需要在数据中进行随机访问时，使用数组是最好的选择。</li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种后进先出的线性结构，它只支持在一端插入、删除元素的操作。该端被称为栈顶，另一端为栈底。向栈顶插入元素的操作称为入栈，从栈顶删除元素的操作称为出栈。在栈结构中，只有最近添加的元素才能被处理。栈的应用广泛，例如函数调用、表达式求值、浏览器的后退、前进等操作。</p><p><strong>优点：</strong></p><ul><li>先进后出的特性适合堆栈结构问题，如递归实现、表达式计算等。</li><li>空间利用率高。</li></ul><p><strong>缺点：</strong></p><ul><li>只能在栈顶添加和移除元素。</li><li>栈容量固定，数据量过大容易导致溢出。</li></ul><p><strong>应用场景：</strong></p><ul><li>需要回溯操作的场合。</li><li>需要按照一定顺序进行处理的场合。</li><li>递归问题的处理。</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种基本的数据结构，是一种先进先出（FIFO）的线性结构，队列中的元素从队尾入队（enqueue），从队首出队（dequeue），因此队列中最早进入的元素最先被处理。队列有多种类型，如普通队列、双端队列、优先级队列等。</p><p><strong>优点：</strong></p><ul><li>数据结构简单，易于实现</li><li>FIFO结构，保证数据先进先出</li></ul><p><strong>缺点：</strong></p><ul><li>不支持随机访问，只能访问队首/队尾</li><li>插入和删除操作的时间复杂度较高</li></ul><p><strong>应用场景：</strong></p><ul><li>需要实现请求队列</li><li>需要进行广度优先搜索时</li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一种基本的线性数据结构，由一组节点（也称为元素）组成，每个节点包含数据和一个指向下一个节点的指针，即链表中每个元素都指向下一个元素。链表可以动态地增加或删除元素，但不支持随机访问元素。链表有多种类型，如单向链表、双向链表、循环链表等。</p><p><strong>优点：</strong></p><ul><li>插入、删除数据的速度很快，只需要改变相邻节点的指针。</li><li>链表的大小不受限制，可以动态创建。</li></ul><p><strong>缺点：</strong></p><ul><li>在内存中分配空间不连续，所以占用的内存比较大</li><li>访问速度不如数组快，时间复杂度为O(n)</li></ul><p><strong>应用场景：</strong></p><ul><li>插入和删除操作频繁</li><li>不需要随机访问</li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表是一种基于哈希函数实现的数据结构，通过哈希函数将键（key）映射到对应的位置（slot）上，然后在该位置上存储对应的值（value），以实现高效的数据查找、插入、删除等操作。哈希表支持O(1)的平均时间复杂度，但最坏情况下会退化为O(n)。</p><p><strong>优点：</strong></p><ul><li>插入和查找操作的速度非常快</li><li>适用于大量的数据存储</li></ul><p><strong>缺点：</strong></p><ul><li>哈希表的建立过程较复杂</li><li>内存占用较大</li></ul><p><strong>应用场景：</strong></p><ul><li>需要快速查找数据</li><li>用户需要快速插入和删除数据</li></ul><h3 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h3><p>树是一种非线性数据结构，由节点（node）和边（edge）组成，节点之间按照父子关系连接。树的一个节点只有一个父节点，但可以有多个子节点，因此树的高度（Height）是从根节点到最深的叶节点所经过的边数。树在计算机科学中有广泛的应用，比如二叉搜索树、AVL树、红黑树、堆等数据结构都是基于树的结构。树的相关操作包括遍历、插入、删除、查找等操作。</p><p><strong>优点：</strong></p><ul><li>支持快速的搜索、插入和删除操作</li><li>可以支持多种用途，例如：二叉搜索树、AVL树和红黑树等。</li></ul><p><strong>缺点：</strong></p><ul><li>树的实现难度较高</li><li>不易调试</li></ul><p><strong>应用场景：</strong></p><ul><li>二叉搜索树：需要进行快速搜索时</li><li>AVL树或红黑树：需要对数据进行插入/删除时，且对时间复杂度有比较高的要求。</li></ul><p>总的来说：每种数据结构都有自己特定的应用场景。</p><h2 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul><li>冒泡排序只会操作<strong>相邻的两个数据</strong>。</li><li>外层需要n-1次排序，第n次比较是多余的，每一次结束后，未排序部分的最大值冒泡到最后。（从后向前）</li><li>内层循环不断对<strong>未排序部分</strong>两两比较交换。</li><li>每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。</li><li>一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</li></ul><p>冒泡的过程只涉及相邻数据的交换操作，空间复杂度为 O(1)，是一个<code>原地</code>排序算法。</p><p>为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换， 所以冒泡排序是<code>稳定</code>的排序算法。</p><p>时间复杂度：最佳：<code>T(n) = O(n)</code>，正序。 最差：<code>T(n) = O(n^2)</code>，反序。 平均：<code>T(n) = O(n^2)</code>。</p><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>我们通常说的插入排序是指直接插入排序。</p><p>插入排序的工作原理：<strong>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</strong>。</p><p><strong>步骤</strong></p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中<strong>从后向前</strong>扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤 2 ~ 5。</li></ul><p>插入排序算法的运行不需要额外的存储空间，空间复杂度是 O(1)，是一个<code>原地</code>排序算法。</p><p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是<code>稳定</code>的排序算法。</p><p>时间：最佳：<code>T(n) = O(n)</code>，正序。 最差：<code>T(n) = O(n^2)</code>，反序。 平均：<code>T(n) = O(n^2)</code>。</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul><li>先找到一个基准点（一般指数组的中部<code>midIndex</code>或随机数），然后数组被该基准点分为两部分，依次与该基准点数据<code>mid</code>比较，如果比它小，放左边；反之，放右边。</li><li>左右分别用一个空数组去存储比较后的数据。</li><li>最后递归执行上述操作，直到数组长度 &lt;= 1;</li></ul><p>缺点：<strong>需要另外声明两个数组，浪费了内存空间资源</strong>。</p><p>优化</p><p>优化的算法进行分区时，不需要很多额外的内存空间，所以快排是<code>原地排序</code>算法。</p><p>快速排序每次交换的元素都有可能不是相邻的，因此它有可能打破原来值为相同的元素之间的顺序。因此，快速排序并<code>不稳定</code>。</p><p>极端的例子：如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为基准点，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n / 2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n^2)。<strong>快排时间复杂度与基准点的选取有关，一般取中部或随机最优。</strong></p><p>时间：最佳：<code>T(n) = O(nlogn)</code>。 最差：<code>T(n) = O(n^2)</code>。 平均：<code>T(n) = O(nlogn)</code>。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划算法主要是通过找出问题中的重复子问题，减少计算时间和空间</p><h3 id="哈希法"><a href="#哈希法" class="headerlink" title="哈希法"></a>哈希法</h3><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归是一种通过调用自身的函数来解决问题的方法。递归通常涉及指定基本情况，该基本情况允许函数退出递归过程的一种情况。然后，递归函数调用自身，将问题变成更小的问题。递归通常用来解决问题的以下情况：</p><ul><li>问题可以被分解为更小的问题。</li><li>解决更小的问题可以帮助解决原始问题。</li><li>问题解决的步骤是相同的。</li></ul><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>二分法也称为折半查找，是一种高效的查找算法。该算法首先需要确定要搜索的数据范围，然后对中间元素进行查找。如果待查找的元素小于中间元素，则继续在中间元素左边的子数组中查找；如果待查找的元素大于中间元素，则继续在中间元素右边的子数组中查找；如果待查找的元素正好是中间元素，则返回该元素的位置。每次查找都可以将数据范围减半，因此该算法的时间复杂度为 O(logn)。</p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>双指针算法是一种常用的线性时间算法。该算法通常涉及使用两个指针来解决问题。这些指针称为“左指针”和“右指针”。使用指针可以大大减少复杂性，因为指针可以在数组或链表中移动，而不需要复制或重新分配元素或节点。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p><a target="_blank" rel="noopener" href="https://imgse.com/i/x12ak9"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/10/06/x12ak9.png" alt="x12ak9.png"></a></p><h3 id="URL输入到页面展现"><a href="#URL输入到页面展现" class="headerlink" title="URL输入到页面展现"></a>URL输入到页面展现</h3><p>总体来说分为以下几个过程:</p><ul><li>浏览器查找当前URL是否存在<strong>缓存</strong>，并比较缓存是否过期。（先判断HTTP请求浏览器是否已缓存）<ul><li><strong>有缓存</strong><ul><li>如为<strong>强制缓存</strong>，通过<code>Expires</code>或<code>Cache-Control：max-age</code>判断该缓存是否过期，未过期，直接使用该资源；Expires和max-age，如果两者同时存在，则被Cache-Control的max-age覆盖。</li><li>如为<strong>协商缓存</strong>，请求头部带上相关信息如<code>if-none-match（Etag）</code>与<code>if-modified-since(last-modified)</code>，验证缓存是否有效，若有效则返回状态码为<code>304</code>，若无效则重新返回资源，状态码为<code>200</code></li></ul></li></ul></li></ul><ul><li><p><strong>解析URL并生成HTTP请求报文</strong></p></li><li><p><strong>DNS 解析</strong>：将<strong>域名</strong>解析成<strong>IP地址</strong></p></li><li><p><strong>TCP 三次握手</strong>建立连接、<strong>TLS三次握手</strong> =》在<strong>HTTPS</strong>上建立安全连接</p></li><li><p>将HTTP报文添加TCP头部（源、目标端口、序号、窗口大小和状态位）生成<strong>TCP报文</strong></p></li><li><p>添加<strong>IP包头</strong>（源、目标IP）和<strong>MAC包头</strong>（收发MAC地址）将数据封装成<strong>网络包</strong></p></li><li><p><strong>网卡驱动</strong>从IP模块获取到包之后，再次封装。</p></li><li><p><strong>网卡</strong>会将包转为<strong>电信号</strong>（光纤传输的话可能还有电光转换）。</p></li><li><p>网络包经过<strong>交换机</strong>和<strong>路由器</strong>转发到达<strong>服务器</strong></p></li><li><p>服务器将<strong>MAC、IP、TCP、HTTP头部一层层解析处理</strong>，<strong>将网页放入HTTP响应报文中</strong>，<strong>穿上TCP、IP、MAC头部返回</strong></p></li><li><p>浏览器拿到HTTP响应报文后，将<strong>HTML和CSS解析出DOM 树和 CSS 规则树</strong>（<strong>CSSOM</strong>），两者生成<strong>渲染树</strong>，之后进行<strong>页面布局与绘制</strong></p><ul><li>如果遇到 script 标签，则判断是否含有 <code>defer</code> 或者 <code>async</code> 属性，如果有，异步去下载该资源；如果没有设置，暂停dom的解析，去加载script的资源，然后执行该js代码（<strong>script标签加载和执行会阻塞页面的渲染</strong>）</li></ul></li><li><p>断开TCP连接 ：<strong>TCP四次挥手</strong></p></li></ul><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p><strong>三次握手</strong></p><ul><li>一开始，客户端和服务端都处于关闭状态。先是服务端<strong>主动监听某个端口</strong>。</li><li>客户端把第一个发送报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，其中包含<strong>客户端序列号</strong>（<code>client_isn</code> ），并且<code>SYN</code> 标志位置为<code>1</code>。</li><li>服务端收到客户端的<code>SYN</code>报文后，发送应答报文给客户端，该报文也不包含应用层数据，包含<strong>服务端序列号</strong>（<code>server_isn</code>）、<strong>确认序列</strong>（<code>client_isn +1</code>）、并且<code>SYN</code>和<code>ACK</code>置1。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，其中包含<strong>确认序列</strong>（<code>server_isn +1</code>），并且<code>ACK</code>置1。这次报文<strong>可以携带客户到服务器的数据</strong>，之后客户端处于建立连接状态。</li><li>服务器收到客户端的应答报文后，也进入建立连接状态。</li></ul><p><strong>为什么三次？</strong></p><p><strong>因为三次握手才能保证双方具有接收和发送的能力</strong>。</p><p><strong>通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。</strong></p><h3 id="TCP四次挥手-★"><a href="#TCP四次挥手-★" class="headerlink" title="TCP四次挥手 ★"></a>TCP四次挥手 ★</h3><p><strong>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</strong></p><ul><li>客户端打算关闭连接，此时会发送<code>FIN</code>报文（<code>FIN</code>置1），之后客户端进入<code>FIN_WAIT_1</code>状态。</li><li>服务端收到该报文后，就向客户端发送<code>ACK</code>应答报文，接着服务端进入<code>CLOSED_WAIT</code>状态；客户端收到服务端的<code>ACK</code>应答报文后，之后进入<code>FIN_WAIT_2</code>状态。</li><li>等待<strong>服务端处理完数据后</strong>，再次向客户端发送<code>FIN</code> 报文，之后服务端进入<code>LAST_ACK</code>状态。</li><li>客户端收到服务端的<code>FIN</code> 报文后，回一个<code>ACK</code>应答报文，之后进入<code>TIME_WAIT</code>状态。</li><li>服务器收到了<code>ACK</code>应答报文后，就完成连接的关闭。</li><li>客户端在经过<code>2MSL</code>一段时间后，自动进入关闭状态。</li></ul><p><strong>为什么挥手需要四次</strong>?</p><p><strong>服务端通常需要等待完成数据的发送和处理</strong>，所以服务端的<code>ACK</code>和 <code>FIN</code>一般都会分开发送，从而比三次握手导致多了一次。</p><p><strong>主动关闭连接的，才有TIME_WAIT状态</strong>。</p><p><code>MSL</code>是<code>Maximum Segment Lifetime</code>，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><p>经过<code>2MSL</code>这个时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><p><code>TIME-WAIT</code>更重要的作用是<strong>等待足够的时间以确保最后的ACK能让被动关闭方接收，从而帮助其正常关闭</strong>。</p><h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><ul><li>HTTP是<strong>超文本传输协议</strong>，信息是<strong>明文传输</strong>，存在安全风险的问题。HTTPS则解决HTTP不安全的缺陷，<strong>在TCP和HTTP之间加入了SSL/TLS安全协议</strong>，使得报文能够<strong>加密</strong>传输。</li><li>HTTP 连接建立相对简单，<strong>TCP三次握手</strong>之后便可进行HTTP的报文传输。而 HTTPS在<strong>TCP三次握手</strong>之后，还需进行<strong>SSL/TLS的握手</strong>过程，才可进入加密报文传输。</li><li>HTTP的端口号是<strong>80</strong>，HTTPS的端口号是<strong>443</strong>。</li><li>HTTPS 协议需要<strong>向CA(证书权威机构）申请数字证书</strong>，来保证服务器的身份是可信的。</li></ul><h4 id="HTTPS连接"><a href="#HTTPS连接" class="headerlink" title="HTTPS连接"></a>HTTPS连接</h4><p><strong>https采用非对称加密+对称加密，非对称加密来传递密钥；对称加密来加密内容</strong></p><ul><li>客户端使用https的url访问web服务器，要求与服务器建立ssl连接</li><li>服务器收到客户端请求后, 会将**网站的证书(包含公钥)**传送一份给客户端</li><li>客户端收到网站证书后会检查证书的<strong>颁发机构以及过期时间</strong>, 如果没有问题就<strong>随机产生一个秘钥</strong></li><li>客户端利用<strong>公钥将会话秘钥加密</strong>, 并传送给服务端</li><li>服务端利用自己的<strong>私钥</strong>解密出会话秘钥，之后服务器与客户端使用秘钥加密传输</li></ul><p>整个SSL/TLS的握手阶段全部结束后，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用<strong>会话秘钥加密内容。</strong></p><p>SSL/TLS 1.2需要4次握手，SSL/TLS 1.3优化了过程，<strong>只需要3次握手</strong>。</p><h3 id="HTTP-1-1、HTTP-2、HTTP-3演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3演变" class="headerlink" title="HTTP/1.1、HTTP/2、HTTP/3演变"></a>HTTP/1.1、HTTP/2、HTTP/3演变</h3><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><p>HTTP/1.1相比HTTP/1.0性能上的改进︰</p><ul><li>使用TCP<strong>长连接</strong>的方式改善了<strong>HTTP/1.0短连接</strong>造成的性能开销。<ul><li><strong>减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载</strong>。</li><li><strong>只要任意一端没有明确提出断开连接，则保持TCP连接状态。</strong></li></ul></li><li>支持<strong>管道（pipeline)网络传输</strong>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li><li>缓存<code>Etag</code></li></ul><p>但HTTP/1.1还是有性能瓶颈︰</p><ul><li><strong>请求/响应头部(Header)未经压缩就发送</strong>，首部信息越多延迟越大。只能压缩<code>Body</code>的部分;</li><li><strong>服务器是按请求的顺序响应的</strong>，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>;</li><li><strong>没有请求优先级控制</strong>;</li><li>请求只能从客户端开始，<strong>服务器只能被动响应</strong>。</li></ul><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p><strong>HTTP/2协议是大多基于HTTPS的，所以HTTP/2的安全性也是有保障的。</strong></p><p>那HTTP/2相比HTTP/1.1 性能上的改进︰</p><ul><li><strong>头部压缩</strong>（HPACK算法）</li><li><strong>二进制格式</strong> 增加了数据传输的效率</li><li><strong>数据流</strong><ul><li>HTTP/2的数据包<strong>不是按顺序发送的</strong>，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</li><li>每个请求或回应的所有数据包，称为一个数据流（<strong>Stream</strong> )。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。</li><li>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</li></ul></li><li><strong>多路复用</strong><ul><li>HTTP/2是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。</li><li>移除了HTTP/1.1中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。</li></ul></li><li><strong>服务器推送</strong><ul><li>HTTP/2还在一定程度上改善了传统的「请求-应答」工作模式，服务不再是被动地响应，<strong>也可以主动向客户端发送消息</strong>。</li><li>举例来说，在浏览器刚请求HTML的时候，就提前把可能会用到的JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送(<strong>Server Push</strong>，也叫<strong>Cache Push</strong>)。</li></ul></li></ul><h4 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h4><p>HTTP/2主要的问题在于，<strong>多个HTTP请求在复用一个TCP连接</strong>，下层的TCP协议是不知道有多少个HTTP请求的。</p><p>所以<strong>一旦发生了丢包现象，就会触发TCP的重传机制</strong>，这样在一个TCP连接中的<strong>所有的HTTP请求都必须等待这个丢了的包被重传回来</strong>。</p><ul><li>HTTP/1.1中的管道（pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了。</li><li>HTTP/2多个请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的HTTP请求。</li></ul><p>这都是<strong>基于TCP传输层</strong>的问题，所以<strong>HTTP/3把HTTP下层的TCP协议改成了UDP</strong>!</p><p>UDP是<strong>不管顺序，也不管丢包的</strong>，所以<strong>不会出现HTTP/1.1的队头阻塞和HTTP/2的一个丢包全部重传问题</strong>。</p><p>大家都知道UDP是不可靠传输的，但<strong>基于UDP的QUIC协议可以实现类似TCP的可靠性传输</strong>。</p><ul><li>QUIC有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，<strong>其他流不会受到影响</strong>。</li><li>TLS3升级成了最新的<strong>1.3</strong>版本，头部压缩算法也升级成了<strong>QPack</strong> 。</li><li>HTTPS要建立一个连接，要花费6次交互，先是建立三次握手，然后是TLS/1.3的三次握手。QUIC直接把以往的TCP和 TLS/1.3的6次交互<strong>合并成了3次，减少了交互次数</strong>。</li></ul><p>所以，QUIC是一个在UDP之上的<strong>伪</strong>TCP+ TLS+ HTTP/2的多路复用的协议。</p><p>QUIC是新协议，对于很多网络设备，根本不知道什么是QUIC，只会当做UDP，这样会出现新的问题。所以HTTP/3现在普及的进度非常的缓慢，不知道未来UDP是否能够逆袭TCP。</p><p>QUIC 全称：Quick UDP Internet Connections，是一种基于 UDP 的传输层协议。由 Google 自研，2012 年部署上线，2013 年提交 IETF，2021 年 5 月，IETF 推出标准版 RFC9000。</p><p>从协议栈可以看出：QUIC = HTTP/2 + TLS + UDP</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li>在传送数据之前<strong>不需要先建立连接</strong>，远地主机在收到 UDP 报文后，<strong>不需要给出任何确认</strong>。</li><li>一般用于<strong>即时通信</strong>，比如： QQ 语音、 QQ 视频 、直播等等</li><li>基于<strong>UDP的QUIC</strong>协议可以实现类似TCP的可靠性传输</li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul><li>提供<strong>面向连接</strong>的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li>TCP 在传递数据之前，会有<strong>三次握手</strong>来建立连接，而且在数据传递时，有<strong>确认</strong>、<strong>窗口</strong>、<strong>重传</strong>、<strong>拥塞控制</strong>机制，在数据传完后，还会<strong>断开连接</strong>用来节约系统资源</li><li>由于 TCP 要提供可靠的，面向连接的传输服务，这难以避免增加了许多开销。</li><li>TCP 一般用于<strong>文件传输、发送和接收邮件、远程登录</strong>等场景。</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leslie Waong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesliewaong.top/posts/9d34f1d1.html">https://lesliewaong.top/posts/9d34f1d1.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lesliewaong.top" target="_blank">Leslie Waong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Leslie Waong</div><div class="author-info__description">BUPT</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">122</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lesliewaong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lesliewaong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1138964397&amp;website=www.qtxml.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">红雨漂泊泛起了回忆怎么潜</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%AE%E8%A7%86"><span class="toc-text">央视</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HR"><span class="toc-text">HR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%AE%E8%A7%86-1"><span class="toc-text">央视</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%9B%AE"><span class="toc-text">节目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF"><span class="toc-text">新媒体技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF%E5%B2%97"><span class="toc-text">新媒体技术岗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E7%AB%99%E5%92%8C%E5%A4%AE%E8%A7%86"><span class="toc-text">B站和央视</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%92"><span class="toc-text">规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%B4%A7%E4%BB%BB%E5%8A%A1%E9%87%8D-%E5%8E%8B%E5%8A%9B"><span class="toc-text">时间紧任务重&#x2F;压力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E4%BD%9C"><span class="toc-text">合作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E7%A0%B4%E5%B8%B8%E8%A7%84%EF%BC%8C%E6%96%B0%E9%A2%96%E7%9A%84%E6%83%B3%E6%B3%95-%E6%9C%89%E6%88%90%E5%B0%B1%E6%84%9F%E7%9A%84%E4%BA%8B"><span class="toc-text">打破常规，新颖的想法 &#x2F; 有成就感的事</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E6%9C%89%E8%AE%A1%E5%88%92%E5%8F%91%E7%94%9F%E9%87%8D%E5%A4%A7%E5%8F%98%E5%8C%96%E7%9A%84%E7%BB%8F%E5%8E%86%E3%80%82"><span class="toc-text">原有计划发生重大变化的经历。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E5%88%86%E6%AD%A7"><span class="toc-text">出现分歧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E4%B8%B4%E7%9A%84%E5%A4%8D%E6%9D%82%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E3%80%81%E6%8F%90%E5%87%BA%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E7%9A%84%E3%80%82"><span class="toc-text">面临的复杂问题，如何快速定位问题、提出解决思路的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-%E7%AB%9E%E4%BA%89%E5%8A%9B"><span class="toc-text">优缺点 竞争力</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%8E%A5%E8%A7%A6%E5%89%8D%E7%AB%AF%E7%9A%84-%E4%B8%BA%E5%95%A5%E5%AD%A6%E5%89%8D%E7%AB%AF"><span class="toc-text">你什么时候接触前端的&#x2F;为啥学前端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%8E%E5%B8%82"><span class="toc-text">城市</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B1%E5%A5%BD"><span class="toc-text">爱好</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B6%E5%BA%AD-%E5%8D%95%E8%BA%AB"><span class="toc-text">家庭&#x2F;单身</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E7%8F%AD"><span class="toc-text">加班</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%91%E7%A0%94"><span class="toc-text">科研</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%B9%A0"><span class="toc-text">实习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9"><span class="toc-text">难点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%E4%B8%8E%E4%B8%8D%E8%B6%B3"><span class="toc-text">收获与不足</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF"><span class="toc-text">微前端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">相关概念</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE"><span class="toc-text">项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android%E8%AF%8D%E5%85%B8"><span class="toc-text">Android词典</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E7%88%AC%E5%8F%96"><span class="toc-text">单词数据的爬取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1"><span class="toc-text">界面设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#API%E6%88%96SDK"><span class="toc-text">API或SDK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVVM"><span class="toc-text">MVVM</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Android-MVC"><span class="toc-text">Android MVC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Android-MVVM"><span class="toc-text">Android MVVM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E2%98%85"><span class="toc-text">商城后台管理系统★</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E8%82%A1"><span class="toc-text">八股</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80"><span class="toc-text">语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AF%94"><span class="toc-text">其他语言对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB-vs-%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-text">基于类 vs 基于原型的语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Js%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88"><span class="toc-text">Js中的堆栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%8C%BA"><span class="toc-text">栈区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%8C%BA"><span class="toc-text">堆区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-text">引用计数算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">标记清除算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1"><span class="toc-text">7+1</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">模块化、组件化、工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">工程化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="toc-text">组件化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E5%A5%BD%E5%A4%84"><span class="toc-text">框架好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-vs-JS"><span class="toc-text">TS vs JS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git"><span class="toc-text">Git</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E5%91%BD%E5%90%8D"><span class="toc-text">分支命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="toc-text">版本控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3"><span class="toc-text">冲突解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-text">队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-text">树结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-text">常见算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%B3%95"><span class="toc-text">哈希法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-text">二分法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">双指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0"><span class="toc-text">URL输入到页面展现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">TCP三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E2%98%85"><span class="toc-text">TCP四次挥手 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS"><span class="toc-text">HTTP和HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E8%BF%9E%E6%8E%A5"><span class="toc-text">HTTPS连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1%E3%80%81HTTP-2%E3%80%81HTTP-3%E6%BC%94%E5%8F%98"><span class="toc-text">HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3演变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-1"><span class="toc-text">HTTP&#x2F;1.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-2"><span class="toc-text">HTTP&#x2F;2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-3"><span class="toc-text">HTTP&#x2F;3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-text">TCP</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/66c016fb.html" title="JVM"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/13.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="JVM"></a><div class="content"><a class="title" href="/posts/66c016fb.html" title="JVM">JVM</a><time datetime="2022-10-07T06:46:20.000Z" title="发表于 2022-10-07 14:46:20">2022-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ff54bd4f.html" title="JS垃圾回收"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/9.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="JS垃圾回收"></a><div class="content"><a class="title" href="/posts/ff54bd4f.html" title="JS垃圾回收">JS垃圾回收</a><time datetime="2022-10-07T03:01:02.000Z" title="发表于 2022-10-07 11:01:02">2022-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f7ede91d.html" title="Java基础"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/4.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="Java基础"></a><div class="content"><a class="title" href="/posts/f7ede91d.html" title="Java基础">Java基础</a><time datetime="2022-10-01T08:46:40.000Z" title="发表于 2022-10-01 16:46:40">2022-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f0caaae4.html" title="TS中那些奇怪的符号"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/3.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="TS中那些奇怪的符号"></a><div class="content"><a class="title" href="/posts/f0caaae4.html" title="TS中那些奇怪的符号">TS中那些奇怪的符号</a><time datetime="2022-07-10T03:12:48.000Z" title="发表于 2022-07-10 11:12:48">2022-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6155a9d6.html" title="Axios"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/10.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="Axios"></a><div class="content"><a class="title" href="/posts/6155a9d6.html" title="Axios">Axios</a><time datetime="2022-07-05T08:42:42.000Z" title="发表于 2022-07-05 16:42:42">2022-07-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Leslie Waong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:""},null))},e=()=>{twikoo.getCommentsCount({envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))},n=(n=!1)=>{"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})};btf.loadComment(document.getElementById("twikoo-wrap"),n)})()</script></div><div class="aplayer no-destroy" data-id="6995412795" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="auto" data-autoplay="true" muted></div><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":0,"vOffset":0},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body></html>