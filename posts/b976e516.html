<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>算法题（JS） | Leslie Waong</title><meta name="keywords" content="JS,算法,Letcode,CodeTop"><meta name="author" content="Leslie Waong"><meta name="copyright" content="Leslie Waong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="根据代码随想录和其他网上解法整理  算法性能分析时间复杂度时间复杂度是一个函数，它定性描述该算法的运行时间。 我们在软件开发中，时间复杂度就是用来方便开发者估算出程序运行的答题时间。 那么该如何估计程序运行时间呢，通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认CPU的每个单元运行消耗的时间都是相同的。 假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增"><meta property="og:type" content="article"><meta property="og:title" content="算法题（JS）"><meta property="og:url" content="https://lesliewaong.top/posts/b976e516.html"><meta property="og:site_name" content="Leslie Waong"><meta property="og:description" content="根据代码随想录和其他网上解法整理  算法性能分析时间复杂度时间复杂度是一个函数，它定性描述该算法的运行时间。 我们在软件开发中，时间复杂度就是用来方便开发者估算出程序运行的答题时间。 那么该如何估计程序运行时间呢，通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认CPU的每个单元运行消耗的时间都是相同的。 假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s4.ax1x.com/2021/12/17/Ti4Oq1.jpg"><meta property="article:published_time" content="2021-07-13T02:37:47.000Z"><meta property="article:modified_time" content="2022-03-16T09:52:30.279Z"><meta property="article:author" content="Leslie Waong"><meta property="article:tag" content="JS"><meta property="article:tag" content="算法"><meta property="article:tag" content="Letcode"><meta property="article:tag" content="CodeTop"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s4.ax1x.com/2021/12/17/Ti4Oq1.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg"><link rel="canonical" href="https://lesliewaong.top/posts/b976e516"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"一年之内的产物",messageNext:"技术可能存在过期"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Leslie Waong",link:"链接: ",source:"来源: Leslie Waong",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"算法题（JS）",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-03-16 17:52:30"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px");const a=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};a(),document.addEventListener("pjax:complete",a)})(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Leslie Waong" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">95</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://s4.ax1x.com/2021/12/17/Ti4Oq1.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leslie Waong</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法题（JS）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-13T02:37:47.000Z" title="发表于 2021-07-13 10:37:47">2021-07-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-16T09:52:30.279Z" title="更新于 2022-03-16 17:52:30">2022-03-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">32.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>120分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="算法题（JS）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote><p>根据代码随想录和其他网上解法整理</p></blockquote><h1 id="算法性能分析"><a href="#算法性能分析" class="headerlink" title="算法性能分析"></a>算法性能分析</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><strong>时间复杂度是一个函数，它定性描述该算法的运行时间</strong>。</p><p>我们在软件开发中，时间复杂度就是用来方便开发者估算出程序运行的答题时间。</p><p>那么该如何估计程序运行时间呢，通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认CPU的每个单元运行消耗的时间都是相同的。</p><p>假设算法的<strong>问题规模为n</strong>，那么操作单元数量便用函数<strong>f(n)<strong>来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的</strong>渐近时间复杂度</strong>，简称时间复杂度，记为 **O(f(n))**。</p><h3 id="什么是大O"><a href="#什么是大O" class="headerlink" title="什么是大O"></a>什么是大O</h3><p>这里的大O是指什么呢，说到时间复杂度，<strong>大家都知道O(n)，O(n^2)，却说不清什么是大O</strong>。</p><p>算法导论给出的解释：<strong>大O用来表示上界的</strong>，当用它作为算法的<strong>最坏情况</strong>运行时间的上界，就是对任意数据输入的运行时间的上界。</p><p>同样算法导论给出了例子：拿插入排序来说，插入排序的时间复杂度我们都说是O(n^2) 。</p><p>输入数据的形式对程序运算时间是有很大影响的，在数据本来有序的情况下时间复杂度是O(n)，但如果数据是逆序的话，插入排序的时间复杂度就是O(n^2)，也就对于所有输入情况来说， 最坏是O(n^2) 的时间复杂度，所以称插入排序的时间复杂度为O(n^2)。</p><p>同样的同理再看一下快速排序，都知道快速排序是O(nlogn)，但是当数据已经有序情况下，快速排序的时间复杂度是O(n^2) 的，**所以严格从大O的定义来讲，快速排序的时间复杂度应该是O(n^2)**。</p><p><strong>但是我们依然说快速排序是O(nlogn)的时间复杂度，这个就是业内的一个默认规定，这里说的O代表的就是一般情况，而不是严格的上界</strong>。</p><p>我们主要关心的还是<strong>一般情况</strong>下的数据形式。</p><p><strong>面试中说道算法的时间复杂度是多少指的都是一般情况</strong>。但是如果面试官和我们深入探讨一个算法的实现以及性能的时候，就要时刻想着数据用例的不一样，时间复杂度也是不同的，这一点是一定要注意的。</p><h3 id="不同数据规模的差异"><a href="#不同数据规模的差异" class="headerlink" title="不同数据规模的差异"></a>不同数据规模的差异</h3><p>在决定使用哪些算法的时候，不是时间复杂越低的越好（因为简化后的时间复杂度忽略了常数项等等），要考虑数据规模，如果数据规模很小甚至可以用O(n^2)的算法比O(n)的更合适（<strong>在有常数项的时候</strong>）。</p><p>那为什么在计算时间复杂度的时候要忽略常数项系数呢，也就说O(100n) 就是O(n)的时间复杂度，O(5n^2) 就是O(n^2)的时间复杂度，而且要默认O(n) 优于O(n^2) 呢 ？</p><p>这里就又涉及到大O的定义，<strong>因为大O就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量</strong>。</p><p><strong>所以我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示</strong>：</p><p><code>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(n^2)平方阶 &lt; O(n^3)(立方阶) &lt; O(2^n) (指数阶)</code></p><p>但是也要注意<strong>大常数</strong>，如果这个常数非常大，例如10^7 ，10^9 ，那么常数就是不得不考虑的因素了。</p><h3 id="复杂表达式的化简"><a href="#复杂表达式的化简" class="headerlink" title="复杂表达式的化简"></a>复杂表达式的化简</h3><p>有时候我们去计算时间复杂度的时候发现不是一个简单的O(n) 或者O(n^2)， 而是一个复杂的表达式，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(<span class="number">2</span>*n^<span class="number">2</span> + <span class="number">10</span>*n + <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>那这里如何描述这个算法的时间复杂度呢，一种方法就是<strong>简化法</strong>。</p><p>去掉运行时间中的加法常数项 （因为常数项并不会因为n的增大而增加计算机的操作次数）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(<span class="number">2</span>*n^<span class="number">2</span> + <span class="number">10</span>*n)</span><br></pre></td></tr></table></figure><p>去掉常数系数（上文中已经详细讲过为什么可以去掉常数项的原因）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(n^<span class="number">2</span> + n)</span><br></pre></td></tr></table></figure><p>只保留保留最高项，去掉数量级小一级的n （因为n^2 的数据规模远大于n），最终简化为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(n^<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>如果这一步理解有困难，那也可以做提取n的操作，变成O(n(n+1)) ，省略加法常数项后也就别变成了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(n^<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>所以最后我们说：这个算法的算法时间复杂度是O(n^2) 。</p><h3 id="O-logn-中的log是以什么为底？"><a href="#O-logn-中的log是以什么为底？" class="headerlink" title="O(logn)中的log是以什么为底？"></a>O(logn)中的log是以什么为底？</h3><p>平时说这个算法的时间复杂度是logn的，那么一定是log 以2为底n的对数么？</p><p>其实不然，也可以是以10为底n的对数，也可以是以20为底n的对数，<strong>但我们统一说 logn，也就是忽略底数的描述</strong>。</p><p>假如有两个算法的时间复杂度，分别是log以2为底n的对数和log以10为底n的对数，那么这里如果还记得高中数学的话，应该不难理解<code>以2为底n的对数 = 以2为底10的对数 * 以10为底n的对数</code>。</p><p>而<strong>以2为底10的对数是一个常数</strong>，在上文已经讲述了我们计算时间复杂度是忽略常数项系数的。</p><p>抽象一下就是在时间复杂度的计算过程中，log以i为底n的对数等于log 以j为底n的对数，所以忽略了i，直接说是logn。</p><p>这样就应该不难理解为什么忽略底数了。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度是对一个算法在运行过程中占用内存空间大小的量度，记做S(n)=O(f(n)。</p><p>空间复杂度(Space Complexity)记作S(n) 依然使用大O来表示。利用程序的空间复杂度，可以对程序运行中需要多少内存有个预先估计。</p><p>关注空间复杂度有两个常见的相关问题</p><ul><li>空间复杂度是考虑程序（可执行文件）的大小么？</li></ul><p>​ 很多同学都会混淆程序运行时内存大小和程序本身的大小。这里强调一下<strong>空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。</strong></p><ul><li>空间复杂度是准确算出程序运行时所占用的内存么？</li></ul><p>​ 不要以为空间复杂度就已经精准的掌握了程序的内存使用大小，很多因素会影响程序真正内存使用大小，例如编译器的内存对齐，编程语言容器的底层实现等等这些都会影响到程序内存的开销。</p><p>所以空间复杂度是预先大体评估程序内存使用的大小。</p><p>说到空间复杂度，我想同学们在OJ（online judge）上应该遇到过这种错误，就是超出内存限制，一般OJ对程序运行时的所消耗的内存都有一个限制。</p><p>为了避免内存超出限制，这也需要我们对算法占用多大的内存有一个大体的预估。</p><p>同样在工程实践中，计算机的内存空间也不是无限的，需要工程师对软件运行时所使用的内存有一个大体评估，这都需要用到算法空间复杂度的分析。</p><p>来看一下例子，什么时候的空间复杂度是O(1)呢，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一段代码可以看出，随着n的变化，所需开辟的内存空间并不会随着n的变化而变化。即此算法空间复杂度为一个常量，所以表示为大 O(1)。</p><p>什么时候的空间复杂度是O(n)？</p><p>**当消耗空间和输入参数n保持线性增长，这样的空间复杂度为O(n)**，来看一下这段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个数组出来，这个数组占用的大小为n，虽然有一个for循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，随着n的增大，开辟的内存大小呈线性增长，即 O(n)。</p><p>其他的 O(n^2)， O(n^3) 我想大家应该都可以以此例举出来了，<strong>那么思考一下 什么时候空间复杂度是 O(logn)呢？</strong></p><p>空间复杂度是logn的情况确实有些特殊，其实是在<strong>递归的时候，会出现空间复杂度为logn的情况</strong>。</p><h2 id="递归算法的时间与空间复杂度分析！"><a href="#递归算法的时间与空间复杂度分析！" class="headerlink" title="递归算法的时间与空间复杂度分析！"></a>递归算法的时间与空间复杂度分析！</h2><p>先来看一下求斐波那契数的递归写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fibonacci= <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(i &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> fibonacci(i-<span class="number">1</span>) + fibonacci(i-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于递归算法来说，代码一般都比较简短，从算法逻辑上看，所用的存储空间也非常少，但运行时需要内存可不见得会少。</p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>来看看这个求斐波那契的递归算法的时间复杂度是多少呢？</p><p>在讲解递归时间复杂度的时候，我们提到了递归算法的时间复杂度本质上是要看: <strong>递归的次数 * 每次递归的时间复杂度</strong>。</p><p>可以看出上面的代码每次递归都是O(1)的操作。再来看递归了多少次，这里将i为5作为输入的递归过程 抽象成一颗递归树，如图：</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/obdrKH"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2021/12/12/obdrKH.png" alt="obdrKH.png"></a></p><p>从图中，可以看出f(5)是由f(4)和f(3)相加而来，那么f(4)是由f(3)和f(2)相加而来 以此类推。</p><p>在这颗二叉树中每一个节点都是一次递归，那么这棵树有多少个节点呢？</p><p>我们之前也有说到，一棵深度（按根节点深度为1）为k的二叉树最多可以有 2^（k - 1 ）个节点。</p><p>所以该递归算法的时间复杂度为 O(2^n) ，这个复杂度是非常大的，随着n的增大，耗时是指数上升的。</p><h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><p>说完了这段递归代码的时间复杂度，再看看如何求其空间复杂度呢，这里给大家提供一个公式：<strong>递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度</strong></p><p>为什么要求递归的深度呢？</p><p>因为每次递归所需的空间都被压到调用栈里（这是内存管理里面的数据结构，和算法里的栈原理是一样的），一次递归结束，这个栈就是就是把本次递归的数据弹出去。所以这个栈最大的长度就是递归的深度。</p><p>此时可以分析这段递归的空间复杂度，从代码中可以看出每次递归所需要的空间大小都是一样的，所以每次递归中需要的空间是一个常量，并不会随着n的变化而变化，每次递归的空间复杂度就是O(1)。</p><p>在看递归的深度是多少呢？如图所示：</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/obwRm9"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2021/12/12/obwRm9.png" alt="obwRm9.png"></a></p><p>递归第n个斐波那契数的话，递归调用栈的深度就是n。</p><p>那么每次递归的空间复杂度是O(1)， 调用栈深度为n，所以这段递归代码的空间复杂度就是O(n)。</p><h1 id="赛码网OJ"><a href="#赛码网OJ" class="headerlink" title="赛码网OJ"></a>赛码网OJ</h1><p><a target="_blank" rel="noopener" href="https://labfiles.acmcoder.com/ojhtml/index.html#/?id=%e6%80%bb%e4%bd%93%e8%af%b4%e6%98%8e">赛码网OJ</a></p><h2 id="输入API"><a href="#输入API" class="headerlink" title="输入API"></a>输入API</h2><h3 id="读取一行输入"><a href="#读取一行输入" class="headerlink" title="读取一行输入"></a>读取一行输入</h3><p><code>read_line()</code></p><p>将读取至多1024个<strong>字符</strong>，当还未达到1024个时如果遇到回车或结束符，提前结束。</p><p>读取多行最简单的办法是<code>while((line = read_line()) != &#39;&#39;)</code>。</p><p>或者使用下一个API。</p><h3 id="读取n个字符"><a href="#读取n个字符" class="headerlink" title="读取n个字符"></a>读取n个字符</h3><p><code>gets(n)</code></p><p>将读取至多n个<strong>字符</strong>，当还未达到n个时如果遇到回车或结束符，会提前结束。</p><p>回车符可能会包含在返回值中。</p><h3 id="读取一个（长）整数"><a href="#读取一个（长）整数" class="headerlink" title="读取一个（长）整数"></a>读取一个（长）整数</h3><p><code>readInt()</code></p><h3 id="读取一个浮点型"><a href="#读取一个浮点型" class="headerlink" title="读取一个浮点型"></a>读取一个浮点型</h3><p><code>readDouble()</code></p><h2 id="输出API"><a href="#输出API" class="headerlink" title="输出API"></a>输出API</h2><h3 id="不加回车的输出"><a href="#不加回车的输出" class="headerlink" title="不加回车的输出"></a>不加回车的输出</h3><p><code>printsth(sth, ...)</code></p><p>往控制台输出sth，当有多个参数时，空格分隔；最后不加回车。</p><h3 id="带回车的输出"><a href="#带回车的输出" class="headerlink" title="带回车的输出"></a>带回车的输出</h3><p><code>print(sth, ...)</code></p><p><code>console.log(sth, ...)</code></p><p>往控制台输出sth，当有多个参数时，空格分隔；最后加回车。</p><h2 id="示例代码1"><a href="#示例代码1" class="headerlink" title="示例代码1"></a>示例代码1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"><span class="keyword">var</span> solveMeFirst = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b;</span><br><span class="line"><span class="keyword">while</span>((a=readInt())!=<span class="literal">null</span> &amp;&amp; (b=readInt())!=<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> c = solveMeFirst(a, b);</span><br><span class="line">    print(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例代码2"><a href="#示例代码2" class="headerlink" title="示例代码2"></a>示例代码2</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> line;</span><br><span class="line"><span class="keyword">var</span> solveMeFirst = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b;</span><br><span class="line"><span class="keyword">while</span>((line = read_line()) != <span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = line.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">parseInt</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">parseInt</span>(arr[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">let</span> c = solveMeFirst(a, b);</span><br><span class="line">    print(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上台阶测试"><a href="#上台阶测试" class="headerlink" title="上台阶测试"></a>上台阶测试</h2><p><strong>时间限制：</strong> 3000MS<br><strong>内存限制：</strong> 589824KB</p><p><strong>题目描述：</strong></p><p>有一楼梯共m级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第m级，共有多少走法？注：规定从<strong>一级到一级有0种</strong>走法。</p><blockquote><p>输入描述</p></blockquote><p>输入数据首先包含一个整数n(1&lt;=n&lt;=100)，表示测试实例的个数，然后是n行数据，每行包含一个整数m，（1&lt;=m&lt;=40), 表示楼梯的级数。</p><blockquote><p>输出描述</p></blockquote><p>对于每个测试实例，请输出不同走法的数量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> climb = <span class="function"><span class="params">n</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">1</span>,cur=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = cur;</span><br><span class="line">    cur=cur+pre;</span><br><span class="line">    pre=temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> n = <span class="built_in">parseInt</span>(read_line());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">  <span class="keyword">let</span> input = <span class="built_in">parseInt</span>(read_line());</span><br><span class="line">  <span class="built_in">console</span>.log(climb(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h1><p>与赛码网类似</p><p>但输入是<code>readline()</code></p><h2 id="最长公共前缀测试"><a href="#最长公共前缀测试" class="headerlink" title="最长公共前缀测试"></a>最长公共前缀测试</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> strs = readline().split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> longestCommonPrefix =<span class="function"><span class="params">strs</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = strs.length;</span><br><span class="line">    <span class="comment">// 字符串数组为空</span></span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 初始化最长公共前缀为第一个字符串</span></span><br><span class="line">    <span class="keyword">let</span> ans = strs[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 与其他字符串两两相比，不断截取以得到最长公共前缀</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> j=<span class="number">0</span>;<span class="comment">// 放在for循环外面是因为字符串长度不一致</span></span><br><span class="line">        <span class="keyword">for</span>(;j&lt;ans.length &amp;&amp; j &lt; strs[i].length;j++) &#123;</span><br><span class="line">            <span class="comment">// 字符串也可以用[]进行字符访问</span></span><br><span class="line">            <span class="keyword">if</span>(ans[j] !== strs[i][j])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从0索引开始截取j个 </span></span><br><span class="line">        ans = ans.substr(<span class="number">0</span>, j); </span><br><span class="line">        <span class="comment">// 最长公共前缀变为&quot;&quot;就提前返回</span></span><br><span class="line">        <span class="keyword">if</span>(ans===<span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(longestCommonPrefix(strs));</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>英文：Dynamic Programming，简称<strong>DP</strong>，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的。</p><blockquote><p>动态规划问题五步曲</p></blockquote><ol><li>确定<strong>dp数组（dp table）</strong>以及<strong>下标</strong>的含义</li><li>确定<strong>递推公式</strong></li><li>dp数组如何<strong>初始化</strong></li><li>确定<strong>遍历顺序</strong></li><li><strong>举例</strong>推导dp数组</li></ol><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><p><code>F(0) = 0, F(1) = 1</code></p><p><code>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</code></p><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要<strong>取模 1e9+7（1000000007）</strong>，如计算初始结果为：1000000008，请返回 1。</p><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="递归（超时）"><a href="#递归（超时）" class="headerlink" title="递归（超时）"></a>递归（超时）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> fib = <span class="function"><span class="params">n</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> MOD=<span class="number">1000000007</span>;<span class="comment">//用来取模</span></span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> (fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>))%MOD;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><ol><li>确定dp数组以及下标的含义</li></ol><p>​ dp[i]的定义为：<strong>第i个数的斐波那契数值是dp[i]</strong></p><ol start="2"><li>确定递推公式</li></ol><p>​ 题目已经把递推公式直接给我们了：状态转移方程 <code>dp[i] = dp[i - 1] + dp[i - 2]</code>;</p><ol start="3"><li>dp数组如何初始化</li></ol><p>​ 题目中把如何初始化也直接给我们了，如下：<code>dp[0] = 0; dp[1] = 1;</code></p><ol start="4"><li>确定遍历顺序</li></ol><p>​ 从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，<strong>dp[i]是依赖 dp[i - 1] 和 dp[i - 2]<strong>，那么遍历的顺序一定是</strong>从前到后</strong>遍历的</p><ol start="5"><li>举例推导dp数组</li></ol><p>​ 按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p><p>​ <code>0 1 1 2 3 5 8 13 21 34 55</code></p><p>​ 如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> fib = <span class="function"><span class="params">n</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// dp[i]=dp[i-1]+dp[i-2]</span></span><br><span class="line">    <span class="comment">// dp[0]=0,dp[1]=1</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n+<span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i]=(dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>])%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p>不需要保存所有的dp值，用两个变量保存过去的状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> fib = <span class="function"><span class="params">n</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> MOD=<span class="number">1000000007</span>;<span class="comment">//用来取模</span></span><br><span class="line">    <span class="comment">// dp[i]=dp[i-1]+dp[i-2]</span></span><br><span class="line">    <span class="comment">// dp[0]=0,dp[1]=1</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// 不需要保存所有的dp值，用两个变量保存过去的状态</span></span><br><span class="line">    <span class="keyword">let</span> pre=<span class="number">0</span>,cur=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">// 创建临时变量保存这次的dp[i-1]</span></span><br><span class="line">        <span class="keyword">let</span> temp =cur;</span><br><span class="line">        <span class="comment">// 更新dp[i-1]和dp[i-2]</span></span><br><span class="line">        cur = (cur+pre)%MOD;</span><br><span class="line">        pre =temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="爬楼梯-动态规划-⭐"><a href="#爬楼梯-动态规划-⭐" class="headerlink" title="爬楼梯(动态规划)⭐"></a>爬楼梯(动态规划)⭐</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><blockquote><p>示例</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入： <span class="number">2</span></span><br><span class="line">输出： <span class="number">2</span></span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">2</span> 阶</span><br><span class="line"></span><br><span class="line">输入： <span class="number">3</span></span><br><span class="line">输出： <span class="number">3</span></span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span>  <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><h4 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> climbStairs = <span class="function"><span class="params">n</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// dp</span></span><br><span class="line">    <span class="comment">// 爬到第i阶台阶,需要先爬到i-1或i-2阶</span></span><br><span class="line">    <span class="comment">// dp[i] = dp[i-1]+dp[i-2]</span></span><br><span class="line">    <span class="comment">// dp[0]=1,dp[1]=1</span></span><br><span class="line">    <span class="comment">// 不需要保存所有dp，用变量代替</span></span><br><span class="line">    <span class="keyword">let</span> pre=<span class="number">1</span>,cur=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 题目规定n&gt;=1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = cur;</span><br><span class="line">        cur=cur+pre;</span><br><span class="line">        pre=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> numWays = <span class="function"><span class="params">n</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// dp </span></span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">1</span> ,cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> temp = cur;</span><br><span class="line">        cur = (pre+cur) % <span class="number">1000000007</span>;</span><br><span class="line">        pre=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最大子数组和-动态规划-⭐"><a href="#最大子数组和-动态规划-⭐" class="headerlink" title="最大子数组和(动态规划)⭐"></a>最大子数组和(动态规划)⭐</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个<strong>连续</strong>部分。</p><p>示例 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：连续子数组 [<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span> 。</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">23</span></span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">10</span>^<span class="number">5</span></span><br><span class="line">-<span class="number">10</span>^<span class="number">4</span> &lt;= nums[i] &lt;= <span class="number">10</span>^<span class="number">4</span></span><br></pre></td></tr></table></figure><p>进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><h4 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h4><p>解题思路：</p><p>示例: [a, b , c, d , e]</p><p>解答这类题目, 省略不掉遍历, 因此我们先从遍历方式说起</p><p>通常我们遍历子串或者子序列有三种遍历方式</p><ul><li><p><strong>以某个节点为开头</strong>的所有子序列: 如 [a]，[a, b]，[ a, b, c] … 再从以 b 为开头的子序列开始遍历 [b] [b, c]。</p></li><li><p>根据<strong>子序列的长度</strong>为标杆，如先遍历出子序列长度为 1 的子序列，在遍历出长度为 2 的 等等。</p></li><li><p><strong>以子序列的结束节点为基准</strong>，先遍历出以某个节点为结束的所有子序列，因为每个节点都可能会是子序列的结束节点，因此要遍历下整个序列，如: 以 b 为结束点的所有子序列: [a , b]、[b] ;以 c 为结束点的所有子序列: [a, b, c]、[b, c]、[ c ]。</p></li></ul><p>第一种遍历方式通常用于<strong>暴力</strong>解法, 第二种遍历方式 leetcode (5. 最长回文子串 ) 中的解法就用到了。</p><p><strong>第三种遍历方式 因为可以产生递推关系, 采用动态规划时, 经常通过此种遍历方式, 如 背包问题, 最大公共子串 , 这里的动态规划解法也是以先遍历出以某个节点为结束节点的所有子序列的思路</strong>。</p><p>因为我们通常的惯性思维是以子序列的开头为基准，先遍历出以 a 为开头的所有子序列，再遍历出以 b 为开头的…但是动态规划为了找到不同子序列之间的递推关系，恰恰是以子序列的结束点为基准的，这点开阔了我们的思路。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> maxSubArray = <span class="function"><span class="params">nums</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// dp[i] 以i结束的最大子数组和</span></span><br><span class="line">    <span class="comment">// dp[i] = max(dp[i - 1] + nums[i], nums[i])</span></span><br><span class="line">    <span class="comment">// dp[0] = nums[0]</span></span><br><span class="line">    <span class="comment">// 没有必要存下所有计算过的dp项。用变量sum去存过去的状态就好</span></span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">let</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> ans = sum; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        sum = <span class="built_in">Math</span>.max(sum+nums[i], nums[i]);</span><br><span class="line">        <span class="comment">// sum = sum+nums[i]&gt;nums[i] ? sum+nums[i]:nums[i];</span></span><br><span class="line">        <span class="comment">// sum = sum&gt;0 ? sum+nums[i]:nums[i];</span></span><br><span class="line">        ans = <span class="built_in">Math</span>.max(ans,sum);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>允许<strong>翻转一段子数组</strong>后的最大子数组和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxSubArray = <span class="function"><span class="params">nums</span>=&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">let</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;l-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 以i结束的最大子数组和</span></span><br><span class="line">        sum1 = <span class="built_in">Math</span>.max(sum1+nums[i], nums[i]);</span><br><span class="line">        <span class="comment">// i+1~l内遍历所有子数组和，与以i结束的最大子数组和相加取最大即为所求</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;l;j++) &#123;</span><br><span class="line">            sum2=<span class="built_in">Math</span>.max(sum2+nums[j], nums[j]);</span><br><span class="line">            ans = <span class="built_in">Math</span>.max(ans, sum1+sum2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>前后dp简化</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxSubArray3 = <span class="function"><span class="params">nums</span>=&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">let</span> ans = nums[<span class="number">0</span>],sum1 = [...nums],sum2 = [...nums],sum3 = [...nums];</span><br><span class="line">    <span class="comment">// 从后向前，sum2[i]第i个开始的最大子数组和</span></span><br><span class="line">    <span class="comment">// sum2[i]=max(nums[i]+sum2[i+1],nums[i])</span></span><br><span class="line">    <span class="comment">// sum2[n-1]=nums[n-1]</span></span><br><span class="line">    <span class="comment">// sum3[i] 区间[i,n-1]内的最大子数组和</span></span><br><span class="line">    <span class="comment">// sum3[i]=max(sum3[i+1], sum2[i]);</span></span><br><span class="line">    <span class="comment">// sum3[n-1]=nums[n-1]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=n-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        sum2[i]=<span class="built_in">Math</span>.max(sum2[i+<span class="number">1</span>]+nums[i], nums[i]);</span><br><span class="line">        sum3[i]=<span class="built_in">Math</span>.max(sum3[i+<span class="number">1</span>], sum2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从前向后，sum1[i] 第i个结束的最大子数组和</span></span><br><span class="line">    <span class="comment">// sum1[i] = max(sum1[i-1]+nums[i], nums[i]);</span></span><br><span class="line">    <span class="comment">// 区间[i,n-1]的最大子数组可以通过一次翻转移过去</span></span><br><span class="line">    <span class="comment">// 以i-1结束的最大子序和+区间i到n-1内的最大子序列和，即为所求</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n-<span class="number">1</span>;i++) &#123;    </span><br><span class="line">        sum1[i] = <span class="built_in">Math</span>.max(sum1[i-<span class="number">1</span>]+nums[i], nums[i]);</span><br><span class="line">        ans = <span class="built_in">Math</span>.max(ans, sum1[i-<span class="number">1</span>]+sum3[i]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p><p><strong>刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心</strong>。</p><h2 id="买卖股票的最佳时机（贪心、动态规划）⭐"><a href="#买卖股票的最佳时机（贪心、动态规划）⭐" class="headerlink" title="买卖股票的最佳时机（贪心、动态规划）⭐"></a>买卖股票的最佳时机（贪心、动态规划）⭐</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span>-<span class="number">1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span>-<span class="number">1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 10^5</code></li><li><code>0 &lt;= prices[i] &lt;= 10^4</code></li></ul><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><h4 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h4><p><strong>局部最优</strong>：卖出股票时保证是在最低价格买入。</p><p><strong>全局最优</strong>：对每一天卖出股票得到的最大利润遍历比较。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">prices</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> maxProfit = <span class="function"><span class="params">prices</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 贪心</span></span><br><span class="line">    <span class="comment">// 局部最优：卖出股票时保证是在最低价格买入</span></span><br><span class="line">    <span class="comment">// 全局最优：对每一天卖出股票得到的最大利润遍历比较</span></span><br><span class="line">    <span class="keyword">const</span> n= prices.length;</span><br><span class="line">    <span class="keyword">let</span> ans =<span class="number">0</span>,minPrice=prices[<span class="number">0</span>];</span><br><span class="line">     <span class="comment">// 无论哪天卖掉股票，都要保证我是在价格最低时买入的。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        minPrice = <span class="built_in">Math</span>.min(minPrice,prices[i-<span class="number">1</span>]);<span class="comment">// 卖出股票前的最低价格</span></span><br><span class="line">        <span class="comment">// prices[i]-minPrice即为当天卖出所能得到的最大利润</span></span><br><span class="line">        <span class="comment">// 遍历所有情况即可得到哪一天卖出可以得到最大利润</span></span><br><span class="line">        ans = <span class="built_in">Math</span>.max(prices[i]-minPrice,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 prices ，其中 <strong>prices[i]</strong> 是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（<strong>多次买卖一支股票</strong>）。</p><p>注意：你<strong>不能同时参与多笔交易</strong>（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= prices.length &lt;= <span class="number">3</span> * <span class="number">10</span>^<span class="number">4</span></span><br><span class="line"><span class="number">0</span> &lt;= prices[i] &lt;= <span class="number">10</span>^<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><h4 id="贪心-2"><a href="#贪心-2" class="headerlink" title="贪心"></a>贪心</h4><p>将每一天与前一天价格比较，有利润的话，前一天买，当天卖。</p><p>局部最优：收集每天的正利润。</p><p>全局最优：累加获得最大利润。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">prices</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> maxProfit = <span class="function"><span class="params">prices</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 贪心 </span></span><br><span class="line">    <span class="comment">// 将每一天与前一天价格比较</span></span><br><span class="line">    <span class="comment">// 有利润的话，前一天买,当天卖</span></span><br><span class="line">    <span class="comment">// 局部最优：收集每天的正利润</span></span><br><span class="line">    <span class="comment">// 全局最优：累加获得最大利润</span></span><br><span class="line">    <span class="keyword">let</span> profit = <span class="number">0</span>;<span class="comment">//收益</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">        <span class="comment">// 今天和昨天的差价大于0，就昨天买，今天卖，赚差价</span></span><br><span class="line">        profit += <span class="built_in">Math</span>.max(prices[i]-prices[i-<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p><p>回溯是递归的副产品，只要有递归就会有回溯。</p><p><strong>回溯函数也就是递归函数，指的都是一个函数</strong>。</p><blockquote><p>回溯法解决的问题</p></blockquote><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合。</li><li>切割问题：一个字符串按一定规则有几种切割方式。</li><li>子集问题：一个N个数的集合里有多少符合条件的子集。</li><li>排列问题：N个数按一定规则<strong>全排列</strong>，有几种排列方式。</li><li>棋盘问题：N皇后，解数独等等。</li></ul><p>组合无序，排列有序。</p><blockquote><p>如何理解回溯法</p></blockquote><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>！</p><p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度构成的树的深度</strong>。</p><blockquote><p>回溯法模板</p></blockquote><ul><li><p>回溯函数模板参数</p></li><li><p>回溯函数终止条件</p></li><li><p>回溯搜索的遍历过程</p></li></ul><p>在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20210130173631174.png" alt="回溯算法理论基础"></p><p>注意图中，我特意举例集合大小和孩子的数量是相等的！</p><p>大家可以从图中看出<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p><p>分析完过程，回溯算法模板框架如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> backtracking= <span class="function">(<span class="params">参数</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><ul><li>递归函数参数</li></ul><p><strong>首先排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合</strong>。</p><p>但排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示:</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20201209174225145.png" alt="46.全排列"></p><ul><li>递归终止条件</li></ul><p>可以看出叶子节点，就是收割结果的地方。</p><p>那么什么时候，算是到达叶子节点呢？</p><p>当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。</p><ul><li>单层搜索的逻辑</li></ul><p>因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。</p><p><strong>而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> permute = <span class="function"><span class="params">nums</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 回溯</span></span><br><span class="line">    <span class="comment">// 关键在于每一次递归结束后都会回到上一层的递归函数</span></span><br><span class="line">    <span class="comment">// 所以，递归前处理节点，递归后撤销操作，就实现了回溯到之前状态</span></span><br><span class="line">    <span class="comment">// 注意，执行递归函数时，当前的for循环可能还没执行完</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = []; <span class="comment">// 结果</span></span><br><span class="line">    <span class="keyword">const</span> used = [];<span class="comment">// 记录使用过的元素</span></span><br><span class="line">    <span class="keyword">const</span> path =[];<span class="comment">// 收集元素的数组path</span></span><br><span class="line">    <span class="comment">// 根据闭包，内层函数可以拿到外层函数的参数</span></span><br><span class="line">    <span class="keyword">const</span> backtracking= <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="comment">// 当path的大小达到和nums一样大时，说明找到了一个全排列</span></span><br><span class="line">        <span class="keyword">if</span> (path.length === nums.length )&#123;</span><br><span class="line">            <span class="comment">//拷贝后放入res，后续对path的操作，就不会影响res</span></span><br><span class="line">            res.push([...path]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// used数组记录此时path里已有的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[num])<span class="keyword">continue</span>;<span class="comment">//使用过的，跳过</span></span><br><span class="line">            path.push(num);<span class="comment">// 没使用过的加入path</span></span><br><span class="line">            used[num]=<span class="literal">true</span>;<span class="comment">// 标记使用</span></span><br><span class="line">            backtracking(path);<span class="comment">// 递归</span></span><br><span class="line">            path.pop(); <span class="comment">//回溯，将最后选的数pop出来</span></span><br><span class="line">            used[num]=<span class="literal">false</span>; <span class="comment">// 撤销这个记录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking();<span class="comment">//递归入口</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="合并两个有序数组（直接、双指针、逆向双指针）⭐"><a href="#合并两个有序数组（直接、双指针、逆向双指针）⭐" class="headerlink" title="合并两个有序数组（直接、双指针、逆向双指针）⭐"></a>合并两个有序数组（直接、双指针、逆向双指针）⭐</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>给你两个按<strong>非递减顺序</strong>排列的整数数组nums1和nums2，另有两个整数m和n，分别表示nums1和nums2中的元素数目。</p><p>请你合并nums2到nums1中，使合并后的数组同样按<strong>非递减顺序</strong>排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组<code>nums1</code>中。为了应对这种情况，nums1的初始长度为<code>m + n</code>，其中前m个元素表示应合并的元素，后n个元素为0 ，应忽略。nums2 的长度为 n 。</p><blockquote><p>示例 ：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span>, nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">输入：nums1 = [<span class="number">1</span>], m = <span class="number">1</span>, nums2 = [], n = <span class="number">0</span></span><br><span class="line">输出：[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输入：nums1 = [<span class="number">0</span>], m = <span class="number">0</span>, nums2 = [<span class="number">1</span>], n = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>提示：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums1.length == m + n</span><br><span class="line">nums2.length == n</span><br><span class="line"><span class="number">0</span> &lt;= m, n &lt;= <span class="number">200</span></span><br><span class="line"><span class="number">1</span> &lt;= m + n &lt;= <span class="number">200</span></span><br><span class="line">-<span class="number">10</span>^<span class="number">9</span> &lt;= nums1[i], nums2[j] &lt;= <span class="number">10</span>^<span class="number">9</span></span><br></pre></td></tr></table></figure><blockquote><p>进阶：</p></blockquote><p>你可以设计实现一个时间复杂度为 <strong>O(m + n)</strong> 的算法解决此问题吗？</p><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：直接合并后排序"><a href="#方法一：直接合并后排序" class="headerlink" title="方法一：直接合并后排序"></a>方法一：直接合并后排序</h4><p>最直观的方法是先将数组nums2 放进数组nums1的尾部，然后直接对整个数组进行排序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">nums1, m, nums2, n</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 直观解法</span></span><br><span class="line">    <span class="comment">// nums2放到nums1后面，再排序</span></span><br><span class="line">    nums1.splice(m,n,...nums2);</span><br><span class="line">    nums1.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);<span class="comment">//升序排序</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度分析</p></blockquote><p>时间复杂度：<code>O((m+n)log(m+n))</code>。<br>排序序列长度为 m+n，套用<strong>快速排序</strong>的时间复杂度即可，平均情况为 O((m+n)log(m+n))。</p><p>空间复杂度：<code>O(log(m+n))</code>。<br>排序序列长度为 m+n，套用快速排序的空间复杂度即可，平均情况为 O(log(m+n))。</p><h4 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h4><p>这一方法将两个数组看作队列，每次从两个数组头部取出比较小的数字放到结果中。</p><p>我们为两个数组分别设置一个指针p1与p2 来作为队列的头部指针。</p><p>但这种方法需要额外一个数组进行存储。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>，cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> sorted = <span class="keyword">new</span> <span class="built_in">Array</span>(m + n).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 === m) &#123;</span><br><span class="line">            cur = nums2[p2++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 === n) &#123;</span><br><span class="line">            cur = nums1[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">            cur = nums1[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = nums2[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        sorted[p1 + p2 - <span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i != m + n; ++i) &#123;</span><br><span class="line">        nums1[i] = sorted[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>复杂度分析</p></blockquote><p>时间复杂度：<code>O(m+n)</code>。<br>指针移动单调递增，最多移动m+n次，因此时间复杂度为O(m+n)。</p><p>空间复杂度：<code>O(m+n)</code>。<br>需要建立长度为m+n的中间数组sorted。</p><h4 id="方法三：逆向双指针"><a href="#方法三：逆向双指针" class="headerlink" title="方法三：逆向双指针"></a>方法三：逆向双指针</h4><p>这个时候我们就要分析，为什么告诉我们 <code>nums1.length = m + n</code>?</p><p>很明显就能猜出出题者的意图，那就是考查<strong>原地修改</strong> ，将空间复杂度降低到 <code>O(1)</code>。</p><p>因为这样不需要使用额外的数组空间了，我们完全可以把nums2也放入nums1 中。</p><p>原地修改时，为了避免从前往后遍历导致原有数组元素被破坏掉，我们要选择<strong>从后往前遍历</strong>！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">nums1, m, nums2, n</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 逆向双指针 原地修改</span></span><br><span class="line">    <span class="keyword">let</span> i=m-<span class="number">1</span>,j=n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[i+j+<span class="number">1</span>]=nums2[j--];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[i+j+<span class="number">1</span>]=nums1[i--];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i]&lt;nums2[j])&#123;</span><br><span class="line">            nums1[i+j+<span class="number">1</span>]=nums2[j--];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nums1[i+j+<span class="number">1</span>]=nums1[i--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度分析</p></blockquote><p>时间复杂度：<code>O(m+n)</code>。</p><p>指针移动单调递减，最多移动m+n 次，因此时间复杂度为O(m+n)。</p><p>空间复杂度：<code>O(1)</code>。<br>直接对数组nums1原地修改，不需要额外空间。</p><h2 id="字符串相加（双指针）⭐"><a href="#字符串相加（双指针）⭐" class="headerlink" title="字符串相加（双指针）⭐"></a>字符串相加（双指针）⭐</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p><blockquote><p>示例 1：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num1 = <span class="string">&quot;11&quot;</span>, num2 = <span class="string">&quot;123&quot;</span></span><br><span class="line">输出：<span class="string">&quot;134&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>提示：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= num1.length, num2.length &lt;= <span class="number">10</span>^<span class="number">4</span></span><br><span class="line">num1 和num2 都只包含数字 <span class="number">0</span>-<span class="number">9</span></span><br><span class="line">num1 和num2 都不包含任何前导零</span><br></pre></td></tr></table></figure><h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><p>因为本题不能使用任何 BigInteger 库，所以我们可以使用双指针来模拟人工计算，步骤如下：</p><ul><li>创建指针 i 指向 nums1 末位数字，j 指向 nums2末位数字。</li><li>i, j 数字相加，用进位就用 carry 来记录进位值，无则为0。</li><li>若产生进位，则当前数字为 (i+j+carry)%10 的值。</li><li>若遍历过程中，nums1 或 nums2 当前已无数字，则用0 补位来计算。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">num1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">num2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> addStrings = <span class="function">(<span class="params">num1, num2</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 双指针来模拟人工计算</span></span><br><span class="line">    <span class="comment">// carry模拟进位</span></span><br><span class="line">    <span class="keyword">let</span> i=num1.length-<span class="number">1</span>,j=num2.length-<span class="number">1</span>,carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> ans = [] ; <span class="comment">// 保存结果的数组</span></span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span> || carry&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> n1 = i&gt;=<span class="number">0</span> ? num1[i]-<span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>,</span><br><span class="line">            n2 = j&gt;=<span class="number">0</span> ? num2.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;<span class="comment">// - &#x27;0&#x27;字符串转数字</span></span><br><span class="line">        <span class="keyword">let</span> sum = n1 + n2 + carry;</span><br><span class="line">        ans.unshift(sum % <span class="number">10</span>);</span><br><span class="line">        carry = <span class="built_in">Math</span>.floor(sum/<span class="number">10</span>); <span class="comment">// 向下取整</span></span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.join(<span class="string">&#x27;&#x27;</span>);<span class="comment">//数组元素拼接成字符串</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="比较版本号-分割、双指针-⭐"><a href="#比较版本号-分割、双指针-⭐" class="headerlink" title="比较版本号(分割、双指针)⭐"></a>比较版本号(分割、双指针)⭐</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><p>给你两个版本号 version1 和 version2 ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 ‘<code>.</code>‘ 连接。每个修订号由多位数字 组成，可能包含前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较<strong>忽略任何前导零后</strong>的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p><p>返回规则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果 version1 &gt; version2 返回 <span class="number">1</span>，</span><br><span class="line">如果 version1 &lt; version2 返回 -<span class="number">1</span>，</span><br><span class="line">除此之外返回 <span class="number">0</span>。</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：version1 = <span class="string">&quot;1.01&quot;</span>, version2 = <span class="string">&quot;1.001&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：忽略前导零，<span class="string">&quot;01&quot;</span> 和 <span class="string">&quot;001&quot;</span> 都表示相同的整数 <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line">输入：version1 = <span class="string">&quot;1.0&quot;</span>, version2 = <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：version1 没有指定下标为 <span class="number">2</span> 的修订号，即视为 <span class="string">&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">输入：version1 = <span class="string">&quot;0.1&quot;</span>, version2 = <span class="string">&quot;1.1&quot;</span></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：version1 中下标为 <span class="number">0</span> 的修订号是 <span class="string">&quot;0&quot;</span>，version2 中下标为 <span class="number">0</span> 的修订号是 <span class="string">&quot;1&quot;</span> 。<span class="number">0</span> &lt; <span class="number">1</span>，所以 version1 &lt; version2</span><br><span class="line"></span><br><span class="line">输入：version1 = <span class="string">&quot;7.5.2.4&quot;</span>, version2 = <span class="string">&quot;7.5.3&quot;</span></span><br><span class="line">输出：-<span class="number">1</span></span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= version1.length, version2.length &lt;= <span class="number">500</span></span><br><span class="line">version1 和 version2 仅包含数字和 <span class="string">&#x27;.&#x27;</span></span><br><span class="line">version1 和 version2 都是 有效版本号</span><br><span class="line">version1 和 version2 的所有修订号都可以存储在<span class="number">32</span>位整数中</span><br></pre></td></tr></table></figure><h3 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3><h4 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h4><p>我们可以将版本号按照<strong>点号</strong>分割（<code>split</code>）成修订号，然后从左到右比较两个版本号的相同下标的修订号。在比较修订号时，需要将字符串转换成整数进行比较。注意根据题目要求，如果版本号不存在某个下标处的修订号，则该修订号视为 0。</p><p>时间复杂度：O(n+m)（或O(max(n,m))，这是等价的），其中 n 是字符串version1 的长度，m 是字符串 version2 的长度。</p><p>空间复杂度：O(n+m)，我们需要 O(n+m)的空间存储分割后的修订号列表。</p><h4 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h4><p>方法一需要<strong>存储分割后的修订号</strong>，为了优化空间复杂度，我们可以在分割版本号的同时解析出修订号进行比较。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">version1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">version2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> compareVersion = <span class="function">(<span class="params">version1, version2</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 双指针</span></span><br><span class="line">    <span class="keyword">const</span> m=version1.length,n=version2.length;</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m || j&lt;n)&#123;</span><br><span class="line">        <span class="keyword">let</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(version1[i]!==<span class="string">&#x27;.&#x27;</span> &amp;&amp; i&lt;m)&#123;</span><br><span class="line">            x = x * <span class="number">10</span> + <span class="built_in">parseInt</span>(version1[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;<span class="comment">//跳过&#x27;.&#x27;</span></span><br><span class="line">        <span class="keyword">while</span>(version2[j]!==<span class="string">&#x27;.&#x27;</span> &amp;&amp; j&lt;n)&#123;</span><br><span class="line">            y = y * <span class="number">10</span> + <span class="built_in">parseInt</span>(version2[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;<span class="comment">//跳过&#x27;.&#x27;</span></span><br><span class="line">        <span class="keyword">if</span>(x !== y)&#123;</span><br><span class="line">            <span class="keyword">return</span> x&gt;y ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n+m)，其中 n 是字符串version1 的长度，m 是字符串 version2 的长度。</p><p>空间复杂度：O(1)，我们只需要常数的空间保存若干变量。</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指hash table就可以了）。</p><blockquote><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p></blockquote><p>其实直白来讲其实<strong>数组就是一张哈希表</strong>。</p><p>哈希表中关键码就是数组的索引下表，然后通过下表直接访问数组中的元素。</p><p>那么哈希表能解决什么问题呢，<strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><p>例如要查询一个名字是否在这所学校里。</p><p>要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1) 就可以做到。</p><p>我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。</p><p>将学生姓名映射到哈希表上就涉及到了<strong>hash function ，也就是哈希函数</strong>。</p><p><strong>常见的三种哈希结构</strong></p><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li><strong>数组</strong></li><li><strong>set （集合）</strong></li><li><strong>map(映射)</strong></li></ul><p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><h2 id="两数之和-哈希表map-⭐"><a href="#两数之和-哈希表map-⭐" class="headerlink" title="两数之和(哈希表map)⭐"></a>两数之和(哈希表map)⭐</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出和为目标值target` 的那两个整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] == <span class="number">9</span> ，返回 [<span class="number">0</span>, <span class="number">1</span>] 。</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>提示：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> &lt;= nums.length &lt;= <span class="number">104</span></span><br><span class="line">-<span class="number">10</span>^<span class="number">9</span> &lt;= nums[i] &lt;= <span class="number">10</span>^<span class="number">9</span></span><br><span class="line">-<span class="number">10</span>^<span class="number">9</span> &lt;= target &lt;= <span class="number">10</span>^<span class="number">9</span></span><br><span class="line">只会存在一个有效答案</span><br></pre></td></tr></table></figure><blockquote><p>进阶：</p></blockquote><p>你可以想出一个时间复杂度小于 O(n^2) 的算法吗？</p><h3 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3><blockquote><p>暴破</p></blockquote><p>最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</p><p>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> twoSum = <span class="function">(<span class="params">nums, target</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 暴力</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i]+nums[j]===target)&#123;</span><br><span class="line">               <span class="keyword">return</span> [i,j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：<code>O(N^2)</code>，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</p><p>空间复杂度：O(1)。</p><blockquote><p>哈希表</p></blockquote><p>我们遍历到数字 a时，用 target 减去 a，就会得到 b，若 b 存在于哈希表中，我们就可以直接返回结果了。若 b 不存在，那么我们需要将 a 存入哈希表，好让后续遍历的数字使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> twoSum = <span class="function">(<span class="params">nums, target</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 哈希表map</span></span><br><span class="line">    <span class="keyword">const</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">// map存在一个键名=target-nums[i]，取出对应的键值</span></span><br><span class="line">        <span class="keyword">if</span>(map.has(target-nums[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> [map.get(target-nums[i]),i];<span class="comment">// 题目要求返回下标</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.set(nums[i],i);<span class="comment">// 键名：数nums[i]；键值：下标i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：<code>O(N)</code>，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以O(1)地寻找 target - x。</p><p>空间复杂度：<code>O(N)</code>，其中 N 是数组中的元素数量。主要为哈希表的开销。</p><h2 id="有效的括号（栈-哈希表Map）⭐"><a href="#有效的括号（栈-哈希表Map）⭐" class="headerlink" title="有效的括号（栈+哈希表Map）⭐"></a>有效的括号（栈+哈希表Map）⭐</h2><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><p>给定一个只包括 ‘<code>(</code>‘，’<code>)</code>‘，’<code>&#123;</code>‘，’<code>&#125;</code>‘，’<code>[</code>‘，’<code>]</code>‘ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;()&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;()[]&#123;&#125;&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;([)]&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;&#123;[]&#125;&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><h3 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：栈"><a href="#方法一：栈" class="headerlink" title="方法一：栈"></a>方法一：栈</h4><p>判断括号的有效性可以使用「<strong>栈</strong>」这一数据结构来解决。</p><p>我们遍历给定的字符串 s。</p><p>当我们遇到一个<strong>左括号</strong>时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。</p><p>由于<strong>后遇到的左括号要先闭合</strong>，因此我们可以将这个<strong>左括号放入栈顶</strong>。</p><p>当我们遇到一个<strong>右括号</strong>时，我们需要将一个相同类型的左括号闭合。</p><p>此时，我们可以<strong>取出栈顶的左括号</strong>并判断它们是否是相同类型的括号。</p><p>如果<strong>不是相同的类型</strong>，或者栈中并<strong>没有左括号</strong>，那么字符串 s 无效，返回 <code>False</code>。</p><p>为了快速判断括号的类型，我们可以使用<strong>哈希表</strong>存储每一种括号。</p><p>哈希表的<strong>键为右括号</strong>，<strong>值为相同类型的左括号</strong>。</p><p>在遍历结束后，如果<strong>栈中没有左括号</strong>，说明我们将字符串 s 中的所有左括号闭合，返回 <code>True</code>，否则返回 False。</p><p>注意到有效字符串的长度一定为<strong>偶数</strong>，因此如果字符串的长度为<strong>奇数</strong>，我们可以直接返回<code>False</code>，省去后续的遍历判断过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> isValid = <span class="function"><span class="params">s</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = s.length;</span><br><span class="line">    <span class="comment">// 如果字符数为奇数一定无效</span></span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>===<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// map存储括号</span></span><br><span class="line">    <span class="comment">// 将数组传入Map构造函数，就可以转为 Map</span></span><br><span class="line">    <span class="keyword">const</span> pairs = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">        [<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;(&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;[&#x27;</span>]</span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">const</span> stack =[];<span class="comment">// 栈 存放左括号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s)&#123;      </span><br><span class="line">        <span class="keyword">if</span>(pairs.has(ch))&#123;</span><br><span class="line">            <span class="comment">// 如果遇到右括号，但栈里没有左括号或最后一个左括号不能与之对应</span></span><br><span class="line">            <span class="comment">// 返回false</span></span><br><span class="line">            <span class="keyword">if</span>( !stack.length || stack[stack.length-<span class="number">1</span>] !== pairs.get(ch))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则从栈里取出对应的左括号</span></span><br><span class="line">            stack.pop();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 左括号入栈</span></span><br><span class="line">            stack.push(ch);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结束后，栈为空说明所有的括号都能闭合</span></span><br><span class="line">    <span class="keyword">return</span> !stack.length;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度分析</p></blockquote><p>时间复杂度：O(n)，其中 n是字符串 s 的长度。</p><p>空间复杂度：O(n+∣Σ∣)，其中 Σ 表示字符集，本题中字符串只包含 6种括号，∣Σ∣=6。栈中的字符数量为 O(n)，而哈希表使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度。</p><h2 id="无重复字符的最长子串⭐"><a href="#无重复字符的最长子串⭐" class="headerlink" title="无重复字符的最长子串⭐"></a>无重复字符的最长子串⭐</h2><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的最长子串的长度。</p><blockquote><p>示例 1:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><blockquote><p>示例 2:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure><blockquote><p>示例 3:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><blockquote><p>提示：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> &lt;= s.length &lt;= <span class="number">5</span> * <span class="number">10</span>^<span class="number">4</span></span><br><span class="line">s 由英文字母、数字、符号和空格组成</span><br></pre></td></tr></table></figure><h3 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3><blockquote><p>滑动窗口</p></blockquote><p>我们先用一个例子考虑如何在较优的时间复杂度内通过本题。</p><p>我们不妨以示例一中的字符串<code>abcabcbb</code> 为例，找出从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p><p>以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；</p><p>以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb；</p><p>以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb；</p><p>以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb；</p><p>以 abca(b)cbb 开始的最长字符串为 abca(bc)bb；</p><p>以 abcab(c)bb 开始的最长字符串为 abcab(cb)b；</p><p>以 abcabc(b)b 开始的最长字符串为 abcabc(b)b；</p><p>以 abcabcb(b) 开始的最长字符串为 abcabcb(b)。</p><p>发现了什么？如果我们<strong>依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的</strong>！</p><p>这里的原因在于，假设我们选择字符串中的第 k个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 r_k。</p><p>那么当我们选择第k+1 个字符作为起始位置时，首先从k+1 到 r_k的字符显然是不重复的，并且由于少了原本的第k 个字符，我们可以尝试继续增大 r_k，直到右侧出现了重复字符为止。</p><p>这样一来，我们就可以使用<strong>滑动窗口</strong>来解决这个问题了：</p><ul><li><p>我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中<code>枚举子串的起始位置</code>，而右指针即为上文中的 <code>r_k</code>；</p></li><li><p>在每一步的操作中，我们会将<strong>左指针向右移动一格</strong>，表示<strong>我们开始枚举下一个字符作为起始位置</strong>，然后我们可以不断地向右移动右指针，但需要保证这<strong>两个指针对应的子串中没有重复的字符</strong>。在移动结束后，这个子串就对应着<strong>以左指针开始的，不包含重复字符的最长子串</strong>。我们记录下这个子串的长度；</p></li><li><p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p></li></ul><blockquote><p>判断重复字符</p></blockquote><p>在上面的流程中，我们还需要使用一种数据结构来判断是否有重复的字符，常用的数据结构为哈希集合（<code>JavaScript</code> 中的 <code>Set</code>）。</p><p>在<strong>左指针向右移动</strong>的时候，我们从哈希集合中<strong>移除一个字符</strong>，在<strong>右指针向右移动</strong>的时候，我们<strong>往哈希集合中添加一个字符</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> lengthOfLongestSubstring = <span class="function"><span class="params">s</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符是否出现</span></span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">const</span> n = s.length;</span><br><span class="line">    <span class="comment">// 右指针，初始值为 -1</span></span><br><span class="line">    <span class="comment">// 相当于在字符串的左边界的左侧，还没开始移动</span></span><br><span class="line">    <span class="keyword">let</span> rk=-<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 左指针 i</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">// 左指针每向右移动一格，移除集合中第一个字符</span></span><br><span class="line">        <span class="keyword">if</span>(i!==<span class="number">0</span>) set.delete(s[i-<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 不断地移动右指针，直到第rk+1个字符已存在</span></span><br><span class="line">        <span class="keyword">while</span>(rk+<span class="number">1</span>&lt;n &amp;&amp; !set.has(s[rk+<span class="number">1</span>]))&#123;</span><br><span class="line">            set.add(s[rk+<span class="number">1</span>]);</span><br><span class="line">            rk++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [i,rk]为无重复子串</span></span><br><span class="line">        ans = <span class="built_in">Math</span>.max(ans,rk-i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度分析</p></blockquote><p>时间复杂度：O(N)，其中 N是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</p><p>空间复杂度：O(∣Σ∣)，其中 Σ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0, 128)[0,128) 内的字符，即∣Σ∣=128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 ∣Σ∣ 个，因此空间复杂度为 O(∣Σ∣)。</p><h1 id="排序数组（快排）"><a href="#排序数组（快排）" class="headerlink" title="排序数组（快排）"></a>排序数组（快排）</h1><h2 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums，请你将该数组升序排列。</p><blockquote><p>示例 1：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><blockquote><p>示例 2：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><blockquote><p>提示：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">50000</span></span><br><span class="line">-<span class="number">50000</span> &lt;= nums[i] &lt;= <span class="number">50000</span></span><br></pre></td></tr></table></figure><h2 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h2><h3 id="基础思路"><a href="#基础思路" class="headerlink" title="基础思路"></a>基础思路</h3><ol><li>如果数组剩下一个以下，那就返回数组</li><li>如果数组有 2 个及以上，那么设置中间点 <code>mid</code></li><li>通过遍历，将小于中间点 <code>mid</code> 的放左边 <code>left</code>，大于中间点 <code>mid</code> 的放右边 <code>right</code></li><li>返回重组后的数组</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="keyword">let</span> midIndex = <span class="built_in">Math</span>.floor(nums.length/<span class="number">2</span>);<span class="comment">// 向下取整</span></span><br><span class="line">    <span class="keyword">let</span> mid = nums.splice(midIndex,<span class="number">1</span>)[<span class="number">0</span>]; <span class="comment">// 取出中间点对应的值，并从原数组中删除</span></span><br><span class="line">    <span class="keyword">let</span> left =[];</span><br><span class="line">    <span class="keyword">let</span> right = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (nums[i] &lt; mid) &#123; </span><br><span class="line">　　　　　　left.push(nums[i]); </span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">　　　　　　right.push(nums[i]); </span><br><span class="line">　　　　&#125; </span><br><span class="line">　　&#125;</span><br><span class="line">    <span class="comment">// 连接这三个数组，不对原数组产生影响</span></span><br><span class="line">    <span class="keyword">return</span> sortArray(left).concat([mid], sortArray(right));</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>栈（stack）是一种运算受限的线性表：</p><ul><li><code>LIFO（last in first out）</code>表示就是后进入的元素，第一个弹出栈空间。类似于自动餐托盘，最后放上的托盘，往往先把拿出去使用。</li><li>其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。</li><li>向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；</li><li>从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</li></ul><p>如下图所示：<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/hiYXX6"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/08/24/hiYXX6.png" alt="hiYXX6.png"></a></p><p>栈的特点：<strong>先进后出，后进先出</strong>。</p><blockquote><p>程序中的栈结构</p></blockquote><ul><li>函数调用栈：A(B(C(D())))：<br>即 A 函数中调用 B，B 调用 C，C 调用 D；在 A 执行的过程中会将 A 压入栈，随后 B 执行时 B 也被压入栈，函数 C 和 D 执行时也会被压入栈。所以当前栈的顺序为：A-&gt;B-&gt;C-&gt;D（栈顶）；函数 D 执行完之后，会弹出栈被释放，弹出栈的顺序为 D-&gt;C-&gt;B-&gt;A;</li><li>递归：<br>==为什么没有停止条件的递归会造成栈溢出？比如函数 A 为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数 A 压入栈，最后造成栈溢出（Queue Overfloat）==。</li></ul><blockquote><p>栈常见的操作</p></blockquote><ul><li><code>push()</code> 添加一个新元素到栈顶位置。</li><li><code>pop()</code> 移除栈顶的元素，同时返回被移除的元素。</li><li><code>peek()</code> 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）。</li><li><code>isEmpty()</code> 如果栈里没有任何元素就返回 <code>true</code>，否则返回 <code>false</code>。</li><li><code>size()</code> 返回栈里的元素个数。这个方法和数组的 <code>length</code> 属性类似。</li><li><code>toString()</code> 将栈结构的内容以字符串的形式返回。</li></ul><h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><h3 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h3><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素val推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li><li></li></ul><p><strong>示例 1:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;MinStack&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;getMin&quot;</span>,<span class="string">&quot;pop&quot;</span>,<span class="string">&quot;top&quot;</span>,<span class="string">&quot;getMin&quot;</span>]</span><br><span class="line">[[],[-<span class="number">2</span>],[<span class="number">0</span>],[-<span class="number">3</span>],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,-<span class="number">3</span>,<span class="literal">null</span>,<span class="number">0</span>,-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(-<span class="number">2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(-<span class="number">3</span>);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">3.</span></span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 <span class="number">0.</span></span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">2.</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= val &lt;= 231 - 1</code></li><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li><li><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 10^4</code> 次</li></ul><h3 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h3><p><strong>能否用临时变量存最小值</strong>？</p><p>用变量 min，存栈中的最小元素，初始值为第一个推入栈的元素</p><p>之后入栈的元素，让它和 min 比较，小于 min 则将 min 更新为新入栈的元素</p><p>getMin调用时，返回 min 即可</p><blockquote><p>这有问题，为什么？</p></blockquote><p>因为只考虑了入栈的情况，没有考虑出栈</p><p>假如，栈中最小元素正好是栈顶元素，如果此时执行出栈</p><p>此时 min 应该更新为多少呢？没有记录第二小的元素</p><p><strong>维护一个辅助栈</strong></p><p>再维护一个栈 min_stack，存：<strong>栈中曾经的最小值</strong></p><p>当第一个元素入栈时，让它也入min_stack栈</p><p>之后入栈的元素，会和 min_stack 的栈顶元素比较，如果更小，则入 min_stack 栈，min_stack 栈顶始终是主栈的最小值。</p><p>每当有元素出栈时，要判断出栈的是否是最小元素，如果是，则 min_stack 的栈顶也出栈，原本第二小的元素成了新的栈顶元素，备胎转正！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MinStack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stack =[];</span><br><span class="line">    <span class="built_in">this</span>.min_stack =[];<span class="comment">// 辅助栈</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">val</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stack.push(val);<span class="comment">// 入栈</span></span><br><span class="line">    <span class="comment">// 辅助栈为空直接传入，否则与栈顶的最小元素比较</span></span><br><span class="line">    <span class="comment">// 辅助栈栈顶永远存当前主栈的最小元素</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.min_stack.length === <span class="number">0</span> || val &lt;= <span class="built_in">this</span>.getMin())&#123;</span><br><span class="line">        <span class="built_in">this</span>.min_stack.push(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> out = <span class="built_in">this</span>.stack.pop();<span class="comment">// 出栈</span></span><br><span class="line">    <span class="comment">// 如果主栈的最小元素出栈，辅助栈栈顶元素也出栈</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.getMin() === out)&#123;</span><br><span class="line">        <span class="built_in">this</span>.min_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.top = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack[<span class="built_in">this</span>.stack.length-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.getMin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.min_stack[<span class="built_in">this</span>.min_stack.length-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MinStack()</span></span><br><span class="line"><span class="comment"> * obj.push(val)</span></span><br><span class="line"><span class="comment"> * obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.getMin()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>什么是链表，链表是一种通过<strong>指针</strong>串联在一起的线性结构，每一个节点由两部分组成，一个是<strong>数据域</strong>一个是<strong>指针域</strong>（存放指向下一个节点的指针），<strong>最后一个节点的指针域指向null</strong>（空指针的意思）。</p><p>链接的入口节点称为链表的头结点也就是<code>head</code>。</p><p>上面说的就是<strong>单链表</strong>。</p><p>单链表中的节点只能指向节点的下一个节点。</p><p><strong>双链表</strong>：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p><p><strong>双链表既可以向前查询也可以向后查询</strong>。</p><p><strong>循环链表</strong>，顾名思义，就是链表首尾相连。可以用来解决约瑟夫环问题。</p><p>链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><p>链表的增添和删除都是O(1)操作，也不会影响到其他节点。</p><p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p><p>链表的长度可以是不固定的，并且可以动态增删， <strong>适合数据量不固定，频繁增删，较少查询的场景</strong>。</p><h2 id="封装链表节点"><a href="#封装链表节点" class="headerlink" title="封装链表节点"></a>封装链表节点</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装单链表的节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.val = value;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输入链表</span></span><br><span class="line"><span class="keyword">const</span> input = []</span><br><span class="line"><span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//初始化头节点</span></span><br><span class="line"><span class="keyword">if</span>(input[<span class="number">0</span>] !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">  head = <span class="keyword">new</span> ListNode(input[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentNode = head;<span class="comment">// 中间变量，指向单链表的最后一个节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; input.length; i++) &#123;</span><br><span class="line">  <span class="comment">// 保证currentNode指向单链表的最后一个节点</span></span><br><span class="line">  <span class="keyword">while</span> (currentNode.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">    currentNode = currentNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后一个节点的next指向新节点</span></span><br><span class="line">  currentNode.next = <span class="keyword">new</span> ListNode(input[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(head);</span><br><span class="line"><span class="keyword">let</span> output = head;</span><br><span class="line"><span class="built_in">console</span>.log(output)</span><br><span class="line"><span class="keyword">const</span> res = [];</span><br><span class="line"><span class="keyword">while</span> (output !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// if(output.val === undefined)break;// 返回空数组</span></span><br><span class="line">  res.push(output.val);<span class="comment">// 将当前节点值存入数组</span></span><br><span class="line">  output = output.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><h2 id="反转链表（迭代-、递归）⭐"><a href="#反转链表（迭代-、递归）⭐" class="headerlink" title="反转链表（迭代 、递归）⭐"></a>反转链表（迭代 、递归）⭐</h2><h3 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是<code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><h3 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h3><h4 id="迭代-双指针"><a href="#迭代-双指针" class="headerlink" title="迭代 双指针 "></a>迭代 双指针 <img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://c1.im5i.com/2021/12/06/cA1rJ.jpg" alt="cA1rJ.jpg"></h4><blockquote><p>关键</p></blockquote><p>初始化：设置pre指针指向 null，将当前节点cur指向head。</p><p>将当前节点cur的next指针指向上一个节点pre。</p><p>然后当前节点和下一个节点更新为pre和cur。</p><p>重复以上动作直到当前节点cur指向null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> reverseList = <span class="function"><span class="params">head</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 双指针</span></span><br><span class="line">    <span class="comment">// 定义一个cur指针，指向头节点，再定义一个pre指针，初始化为null</span></span><br><span class="line">    <span class="keyword">let</span> cur=head,pre=<span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 直到当前节点指向null结束</span></span><br><span class="line">    <span class="keyword">while</span>(cur !==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 简化版本 解构赋值</span></span><br><span class="line">        <span class="comment">// [cur.next,pre,cur] = [pre,cur,cur.next];</span></span><br><span class="line">        <span class="keyword">let</span> temp = cur.next;<span class="comment">// 临时保存下一个节点</span></span><br><span class="line">        cur.next = pre;<span class="comment">//当前节点的next指向前一个</span></span><br><span class="line">        pre =cur;<span class="comment">// 将当前节点更新为pre</span></span><br><span class="line">        cur = temp;<span class="comment">//将下一个节点更新为cur</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度分析</p></blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>关键是反转操作</p><ul><li><p>当前节点<code>head</code>，下一个节点 <code>head.next</code></p></li><li><p><code>head.next.next = head</code></p><ul><li>此处将下一个节点指向当前节点，即是反转</li></ul></li><li><p><code>head.next = null</code></p><ul><li>此处将当前节点指向下一个节点的指针断开</li></ul></li></ul><p>递归</p><ul><li><p>由编译器函数调用执行栈原理可知</p><ul><li><strong>最先调用的函数会在递归过程中最后被执行，而最后调用的会最先执行</strong></li></ul></li><li><p>因此此题，<strong>最先返回最后两个节点开始反转操作</strong></p><ul><li>依次从后面两两节点开始反转</li></ul></li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://c1.im5i.com/2021/12/06/c8d88.png" alt="c8d88.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> reverseList = <span class="function"><span class="params">head</span>=&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 递归 从后向前</span></span><br><span class="line">  <span class="comment">// 递归结束条件：</span></span><br><span class="line">  <span class="comment">// !head 输入空数组</span></span><br><span class="line">  <span class="comment">// 只有一个节点 head.next=null 返回这个节点</span></span><br><span class="line">  <span class="comment">// 递归时 head.next.next=null head指向倒数第二个节点时，返回head.next</span></span><br><span class="line">  <span class="keyword">if</span>(!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="comment">// reverseHead最开时指向最后一个节点head.next</span></span><br><span class="line">  <span class="keyword">const</span> reverseHead = reverseList(head.next);</span><br><span class="line">  <span class="comment">// 从后向前开始反转，后一个节点指向前一个，并断开前一个的原本指向</span></span><br><span class="line">  head.next.next = head;</span><br><span class="line">  head.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 将反转好的部分返回给上一层的reverseHead</span></span><br><span class="line">  <span class="comment">// 返回到上一层时head指向也会前移</span></span><br><span class="line">  <span class="keyword">return</span> reverseHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有一种递归，是在双指针的基础上</p><p>这个递归还是从前向后两两翻转，因为递归后没有操作，最后得到的反转后的链表会逐层返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> reverseList = <span class="function"><span class="params">head</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 递归 </span></span><br><span class="line">    <span class="keyword">const</span> reverse = <span class="function">(<span class="params">pre,cur</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cur) <span class="keyword">return</span> pre;<span class="comment">//cur=null =&gt; pre.next =null pre已经到了尾节点</span></span><br><span class="line">        <span class="keyword">let</span> temp = cur.next;<span class="comment">// 临时保存下一个节点</span></span><br><span class="line">        cur.next=pre;<span class="comment">//当前节点的next指向前一个</span></span><br><span class="line">        <span class="keyword">return</span> reverse(cur,temp);<span class="comment">// 递归后无操作，将最后一个pre逐层返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverse(<span class="literal">null</span>,head);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="栈解"><a href="#栈解" class="headerlink" title="栈解"></a>栈解</h4><ul><li><p>思路</p><ul><li>既然是反转，那么符合栈先进后出的特点</li><li>将原节点依次入栈</li><li>出栈时，重新构造链表改变指向</li><li>同样设置哨兵节点</li></ul></li></ul><h2 id="环形链表（哈希表map、快慢指针）⭐"><a href="#环形链表（哈希表map、快慢指针）⭐" class="headerlink" title="环形链表（哈希表map、快慢指针）⭐"></a>环形链表（哈希表map、快慢指针）⭐</h2><h3 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h3><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。</p><p>为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。</p><p>如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><h3 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h3><h4 id="借助哈希表"><a href="#借助哈希表" class="headerlink" title="借助哈希表"></a>借助哈希表</h4><p>哈希表存遍历过的节点，每遍历一个节点，都查看哈希表是否存在当前节点，如果存在，则说明链表有环</p><p>如果不存在，则存入哈希表，继续遍历</p><p>时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(n)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> hasCycle = <span class="function"><span class="params">head</span>  =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();<span class="comment">//哈希表存遍历过的节点</span></span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(head)) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 如果存在，则说明链表有环</span></span><br><span class="line">        map.set(head,<span class="literal">true</span>);<span class="comment">// 存的是节点的地址引用，而不是节点值</span></span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h4><p>快、慢指针，从头节点出发。</p><p>慢指针每次走一步，快指针每次走两步，不断比较它们指向的节点的值。</p><p>如果节点值相同，说明有环。如果不同，继续循环。</p><blockquote><p>类似 “追及问题”</p></blockquote><p>两个人在环形跑道上赛跑，同一个起点出发，一个跑得快一个跑得慢，在某一时刻，跑得快的必定会追上跑得慢的，只要是跑道是环形的，不是环形就肯定追不上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> hasCycle = <span class="function"><span class="params">head</span>  =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="keyword">let</span> fast =head,slow=head;</span><br><span class="line">    <span class="comment">// fast 防止链表为空的情况</span></span><br><span class="line">    <span class="comment">// fast.next 快指针每次移动两格，</span></span><br><span class="line">    <span class="comment">// 如果fast.next已经指向null，fast.next.next就不存在，且此时一定没有环</span></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.next )&#123;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">// 相对速度是1，快的只能一格一格追，有环的话一定会相遇</span></span><br><span class="line">        <span class="keyword">if</span>(slow===fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：<code>O(N)</code>，其中 N 是链表中的节点数。</p><p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p><p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。</p><p>空间复杂度：<code>O(1)</code>。我们只使用了两个指针的额外空间。</p><h2 id="反转链表-II"><a href="#反转链表-II" class="headerlink" title="反转链表 II"></a>反转链表 II</h2><h3 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h3><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], left = <span class="number">2</span>, right = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h3 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：穿针引线"><a href="#方法一：穿针引线" class="headerlink" title="方法一：穿针引线"></a>方法一：穿针引线</h4><p>我们以下图中黄色区域的链表反转为例。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.leetcode-cn.com/1615105129-iUPoGi-image.png" alt="img"></p><p>使用「反转链表」的解法，反转 left 到 right 部分以后，再拼接起来。我们还需要记录 left 的前一个节点，和 right 的后一个节点。如图所示：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.leetcode-cn.com/1615105150-pfWiGq-image.png" alt="image.png"></p><p>算法步骤：</p><p>第 1 步：先将待反转的区域反转；</p><p>第 2 步：把 pre 的 next 指针指向反转以后的链表头节点，把反转以后的链表的尾节点的 next 指针指向 succ。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseBetween = <span class="function"><span class="keyword">function</span>(<span class="params">head, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论</span></span><br><span class="line">    <span class="keyword">const</span> dummyNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> pre = dummyNode;</span><br><span class="line">    <span class="comment">// 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点</span></span><br><span class="line">    <span class="comment">// 建议写在 for 循环里，语义清晰</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点</span></span><br><span class="line">    <span class="keyword">let</span> rightNode = pre;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        rightNode = rightNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 3 步：切断出一个子链表（截取链表）</span></span><br><span class="line">    <span class="keyword">let</span> leftNode = pre.next;</span><br><span class="line">    <span class="keyword">let</span> curr = rightNode.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：切断链接</span></span><br><span class="line">    pre.next = <span class="literal">null</span>;</span><br><span class="line">    rightNode.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 4 步：同第 206 题，反转链表的子区间</span></span><br><span class="line">    reverseLinkedList(leftNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 5 步：接回到原来的链表中</span></span><br><span class="line">    pre.next = rightNode;</span><br><span class="line">    leftNode.next = curr;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reverseLinkedList = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">const</span> next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(N)，其中 N是链表总节点数。最坏情况下，需要遍历整个链表。</li><li>空间复杂度：O(1)。只使用到常数个变量。</li></ul><h4 id="方法二：一次遍历「穿针引线」反转链表（头插法）"><a href="#方法二：一次遍历「穿针引线」反转链表（头插法）" class="headerlink" title="方法二：一次遍历「穿针引线」反转链表（头插法）"></a>方法二：一次遍历「穿针引线」反转链表（头插法）</h4><p>方法一的缺点是：如果 left 和 right 的区域很大，恰好是链表的头节点和尾节点时，找到 left 和 right 需要遍历一次，反转它们之间的链表还需要遍历一次，虽然总的时间复杂度为 O(N)O(N)，但遍历了链表 22 次，可不可以只遍历一次呢？答案是可以的。我们依然画图进行说明。</p><p>整体思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。下面的图展示了整个流程。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.leetcode-cn.com/1615105242-ZHlvOn-image.png" alt="img"></p><p>下面我们具体解释如何实现。使用三个指针变量 pre、curr、next 来记录反转的过程中需要的变量，它们的意义如下：</p><p>curr：指向待反转区域的第一个节点 left；<br>next：永远指向 curr 的下一个节点，循环过程中，curr 变化以后 next 会变化；<br>pre：永远指向待反转区域的第一个节点 left 的前一个节点，在循环过程中不变。</p><p>第 1 步，我们使用 ①、②、③ 标注「穿针引线」的步骤。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.leetcode-cn.com/1615105296-bmiPxl-image.png" alt="img"></p><p>操作步骤：</p><p>先将 curr 的下一个节点记录为 next；<br>执行操作 ①：把 curr 的下一个节点指向 next 的下一个节点；<br>执行操作 ②：把 next 的下一个节点指向 pre 的下一个节点；<br>执行操作 ③：把 pre 的下一个节点指向 next。<br>第 1 步完成以后「拉直」的效果如下：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.leetcode-cn.com/1615105340-UBnTBZ-image.png" alt="img"></p><p>第 2 步，同理。同样需要注意 <strong>「穿针引线」操作的先后顺序</strong>。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.leetcode-cn.com/1615105353-PsCmzb-image.png" alt="img"></p><p>第 2 步完成以后「拉直」的效果如下：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.leetcode-cn.com/1615105364-aDIFqy-image.png" alt="img"></p><p>第 3 步，同理。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.leetcode-cn.com/1615105376-jIyGwv-image.png" alt="img"></p><p>第 3 步完成以后「拉直」的效果如下：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.leetcode-cn.com/1615105395-EJQnMe-image.png" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseBetween = <span class="function"><span class="keyword">function</span>(<span class="params">head, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">    <span class="keyword">const</span> dummy_node = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy_node.next = head;</span><br><span class="line">    <span class="keyword">let</span> pre = dummy_node;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> cur = pre.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; right - left; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> next = cur.next;</span><br><span class="line">        cur.next = next.next;</span><br><span class="line">        next.next = pre.next;</span><br><span class="line">        pre.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy_node.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：O(N)，其中 N 是链表总节点数。最多只遍历了链表一次，就完成了反转。</p><p>空间复杂度：O(1)。只使用到常数个变量。</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><h3 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h3><p>在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。</p><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p><p>如图所示：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20200806185805576.png" alt="img"></p><p>这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。</p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>什么是完全二叉树？</p><p>完全二叉树的定义如下：在完全二叉树中，除了最<strong>底层节点可能没填满外</strong>，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层<strong>最左边的若干位置</strong>。若最底层为第 h 层，则该层包含 1~ 2^h -1 个节点。</p><p><strong>大家要自己看完全二叉树的定义，很多同学对完全二叉树其实不是真正的懂了。</strong></p><p>我来举一个典型的例子如题：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20200920221638903.png" alt="img"></p><p><strong>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</strong></p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p>下面这两棵树都是搜索树 <img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20200806190304693.png" alt="img"></p><h4 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h4><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵<strong>空树</strong>或它的<strong>左右两个子树的高度差的绝对值不超过1</strong>，并且<strong>左右两个子树都是一棵平衡二叉树</strong>。</p><p>如图：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20200806190511967.png" alt="img"></p><p>最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。</p><h3 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h3><p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p><p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p><p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在散落在各个地址的节点串联一起。</p><p>链式存储如图：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/2020092019554618.png" alt="img"></p><p>链式存储是大家很熟悉的一种方式，那么我们来看看如何顺序存储呢？</p><p>其实就是用数组来存储二叉树，顺序存储的方式如图：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20200920200429452.png" alt="img"></p><p>用数组来存储二叉树如何遍历的呢？</p><p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p><p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p><h3 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h3><p>关于二叉树的遍历方式，要知道二叉树遍历的基本方式都有哪些。</p><p>二叉树主要有两种遍历方式：</p><ol><li><strong>深度优先遍历</strong>：先往深走，遇到叶子节点再往回走。</li><li><strong>广度优先遍历</strong>：一层一层的去遍历。</li></ol><p><strong>这两种遍历是图论中最基本的两种遍历方式</strong>，后面在介绍图论的时候 还会介绍到。</p><p>那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p><ul><li>深度优先遍历<ul><li><strong>前序遍历（递归法，迭代法）</strong></li><li><strong>中序遍历（递归法，迭代法）</strong></li><li><strong>后序遍历（递归法，迭代法）</strong></li></ul></li><li>广度优先遍历<ul><li><strong>层次遍历（迭代法）</strong></li></ul></li></ul><p>在深度优先遍历中：有三个顺序，前中后序遍历， <strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，只要大家记住 前中后序指的就是中间节点的位置就可以了。</p><p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p>大家可以对着如下图，看看自己理解的前后中序有没有问题。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20200806191109896.png" alt="img"></p><p>最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用<strong>递归</strong>的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。</p><p><strong>之前我们讲栈与队列的时候，就说过栈其实就是递归的一种是实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助<strong>栈</strong>使用非递归的方式来实现的。</p><p>而广度优先遍历的实现一般使用<strong>队列</strong>来实现，这也是队列<strong>先进先出</strong>的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p><p><strong>这里其实我们又了解了栈与队列的一个应用场景了。</strong></p><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p>刚刚我们说过了二叉树有两种存储方式顺序存储，和链式存储，顺序存储就是用数组来存，这个定义没啥可说的，我们来看看链式存储的二叉树节点的定义方式。</p><p>JS代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装树的节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.val = val;</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉树的定义和<strong>链表</strong>是差不多的，相对于链表 ，二叉树的节点里多了一个指针， 有<strong>两个指针</strong>，指向左右孩子。</p><h2 id="路径总和（递归-二叉树）⭐"><a href="#路径总和（递归-二叉树）⭐" class="headerlink" title="路径总和（递归+二叉树）⭐"></a>路径总和（递归+二叉树）⭐</h2><h3 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p><p>叶子节点 是指没有子节点的节点。</p><blockquote><p>示例</p></blockquote><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ooiseS"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2021/12/10/ooiseS.jpg" alt="ooiseS.jpg"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure><p>提示：</p><p>树中节点的数目在范围 [0, 5000] 内<br>-1000 &lt;= Node.val &lt;= 1000<br>-1000 &lt;= targetSum &lt;= 1000</p><h3 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h3><blockquote><p>思路</p></blockquote><p>sum： 从根节点到叶子节点的路径上的节点值相加的目标和</p><p>对 root 递归。转为判断：root 的左、右子树中能否找出和为 sum-root.val 的路径</p><p>就变成一个规模小一点的相同问题</p><p>即，每遍历一个节点，sum 就减去当前节点值，当遍历到叶子节点时，因为没有子节点了，如果 sum - 当前叶子节点值 == 0 ，即找到了从根节点到叶子节点的和为 sum 的路径</p><p>时间复杂度：O(n)，每个节点被遍历一次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">targetSum</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123; <span class="comment">// 遍历到null节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;                </span><br><span class="line">  <span class="keyword">if</span> (root.left === <span class="literal">null</span> &amp;&amp; root.right === <span class="literal">null</span>) &#123; <span class="comment">// 遍历到叶子节点</span></span><br><span class="line">    <span class="keyword">return</span> targetSum - root.val === <span class="number">0</span>;                  <span class="comment">// 如果满足这个就返回true。否则返回false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不是上面的情况，则拆成两个子树的问题，其中一个true了就行</span></span><br><span class="line">  <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">9</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: <span class="number">9</span> 出现在 nums 中并且下标为 <span class="number">4</span></span><br><span class="line"></span><br><span class="line">输入: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">2</span></span><br><span class="line">输出: -<span class="number">1</span></span><br><span class="line">解释: <span class="number">2</span> 不存在 nums 中因此返回 -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol><h2 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h2><blockquote><p>思路</p></blockquote><p>这道题目的前提是数组为有序数组，同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p><p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p><p>大家写二分法经常写乱，主要是因为对区间的定义没有想清楚，区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。</p><p>写二分法，区间的定义一般为两种，左闭右闭即<code>[left, right]</code>，或者左闭右开即<code>[left, right)</code>。</p><blockquote><p>二分法第一种写法</p></blockquote><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，也就是<code>[left, right]</code> （这个很重要非常重要）。</p><p>区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点：</p><p><code>while (left &lt;= right)</code> 要使用 <code>&lt;=</code> ，因为left == right是有意义的，所以使用 &lt;=</p><p><code>if (nums[middle] &gt; target)</code> right 要赋值为 <code>middle - 1</code>，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</p><p>例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oo8wqg"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2021/12/10/oo8wqg.png" alt="oo8wqg.png"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 区间 [l, r]</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;<span class="comment">//向右移位实现除以2，并向下取整</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] === target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">let</span> isSmall = nums[mid] &lt; target;</span><br><span class="line">        l = isSmall ? mid + <span class="number">1</span> : l;</span><br><span class="line">        r = isSmall ? r : mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>二分法第二种写法</p></blockquote><p>如果说定义 target 是在一个在左闭右开的区间里，也就是<code>[left, right)</code> ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><p><code>while (left &lt; right)</code>，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</p><p><code>if (nums[middle] &gt; target)</code> right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</p><p>在数组：1,2,3,4,7,9,10中查找元素2，如图所示：（注意和方法一的区别）</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oo87J1"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2021/12/10/oo87J1.png" alt="oo87J1.png"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = nums.length;</span><br><span class="line">    <span class="comment">// 区间 [l, r）</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] === target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">let</span> isSmall = nums[mid] &lt; target;</span><br><span class="line">        l = isSmall ? mid + <span class="number">1</span> : l;</span><br><span class="line">        <span class="comment">// 所以 mid 不会被取到</span></span><br><span class="line">        r = isSmall ? r : mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h1><h2 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 k = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">返回链表 <span class="number">4</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure><h2 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>最简单直接的方法即为顺序查找，假设当前链表的长度为 n，则我们知道链表的倒数第 k 个节点即为正数第 n−k 个节点，此时我们只需要顺序遍历到链表的第 n−k 个节点即为倒数第 k 个节点。</p><p>我们首先求出链表的长度 n，然后顺序遍历到链表的第 n−k 个节点返回即可。</p><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>快慢指针的思想。我们将第一个指针fast 指向链表的第 k + 1 个节点，第二个指针slow 指向链表的第一个节点，此时指针 fast 与 slow 二者之间刚好间隔 k 个节点。此时两个指针同步向后走，当第一个指针 fast 走到链表的尾部空节点时，则此时 slow 指针刚好指向链表的倒数第k个节点。</p><p>我们首先将 fast 指向链表的头节点，然后向后走 k 步，则此时fast 指针刚好指向链表的第 k+1 个节点。</p><p>我们首先将 slow 指向链表的头节点，同时 slow 与 fast 同步向后走，当fast 指针指向链表的尾部空节点时，则此时返回 slow 所指向的节点即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getKthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head,slow=head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        [fast,k] =[fast.next,k-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">        [fast,slow] = [fast.next,slow.next];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)，其中 n 为链表的长度。我们使用快慢指针，只需要一次遍历即可，复杂度为 O(n)。</p><p>空间复杂度：O(1)。</p><h1 id="二叉树的最大深度（BFS）⭐"><a href="#二叉树的最大深度（BFS）⭐" class="headerlink" title="二叉树的最大深度（BFS）⭐"></a>二叉树的最大深度（BFS）⭐</h1><h2 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：</p><p>给定二叉树 [3,9,20,null,null,15,7]，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><h2 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>一个树的最大深度 = 根节点的高度（即1）+ 左右子树的最大深度中的较大者。</p><p>“嗨，maxDepth函数，请帮我计算出我的左右子树的最大深度，我等你的返回结果，我就能算出自己的最大深度了。”</p><p>递归的结束条件：当遍历到 null 节点，它们的高度是 0，返回 0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> leftMaxDepth =maxDepth(root.left);</span><br><span class="line">    <span class="keyword">const</span> rightMaxDepth=maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">Math</span>.max(leftMaxDepth,rightMaxDepth);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度<ul><li>最坏情况下 <code>O(n)</code> 退化为单链表</li><li>最好情况下 <code>O(logn)</code> 为平衡二叉树且高度为logn</li></ul></li></ul><h3 id="BFS-典型的BFS模板写法"><a href="#BFS-典型的BFS模板写法" class="headerlink" title="BFS (典型的BFS模板写法)"></a>BFS (典型的BFS模板写法)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxDepth = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> queue = [root];</span><br><span class="line">    <span class="keyword">let</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="comment">// 当前层的节点个数</span></span><br><span class="line">        <span class="keyword">const</span> levelSize = queue.length;          </span><br><span class="line">        <span class="comment">// 逐个让当前层的节点出列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;    </span><br><span class="line">            <span class="comment">// 当前出列的节点</span></span><br><span class="line">            <span class="keyword">const</span> cur = queue.shift();            </span><br><span class="line">            <span class="comment">// 左右子节点入列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left) queue.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right) queue.push(cur.right); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前层所有节点已经出列，如果队列不为空，说明有下一层节点，depth+1</span></span><br><span class="line">        <span class="keyword">if</span> (queue.length) depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Excel表列名称"><a href="#Excel表列名称" class="headerlink" title="Excel表列名称"></a>Excel表列名称</h1><h2 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; <span class="number">1</span></span><br><span class="line">B -&gt; <span class="number">2</span></span><br><span class="line">C -&gt; <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Z -&gt; <span class="number">26</span></span><br><span class="line">AA -&gt; <span class="number">27</span></span><br><span class="line">AB -&gt; <span class="number">28</span> </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：columnNumber = <span class="number">1</span></span><br><span class="line">输出：<span class="string">&quot;A&quot;</span></span><br><span class="line"></span><br><span class="line">输入：columnNumber = <span class="number">28</span></span><br><span class="line">输出：<span class="string">&quot;AB&quot;</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= columnNumber &lt;= 231 - 1</code></li></ul><h2 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h2><p>本题本质就是进制转换，10进制转26进制，但有所不同的是正常转换成26进制的余数是0-25，<br>而本题的余数是1-26（对应A-Z），为了消除差距的这个1，有两种方法：</p><p>①让除数减一，那么余数自然就少一，原来余 1 的变成余 0，以此类推(详细见下表)。<br>核心代码 <code>let remain = (n - 1) % 26;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> convertToTitle = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        n--; <span class="comment">// 通过让 n - 1，使得余数 remain 减少 1 </span></span><br><span class="line">        <span class="keyword">let</span> remain = n % <span class="number">26</span>;</span><br><span class="line">        <span class="comment">// unshift 向数组开头添加元素</span></span><br><span class="line">        <span class="comment">// fromCharCode 将 Unicode 编码转为一个字符 A:65</span></span><br><span class="line">        res.unshift(<span class="built_in">String</span>.fromCharCode(remain + <span class="number">65</span>));</span><br><span class="line">        n = <span class="built_in">Math</span>.floor(n / <span class="number">26</span>);<span class="comment">// 向下取整</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);<span class="comment">// 将数组转换为一个字符串并且设置没有分隔符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>②对值为 26 的倍数单独处理，保留为 26，而不取余<br>核心代码 <code>let remain = n % 26 ? n % 26 : 26;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> convertToTitle = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        <span class="comment">// if(n % 26 === 0) remain = 26;</span></span><br><span class="line">        <span class="comment">// else remain = n % 26;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面两行可以简写为下面一行</span></span><br><span class="line">        <span class="keyword">let</span> remain = n % <span class="number">26</span> ? n % <span class="number">26</span> : <span class="number">26</span>;</span><br><span class="line">        res.unshift(<span class="built_in">String</span>.fromCharCode(remain + <span class="number">64</span>));</span><br><span class="line">        n = <span class="built_in">Math</span>.floor((n - remain) / <span class="number">26</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h1><h2 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h2><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>前序遍历的定义：对每个节点，都是先处理当前节点，对它执行我们的处理逻辑，再递归它的左子树，再递归它的右子树，对子树中的节点执行相同的逻辑。(<strong>中左右</strong>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> preOrder = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root===<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(root.val);<span class="comment">// 根节点</span></span><br><span class="line">        preOrder(root.left);<span class="comment">// 左节点</span></span><br><span class="line">        preOrder(root.right);<span class="comment">// 右节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：<code>O(n)</code>，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</p><p>空间复杂度：<code>O(n)</code>，为递归过程中栈的开销，平均情况下为 <code>O(logn)</code>，最坏情况下树呈现链状，为 <code>O(n)</code>。</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>为什么可以用迭代法（非递归的方式）来实现二叉树的前后中序遍历呢？</p><p>递归的实现就是：<strong>每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因</strong>。</p><p>此时大家应该知道我们用<strong>栈</strong>也可以是实现二叉树的前后中序遍历了。</p><h4 id="方法一-非统一格式"><a href="#方法一-非统一格式" class="headerlink" title="方法一 非统一格式"></a>方法一 非统一格式</h4><p>前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要先加入右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">let</span> stack=[];</span><br><span class="line">    <span class="comment">// 当根节点不为空的时候，将根节点入栈</span></span><br><span class="line">    <span class="keyword">if</span>(root) stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(stack.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 将根节点出栈，将根节点值放入结果数组中</span></span><br><span class="line">        <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">        res.push(node.val);</span><br><span class="line">        <span class="comment">// 然后遍历左子树、右子树，</span></span><br><span class="line">        <span class="comment">// 因为栈是先入后出，所以，我们先右子树入栈，然后左子树入栈</span></span><br><span class="line">        <span class="keyword">if</span>(node.right) stack.push(node.right);</span><br><span class="line">        <span class="keyword">if</span>(node.left) stack.push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法二-统一格式"><a href="#方法二-统一格式" class="headerlink" title="方法二 统一格式"></a>方法二 统一格式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">let</span> stack=[];</span><br><span class="line">    <span class="keyword">let</span> node =root;</span><br><span class="line">    <span class="comment">// 和递归思想类似</span></span><br><span class="line">    <span class="keyword">while</span>(node || stack.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            res.push(node.val);</span><br><span class="line">            node=node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;    </span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：<code>O(n)</code>，其中 nn 是二叉树的节点数。每一个节点恰好被遍历一次。</p><p>空间复杂度：<code>O(n)</code>，为迭代过程中显式栈的开销，平均情况下为 <code>O(logn)</code>，最坏情况下树呈现链状，为 <code>O(n)</code>。</p><h1 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h1><h2 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h2><h3 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res =[];</span><br><span class="line">    <span class="keyword">const</span> postOrder = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root===<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder(root.left);<span class="comment">// 左</span></span><br><span class="line">        postOrder(root.right); <span class="comment">// 右</span></span><br><span class="line">        res.push(root.val);<span class="comment">// 中</span></span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h3><p>方法一 与前序类似</p><p>解题思路： 后序遍历与前序遍历不同的是：</p><p>后序遍历是<strong>左右根</strong></p><p>而前序遍历是<strong>根左右</strong></p><p>如果我们把前序遍历的 <code>res.push(node.val)</code> 变更为 <code>res.unshift(node.val)</code> （遍历结果逆序），那么遍历顺序就由 <strong>根左右</strong> 变更为 <strong>右左根</strong></p><p>然后我们仅需将 <strong>右左根</strong> 变更为 <strong>左右根</strong> 即可完成后序遍历</p><p>或者 先按<strong>根右左</strong>遍历，最后<code>reverse()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res =[];</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">if</span>(root)stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(stack.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> node = stack.pop();</span><br><span class="line">        <span class="comment">// 根左右=&gt;右左根</span></span><br><span class="line">        res.unshift(node.val);</span><br><span class="line">        <span class="comment">//res.push(node.val);</span></span><br><span class="line">        <span class="comment">// 先进栈左子树后右子树</span></span><br><span class="line">        <span class="comment">// 出栈的顺序就变更为先右后左</span></span><br><span class="line">        <span class="comment">// 右先头插法入res</span></span><br><span class="line">        <span class="comment">// 左再头插法入res</span></span><br><span class="line">        <span class="comment">// 实现右左根=&gt;左右根</span></span><br><span class="line">        <span class="keyword">if</span>(node.left)stack.push(node.left);</span><br><span class="line">        <span class="keyword">if</span>(node.right)stack.push(node.right);</span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// return res.reverse();// 不用unshift的话，最后将整个数组反转也可</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>统一格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res =[];</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> node = root;</span><br><span class="line">    <span class="keyword">while</span>(node || stack.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            <span class="comment">//res.push(node.val);</span></span><br><span class="line">            res.unshift(node.val);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">//return res.reverse();</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的中序遍历（递归、迭代（栈））⭐"><a href="#二叉树的中序遍历（递归、迭代（栈））⭐" class="headerlink" title="二叉树的中序遍历（递归、迭代（栈））⭐"></a>二叉树的中序遍历（递归、迭代（栈））⭐</h1><h2 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h2><p>递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">const</span> inOrder = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        res.push(root.val);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">let</span> stack=[];</span><br><span class="line">    <span class="keyword">let</span> node = root;</span><br><span class="line">    <span class="keyword">while</span>(node || stack.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        node=stack.pop();</span><br><span class="line">        res.push(node.val);</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的层序遍历（BFS-队列）⭐"><a href="#二叉树的层序遍历（BFS-队列）⭐" class="headerlink" title="二叉树的层序遍历（BFS 队列）⭐"></a>二叉树的层序遍历（BFS 队列）⭐</h1><h2 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h2><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树：[3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回其层序遍历结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h2><p><strong>DFS（Deep First Search）深度优先搜索。</strong></p><p><strong>BFS（Breath First Search）广度优先搜索。</strong></p><blockquote><p>思路</p></blockquote><p>遍历每一层的节点，将节点值推入 subRes 数组中</p><p>将 subRes 数组推入 res 数组中</p><p><strong>怎么获取每一层的节点</strong></p><ul><li>我们已知的是根节点，就一个</li><li>通过它可以 “找出” 第 2 层的所有节点</li><li>通过第 2 层的节点可以 “找出” 所有第 3 层的节点</li><li>…………</li></ul><p><strong>怎么存储每一层的节点</strong></p><ul><li>我们需要用一个数据结构存储每一层的节点</li><li>且我们希望某一刻新层节点全进来了，旧层节点全出去了</li><li>队列的先进先出符合要求</li><li>于是维护一个 <strong>queue 队列</strong>，是层序遍历的特征</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">let</span> queue = [root];</span><br><span class="line">    <span class="comment">// 队列中没有节点时，遍历完毕</span></span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> subRes = [];<span class="comment">//题目需要</span></span><br><span class="line">        <span class="keyword">const</span> len =queue.length;<span class="comment">//当前层的节点数目</span></span><br><span class="line">        <span class="comment">//遍历当前层的节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> cur = queue.shift();<span class="comment">// 出列</span></span><br><span class="line">            subRes.push(cur.val);<span class="comment">// 填充subRes数组</span></span><br><span class="line">            <span class="comment">// 下层节点入列</span></span><br><span class="line">            <span class="keyword">if</span>(cur.left) queue.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right) queue.push(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(subRes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>“携家带子”，queue “更新换代”</strong></p><ul><li>queue 初始时为 [root] ，代表第 1 层</li><li>开启 while 循环，对当前层的节点进行遍历</li><li>当前层的节点逐个出列，节点值推入 subRes 数组</li><li>判断如果当前出列节点有子节点，让子节点入列</li><li>本层的节点出列，下层的进来，下次循环时，queue 中全是新层的节点，没有旧层的节点while 循环终止的条件是 queue 队列空了，节点遍历完了</li></ul><p><strong>易错点</strong></p><ul><li><code>const len = queue.length</code> 必须先保存当前层的节点数，再做遍历</li><li>不能 <code>for (let i = 0; i &lt; queue.length; i++) &#123;...&#125;</code></li><li>因为在 for 循环时，queue有出列和入列，长度是动态变化的</li></ul><p><strong>复杂度</strong></p><p>记树上所有节点的个数为 n。</p><p>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 <code>O(n)</code>。<br>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 <code>O(n)</code>。</p><h1 id="二叉树的右视图（BFS）⭐"><a href="#二叉树的右视图（BFS）⭐" class="headerlink" title="二叉树的右视图（BFS）⭐"></a>二叉树的右视图（BFS）⭐</h1><h2 id="题目-26"><a href="#题目-26" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><h2 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h2><p>BFS</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rightSideView = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">let</span> queue =[root];</span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> len = queue.length;</span><br><span class="line">        <span class="keyword">while</span>(len)&#123;</span><br><span class="line">            <span class="keyword">let</span> cur=queue.shift();</span><br><span class="line">            <span class="keyword">if</span>(len === <span class="number">1</span>)res.push(cur.val);</span><br><span class="line">            <span class="keyword">if</span>(cur.left) queue.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right) queue.push(cur.right); </span><br><span class="line">            len--;          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><p>翻转一棵二叉树。</p><p><strong>示例：</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>一个二叉树，怎么才算翻转了？</p><ul><li>它的<strong>左右子树要交换</strong>，并且左右子树内部的<strong>所有子树</strong>，都要进行<strong>左右子树的交换</strong>。、</li></ul><p>每个子树的根节点都说：先交换我的左右子树吧。那么递归就会先压栈压到底。然后才做交换。<br>即，位于底部的、左右孩子都是 null 的子树，先被翻转。<br>随着递归向上返回，子树一个个被翻转……整棵树翻转好了。<br>问题是在递归出栈时解决的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="comment">// 遍历到null节点时，不用翻转，直接返回它本身</span></span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right=temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="递归思路-2"><a href="#递归思路-2" class="headerlink" title="递归思路 2"></a>递归思路 2</h4><p>思路变了：先 “做事”——<strong>先交换左右子树</strong>，它们内部的子树还没翻转——丢给递归去做。<br>把交换的操作，放在递归子树之前。<br>问题是在递归压栈前被解决的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="comment">// 遍历到null节点时，不用翻转，直接返回它本身</span></span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right=temp;</span><br><span class="line">     <span class="comment">// 内部的翻转交给递归去做</span></span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复盘总结<br>两种分别是后序遍历和前序遍历。都是基于DFS，都是先遍历根节点、再遍历左子树、再右子树。<br>唯一的区别是：<br>前序遍历：将「处理当前节点」放到「递归左子树」之前。<br>后序遍历：将「处理当前节点」放到「递归右子树」之后。</p><p>这个「处理当前节点」，就是交换左右子树 ，就是解决问题的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const temp = root.left;</span><br><span class="line">root.left = root.right;</span><br><span class="line">root.right = temp;</span><br></pre></td></tr></table></figure><p>递归帮你遍历这棵树，核心是解决问题的代码，递归把它应用到每个子树上，解决每个子问题，最后解决整个问题。</p><p>你可以选择将 “做事” 的代码，放到 DFS 过程中的一个合适的时间点，而已。</p><p>评论区有人问递归到 null 不知道返回什么：<br>递归做的事——交换当前root的左右子树，返回root。遍历到 null，它没有子树可交换，返回出这个子树（null）</p><p>。</p><p>BFS 写法<br>用层序遍历的方式去遍历二叉树。</p><p>根节点先入列，然后出列，出列就 “做事”，交换它的左右子节点（左右子树）。<br>并让左右子节点入列，往后，这些子节点出列，也被翻转。<br>直到队列为空，就遍历完所有的节点，翻转了所有子树。</p><p>解决问题的代码放在节点出列时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="comment">// 遍历到null节点时，不用翻转，直接返回它本身</span></span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> queue =[root]; <span class="comment">// 维护一个队列，初始推入第一层的root</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="keyword">const</span> cur = queue.shift();<span class="comment">// 出列的节点</span></span><br><span class="line">        <span class="comment">// 交换左右子树</span></span><br><span class="line">        <span class="comment">// 数组的结构赋值：将数组中的值按照位置提取出来，然后赋值给变量。</span></span><br><span class="line">        [cur.left,cur.right] = [cur.right,cur.left];</span><br><span class="line">        <span class="keyword">if</span>(cur.left)queue.push(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(cur.right)queue.push(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h1><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder = [9,15,7,20,3]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TprtV1"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2021/12/15/TprtV1.png" alt="TprtV1.png"></a></p><p>有了左右子树的 postOrder 和 inorder 之后，就能继续递归构建左、右子树，一直递归下去，直到：无法形成 postOrder 和 inorder 数组，就构建不出子树了，即来到树的底部了，返回 null 节点。</p><p>递归函数可以选择接受数组本身，也可以接收指针，我采用后者，根据指针 iStart 到指针 iEnd 的 inorder 数组，和从 pStart 到 pEnd 的 postorder 数组，构建当前子树，避免每次递归都要切割字符串。</p><p>定位root在inorder数组中的位置<br>我用了一个 map 去提前存下所有节点值在 inorder 数组中的索引，这样就不用每次都花 O(n) 的时间去定位 root 的位置。（不用类似 indexOf 这样的库函数），用空间换取时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">inorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">postorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">inorder, postorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map =&#123;&#125;;</span><br><span class="line">    <span class="comment">// 将节点值在inorder数组中的位置提前存入map</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">        map[inorder[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据iStart到iEnd的inorder数组，和从pStart到pEnd的postorder数组构建当前子树</span></span><br><span class="line">    <span class="keyword">const</span> helper =<span class="function">(<span class="params">iStart, iEnd, pStart, pEnd</span>) =&gt;</span>&#123;</span><br><span class="line">       <span class="comment">// 指针交错了，返回null节点</span></span><br><span class="line">       <span class="keyword">if</span>(pStart&gt;pEnd || iStart&gt;iEnd)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 获取当前要构建的根节点的值</span></span><br><span class="line">       <span class="keyword">const</span> rootVal = postorder[pEnd];</span><br><span class="line">       <span class="comment">// 获取到它在inorder数组中的位置</span></span><br><span class="line">       <span class="keyword">const</span> mid = map[rootVal];</span><br><span class="line">       <span class="comment">// 获取左子树的节点个数</span></span><br><span class="line">       <span class="keyword">const</span> leftNodeNum = mid - iStart;</span><br><span class="line">       <span class="comment">// 创建节点</span></span><br><span class="line">       <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">       <span class="comment">// 用递归构建左子树</span></span><br><span class="line">       root.left = helper(iStart,mid-<span class="number">1</span>,pStart,pStart+leftNodeNum-<span class="number">1</span>);</span><br><span class="line">       <span class="comment">// 用递归构建右子树</span></span><br><span class="line">       root.right = helper(mid+<span class="number">1</span>,iEnd,pStart+leftNodeNum,pEnd-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 返回当前构建好的子树</span></span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归的入口</span></span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>,inorder.length-<span class="number">1</span>,<span class="number">0</span>,postorder.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h1><p>给定一棵树的前序遍历 <code>preorder</code> 与中序遍历 <code>inorder</code>。请构造二叉树并返回其根节点。</p><p>思路<br>构建一个二叉树需要构建三部分：root、左子树、右子树<br>左子树、右子树的构建，又包括：root、左子树、右子树<br>解题关键在于定位出根节点，划分出左右子树，然后 递归 构建左右子树<br>具体做法<br>preorder 数组的第一项肯定是根节点 —— 因为前序遍历的顺序是 根| 左|右根∣左∣右。<br>根据根节点，在 inorder [左 | 根 | 右][左∣根∣右] 中划分出分别属于左、右子树的 inorder 序列。<br>并求出左右子树的节点个数，在 preorder 中划分出分别属于左、右子树的 preorder 序列。<br>于是就有了左、右子树的 preorder 和 inorder 序列，递归构建左、右子树就好。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildTree = <span class="function">(<span class="params">preorder, inorder</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (inorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">const</span> mid = inorder.indexOf(preorder[<span class="number">0</span>]);</span><br><span class="line">  root.left = buildTree(preorder.slice(<span class="number">1</span>, mid + <span class="number">1</span>), inorder.slice(<span class="number">0</span>, mid));</span><br><span class="line">  root.right = buildTree(preorder.slice(mid + <span class="number">1</span>), inorder.slice(mid + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="优化一下"><a href="#优化一下" class="headerlink" title="优化一下"></a>优化一下</h4><p>字符串截取存在性能消耗，没必要每次都切割。用两个指针表示即可。递归函数传指针。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildTree = <span class="function">(<span class="params">preorder, inorder</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> helper = <span class="function">(<span class="params">p_start, p_end, i_start, i_end</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p_start &gt; p_end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> rootVal = preorder[p_start];    <span class="comment">// 根节点的值</span></span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">new</span> TreeNode(rootVal);   <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">let</span> mid = inorder.indexOf(rootVal); <span class="comment">// 根节点在inorder的位置</span></span><br><span class="line">    <span class="keyword">let</span> leftNum = mid - i_start;        <span class="comment">// 左子树的节点数</span></span><br><span class="line">    root.left = helper(p_start + <span class="number">1</span>, p_start + leftNum, i_start, mid - <span class="number">1</span>);</span><br><span class="line">    root.right = helper(p_start + leftNum + <span class="number">1</span>, p_end, mid + <span class="number">1</span>, i_end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> helper(<span class="number">0</span>, preorder.length - <span class="number">1</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再次优化<br>indexOf 的使用导致每次递归都花 O(n) 的时间定位根节点的位置，不理想。<br>提前把 inorder 的元素和索引存到哈希表中，用空间换取时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">preorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">inorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map =<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="comment">// 提前把 inorder 的元素和索引存到哈希表中，用空间换取时间。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;inorder.length;i++)&#123;</span><br><span class="line">        map.set(inorder[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> helper = <span class="function">(<span class="params">pStart,pEnd,iStart,iEnd</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pStart&gt;pEnd)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> rootVal = preorder[pStart];<span class="comment">//根节点的值</span></span><br><span class="line">        <span class="keyword">let</span> root = <span class="keyword">new</span> TreeNode(rootVal);<span class="comment">//根节点</span></span><br><span class="line">        <span class="keyword">let</span> mid =map.get(rootVal);<span class="comment">//根节点在inorder中的位置</span></span><br><span class="line">        <span class="keyword">let</span> leftNum = mid-iStart; <span class="comment">//左子树的节点数</span></span><br><span class="line">        root.left = helper(pStart+<span class="number">1</span>,pStart+leftNum,iStart,mid-<span class="number">1</span>);</span><br><span class="line">        root.right = helper(pStart+leftNum+<span class="number">1</span>,pEnd,mid+<span class="number">1</span>,iEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>,preorder.length-<span class="number">1</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="最长回文子串（中心扩展）⭐"><a href="#最长回文子串（中心扩展）⭐" class="headerlink" title="最长回文子串（中心扩展）⭐"></a>最长回文子串（中心扩展）⭐</h1><h2 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</li></ul><h2 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h2><h3 id="中心扩展算法"><a href="#中心扩展算法" class="headerlink" title="中心扩展算法"></a>中心扩展算法</h3><p>两种情况</p><ul><li>一种是回文子串长度为奇数（如aba，中心是b）</li><li>另一种回文子串长度为偶数（如abba，中心是b，b）</li></ul><p>循环遍历字符串，对取到的每个值，都假设他可能成为最后的中心进行判断。</p><p>由中心向两边扩散，直到左右边界不相等时，与之前得到的回文子串长度进行比较，大的话记录。</p><p>最后通过slice()截取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> longestPalindrome = <span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 中心扩展 分奇偶</span></span><br><span class="line">    <span class="keyword">const</span> n=s.length;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">let</span> l=<span class="number">0</span>,r=<span class="number">0</span>;<span class="comment">// 截取边界 (l,r)</span></span><br><span class="line">    <span class="keyword">const</span> helper = <span class="function">(<span class="params">left,right</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; right&lt;n &amp;&amp; s[left]===s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回文串长度=right-left-1</span></span><br><span class="line">        <span class="comment">// 如果此轮询得到回文串长度大于之前记录， 记录此轮循边界</span></span><br><span class="line">        <span class="keyword">if</span>(right-left-<span class="number">1</span>&gt;r-l-<span class="number">1</span>)&#123;</span><br><span class="line">            l=left;</span><br><span class="line">            r=right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        helper(i,i); <span class="comment">// 奇数</span></span><br><span class="line">        helper(i,i+<span class="number">1</span>);<span class="comment">// 偶数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.slice(l+<span class="number">1</span>,r);</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：<code>O(n^2)</code>，其中 n 是字符串的长度。长度为 1 和 2 的回文中心分别有 <code>n</code> 和 <code>n-1</code> 个，每个回文中心最多会向外扩展 <code>O(n)</code>次。</p><p>空间复杂度：<code>O(1)</code>。</p><h3 id="动态规划-4"><a href="#动态规划-4" class="headerlink" title="动态规划"></a>动态规划</h3><h1 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h1><h2 id="题目-28"><a href="#题目-28" class="headerlink" title="题目"></a>题目</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2</span>, nums = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">2</span> ，并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span> 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按升序排列</li></ul><h2 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h2><p>双指针</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length&lt;<span class="number">2</span>)<span class="keyword">return</span> nums.length;</span><br><span class="line">    <span class="keyword">let</span> slow=<span class="number">1</span>,fast=<span class="number">1</span>;<span class="comment">// 快慢指针起始点都是原数组第二个元素</span></span><br><span class="line">    <span class="keyword">while</span>(fast&lt;nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] !== nums[fast-<span class="number">1</span>])&#123;</span><br><span class="line">            nums[slow++] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    nums.length=slow;<span class="comment">// 去重后数组长度,原数组多余部分会被删除</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)，其中 n是数组的长度。快指针和慢指针最多各移动 n 次。</p><p>空间复杂度：O(1)。只需要使用常数的额外空间。</p><h1 id="4的幂"><a href="#4的幂" class="headerlink" title="4的幂"></a>4的幂</h1><h2 id="题目-29"><a href="#题目-29" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。</p><p>整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4^x</p><p><strong>进阶：</strong>你能不使用循环或者递归来完成本题吗？</p><h2 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h2><h3 id="正则-toString"><a href="#正则-toString" class="headerlink" title="正则+toString"></a>正则+toString</h3><p>多少次幂都能搞定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPowerOfFour = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// n.toString(4) 转成4进制字符串</span></span><br><span class="line">    <span class="comment">// 正则 test检验 4的幂都是10 100 1000...</span></span><br><span class="line">    <span class="comment">// ^开头 $结尾 *匹配任何包含零个或多个0的字符串。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^10*$/</span>.test(n.toString(<span class="number">4</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><h2 id="题目-30"><a href="#题目-30" class="headerlink" title="题目"></a>题目</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><h2 id="题解-30"><a href="#题解-30" class="headerlink" title="题解"></a>题解</h2><h3 id="递归-4"><a href="#递归-4" class="headerlink" title="递归"></a>递归</h3><p>这道题可以使用递归实现，新链表也不需要构造新节点，我们下面列举递归三个要素</p><ul><li>终止条件：两条链表分别名为 <code>l1</code> 和 <code>l2</code>，当 <code>l1</code> 为空或 <code>l2</code> 为空时结束</li><li>返回值：每一层调用都返回排序好的链表头</li><li>本级递归内容：如果 <code>l1</code> 的 val 值更小，则将 <code>l1.next</code> 与排序好的链表头相接，<code>l2</code> 同理</li></ul><p><strong>复杂度分析</strong></p><p>时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)。</p><p>空间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m次，因此空间复杂度为 O(n+m)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">list1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">list2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">list1, list2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// list1&lt;list2,list1.next=null,此时令list1.next=list2</span></span><br><span class="line">    <span class="keyword">if</span>(list1 === <span class="literal">null</span>)<span class="keyword">return</span> list2</span><br><span class="line">    <span class="keyword">if</span>(list2 === <span class="literal">null</span>)<span class="keyword">return</span> list1</span><br><span class="line">    <span class="comment">// 每一层调用都返回排序好的链表头</span></span><br><span class="line">    <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">        list1.next = mergeTwoLists(list1.next,list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        list2.next = mergeTwoLists(list1,list2.next);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><p>我们可以用迭代的方法来实现上述算法。</p><p>当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。</p><p>首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。</p><p>我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。</p><p>然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。</p><p>否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。</p><p>在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。</p><p>这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">list1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">list2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">list1, list2</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 设定一个哨兵节点</span></span><br><span class="line">   <span class="keyword">const</span> prehead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">   <span class="comment">// 维护一个 prev 指针，我们需要做的是调整它的 next 指针</span></span><br><span class="line">   <span class="keyword">let</span> prev = prehead;</span><br><span class="line">   <span class="keyword">while</span>(list1 !== <span class="literal">null</span> &amp;&amp; list2 !== <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">           prev.next = list1;</span><br><span class="line">           list1 = list1.next;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           prev.next = list2;</span><br><span class="line">           list2 = list2.next;</span><br><span class="line">       &#125;</span><br><span class="line">       prev = prev.next;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">   prev.next =  (list1 === <span class="literal">null</span>) ? list2 :list1;</span><br><span class="line">   <span class="keyword">return</span> prehead.next;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h1><h2 id="题目-31"><a href="#题目-31" class="headerlink" title="题目"></a>题目</h2><p>给你两个单链表的头节点<code>headA</code>和<code>headB</code>，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。</p><p>题目数据保证整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须保持其原始结构 。</p><p>自定义评测：</p><p>评测系统 的输入如下（你设计的程序不适用此输入）：</p><ul><li>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0</li><li>listA - 第一个链表</li><li>listB - 第二个链表</li><li>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数</li><li>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p><h2 id="题解-31"><a href="#题解-31" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>对于链表 A 的每个节点，都去链表 B 中遍历一遍找看看有没有相同的节点。</p><p><strong>复杂度</strong></p><p>时间复杂度：O(M * N), M, N 分别为两个链表的长度。</p><p>空间复杂度：O(1)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">headA</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">headB</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> pA=headA;</span><br><span class="line">    <span class="keyword">while</span>(pA)&#123;</span><br><span class="line">        <span class="keyword">let</span> pB= headB;</span><br><span class="line">        <span class="keyword">while</span>(pB)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pA === pB) <span class="keyword">return</span> pA;</span><br><span class="line">            pB=pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pA= pA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h3><p>先遍历一遍链表 A，用哈希表把每个节点都记录下来(注意要存节点引用而不是节点值)。</p><p>再去遍历链表 B，找到在哈希表中出现过的节点即为两个链表的交点。</p><p><strong>复杂度</strong></p><p>时间复杂度：O(M + N), M, N 分别为两个链表的长度。</p><p>空间复杂度：O(N)，N 为链表 A 的长度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">headA</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">headB</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> hasMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> pA=headA,pB=headB;</span><br><span class="line">    <span class="keyword">while</span>(pA)&#123;</span><br><span class="line">        hasMap.set(pA,<span class="number">1</span>);</span><br><span class="line">        pA= pA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pB)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hasMap.has(pB))<span class="keyword">return</span> pB;</span><br><span class="line">        pB=pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="双指针-2"><a href="#双指针-2" class="headerlink" title="双指针"></a>双指针</h3><blockquote><p>我走过你来时的路</p></blockquote><p>两个指针分别从头开始遍历，当其中一个遍历完后，将它移到另一个链表头开始遍历，最多m+n次就能找到相交节点。</p><p>如果链表没有交点</p><ul><li>两个链表长度一样，第一次遍历结束后 pA 和 pB 都是 null，结束遍历</li><li>两个链表长度不一样，两次遍历结束后 pA 和 pB 都是 null，结束遍历</li></ul><p><strong>复杂度</strong></p><p>时间复杂度：O(M + N), M, N 分别为两个链表的长度。</p><p>空间复杂度：O(1)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">headA</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">headB</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> pA=headA,pB=headB;</span><br><span class="line">    <span class="keyword">while</span>(pA !== pB)&#123;</span><br><span class="line">        pA = pA === <span class="literal">null</span> ? headB:pA.next;</span><br><span class="line">        pB = pB === <span class="literal">null</span> ? headA:pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a>圆圈中最后剩下的数字</h1><h2 id="题目-32"><a href="#题目-32" class="headerlink" title="题目"></a>题目</h2><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><h2 id="题解-32"><a href="#题解-32" class="headerlink" title="题解"></a>题解</h2><blockquote><p>只关心最终活着那个人的序号变化</p></blockquote><p><strong>约瑟夫问题</strong></p><p>这个问题实际上是约瑟夫问题，这个问题描述是</p><p>N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。</p><p><strong>问题转换</strong></p><p>既然约塞夫问题就是用人来举例的，那我们也给每个人一个编号（索引值），每个人用字母代替</p><p>下面这个例子是N=8 m=3的例子</p><p>我们定义F(n,m)表示最后剩下那个人的索引号，因此我们只关系最后剩下来这个人的索引号的变化情况即可</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7dGhuD"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/01/17/7dGhuD.png" alt="7dGhuD.png"></a></p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7dG4De"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/01/17/7dG4De.png" alt="7dG4De.png"></a></p><p>从8个人开始，每次杀掉一个人，去掉被杀的人，然后把杀掉那个人之后的第一个人作为开头重新编号</p><p>第一次C被杀掉，人数变成7，D作为开头，（最终活下来的G的编号从6变成3）<br>第二次F被杀掉，人数变成6，G作为开头，（最终活下来的G的编号从3变成0）<br>第三次A被杀掉，人数变成5，B作为开头，（最终活下来的G的编号从0变成3）<br>以此类推，当只剩一个人时，他的编号必定为0！（重点！）<br>3 最终活着的人编号的反推<br>现在我们知道了G的索引号的变化过程，那么我们反推一下<br>从N = 7 到N = 8 的过程</p><p>如何才能将N = 7 的排列变回到N = 8 呢？</p><p>我们先把被杀掉的C补充回来，然后右移m个人，发现溢出了，再把溢出的补充在最前面</p><p>神奇了 经过这个操作就恢复了N = 8 的排列了！</p><p>因此我们可以推出递推公式f(8,3) = [f(7, 3) + 3] % 8f(8,3)=[f(7,3)+3]%8<br>进行推广泛化，即f(n,m) = [f(n-1, m) + m] % nf(n,m)=[f(n−1,m)+m]%n</p><p>4 递推公式的导出<br>再把n=1这个最初的情况加上，就得到递推公式</p><p>f(n,m)=\left{ \begin{aligned} &amp;0 &amp; &amp; {n = 1}\ &amp;[f(n-1, m) + m] % n &amp; &amp; {n &gt; 1} \ \end{aligned} \right.<br>f(n,m)={</p><p>0<br>[f(n−1,m)+m]%n</p><p>n=1<br>n&gt;1</p><p>为了更好理解，这里是拿着约瑟夫环的结论进行举例解释，具体的数学证明请参考维基百科。</p><h1 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h1><h2 id="题目-33"><a href="#题目-33" class="headerlink" title="题目"></a>题目</h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>示例 1:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">5</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>] 和 k = <span class="number">4</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= k &lt;= nums.length &lt;= <span class="number">10</span>^<span class="number">4</span></span><br><span class="line">-<span class="number">10</span>^<span class="number">4</span> &lt;= nums[i] &lt;= <span class="number">10</span>^<span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="题解-33"><a href="#题解-33" class="headerlink" title="题解"></a>题解</h2><h3 id="简洁解法"><a href="#简洁解法" class="headerlink" title="简洁解法"></a>简洁解法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findKthLargest = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// js流氓解法</span></span><br><span class="line">    <span class="keyword">return</span> nums.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span> b-a)[k-<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序整个流程可以总结为：上浮下沉</p><blockquote><p>为什么解决本题需要用到堆？</p></blockquote><p>很多同学可能会想到这样一种解决，我把数组全部排序好，这样就可以拿到第k大的元素，这样是一种解法，但是我们是需要第K大的元素，不一定要全部排序好再去拿，只针对部分元素进行排序，这样的复杂度显然可以降低的。</p><p>也就是可以转化为：使用堆排序来解决这个问题——建立一个大顶堆，做k−1 次删除操作后,堆顶元素就是我们要找的答案（堆排序过程中，不全部下沉，下沉<code>nums.length-k+1</code>,然后堆顶可以拿到我们<code>top k</code>答案了）</p><blockquote><p>基本介绍</p></blockquote><p>堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，它是一种选择排序，最坏 、最好、平均时间复杂度均为 <code>O(nlogn)</code>，它是不稳定排序。</p><blockquote><p>注意因为完全二叉树的性质，可以用数组表示对应的树结构（所以，堆排序过程中，你是看不到树这数据结构的，用数组进行映射了），这叫顺序存储。</p></blockquote><p>顺序存储二叉树</p><p>特点</p><ul><li>第 n 个元素的 左子节点 为 <code>2*n+1</code></li><li>第 n 个元素的 右子节点 为 <code>2*n+2</code></li><li>第 n 个元素的 父节点 为 <code>(n-1)/2</code></li><li>最后一个非叶子节点为 <code>Math.floor(arr.length/2)-1</code></li></ul><p>堆是具有以下性质的完全二叉树：</p><ul><li><p>大顶堆：每个节点的值都<strong>大于或等于</strong>其左右孩子节点的值</p><p>注：<strong>没有要求左右值的大小关系</strong></p></li><li><p>小顶堆：每个节点的值都<strong>小于或等于</strong>其左右孩子节点的值</p></li></ul><p>举例说明：</p><p>大顶堆举例</p><p>对堆中的节点按层进行编号，映射到数组中如下图</p><p>大顶堆特点：arr[i] &gt;= arr[2<em>i+1] &amp;&amp; arr[i] &gt;= arr[2</em>i+2]，i 对应第几个节点，i 从 0 开始编号</p><p>小顶堆举例</p><p>小顶堆特点：arr[i] &lt;= arr[2<em>i+1] &amp;&amp; arr[i] &lt;= arr[2</em>i+2]，i 对应第几个节点，i 从 0 开始</p><p>排序说明<br>升序：一般采用大顶堆<br>降序：一般采用小顶堆<br>基本思想<br>将待排序序列构造成一个大顶堆</p><p>注意：这里使用的是数组，而不是一颗二叉树</p><p>此时：整个序列的 最大值就是堆顶的根节点</p><p>将其 与末尾元素进行交换，此时末尾就是最大值</p><p>然后将剩余 n-1 个元素重新构造成一个堆，这样 就会得到 n 个元素的次小值。如此反复，便能的得到一个有序序列。</p><p>堆排序步骤图解<br>对数组 4,6,8,5,9 进行堆排序，将数组升序排序。</p><p>步骤一：构造初始堆<br>给定无序序列结构 如下：注意这里的操作用数组，树结构只是参考理解</p><p>将给定无序序列构造成一个大顶堆。</p><p>此时从最后一个非叶子节点开始调整，从左到右，从上到下进行调整。<br>叶节点不用调整，第一个非叶子节点 arr.length/2-1 = 5/2-1 = 1 ，也就是 元素为 6 的节点。</p><p>比较时：先让 5 与 9 比较，得到最大的那个，再和 6 比较，发现 9 大于 6，则调整他们的位置。</p><ol start="3"><li>找到第二个非叶子节点 4，由于 [4,9,8] 中，9 元素最大，则 4 和 9 进行交换</li></ol><p>此时，交换导致了子根 [4,5,6] 结构混乱，将其继续调整。[4,5,6] 中 6 最大，将 4 与 6 进行调整。</p><p>此时，就将一个无序序列构造成了一个大顶堆。</p><p>步骤二：将堆顶元素与末尾元素进行交换<br>将堆顶元素与末尾元素进行交换，使其末尾元素最大。然后继续调整，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</p><p>将堆顶元素 9 和末尾元素 4 进行交换</p><p>重新调整结构，使其继续满足堆定义</p><p>再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8</p><p>后续过程，继续进行调整、交换，如此反复进行，最终使得整个序列有序</p><p>总结思路<br>将无序序列构建成一个堆，根据升序降序需求选择大顶堆<br>将堆顶元素与末尾元素交换，将最大元素「沉」到数组末端<br>重新调整结构，使其满足堆定义，然后继续交换堆顶与当前末尾元素，反复执行调整、交换步骤，直到整个序列有序。<br>步骤<br>这里想说的几点注意事项（代码实现的关键思路）：</p><p>第一步构建初始堆：是自底向上构建，从最后一个非叶子节点开始。</p><p>第二步就是下沉操作让尾部元素与堆顶元素交换，最大值被放在数组末尾，并且缩小数组的length，不参与后面大顶堆的调整</p><p>第三步就是调整：是从上到下，从左到右,因为堆顶元素下沉到末尾了，要重新调整这颗大顶堆</p><h1 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h1><h2 id="题目-34"><a href="#题目-34" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><blockquote><p>示例 1：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [<span class="string">&quot;flower&quot;</span>,<span class="string">&quot;flow&quot;</span>,<span class="string">&quot;flight&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;fl&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>示例 2：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;racecar&quot;</span>,<span class="string">&quot;car&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;&quot;</span></span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure><blockquote><p>提示：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= strs.length &lt;= <span class="number">200</span></span><br><span class="line"><span class="number">0</span> &lt;= strs[i].length &lt;= <span class="number">200</span></span><br><span class="line">strs[i] 仅由小写英文字母组成</span><br></pre></td></tr></table></figure><h2 id="题解-34"><a href="#题解-34" class="headerlink" title="题解"></a>题解</h2><h3 id="逐个比较"><a href="#逐个比较" class="headerlink" title="逐个比较"></a>逐个比较</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">strs</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> longestCommonPrefix =<span class="function"><span class="params">strs</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = strs.length;</span><br><span class="line">    <span class="comment">// 字符串数组为空</span></span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 初始化最长公共前缀为第一个字符串</span></span><br><span class="line">    <span class="keyword">let</span> ans = strs[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 与其他字符串两两相比，不断截取以得到最长公共前缀</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> j=<span class="number">0</span>;<span class="comment">// 放在for循环外面是因为字符串长度不一致</span></span><br><span class="line">        <span class="keyword">for</span>(;j&lt;ans.length &amp;&amp; j &lt; strs[i].length;j++) &#123;</span><br><span class="line">            <span class="comment">// 字符串也可以用[]进行字符访问</span></span><br><span class="line">            <span class="keyword">if</span>(ans[j] !== strs[i][j])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从0索引开始截取j个 </span></span><br><span class="line">        ans = ans.substr(<span class="number">0</span>, j); </span><br><span class="line">        <span class="comment">// 最长公共前缀变为&quot;&quot;就提前返回</span></span><br><span class="line">        <span class="keyword">if</span>(ans===<span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leslie Waong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesliewaong.top/posts/b976e516.html">https://lesliewaong.top/posts/b976e516.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lesliewaong.top" target="_blank">Leslie Waong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JS/">JS</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/Letcode/">Letcode</a><a class="post-meta__tags" href="/tags/CodeTop/">CodeTop</a></div><div class="post_share"><div class="social-share" data-image="https://s4.ax1x.com/2021/12/17/Ti4Oq1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/7cb809c.html"><img class="prev-cover" src="https://s4.ax1x.com/2021/12/17/Ti5SPO.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaScript进阶</div></div></a></div><div class="next-post pull-right"><a href="/posts/1d0f8d42.html"><img class="next-cover" src="https://s4.ax1x.com/2021/12/17/Ti4hV0.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">前端常见面试题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/caa34564.html" title="JS数组常用方法总结"><img class="cover" src="https://s4.ax1x.com/2021/12/17/Ti4aDI.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-11</div><div class="title">JS数组常用方法总结</div></div></a></div><div><a href="/posts/54b11a0c.html" title="Promise"><img class="cover" src="https://s4.ax1x.com/2021/12/17/Ti4HxJ.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-25</div><div class="title">Promise</div></div></a></div><div><a href="/posts/1d0f8d42.html" title="前端常见面试题"><img class="cover" src="https://s4.ax1x.com/2021/12/17/Ti4hV0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-12</div><div class="title">前端常见面试题</div></div></a></div><div><a href="/posts/8fbd8643.html" title="手写源码系列"><img class="cover" src="https://s4.ax1x.com/2021/12/29/T29QfI.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-10</div><div class="title">手写源码系列</div></div></a></div><div><a href="/posts/a9ba4134.html" title="JavaScript基础"><img class="cover" src="https://s4.ax1x.com/2021/12/17/Ti5ZIf.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-11</div><div class="title">JavaScript基础</div></div></a></div><div><a href="/posts/c6d48fcf.html" title="ES6+"><img class="cover" src="https://s4.ax1x.com/2021/12/17/Ti4jVx.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-02</div><div class="title">ES6+</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Leslie Waong</div><div class="author-info__description">BUPT</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">95</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lesliewaong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lesliewaong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1138964397&amp;website=www.qtxml.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">红雨漂泊泛起了回忆怎么潜</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">算法性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7O"><span class="toc-text">什么是大O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E8%A7%84%E6%A8%A1%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-text">不同数据规模的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%96%E7%AE%80"><span class="toc-text">复杂表达式的化简</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#O-logn-%E4%B8%AD%E7%9A%84log%E6%98%AF%E4%BB%A5%E4%BB%80%E4%B9%88%E4%B8%BA%E5%BA%95%EF%BC%9F"><span class="toc-text">O(logn)中的log是以什么为底？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%81"><span class="toc-text">递归算法的时间与空间复杂度分析！</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-text">时间复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-text">空间复杂度分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%9B%E7%A0%81%E7%BD%91OJ"><span class="toc-text">赛码网OJ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5API"><span class="toc-text">输入API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E4%B8%80%E8%A1%8C%E8%BE%93%E5%85%A5"><span class="toc-text">读取一行输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96n%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="toc-text">读取n个字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%EF%BC%88%E9%95%BF%EF%BC%89%E6%95%B4%E6%95%B0"><span class="toc-text">读取一个（长）整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-text">读取一个浮点型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BAAPI"><span class="toc-text">输出API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8A%A0%E5%9B%9E%E8%BD%A6%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-text">不加回车的输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%9B%9E%E8%BD%A6%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-text">带回车的输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%811"><span class="toc-text">示例代码1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%812"><span class="toc-text">示例代码2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E5%8F%B0%E9%98%B6%E6%B5%8B%E8%AF%95"><span class="toc-text">上台阶测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%9B%E5%AE%A2%E7%BD%91"><span class="toc-text">牛客网</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%E6%B5%8B%E8%AF%95"><span class="toc-text">最长公共前缀测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-text">斐波那契数列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%EF%BC%88%E8%B6%85%E6%97%B6%EF%BC%89"><span class="toc-text">递归（超时）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="toc-text">动态规划</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E2%AD%90"><span class="toc-text">爬楼梯(动态规划)⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-1"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="toc-text">动态规划</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98"><span class="toc-text">青蛙跳台阶问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E2%AD%90"><span class="toc-text">最大子数组和(动态规划)⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-2"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="toc-text">动态规划</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%88%E8%B4%AA%E5%BF%83%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89%E2%AD%90"><span class="toc-text">买卖股票的最佳时机（贪心、动态规划）⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-3"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-3"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83-1"><span class="toc-text">贪心</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="toc-text">买卖股票的最佳时机 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-4"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-4"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83-2"><span class="toc-text">贪心</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-5"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-5"><span class="toc-text">题解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%88%E7%9B%B4%E6%8E%A5%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%81%E9%80%86%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89%E2%AD%90"><span class="toc-text">合并两个有序数组（直接、双指针、逆向双指针）⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-6"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-6"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%90%88%E5%B9%B6%E5%90%8E%E6%8E%92%E5%BA%8F"><span class="toc-text">方法一：直接合并后排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">方法二：双指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E9%80%86%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">方法三：逆向双指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89%E2%AD%90"><span class="toc-text">字符串相加（双指针）⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-7"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-7"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7-%E5%88%86%E5%89%B2%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88-%E2%AD%90"><span class="toc-text">比较版本号(分割、双指针)⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-8"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-8"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2"><span class="toc-text">字符串分割</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="toc-text">双指针</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-%E5%93%88%E5%B8%8C%E8%A1%A8map-%E2%AD%90"><span class="toc-text">两数之和(哈希表map)⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-9"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-9"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%EF%BC%88%E6%A0%88-%E5%93%88%E5%B8%8C%E8%A1%A8Map%EF%BC%89%E2%AD%90"><span class="toc-text">有效的括号（栈+哈希表Map）⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-10"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-10"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%A0%88"><span class="toc-text">方法一：栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E2%AD%90"><span class="toc-text">无重复字符的最长子串⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-11"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-11"><span class="toc-text">题解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%88%E5%BF%AB%E6%8E%92%EF%BC%89"><span class="toc-text">排序数组（快排）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-12"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-12"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%80%9D%E8%B7%AF"><span class="toc-text">基础思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-text">基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-text">最小栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-13"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-13"><span class="toc-text">题解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9"><span class="toc-text">封装链表节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3-%E3%80%81%E9%80%92%E5%BD%92%EF%BC%89%E2%AD%90"><span class="toc-text">反转链表（迭代 、递归）⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-14"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-14"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">迭代 双指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E8%A7%A3"><span class="toc-text">栈解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8map%E3%80%81%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%EF%BC%89%E2%AD%90"><span class="toc-text">环形链表（哈希表map、快慢指针）⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-15"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-15"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%9F%E5%8A%A9%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">借助哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-text">快慢指针法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="toc-text">反转链表 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-16"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-16"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%A9%BF%E9%92%88%E5%BC%95%E7%BA%BF"><span class="toc-text">方法一：穿针引线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86%E3%80%8C%E7%A9%BF%E9%92%88%E5%BC%95%E7%BA%BF%E3%80%8D%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E5%A4%B4%E6%8F%92%E6%B3%95%EF%BC%89"><span class="toc-text">方法二：一次遍历「穿针引线」反转链表（头插法）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-1"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">二叉树的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">满二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">完全二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">平衡二叉搜索树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">二叉树的存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-text">二叉树的遍历方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">二叉树的定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%EF%BC%88%E9%80%92%E5%BD%92-%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89%E2%AD%90"><span class="toc-text">路径总和（递归+二叉树）⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-17"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-17"><span class="toc-text">题解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-18"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-18"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text">链表中倒数第k个节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-19"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-19"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-text">顺序查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-text">快慢指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88BFS%EF%BC%89%E2%AD%90"><span class="toc-text">二叉树的最大深度（BFS）⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-20"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-20"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92-1"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFS-%E5%85%B8%E5%9E%8B%E7%9A%84BFS%E6%A8%A1%E6%9D%BF%E5%86%99%E6%B3%95"><span class="toc-text">BFS (典型的BFS模板写法)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0"><span class="toc-text">Excel表列名称</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-21"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-21"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的前序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-22"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-22"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92-2"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-text">迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-%E9%9D%9E%E7%BB%9F%E4%B8%80%E6%A0%BC%E5%BC%8F"><span class="toc-text">方法一 非统一格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-%E7%BB%9F%E4%B8%80%E6%A0%BC%E5%BC%8F"><span class="toc-text">方法二 统一格式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-23"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-23"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92-3"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="toc-text">迭代实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E3%80%81%E8%BF%AD%E4%BB%A3%EF%BC%88%E6%A0%88%EF%BC%89%EF%BC%89%E2%AD%90"><span class="toc-text">二叉树的中序遍历（递归、迭代（栈））⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-24"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-24"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88BFS-%E9%98%9F%E5%88%97%EF%BC%89%E2%AD%90"><span class="toc-text">二叉树的层序遍历（BFS 队列）⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-25"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-25"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE%EF%BC%88BFS%EF%BC%89%E2%AD%90"><span class="toc-text">二叉树的右视图（BFS）⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-26"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-26"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">翻转二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%80%9D%E8%B7%AF-2"><span class="toc-text">递归思路 2</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">从前序与中序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E4%B8%80%E4%B8%8B"><span class="toc-text">优化一下</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95%EF%BC%89%E2%AD%90"><span class="toc-text">最长回文子串（中心扩展）⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-27"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-27"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95%E7%AE%97%E6%B3%95"><span class="toc-text">中心扩展算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-4"><span class="toc-text">动态规划</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-text">删除有序数组中的重复项</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-28"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-28"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E7%9A%84%E5%B9%82"><span class="toc-text">4的幂</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-29"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-29"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99-toString"><span class="toc-text">正则+toString</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">合并两个有序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-30"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-30"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92-4"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-1"><span class="toc-text">迭代</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-text">相交链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-31"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-31"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E6%B3%95"><span class="toc-text">暴力法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-1"><span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-2"><span class="toc-text">双指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">圆圈中最后剩下的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-32"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-32"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-text">数组中的第K个最大元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-33"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-33"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E6%B4%81%E8%A7%A3%E6%B3%95"><span class="toc-text">简洁解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">堆排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-text">最长公共前缀</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-34"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-34"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E4%B8%AA%E6%AF%94%E8%BE%83"><span class="toc-text">逐个比较</span></a></li></ol></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/58c5541d.html" title="跨域通信"><img src="https://s4.ax1x.com/2022/02/20/HLcGKx.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="跨域通信"></a><div class="content"><a class="title" href="/posts/58c5541d.html" title="跨域通信">跨域通信</a><time datetime="2022-03-03T11:10:23.000Z" title="发表于 2022-03-03 19:10:23">2022-03-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6154ca16.html" title="从URL输入到页面展现到底发生什么？"><img src="https://s4.ax1x.com/2022/03/03/bt3nG6.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="从URL输入到页面展现到底发生什么？"></a><div class="content"><a class="title" href="/posts/6154ca16.html" title="从URL输入到页面展现到底发生什么？">从URL输入到页面展现到底发生什么？</a><time datetime="2022-03-03T05:14:52.000Z" title="发表于 2022-03-03 13:14:52">2022-03-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2c5b9cd5.html" title="HTTP相关内容"><img src="https://s4.ax1x.com/2022/03/03/btsdSg.png" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="HTTP相关内容"></a><div class="content"><a class="title" href="/posts/2c5b9cd5.html" title="HTTP相关内容">HTTP相关内容</a><time datetime="2022-03-02T03:11:12.000Z" title="发表于 2022-03-02 11:11:12">2022-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c33f9478.html" title="cookie、sessionStorage、localStorage 详解及应用场景"><img src="https://s4.ax1x.com/2022/03/01/bQ1ipn.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="cookie、sessionStorage、localStorage 详解及应用场景"></a><div class="content"><a class="title" href="/posts/c33f9478.html" title="cookie、sessionStorage、localStorage 详解及应用场景">cookie、sessionStorage、localStorage 详解及应用场景</a><time datetime="2022-03-01T02:11:13.000Z" title="发表于 2022-03-01 10:11:13">2022-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ebeefcc9.html" title="异步编程和事件循环"><img src="https://s4.ax1x.com/2022/03/01/bQ1k60.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="异步编程和事件循环"></a><div class="content"><a class="title" href="/posts/ebeefcc9.html" title="异步编程和事件循环">异步编程和事件循环</a><time datetime="2022-02-27T05:12:12.000Z" title="发表于 2022-02-27 13:12:12">2022-02-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Leslie Waong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:""},null))},e=()=>{twikoo.getCommentsCount({envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))},n=(n=!1)=>{"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})};btf.loadComment(document.getElementById("twikoo-wrap"),n)})()</script></div><div class="aplayer no-destroy" data-id="6995412795" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="auto" data-autoplay="true" muted></div><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":0,"vOffset":0},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body></html>