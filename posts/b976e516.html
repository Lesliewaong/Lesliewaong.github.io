<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>算法题（JS） | Leslie Waong</title><meta name="keywords" content="JS,算法,Letcode,CodeTop"><meta name="author" content="Leslie Waong"><meta name="copyright" content="Leslie Waong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="合并两个有序数组题目给你两个按非递减顺序排列的整数数组nums1和nums2，另有两个整数m和n，分别表示nums1和nums2中的元素数目。 请你合并nums2到nums1中，使合并后的数组同样按非递减顺序排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组nums1中。为了应对这种情况，nums1的初始长度为m + n，其中前m个元素表示应合并的元素，后n个元素为0 ，应忽略。nums">
<meta property="og:type" content="article">
<meta property="og:title" content="算法题（JS）">
<meta property="og:url" content="https://lesliewaong.top/posts/b976e516.html">
<meta property="og:site_name" content="Leslie Waong">
<meta property="og:description" content="合并两个有序数组题目给你两个按非递减顺序排列的整数数组nums1和nums2，另有两个整数m和n，分别表示nums1和nums2中的元素数目。 请你合并nums2到nums1中，使合并后的数组同样按非递减顺序排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组nums1中。为了应对这种情况，nums1的初始长度为m + n，其中前m个元素表示应合并的元素，后n个元素为0 ，应忽略。nums">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/17/Ti4Oq1.jpg">
<meta property="article:published_time" content="2021-12-01T02:37:47.000Z">
<meta property="article:modified_time" content="2021-12-17T13:46:09.012Z">
<meta property="article:author" content="Leslie Waong">
<meta property="article:tag" content="JS">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="Letcode">
<meta property="article:tag" content="CodeTop">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s4.ax1x.com/2021/12/17/Ti4Oq1.jpg"><link rel="shortcut icon" href="https://z3.ax1x.com/2021/08/21/fv5m9O.jpg"><link rel="canonical" href="https://lesliewaong.top/posts/b976e516"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"一年之内的产物","messageNext":"技术可能存在过期"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Leslie Waong","link":"链接: ","source":"来源: Leslie Waong","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法题（JS）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-17 21:46:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link defer rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/css/icon.css"><link defer rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Leslie Waong" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://z3.ax1x.com/2021/08/21/fv5m9O.jpg" onerror="onerror=null;src='https://lesliewaong.top/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s4.ax1x.com/2021/12/17/Ti4Oq1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leslie Waong</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法题（JS）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-01T02:37:47.000Z" title="发表于 2021-12-01 10:37:47">2021-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-17T13:46:09.012Z" title="更新于 2021-12-17 21:46:09">2021-12-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>77分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法题（JS）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个按<strong>非递减顺序</strong>排列的整数数组nums1和nums2，另有两个整数m和n，分别表示nums1和nums2中的元素数目。</p>
<p>请你合并nums2到nums1中，使合并后的数组同样按<strong>非递减顺序</strong>排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组<code>nums1</code>中。为了应对这种情况，nums1的初始长度为<code>m + n</code>，其中前m个元素表示应合并的元素，后n个元素为0 ，应忽略。nums2 的长度为 n 。</p>
<blockquote>
<p> 示例 ：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span>, nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">输入：nums1 = [<span class="number">1</span>], m = <span class="number">1</span>, nums2 = [], n = <span class="number">0</span></span><br><span class="line">输出：[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输入：nums1 = [<span class="number">0</span>], m = <span class="number">0</span>, nums2 = [<span class="number">1</span>], n = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums1.length == m + n</span><br><span class="line">nums2.length == n</span><br><span class="line"><span class="number">0</span> &lt;= m, n &lt;= <span class="number">200</span></span><br><span class="line"><span class="number">1</span> &lt;= m + n &lt;= <span class="number">200</span></span><br><span class="line">-<span class="number">10</span>^<span class="number">9</span> &lt;= nums1[i], nums2[j] &lt;= <span class="number">10</span>^<span class="number">9</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>进阶：</p>
</blockquote>
<p>你可以设计实现一个时间复杂度为 <strong>O(m + n)</strong> 的算法解决此问题吗？</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一：直接合并后排序"><a href="#方法一：直接合并后排序" class="headerlink" title="方法一：直接合并后排序"></a>方法一：直接合并后排序</h3><p>最直观的方法是先将数组nums2 放进数组nums1的尾部，然后直接对整个数组进行排序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">    nums1.splice(m, nums1.length - m, ...nums2);</span><br><span class="line">    nums1.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>复杂度分析</p>
</blockquote>
<p>时间复杂度：<code>O((m+n)log(m+n))</code>。<br>排序序列长度为 m+n，套用<strong>快速排序</strong>的时间复杂度即可，平均情况为 O((m+n)log(m+n))。</p>
<p>空间复杂度：<code>O(log(m+n))</code>。<br>排序序列长度为 m+n，套用快速排序的空间复杂度即可，平均情况为 O(log(m+n))。</p>
<h3 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h3><p>这一方法将两个数组看作队列，每次从两个数组头部取出比较小的数字放到结果中。如下面的动画所示：</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/88/1.gif" alt="gif1"></p>
<p>我们为两个数组分别设置一个指针p1与p2 来作为队列的头部指针。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> sorted = <span class="keyword">new</span> <span class="built_in">Array</span>(m + n).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">var</span> cur;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 === m) &#123;</span><br><span class="line">            cur = nums2[p2++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 === n) &#123;</span><br><span class="line">            cur = nums1[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">            cur = nums1[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = nums2[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        sorted[p1 + p2 - <span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i != m + n; ++i) &#123;</span><br><span class="line">        nums1[i] = sorted[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>复杂度分析</p>
</blockquote>
<p>时间复杂度：<code>O(m+n)</code>。<br>指针移动单调递增，最多移动m+n次，因此时间复杂度为O(m+n)。</p>
<p>空间复杂度：<code>O(m+n)</code>。<br>需要建立长度为m+n的中间数组sorted。</p>
<h3 id="方法三：逆向双指针"><a href="#方法三：逆向双指针" class="headerlink" title="方法三：逆向双指针"></a>方法三：逆向双指针</h3><p>这个时候我们就要分析，为什么告诉我们 <code>nums1.length &gt;= m + n</code>?</p>
<p>很明显就能猜出出题者的意图，那就是考查<strong>原地修改</strong> ，将空间复杂度降低到 <code>O(1)</code>。</p>
<p>因为这样不需要使用额外的数组空间了，我们完全可以把nums2也放入nums1 中。</p>
<p>原地修改时，为了避免从前往后遍历导致原有数组元素被破坏掉，我们要选择<strong>从后往前遍历</strong>！</p>
<p>所以，我们总共需要创建三个指针，两个指针用于指向nums1 和nums2 的初始化元素数量的末位，也就是分别指向m-1和n−1的位置，还有一个指针，我们指向nums1数组末位m+n-1即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>, k = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) nums1[k--] = nums2[j--];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j &lt; <span class="number">0</span>) nums1[k--] = nums1[i--];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j]) nums1[k--] = nums2[j--];</span><br><span class="line">        <span class="keyword">else</span> nums1[k--] = nums1[i--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>复杂度分析</p>
</blockquote>
<p>时间复杂度：<code>O(m+n)</code>。</p>
<p>指针移动单调递减，最多移动m+n 次，因此时间复杂度为O(m+n)。</p>
<p>空间复杂度：<code>O(1)</code>。<br>直接对数组nums1原地修改，不需要额外空间。</p>
<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的最长子串的长度。</p>
<blockquote>
<p>示例 1:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例 2:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例 3:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> &lt;= s.length &lt;= <span class="number">5</span> * <span class="number">10</span>^<span class="number">4</span></span><br><span class="line">s 由英文字母、数字、符号和空格组成</span><br></pre></td></tr></table></figure>

<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><blockquote>
<p>滑动窗口</p>
</blockquote>
<p>我们先用一个例子考虑如何在较优的时间复杂度内通过本题。</p>
<p>我们不妨以示例一中的字符串<code>abcabcbb</code> 为例，找出从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p>
<p>以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；<br>以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb；<br>以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb；<br>以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb；<br>以 abca(b)cbb 开始的最长字符串为 abca(bc)bb；<br>以 abcab(c)bb 开始的最长字符串为 abcab(cb)b；<br>以 abcabc(b)b 开始的最长字符串为 abcabc(b)b；<br>以 abcabcb(b) 开始的最长字符串为 abcabcb(b)。</p>
<p>发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 k个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 r_k。那么当我们选择第k+1 个字符作为起始位置时，首先从k+1 到 r_k的字符显然是不重复的，并且由于少了原本的第k 个字符，我们可以尝试继续增大 r_k，直到右侧出现了重复字符为止。</p>
<p>这样一来，我们就可以使用「滑动窗口」来解决这个问题了：</p>
<ul>
<li><p>我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中<code>枚举子串的起始位置</code>，而右指针即为上文中的 r_k；</p>
</li>
<li><p>在每一步的操作中，我们会将左指针向右移动一格，表示我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；</p>
</li>
<li><p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p>
</li>
</ul>
<p>判断重复字符</p>
<p>在上面的流程中，我们还需要使用一种数据结构来判断是否有重复的字符，常用的数据结构为哈希集合（即 <code>C++</code> 中的 <code>std::unordered_set</code>，<code>Java</code> 中的 <code>HashSet</code>，<code>Python</code> 中的 <code>set</code>, <code>JavaScript</code> 中的 <code>Set</code>）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。</p>
<h1 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a>字符串相加</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p>
<p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p>
<blockquote>
<p>示例 1：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num1 = <span class="string">&quot;11&quot;</span>, num2 = <span class="string">&quot;123&quot;</span></span><br><span class="line">输出：<span class="string">&quot;134&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= num1.length, num2.length &lt;= <span class="number">10</span>^<span class="number">4</span></span><br><span class="line">num1 和num2 都只包含数字 <span class="number">0</span>-<span class="number">9</span></span><br><span class="line">num1 和num2 都不包含任何前导零</span><br></pre></td></tr></table></figure>

<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>因为本题不能使用任何 BigInteger 库，所以我们可以使用双指针来模拟人工计算，步骤如下：</p>
<ul>
<li>创建指针 i 指向 nums1 末位数字，j 指向 nums2末位数字。</li>
<li>i, j 数字相加，用进位就用 carry 来记录进位值，无则为0。</li>
<li>若产生进位，则当前数字为 (i+j)%10 的值。</li>
<li>若遍历过程中，nums1 或 nums2 当前已无数字，则用0 补位来计算。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addStrings = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i=num1.length-<span class="number">1</span>,j=num2.length-<span class="number">1</span>,carry=<span class="number">0</span>,ans=[];</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span> || carry !== <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> c1 = i&gt;=<span class="number">0</span> ? num1.charAt(i)-<span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>,</span><br><span class="line">            c2 = j&gt;=<span class="number">0</span> ? num2.charAt(j)-<span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> sum = c1+c2+carry;</span><br><span class="line">        ans.push(sum % <span class="number">10</span>);</span><br><span class="line">        carry = <span class="built_in">Math</span>.floor(sum/<span class="number">10</span>);</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a>排序数组</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums，请你将该数组升序排列。</p>
<blockquote>
<p>示例 1：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例 2：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">50000</span></span><br><span class="line">-<span class="number">50000</span> &lt;= nums[i] &lt;= <span class="number">50000</span></span><br></pre></td></tr></table></figure>

<h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><h3 id="基础思路"><a href="#基础思路" class="headerlink" title="基础思路"></a>基础思路</h3><ol>
<li>如果数组剩下一个以下，那就返回数组</li>
<li>如果数组有 2 个及以上，那么设置中间点 <code>mid</code></li>
<li>通过遍历，将小于中间点 <code>mid</code> 的放左边 <code>left</code>，大于中间点 <code>mid</code> 的放右边 <code>right</code></li>
<li>返回重组后的数组</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="keyword">let</span> midIndex = <span class="built_in">Math</span>.floor(nums.length/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> mid = nums.splice(midIndex,<span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> left =[];</span><br><span class="line">    <span class="keyword">let</span> right = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (nums[i] &lt; mid) &#123; </span><br><span class="line">　　　　　　left.push(nums[i]); </span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">　　　　　　right.push(nums[i]); </span><br><span class="line">　　　　&#125; </span><br><span class="line">　　&#125;</span><br><span class="line">    <span class="keyword">return</span> sortArray(left).concat([mid], sortArray(right));</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 和为目标值 <code>target</code>  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] == <span class="number">9</span> ，返回 [<span class="number">0</span>, <span class="number">1</span>] 。</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> &lt;= nums.length &lt;= <span class="number">104</span></span><br><span class="line">-<span class="number">10</span>^<span class="number">9</span> &lt;= nums[i] &lt;= <span class="number">10</span>^<span class="number">9</span></span><br><span class="line">-<span class="number">10</span>^<span class="number">9</span> &lt;= target &lt;= <span class="number">10</span>^<span class="number">9</span></span><br><span class="line">只会存在一个有效答案</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进阶：</p>
</blockquote>
<p>你可以想出一个时间复杂度小于 O(n2) 的算法吗？</p>
<h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><blockquote>
<p>暴破</p>
</blockquote>
<p>最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</p>
<p>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[j]===target)&#123;</span><br><span class="line">                <span class="keyword">return</span> [i,j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：<code>O(N^2)</code>，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</p>
<p>空间复杂度：O(1)。</p>
<blockquote>
<p>哈希表</p>
</blockquote>
<p>我们遍历到数字 a时，用 target 减去 a，就会得到 b，若 b 存在于哈希表中，我们就可以直接返回结果了。若 b 不存在，那么我们需要将 a 存入哈希表，好让后续遍历的数字使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map= <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,len=nums.length;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(target-nums[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> [map.get(target-nums[i]),i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.set(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1)地寻找 target - x。</p>
<p>空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。</p>
<h1 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>给你两个版本号 version1 和 version2 ，请你比较它们。</p>
<p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p>
<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p>
<p>返回规则如下：</p>
<p>如果 version1 &gt; version2 返回 1，<br>如果 version1 &lt; version2 返回 -1，<br>除此之外返回 0。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：version1 = <span class="string">&quot;1.01&quot;</span>, version2 = <span class="string">&quot;1.001&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：忽略前导零，<span class="string">&quot;01&quot;</span> 和 <span class="string">&quot;001&quot;</span> 都表示相同的整数 <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line">输入：version1 = <span class="string">&quot;1.0&quot;</span>, version2 = <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：version1 没有指定下标为 <span class="number">2</span> 的修订号，即视为 <span class="string">&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">输入：version1 = <span class="string">&quot;0.1&quot;</span>, version2 = <span class="string">&quot;1.1&quot;</span></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：version1 中下标为 <span class="number">0</span> 的修订号是 <span class="string">&quot;0&quot;</span>，version2 中下标为 <span class="number">0</span> 的修订号是 <span class="string">&quot;1&quot;</span> 。<span class="number">0</span> &lt; <span class="number">1</span>，所以 version1 &lt; version2</span><br><span class="line"></span><br><span class="line">输入：version1 = <span class="string">&quot;7.5.2.4&quot;</span>, version2 = <span class="string">&quot;7.5.3&quot;</span></span><br><span class="line">输出：-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= version1.length, version2.length &lt;= <span class="number">500</span></span><br><span class="line">version1 和 version2 仅包含数字和 <span class="string">&#x27;.&#x27;</span></span><br><span class="line">version1 和 version2 都是 有效版本号</span><br><span class="line">version1 和 version2 的所有修订号都可以存储在 <span class="number">32</span> 位整数 中</span><br></pre></td></tr></table></figure>

<h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一：字符串分割"><a href="#方法一：字符串分割" class="headerlink" title="方法一：字符串分割"></a>方法一：字符串分割</h3><p>我们可以将版本号按照点号分割成修订号，然后从左到右比较两个版本号的相同下标的修订号。在比较修订号时，需要将字符串转换成整数进行比较。注意根据题目要求，如果版本号不存在某个下标处的修订号，则该修订号视为 0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compareVersion = <span class="function"><span class="keyword">function</span>(<span class="params">version1, version2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> v1=version1.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> v2=version2.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;v1.length || i&lt;v2.length;++i)&#123;</span><br><span class="line">        <span class="keyword">let</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;v1.length)&#123;</span><br><span class="line">            x=<span class="built_in">parseInt</span>(v1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;v2.length)&#123;</span><br><span class="line">            y=<span class="built_in">parseInt</span>(v2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n+m)（或O(max(n,m))，这是等价的），其中 n 是字符串version1 的长度，m 是字符串 version2 的长度。</p>
<p>空间复杂度：O(n+m)，我们需要 O(n+m)的空间存储分割后的修订号列表。</p>
<h3 id="方法二：双指针-1"><a href="#方法二：双指针-1" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h3><p>方法一需要存储分割后的修订号，为了优化空间复杂度，我们可以在分割版本号的同时解析出修订号进行比较。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compareVersion = <span class="function"><span class="keyword">function</span>(<span class="params">version1, version2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = version1.length, m = version2.length;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n || j &lt; m) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n &amp;&amp; version1[i] !== <span class="string">&#x27;.&#x27;</span>; ++i) &#123;</span><br><span class="line">            x = x * <span class="number">10</span> + version1[i].charCodeAt() - <span class="string">&#x27;0&#x27;</span>.charCodeAt();</span><br><span class="line">        &#125;</span><br><span class="line">        ++i; <span class="comment">// 跳过点号</span></span><br><span class="line">        <span class="keyword">let</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; m &amp;&amp; version2.charAt(j) !== <span class="string">&#x27;.&#x27;</span>; ++j) &#123;</span><br><span class="line">            y = y * <span class="number">10</span> + version2[j].charCodeAt() - <span class="string">&#x27;0&#x27;</span>.charCodeAt();</span><br><span class="line">        &#125;</span><br><span class="line">        ++j; <span class="comment">// 跳过点号</span></span><br><span class="line">        <span class="keyword">if</span> (x !== y) &#123;</span><br><span class="line">            <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n+m)，其中 n 是字符串version1 的长度，m 是字符串 version2 的长度。</p>
<p>空间复杂度：O(1)，我们只需要常数的空间保存若干变量。</p>
<h1 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<p>示例 ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：连续子数组 [<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span> 。</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">23</span></span><br></pre></td></tr></table></figure>


<p>提示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">105</span></span><br><span class="line">-<span class="number">104</span> &lt;= nums[i] &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure>


<p>进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。</p>
<h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><h3 id="解法一：暴力枚举-超时"><a href="#解法一：暴力枚举-超时" class="headerlink" title="解法一：暴力枚举(超时)"></a>解法一：暴力枚举(超时)</h3><p>由题意可知，此题是在求连续子组合的最大值<br>双重循环，内循环初始值跟着外循环后面，确保是在求连续子组合的和<br>当前遍历数字也有可能是最大数即所求组合为一个数；例如[9,-2,-3,-4,-5]</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="built_in">Number</span>.MIN_SAFE_INTEGER;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> sum =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;max)&#123;</span><br><span class="line">                max=sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h4><p>解题思路：</p>
<p>示例: [a, b , c, d , e]</p>
<p>解答这类题目, 省略不掉遍历, 因此我们先从遍历方式说起</p>
<p>通常我们遍历子串或者子序列有三种遍历方式</p>
<ul>
<li><p>以某个节点为开头的所有子序列: 如 [a]，[a, b]，[ a, b, c] … 再从以 b 为开头的子序列开始遍历 [b] [b, c]。</p>
</li>
<li><p>根据子序列的长度为标杆，如先遍历出子序列长度为 1 的子序列，在遍历出长度为 2 的 等等。</p>
</li>
<li><p><strong>以子序列的结束节点为基准，先遍历出以某个节点为结束的所有子序列，因为每个节点都可能会是子序列的结束节点，因此要遍历下整个序列</strong>，如: 以 b 为结束点的所有子序列: [a , b] [b] 以 c 为结束点的所有子序列: [a, b, c] [b, c] [ c ]。</p>
</li>
</ul>
<p>第一种遍历方式通常用于暴力解法, 第二种遍历方式 leetcode (5. 最长回文子串 ) 中的解法就用到了。</p>
<p><strong>第三种遍历方式 因为可以产生递推关系, 采用动态规划时, 经常通过此种遍历方式, 如 背包问题, 最大公共子串 , 这里的动态规划解法也是以 先遍历出 以某个节点为结束节点的所有子序列 的思路</strong></p>
<p>对于刚接触动态规划的, 我感觉熟悉第三种遍历方式是需要抓住的核心</p>
<p>因为我们通常的惯性思维是以子序列的开头为基准，先遍历出以 a 为开头的所有子序列，再遍历出以 b 为开头的…但是动态规划为了找到不同子序列之间的递推关系，恰恰是以子序列的结束点为基准的，这点开阔了我们的思路。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kadane算法扫描一次整个数列的所有数值，</span></span><br><span class="line"><span class="comment">// 在每一个扫描点计算以该点数值为结束点的子数列的最大和（正数和）。</span></span><br><span class="line"><span class="comment">// 该子数列由两部分组成：以前一个位置为结束点的最大子数列、该位置的数值。</span></span><br><span class="line"><span class="comment">// 因为该算法用到了“最佳子结构”（以每个位置为终点的最大子数列都是基于其前一位置的最大子数列计算得出, </span></span><br><span class="line"><span class="comment">// 该算法可看成动态规划的一个例子。</span></span><br><span class="line"><span class="comment">// 状态转移方程：sum[i] = max&#123;sum[i-1]+a[i],a[i]&#125;   </span></span><br><span class="line"><span class="comment">// 其中(sum[i]记录以a[i]为子序列末端的最大序子列连续和)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.length)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在每一个扫描点计算以该点数值为结束点的子数列的最大和（正数和）。</span></span><br><span class="line">    <span class="keyword">let</span> maxEnd = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">// 以每个位置为终点的最大子数列 都是基于其前一位置的最大子数列计算得出</span></span><br><span class="line">        maxEnd = <span class="built_in">Math</span>.max(nums[i],maxEnd+nums[i]);</span><br><span class="line">        maxSum = <span class="built_in">Math</span>.max(maxSum,maxEnd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="comment">// if(sum &gt; 0) &#123; 可以写成这样</span></span><br><span class="line">        <span class="comment">//if(sum + num &gt; num )&#123;</span></span><br><span class="line">        <span class="comment">//    sum = sum + num;</span></span><br><span class="line">        <span class="comment">//&#125; else &#123;</span></span><br><span class="line">        <span class="comment">//    sum = num;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        sum = (sum&gt;<span class="number">0</span>) ? sum+num:num;</span><br><span class="line">        ans = <span class="built_in">Math</span>.max(ans, sum);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二块代码和 第一块代码 思路实现是完全一样的，但是如果第一次看到这类题目，直接阅读 第二块代码，理解起来很难，尤其是 如果改成 <code>if (sum &gt; 0 )</code> 对于刚接触的这题目的比较不好理解。</p>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p> <strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<h2 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h2><h3 id="解法一：迭代"><a href="#解法一：迭代" class="headerlink" title="解法一：迭代"></a>解法一：迭代</h3><p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<p><img src="https://c1.im5i.com/2021/12/06/cA1rJ.jpg" alt="cA1rJ.jpg"></p>
<blockquote>
<p>关键</p>
</blockquote>
<p>将当前节点的指针指向上一个节点</p>
<p>然后更新当前节点和下一个节点的值即顺移</p>
<blockquote>
<p>技巧</p>
</blockquote>
<p>设置哨兵节点 null，初始化时将head节点指向null，下一步将next指向head</p>
<p>重复以上动作直到当前节点为尾节点的节点null</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>;<span class="comment">// 设置哨兵节点 null，初始化时将head节点指向null</span></span><br><span class="line">    <span class="keyword">let</span> curr = head;<span class="comment">// 当前节点,初始化 头节点</span></span><br><span class="line">    <span class="comment">// 直到当前节点为尾节点的节点null</span></span><br><span class="line">    <span class="keyword">while</span>(curr !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 保存当前节点的指针指向（下一个节点）</span></span><br><span class="line">        <span class="keyword">const</span> next = curr.next;</span><br><span class="line">        <span class="comment">// 将当前节点的指针指向上一个节点（此时原指向就断开了，所以需要提前保存）</span></span><br><span class="line">        curr.next = prev;</span><br><span class="line">        <span class="comment">// 将当前节点更新为上一个节点</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        <span class="comment">// 根据之前保存的指针更新当前节点</span></span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：尾递归"><a href="#解法二：尾递归" class="headerlink" title="解法二：尾递归"></a>解法二：尾递归</h3><blockquote>
<p>思路</p>
</blockquote>
<p>其实就是解法一的简化版</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prev = curr;</span><br><span class="line">curr = next;</span><br></pre></td></tr></table></figure>

<p>此解法将上面放在递归里返回</p>
<p>都是将当前节点指向前一个节点的操作之后，来顺移更新前一个、当前、和下一个节点的操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过递归实现 prev=curr；curr=next</span></span><br><span class="line">   <span class="keyword">let</span> reverse = <span class="function">(<span class="params">prev,curr</span>)=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!curr)<span class="keyword">return</span> prev;</span><br><span class="line">       c next = curr.next;</span><br><span class="line">       curr.next = prev;</span><br><span class="line">       <span class="keyword">return</span> reverse(curr,next);</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">//初始化头节点指向和当前节点</span></span><br><span class="line">   <span class="keyword">return</span> reverse(<span class="literal">null</span>,head);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：递归"><a href="#解法三：递归" class="headerlink" title="解法三：递归"></a>解法三：递归</h3><p>关键是反转操作</p>
<ul>
<li><p>当前节点 head，下一个节点 head.next</p>
</li>
<li><p>head.next.next = head</p>
<ul>
<li>此处将原 head.next 指向head，即是反转</li>
</ul>
</li>
<li><p>head.next = null</p>
<ul>
<li>此处将原 head 指向head.next的指针断开</li>
</ul>
</li>
</ul>
<p>递归</p>
<ul>
<li><p>由编译器函数调用执行栈原理可知</p>
<ul>
<li><strong>最先调用的函数会在递归过程中最后被执行，而最后调用的会最先执行</strong></li>
</ul>
</li>
<li><p>因此此题，<strong>最先返回最后两个节点开始反转操作</strong></p>
<ul>
<li>依次从后面两两节点开始反转</li>
</ul>
</li>
</ul>
<p><img src="https://c1.im5i.com/2021/12/06/c8d88.png" alt="c8d88.png"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果测试用例只有一个节点 或者 递归到了尾节点，返回当前节点 </span></span><br><span class="line">    <span class="keyword">if</span>(!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 存储当前节点的下一个节点</span></span><br><span class="line">    <span class="keyword">const</span> reverseHead = reverseList(head.next);</span><br><span class="line">    <span class="comment">// 反转，后一个节点连接当前节点</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    <span class="comment">// 断开 head ，如图闪电⚡️标记处</span></span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> reverseHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法四：栈解"><a href="#解法四：栈解" class="headerlink" title="解法四：栈解"></a>解法四：栈解</h3><ul>
<li><p>思路</p>
<ul>
<li>既然是反转，那么符合栈先进后出的特点</li>
<li>将原节点依次入栈</li>
<li>出栈时，重新构造链表改变指向</li>
<li>同样设置哨兵节点<ul>
<li>最后返回哨兵的next即为所求</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = head;</span><br><span class="line">    <span class="keyword">let</span> tHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> pre = tHead;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">        stack.push(tmp.val);</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stack.length != <span class="number">0</span>)&#123;</span><br><span class="line">        pre.next = <span class="keyword">new</span> ListNode(stack.pop());</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tHead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="反转链表-II"><a href="#反转链表-II" class="headerlink" title="反转链表 II"></a>反转链表 II</h1><h2 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h2><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], left = <span class="number">2</span>, right = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h2 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一：穿针引线"><a href="#方法一：穿针引线" class="headerlink" title="方法一：穿针引线"></a>方法一：穿针引线</h3><p>我们以下图中黄色区域的链表反转为例。</p>
<p><img src="https://pic.leetcode-cn.com/1615105129-iUPoGi-image.png" alt="img"></p>
<p>使用「反转链表」的解法，反转 left 到 right 部分以后，再拼接起来。我们还需要记录 left 的前一个节点，和 right 的后一个节点。如图所示：</p>
<p><img src="https://pic.leetcode-cn.com/1615105150-pfWiGq-image.png" alt="image.png"></p>
<p>算法步骤：</p>
<p>第 1 步：先将待反转的区域反转；</p>
<p>第 2 步：把 pre 的 next 指针指向反转以后的链表头节点，把反转以后的链表的尾节点的 next 指针指向 succ。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseBetween = <span class="function"><span class="keyword">function</span>(<span class="params">head, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论</span></span><br><span class="line">    <span class="keyword">const</span> dummyNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> pre = dummyNode;</span><br><span class="line">    <span class="comment">// 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点</span></span><br><span class="line">    <span class="comment">// 建议写在 for 循环里，语义清晰</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点</span></span><br><span class="line">    <span class="keyword">let</span> rightNode = pre;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        rightNode = rightNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 3 步：切断出一个子链表（截取链表）</span></span><br><span class="line">    <span class="keyword">let</span> leftNode = pre.next;</span><br><span class="line">    <span class="keyword">let</span> curr = rightNode.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：切断链接</span></span><br><span class="line">    pre.next = <span class="literal">null</span>;</span><br><span class="line">    rightNode.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 4 步：同第 206 题，反转链表的子区间</span></span><br><span class="line">    reverseLinkedList(leftNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 5 步：接回到原来的链表中</span></span><br><span class="line">    pre.next = rightNode;</span><br><span class="line">    leftNode.next = curr;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reverseLinkedList = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">const</span> next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N是链表总节点数。最坏情况下，需要遍历整个链表。</li>
<li>空间复杂度：O(1)。只使用到常数个变量。</li>
</ul>
<h3 id="方法二：一次遍历「穿针引线」反转链表（头插法）"><a href="#方法二：一次遍历「穿针引线」反转链表（头插法）" class="headerlink" title="方法二：一次遍历「穿针引线」反转链表（头插法）"></a>方法二：一次遍历「穿针引线」反转链表（头插法）</h3><p>方法一的缺点是：如果 left 和 right 的区域很大，恰好是链表的头节点和尾节点时，找到 left 和 right 需要遍历一次，反转它们之间的链表还需要遍历一次，虽然总的时间复杂度为 O(N)O(N)，但遍历了链表 22 次，可不可以只遍历一次呢？答案是可以的。我们依然画图进行说明。</p>
<p>整体思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。下面的图展示了整个流程。</p>
<p><img src="https://pic.leetcode-cn.com/1615105242-ZHlvOn-image.png" alt="img"></p>
<p>下面我们具体解释如何实现。使用三个指针变量 pre、curr、next 来记录反转的过程中需要的变量，它们的意义如下：</p>
<p>curr：指向待反转区域的第一个节点 left；<br>next：永远指向 curr 的下一个节点，循环过程中，curr 变化以后 next 会变化；<br>pre：永远指向待反转区域的第一个节点 left 的前一个节点，在循环过程中不变。</p>
<p>第 1 步，我们使用 ①、②、③ 标注「穿针引线」的步骤。</p>
<p><img src="https://pic.leetcode-cn.com/1615105296-bmiPxl-image.png" alt="img"></p>
<p>操作步骤：</p>
<p>先将 curr 的下一个节点记录为 next；<br>执行操作 ①：把 curr 的下一个节点指向 next 的下一个节点；<br>执行操作 ②：把 next 的下一个节点指向 pre 的下一个节点；<br>执行操作 ③：把 pre 的下一个节点指向 next。<br>第 1 步完成以后「拉直」的效果如下：</p>
<p><img src="https://pic.leetcode-cn.com/1615105340-UBnTBZ-image.png" alt="img"></p>
<p>第 2 步，同理。同样需要注意 <strong>「穿针引线」操作的先后顺序</strong>。</p>
<p><img src="https://pic.leetcode-cn.com/1615105353-PsCmzb-image.png" alt="img"></p>
<p>第 2 步完成以后「拉直」的效果如下：</p>
<p><img src="https://pic.leetcode-cn.com/1615105364-aDIFqy-image.png" alt="img"></p>
<p>第 3 步，同理。</p>
<p><img src="https://pic.leetcode-cn.com/1615105376-jIyGwv-image.png" alt="img"></p>
<p>第 3 步完成以后「拉直」的效果如下：</p>
<p><img src="https://pic.leetcode-cn.com/1615105395-EJQnMe-image.png" alt="img"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseBetween = <span class="function"><span class="keyword">function</span>(<span class="params">head, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">    <span class="keyword">const</span> dummy_node = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy_node.next = head;</span><br><span class="line">    <span class="keyword">let</span> pre = dummy_node;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> cur = pre.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; right - left; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> next = cur.next;</span><br><span class="line">        cur.next = next.next;</span><br><span class="line">        next.next = pre.next;</span><br><span class="line">        pre.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy_node.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<p>时间复杂度：O(N)，其中 N 是链表总节点数。最多只遍历了链表一次，就完成了反转。</p>
<p>空间复杂度：O(1)。只使用到常数个变量。</p>
<h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><h2 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;()&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;()[]&#123;&#125;&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;([)]&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;&#123;[]&#125;&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<h2 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一：栈"><a href="#方法一：栈" class="headerlink" title="方法一：栈"></a>方法一：栈</h3><p>判断括号的有效性可以使用「栈」这一数据结构来解决。</p>
<p>我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p>
<p>当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。</p>
<p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False。</p>
<p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回False，省去后续的遍历判断过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = s.length;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> pairs = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">        [<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>]</span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">const</span> stk = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">if</span> (pairs.has(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!stk.length || stk[stk.length - <span class="number">1</span>] !== pairs.get(ch)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            stk.push(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> !stk.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)，其中 nn 是字符串 s 的长度。</p>
<p>空间复杂度：O(n+∣Σ∣)，其中 Σ 表示字符集，本题中字符串只包含 6种括号，∣Σ∣=6。栈中的字符数量为 O(n)，而哈希表使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度。</p>
<h1 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h1><h2 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h2><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<blockquote>
<p>示例 </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入： <span class="number">2</span></span><br><span class="line">输出： <span class="number">2</span></span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">2</span> 阶</span><br><span class="line"></span><br><span class="line">输入： <span class="number">3</span></span><br><span class="line">输出： <span class="number">3</span></span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span>  <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure>

<h2 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一-动态规划"><a href="#方法一-动态规划" class="headerlink" title="方法一 动态规划"></a>方法一 动态规划</h3><p><strong>假设 n = 5，有 5 级楼梯要爬</strong></p>
<p>题意说，每次有2种选择：爬1级，或，爬2级。</p>
<ul>
<li><p>如果爬1级，则剩下4级要爬。</p>
</li>
<li><p>如果爬2级，则剩下3级要爬。</p>
</li>
</ul>
<p>这拆分出 2 个问题：</p>
<ul>
<li><p>爬4级楼梯有几种方式？</p>
</li>
<li><p>爬3级楼梯有几种方式？</p>
</li>
</ul>
<p>于是，爬 5 级楼梯的方式数 = 爬 4 级楼梯的方式数 + 爬 3 级楼梯的方式数。</p>
<p><strong>画出递归树</strong></p>
<p>用「剩下要爬的楼梯数」描述一个节点。</p>
<p>子问题又会面临 2 个选择，不断分支，直到遇到位于递归树底部的 base case：</p>
<ul>
<li>楼梯数为 0 时，只有 1 种选择：什么都不做。</li>
<li>楼梯数为 1 时，只有1种选择：爬1级。</li>
</ul>
<p>当递归遍历到 base case，解是已知的，开始返回，子问题的结果不断向上返回，得到父问题的解。</p>
<p>调用栈的深度是楼梯数n，空间复杂度是<code>O(n)</code>，时间复杂度最坏是<code>O(2^n)</code>，所有节点都遍历到。</p>
<p><strong>存在重复的子问题</strong></p>
<p>子问题的计算结果可以存到合适的数据结构中，下次遇到就不用再进入相同的递归。</p>
<p>去除重复的计算后的子树如下，时间复杂度降到了O(n)，空间复杂度O(n)。</p>
<p><strong>动态规划，自底而上思考</strong></p>
<p>从后往前思考：爬到 i 层，必然要先爬到 i-2 或 i-1 层。</p>
<p>即有，<code>爬 i 层楼梯的方式数 = 爬 i-2 层楼梯的方式数 + 爬 i-1 层楼梯的方式数</code>。</p>
<p>如前所述，我们有两个 base case，结合上面的递推式，就能递推出爬 i 层楼梯的方式数。</p>
<p>用一个数组 dp 存放中间子问题的结果。</p>
<p><code>定义dp[i]：爬 i 级楼梯的方式数</code>。从base case: <code>dp[0], dp[1]</code>出发，顺序计算，直到算出dp[i]。</p>
<p><code>dp[i-]=dp[i-1]+dp[i-2]</code>;</p>
<p><strong>压缩空间，优化</strong></p>
<p>dp[i] 只与过去的两项：dp[i-1] 和 dp[i-2] 有关，没有必要存下所有计算过的 dp 项。用两个变量去存这两个过去的状态就好。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> climbStairs = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> cur = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = cur;   <span class="comment">// 暂存上一次的cur</span></span><br><span class="line">    cur = prev + cur;   <span class="comment">// 当前的cur = 上上次cur + 上一次cur</span></span><br><span class="line">    prev = temp;        <span class="comment">// prev 更新为 上一次的cur</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：循环执行 n次，每次花费常数的时间代价，故渐进时间复杂度为 <code>O(n)</code>。</p>
<p>空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 <code>O(1)</code>。</p>
<p><strong>可以用动态规划的问题都能用递归</strong></p>
<p>从子问题入手，解决原问题，分两种做法：自顶向下和自底向上</p>
<p>前者对应递归，借助函数调用自己，是程序解决问题的方式，它不会记忆解</p>
<p>后者对应动态规划，利用迭代将子问题的解存在数组里，从数组0位开始顺序往后计算</p>
<p>递归的缺点在于包含重复的子问题（没有加记忆化的情况下），动态规划的效率更高</p>
<p><strong>DP也有局限性</strong></p>
<p>DP 相比于 递归，有时候不太好理解，或者边界情况比较难确定</p>
<p>而且必须是一步步邻接的，连续地计算</p>
<p>加入了记忆化的递归，就灵活很多，它在递归基础上稍作修改，往往更好理解，也少了局限性，不好用DP时一定能用它</p>
<p>比如有时候要求出达到某个结果的路径，递归（DFS）回溯出路径，显然更有优势</p>
<h1 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numWays = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> MOD=<span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="number">1</span> ,cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> temp = cur;</span><br><span class="line">        cur = (prev+cur) % MOD;</span><br><span class="line">        prev=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><h2 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h2><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p>
<p><code>F(0) = 0,   F(1) = 1</code></p>
<p><code>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</code></p>
<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 100</code></li>
</ul>
<h2 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> MOD=<span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="number">0</span>,cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = cur;   <span class="comment">// 暂存上一次的cur</span></span><br><span class="line">        cur = (prev + cur)%MOD;   <span class="comment">// 当前的cur = 上上次cur + 上一次cur</span></span><br><span class="line">        prev = temp;        <span class="comment">// prev 更新为 上一次的cur</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><h3 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h3><h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><h2 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p>示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 6</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<h2 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h2><p>每一位都有3种选择：1、2、3。</p>
<p>每一次都做选择，展开出一棵空间树，如下图。</p>
<p>利用约束条件「不能重复选」，做剪枝，剪去不会产生正确解的选项（分支）。</p>
<ul>
<li>用一个 hashMap，记录选过的数，下次遇到相同的数，跳过。</li>
<li>这样就不会进入「不会得出解的分支」，做无效的搜索。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oIdMdO"><img src="https://s1.ax1x.com/2021/12/10/oIdMdO.png" alt="oIdMdO.png"></a></p>
<p><strong>怎么写递归函数</strong></p>
<p>我们要在这个包含解的空间树上，用 DFS（递归）的方式搜索出所有的解。</p>
<p>dfs 函数：基于当前的 path，继续选数，直到构建出合法的path，加入解集。</p>
<ul>
<li><p>递归的入口：dfs 执行传入空 path，什么都还没选。</p>
</li>
<li><p>函数体内，用 for 循环枚举出当前所有的选项，并用 if 语句跳过剪枝项。</p>
<ul>
<li>每一轮迭代，作出一个选择，基于它，继续选（递归调用）。</li>
</ul>
</li>
<li><p>递归的出口：当构建的 path 数组长度等于 nums 长度，就选够了，加入解集。</p>
</li>
</ul>
<p><strong>为什么要回溯</strong></p>
<p>我们不是找到一个排列就完事，要找出所有满足条件的排列。</p>
<p>递归结束时，结束的是当前的递归分支，还要去别的分支继续搜。</p>
<p>所以，要撤销当前的选择，回到选择前的状态，去选下一个选项，即切入下一个分支。</p>
<p>注意，往map添加的当前选择也要同时撤销。代表没有做这个选择。</p>
<p>退回来，把路走全，才能在一棵空间树中，回溯出所有的解。</p>
<p><strong>解答评论区的困惑</strong></p>
<p>为什么加入解集时，要将数组内容拷贝到一个新的数组里，再加入解集。</p>
<p>因为该 path 变量存的是地址引用，结束当前递归时，将它加入 res 后，还要进入别的递归分支继续搜索，还要继续传递该 path 给别的递归调用，它所指向的内存空间还要继续被操作，所以 res 中的 path 的内容会被改变，这就不对。所以要弄一份当前的拷贝，放入 res，这样后续对 path 的操作，就不会影响已经放入 res 的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> used = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.length === nums.length) &#123; <span class="comment">// 个数选够了</span></span><br><span class="line">            <span class="comment">// 拷贝一份path，加入解集res</span></span><br><span class="line">            <span class="comment">// slice，start和end都不写，返回数组中所有元素</span></span><br><span class="line">            res.push(path.slice()); </span><br><span class="line">            <span class="keyword">return</span>;                 <span class="comment">// 结束当前递归分支</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123; <span class="comment">// for枚举出每个可选的选项</span></span><br><span class="line">            <span class="comment">// if (path.includes(num)) continue; // 别这么写！查找是O(n)，增加时间复杂度</span></span><br><span class="line">            <span class="keyword">if</span> (used[num]) <span class="keyword">continue</span>; <span class="comment">// 使用过的，跳过</span></span><br><span class="line">            path.push(num);         <span class="comment">// 选择当前的数，加入path</span></span><br><span class="line">            used[num] = <span class="literal">true</span>;       <span class="comment">// 记录一下 使用了</span></span><br><span class="line">            dfs(path);              <span class="comment">// 基于选了当前的数，递归</span></span><br><span class="line">            path.pop();             <span class="comment">// 上一句的递归结束，回溯，将最后选的数pop出来</span></span><br><span class="line">            used[num] = <span class="literal">false</span>;      <span class="comment">// 撤销这个记录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs([]); <span class="comment">// 递归的入口，空path传进去</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h1><h2 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<blockquote>
<p>示例</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ooiseS"><img src="https://s1.ax1x.com/2021/12/10/ooiseS.jpg" alt="ooiseS.jpg"></a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p>树中节点的数目在范围 [0, 5000] 内<br>-1000 &lt;= Node.val &lt;= 1000<br>-1000 &lt;= targetSum &lt;= 1000</p>
<h2 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h2><blockquote>
<p>思路</p>
</blockquote>
<p>sum ： 从根节点到叶子节点的路径上的节点值相加的目标和</p>
<p>对 root 递归。转为判断：root 的左、右子树中能否找出和为 sum-root.val 的路径</p>
<p>就变成一个规模小一点的相同问题</p>
<p>即，每遍历一个节点，sum 就减去当前节点值，当遍历到叶子节点时，因为没有子节点了，如果 sum - 当前叶子节点值 == 0 ，即找到了从根节点到叶子节点的和为 sum 的路径</p>
<p>时间复杂度：O(n)，每个节点被遍历一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">targetSum</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123; <span class="comment">// 遍历到null节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;                </span><br><span class="line">  <span class="keyword">if</span> (root.left === <span class="literal">null</span> &amp;&amp; root.right === <span class="literal">null</span>) &#123; <span class="comment">// 遍历到叶子节点</span></span><br><span class="line">    <span class="keyword">return</span> targetSum - root.val == <span class="number">0</span>;                  <span class="comment">// 如果满足这个就返回true。否则返回false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不是上面的情况，则拆成两个子树的问题，其中一个true了就行</span></span><br><span class="line">  <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">9</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: <span class="number">9</span> 出现在 nums 中并且下标为 <span class="number">4</span></span><br><span class="line"></span><br><span class="line">输入: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">2</span></span><br><span class="line">输出: -<span class="number">1</span></span><br><span class="line">解释: <span class="number">2</span> 不存在 nums 中因此返回 -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>
</ol>
<h2 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h2><blockquote>
<p>思路</p>
</blockquote>
<p>这道题目的前提是数组为有序数组，同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p>
<p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p>
<p>大家写二分法经常写乱，主要是因为对区间的定义没有想清楚，区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。</p>
<p>写二分法，区间的定义一般为两种，左闭右闭即<code>[left, right]</code>，或者左闭右开即<code>[left, right)</code>。</p>
<blockquote>
<p>二分法第一种写法</p>
</blockquote>
<p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，也就是<code>[left, right]</code> （这个很重要非常重要）。</p>
<p>区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点：</p>
<p><code>while (left &lt;= right)</code> 要使用 <code>&lt;=</code> ，因为left == right是有意义的，所以使用 &lt;=</p>
<p><code>if (nums[middle] &gt; target)</code> right 要赋值为 <code>middle - 1</code>，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</p>
<p>例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oo8wqg"><img src="https://s1.ax1x.com/2021/12/10/oo8wqg.png" alt="oo8wqg.png"></a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 区间 [l, r]</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;<span class="comment">//向右移位实现除以2，并向下取整</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] === target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">let</span> isSmall = nums[mid] &lt; target;</span><br><span class="line">        l = isSmall ? mid + <span class="number">1</span> : l;</span><br><span class="line">        r = isSmall ? r : mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>二分法第二种写法</p>
</blockquote>
<p>如果说定义 target 是在一个在左闭右开的区间里，也就是<code>[left, right)</code> ，那么二分法的边界处理方式则截然不同。</p>
<p>有如下两点：</p>
<p><code>while (left &lt; right)</code>，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</p>
<p><code>if (nums[middle] &gt; target)</code> right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</p>
<p>在数组：1,2,3,4,7,9,10中查找元素2，如图所示：（注意和方法一的区别）</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oo87J1"><img src="https://s1.ax1x.com/2021/12/10/oo87J1.png" alt="oo87J1.png"></a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = nums.length;</span><br><span class="line">    <span class="comment">// 区间 [l, r）</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] === target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">let</span> isSmall = nums[mid] &lt; target;</span><br><span class="line">        l = isSmall ? mid + <span class="number">1</span> : l;</span><br><span class="line">        <span class="comment">// 所以 mid 不会被取到</span></span><br><span class="line">        r = isSmall ? r : mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><h2 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p>示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 104]</code></li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>
</ul>
<h2 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h2><p>暴力法<br>cur1 每遍历到一个节点，就让 cur2 从头遍历之前所有节点<br>如果 cur2 走到 cur1，所用的步数二者一样，则相遇点不是入环点<br>如果 cur2 走到 cur1，用的步数二者不一样，则相遇点是入环点，<strong>cur1比 cur2多走一个环</strong></p>
<p>时间复杂度为 O(n^2)，空间复杂度为 O(1)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cur1 = head;    <span class="comment">// cur1指针</span></span><br><span class="line">  <span class="keyword">let</span> step1 = <span class="number">0</span>;      <span class="comment">// cur1指针走的步数</span></span><br><span class="line">  <span class="keyword">while</span> (cur1) &#123;</span><br><span class="line">    step1++;</span><br><span class="line">    <span class="keyword">let</span> cur2 = head;  <span class="comment">// cur2指针从头遍历</span></span><br><span class="line">    <span class="keyword">let</span> step2 = <span class="number">0</span>;    <span class="comment">// cur2指针走的步数</span></span><br><span class="line">    <span class="keyword">while</span> (cur2) &#123;</span><br><span class="line">      step2++;</span><br><span class="line">      <span class="keyword">if</span> (cur1 === cur2) &#123;     <span class="comment">// cur1和cur2的元素相同</span></span><br><span class="line">        <span class="keyword">if</span> (step1 === step2) &#123; <span class="comment">// 如果走的步数一样，即走到了cur1这里</span></span><br><span class="line">          <span class="keyword">break</span>;              <span class="comment">// 退出内层while</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;              <span class="comment">// 相遇但步数不一样</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">// 说明链表有环。cur1比cur2多走一个环</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cur2 = cur2.next;   <span class="comment">// cur2一次走一步</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur1 = cur1.next;     <span class="comment">// cur1一次走一步</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法2：借助哈希表<br>哈希表存遍历过的节点，每遍历一个节点，都查看哈希表是否存在当前节点，如果存在，则说明链表有环<br>如果不存在，则存入哈希表，继续遍历<br>时间复杂度为 O(n)，空间复杂度为 O(n)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">while</span> (head) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(head)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    map.set(head, <span class="literal">true</span>); <span class="comment">// 存的是节点的地址引用，而不是节点值</span></span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>快慢指针法<br>快、慢指针，从头节点出发<br>慢指针每次走一步，快指针每次走两步，不断比较它们指向的节点的值<br>如果节点值相同，说明有环。如果不同，继续循环。<br>类似 “追及问题”<br>两个人在环形跑道上赛跑，同一个起点出发，一个跑得快一个跑得慢，在某一时刻，跑得快的必定会追上跑得慢的，只要是跑道是环形的，不是环形就肯定追不上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> fast = head;</span><br><span class="line">  <span class="keyword">let</span> slow = head;</span><br><span class="line">  <span class="keyword">while</span> (fast) &#123;                        </span><br><span class="line">    <span class="keyword">if</span> (fast.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 如果Next就出去了，说明没有环</span></span><br><span class="line">    slow = slow.next;                 </span><br><span class="line">    fast = fast.next.next; </span><br><span class="line">    <span class="comment">// 相对速度是1，快的只能一格一格追，有环的话最终在一格相遇</span></span><br><span class="line">    <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(N)，其中 N 是链表中的节点数。</p>
<p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p>
<p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。</p>
<p>空间复杂度：O(1)。我们只使用了两个指针的额外空间。</p>
<h1 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h1><h2 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p>示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span>-<span class="number">1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span>-<span class="number">1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"></span><br><span class="line">输入：prices = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 10^5</code></li>
<li><code>0 &lt;= prices[i] &lt;= 10^4</code></li>
</ul>
<h2 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>因为股票就买卖一次，那么贪心的想法很自然就是取最左最小值，取最右最大值，那么得到的差值就是最大利润。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">prices</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans= <span class="number">0</span>,low=prices[<span class="number">0</span><span class="comment">// 重点是维护这个最小值（贪心的思想） </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">        low=<span class="built_in">Math</span>.min(low,prices[i]);<span class="comment">// 贪心地选择左面的最小价格</span></span><br><span class="line">        ans=<span class="built_in">Math</span>.max(ans,prices[i]-low);<span class="comment">// 遍历一趟就可以获得最大利润</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>动规五部曲分析如下：</p>
<ul>
<li><p>确定dp数组（dp table）以及下标的含义</p>
<p><code>dp[i][0]</code> 表示第i天持有股票所得最多现金 ，这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？</p>
<p>其实一开始现金是0，那么加入第i天买入股票现金就是 <code>-prices[i]</code>， 这是一个负数。</p>
<p><code>dp[i][1]</code> 表示第i天不持有股票所得最多现金</p>
<p>注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态</p>
</li>
<li><p>确定递推公式</p>
<p>如果第i天持有股票即<code>dp[i][0]</code>， 那么可以由两个状态推出来</p>
<ul>
<li><p>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：<code>dp[i - 1][0]</code></p>
</li>
<li><p>第i天买入股票，所得现金就是买入今天的股票后所得现金即：<code>-prices[i]</code></p>
</li>
</ul>
<p>那么<code>dp[i][0]</code>应该选所得现金最大的，所以<code>dp[i][0] = max(dp[i - 1][0], -prices[i]);</code></p>
<p>如果第i天不持有股票即<code>dp[i][1]</code>， 也可以由两个状态推出来</p>
<ul>
<li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：<code>dp[i - 1][1]</code></li>
<li>第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：<code>prices[i] + dp[i - 1][0]</code></li>
</ul>
<p>同样<code>dp[i][1]</code>取最大的，<code>dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);</code></p>
</li>
<li><p>dp数组如何初始化</p>
<p>由递推公式 <code>dp[i][0] = max(dp[i - 1][0], -prices[i]);</code> 和 <code>dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);</code>可以看出</p>
<p>其基础都是要从<code>dp[0][0]</code>和<code>dp[0][1]</code>推导出来。</p>
<p>那么<code>dp[0][0]</code>表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以<code>dp[0][0] -= prices[0];</code></p>
<p><code>dp[0][1]</code>表示第0天不持有股票，不持有股票那么现金就是0，所以<code>dp[0][1] = 0;</code></p>
</li>
<li><p>确定遍历顺序</p>
<p>从递推公式可以看出<code>dp[i]</code>都是有<code>dp[i - 1]</code>推导出来的，那么一定是<strong>从前向后遍历</strong>。</p>
</li>
<li><p>举例推导dp数组</p>
<p>以示例1，输入：[7,1,5,3,6,4]为例，dp数组状态如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/obbAb9"><img src="https://s4.ax1x.com/2021/12/12/obbAb9.png" alt="obbAb9.png"></a></p>
</li>
</ul>
<p><code>dp[5][1]</code>就是最终结果。</p>
<p>为什么不是<code>dp[5][0]</code>呢？</p>
<p><strong>因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！</strong></p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>从递推公式可以看出，dp[i]只是依赖于dp[i - 1]的状态。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>那么我们只需要记录 当前天的dp状态和前一天的dp状态就可以了，可以使用滚动数组来节省空间，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">prices</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>)  </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = prices.length;</span><br><span class="line">    <span class="comment">// 创建dp数组</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill([<span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// dp数组初始化</span></span><br><span class="line">    dp[<span class="number">0</span>] = [-prices[<span class="number">0</span>], <span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 更新dp[i]</span></span><br><span class="line">        dp[i] = [</span><br><span class="line">            <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]),</span><br><span class="line">            <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)<br>空间复杂度：O(1)<br>这里能写出版本一就可以了，版本二虽然原理都一样，但是想直接写出版本二还是有点麻烦，容易自己给自己找bug。</p>
<p>所以建议是先写出版本一，然后在版本一的基础上优化成版本二，而不是直接就写出版本二。</p>
<h1 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h1><h2 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<p>1 &lt;= prices.length &lt;= 3 * 10^4<br>0 &lt;= prices[i] &lt;= 10^4</p>
<h2 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h2><p>贪心</p>
<p>这道题不是让你实时参与决策。给定一张已知的折线图，问你最多从中赚多少钱。<br>遵循：低买高卖。遍历数组，只要今天比昨天高，就卖，赚差价。<br>连续涨的，也是一天一卖，卖了当天再买，和留到峰顶再卖，差价是一样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">prices</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> profit = <span class="number">0</span>;<span class="comment">//收益</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">        <span class="comment">// 今天和昨天的差价大于0，就昨天买，今天卖，赚差价</span></span><br><span class="line">        profit += (prices[i]-prices[i-<span class="number">1</span>])&gt;<span class="number">0</span> ? prices[i]-prices[i-<span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// profit += Math.max(prices[i]-prices[i-1],0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><h2 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：</p>
<p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<h2 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>一个树的最大深度 = 根节点的高度（即1）+ 左右子树的最大深度中的较大者。<br>“嗨，maxDepth函数，请帮我计算出我的左右子树的最大深度，我等你的返回结果，我就能算出自己的最大深度了。”<br>递归的结束条件：当遍历到 null 节点，它们的高度是 0，返回 0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> leftMaxDepth =maxDepth(root.left);</span><br><span class="line">    <span class="keyword">const</span> rightMaxDepth=maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">Math</span>.max(leftMaxDepth,rightMaxDepth);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度<ul>
<li>最坏情况下 O(n) 退化为单链表</li>
<li>最好情况下 O(logn) 为平衡二叉树且高度为logn</li>
</ul>
</li>
</ul>
<h3 id="BFS-典型的BFS模板写法"><a href="#BFS-典型的BFS模板写法" class="headerlink" title="BFS (典型的BFS模板写法)"></a>BFS (典型的BFS模板写法)</h3><p>队列 BFS<br>广度优先遍历 BFS<br>此处即二叉树的层次(序)遍历<br>求最大深度 亦即 求二叉树有几层<br>广度优先代码<br>特点：”从左到右，从上到下”<br>队列<br>特点：”先进先出”<br>队列实现广度优先<br>遍历二叉树节点，依次将当前节点 和它的左右子节点入队，并再一一出队<br>针对子节点的节点重复上一步操作<br>刚好符合”先进先出” =&gt; “先入队再出队”<br>数组：push -&gt; shift<br>所以二叉树的广度优先即层序遍历用队列实现为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxDepth = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> queue = [root];</span><br><span class="line">    <span class="keyword">let</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="comment">// 当前层的节点个数</span></span><br><span class="line">        <span class="keyword">const</span> levelSize = queue.length;          </span><br><span class="line">        <span class="comment">// 逐个让当前层的节点出列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;    </span><br><span class="line">            <span class="comment">// 当前出列的节点</span></span><br><span class="line">            <span class="keyword">const</span> cur = queue.shift();            </span><br><span class="line">            <span class="comment">// 左右子节点入列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left) queue.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right) queue.push(cur.right); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前层所有节点已经出列，如果队列不为空，说明有下一层节点，depth+1</span></span><br><span class="line">        <span class="keyword">if</span> (queue.length) depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Excel表列名称"><a href="#Excel表列名称" class="headerlink" title="Excel表列名称"></a>Excel表列名称</h1><h2 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; <span class="number">1</span></span><br><span class="line">B -&gt; <span class="number">2</span></span><br><span class="line">C -&gt; <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Z -&gt; <span class="number">26</span></span><br><span class="line">AA -&gt; <span class="number">27</span></span><br><span class="line">AB -&gt; <span class="number">28</span> </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：columnNumber = <span class="number">1</span></span><br><span class="line">输出：<span class="string">&quot;A&quot;</span></span><br><span class="line"></span><br><span class="line">输入：columnNumber = <span class="number">28</span></span><br><span class="line">输出：<span class="string">&quot;AB&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= columnNumber &lt;= 231 - 1</code></li>
</ul>
<h2 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h2><p>本题本质就是进制转换，10进制转26进制，但有所不同的是正常转换成26进制的余数是0-25，<br>而本题的余数是1-26（对应A-Z），为了消除差距的这个1，有两种方法：</p>
<p>①让除数减一，那么余数自然就少一，原来余 1 的变成余 0，以此类推(详细见下表)。<br>核心代码 <code>let remain = (n - 1) % 26;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> convertToTitle = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        n--; <span class="comment">// 通过让 n - 1，使得余数 remain 减少 1 </span></span><br><span class="line">        <span class="keyword">let</span> remain = n % <span class="number">26</span>;</span><br><span class="line">        <span class="comment">// unshift 向数组开头添加元素</span></span><br><span class="line">        <span class="comment">// fromCharCode 将 Unicode 编码转为一个字符 A:65</span></span><br><span class="line">        res.unshift(<span class="built_in">String</span>.fromCharCode(remain + <span class="number">65</span>));</span><br><span class="line">        n = <span class="built_in">Math</span>.floor(n / <span class="number">26</span>);<span class="comment">// 向下取整</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);<span class="comment">// 将数组转换为一个字符串并且设置没有分隔符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>②对值为 26 的倍数单独处理，保留为 26，而不取余<br>核心代码 <code>let remain = n % 26 ? n % 26 : 26;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> convertToTitle = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        <span class="comment">// if(n % 26 === 0) remain = 26;</span></span><br><span class="line">        <span class="comment">// else remain = n % 26;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面两行可以简写为下面一行</span></span><br><span class="line">        <span class="keyword">let</span> remain = n % <span class="number">26</span> ? n % <span class="number">26</span> : <span class="number">26</span>;</span><br><span class="line">        res.unshift(<span class="built_in">String</span>.fromCharCode(remain + <span class="number">64</span>));</span><br><span class="line">        n = <span class="built_in">Math</span>.floor((n - remain) / <span class="number">26</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h1><h2 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>前序遍历的定义：对每个节点，都是先处理当前节点，对它执行我们的处理逻辑，再递归它的左子树，再递归它的右子树，对子树中的节点执行相同的逻辑。(<strong>中左右</strong>)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> preOrder = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root===<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(root.val);<span class="comment">// 根节点</span></span><br><span class="line">        preOrder(root.left);<span class="comment">// 左节点</span></span><br><span class="line">        preOrder(root.right);<span class="comment">// 右节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：<code>O(n)</code>，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</p>
<p>空间复杂度：<code>O(n)</code>，为递归过程中栈的开销，平均情况下为 <code>O(logn)</code>，最坏情况下树呈现链状，为 <code>O(n)</code>。</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>为什么可以用迭代法（非递归的方式）来实现二叉树的前后中序遍历呢？</p>
<p>递归的实现就是：<strong>每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因</strong>。</p>
<p>此时大家应该知道我们用<strong>栈</strong>也可以是实现二叉树的前后中序遍历了。</p>
<h4 id="方法一-非统一格式"><a href="#方法一-非统一格式" class="headerlink" title="方法一 非统一格式"></a>方法一 非统一格式</h4><p>前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p>
<p>为什么要先加入右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">let</span> stack=[];</span><br><span class="line">    <span class="comment">// 当根节点不为空的时候，将根节点入栈</span></span><br><span class="line">    <span class="keyword">if</span>(root) stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(stack.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 将根节点出栈，将根节点值放入结果数组中</span></span><br><span class="line">        <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">        res.push(node.val);</span><br><span class="line">        <span class="comment">// 然后遍历左子树、右子树，</span></span><br><span class="line">        <span class="comment">// 因为栈是先入后出，所以，我们先右子树入栈，然后左子树入栈</span></span><br><span class="line">        <span class="keyword">if</span>(node.right) stack.push(node.right);</span><br><span class="line">        <span class="keyword">if</span>(node.left) stack.push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法二-统一格式"><a href="#方法二-统一格式" class="headerlink" title="方法二 统一格式"></a>方法二 统一格式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">let</span> stack=[];</span><br><span class="line">    <span class="keyword">let</span> node =root;</span><br><span class="line">    <span class="comment">// 和递归思想类似</span></span><br><span class="line">    <span class="keyword">while</span>(node || stack.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            res.push(node.val);</span><br><span class="line">            node=node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;    </span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：<code>O(n)</code>，其中 nn 是二叉树的节点数。每一个节点恰好被遍历一次。</p>
<p>空间复杂度：<code>O(n)</code>，为迭代过程中显式栈的开销，平均情况下为 <code>O(logn)</code>，最坏情况下树呈现链状，为 <code>O(n)</code>。</p>
<h1 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h1><h2 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h2 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h2><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res =[];</span><br><span class="line">    <span class="keyword">const</span> postOrder = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root===<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder(root.left);<span class="comment">// 左</span></span><br><span class="line">        postOrder(root.right); <span class="comment">// 右</span></span><br><span class="line">        res.push(root.val);<span class="comment">// 中</span></span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h3><p>方法一 与前序类似</p>
<p>解题思路： 后序遍历与前序遍历不同的是：</p>
<p>后序遍历是<strong>左右根</strong></p>
<p>而前序遍历是<strong>根左右</strong></p>
<p>如果我们把前序遍历的 <code>res.push(node.val)</code> 变更为 <code>res.unshift(node.val)</code> （遍历结果逆序），那么遍历顺序就由 <strong>根左右</strong> 变更为 <strong>右左根</strong></p>
<p>然后我们仅需将 <strong>右左根</strong> 变更为 <strong>左右根</strong> 即可完成后序遍历</p>
<p>或者 先按<strong>根右左</strong>遍历，最后<code>reverse()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res =[];</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">if</span>(root)stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(stack.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> node = stack.pop();</span><br><span class="line">        <span class="comment">// 根左右=&gt;右左根</span></span><br><span class="line">        res.unshift(node.val);</span><br><span class="line">        <span class="comment">//res.push(node.val);</span></span><br><span class="line">        <span class="comment">// 先进栈左子树后右子树</span></span><br><span class="line">        <span class="comment">// 出栈的顺序就变更为先右后左</span></span><br><span class="line">        <span class="comment">// 右先头插法入res</span></span><br><span class="line">        <span class="comment">// 左再头插法入res</span></span><br><span class="line">        <span class="comment">// 实现右左根=&gt;左右根</span></span><br><span class="line">        <span class="keyword">if</span>(node.left)stack.push(node.left);</span><br><span class="line">        <span class="keyword">if</span>(node.right)stack.push(node.right);</span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// return res.reverse();// 不用unshift的话，最后将整个数组反转也可</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>统一格式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res =[];</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> node = root;</span><br><span class="line">    <span class="keyword">while</span>(node || stack.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            <span class="comment">//res.push(node.val);</span></span><br><span class="line">            res.unshift(node.val);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">//return res.reverse();</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">const</span> inOrder = <span class="function"><span class="params">root</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        res.push(root.val);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>迭代</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">let</span> stack=[];</span><br><span class="line">    <span class="keyword">let</span> node = root;</span><br><span class="line">    <span class="keyword">while</span>(node || stack.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        node=stack.pop();</span><br><span class="line">        res.push(node.val);</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树：[3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回其层序遍历结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>DFS（Deep First Search）深度优先搜索。</strong></p>
<p><strong>BFS（Breath First Search）广度优先搜索。</strong></p>
<p>BFS</p>
<p>思路<br>遍历每一层的节点，将节点值推入 subRes 数组中<br>将 subRes 数组推入 res 数组中<br>怎么获取每一层的节点<br>我们已知的是根节点，就一个<br>通过它可以 “找出” 第 2 层的所有节点<br>通过第 2 层的节点可以 “找出” 所有第 3 层的节点<br>…………<br>怎么存储每一层的节点<br>我们需要用一个数据结构存储每一层的节点<br>且我们希望某一刻 新层节点全进来了，旧层节点全出去了<br>队列 的 先进先出 符合要求<br>于是维护一个 queue 队列，是 层序遍历 的特征</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">let</span> queue = [root];</span><br><span class="line">    <span class="comment">// 队列中没有节点时，遍历完毕</span></span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> subRes = [];<span class="comment">//题目需要</span></span><br><span class="line">        <span class="keyword">const</span> len =queue.length;<span class="comment">//当前层的节点数目</span></span><br><span class="line">        <span class="comment">//遍历当前层的节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> cur = queue.shift();<span class="comment">// 出列</span></span><br><span class="line">            subRes.push(cur.val);<span class="comment">// 填充subRes数组</span></span><br><span class="line">            <span class="comment">// 下层节点入列</span></span><br><span class="line">            <span class="keyword">if</span>(cur.left) queue.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right) queue.push(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(subRes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>“携家带子”，queue “更新换代”<br>queue 初始时为 [root] ，代表第 1 层<br>开启 while 循环，对当前层的节点进行遍历<br>当前层的节点逐个出列，节点值推入 subRes 数组<br>判断如果当前出列节点有子节点，让子节点入列<br>本层的节点出列，下层的进来，下次循环时，queue 中全是新层的节点，没有旧层的节点<br>while 循环终止的条件是 queue 队列空了，节点遍历完了<br>易错点<br>const len = queue.length 必须先保存当前层的节点数，再做遍历<br>不能 for (let i = 0; i &lt; queue.length; i++) {…}<br>因为在 for 循环时，queue有出列和入列，长度是动态变化的</p>
<p>记树上所有节点的个数为 n。</p>
<p>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。<br>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)。</p>
<h1 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h1><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p>BFS</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rightSideView = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">let</span> queue =[root];</span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> len = queue.length;</span><br><span class="line">        <span class="keyword">while</span>(len)&#123;</span><br><span class="line">            <span class="keyword">let</span> cur=queue.shift();</span><br><span class="line">            <span class="keyword">if</span>(len === <span class="number">1</span>)res.push(cur.val);</span><br><span class="line">            <span class="keyword">if</span>(cur.left) queue.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right) queue.push(cur.right); </span><br><span class="line">            len--;          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><p>翻转一棵二叉树。</p>
<p><strong>示例：</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>



<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>一个二叉树，怎么才算翻转了？</p>
<ul>
<li>它的<strong>左右子树要交换</strong>，并且左右子树内部的<strong>所有子树</strong>，都要进行<strong>左右子树的交换</strong>。、</li>
</ul>
<p>每个子树的根节点都说：先交换我的左右子树吧。那么递归就会先压栈压到底。然后才做交换。<br>即，位于底部的、左右孩子都是 null 的子树，先被翻转。<br>随着递归向上返回，子树一个个被翻转……整棵树翻转好了。<br>问题是在递归出栈时解决的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="comment">// 遍历到null节点时，不用翻转，直接返回它本身</span></span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right=temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="递归思路-2"><a href="#递归思路-2" class="headerlink" title="递归思路 2"></a>递归思路 2</h4><p>思路变了：先 “做事”——<strong>先交换左右子树</strong>，它们内部的子树还没翻转——丢给递归去做。<br>把交换的操作，放在递归子树之前。<br>问题是在递归压栈前被解决的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="comment">// 遍历到null节点时，不用翻转，直接返回它本身</span></span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right=temp;</span><br><span class="line">     <span class="comment">// 内部的翻转交给递归去做</span></span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复盘总结<br>两种分别是后序遍历和前序遍历。都是基于DFS，都是先遍历根节点、再遍历左子树、再右子树。<br>唯一的区别是：<br>前序遍历：将「处理当前节点」放到「递归左子树」之前。<br>后序遍历：将「处理当前节点」放到「递归右子树」之后。</p>
<p>这个「处理当前节点」，就是交换左右子树 ，就是解决问题的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const temp = root.left;</span><br><span class="line">root.left = root.right;</span><br><span class="line">root.right = temp;</span><br></pre></td></tr></table></figure>


<p>递归帮你遍历这棵树，核心是解决问题的代码，递归把它应用到每个子树上，解决每个子问题，最后解决整个问题。</p>
<p>你可以选择将 “做事” 的代码，放到 DFS 过程中的一个合适的时间点，而已。</p>
<p>评论区有人问递归到 null 不知道返回什么：<br>递归做的事——交换当前root的左右子树，返回root。遍历到 null，它没有子树可交换，返回出这个子树（null）</p>
<p>。</p>
<p>BFS 写法<br>用层序遍历的方式去遍历二叉树。</p>
<p>根节点先入列，然后出列，出列就 “做事”，交换它的左右子节点（左右子树）。<br>并让左右子节点入列，往后，这些子节点出列，也被翻转。<br>直到队列为空，就遍历完所有的节点，翻转了所有子树。</p>
<p>解决问题的代码放在节点出列时</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="comment">// 遍历到null节点时，不用翻转，直接返回它本身</span></span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> queue =[root]; <span class="comment">// 维护一个队列，初始推入第一层的root</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="keyword">const</span> cur = queue.shift();<span class="comment">// 出列的节点</span></span><br><span class="line">        <span class="comment">// 交换左右子树</span></span><br><span class="line">        <span class="comment">// 数组的结构赋值：将数组中的值按照位置提取出来，然后赋值给变量。</span></span><br><span class="line">        [cur.left,cur.right] = [cur.right,cur.left];</span><br><span class="line">        <span class="keyword">if</span>(cur.left)queue.push(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(cur.right)queue.push(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h1><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder = [9,15,7,20,3]</span><br></pre></td></tr></table></figure>

<p>返回如下的二叉树：</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TprtV1"><img src="https://s4.ax1x.com/2021/12/15/TprtV1.png" alt="TprtV1.png"></a></p>
<p>有了左右子树的 postOrder 和 inorder 之后，就能继续递归构建左、右子树，一直递归下去，直到：无法形成 postOrder 和 inorder 数组，就构建不出子树了，即来到树的底部了，返回 null 节点。</p>
<p>递归函数可以选择接受数组本身，也可以接收指针，我采用后者，根据指针 iStart 到指针 iEnd 的 inorder 数组，和从 pStart 到 pEnd 的 postorder 数组，构建当前子树，避免每次递归都要切割字符串。</p>
<p>定位root在inorder数组中的位置<br>我用了一个 map 去提前存下所有节点值在 inorder 数组中的索引，这样就不用每次都花 O(n) 的时间去定位 root 的位置。（不用类似 indexOf 这样的库函数），用空间换取时间。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">inorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">postorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">inorder, postorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map =&#123;&#125;;</span><br><span class="line">    <span class="comment">// 将节点值在inorder数组中的位置提前存入map</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">        map[inorder[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据iStart到iEnd的inorder数组，和从pStart到pEnd的postorder数组构建当前子树</span></span><br><span class="line">    <span class="keyword">const</span> helper =<span class="function">(<span class="params">iStart, iEnd, pStart, pEnd</span>) =&gt;</span>&#123;</span><br><span class="line">       <span class="comment">// 指针交错了，返回null节点</span></span><br><span class="line">       <span class="keyword">if</span>(pStart&gt;pEnd || iStart&gt;iEnd)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 获取当前要构建的根节点的值</span></span><br><span class="line">       <span class="keyword">const</span> rootVal = postorder[pEnd];</span><br><span class="line">       <span class="comment">// 获取到它在inorder数组中的位置</span></span><br><span class="line">       <span class="keyword">const</span> mid = map[rootVal];</span><br><span class="line">       <span class="comment">// 获取左子树的节点个数</span></span><br><span class="line">       <span class="keyword">const</span> leftNodeNum = mid - iStart;</span><br><span class="line">       <span class="comment">// 创建节点</span></span><br><span class="line">       <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">       <span class="comment">// 用递归构建左子树</span></span><br><span class="line">       root.left = helper(iStart,mid-<span class="number">1</span>,pStart,pStart+leftNodeNum-<span class="number">1</span>);</span><br><span class="line">       <span class="comment">// 用递归构建右子树</span></span><br><span class="line">       root.right = helper(mid+<span class="number">1</span>,iEnd,pStart+leftNodeNum,pEnd-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 返回当前构建好的子树</span></span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归的入口</span></span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>,inorder.length-<span class="number">1</span>,<span class="number">0</span>,postorder.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h1><p>给定一棵树的前序遍历 <code>preorder</code> 与中序遍历 <code>inorder</code>。请构造二叉树并返回其根节点。</p>
<p>思路<br>构建一个二叉树需要构建三部分：root、左子树、右子树<br>左子树、右子树的构建，又包括：root、左子树、右子树<br>解题关键在于定位出根节点，划分出左右子树，然后 递归 构建左右子树<br>具体做法<br>preorder 数组的第一项肯定是根节点 —— 因为前序遍历的顺序是 根| 左|右根∣左∣右。<br>根据根节点，在 inorder [左 | 根 | 右][左∣根∣右] 中划分出分别属于左、右子树的 inorder 序列。<br>并求出左右子树的节点个数，在 preorder 中划分出分别属于左、右子树的 preorder 序列。<br>于是就有了左、右子树的 preorder 和 inorder 序列，递归构建左、右子树就好。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildTree = <span class="function">(<span class="params">preorder, inorder</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (inorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">const</span> mid = inorder.indexOf(preorder[<span class="number">0</span>]);</span><br><span class="line">  root.left = buildTree(preorder.slice(<span class="number">1</span>, mid + <span class="number">1</span>), inorder.slice(<span class="number">0</span>, mid));</span><br><span class="line">  root.right = buildTree(preorder.slice(mid + <span class="number">1</span>), inorder.slice(mid + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="优化一下"><a href="#优化一下" class="headerlink" title="优化一下"></a>优化一下</h4><p>字符串截取存在性能消耗，没必要每次都切割。用两个指针表示即可。递归函数传指针。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildTree = <span class="function">(<span class="params">preorder, inorder</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> helper = <span class="function">(<span class="params">p_start, p_end, i_start, i_end</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p_start &gt; p_end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> rootVal = preorder[p_start];    <span class="comment">// 根节点的值</span></span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">new</span> TreeNode(rootVal);   <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">let</span> mid = inorder.indexOf(rootVal); <span class="comment">// 根节点在inorder的位置</span></span><br><span class="line">    <span class="keyword">let</span> leftNum = mid - i_start;        <span class="comment">// 左子树的节点数</span></span><br><span class="line">    root.left = helper(p_start + <span class="number">1</span>, p_start + leftNum, i_start, mid - <span class="number">1</span>);</span><br><span class="line">    root.right = helper(p_start + leftNum + <span class="number">1</span>, p_end, mid + <span class="number">1</span>, i_end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> helper(<span class="number">0</span>, preorder.length - <span class="number">1</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再次优化<br>indexOf 的使用导致每次递归都花 O(n) 的时间定位根节点的位置，不理想。<br>提前把 inorder 的元素和索引存到哈希表中，用空间换取时间。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">preorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">inorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map =<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="comment">// 提前把 inorder 的元素和索引存到哈希表中，用空间换取时间。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;inorder.length;i++)&#123;</span><br><span class="line">        map.set(inorder[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> helper = <span class="function">(<span class="params">pStart,pEnd,iStart,iEnd</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pStart&gt;pEnd)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> rootVal = preorder[pStart];<span class="comment">//根节点的值</span></span><br><span class="line">        <span class="keyword">let</span> root = <span class="keyword">new</span> TreeNode(rootVal);<span class="comment">//根节点</span></span><br><span class="line">        <span class="keyword">let</span> mid =map.get(rootVal);<span class="comment">//根节点在inorder中的位置</span></span><br><span class="line">        <span class="keyword">let</span> leftNum = mid-iStart; <span class="comment">//左子树的节点数</span></span><br><span class="line">        root.left = helper(pStart+<span class="number">1</span>,pStart+leftNum,iStart,mid-<span class="number">1</span>);</span><br><span class="line">        root.right = helper(pStart+leftNum+<span class="number">1</span>,pEnd,mid+<span class="number">1</span>,iEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>,preorder.length-<span class="number">1</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</li>
</ul>
<p>解题思路</p>
<h4 id="中心扩展算法"><a href="#中心扩展算法" class="headerlink" title="中心扩展算法"></a>中心扩展算法</h4><p>两种情况<br>一种是回文子串长度为奇数（如aba，中心是b）<br>另一种回文子串长度为偶数（如abba，中心是b，b）</p>
<p>循环遍历字符串 对取到的每个值 都假设他可能成为最后的中心进行判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双指针记录截取边界</span></span><br><span class="line">    <span class="keyword">let</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> helper = <span class="function">(<span class="params">left,right</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;=<span class="number">0</span> &amp;&amp; right &lt;s.length &amp;&amp; s[left]===s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环完后是恰好不满足循环条件的时刻 </span></span><br><span class="line">        <span class="comment">// 如果此轮询得到回文串长度大于之前记录， 记录此轮循边界</span></span><br><span class="line">        <span class="keyword">if</span> (right-left-<span class="number">1</span> &gt; r-l-<span class="number">1</span>)&#123;</span><br><span class="line">            l=left;</span><br><span class="line">            r=right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">        <span class="comment">// 回文子串长度是奇数</span></span><br><span class="line">        helper(i,i);</span><br><span class="line">        <span class="comment">// 回文子串长度是偶数</span></span><br><span class="line">        helper(i,i+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两个边界不取</span></span><br><span class="line">    <span class="comment">// slice不改变原数组，返回截取后的数组，左闭右开</span></span><br><span class="line">    <span class="keyword">return</span> s.slice(l+<span class="number">1</span>,r);    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n^2)，其中 nn 是字符串的长度。长度为 11 和 22 的回文中心分别有 n 和 n-1 个，每个回文中心最多会向外扩展 O(n)次。</p>
<p>空间复杂度：O(1)。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leslie Waong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesliewaong.top/posts/b976e516.html">https://lesliewaong.top/posts/b976e516.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lesliewaong.top" target="_blank">Leslie Waong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JS/">JS</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/Letcode/">Letcode</a><a class="post-meta__tags" href="/tags/CodeTop/">CodeTop</a></div><div class="post_share"><div class="social-share" data-image="https://s4.ax1x.com/2021/12/17/Ti4Oq1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://z3.ax1x.com/2021/08/26/hevKvn.png" target="_blank"><img class="post-qr-code-img" src="https://z3.ax1x.com/2021/08/26/hevKvn.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://z3.ax1x.com/2021/08/26/hevugs.png" target="_blank"><img class="post-qr-code-img" src="https://z3.ax1x.com/2021/08/26/hevugs.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/d8a440d1.html"><img class="next-cover" src="https://s4.ax1x.com/2021/12/17/Ti4724.jpg" onerror="onerror=null;src='https://lesliewaong.top/img/friend_404.gif'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">React</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/54b11a0c.html" title="Promise"><img class="cover" src="https://s4.ax1x.com/2021/12/17/Ti4HxJ.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-25</div><div class="title">Promise</div></div></a></div><div><a href="/posts/c6d48fcf.html" title="ES6+"><img class="cover" src="https://s4.ax1x.com/2021/12/17/Ti4jVx.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-02</div><div class="title">ES6+</div></div></a></div><div><a href="/posts/a9ba4134.html" title="JavaScript基础"><img class="cover" src="https://s4.ax1x.com/2021/12/17/Ti5ZIf.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-11</div><div class="title">JavaScript基础</div></div></a></div><div><a href="/posts/7cb809c.html" title="JavaScript进阶"><img class="cover" src="https://s4.ax1x.com/2021/12/17/Ti5SPO.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-15</div><div class="title">JavaScript进阶</div></div></a></div><div><a href="/posts/1d0f8d42.html" title="前端常见面试题"><img class="cover" src="https://c1.im5i.com/2021/12/04/c2pCm.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-01</div><div class="title">前端常见面试题</div></div></a></div><div><a href="/posts/2181d083.html" title="JavaScript数据结构与算法"><img class="cover" src="https://s4.ax1x.com/2021/12/17/Ti4LrR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-30</div><div class="title">JavaScript数据结构与算法</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://z3.ax1x.com/2021/08/21/fv5m9O.jpg" onerror="this.onerror=null;this.src='https://lesliewaong.top/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Leslie Waong</div><div class="author-info__description">BUPT</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lesliewaong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lesliewaong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1138964397&amp;website=www.qtxml.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">红雨漂泊泛起了回忆怎么潜</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">合并两个有序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%90%88%E5%B9%B6%E5%90%8E%E6%8E%92%E5%BA%8F"><span class="toc-text">方法一：直接合并后排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">方法二：双指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E9%80%86%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">方法三：逆向双指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-text">无重复字符的最长子串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-1"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0"><span class="toc-text">字符串相加</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-2"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">排序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-3"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-3"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%80%9D%E8%B7%AF"><span class="toc-text">基础思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">两数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-4"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-4"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-text">比较版本号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-5"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-5"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2"><span class="toc-text">方法一：字符串分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="toc-text">方法二：双指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-text">最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-6"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-6"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE-%E8%B6%85%E6%97%B6"><span class="toc-text">解法一：暴力枚举(超时)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">解法二：动态规划</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-7"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-7"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E8%BF%AD%E4%BB%A3"><span class="toc-text">解法一：迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%B0%BE%E9%80%92%E5%BD%92"><span class="toc-text">解法二：尾递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%89%EF%BC%9A%E9%80%92%E5%BD%92"><span class="toc-text">解法三：递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E5%9B%9B%EF%BC%9A%E6%A0%88%E8%A7%A3"><span class="toc-text">解法四：栈解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="toc-text">反转链表 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-8"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-8"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%A9%BF%E9%92%88%E5%BC%95%E7%BA%BF"><span class="toc-text">方法一：穿针引线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86%E3%80%8C%E7%A9%BF%E9%92%88%E5%BC%95%E7%BA%BF%E3%80%8D%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E5%A4%B4%E6%8F%92%E6%B3%95%EF%BC%89"><span class="toc-text">方法二：一次遍历「穿针引线」反转链表（头插法）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-text">有效的括号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-9"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-9"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%A0%88"><span class="toc-text">方法一：栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text">爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-10"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-10"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">方法一 动态规划</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98"><span class="toc-text">青蛙跳台阶问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-text">斐波那契数列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-11"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-11"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-text">矩阵快速幂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%A1%B9%E5%85%AC%E5%BC%8F"><span class="toc-text">通项公式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-12"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-12"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-text">路径总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-13"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-13"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-14"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-14"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-text">环形链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-15"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-15"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-text">买卖股票的最佳时机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-16"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-16"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-text">贪心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="toc-text">动态规划</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="toc-text">买卖股票的最佳时机 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-17"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-17"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text">二叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-18"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-18"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFS-%E5%85%B8%E5%9E%8B%E7%9A%84BFS%E6%A8%A1%E6%9D%BF%E5%86%99%E6%B3%95"><span class="toc-text">BFS (典型的BFS模板写法)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0"><span class="toc-text">Excel表列名称</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-19"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-19"><span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的前序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-20"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-20"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92-1"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-text">迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-%E9%9D%9E%E7%BB%9F%E4%B8%80%E6%A0%BC%E5%BC%8F"><span class="toc-text">方法一 非统一格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-%E7%BB%9F%E4%B8%80%E6%A0%BC%E5%BC%8F"><span class="toc-text">方法二 统一格式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-21"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-21"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92-2"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="toc-text">迭代实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的中序遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的层序遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-text">二叉树的右视图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">翻转二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%80%9D%E8%B7%AF-2"><span class="toc-text">递归思路 2</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">从前序与中序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E4%B8%80%E4%B8%8B"><span class="toc-text">优化一下</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-text">最长回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95%E7%AE%97%E6%B3%95"><span class="toc-text">中心扩展算法</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/b976e516.html" title="算法题（JS）"><img src="https://s4.ax1x.com/2021/12/17/Ti4Oq1.jpg" onerror="this.onerror=null;this.src='https://lesliewaong.top/img/friend_404.gif'" alt="算法题（JS）"/></a><div class="content"><a class="title" href="/posts/b976e516.html" title="算法题（JS）">算法题（JS）</a><time datetime="2021-12-01T02:37:47.000Z" title="发表于 2021-12-01 10:37:47">2021-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d8a440d1.html" title="React"><img src="https://s4.ax1x.com/2021/12/17/Ti4724.jpg" onerror="this.onerror=null;this.src='https://lesliewaong.top/img/friend_404.gif'" alt="React"/></a><div class="content"><a class="title" href="/posts/d8a440d1.html" title="React">React</a><time datetime="2021-10-07T03:29:47.000Z" title="发表于 2021-10-07 11:29:47">2021-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2181d083.html" title="JavaScript数据结构与算法"><img src="https://s4.ax1x.com/2021/12/17/Ti4LrR.jpg" onerror="this.onerror=null;this.src='https://lesliewaong.top/img/friend_404.gif'" alt="JavaScript数据结构与算法"/></a><div class="content"><a class="title" href="/posts/2181d083.html" title="JavaScript数据结构与算法">JavaScript数据结构与算法</a><time datetime="2021-09-30T09:57:47.000Z" title="发表于 2021-09-30 17:57:47">2021-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d044eab7.html" title="TypeScript"><img src="https://s4.ax1x.com/2021/12/17/Ti4oPU.jpg" onerror="this.onerror=null;this.src='https://lesliewaong.top/img/friend_404.gif'" alt="TypeScript"/></a><div class="content"><a class="title" href="/posts/d044eab7.html" title="TypeScript">TypeScript</a><time datetime="2021-09-15T05:12:48.000Z" title="发表于 2021-09-15 13:12:48">2021-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1d0f8d42.html" title="前端常见面试题"><img src="https://c1.im5i.com/2021/12/04/c2pCm.webp" onerror="this.onerror=null;this.src='https://lesliewaong.top/img/friend_404.gif'" alt="前端常见面试题"/></a><div class="content"><a class="title" href="/posts/1d0f8d42.html" title="前端常见面试题">前端常见面试题</a><time datetime="2021-09-01T05:14:52.000Z" title="发表于 2021-09-01 13:14:52">2021-09-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Leslie Waong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/js/utils.js"></script><script src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/js/main.js"></script><script src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/js/animate.js"></script><div class="aplayer no-destroy" data-id="6995412795" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="auto" data-autoplay="true" muted></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":0,"vOffset":0},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body></html>