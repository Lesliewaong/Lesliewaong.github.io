<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>前端 | Leslie Waong</title><meta name="keywords" content="CSS,HTML,JS,框架,计算机网络,浏览器"><meta name="author" content="Leslie Waong"><meta name="copyright" content="Leslie Waong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTML&amp;CSS语义化的理解⭐语义化，指选择合乎语义的标签，使文本内容的结构化，便于开发者阅读、维护和写出更优雅的代码，同时让浏览器的爬虫和辅助技术更好的解析。 常用的一些语义化标签 &lt;h1&gt;~&lt;h6&gt; ，标题 &lt;p&gt; 段落 &lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;，无序、有序列表 &lt;table&gt;、&lt;thead&amp;"><meta property="og:type" content="article"><meta property="og:title" content="前端"><meta property="og:url" content="https://lesliewaong.top/posts/f3b98ae9.html"><meta property="og:site_name" content="Leslie Waong"><meta property="og:description" content="HTML&amp;CSS语义化的理解⭐语义化，指选择合乎语义的标签，使文本内容的结构化，便于开发者阅读、维护和写出更优雅的代码，同时让浏览器的爬虫和辅助技术更好的解析。 常用的一些语义化标签 &lt;h1&gt;~&lt;h6&gt; ，标题 &lt;p&gt; 段落 &lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;，无序、有序列表 &lt;table&gt;、&lt;thead&amp;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/4.webp"><meta property="article:published_time" content="2021-07-12T05:14:52.000Z"><meta property="article:modified_time" content="2022-03-25T14:08:26.426Z"><meta property="article:author" content="Leslie Waong"><meta property="article:tag" content="CSS"><meta property="article:tag" content="HTML"><meta property="article:tag" content="JS"><meta property="article:tag" content="框架"><meta property="article:tag" content="计算机网络"><meta property="article:tag" content="浏览器"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/4.webp"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg"><link rel="canonical" href="https://lesliewaong.top/posts/f3b98ae9"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"一年之内的产物",messageNext:"技术可能存在过期"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Leslie Waong",link:"链接: ",source:"来源: Leslie Waong",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"前端",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-03-25 22:08:26"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px");const a=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};a(),document.addEventListener("pjax:complete",a)})(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Leslie Waong" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/4.webp)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leslie Waong</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-12T05:14:52.000Z" title="发表于 2021-07-12 13:14:52">2021-07-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-25T14:08:26.426Z" title="更新于 2022-03-25 22:08:26">2022-03-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">39.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>130分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="前端"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML&amp;CSS"></a>HTML&amp;CSS</h1><h2 id="语义化的理解⭐"><a href="#语义化的理解⭐" class="headerlink" title="语义化的理解⭐"></a>语义化的理解⭐</h2><p><strong>语义化</strong>，指选择合乎语义的标签，使<strong>文本内容的结构化</strong>，便于<strong>开发者阅读</strong>、<strong>维护和写出更优雅的代码，同时让浏览器的爬虫和辅助技术更好的解析。</strong></p><h3 id="常用的一些语义化标签"><a href="#常用的一些语义化标签" class="headerlink" title="常用的一些语义化标签"></a>常用的一些语义化标签</h3><ul><li><code>&lt;h1&gt;~&lt;h6&gt;</code> ，标题</li><li><code>&lt;p&gt;</code> 段落</li><li><code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>，无序、有序列表</li><li><code>&lt;table&gt;</code>、<code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;td&gt;</code>、<code>&lt;th&gt;</code>、<code>&lt;caption&gt;</code>， 表格</li></ul><h3 id="被滥用的语义化标签"><a href="#被滥用的语义化标签" class="headerlink" title="被滥用的语义化标签"></a>被滥用的语义化标签</h3><ul><li><p><code>p</code>：不要用来增加额外的空白段落，应使用<code>CSS</code>的<code>margin/padding</code>来实现；</p></li><li><p><code>&lt;h1&gt;~&lt;h6&gt;</code>：该标签可以使文本字体变大，变粗，但如果文本<strong>并非是标题</strong>，应该使用<code>CSS font-weight font-size</code>；</p></li><li><p>不要将<code>&lt;b&gt;</code>元素与 <code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>或<code>&lt;mark&gt;</code>元素混淆。</p><ul><li><code>&lt;strong&gt;</code>用来对一个句子的部分增加<strong>重要性</strong>。（粗体）</li><li><code>&lt;em&gt;</code>用于改变一个句子的意思，<strong>强调</strong>某些文本。（斜体）</li><li><code>&lt;mark&gt;</code>表示上下文的<strong>关联性</strong>。（高亮）</li><li><code>&lt;b&gt;</code>用于吸引读者的注意到该元素的内容上，仅在没有其他合适的元素时使用它，如摘要中的关键字（粗体）</li></ul><p>如果不是出于语义目的而使用 <code>&lt;b&gt;</code> 元素，那么让文本显示粗体更好的方式是使用将 CSS 的 <code>font-weight</code> 属性设置为 <code>&quot;bold&quot;</code>。</p></li></ul><h3 id="HTML5新增"><a href="#HTML5新增" class="headerlink" title="HTML5新增"></a>HTML5新增</h3><p><code>header</code>：头部,包裹目录部分、搜索框、一个nav或者任何相关的logo</p><p><code>main</code>：主体,唯一的，其后代元素常常包括<code>&lt;article&gt;</code></p><p><code>nav</code>：导航,一般和<code>ul</code>、<code>li</code>配合做导航栏</p><p><code>footer</code>：底部,通常包含作者、版权信息或者相关链接等</p><p><code>aside</code>：侧边栏,作为主要内容的附属信息，如索引，词条列表</p><p><code>article</code>：独立文章,通常带有标题，当article内嵌article时，里外层的内容应该是相关的</p><p><code>section</code>：独立区块,它是整体的一部分，或者是文章的一节，一般来说section也会带有标题</p><p><code>div</code>：作为一个没有任何语义，仅仅是用来构建结构的元素，是<strong>最适合做容器的标签。</strong></p><h2 id="lt-img-gt-的title和alt有什么区别"><a href="#lt-img-gt-的title和alt有什么区别" class="headerlink" title="&lt;img&gt;的title和alt有什么区别"></a><code>&lt;img&gt;</code>的<code>title</code>和<code>alt</code>有什么区别</h2><ul><li>通常当鼠标滑动到元素上的时候显示<code>title</code>。</li><li><code>alt</code>是<code>&lt;img&gt;</code>的<strong>特有属性</strong>，是<strong>图片内容的等价描述</strong>，用于图片无法加载时显示、读屏器阅读图片。可提高图片可访问性，除了纯装饰图片外都必须设置有意义的值，<strong>搜索引擎</strong>会重点分析。</li></ul><h2 id="H5的新特性有哪些⭐"><a href="#H5的新特性有哪些⭐" class="headerlink" title="H5的新特性有哪些⭐"></a>H5的新特性有哪些⭐</h2><ul><li><p>新增语义化标签。</p></li><li><p>H5提供了<code>sessionStorage</code>、<code>localStorage</code>和<code>indexedDB</code>加强本地存储。</p></li><li><p>input标签新增属性:</p><ul><li><p>placeholder属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>autofocus属性，页面只能有一个,自动获得焦点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">autofocus</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>canvas</code> 是 HTML5 新定义的标签，通过使用脚本（通常是 JavaScript）绘制图形。<code>&lt;canvas&gt;</code> 标签只是图形容器，相当于一个画布，<code>canvas</code> 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成，相当于使用画笔在画布上画画。</p><p>默认情况下，<code>&lt;canvas&gt;</code> 没有边框和内容。默认是一个 300*150 的画布，所以我们创建了 <code>&lt;canvas&gt;</code> 之后要对其设置宽高。</p><p>我们可以通过html属性‘width’，‘height’来设置canvas的宽高，不可以通过 css 属性来设置宽高。因为通过 css 属性设置的宽高会使 canvas 内的图像按照 300*150 时的比例放大或缩小。</p></li><li><p>地理(<code>Geolocation</code>) API</p></li><li><p>音频、视频API(<code>audio</code>,<code>video</code>)</p></li><li><p><code>webworker</code>, <code>websocket</code></p><ul><li><p><code>webworker</code>是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。</p></li><li><p><code>WebSocket</code> 使用<code>ws</code>或<code>wss</code>协议，<code>Websocket</code>是一个<strong>持久化的协议</strong>，相对于HTTP这种非持久的协议来说。WebSocket API最伟大之处在于<strong>服务器和客户端可以在给定的时间范围内的任意时刻，相互推送信息</strong>。<code>WebSocket</code>并<strong>不限于以Ajax(或XHR)方式通信</strong>，因为Ajax技术需要客户端发起请求，而WebSocket服务器和客户端可以彼此相互推送信息；XHR受到域的限制，而<code>WebSocket</code><strong>允许跨域通信</strong>。</p></li></ul></li></ul><h2 id="iframe优缺点"><a href="#iframe优缺点" class="headerlink" title="iframe优缺点"></a>iframe优缺点</h2><p>iframe可以在一个网站里面嵌入另一个网站的内容。</p><h3 id="iframe的优点"><a href="#iframe的优点" class="headerlink" title="iframe的优点"></a>iframe的优点</h3><ul><li>iframe能够原封不动的把嵌入的网页展现出来。</li><li>如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。</li><li>网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。</li><li>如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。</li></ul><h3 id="iframe的缺点"><a href="#iframe的缺点" class="headerlink" title="iframe的缺点"></a>iframe的缺点</h3><ul><li>会产生很多页面，不容易管理。</li><li>iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。</li><li>代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以<strong>使用iframe会不利于搜索引擎优化。</strong></li><li>iframe 里面的样式、脚本资源，会增加请求次数，对于大型网站是不可取的。</li><li>iframe 会阻碍页面的 <code>onload</code> 事件，给用户页面加载很慢的感觉。</li></ul><h2 id="简述一下src与href的区别"><a href="#简述一下src与href的区别" class="headerlink" title="简述一下src与href的区别"></a>简述一下src与href的区别</h2><ul><li><code>src</code>是<code>source</code>的缩写，<strong>指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置</strong>；在请求<code>src</code>资源时会将其指向的资源下载并应用到文档内，例如<code>js</code>脚本，<code>img</code>图片和<code>iframe</code>等元素</li><li>img、script、input、iframe</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> =<span class="string">”js.js”</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>js脚本阻塞渲染并不是因为他是src引入的，而是因为他有可能改变DOM树或CSSOM树。</p><p>是否阻塞跟href和src没有关系，跟浏览器实现最佳体检的设计有关。</p></blockquote><ul><li><code>href</code>是<code>Hypertext Reference</code>的缩写，<strong>指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接</strong></li><li>link、a</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">”common.css”</span> <span class="attr">rel</span>=<span class="string">”stylesheet”/</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。</p></blockquote><h2 id="知道的网页制作会用到的图片格式有哪些"><a href="#知道的网页制作会用到的图片格式有哪些" class="headerlink" title="知道的网页制作会用到的图片格式有哪些"></a>知道的网页制作会用到的图片格式有哪些</h2><p><code>png-8</code>，<code>png-24</code>，<code>jpeg</code>，<code>gif</code>，<code>svg</code></p><p>Webp：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。</p><p>在<strong>质量相同</strong>的情况下，<code>WebP</code>格式图像的体积要比JPEG格式图像小<code>40%</code></p><h2 id="inline，block，inline-block的区别⭐"><a href="#inline，block，inline-block的区别⭐" class="headerlink" title="inline，block，inline-block的区别⭐"></a>inline，block，inline-block的区别⭐</h2><blockquote><p>HTML 标准中块级元素和行内元素的区别至高出现在 4.01 标准中。在 HTML5，这种区别被一个更复杂的内容类别代替。</p><p>”块级“类别大致相当于 HTML5 中的<code>Flow content(流内容)</code>类别，而”行内“类别相当于 HTML5 中的<code>Phrasing content(短语内容)</code>类别，不过除了这两个还有其他类别。</p></blockquote><p>行内元素：</p><ul><li>一般情况下<strong>只能包含数据和其他行内元素</strong>。</li><li>一般是<strong>内容的容器</strong>。</li></ul><p>块级元素：</p><ul><li><strong>包含行内元素和其他块级元素</strong>。</li><li>适合做<strong>布局</strong>。</li></ul><h3 id="块级元素-block"><a href="#块级元素-block" class="headerlink" title="块级元素(block)"></a>块级元素(block)</h3><ul><li><p>水平（独占一行，<strong>占据其父元素（容器）的整个水平空间</strong>），垂直空间等于其<strong>内容高度</strong>，因此创建了一个“块”。</p></li><li><p><strong>可以设置宽高</strong>。即使设置宽度也还是<strong>独占一行</strong>。</p><p>当指定了 <code>width</code> 和 <code>height</code> 的值时，内容超出块级元素的尺寸就会<strong>溢出</strong>，这时块级元素要呈现什么行为要看其 <code>overflow</code> 的值（<code>visible,hidden,scroll</code>)</p></li><li><p>可以设置<code>margin</code>和<code>padding</code>属性。</p></li></ul><p>举例：</p><p><code>h1-h6、div、p</code></p><p><code>（HTML5）header、footer、article、aside、section</code></p><h3 id="行内元素-inline"><a href="#行内元素-inline" class="headerlink" title="行内元素(inline)"></a>行内元素(inline)</h3><ul><li><p><strong>可以多个标签存在一行</strong></p></li><li><p><strong>对宽高属性值不生效</strong>，<strong>完全靠内容撑开宽高</strong>。</p></li><li><p>竖直方向的<code>margin</code>不起作用。</p></li><li><p>行内元素竖直方向的<code>padding</code>会起作用，不过就像脱离了标准流一样，并不会占据位置，并且还把其他元素给盖住了。</p><p>但是，假如inline的元素没有内容，“<code>padding-top、padding-bottom</code>“将不起作用。如果想要起作用，只需要给<code>padding-left</code>或者<code>padding-right</code>设置一个值，或者当inline的元素有内容时就会起作用。</p></li></ul><p>举例：</p><p><code>span</code>、<code>button</code>、<code>input</code>等</p><h3 id="行内块元素-inline-block"><a href="#行内块元素-inline-block" class="headerlink" title="行内块元素(inline-block)"></a>行内块元素(inline-block)</h3><ul><li><p><strong>既可以设置宽高，又可以和其他行内元素并排</strong>。</p></li><li><p>当<code>inline-block</code>碰到同类（inline-block)时，谁的上下margin、padding或line-height大，就听谁的。除非它是inline，因为inline的竖直方向margin是不起作用的，且inline的竖直方向padding是不占空间的。</p></li><li><p><code>inline</code>和<code>inline-block</code>会引起<strong>间距</strong>。这个间距是有<strong>空格</strong>或<strong>换行</strong>导致的。解决方法一：<strong>将空格直接删除，放到一行</strong></p></li></ul><h3 id="行内元素与块状元素之间的转换"><a href="#行内元素与块状元素之间的转换" class="headerlink" title="行内元素与块状元素之间的转换"></a>行内元素与块状元素之间的转换</h3><ul><li><strong>float:</strong> 行内=&gt;块。</li><li><strong>position:</strong> <code>position:absolute/fixed</code>，行内=&gt;块。</li><li><strong>display:</strong><ul><li><code>display:inline;</code></li><li><code>display:block;</code></li><li><code>display:inline-block;</code></li></ul></li></ul><h2 id="居中布局⭐"><a href="#居中布局⭐" class="headerlink" title="居中布局⭐"></a>居中布局⭐</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ul><li><p><code>text-align: center</code></p><ul><li>设置<strong>块元素或表格单元格</strong>中<strong>内容</strong>的水平对齐方式。</li><li><strong>不能直接用于行内元素</strong> 。</li><li>另外，这个内容不一定是行内元素，块元素中有h1(块元素)一样可以实现效果。</li></ul></li><li><p><code>margin: 0 auto</code></p><ul><li>计算元素对应方向上应该获得的<strong>剩余空间</strong>大小。</li><li>因为块级元素设置宽度后仍占据一行空间，<code>margin: 0 auto</code>会将这一行的剩余空间平均分配给左右外边距。</li><li><code>margin:auto</code> 能使<strong>块级元素</strong>水平居中，但是不能垂直居中，因为<strong>垂直方向上默认没有剩余的空间</strong>。</li><li><code>margin:auto</code> <strong>行内元素</strong>既不能水平居中也不能垂直居中，因为行内元素<strong>水平垂直方向上默认都没有剩余的空间</strong>。</li></ul></li></ul><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ul><li><code>line-height: 父元素高度</code><ul><li>适合文本。</li></ul></li></ul><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><ul><li><code>flex + justify-content + align-items</code></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但对<strong>子元素图片、文字</strong>都有时，<strong>竖直方向</strong>的对齐会有差异，可以<strong>父元素开启Flex布局</strong>，图片子元素设置<code>align-self: center;</code>，文字子元素使用<code>line-height</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">align-self</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>absolute + transform</code></li></ul><p><code>top,left</code>跟根据<strong>父元素的宽和高</strong>偏移的。<code>top: 50%;left: 50%;</code> 元素左上角居中。</p><p><code>transform: translate(-50%, -50%);</code>是根据<strong>自身的宽高</strong>偏移的。</p><p><strong>注意子元素是否存在margin</strong>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wp</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;  </span><br><span class="line">&#125;     </span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li><strong>网格布局（Grid）</strong>是最强大的 CSS 布局方案。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    justify-items: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.small</span> &#123;</span><br><span class="line">    justify-self: center;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他：</p><p><code>absolute(top:50%;left:50%;) + 负margin</code></p><p><code>absolute(top:0;left:0;right:0;bottom:0;)+margin:auto</code></p><h2 id="Flex⭐"><a href="#Flex⭐" class="headerlink" title="Flex⭐"></a>Flex⭐</h2><p>Flex是Flexible Box的缩写，翻译成中文就是“弹性盒子”，用来为盒模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。</p><p>采用Flex布局的元素，被称为Flex容器(flex container)，简称“容器”。</p><p>其所有子元素自动成为容器成员，成为Flex项目(Flex item)，简称“项目”。</p><p>容器默认存在两根主轴：<strong>水平方向</strong>主轴(main axis)和垂直方向交叉轴(cross axis)，<strong>默认项目按主轴排列</strong>。</p><h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p><strong>flex-direction（主轴的方向）和flex-wrap（换行）的简写，默认row nowrap</strong></p><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p><strong>定义项目在主轴上的对齐方式。</strong></p><p><code>justify-content:center</code> 默认用作水平居中</p><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p><strong>定义在交叉轴上的对齐方式</strong></p><p><code>align-items:center</code> 默认用作垂直居中</p><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p><strong>定义多根轴线的对齐方式</strong> 必须通过<code>flex-wrap</code>先有多根轴线</p><h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>允许单个项目有与其他项目不一样的对齐方式，常用于居中布局。</p><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p><strong>==flex-grow，flex-shrink和flex-basis的简写==</strong></p><blockquote><p>默认值为0 1 auto，<strong>第一个属性必须</strong>，后两个属性可选。</p></blockquote><p>flex-grow定义项目的放大比例（<strong>容器宽度&gt;元素总宽度时如何伸展</strong>），<code>flex-grow：1</code>或<code>flex：1</code>，经常用作自适应布局。</p><p>flex-shrink定义了项目的缩小比例（<strong>容器宽度&lt;元素总宽度时如何收缩</strong>），默认为1，即如果空间不足，该项目将缩小。</p><p>flex-basis设置的是<strong>元素在主轴上的初始尺寸</strong>，所谓的初始尺寸就是元素在<code>flex-grow</code>和<code>flex-shrink</code>生效前的尺寸。浏览器根据这个属性，计算主轴是否有多余空间。</p><p>一些属性有：</p><ul><li>flex: 1 = flex: 1 1 0%</li><li>flex: 2 = flex: 2 1 0%</li><li>flex: auto = flex: 1 1 auto</li><li>flex: none = flex: 0 0 auto，常用于固定尺寸不伸缩</li></ul><p><code>flex:1</code> 和 <code>flex:auto</code> 的区别，可以归结于<code>flex-basis:0</code>和<code>flex-basis:auto</code>的区别。</p><p>当设置为<code>0</code>时（绝对弹性元素），此时相当于告诉<code>flex-grow</code>和<code>flex-shrink</code>在伸缩的时候不需要考虑我的尺寸。</p><p>当设置为<code>auto</code>时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑。</p><h2 id="三栏布局⭐"><a href="#三栏布局⭐" class="headerlink" title="三栏布局⭐"></a>三栏布局⭐</h2><blockquote><p>问题：假设容器的高度默认100px，请写出<strong>三栏布局</strong>，其中左栏、右栏的宽度各为300px，中间的宽度自适应。</p></blockquote><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>左侧设置<strong>左浮动</strong>，右侧设置<strong>右浮动</strong>即可，中间会自动地自适应。</p><p>兼容性较好；脱离文档流，浮动带来影响。</p><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>左侧设置为绝对定位， <code>left：0px</code>。右侧设置为绝对定位， <code>right：0px</code>。</p><p>中间设置为绝对定位，<code>left 和right 都为300px</code>，即可。中间的宽度会自适应。</p><p>快捷；脱离文档流。</p><h3 id="Flexbox布局"><a href="#Flexbox布局" class="headerlink" title="Flexbox布局"></a>Flexbox布局</h3><p>将父容器设置<code>display：flex</code>，侧边栏大小固定后，将内容区<code>flex：1</code>，内容区则会自动放大占满剩余空间。</p><p>比较完美的解决了浮动和绝对定位的问题。在移动端比较常用。可能有兼容性问题（IE）。</p><h3 id="表格布局table"><a href="#表格布局table" class="headerlink" title="表格布局table"></a>表格布局table</h3><p>设置整个容器的宽度为<code>100%</code>，<code>display: table;</code>，设置三个部分均为表格单元<code>display: table-cell;</code>，然后左边的单元格为 <code>300px</code>，右边的单元格为 <code>300px</code>，即可。中间的单元格会自适应。</p><p>兼容性非常好；三个部分都当成了<strong>单元格</strong>来对待，此时，如果中间的部分变高了，其会部分也会被迫调整高度。</p><h3 id="网格布局-grid"><a href="#网格布局-grid" class="headerlink" title="网格布局 grid"></a>网格布局 grid</h3><p>设置容器为网格布局<code>display: grid</code>，宽度为<code>100%</code>，并设置<code>grid-template-columns: 300px auto 300px</code>。</p><p>CSS3中引入的布局，功能强大。</p><h2 id="对CSS盒模型的认识⭐"><a href="#对CSS盒模型的认识⭐" class="headerlink" title="对CSS盒模型的认识⭐"></a>对CSS盒模型的认识⭐</h2><h3 id="块级盒子（Block-box）-和-内联盒子（Inline-box）"><a href="#块级盒子（Block-box）-和-内联盒子（Inline-box）" class="headerlink" title="块级盒子（Block box） 和 内联盒子（Inline box）"></a>块级盒子（Block box） 和 内联盒子（Inline box）</h3><p>在 CSS 中我们广泛地使用两种“盒子” —— <strong>块级盒子</strong> (<strong>block box</strong>) 和 <strong>内联盒子</strong> (<strong>inline box</strong>)。这两种盒子会在<strong>页面流</strong>（page flow）和<strong>元素之间的关系</strong>方面表现出不同的行为:</p><p>一个被定义成块级的（block）盒子会表现出以下行为:</p><ul><li>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，<strong>在绝大数情况下意味着盒子会和父容器一样宽</strong></li><li>每个盒子都会<strong>换行</strong></li><li><code>width</code>和 <code>height</code> 属性可以发挥作用</li><li>内边距（<code>padding</code>）, 外边距（<code>margin</code>） 和 边框（<code>border</code>） 会将其他元素从当前盒子周围“推开”</li></ul><p>除非特殊指定，诸如标题(<code>&lt;h1&gt;</code>等)和段落(<code>&lt;p&gt;</code>)默认情况下都是块级的盒子。</p><p>如果一个盒子对外显示为 <code>inline</code>，那么他的行为如下:</p><ul><li>盒子<strong>不会产生换行</strong>。</li><li><code>width</code>和 <code>height</code> 属性将不起作用。</li><li><strong>垂直方向的内边距、外边距以及边框</strong>会被应用但是<strong>不会</strong>把其他处于 <code>inline</code> 状态的盒子推开。</li><li><strong>水平方向的内边距、外边距以及边框</strong>会被应用且<strong>会</strong>把其他处于 <code>inline</code> 状态的盒子推开。</li></ul><p>用做链接的 <code>&lt;a&gt;</code> 元素、 <code>&lt;span&gt;</code>、 <code>&lt;em&gt;</code> 以及 <code>&lt;strong&gt;</code> 都是默认处于 <code>inline</code> 状态的。</p><p>我们通过对盒子<code>display</code> 属性的设置，比如 <code>inline</code> 或者 <code>block</code> ，来控制盒子的外部显示类型。</p><h3 id="什么是CSS-盒模型"><a href="#什么是CSS-盒模型" class="headerlink" title="什么是CSS 盒模型?"></a>什么是CSS 盒模型?</h3><p>完整的 CSS 盒模型应用于<strong>块级盒子</strong>，<strong>内联盒子只使用盒模型中定义的部分内容</strong>。</p><p>模型定义了盒的每个部分 —— <code>margin外边距</code>, <code>border边框</code>, <code>padding内边距</code>和 <code>content内容区</code> —— 合在一起就可以创建我们在页面上看到的内容。</p><h3 id="标准盒模型和IE盒子模型"><a href="#标准盒模型和IE盒子模型" class="headerlink" title="标准盒模型和IE盒子模型"></a>标准盒模型和IE盒子模型</h3><p>CSS标准盒模型和IE盒模型的区别：</p><ul><li><p>在 <strong>标准盒子模型</strong>中，<strong>width 和 height 指的是内容区域</strong>的宽度和高度。</p></li><li><p><strong>IE盒子模型</strong>中，<strong>width 和 height 指的是内容区域+padding+border</strong>的宽度和高度。</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置当前盒子为 标准盒模型（默认） */</span></span><br><span class="line"><span class="attribute">box-sizing</span>: content-box;</span><br><span class="line"><span class="comment">/* 设置当前盒子为 IE盒模型 */</span></span><br><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br></pre></td></tr></table></figure><h2 id="BFC⭐"><a href="#BFC⭐" class="headerlink" title="BFC⭐"></a>BFC⭐</h2><h3 id="BFC的概念"><a href="#BFC的概念" class="headerlink" title="BFC的概念"></a>BFC的概念</h3><p><strong>块级格式化上下文（Block Formatting Context，BFC）</strong> 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p><p><code>BFC</code>是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。</p><h3 id="如何生成BFC"><a href="#如何生成BFC" class="headerlink" title="如何生成BFC"></a>如何生成BFC</h3><ul><li><p><code>overflow: 不为visible，可以让属性是 hidden、auto</code>。【最常用】</p></li><li><p>浮动中：<code>float</code>的属性值不为none。意思是，<code>只要设置了浮动，当前元素就创建了BFC</code>。</p></li><li><p>绝对定位：<code>posiiton</code>是<code>absolute</code>或<code>fixed</code>。</p></li><li><p><code>display</code>为<code>inline-block</code>, <code>table-cell</code>, <code>table-caption</code>, <code>flex</code>, <code>inline-flex</code>、<code>grid</code>等</p></li></ul><h3 id="BFC-的应用"><a href="#BFC-的应用" class="headerlink" title="BFC 的应用"></a>BFC 的应用</h3><h4 id="解决margin重叠"><a href="#解决margin重叠" class="headerlink" title="解决margin重叠"></a>解决margin重叠</h4><p><strong>标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin</strong>(水平方向的margin是可以叠加的）。</p><p>且只会发生在块级元素，行内元素和行内块元素不会出现。</p><p><strong>儿子和父亲在竖直方向上为一个margin</strong>。</p><p>当父元素和子元素发生 margin 重叠时，解决办法：<strong>给子元素或父元素创建BFC</strong>。</p><h4 id="清除浮动影响（高度塌陷）"><a href="#清除浮动影响（高度塌陷）" class="headerlink" title="清除浮动影响（高度塌陷）"></a>清除浮动影响（高度塌陷）</h4><p><strong>父元素不设置高度默认是被子元素撑开的</strong>，当<strong>子元素浮动</strong>后，其会完全<strong>脱离文档流</strong>。</p><p>子元素从文档流中脱离，将会无法撑起父元素的高度，<strong>导致父元素的高度丢失</strong>。</p><p>父元素高度丢失以后，其下的元素会自动上移，导致<strong>页面的布局混乱</strong>。</p><p><strong>解决方案</strong></p><ul><li><p>给父亲增加 <code>overflow=hidden</code>属性即可，因为计算BFC的高度时，浮动元素也参与计算。</p></li><li><p>给父亲设置高度。正所谓<strong>有高度的盒子，才能关住浮动</strong>。</p></li><li><p><strong>伪元素+clear</strong></p><ul><li><p><code>clear</code> 属性指定一个元素是否必须移动(清除浮动后)到<strong>在它之前的浮动元素下面</strong>。</p></li><li><p><strong>要被清除的相关浮动元素</strong>指的是在相同<strong>块级格式化上下文</strong>中的<strong>前置浮动</strong>。</p></li><li><p>具体方法：</p><ul><li><p>给<strong>浮动元素的容器</strong>添加一个<code>clearfix</code>的class。</p></li><li><p>然后给这个class添加一个<code>::after</code>(用来创建一个伪元素，作为已选中元素的最后一个子元素)，</p></li><li><p>内容为空即没有高度看不到，但<code>display: block;</code>宽度仍然占满父元素，方便判断之前的左右浮动以清理。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block; <span class="comment">/* 确保该元素是一个块级元素 */</span></span><br><span class="line">    <span class="attribute">clear</span>: both;<span class="comment">/*清除浮动*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="CSS中link和-import区别"><a href="#CSS中link和-import区别" class="headerlink" title="CSS中link和@import区别"></a>CSS中link和@import区别</h2><p><strong>1.从属关系区别</strong><br><code>@import</code>是 <strong>CSS</strong> 提供的语法规则，只有<strong>导入样式表</strong>的作用；<code>link</code>是<strong>HTML</strong>提供的标签，不仅可以<strong>加载 CSS 文件</strong>，还可以<strong>定义 RSS、rel 连接属性</strong>等。</p><p><strong>2.加载顺序区别</strong><br>加载页面时，<code>link</code>标签引入的 CSS 被同时加载；<code>@import</code>引入的 CSS 将<strong>在页面加载完毕后被加载</strong>。</p><p><strong>3.兼容性区别</strong><br><code>@import</code>是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；<code>link</code>标签作为 HTML 元素，不存在兼容性问题。</p><p>操控DOM和样式的权重暂不理解。</p><h2 id="less⭐"><a href="#less⭐" class="headerlink" title="less⭐"></a>less⭐</h2><p>less是一门css的预处理语言</p><ul><li>less是一个css的增强版，通过less可以<strong>编写更少的代码实现更强大的样式</strong>，添加了许多的新特性：像对<strong>变量</strong>的支持、对<strong>mixin</strong>的支持… …</li><li>less的语法大体上和css语法一致，但是less中增添了许多对css的扩展，所以浏览器无法直接执行less代码，要执行必须向将<strong>less转换为css</strong>，然后再由浏览器执行</li></ul><p>特点</p><ul><li><strong>结构写的更加清晰</strong></li><li>变量 <code>@变量名</code></li><li><code>&amp;</code> 表示外层的父元素 <code>&amp;::after</code> <code>&amp;:hover</code></li><li><code>:extend()</code> 对当前选择器扩展指定选择器的样式（选择器分组）</li></ul><h2 id="script标签的defer和async属性有什么区别"><a href="#script标签的defer和async属性有什么区别" class="headerlink" title="script标签的defer和async属性有什么区别"></a>script标签的defer和async属性有什么区别</h2><h3 id="async标记"><a href="#async标记" class="headerlink" title="async标记"></a>async标记</h3><p>async标记告诉浏览器在等待js下载期间可以去干其他事，当js下载完成后会<strong>立即(尽快)执行</strong>，多条js可以并行下载。</p><p>async的好处是让多条js不会互相等待，下载期间浏览器会去干其他事(继续解析HTML等)，异步下载，异步执行。</p><h3 id="defer标记"><a href="#defer标记" class="headerlink" title="defer标记"></a>defer标记</h3><p>与async一样，defer标记告诉浏览器在等待js下载期间可以去干其他事，多条js可以并行下载，不过当js下载完成之后<strong>不会立即执行</strong>，而是会等待解析完整个HTML之后在开始执行，而且多条defer标记的js会<strong>按照顺序执行</strong>。</p><h3 id="到底该用哪个标记"><a href="#到底该用哪个标记" class="headerlink" title="到底该用哪个标记"></a>到底该用哪个标记</h3><p>两个标记都是为了让script标签实现<strong>异步下载</strong>，主要的区别在于<code>async</code>无法保证顺序且下载完就会执行而<code>defer</code>则会等待整个HTML解析之后才会开始执行，并且按照插入的顺序执行。</p><p>如果两个script之间<strong>没有依赖关系</strong>并且<strong>无需等待页面解析</strong>的更加适合使用<code>async</code>，反之如果两个script之间<strong>有依赖关系</strong>，或者希望<strong>优先解析HTML</strong>，则<code>defer</code>更加适合。</p><p>defer脚本会在文档渲染完毕后，<code>DOMContentLoaded</code>事件调用前执行。</p><h2 id="CSS选择器优先级⭐"><a href="#CSS选择器优先级⭐" class="headerlink" title="CSS选择器优先级⭐"></a>CSS选择器优先级⭐</h2><p>CSS 中的权重，指的是<strong>选择器的优先级</strong>。</p><p>对同一HTML元素设置样式时，不同选择器的优先级不同，<strong>优先级低的样式将被高优先级的样式层叠掉</strong>。</p><p>CSS 权重优先级顺序简单表示为：</p><p><code>!important &gt; 内联样式(style=&quot;&quot;) &gt; ID (#id属性值) &gt; 类(.class属性值)、伪类(:nth-child())、属性([属性名]) &gt; 标签名(p&#123;&#125;)、伪元素(::after) &gt; 通配符(*)</code></p><h1 id="纯CSS3实现卡通人物眼睛的动画特效⭐"><a href="#纯CSS3实现卡通人物眼睛的动画特效⭐" class="headerlink" title="纯CSS3实现卡通人物眼睛的动画特效⭐"></a>纯CSS3实现卡通人物眼睛的动画特效⭐</h1><p>整体主要是利用边框和圆角进行绘制。</p><ul><li><p>左眼勾玉：span设置圆角，它伪元素设置边框实现</p></li><li><p>右眼轮回圈：边框+圆角+层叠等级</p></li><li><p>木叶标志：边框+圆角</p></li><li><p>胡须：边框三角形</p></li><li><p>眼睛效果：<code>box-shadow</code>+<code>border-radius</code>获得眼睛轮廓和内眼影，外眼影<code>filter: drop-shadow</code></p></li></ul><p>具体设置数值参考他人，自己主要是换成了vw，vh进行自适应适配。</p><p>动画：</p><ul><li>眼睛：animation+transform（旋转、缩放）+opacity（不透明度）+定位</li><li>hover鼠标移入，写轮眼 无限旋转 轮回眼 缩放 反向交替执行</li></ul><h2 id="自适应布局"><a href="#自适应布局" class="headerlink" title="自适应布局"></a>自适应布局</h2><p>网页在各终端上的展示效果就像缩放设计稿图片一样，在不同屏幕上等比缩放，每一个元素与整体比例保持不变，真实还原设计稿。</p><h3 id="1px边框问题"><a href="#1px边框问题" class="headerlink" title="1px边框问题"></a>1px边框问题</h3><p><strong>dpr(物理像素和设备独立像素（逻辑像素）的比值）可以用来解释不同分辨率手机呈现页面的精细度的差异</strong>，但并不能解释1px问题。</p><p><strong>多（2，3）倍的设计图设计了1px的边框，在手机上缩小呈现时，由于css最低只支持显示1px大小，导致边框太粗的效果。（ps：ios较新版已支持0.5px，安卓不支持，这里暂且忽略）。</strong></p><h4 id="通过设置meta标签viewport"><a href="#通过设置meta标签viewport" class="headerlink" title="通过设置meta标签viewport"></a>通过设置meta标签viewport</h4><p>如果设置<strong>content的width就等于设计图大小750px</strong>，然后通过<strong>动态设置initial-scale值让网页整体缩放</strong>，就能实现效果了。</p><h4 id="通过transform-scale-缩放（推荐）"><a href="#通过transform-scale-缩放（推荐）" class="headerlink" title="通过transform: scale()缩放（推荐）"></a>通过transform: scale()缩放（推荐）</h4><p>具体的scale缩放比例取决于你是<strong>几倍设计图尺寸下的1px</strong>。</p><h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><p>视口(viewport)代表当前可见的计算机图形区域。在Web浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的UI， 菜单栏等——即指你正在浏览的文档的那一部分。</p><p>而移动端则较为复杂，它涉及到三个视口：布局视口（Layout Viewport）、视觉视口（Visual Viewport）和理想视口（Ideal Viewport）。</p><p>布局视口使视口与移动端浏览器屏幕宽度完全独立开。CSS 布局将会根据它来进行计算，并被它约束。</p><p>视觉视口是用户当前看到的区域，用户可以通过缩放操作视觉视口，同时不会影响布局视口。</p><p>理想视口对设备而言是最理想的布局视口尺寸。显示在理想视口中的网站具有最理想的宽度，用户无需进行缩放。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="解决适配方法"><a href="#解决适配方法" class="headerlink" title="解决适配方法"></a>解决适配方法</h3><h4 id="rem适配"><a href="#rem适配" class="headerlink" title="rem适配"></a>rem适配</h4><p><code>em</code>：在 <code>font-size</code> 中使用是相对于<strong>父元素的字体大小</strong>，在<strong>其他属性</strong>中使用是相对于<strong>自身的字体大小</strong>，如 width。</p><p>区别在于使用rem为元素设定字体大小时，仍然是相对大小，但<strong>相对的只是HTML根元素</strong>。</p><p>这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到<strong>只修改根元素就成比例地调整所有字体大小</strong>，又可以避免字体大小逐层复合的连锁反应。</p><h4 id="vw，vh布局"><a href="#vw，vh布局" class="headerlink" title="vw，vh布局"></a>vw，vh布局</h4><p>vh、vw方案即将视觉视口宽度 window.innerWidth和视觉视口高度 window.innerHeight 等分为 100 份。</p><p>像<code>vw</code>、<code>vh</code>，比较容易混淆的一个单位是<code>%</code>，不过百分比宽泛的讲是相对于<strong>父元素</strong>。</p><p>视口单位主要包括以下4个：</p><ul><li><strong>vw</strong>：1vw等于视口宽度的1%。</li><li><strong>vh</strong>：1vh等于视口高度的1%。</li><li><strong>vmin</strong>：选取vw和vh中最小的那个。</li><li><strong>vmax</strong>：选取vw和vh中最大的那个。</li></ul><p><strong>缺点</strong>：用户失去了放缩任何使用<code>vw</code>单位的元素的能力。</p><p>vh和vw方案和rem类似也是相当麻烦需要做单位转化，而且px转换成vw不一定能完全整除，因此有一定的像素差。</p><p>不过在工程化的今天，webpack解析css 的时候用postcss-loader 有个postcss-px-to-viewport能自动实现px到vw的转化</p><h4 id="媒体查询-响应式布局"><a href="#媒体查询-响应式布局" class="headerlink" title="媒体查询 响应式布局"></a>媒体查询 响应式布局</h4><p><code>@media 查询规则&#123;&#125;</code>通过媒体查询，可以为不同的设备，或设备不同状态来分别设置样式</p><h4 id="px为主，vx和vxxx（vw-vh-vmax-vmin）为辅，搭配一些flex（推荐）"><a href="#px为主，vx和vxxx（vw-vh-vmax-vmin）为辅，搭配一些flex（推荐）" class="headerlink" title="px为主，vx和vxxx（vw/vh/vmax/vmin）为辅，搭配一些flex（推荐）"></a>px为主，vx和vxxx（vw/vh/vmax/vmin）为辅，搭配一些flex（推荐）</h4><h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><h3 id="利用border画三角形"><a href="#利用border画三角形" class="headerlink" title="利用border画三角形"></a>利用border画三角形</h3><p><code>border</code>可以用于设置一个或多个以下属性的值: <code>border-width</code>, <code>border-style</code>, <code>border-color</code></p><p>本质还是利用了盒模型，<strong>每个边框都是梯形</strong>，当<strong>内容区宽高为0</strong>时就成三角形。</p><p>最简单：内容区宽高为0，border设置大小但颜色透明，单独给一个边框颜色。四个边框分别设置会得到更多不同形状的三角形。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">125px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left-color</span>: aqua;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日常用的更多可能是利用伪元素，<code>content: &#39;&#39;;</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div5</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-top-color</span>:  white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h3><p><code>border-radius</code>允许你设置元素的外边框圆角当使用<strong>一个半径时确定一个圆形</strong>,当使用<strong>两个半径时确定一个椭圆</strong></p><p>这个(椭)圆与边框的交集形成圆角效果。</p><p>该属性是一个简写属性,是为了将这四个属性 <code>border-top-left-radius</code> 、<code>border-top-right-radius</code> 、<code>border-bottom-right-radius</code>和 <code>border-bottom-left-radius</code> 简写为一个属性。</p><p>即使元素<strong>没有边框</strong>,圆角也可以用到 <code>background</code> 上面。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 右上和左下设置圆角*/</span></span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">12vmin</span> <span class="number">0</span> <span class="number">12vmin</span>;</span><br><span class="line"><span class="comment">/* 圆形*/</span></span><br><span class="line"><span class="attribute">width</span>: <span class="number">60vmin</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">60vmin</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br></pre></td></tr></table></figure><h3 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h3><p>用于在元素的框架上添加阴影效果。你可以在同一个元素上设置多个阴影效果，并用逗号将他们分隔开。该属性可设置的值包括<code>阴影的X轴偏移量</code>、<code>Y轴偏移量</code>、<code>模糊半径</code>、<code>扩散半径</code>和<code>颜色</code>。</p><p>如果元素同时设置了 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius"><code>border-radius</code></a>属性 ，那么阴影也会有圆角效果。</p><p>如果没有指定<code>inset</code>，默认阴影在边框外，即阴影向外扩散。</p><p>使用 <code>inset</code> 关键字会使得阴影落在盒子内部，此时阴影会在边框之内 (即使是透明边框）、背景之上、内容之下。</p><p>ios中<code>box-shadow</code>容易出现bug，一种方式是设置<code>border: none;</code>，使用<code>box-shadow</code>和<code>border-radius</code>可以获得类似<strong>边框</strong>的效果。</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。</p><p>drop-shadow()为输入图像添加投影效果。投影实际上是输入图像的alpha蒙版的一个模糊的、偏移的版本，用特定的颜色绘制并合成在图像下面。</p><p><code>drop-shadow()</code>在ios中也会出现bug，但在一些地方又能正常显示，因此尚未找到原因和解决方法。</p><h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p>：<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>这四个属性要生效的话,必须得设置<code>相对定位/绝对定位</code>，即<code>position：relative;</code>或者<code>position：absolute;</code>，也就是说<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>是为<code>相对定位/绝对定位</code>而生的。</p><p>子绝父相就是：子元素为绝对定位(<code>position：absolute;</code>)，父元素为相对定位<code>position：relative;</code>。</p><p><strong>absolute</strong>元素会<strong>被移出正常文档流</strong>，并不为元素预留空间，通过指定元素相对于<strong>最近的非 static 定位祖先元素的偏移</strong>，来确定元素位置。</p><p><strong>fixed</strong>元素会<strong>被移出正常文档流</strong>，并不为元素预留空间，而是通过指定元素相对于<strong>屏幕视口（viewport）</strong>的位置来指定元素位置。</p><h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><p>元素提升为一个比较特殊的图层，在三维空间中 <strong>(z轴)</strong> 高出普通元素一等。</p><ul><li>触发条件<ul><li>根层叠上下文(<code>html</code>)</li><li><code>position</code></li><li>css3属性</li></ul></li><li>层叠等级：层叠上下文在z轴上的排序<ul><li><strong>在同一层叠上下文中，层叠等级才有意义</strong> 先处理子元素，作为整体传递，父元素再与其兄弟元素层叠。</li><li><code>z-index</code>的优先级最高，行内，浮动，块，<code>z-index</code>为负，背景/边框</li></ul></li></ul><h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>**<code>transform</code>**属性允许你旋转<code>rotate()</code>，缩放<code>scale()</code>，倾斜或平移<code>translate()</code>给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。</p><p><strong><code>transform-origin</code></strong> 属性让你更改一个元素变形的原点。（默认的转换原点是 <code>center</code>)</p><blockquote><p>transform对定位元素的影响</p></blockquote><p>当给一个元素加上<code>transform</code>属性的时候，这个元素就会具有<code>relative</code>的特性,所以<strong>若一个元素的父元素拥有tranform属性，那么子元素在使用定位属性的时候要注意。</strong></p><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>简写属性。</p><h4 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h4><p>后边指定动画名称<code>animation-name</code></p><p>关键帧 <strong><code>@keyframes</code></strong> at-rule 规则通过在动画序列中定义关键帧（或waypoints）的样式来<strong>控制CSS动画序列中的中间步骤</strong>。</p><p><code>0%</code>/<code>from</code> 和<code>100%</code>/<code>to</code></p><h4 id="animation-duration"><a href="#animation-duration" class="headerlink" title="animation-duration"></a>animation-duration</h4><p>指定一个<strong>动画周期的时长</strong>。</p><h4 id="animation-timing-function"><a href="#animation-timing-function" class="headerlink" title="animation-timing-function"></a>animation-timing-function</h4><p>定义CSS动画在每一动画周期中<strong>执行的节奏</strong> 可能值为一或多个 <code>&lt;timing-function&gt;</code> 。</p><p>对于关键帧动画来说,<code>timing function</code>作用于<strong>一个关键帧周期</strong>而非整个动画周期,即从关键帧开始开始,到关键帧结束结束。</p><h4 id="animation-delay"><a href="#animation-delay" class="headerlink" title="animation-delay"></a>animation-delay</h4><p>定义动画于何时开始，即<strong>从动画应用在元素上到动画开始的这段时间的长度</strong>。</p><h4 id="animation-iteration-count"><a href="#animation-iteration-count" class="headerlink" title="animation-iteration-count"></a>animation-iteration-count</h4><p>定义动画在结束前运行的<strong>次数</strong> 。可以是1次/无限循环<code>infinite</code>.</p><h4 id="animation-direction"><a href="#animation-direction" class="headerlink" title="animation-direction"></a>animation-direction</h4><p>指示动画是否<strong>反向播放</strong>。</p><h4 id="animation-fill-mode"><a href="#animation-fill-mode" class="headerlink" title="animation-fill-mode"></a>animation-fill-mode</h4><p>设置CSS动画在<strong>执行之前和之后如何将样式应用于其目标</strong>。</p><h2 id="伪类-伪元素"><a href="#伪类-伪元素" class="headerlink" title="伪类/伪元素"></a>伪类/伪元素</h2><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p><strong>伪类</strong>是选择器的一种，它用于选择处于<strong>特定状态</strong>的元素。</p><p><code>:first-child</code> 第一个子元素，<code>:last-child</code>，最后一个子元素 <code>:nth-child()</code> 选中第n个子元素。</p><p><code>:hover</code>- 这仅适用于用户在元素上<strong>移动鼠标</strong>，通常是<strong>链接</strong>。</p><p><code>:focus</code> - 仅在用户通过<strong>单击或使用键盘控件</strong>来适用元素。</p><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p><strong><code>::before</code></strong>/<code>::after</code>用来创建一个伪元素，作为已选中元素的<strong>第一个</strong>/<strong>最后一个子元素</strong>。通常会配合<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content"><code>content</code></a>属性来为该元素添加装饰内容。这个虚拟元素<strong>默认是行内元素</strong>。</p><p><strong><code>::before</code></strong>/<code>::after</code>表示法是在<strong>CSS 3</strong>中引入的，<code>::</code>符号是用来区分<strong>伪类</strong>和伪元素的。支持CSS3的浏览器同时也都支持CSS2中引入的表示法<code>:before</code>/<code>:after</code>。</p><h1 id="JacaScript"><a href="#JacaScript" class="headerlink" title="JacaScript"></a>JacaScript</h1><h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><h3 id="解释代码-vs-编译代码"><a href="#解释代码-vs-编译代码" class="headerlink" title="解释代码 vs 编译代码"></a>解释代码 vs 编译代码</h3><p>在<strong>解释型</strong>语言中，代码<strong>自上而下</strong>运行，且<strong>实时返回运行结果</strong>。</p><p>代码在由浏览器执行前，<strong>不需要将其转化为其他形式</strong>。代码将直接以<strong>文本格式（text form）</strong>被接收和处理。</p><p>相对的，<strong>编译型</strong>语言需要先将代码<strong>转化（编译）</strong>成另一种形式才能运行。</p><p>比如 C/C++ 先被<strong>编译成汇编语言</strong>，然后才能由计算机运行。程序将以<strong>二进制</strong>的格式运行，这些二进制内容是由程序源代码产生的。</p><p><strong>JavaScript 是轻量级解释型语言</strong>。</p><p>浏览器接受到JavaScript代码，并以代码自身的文本格式运行它。</p><p>技术上，几乎所有 JavaScript 转换器都运用了一种叫做<strong>即时编译（just-in-time compiling）</strong>的技术；</p><p>当 JavaScript 源代码被执行时，它会被编译成<strong>二进制</strong>的格式，使代码<strong>运行速度更快</strong>。</p><p>尽管如此，JavaScript 仍然是一门解释型语言，因为<strong>编译过程发生在代码运行中，而非之前</strong>。</p><h3 id="服务器端代码-vs-客户端代码"><a href="#服务器端代码-vs-客户端代码" class="headerlink" title="服务器端代码 vs 客户端代码"></a>服务器端代码 vs 客户端代码</h3><p>客户端代码是在用户的电脑上运行的代码，在浏览一个网页时，它的客户端代码就会被下载，然后由浏览器来运行并展示。</p><p>这就是<strong>客户端JavaScript</strong>。</p><p>而服务器端代码在服务器上运行，接着运行结果才由浏览器下载并展示出来。</p><p>流行的服务器端 web 语言包括：PHP、Python、Ruby、ASP.NET 以及…… JavaScript！</p><p><strong>JavaScript 也可用作服务器端语言</strong>，比如现在流行的 Node.js 环境。</p><h2 id="数据类型⭐"><a href="#数据类型⭐" class="headerlink" title="数据类型⭐"></a>数据类型⭐</h2><blockquote><p>JavaScript 是一种<strong>弱类型</strong>或者说<strong>动态</strong>语言。</p><p>这意味着你<strong>不用提前声明变量</strong>的类型，在程序<strong>运行</strong>过程中，<strong>类型会被自动确定</strong>。</p><p>这也意味着你可以使用<strong>同一个变量保存不同类型的数据</strong>。</p></blockquote><h3 id="8种数据类型-7-1"><a href="#8种数据类型-7-1" class="headerlink" title="8种数据类型: 7+1"></a>8种数据类型: 7+1</h3><ul><li>原始类型(值不可变，栈)：<code>Undefined</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>BigInt</code>、<code>Symbol</code>、<code>Null</code></li><li>引用数据类型（堆，地址：栈）：<code>Object</code>（几乎所有通过 <code>new</code> 创建的东西：Array、Set、Date）</li></ul><h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><p><strong>typeof</strong>（操作符，非函数）：</p><p>对于<strong>原始类型</strong>，除 <code>null</code> （遗留已久的 bug）都可以正确判断；对于引用类型，除 <code>function</code> 外，都会返回 <code>&#39;object&#39;</code>。返回值为 <code>string</code> （小写）。<code>typeof</code> 未定义的变量返回 <code>&#39;undefined&#39;</code>。</p><p><strong>instanceof</strong></p><p>用于检测构造函数的 <code>prototype</code> 属性是否出现在<strong>某个实例对象的原型链上</strong>。只能判断<strong>引用类型</strong>。</p><p>常用来判断 <code>A</code> 是否为 <code>B</code> 的实例。返回布尔值。</p><p><code>instanceof</code> 和多全局对象(例如：多个 frame 或多个 window 之间的交互)</p><p><strong>多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。</strong></p><p><strong>Object.prototype.toString.call()</strong> <strong>toString.call()</strong></p><p>精准判断数据类型 。统一返回格式<code>&#39;[object Xxx]&#39;</code> 的字符串</p><h3 id="判断数组"><a href="#判断数组" class="headerlink" title="判断数组"></a>判断数组</h3><ul><li><p><code>Array.isArray()</code></p></li><li><p><code>Object.prototype.toString.call()</code> 进行判断，此方式兼容性最好</p></li><li><p><code>instanceof</code></p><p>多个 frame 或多个 window 之间的交互不适用。</p></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><blockquote><p>隐式（自动）/显式强转（开发人员）</p></blockquote><p><strong>在 JS 中只会转换为以下 3 种类型</strong></p><ul><li><code>Number</code> 类型：</li><li>强转：<ul><li><code>Number()</code><ul><li>字符串：<strong>空字符串变为0</strong>，如果出现<strong>任何一个非有效数字字符</strong>，结果都是<code>NaN</code></li><li>布尔转换为数字 true-&gt;1 false-&gt;0</li><li>null-&gt;0 undefined-&gt;NaN</li><li>Symbol无法转换为数字，BigInt去除“n”</li></ul></li><li><code>parseInt(string, radix)</code>：逐个解析字符，并返回一个整数。当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</li><li><code>parseFloat(string)</code>：指定字符串中的首个字符是否是数字。是，解析，直到到达数字的末端为止返回该数字。</li></ul></li><li>隐式：<ul><li>比较操作（&gt;, &lt;, &lt;=, &gt;=）</li><li>按位操作（| &amp; ^ ~）</li><li>算数操作（- + * / %）， <strong>注意</strong>：当 + 操作存在任意的操作数是 string 类型时，不会触发 number 类型的隐式转换</li></ul></li><li><code>String</code> 类型：</li><li>强转：<code>String()</code> / <code>toString()</code>(数组方法)</li><li>隐式：有 <code>+</code> 运算符并且有一个操作数是 <code>string/object</code> 类型</li><li><code>Boolean</code> 类型:<ul><li>强转：<code>Boolean()</code></li><li>隐式：逻辑判断或者有逻辑运算符（|| &amp;&amp; !），逻辑运算符内部转换和比较，实际返回原始操作数值<ul><li><strong>false</strong>：<code>0</code> <code>NaN</code> <code>&quot;&quot;</code> <code>null</code> <code>undefined</code>，其余都是true</li></ul></li></ul></li></ul><h3 id="amp"><a href="#amp" class="headerlink" title="=== &amp; =="></a><code>=== &amp; ==</code></h3><ul><li><code>===</code> 是严格相等，要求数据类型和值都要相等；<code>==</code> 只需要值相等。</li><li><code>==</code> 会发生隐式类型转换，<code>===</code> 不会发生隐式类型转换。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span>==<span class="literal">undefined</span>      <span class="comment">//true  null/undefined和其他任何值都不相等</span></span><br><span class="line"><span class="literal">null</span>===<span class="literal">undefined</span>     <span class="comment">//false</span></span><br><span class="line">&#123;&#125;==&#123;&#125;      <span class="comment">//false   因为比较的是地址</span></span><br><span class="line"><span class="literal">NaN</span>==<span class="literal">NaN</span> <span class="comment">//false</span></span><br><span class="line">[] == <span class="number">0</span> <span class="comment">// true 对象，另一个是数字或字符串，会尝试使用对象方法转换为原始值</span></span><br><span class="line"><span class="literal">true</span> == <span class="number">2</span> <span class="comment">// false 操作数之一是Boolean，则将布尔操作数转换为1或0</span></span><br><span class="line"><span class="string">&#x27;1222&#x27;</span>==<span class="number">1222</span> <span class="comment">// 当数字与字符串进行比较时，会尝试将字符串转换为数字值。</span></span><br></pre></td></tr></table></figure><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>基于 IEEE 754 标准的<strong>双精度 64 位</strong>二进制格式的值（<code>-(2^53 -1) 到 2^53 -1</code>）。<strong>它并没有为整数给出一种特定的类型</strong>。</p><p>除了能够表示浮点数外，还有一些带符号的值：<code>+Infinity</code>，<code>-Infinity</code> 和 <code>NaN</code> (非数值，Not-a-Number)。</p><p>要检查值是否大于或小于 <code>+/-Infinity</code>，你可以使用常量<code>Number.MAX_VALUE</code> 和 <code>Number.MIN_VALUE</code>。</p><p>另外在 ECMAScript 6 中，你也可以通过 <code>Number.isSafeInteger()</code>方法还有 <code>Number.MAX_SAFE_INTEGER</code>和 <code>Number.MIN_SAFE_INTEGER</code>来检查值是否在双精度浮点数的取值范围内。</p><p><strong>超出这个范围，JavaScript 中的数字不再安全了。</strong></p><h3 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1 + 0.2 !== 0.3?"></a>0.1 + 0.2 !== 0.3?</h3><p>导致这样的问题是因为 <code>JavaScript</code> 中使用基于<strong>IEEE 754标准</strong>的<strong>浮点数</strong>运算，所以会产生舍入误差。</p><p>也就是说所有遵循 <code>IEEE 754</code> 标准的语言进行浮点数运算的时候，都会有这个问题。</p><p>双精度浮点数使用<strong>64 bit</strong>来进行存储。</p><p><strong>计算机中用二进制来存储小数，而大部分小数转成二进制之后都是无限循环的值，因此存在取舍问题，也就是精度丢失。</strong></p><p><strong>不管是浮点数计算的计算结果错误和大整数的计算结果错误，最终都可以归结到JS的精度只有53位（尾数只能存储53位的有效数字）。</strong></p><blockquote><p>解决方案</p></blockquote><ol><li>使用 <code>JavaScript</code> 提供的<strong>最小精度值</strong>判断误差是否在该值范围内<br><code>Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON</code></li><li>使用别人的轮子,例如：<code>math.js</code></li></ol><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p><code>use strict</code></p><p>全局变量必须<strong>显式声明</strong></p><p><strong>禁止（函数中）this指向全局对象，而是指向undefined</strong></p><p><strong>禁止删除变量</strong></p><p>禁止了<strong>不在脚本或者函数层面上</strong>的函数声明</p><p>禁止<strong>变量</strong>、<strong>对象属性</strong>或<strong>函数参数</strong>重名</p><p>禁止动态绑定</p><p><strong>限制了arguments对象</strong>：不允许对arguments赋值，arguments不再跟踪参数的变化</p><h2 id="作用域与闭包⭐"><a href="#作用域与闭包⭐" class="headerlink" title="作用域与闭包⭐"></a>作用域与闭包⭐</h2><h2 id="原型与原型链⭐"><a href="#原型与原型链⭐" class="headerlink" title="原型与原型链⭐"></a>原型与原型链⭐</h2><p><code>JavaScript</code>所有的对象本质上都是通过<code>new 函数</code>创建的，包括对象字面量的形式定义对象(相当于<code>new Object()</code>的语法糖)。</p><p>所有的函数本质上都是通过<code>new Function</code>创建的，包括<code>Object</code>、<code>Array</code>等。</p><p>所有的函数都是对象。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Tkh7H1"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2021/12/17/Tkh7H1.png" alt="Tkh7H1.png"></a></p><ul><li>每个函数都有一个属性<code>prototype</code>，它就是原型，默认情况下它是一个普通<code>Object</code>对象，这个对象是调用该构造函数所创建的实例的原型。</li><li>JavaScript同样存在由原型指向构造函数的属性：<code>constructor</code>，即<code>Func.prototype.constructor --&gt; Func</code></li><li><code>JavaScript</code>中所有对象都具有一个<code>__proto__</code>属性，该属性指向该对象的原型。</li></ul><p>实例对象在查找属性时，如果查找不到，就会沿着<code>__proto__</code>去与对象关联的原型上查找，如果还查找不到，就去找原型的原型，直至查到最顶层，这也就是原型链的概念。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TkhJ0I"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2021/12/17/TkhJ0I.png" alt="TkhJ0I.png"></a></p><ul><li><p>所有函数(包括<code>Function</code>)的<code>__proto__</code>指向<code>Function.prototype</code></p></li><li><p>自定义对象实例的<code>__proto__</code>指向构造函数的原型</p></li><li><p>函数的<code>prototype</code>的<code>__proto__</code>指向<code>Object.prototype</code></p></li><li><p><code>Object.prototype.__proto__ --&gt; null</code></p></li></ul><h2 id="DOM事件总结⭐"><a href="#DOM事件总结⭐" class="headerlink" title="DOM事件总结⭐"></a>DOM事件总结⭐</h2><h3 id="DOM事件的级别"><a href="#DOM事件的级别" class="headerlink" title="DOM事件的级别"></a>DOM事件的级别</h3><p><strong>DOM0的写法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种事件绑定的方式，如果绑定多个，则后面的会覆盖掉前面的</span></span><br><span class="line">element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是在 js 中的写法；如果要在html中写，写法是：在onclick属性中，加 js 语句。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;hello&#x27;);&quot;</span>&gt;</span>我是按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p><strong>DOM2的写法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高版本浏览器</span></span><br><span class="line">element.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// IE8及以下版本浏览器。IE11和谷歌浏览器等不支持</span></span><br><span class="line">element.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的第三参数中，<strong>true</strong>表示事件在<strong>捕获阶段</strong>触发，<strong>false</strong>表示事件在<strong>冒泡阶段</strong>触发（默认）。</p><p><code>addEventListener()</code>中的<code>this</code>，是<strong>绑定事件的对象</strong>；如果写箭头函数是<strong>window</strong>。</p><p>绑定多个响应函数执行顺序是：<strong>先绑定先执行</strong>。</p><p><strong>DOM3的写法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>DOM3中，增加了很多事件类型，比如<strong>鼠标事件</strong>、<strong>键盘事件</strong>等。</p><h3 id="DOM事件模型"><a href="#DOM事件模型" class="headerlink" title="DOM事件模型"></a>DOM事件模型</h3><p><strong>DOM事件模型</strong>讲的就是<strong>捕获和冒泡</strong>。</p><ul><li><p>捕获：从上往下。事件会从最外层开始发生，直到最具体的元素。</p></li><li><p>冒泡：从下（目标元素）往上。事件会从最内层的元素开始发生，一直向上传播到<code>Window</code> 对象。</p></li></ul><p><strong>DOM事件流</strong>讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。</p><p>完整的事件流，分三个阶段：</p><ul><li><p><strong>捕获</strong>：从 <code>window</code> 对象传到 <strong>目标元素</strong>。</p></li><li><p><strong>目标阶段</strong>：事件通过捕获，到达目标元素，这个阶段就是目标阶段。</p></li><li><p><strong>冒泡</strong>：从<strong>目标元素</strong>传到 <code>Window</code> 对象。</p></li></ul><p>捕获阶段，事件依次传递的顺序是：<code>window</code> –&gt; <code>document</code> –&gt; <code>html</code>–&gt; <code>body</code> –&gt; 父元素、子元素、目标元素。</p><p>冒泡的流程与捕获的流程相反。</p><p><strong>事件捕获优先于事件冒泡</strong>。</p><h3 id="Event对象的常见-api-方法"><a href="#Event对象的常见-api-方法" class="headerlink" title="Event对象的常见 api 方法"></a>Event对象的常见 api 方法</h3><p><strong>Event 对象代表事件的状态</strong>，当dom tree中某个事件被触发的时候，会同时自动产生一个<strong>用来描述事件所有的相关信息</strong>（比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态）的对象。</p><p>阻止默认事件<code>event.preventDefault();</code> 如阻止了链接的默认跳转</p><p>阻止冒泡 <code>event.stopPropagation();</code></p><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委派指将事件统一绑定给元素的<strong>共同的祖先元素</strong>，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。事件委派是利用了<strong>冒泡</strong>，通过委派可以减少事件绑定的次数，提高程序的性能。</p><p><code>event.currentTarget</code> 返回<strong>绑定事件的元素</strong>。在事件委托中，一般是【祖先元素】。<br><code>event.target</code> 返回<strong>触发事件的元素</strong>。在事件委托中，一般是【子元素】。</p><h2 id="this指向⭐"><a href="#this指向⭐" class="headerlink" title="this指向⭐"></a>this指向⭐</h2><p>目的就是指向<strong>函数</strong>运行时（箭头函数除外）所在的环境。</p><p>总结了<code>this</code>的绑定规则总共是有下面5种：请记住一点：==谁调用这个函数或方法,this关键字就指向谁。==</p><ul><li><p>默认绑定（严格/非严格模式）</p><ul><li>无论是否在严格模式下，在全局执行环境中（在任何函数体外部）<code>this</code> 都指向全局对象。</li><li>非严格模式，函数中 <code>this</code> 的值默认指向全局对象，浏览器中就是<code>window</code>。</li><li>严格模式下，<code>this</code> 会保持为 <code>undefined</code>。</li><li><code>this</code> 在类中的表现与在函数中类似，在类的构造函数中，<code>this</code> 是一个常规对象。类中所有非静态的方法都会被添加到 <code>this</code> 的原型。静态方法不是 this 的属性，它们只是类自身的属性。</li><li>派生类的构造函数没有初始的 <code>this</code> 绑定。在构造函数中调用 <code>super()</code>会生成一个 <code>this</code> 绑定，并相当于获得基类的this。</li></ul></li><li><p>隐式绑定</p><ul><li>当<strong>函数作为对象的属性</strong>存在，通过<strong>对象属性执行函数</strong>时，此时隐式绑定规则会将<code>this</code>绑定到对象上。</li><li>赋值或函数传参（隐式赋值），会丢失该this绑定。</li></ul></li><li><p>显式绑定</p><ul><li><strong>通过 <code>call</code> <code>apply</code> <code>bind</code>绑定</strong></li></ul></li><li><p>new绑定</p><ul><li>当一个函数用作<strong>构造函数</strong>时（使用<code>new</code>关键字），它的<code>this</code>被绑定到<strong>正在构造的新对象</strong>。</li><li>当构造函数<strong>返回值为对象</strong>时，直接返回这个对象；否则返回<strong>new创建的对象</strong>。</li></ul></li><li><p>ES6箭头函数绑定</p><ul><li>通过<strong>作用域链</strong>查到<strong>外层作用域的 this</strong> ，且指向<strong>函数定义时的 this</strong> 而非执行时</li></ul></li></ul><p>判断this指向顺序：new、call/apply/bind、隐式绑定、默认绑定</p><h2 id="JS数组常用方法总结⭐"><a href="#JS数组常用方法总结⭐" class="headerlink" title="JS数组常用方法总结⭐"></a>JS数组常用方法总结⭐</h2><p>常见的数组定义：<strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p><p>==JavaScript 数组的长度和元素类型都是非固定的。==</p><p>因为数组的<strong>长度可随时改变</strong>，并且其数据<strong>在内存中也可以不连续</strong>（存储相同类型元素内存连续）。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><code>Array.from()</code> 从一个<strong>类数组</strong>或<strong>可迭代对象</strong>创建一个<strong>新的</strong>、<strong>浅拷贝</strong>的Array实例。</p><p><code>Array.isArray()</code>判断数组</p><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><p><code>Array.prototype.length</code></p><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p><strong>改变原数组</strong>的方法(9个):</p><ul><li><code>push(element1, ...)</code>：<strong>末尾</strong>+1/多，并返回<code>length</code></li><li><code>pop()</code>：<strong>删除最后一个元素</strong>，并<strong>返回该元素的值</strong>。</li><li><code>unshift(element1, ...)</code>：<strong>开头</strong>+1/多，并返回<code>length</code></li><li><code>shift()</code>：<strong>删除第一个元素</strong>，并<strong>返回该元素的值</strong>。</li><li><code>splice(开始,删除个数,新元素1...)</code>：<strong>删除</strong>或<strong>替换</strong>现有元素或者<strong>原地添加</strong>新的元素来修改数组,并<strong>以数组形式返回被删除的元素</strong></li><li><code>sort([比较函数])</code>：<strong>原地算法</strong>对数组的元素进行排序，并返回数组。比较函数返回值&gt;0,交换a、b。升序排列：<code>arr.sort((a,b)=&gt;a - b)</code></li><li><code>reverse()</code>：翻转数组</li><li><code>fill(1,0,this.length)</code>：用一个<strong>固定值</strong>填充一个数组中从<strong>起始索引</strong>到<strong>终止索引</strong>内的全部元素。<strong>不包括终止索引</strong>。返回<strong>修改后的数组</strong>。</li></ul><p><strong>不改变原数组</strong>的方法(8个):</p><ul><li><code>slice(begin,end)</code>：返回一个新的数组对象(一个<code>[begin,end)</code>决定的原数组的<strong>浅拷贝</strong>）</li><li><code>join(&#39;&#39;)</code>：将一个数组（或一个<strong>类数组对象</strong>）的所有元素连接成一个<strong>字符串</strong>并返回这个字符串。默认<code>,</code>分隔。</li><li><code>concat(arr1,...)</code>：合并数组，<strong>浅拷贝</strong></li><li><code>indexOf(searchElement, fromIndex)</code>：返回在数组中可以找到一个<strong>给定元素的第一个索引</strong>，如果不存在，则返回<code>-1</code>。严格相等<code>===</code>搜索元素。不能识别<code>NaN</code>。</li><li><code>includes</code>：判断一个数组是否包含一个指定的值，返回布尔值。</li></ul><p><strong>遍历</strong>方法(12个):</p><ul><li><p><code>forEach</code>：对数组的每个元素执行一次给定的函数。<code>array.forEach(function(currentValue, index, arr), thisArg)</code></p><ul><li>无法中途退出循环，只能用<code>return</code>退出本次回调，进行下一次回调。</li><li>它总是返回 <code>undefined</code>值,即使你return了一个值。</li></ul></li><li><p><code>map</code>：创建一个<strong>新数组</strong>，其结果是<strong>该数组中的每个元素都调用一个提供的函数后返回的结果</strong>。</p><ul><li><code>let new_array = arr.map(function(currentValue, index, arr), thisArg)</code></li></ul></li><li><p><code>filter</code>：返回一个<strong>新数组</strong>, 其包含<strong>通过所提供函数实现的测试的所有元素</strong>。</p><ul><li>``let new_array = arr.filter(function(currentValue, index, arr), thisArg)`</li></ul></li><li><p><code>reduce</code>：对累加器和数组中的每个元素（<strong>从左到右</strong>）应用一个函数，最终合并为一个值。</p><ul><li><code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code></li><li>如果 <code>initialValue</code> 在调用 reduce 时被提供，那么<strong>第一个</strong> <code>total</code> 将等于 <code>initialValue</code>，此时 <code>currentValue</code> 等于数组中的<strong>第一个值</strong>；</li><li>如果 <code>initialValue</code> 未被提供，那么 <code>total</code> 等于数组中的<strong>第一个值</strong>，<code>currentValue</code> 等于数组中的<strong>第二个值</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组求和 </span></span><br><span class="line"><span class="keyword">let</span> sum = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 将二维数组转化为一维 将数组元素展开</span></span><br><span class="line"><span class="keyword">let</span> flattened = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].reduce(</span><br><span class="line">    <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.concat(b),</span><br><span class="line">    []</span><br><span class="line">);</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p><code>keys/values/entries</code></p><ul><li>遍历<strong>键名</strong>、遍历<strong>键值</strong>、遍历<strong>键名+键值</strong></li><li>在<code>for..of</code>中如果遍历中途要退出，可以使用<code>break</code>退出循环。</li></ul></li></ul><h2 id="for…in和for…of有什么区别？"><a href="#for…in和for…of有什么区别？" class="headerlink" title="for…in和for…of有什么区别？"></a>for…in和for…of有什么区别？</h2><p><code>for…of</code> 是<code>ES6</code>新增的遍历方式，允许遍历一个含有<code>iterator</code>接口的数据结构（数组等）并且返回各项的值，和ES3中的<code>for…in</code>的区别如下：</p><ul><li><code>for…of</code> 遍历获取的是对象的<strong>键值</strong>，<code>for…in</code> 获取的是对象的<strong>键名</strong>；</li><li><code>for… in</code> 会遍历对象的整个<strong>原型链</strong>，性能非常差不推荐使用，而 <code>for … of</code> <strong>只遍历当前对象</strong>不会遍历原型链；</li><li>对于数组的遍历，<code>for…in</code> 会返回<strong>数组中所有可枚举的属性</strong>(包括原型链上可枚举的属性)，<code>for…of</code> 只返回数组的<strong>下标对应的属性值</strong>；</li></ul><p>总结： <code>for...in</code> 循环主要是为了<strong>遍历对象</strong>而生，不适用于遍历数组；<code>for...of</code> 循环可以用来<strong>遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象</strong>。</p><h2 id="对调两个变量的多种方法"><a href="#对调两个变量的多种方法" class="headerlink" title="对调两个变量的多种方法"></a>对调两个变量的多种方法</h2><h3 id="解构赋值法"><a href="#解构赋值法" class="headerlink" title="解构赋值法"></a>解构赋值法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">3</span>,b=<span class="number">5</span>;</span><br><span class="line">[a,b]=[b,a];</span><br></pre></td></tr></table></figure><h3 id="临时变量法"><a href="#临时变量法" class="headerlink" title="临时变量法"></a>临时变量法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">3</span>,b=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> c=a;</span><br><span class="line">a=b;</span><br><span class="line">b=c;</span><br></pre></td></tr></table></figure><h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">3</span>,b=<span class="number">5</span>;</span><br><span class="line">a=a+b;</span><br><span class="line">b=a-b;</span><br><span class="line">a=a-b;</span><br></pre></td></tr></table></figure><h3 id="数组法"><a href="#数组法" class="headerlink" title="数组法"></a>数组法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">3</span>,b=<span class="number">5</span>;</span><br><span class="line">a=[a,b];</span><br><span class="line">b=a[<span class="number">0</span>];</span><br><span class="line">a=a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">a=[b,b=a][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h3 id="对象法"><a href="#对象法" class="headerlink" title="对象法"></a>对象法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">3</span>,b=<span class="number">5</span>;</span><br><span class="line">a=&#123;<span class="attr">a</span>:b,<span class="attr">b</span>:a&#125;;</span><br><span class="line">b=a.b;</span><br><span class="line">a=a.a;</span><br></pre></td></tr></table></figure><h3 id="按位异或法"><a href="#按位异或法" class="headerlink" title="按位异或法"></a>按位异或法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">3</span>,b=<span class="number">5</span>;</span><br><span class="line">a=a^b;</span><br><span class="line">b=b^a;</span><br><span class="line">a=a^b;</span><br></pre></td></tr></table></figure><h2 id="浅拷贝和深拷贝⭐"><a href="#浅拷贝和深拷贝⭐" class="headerlink" title="浅拷贝和深拷贝⭐"></a>浅拷贝和深拷贝⭐</h2><p>对象直接赋值的情况，不涉及任何拷贝。此时为<strong>同一个引用</strong>。</p><p>浅拷贝只能拷贝<strong>一层对象</strong>。如果有对象的<strong>嵌套</strong>，那么浅拷贝将无能为力。</p><p><strong>浅拷贝：</strong></p><ul><li><strong>concat()</strong></li><li><strong>slice()</strong></li><li><strong>…展开运算符</strong></li><li><strong>Array.from</strong></li><li><strong>Object.assign(target, …sources)</strong> 拷贝的是<strong>对象的属性的引用</strong></li></ul><p><strong>深拷贝:</strong></p><p><code>JSON.parse(JSON.stringify(object))</code></p><ol><li>无法解决<code>循环引用</code>的问题。举个例子：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">val</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a.target = a;</span><br></pre></td></tr></table></figure><p>拷贝a会出现系统栈溢出，因为出现了<code>无限递归</code>的情况。</p><ol start="2"><li>无法拷贝一些<code>特殊的对象</code>，诸如 RegExp, Date, Set, Map等。</li><li>无法拷贝<code>函数</code>。</li><li>会忽略 undefined、symbol等</li></ol><p>第三方最完善的深拷贝方法是 <a href="https://link.juejin.cn/?target=https://www.lodashjs.com/">Lodash</a> 库的 <a href="https://link.juejin.cn/?target=https://www.lodashjs.com/docs/lodash.cloneDeep"><code>_.cloneDeep()</code></a> 方法。</p><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p><strong>封装实参的对象</strong></p><ul><li>arguments是一个<strong>类数组</strong>对象,它也可以通过索引来操作数据，也可以获取长度。</li><li>在调用函数时，我们所传递的实参都会在arguments中保存</li><li><code>arguments.length</code>可以用来获取实参的长度</li><li><code>arguments[0]</code> 表示第一个实参，<code>arguments[1]</code> 表示第二个实参 。。。</li></ul><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6+"></a>ES6+</h1><h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><p><code>BigInt</code>类型是 JavaScript 中的一个基础的数值类型，可以<strong>用任意精度表示整数</strong>。</p><p>使用 BigInt，您可以<strong>安全地存储和操作大整数，甚至可以超过数字的安全整数限制</strong>。</p><p>BigInt 是通过在整数末尾附加 <code>n</code>或调用构造函数来创建的。</p><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol是 ECMAScript 第6版新定义的。符号类型是<strong>唯一</strong>的并且是<strong>不可修改</strong>的, 并且也可以<strong>用来作为 Object 的 key 的值</strong>。</p><h2 id="Class与继承⭐"><a href="#Class与继承⭐" class="headerlink" title="Class与继承⭐"></a>Class与继承⭐</h2><p><strong>类是用于创建对象的模板。</strong>JS中的类建立在<strong>原型</strong>上，但也具有某些语法和语义未与ES5类相似语义共享。</p><h3 id="类定义与调用"><a href="#类定义与调用" class="headerlink" title="类定义与调用"></a>类定义与调用</h3><p><strong>类表达式</strong>和<strong>类声明</strong>。<strong>类声明不会提升</strong>。</p><p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p><h3 id="严格模式-1"><a href="#严格模式-1" class="headerlink" title="严格模式"></a>严格模式</h3><p>类的主体都执行在<strong>严格模式</strong>下，与普通构造函数不同。</p><p>当调用静态或原型方法时<strong>没有指定 this的值</strong>，那么方法内的 this值将被置为 **<code>undefined</code>**。</p><h3 id="构造函数与方法"><a href="#构造函数与方法" class="headerlink" title="构造函数与方法"></a>构造函数与方法</h3><p><code>constructor</code>（<strong>构造函数</strong>）方法是一个特殊的方法，这种方法用于<strong>创建和初始化</strong>一个由<code>class</code>创建的对象。</p><p>一个构造函数可以使用 <code>super</code> 关键字来<strong>调用一个父类的构造函数</strong>，从而获得父类的this。</p><p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。</p><p>事实上，<strong>类的所有非静态方法</strong>都定义在类的<code>prototype</code>属性上面。</p><p>因此，<strong>在类的实例上面调用方法，其实就是调用原型上的方法</strong>。</p><p>另外，类的内部所有定义的方法，都是<strong>不可枚举的（non-enumerable）</strong>。这一点与 ES5 的行为不一致。</p><p><code>static</code> 关键字用来定义一个类的一个静态方法。调用静态方法不需要<strong>实例化</strong>该类，但<strong>不能通过一个类实例调用静态方法</strong>。静态方法通常用于<strong>为一个应用程序创建工具函数</strong>。</p><h3 id="属性-字段"><a href="#属性-字段" class="headerlink" title="属性/字段"></a>属性/字段</h3><p><strong>实例的属性</strong>必须定义在<strong>类的方法里</strong>，静态的或原型的数据属性必须定义在<strong>类定义的外面</strong>。</p><p><strong>字段声明</strong>（实验性功能）</p><ul><li><p>公有字段：预先声明字段，类定义变得更加自我记录，并且字段始终存在。这个字段<strong>可以用也可以不用默认值来声明</strong>。</p></li><li><p>私有字段（<code>#</code>） 它们只能在类里面中读取或写入。</p></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><code>extends</code> 关键字在类声明或类表达式中用于创建一个类作为另一个类的一个子类。</p><p>如果子类中定义了构造函数，那么它必须先调用 <code>super()</code> 才能使用 <code>this</code> 。</p><p><code>super</code> 关键字用于<strong>调用对象的父对象上的方法。</strong></p><p>也可以继承传统的基于函数的“类”，但不能继承<strong>常规对象（不可构造的）</strong>。</p><p>如果要继承常规对象，可以改用<code>Object.setPrototypeOf()</code>：</p><p><code>Object.setPrototypeOf(obj, proto);</code>直接修改已有对象的原型。</p><h2 id="箭头函数与普通函数区别⭐"><a href="#箭头函数与普通函数区别⭐" class="headerlink" title="箭头函数与普通函数区别⭐"></a>箭头函数与普通函数区别⭐</h2><p><strong>箭头函数表达式</strong>的语法比<strong>函数表达式</strong>更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。</p><p>箭头函数表达式<strong>更适用于那些本来需要匿名函数的地方</strong>，并且它<strong>不能用作构造函数</strong>。</p><ol><li>箭头函数<strong>没有自己的this</strong>，它是<strong>通过作用域链查到外层作用域的this</strong>，且指向函数<strong>定义时</strong>的this而<strong>非执行时</strong>。</li><li><strong>不可以用作构造函数</strong>，<strong>不能使用new命令</strong>，否则会报错。同时，箭头函数<strong>没有prototype属性</strong>。</li><li>箭头函数<strong>没有arguments对象</strong>，如果要用，使用<strong>rest参数</strong>（<code>...args</code>）代替。</li><li><strong>不可以使用yield命令</strong>，因此箭头函数<strong>不能用作Generator函数</strong>。</li><li><strong>不能用call/apply/bind修改this指向</strong>，但<strong>可以通过修改外层作用域的this来间接修改</strong>。</li></ol><h2 id="let、const和var的区别⭐"><a href="#let、const和var的区别⭐" class="headerlink" title="let、const和var的区别⭐"></a>let、const和var的区别⭐</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul><li><p>存在<strong>变量提升</strong>，即变量可以在声明之前调用，值为<code>undefined</code>。</p></li><li><p>可以<strong>重复声明</strong>，第一次用来声明，后面只是重新赋值。</p></li><li><p>在<strong>函数</strong>中使用var声明变量的时候，该变量是<strong>局部</strong>的；对于声明在任何函数外（<strong>特别注意if和for中</strong>）的变量来说是<strong>全局</strong>的。</p></li></ul><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li><p>不存在变量提升，let声明变量前，该变量不能使用（<strong>暂时性死区</strong>）。</p></li><li><p>在<strong>块级作用域</strong>内有效。</p></li><li><p>let不允许在<strong>相同作用域</strong>中重复声明，注意是相同作用域，不同作用域有重复声明不会报错。</p></li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul><li><p><strong>不存在变量提升</strong>。</p></li><li><p><strong>存在块级作用域</strong>。</p></li><li><p><strong>同一作用域不允许重复声明变量</strong>。</p></li><li><p>声明一个只读的常量。一旦声明，<strong>常量的值就不能改变</strong>。const并不是变量的值不能改动，而是<strong>变量指向的内存地址所保存的数据不得改动</strong>。例如，在引用内容是对象的情况下，这意味着<strong>可以改变对象的内容</strong>。</p></li></ul><blockquote><p>全局中用<strong>let</strong>和<strong>const</strong>声明的变量存在<strong>Script</strong>上，用<strong>var</strong>声明的存在<strong>Global</strong>上（浏览器一般用<strong>Window</strong>表示）</p></blockquote><h3 id="变量提升和函数提升"><a href="#变量提升和函数提升" class="headerlink" title="变量提升和函数提升"></a>变量提升和函数提升</h3><ul><li><p><strong>所有的声明都会提升到作用域的最顶上去</strong>。</p></li><li><p>同一个变量只会<strong>声明一次</strong>，其他的会被忽略掉。</p></li><li><p><strong>函数声明的优先级高于变量声明的优先级</strong>，并且函数声明和函数定义的部分一起被提升。</p></li><li><p><strong>函数表达式声明的函数</strong>，相当于<strong>变量提升</strong>，如果使用<strong>const</strong>或<strong>let</strong>，则无法提升。</p></li></ul><h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><p>当函数中隐式声明一个变量时：</p><ul><li><p><strong>该变量和参数同名</strong>，该变量为<strong>局部变量</strong>。</p><p>函数传参相当于在内部声明了一个局部变量（<code>var param = param;</code>）</p><ul><li>实参如果是<strong>对象</strong>，就把该对象的<strong>地址</strong>赋给这个局部变量，可以通过地址<strong>修改外层对象的属性</strong>，但如果重新赋给该变量一个<strong>新的对象</strong>，不会覆盖外层对象</li><li>实参如果是<strong>原始类型</strong>就把值赋给该变量，<strong>修改该变量不会影响外层变量</strong>。</li></ul></li><li><p>函数<strong>没有参数</strong>，通过<strong>作用域链</strong>向外一直找到<strong>全局作用域</strong>，如果有该变量，说明该变量只是在其他地方进行了声明。</p></li><li><p>若没有找到，此时<strong>隐式声明了一个全局变量（window上）</strong>，且不会进行变量提升。</p></li></ul><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>早期JavaScript 程序本来很小，它们大多被用来执行独立的脚本任务，在你的 web 页面需要的地方提供一定交互，所以一般不需要多大的脚本。过了几年，我们现在有了运行大量 JavaScript 脚本的复杂程序，还有一些被用在其他环境（例如 <code>Node.js</code>）。</p><p>因此，近年来，有必要开始考虑提供一种<strong>将 JavaScript 程序拆分为可按需导入的单独模块的机制</strong>。</p><ul><li>避免命名冲突(减少命名空间污染)</li><li>更好的分离, 按需加载</li><li>更高复用性</li><li>高可维护性</li></ul><p>早期 全局函数 对象 IIFE(闭包) 缺点：引入多个<code>&lt;script&gt;</code>请求过多、依赖模糊、难以维护</p><p>通过<strong>模块化规范</strong>解决</p><p>CommonJS 服务端 同步</p><p>AMD 异步 开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</p><p>CMD与AMD规范很相似 依赖就近，延迟执行，可以很容易在Node.js中运行 依赖SPM 打包，模块的加载逻辑偏重。</p><p><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</strong>。</p><p>CommonJS 用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用<code>exports</code>），用<code>require</code>加载模块。</p><p>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</p><p>CommonJS 模块是运行时加载（对象），ES6 模块是编译时输出接口。</p><p>ES6模块化</p><p>export 导出<strong>函数</strong>，<code>var</code>，<code>let</code>，<code>const</code>, 和<strong>类</strong>。</p><p><code>import</code> <code>from</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;main.mjs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>模块自动使用严格模式和自动延迟加载。</p><p><code>export default</code></p><p><code>as</code></p><p><code>import * as Module</code> 创建模块对象</p><p><code>export &#123; name &#125; from &#39;x.mjs&#39;</code> 合并模块</p><p>动态加载模块 将<code>import()</code>作为函数调用，将其传递给模块的路径作为参数。 它返回一个 <code>promise</code>，它用一个<strong>模块对象</strong>来实现，让你可以访问该对象的导出。</p><h2 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h2><p>遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。</p><p>任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><p>Iterator 的作用有三个：</p><ul><li>一是为各种数据结构，提供一个统一的、简便的访问接口；</li><li>二是使得数据结构的成员能够按某种次序排列；</li><li>三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</li></ul><p>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p><p>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</p><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。</p><p>具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。</p><p>其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p><p>原生具备 Iterator 接口的数据结构如下。</p><ul><li><strong>Array</strong></li><li><strong>Map</strong></li><li><strong>Set</strong></li><li><strong>String</strong></li><li>TypedArray</li><li><strong>函数的 arguments 对象</strong></li><li>NodeList 对象</li></ul><p><strong>调用 Iterator 接口的场合：</strong></p><ul><li><p>对数组和 Set 结构进行<strong>解构赋值</strong>时，会默认调用<code>Symbol.iterator</code>方法。</p></li><li><p><strong>扩展运算符</strong>（…）也会调用默认的 Iterator 接口。</p></li></ul><p>实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...iterable];</span><br></pre></td></tr></table></figure><ul><li><p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p></li><li><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。</p><ul><li><p>for…of</p></li><li><p>Array.from()</p></li><li><p>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</p></li><li><p>Promise.all()</p></li><li><p>Promise.race()</p></li></ul></li></ul><h2 id="Set，WeakSet，Map和WeakMap"><a href="#Set，WeakSet，Map和WeakMap" class="headerlink" title="Set，WeakSet，Map和WeakMap"></a>Set，WeakSet，Map和WeakMap</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>值的集合（键和值相同，且唯一）</p><p><strong>方法</strong>：<code>add</code> <code>delete</code> <code>has</code>（布尔值） <code>clear</code> 属性：<code>size</code></p><p><strong>实现了iterator接口</strong></p><ul><li><p>可以使用<code>for…of…</code>进行遍历 <code>keys()</code>，<code>values()</code>(默认)，<code>entries()</code></p></li><li><p>遍历顺序就是<strong>插入顺序</strong></p></li><li><p><code>forEach</code>（键值、键名、集合本身），用于对每个成员执行某种操作，没有返回值</p></li><li><p>扩展运算符（<code>...</code>）</p></li><li><p>数组的<code>map</code>和<code>filter</code>方法也可以<strong>间接</strong>用于 Set 了 <code>new Set([...set].map(x =&gt; x * 2))</code></p></li></ul><p><strong>应用</strong></p><p><strong>去重</strong></p><p><code>Set</code>函数可以接受一个数组（或者具有 <code>iterable</code> 接口的其他数据结构）作为参数，用来初始化。</p><p>数组去重：<code>Array.from(new Set(array))</code>或<code>[...new Set(array)]</code></p><p>字符串去重：<code>[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)</code></p><p>set中所有<code>NaN</code>值都是相等的。</p><p><strong>交并差</strong></p><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>值只能是<strong>对象</strong></p><p><strong>弱引用：</strong>如果其他对象都不再引用该对象，那么<strong>垃圾回收机制会自动回收该对象所占用的内存</strong>，不考虑该对象还存在于 WeakSet 之中。</p><p>由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，所以<strong>不可遍历</strong> 。</p><p>方法：<code>add</code> <code>delete</code> <code>has</code></p><p>使用场景：<strong>储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏</strong>。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><strong>键值对</strong>的<strong>有序</strong>列表，而键和值都可以是<strong>任意类型</strong></p><p>方法：<code>set(key, value)</code>、<code>get(key)</code>（键对应的值）、<code>has(key)</code>（布尔值）、 <code>delete(key)</code>、 <code>clear</code> 属性：<code>size</code></p><p>遍历大致同Set，只是set的键值相同。Map初始化传入的应该至少是一个二维数组。<code>entries()</code>（默认，[键，值]）</p><p><strong>Object 和 map 的比较</strong></p><ul><li><p>map 只包含<strong>显式插入的键</strong>；Object <strong>原型链</strong>上的键名有可能和你自己在对象上的设置的键名产生冲突。</p></li><li><p>map 键可以是<strong>任意值</strong>；Object 的键必须是一个 <code>String</code> 或是<code>Symbol</code>,写数字<code>1</code>和字符串<code>&#39;1&#39;</code>效果一样,且需要<code>a[1]/a[&#39;1&#39;]</code>获取对应值，不可以<code>a.1/a.&#39;1&#39;</code></p></li><li><p>map 键 有序（插入）；Object 的键是<strong>无序</strong>的。自ECMAScript 2015规范以来，对象确实保留了字符串和Symbol键的创建顺序； 因此，在<strong>只有字符串键的对象</strong>上进行迭代将按插入顺序产生键。</p></li><li><p>键值对个数 map size；Object无。</p></li><li><p>map 可迭代； Object 需要以某种方式获得键。</p></li><li><p>map在<strong>频繁增删键值对</strong>的场景下表现更好。</p></li></ul><p><strong>对象和map互换</strong></p><ul><li>对象转为 Map 可以通过<code>Object.entries()</code>。 <code>new Map(Object.entries(obj))</code></li><li>map 转为对象。如果所有Map的键都是字符串，它可以无损地转为对象。<code>Object.create(null); obj[k] = v;</code></li></ul><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>键名只能<strong>对象</strong></p><p><strong>弱引用的只是键名</strong>，<strong>无法遍历</strong></p><p>方法：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code></p><p>应用：<strong>DOM 节点作为键名</strong>，防止内存泄漏；部署私有属性；<strong>深拷贝循环引用</strong></p><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>异步回调</p><p>setTimeout() &amp; setInterval() requestAnimationFrame()</p><p>Async/await</p><p>Promise</p><h2 id="事件循环机制⭐"><a href="#事件循环机制⭐" class="headerlink" title="事件循环机制⭐"></a>事件循环机制⭐</h2><blockquote><p>事件循环负责收集事件（包括用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。然后它执行所有处于等待中的 JavaScript 任务（宏任务），然后是微任务，然后在开始下一次循环之前执行一些必要的渲染和绘制操作。</p></blockquote><p>任务的执行模式</p><ul><li><p>同步：连续性、阻塞</p></li><li><p>异步</p><ul><li>宏任务（Macrotask，Task，宿主（浏览器、Node）发起）：script（整体代码块）、setTimeout、setInterval</li><li>微任务（Microtask，Jobs， JS 自身发起）：Promise.[ then/catch/finally ]、queueMicrotask</li></ul></li></ul><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bt7ZTO"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/bt7ZTO.png" alt="bt7ZTO.png"></a></p><ol><li>判断宏任务队列是否为空<ul><li>不空 –&gt; 执行最早进入队列的任务 –&gt; 执行下一步</li><li>空 –&gt; 执行下一步</li></ul></li><li>判断微任务队列是否为空<ul><li>不空 –&gt; 执行最早进入队列的任务 –&gt; <strong>继续检查微任务队列空不空</strong></li><li>空 –&gt; 执行下一步</li></ul></li></ol><p><strong>如何理解 script（整体代码块）是个宏任务呢</strong></p><p>script标签在设置defer和async属性可以异步执行，可以看作是一个异步任务。</p><p>同时存在两个 script 代码块，会首先在执行<strong>第一个 script 代码块中的同步代码</strong>，如果这个过程中创建了微任务并进入了微任务队列，第一个 script 同步代码执行完之后，会首先去<strong>清空微任务队列</strong>，再去开启<strong>第二个 script 代码块</strong>的执行。所以这里应该就可以理解 script（整体代码块）为什么会是宏任务。</p><p>首次执行<strong>宏队列中会有 script（整体代码块）任务</strong>，所以实际上就是 Js 解析完成后，在异步任务中，会<strong>先执行完所有的微任务</strong>。需要注意的是，<strong>新创建的微任务会立即进入微任务队列排队执行，不需要等待下一次轮回</strong>。</p><p>所谓任务，浅显来说就是<strong>代码块开始执行的入口</strong>(确切地说，是函数栈的入口，但是栈的概念较为复杂，不表)。</p><p>而在 <code>JS</code> 里，除了“<code>script</code>整体代码块”之外，<strong>所有代码块的入口都是“回调函数”</strong>，回调函数被注册到事件后不会马上被执行，而是保存在一个神秘的的地方，保存起来待执行的才能算“任务”，然后才有宏/微任务之分。</p><p>“<code>script</code>整体代码块”的特殊之处，在于<strong>它的入口不是回调函数</strong>，但是我们可以想象它被装在一个隐形的函数里，作为回调函数被注册到某个事件里（大概是它解析完成之后会触发的一个事件），这时候这个隐形的函数就成为了一个任务。</p><p>浏览器<code>UI</code>是多线程的，异步任务借助浏览器的线程和<code>JavaScript</code>的执行机制实现。</p><p><strong>queueMicrotask</strong></p><p><strong>可以安全的引入微任务而避免使用额外的技巧</strong>。由晦涩地使用 promise 去创建微任务而带来的风险就可以被避免了。举例来说，当使用 promise 创建微任务时，由回调抛出的异常被报告为 rejected promises 而不是标准异常。同时，创建和销毁 promise 带来了事件和内存方面的额外开销，这是正确入列微任务的函数应该避免的。</p><h2 id="展开语法、剩余参数"><a href="#展开语法、剩余参数" class="headerlink" title="展开语法、剩余参数"></a>展开语法、剩余参数</h2><ul><li><p><strong>展开语法</strong>（扩展运算符<code>...</code>）是将<strong>数组</strong>或者<strong>可迭代对象</strong>拆分成逗号分隔的参数序列。</p></li><li><p><strong>剩余参数</strong>语法允许我们将一个不定数量的参数表示为一个数组。</p></li><li><p>剩余语法(Rest syntax) 看起来和展开语法完全相同，不同点在于, 剩余参数用于解构数组和对象。从某种意义上说，剩余语法与展开语法是相反的：展开语法将数组展开为其中的各个元素，而剩余语法则是将多个元素收集起来并“凝聚”为单个元素。</p></li></ul><h1 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h1><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p><strong>递归</strong>的思路去实现一个深拷贝方法。WeakMap解决<strong>循环引用</strong>。</p><p>假设我们使用的 Map，那么 <code>foo</code> 对象和我们深拷贝内部的 <code>const map = new Map()</code> 创建的 <code>map</code> 对象一直都是强引用关系，那么在程序结束之前，<code>foo</code> 不会被回收，其占用的内存空间一直不会被释放。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝简易版本</span></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function"><span class="params">source</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 WeakMap 对象，记录已拷贝过的对象</span></span><br><span class="line">    <span class="keyword">const</span> weakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">    <span class="comment">//拷贝（递归）</span></span><br><span class="line">    <span class="keyword">const</span> copy = <span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 当输入为函数或基本数据类型时，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">&#x27;function&#x27;</span> || !isObject(input)) <span class="keyword">return</span> input;</span><br><span class="line">        <span class="comment">// 针对已拷贝过的对象，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (weakmap.has(input)) &#123;</span><br><span class="line">            <span class="keyword">return</span> weakmap.get(input)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是数组(toString.call)还是对象(typeof 注意null)</span></span><br><span class="line">        <span class="keyword">const</span> output = isArray(input) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="comment">// 记录每次拷贝的对象(需要放在递归引用的前面)</span></span><br><span class="line">        weakmap.set(input, output);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> input) &#123;</span><br><span class="line">            <span class="comment">// 如果key是对象的自有属性</span></span><br><span class="line">            <span class="keyword">if</span> (input.hasOwnProperty(key)) &#123;</span><br><span class="line">                <span class="comment">// 递归调用深拷贝方法</span></span><br><span class="line">                output[key] = copy(input[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new⭐"><a href="#new⭐" class="headerlink" title="new⭐"></a>new⭐</h2><p>new 的原理很简单, 就是引擎内部新建一个空对象，然后将这个空对象的<code>__proto__</code> 指向构造函数的<code>prototype</code>.然后调用构造函数，去填充我们创建的空对象(如果有必要)。 最后将<code>this</code>指向我们刚刚创建的新对象。</p><p><strong>new 运算符</strong>创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。<strong>new</strong> 关键字会进行如下的操作：</p><ol><li>创建一个空的简单JavaScript对象（即<code>&#123;&#125;</code>）；</li><li>将该对象的<code>__proto__</code>指向构造函数原型；</li><li>将步骤1新创建的对象作为<code>this</code>的上下文 ；</li><li>如果<strong>该函数没有返回对象</strong>，则返回<code>this</code>（新创建的对象）。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化后 new 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1、通过call，this指向了arguments(封装实参的对象)，shift删除并获得arguments中第一个参数——构造函数</span></span><br><span class="line">  Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 2、创建一个空的对象并将该对象的__proto__指向构造函数原型</span></span><br><span class="line">  <span class="comment">// obj.__proto__ 影响性能，不建议用</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(Con.prototype);</span><br><span class="line">  <span class="comment">// 3、绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">  <span class="keyword">let</span> ret = Con.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 4、优先返回构造函数返回的对象</span></span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>shift/unshift</code> 方法并不局限于数组：这个方法能够通过 <code>call()</code> 或 <code>apply()</code>方法作用于类似数组的对象上。</p><h2 id="call、apply、bind区别"><a href="#call、apply、bind区别" class="headerlink" title="call、apply、bind区别"></a>call、apply、bind区别</h2><ul><li>三者都可以改变函数的<code>this</code>对象指向</li><li>三者第一个参数都是<code>this</code>要指向的对象，如果如果没有这个参数或参数为<code>undefined</code>或<code>null</code>，则默认指向全局<code>window</code></li><li>三者都可以传参，但是<code>apply</code>是数组，而<code>call</code>是参数列表，且<code>apply</code>和<code>call</code>是一次性传入参数，而<code>bind</code>可以分为多次传入</li><li><code>bind</code>是返回绑定this之后的函数，<code>apply</code>、<code>call</code> 则是立即执行</li></ul><h3 id="模拟实现-call"><a href="#模拟实现-call" class="headerlink" title="模拟实现 call"></a>模拟实现 call</h3><ul><li><strong>将函数设置为绑定对象的属性</strong></li><li>执行函数</li><li>删除对象的这个属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.newCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：非严格模式下, </span></span><br><span class="line">    <span class="comment">// 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中就是 window 对象)</span></span><br><span class="line">    <span class="comment">// 值为原始值(数字，字符串，布尔值)的 this 会指向该原始值的自动包装对象(用 Object() 转换）</span></span><br><span class="line">    context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>; </span><br><span class="line">    <span class="comment">// 将函数设为对象的属性</span></span><br><span class="line">    <span class="comment">// newCall由函数调用，此时的this指向函数，是一种隐式绑定</span></span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 执行该函数</span></span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> result = context.fn(...args);</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 删除该函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="comment">// 注意：函数是可以有返回值的</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="防抖-节流"><a href="#防抖-节流" class="headerlink" title="防抖/节流"></a>防抖/节流</h2><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><ol><li><code>instanceof</code> 判断<strong>对象的原型链上是否存在构造函数的原型</strong>。只能判断引用类型。</li><li><code>instanceof</code> 常用来判断 <code>A</code> 是否为 <code>B</code> 的实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instanceof 的内部实现 </span></span><br><span class="line"><span class="keyword">const</span> instance_of = <span class="function">(<span class="params">Case,Constructor</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 基本数据类型返回false</span></span><br><span class="line">    <span class="comment">// 兼容一下函数对象</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">typeof</span>(Case) !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span>(Case) !== <span class="string">&#x27;function&#x27;</span>) || Case === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> CaseProto = <span class="built_in">Object</span>.getPrototypeOf(Case);<span class="comment">//返回指定对象的原型</span></span><br><span class="line">    <span class="comment">// let CaseProto = Case.__proto__;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 查到原型链顶端，仍未查到，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (CaseProto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 找到相同的原型</span></span><br><span class="line">        <span class="keyword">if</span> (CaseProto === Constructor.prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// CaseProto = CaseProto.__proto__;</span></span><br><span class="line">        CaseProto = <span class="built_in">Object</span>.getPrototypeOf(CaseProto);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。</p><p>继承的本质就是<strong>复制，即重写原型对象，代之以一个新类型的实例</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c0107fd80c7~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>原型链方案存在的缺点：多个实例对引用类型的操作会被篡改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(); </span><br><span class="line">alert(instance2.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>使用父类的构造函数来增强子类<strong>实例</strong>，等同于复制父类的实例给子类（不使用原型）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color=[<span class="string">&quot;red&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;blue&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承自SuperType</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.color.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">alert(instance1.color);<span class="comment">//&quot;red,green,blue,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.color);<span class="comment">//&quot;red,green,blue&quot;</span></span><br></pre></td></tr></table></figure><p>核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用<code>SuperType</code>构造函数，于是<code>SubType</code>的每个实例都会将<code>SuperType</code>中的属性复制一份。</p><p>缺点：</p><ul><li>只能继承父类的<strong>实例</strong>属性和方法，不能继承<strong>原型</strong>属性/方法</li><li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li></ul><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合上述两种方法就是组合继承。用原型链实现对<strong>原型</strong>属性和方法的继承，用借用构造函数技术来实现<strong>实例</strong>属性的继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="comment">// 第二次调用SuperType()</span></span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="comment">// 构建原型链</span></span><br><span class="line"><span class="comment">// 第一次调用SuperType()</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line"><span class="comment">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span></span><br><span class="line">SubType.prototype.constructor = SubType; </span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line">instance1.sayName(); <span class="comment">//&quot;Nicholas&quot;;</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//&quot;red,blue,green&quot;</span></span><br><span class="line">instance2.sayName(); <span class="comment">//&quot;Greg&quot;;</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性<code>name</code>，<code>color</code>。</li><li>第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性<code>name</code>，<code>color</code>。</li></ul><p>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象<code>SubType.prototype</code>的两个同名属性。所以，组合模式的缺点就是在<strong>使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</strong></p><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>利用一个<strong>空对象</strong>作为中介，将<strong>某个对象直接赋值给空对象构造函数的原型</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>object()对传入其中的对象执行了一次<code>浅复制</code>，<strong>将构造函数F的原型直接指向传入的对象</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">&quot;Rob&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">&quot;Linda&quot;</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">&quot;Barbie&quot;</span>);</span><br><span class="line"></span><br><span class="line">alert(person.friends);   <span class="comment">//&quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul><p>另外，ES5中存在<code>Object.create()</code>的方法，能够代替上面的object方法。</p><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>核心：在原型式继承的基础上，增强对象，返回构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(original); <span class="comment">// 通过调用 object() 函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 以某种方式来增强对象</span></span><br><span class="line">    alert(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的主要作用是为构造函数新增属性和方法，以<strong>增强函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">//&quot;hi&quot;</span></span><br></pre></td></tr></table></figure><p>缺点（同原型式继承）：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>结合借用构造函数传递参数和寄生模式实现继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(superType.prototype); <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">  prototype.constructor = subType;                    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">  subType.prototype = prototype;                      <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类初始化实例属性和原型属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将父类原型指向子类</span></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类原型属性</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;xyc&quot;</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;lxy&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">instance1.colors.push(<span class="string">&quot;2&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]</span></span><br><span class="line">instance1.colors.push(<span class="string">&quot;3&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;]</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c0109df5438~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code> 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code> 和<code>isPrototypeOf()</code></p><p><strong>这是最成熟的方法，也是现在库实现的方法</strong>。</p><h3 id="混入方式继承多个对象"><a href="#混入方式继承多个对象" class="headerlink" title="混入方式继承多个对象"></a>混入方式继承多个对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     SuperClass.call(<span class="built_in">this</span>);</span><br><span class="line">     OtherSuperClass.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承一个类</span></span><br><span class="line">MyClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line"><span class="comment">// 混合其它</span></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype);</span><br><span class="line"><span class="comment">// 重新指定constructor</span></span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Object.assign</code>会把 <code>OtherSuperClass</code>原型上的函数拷贝到 <code>MyClass</code>原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。</p><h3 id="ES6类继承extends"><a href="#ES6类继承extends" class="headerlink" title="ES6类继承extends"></a>ES6类继承extends</h3><p><code>extends</code>关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中<code>constructor</code>表示构造函数，一个类中只能有一个构造函数，有多个会报出<code>SyntaxError</code>错误,如果没有显式指定构造方法，则会添加默认的 <code>constructor</code>方法，使用例子如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getter</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.calcArea()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Method</span></span><br><span class="line">    <span class="function"><span class="title">calcArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rectangle.area);</span><br><span class="line"><span class="comment">// 输出 200</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(length, length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Square&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> Square(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(square.area);</span><br><span class="line"><span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure><p><code>extends</code>继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">    <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">    subType.prototype = <span class="built_in">Object</span>.create(superType &amp;&amp; superType.prototype, &#123;</span><br><span class="line">        <span class="attr">constructor</span>: &#123;</span><br><span class="line">            <span class="attr">value</span>: subType,</span><br><span class="line">            <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (superType) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.setPrototypeOf </span><br><span class="line">            ? <span class="built_in">Object</span>.setPrototypeOf(subType, superType) </span><br><span class="line">            : subType.__proto__ = superType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h2 id="如何实现数组扁平化"><a href="#如何实现数组扁平化" class="headerlink" title="如何实现数组扁平化"></a>如何实现数组扁平化</h2><p>数组扁平化就是把多维数组转化成一维数组。</p><h3 id="ES6提供的新方法-flat-depth"><a href="#ES6提供的新方法-flat-depth" class="headerlink" title="ES6提供的新方法 flat(depth)"></a>ES6提供的新方法 flat(depth)</h3><p>不会改变原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,[<span class="number">5</span>]]]];  </span><br><span class="line">a.flat(<span class="number">4</span>-<span class="number">1</span>); <span class="comment">// [1,2,3,4,5]  a是4维数组</span></span><br><span class="line">a.flat(<span class="literal">Infinity</span>); <span class="comment">// [1,2,3,4,5]  a是4维数组</span></span><br></pre></td></tr></table></figure><h3 id="reduce方法-递归"><a href="#reduce方法-递归" class="headerlink" title="reduce方法 递归"></a>reduce方法 递归</h3><p>这里使用的是数组的reduce方法，需要注意的是reduce方法，我们传递了两个参数，<br>第一个参数就是就是处理扁平化的箭头函数<br>第二个参数是一个空数组，也是作为遍历的开始。（res）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flatten = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">res,next</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res.concat(<span class="built_in">Array</span>.isArray(next)?flatten(next):next);</span><br><span class="line"></span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平铺数组转树形结构"><a href="#平铺数组转树形结构" class="headerlink" title="平铺数组转树形结构"></a>平铺数组转树形结构</h2><h2 id="随机打乱数组shuffle"><a href="#随机打乱数组shuffle" class="headerlink" title="随机打乱数组shuffle"></a>随机打乱数组shuffle</h2><p>Fisher–Yates shuffle 洗牌算法可以做到理论上的完全乱序</p><p>lodash.js 中的 shuffle 函数也使用此算法实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shuffle = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> point =arr.length-<span class="number">1</span>;point&gt;=<span class="number">0</span>;point--)&#123;</span><br><span class="line">        index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*point);</span><br><span class="line">        [arr[index],arr[point]]=[arr[point],arr[index]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">arr1= shuffle(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br></pre></td></tr></table></figure><h1 id="计算机网络和浏览器"><a href="#计算机网络和浏览器" class="headerlink" title="计算机网络和浏览器"></a>计算机网络和浏览器</h1><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><strong>TCP/IP</strong>体系结构相当于将<strong>OSI</strong>体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p><p>教学时经常把TCP/IP体系结构的<strong>网络接口层</strong>分成了<strong>物理层</strong>和<strong>数据链路层</strong>。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/q8fbgs"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/24/q8fbgs.png" alt="q8fbgs.png"></a></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong> 只需要专注于为用户提供应用功能，不用去关心数据是如何传输的。</p><p>协议：DNS、HTTP等</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p><strong>负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。</p><p><strong>运输层主要使用以下两种协议：</strong></p><ol><li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p><strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong></p><p>IP协议</p><ul><li><strong>寻址</strong>：告诉我们去往下一个目的地该朝哪个方向走。配合<strong>子网掩码</strong>才能算出IP地址的<strong>网络号</strong>和<strong>主机号</strong>。在寻址的过程中，先匹配到相同的网络号，才会去找对应的主机。</li><li><strong>路由</strong>：是根据「下一个目的地」选择路径。</li></ul><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><ul><li>通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）</li><li>主要为网络层提供链路级别传输的服务</li><li><strong>作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）</strong></li></ul><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><ul><li><p><strong>实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong>。</p></li><li><p>当数据准备要从设备发送到网络时，需要把数据包转换成光/电信号，让其可以在物理介质中传输，</p></li><li><p>它主要是为数据链路层提供二进制传输的职务。</p></li></ul><h3 id="为什么网络要分层？"><a href="#为什么网络要分层？" class="headerlink" title="为什么网络要分层？"></a>为什么网络要分层？</h3><ul><li><strong>各层之间相互独立</strong></li><li><strong>提高了整体灵活性</strong> 高内聚，低耦合</li><li><strong>大问题化小</strong></li></ul><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><ul><li>两台电脑可以通过一根<strong>网线</strong>直接连接，进行通信。</li><li>机器一多，可以把网线都接到<strong>集线器</strong>（<strong>物理层</strong>）上，但是集线器会不管三七二十一进行<strong>广播</strong>。</li><li>不想广播，可以用（二层）<strong>交换机</strong>（<strong>数据链路层</strong>），又叫多端口网桥，它比较聪明，会自我学习生产<strong>MAC地址表</strong>，知道消息发到哪，那就<strong>不需要广播</strong>啦。</li><li><strong>互联网</strong>电脑这么多，交换机MAC地址表总不能全放下吧。改用<strong>路由器</strong>（<strong>网络层</strong>），也叫<strong>三层交换机</strong>，通过网段的方式定位要把消息转发到哪，就不需要像交换机那样苦哈哈一条条记录MAC地址啦（具有<strong>MAC地址</strong>和<strong>IP地址</strong>）。</li><li>路由器和光猫之间是好搭档，<strong>光猫</strong>负责把光纤里的光信号转换成电信号给路由器。</li><li>现在一般情况下，家里已经不用集线器和交换机了，<strong>大部分路由器也支持交换机的功能</strong>。所以可以看到，家里的台式机电脑一般就连到一个路由器，再连个光猫就够能快乐上网了。</li></ul><h2 id="HTTP⭐"><a href="#HTTP⭐" class="headerlink" title="HTTP⭐"></a>HTTP⭐</h2><p>HTTP：<strong>超文本传输协议</strong>。</p><p><strong>HTTP是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><p><strong>请求报文包括：</strong></p><ul><li><strong>请求行</strong>：包括<strong>请求方法</strong>、<strong>请求的URL</strong>、<strong>HTTP协议及版本</strong>。</li><li><strong>请求头</strong>：一大堆的键值对。</li><li><strong>空行</strong>指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。</li><li><strong>请求体</strong>：数据部分。</li></ul><p>响应报文包括：</p><ul><li><strong>状态行</strong>：<strong>HTTP协议及版本</strong>、<strong>状态码</strong>及<strong>状态描述</strong>。</li><li><strong>响应头</strong></li><li><strong>空行</strong></li><li><strong>响应体</strong></li></ul><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p><strong>1xx</strong>类状态码属于<strong>提示信息</strong>，是协议处理中的一种<strong>中间状态</strong>，实际用到的比较少。</p><p><strong>2xx</strong>类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li><strong>200 OK</strong> 是最常见的成功状态码，表示一切正常。</li></ul><p><strong>3xx</strong>类状态码表示客户端请求的资源发送了变动，需要客户端用新的URL重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li><p><strong>301 Moved Permanently</strong> 表示<strong>永久重定向</strong>，说明请求的资源已经不存在了，需改用新的URL再次访问。</p></li><li><p><strong>302 Found</strong> 表示<strong>临时重定向</strong>，说明请求的资源还在，但暂时需要用另一个URL来访问。</p><ul><li><strong>301</strong>和<strong>302</strong>都会在响应头里使用字段<strong>Location</strong>，指明后续要跳转的URL，浏览器会自动重定向新的URL。</li></ul></li><li><p><strong>304 Not Modified</strong> 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称<strong>缓存重定向</strong>，用于缓存控制。</p></li></ul><p><strong>4xx</strong>类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是<strong>错误码</strong>的含义。</p><ul><li><strong>400 Bad Request</strong> 表示客户端请求的报文有错误，但只是个笼统的错误</li><li><strong>403 Forbidden</strong> 表示<strong>服务器禁止访问资源</strong>，并不是客户端的请求出错。</li><li><strong>404 Not Found</strong> 表<strong>示请求的资源在服务器上不存在或未找到</strong>，所以无法提供给客户端。</li></ul><p><strong>5xx</strong>类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于<strong>服务器端的错误码</strong>。</p><p>项目静态网页状态码 <code>404 &amp; 405</code></p><p><strong>405 Method Not Allowed</strong>表明服务器禁止了使用当前 HTTP 方法的请求。绝大多数web服务器，都不允许静态文件响应POST请求。原项目使用正向代理发送跨域请求，所以静态网页没有完成代理转发。</p><h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><p><strong>根据场景合理使用各个方法，可以起到优化性能、增加网络安全的效果。</strong></p><h4 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h4><p><code>GET</code>方法的含义是<strong>请求从服务器获取资源</strong>，这个资源可以是静态的文本、页面、图片视频等。</p><p>而<code>POST</code>方法则是相反操作，它向<code>URI</code>指定的资源提交数据，数据就放在报文的<code>body</code>里。</p><h5 id="参数传递方式"><a href="#参数传递方式" class="headerlink" title="参数传递方式"></a>参数传递方式</h5><ul><li>GET 的参数一般是通过 <code>?</code> 跟在 URL 后面的，多个参数通过 <code>&amp;</code> 连接</li><li>POST 的参数一般是包含在 <code>request body</code> 中的</li></ul><h5 id="参数长度限制不同"><a href="#参数长度限制不同" class="headerlink" title="参数长度限制不同"></a>参数长度限制不同</h5><p>GET 和 POST 传递参数的长度不同：</p><ul><li>get传送的数据量较小，不能大于2KB。</li><li>post传送的数据量较大，一般被默认为不受限制。</li></ul><p>在这里我们要明确一点：<strong>HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。</strong></p><p>服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。</p><h5 id="安全和幂等"><a href="#安全和幂等" class="headerlink" title="安全和幂等"></a>安全和幂等</h5><ul><li>在HTTP 协议里，<strong>所谓的「安全」是指请求方法不会「破坏」服务器上的资源</strong>。</li><li><strong>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</strong></li></ul><p>那么很明显<strong>GET方法就是安全且幂等</strong>的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</p><p><strong>POST</strong>因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以不<strong>是幂等</strong>的。</p><h5 id="安全性不同（传输的角度）"><a href="#安全性不同（传输的角度）" class="headerlink" title="安全性不同（传输的角度）"></a>安全性不同（传输的角度）</h5><p>因为参数传递方式的不同，所以 GET 和 POST 的安全性不同：GET 比 POST 更不安全，因为参数直接暴露在URL上，所以 GET 不能用来传递敏感信息。</p><blockquote><p>从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文，要想安全传输，就只有加密，也就是 HTTPS。</p></blockquote><h5 id="缓存机制不同"><a href="#缓存机制不同" class="headerlink" title="缓存机制不同"></a>缓存机制不同</h5><p>这个需要从以下几点来说明：</p><ul><li>GET 请求会<strong>被浏览器主动cache</strong>，而 POST 不会，除非手动设置。</li><li>GET 请求参数<strong>会被完整保留在浏览器历史记录里</strong>，而 POST 中的参数不会被保留。</li><li>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。</li><li>GET 在<strong>浏览器回退时是无害的</strong>，而 POST 会再次提交请求。</li></ul><h5 id="时间消耗不同"><a href="#时间消耗不同" class="headerlink" title="时间消耗不同"></a>时间消耗不同</h5><p>GET 和 POST 请求时间的不同主要是因为：</p><ul><li>GET 产生<strong>一个</strong> TCP 数据包；</li><li>POST 产生<strong>两个</strong> TCP 数据包。</li></ul><p>对于 GET 方式的请求，浏览器会把 <strong>header 和 data</strong> 一并发送出去，服务器响应 200（返回数据）；而对于 POST，浏览器先发送 <strong>header</strong>，服务器响应 <strong>100 continue</strong>，浏览器再发送 <strong>data</strong>，服务器响应 200 ok（返回数据）。</p><p>在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将不传回资源的本文部分，只返回<strong>头部消息</strong>。</p><p>HEAD 方法的使用场景</p><ul><li>在不获取资源的情况下，了解资源的一些信息，比如资源类型；</li><li>通过查看响应中的状态码，可以确定资源是否存在；</li><li>通过查看首部，测试资源是否被修改。</li></ul><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>PUT 方法用于将数据发送到服务器来创建/更新资源。</p><p>PUT 与 POST 方法的区别在于，<strong>PUT 方法是幂等的</strong>：<strong>调用一次与连续调用多次是等价的（即没有副作用）</strong>。</p><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>DELETE 方法就是请求服务器删除指定 URL 所对应的资源。</p><h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><blockquote><p>浏览器缓存(Brower Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力。</p><p>http缓存机制主要在<strong>http响应头</strong>中设定，响应头中相关字段为<code>Expires</code>、<code>Cache-Control</code>、<code>Last-Modified</code>、<code>Etag</code>。</p></blockquote><h4 id="基本流程（强缓存、协商缓存）"><a href="#基本流程（强缓存、协商缓存）" class="headerlink" title="基本流程（强缓存、协商缓存）"></a>基本流程（强缓存、协商缓存）</h4><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/qZJSgJ"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/20/qZJSgJ.png" alt="qZJSgJ.png"></a></p><p>在第一次请求时，没有缓存，直接向服务器发送请求，服务器会将页面<strong>最后修改时间</strong>通过<code>Last-Modified</code>标识由服务器发送给客户端，客户端记录修改时间；服务器还会生成一个<code>Etag</code>，并发送给客户端。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/qZJpv9"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/20/qZJpv9.png" alt="qZJpv9.png"></a></p><p>第二次浏览器请求某一资源时：</p><ul><li>强缓存 <code>Cache-Control</code>（max-age,优先级高）、<code>Expires</code>(GMT）=&gt; 判断<strong>是否过期</strong></li></ul><p>​ <strong>没过期则直接从缓存中获取资源信息</strong>，<strong>不会与服务器进行通信</strong>。</p><ul><li><p>协商缓存 <strong>由服务器来确定缓存资源是否可用</strong></p><ul><li><p>客户端：<code>If-None-Match</code>头将先前服务器端发送过来的<code>Etag</code>发送给服务器；</p><p>服务会对比这个客户端发过来的<code>Etag</code>是否与服务器的相同。</p><ul><li>若<strong>相同</strong>，返回状态<code>304</code>，客户端<strong>继续使用本地缓存</strong>。</li><li>若<strong>不相同</strong>，返回状态为<code>200</code>，客户端重新解析服务器端返回的数据。</li></ul></li></ul><ul><li>如果没有<code>Etag</code>，客户端还会通过<code>If-Modified-Since</code>头将先前服务器端发过来的<strong>最后修改时间戳</strong>发送给服务器<ul><li>如果不是最新的，则返回最新的内容，<code>200</code>。</li><li>如果是最新的，则返回<code>304</code>，客户端继续使用本地缓存。</li></ul></li></ul></li></ul><h4 id="缓存发展历程"><a href="#缓存发展历程" class="headerlink" title="缓存发展历程"></a>缓存发展历程</h4><p>强缓存有缺点，比如说，设置了<code>expires</code>，<code>GMT</code>格式，但是浏览器的时间可以改变，因此就通过<code>cache-control</code>返回一个<strong>相对时间</strong>来。但是假如说<strong>资源并没有更新</strong>，但是强缓存时间过期了，那就需要重新拉去资源，因此就有了<code>Last-Modify</code>，但是last-modified的时间单位是<code>s</code>，当1s内有资源修改，那浏览器返回的最后修改时间和上次的修改时间相同，那就不会重新拉取资源，因此推出了<code>Etag</code>，通过比对资源内容来判断是否修改。</p><h4 id="为什么要有Etag"><a href="#为什么要有Etag" class="headerlink" title="为什么要有Etag"></a>为什么要有Etag</h4><p>HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p><ul><li>一些文件也许会周期性的更改，但是他的**内容并不改变(仅仅改变的修改时间)**，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</li><li>某些文件<strong>修改非常频繁</strong>，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是<code>s</code>级的；</li><li>某些服务器<strong>不能精确的得到文件的最后修改时间</strong>。</li></ul><p>Last-Modified与ETag是可以一起使用的，<strong>服务器会优先验证ETag</strong>。</p><h4 id="不同刷新的请求执行过程"><a href="#不同刷新的请求执行过程" class="headerlink" title="不同刷新的请求执行过程"></a>不同刷新的请求执行过程</h4><ul><li><p><strong>浏览器地址栏中写入URL，回车 / 普通刷新F5</strong></p><p>不同浏览器和不同类型资源缓存方式不同，个人理解：</p><ul><li>返回200，并显示从缓存中获取，则为强缓存（虽然没有发出真实的 http 请求）。</li><li>返回304，说明是协商缓存命中走<strong>缓存</strong>。</li></ul></li><li><p><strong>强制刷新Ctrl+F5</strong> 删除缓存，重新请求。</p></li></ul><h3 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p><strong>简单<code>header（key-value） + body</code>、灵活和易于扩展（应用层(OSI第七层)，下层可随意变化）、应用广泛和跨平台</strong>。</p><h4 id="双刃剑"><a href="#双刃剑" class="headerlink" title="双刃剑"></a>双刃剑</h4><p>无状态</p><ul><li>不需要额外的资源来记录状态信息</li><li>完成有关联性的操作时会非常麻烦</li></ul><p>明文传输</p><ul><li>调试工作带了极大的便利性</li><li>毫无隐私可言，很容易就能被窃取</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>HTTP比较严重的缺点就是不安全:</p><ul><li>**通信使用明文（不加密)**，内容可能会被窃听。</li><li><strong>不验证通信方的身份</strong>，因此有可能遭遇伪装。</li><li><strong>无法证明报文的完整性</strong>，所以有可能已遭篡改。</li></ul><p>HTTP的安全问题，可以用<strong>HTTPS</strong>的方式解决，也就是通过引入<strong>SSL/TLS</strong>层，使得在安全上达到了极致。</p><h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>HTTP是<strong>超文本传输协议</strong>，信息是<strong>明文传输</strong>，存在安全风险的问题。HTTPS则解决HTTP不安全的缺陷，<strong>在TCP和HTTP之间加入了SSL/TLS安全协议</strong>，使得报文能够<strong>加密</strong>传输。</li><li>HTTP 连接建立相对简单，<strong>TCP三次握手</strong>之后便可进行HTTP的报文传输。而 HTTPS在<strong>TCP三次握手</strong>之后，还需进行<strong>SSL/TLS的握手</strong>过程，才可进入加密报文传输。</li><li>HTTP的端口号是<strong>80</strong>，HTTPS的端口号是<strong>443</strong>。</li><li>HTTPS 协议需要<strong>向CA(证书权威机构）申请数字证书</strong>，来保证服务器的身份是可信的。</li></ul><blockquote><p>SSL和TLS？</p></blockquote><p>这两实际上是一个东西。很多相关的文章都把这两者并列称呼(SSL/TLS)，因为这两者可以视作<strong>同一个东西的不同阶段</strong>。</p><h4 id="HTTPS优点"><a href="#HTTPS优点" class="headerlink" title="HTTPS优点"></a>HTTPS优点</h4><h5 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h5><p>通过<strong>混合加密</strong>的方式可以保证信息的<strong>机密性</strong>，解决了窃听的风险。</p><p>HTTPS采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的<strong>混合加密</strong>方式:</p><ul><li>在<strong>通信建立前</strong>采用<strong>非对称加密</strong>的方式<strong>交换</strong>「会话秘钥」，后续就不再使用非对称加密。</li><li>在<strong>通信过程中</strong>全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul><p>采用「混合加密」的方式的原因:</p><blockquote><p>对称加密：加密和解密使用的是同一个密钥。</p><p>RSA（非对称加密算法）：双方必须协商一对密钥，一个私钥一个公钥。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。</p></blockquote><p>对称加密运算速度快，但最开始仍可能被拦截，发送信息依然不安全，非对称加密足够安全，但运算速度慢。</p><p><strong>使用非对称加密的方法将加密算法的对称密钥发送过去</strong>，之后就可以使用使用这个密钥，利用<strong>对称密钥</strong>来通信了。</p><h5 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h5><p><strong>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</strong></p><p>这就存在些问题，<strong>如何保证公钥不被篡改和信任度?</strong></p><p>所以这里就需要借助第三方权威机构<code>CA</code>(数字证书认证机构)﹐将<strong>服务器公钥放在数字证书</strong>（由数字证书认证机构颁发)中，只要证书是可信的，公钥就是可信的。</p><p>通过数字证书的方式保证服务器公钥的身份，解决<strong>冒充</strong>的风险。</p><h5 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h5><p><strong>摘要算法</strong>用来实现<strong>完整性</strong>，能够为数据生成独一无二的<strong>指纹</strong>﹐用于校验数据的完整性，解决了<strong>篡改</strong>的风险。</p><p>客户端在发送明文之前会通过<strong>摘要算法</strong>算出明文的<strong>指纹</strong>，发送的时候把<strong>指纹＋明文</strong>一同加密成密文后，发送给服务器，服务器解密后，用<strong>相同的摘要算法</strong>算出发送过来的明文，通过比较客户端携带的<strong>指纹</strong>和当前算出的<strong>指纹</strong>做比较，若<strong>指纹</strong>相同，说明数据是完整的。</p><h4 id="HTTPS连接"><a href="#HTTPS连接" class="headerlink" title="HTTPS连接"></a>HTTPS连接</h4><p>SSL/TLS协议基本流程∶</p><ul><li><strong>客户端向服务器索要并验证服务器的公钥</strong>。</li><li>双方协商生产<strong>会话秘钥</strong>。</li><li>双方采用<strong>会话秘钥</strong>进行加密通信。</li></ul><p>前两步也就是SSL/TLS的建立过程，也就是握手阶段。</p><p>整个SSL/TLS的握手阶段全部结束后，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用<strong>会话秘钥加密内容。</strong></p><p>SSL/TLS 1.2需要4次握手，SSL/TLS 1.3优化了过程，<strong>只需要3次握手</strong>。</p><h3 id="HTTP-1-1、HTTP-2、HTTP-3演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3演变" class="headerlink" title="HTTP/1.1、HTTP/2、HTTP/3演变"></a>HTTP/1.1、HTTP/2、HTTP/3演变</h3><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><p>HTTP/1.1相比HTTP/1.0性能上的改进︰</p><ul><li>使用TCP<strong>长连接</strong>的方式改善了<strong>HTTP/1.0短连接</strong>造成的性能开销。<ul><li><strong>减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载</strong>。</li><li><strong>只要任意一端没有明确提出断开连接，则保持TCP连接状态。</strong></li></ul></li><li>支持<strong>管道（pipeline)网络传输</strong>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li><li>缓存Etag</li></ul><p>但HTTP/1.1还是有性能瓶颈︰</p><ul><li><strong>请求/响应头部(Header)未经压缩就发送</strong>，首部信息越多延迟越大。只能压缩<code>Body</code>的部分;</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>;</li><li><strong>没有请求优先级控制</strong>;</li><li>请求只能从客户端开始，<strong>服务器只能被动响应</strong>。</li></ul><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p><strong>HTTP/2协议是大多基于HTTPS的，所以HTTP/2的安全性也是有保障的。</strong></p><p>那HTTP/2相比HTTP/1.1 性能上的改进︰</p><ul><li><p><strong>头部压缩</strong>（HPACK算法）</p><ul><li>HTTP/2会<strong>压缩头</strong>(Header)。</li><li>如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</li></ul></li><li><p><strong>二进制格式</strong></p><ul><li>不再是纯文本形式的报文，而是全面采用了<strong>二进制格式</strong></li><li>直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</li></ul></li><li><p><strong>数据流</strong></p><ul><li>HTTP/2的数据包<strong>不是按顺序发送的</strong>，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</li><li>每个请求或回应的所有数据包，称为一个数据流（<strong>Stream</strong> )。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。</li><li>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</li></ul></li><li><p><strong>多路复用</strong></p><ul><li>HTTP/2是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。</li><li>移除了HTTP/1.1中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。</li></ul></li><li><p><strong>服务器推送</strong></p><ul><li>HTTP/2还在一定程度上改善了传统的「请求-应答」工作模式，服务不再是被动地响应，<strong>也可以主动向客户端发送消息</strong>。</li><li>举例来说，在浏览器刚请求HTML的时候，就提前把可能会用到的JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送(<strong>Server Push</strong>，也叫<strong>Cache Push</strong>)。</li></ul></li></ul><h4 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h4><p>HTTP/2主要的问题在于，<strong>多个HTTP请求在复用一个TCP连接</strong>，下层的TCP协议是不知道有多少个HTTP请求的。</p><p>所以<strong>一旦发生了丢包现象，就会触发TCP的重传机制</strong>，这样在一个TCP连接中的<strong>所有的HTTP请求都必须等待这个丢了的包被重传回来</strong>。</p><ul><li>HTTP/1.1中的管道（pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了。</li><li>HTTP/2多个请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的HTTP请求。</li></ul><p>这都是<strong>基于TCP传输层</strong>的问题，所以<strong>HTTP/3把HTTP下层的TCP协议改成了UDP</strong>!</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/btsh6J"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btsh6J.png" alt="btsh6J.png"></a></p><p>UDP是<strong>不管顺序，也不管丢包的</strong>，所以<strong>不会出现HTTP/1.1的队头阻塞和HTTP/2的一个丢包全部重传问题</strong>。</p><p>大家都知道UDP是不可靠传输的，但<strong>基于UDP的QUIC协议可以实现类似TCP的可靠性传输</strong>。</p><ul><li>QUIC有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，<strong>其他流不会受到影响</strong>。</li><li>TLS3升级成了最新的<strong>1.3</strong>版本，头部压缩算法也升级成了<strong>QPack</strong> 。</li><li>HTTPS要建立一个连接，要花费6次交互，先是建立三次握手，然后是TLS/1.3的三次握手。QUIC直接把以往的TCP和 TLS/1.3的6次交互<strong>合并成了3次，减少了交互次数</strong>。</li></ul><p>所以，QUIC是一个在UDP之上的<strong>伪</strong>TCP+ TLS+ HTTP/2的多路复用的协议。</p><p>QUIC是新协议，对于很多网络设备，根本不知道什么是QUIC，只会当做UDP，这样会出现新的问题。所以HTTP/3现在普及的进度非常的缓慢，不知道未来UDP是否能够逆袭TCP。</p><h2 id="Ajax⭐"><a href="#Ajax⭐" class="headerlink" title="Ajax⭐"></a>Ajax⭐</h2><p>一种异步请求数据的web开发技术，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。</p><h3 id="原生Ajax"><a href="#原生Ajax" class="headerlink" title="原生Ajax"></a>原生Ajax</h3><blockquote><p>XMLHttpRequest（XHR）对象用于与服务器交互。</p></blockquote><ul><li><p>创建<code>XMLHttpRequest</code> 对象。<code>const xhr = new XMLHttpRequest()</code></p></li><li><p>使用<code>open</code>方法设置请求的参数。<code>xhr.open(method, url, 是否异步)</code>。</p><ul><li><p><code>get</code>可以把请求参数拼接在<code>url</code></p></li><li><p>如果想要使用<code>post</code>提交数据,必须添加此行。</p><p><code>xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</code></p></li></ul></li><li><p>注册<code>onreadystatechange</code>事件，<strong>状态改变时就会调用</strong>。</p><ul><li><code>xhr.readyState===4</code> 请求已完成，且响应已就绪。存有 <code>XMLHttpRequest</code> 的状态。从 0 到 4 发生变化。</li><li><code>(xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300) || xhr.status === 304</code> 304：服务器端资源未改变，可直接使用客户端未过期的缓存。</li></ul></li><li><p>发送请求。</p><ul><li><code>get</code>请求：<code>xhr.send()</code></li><li><code>post</code>请求：将数据通过<code>send</code>方法传递 <code>xhr.send(&#39;name=fox&amp;age=18&#39;);</code></li></ul></li><li><p>获取返回的数据，更新UI。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="params">url</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">&#x27;GET&#x27;</span>,url, <span class="literal">true</span>);</span><br><span class="line">        xhr.onreadystatechange = <span class="function">()=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> ((xhr.status&gt;=<span class="number">200</span> &amp;&amp; xhr.status&lt;<span class="number">300</span>) || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">                    resolve(xhr.responseText);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.responseText));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p>fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。</p><h3 id="Promise封装axios"><a href="#Promise封装axios" class="headerlink" title="Promise封装axios"></a>Promise封装axios</h3><p>axios是一个基于<code>promise</code>的<code>HTTP</code>库，可以用在<code>浏览器</code>或者<code>node.js</code>中。</p><p>axios是通过promise实现对ajax技术的一种封装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; message &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url,data=&#123;&#125;,type=<span class="string">&#x27;GET&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> promise;</span><br><span class="line">        <span class="comment">// 执行异步ajax请求</span></span><br><span class="line">        <span class="keyword">if</span>(type===<span class="string">&#x27;GET&#x27;</span>)&#123;<span class="comment">//发GET请求</span></span><br><span class="line">            promise=axios.get(url,&#123;</span><br><span class="line">                <span class="attr">params</span>:data</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//发POST请求</span></span><br><span class="line">            promise=axios.post(url,data)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果请求成功了，调用resolve(value)</span></span><br><span class="line">        <span class="comment">// 该方法返回一个以response.data值解析后的Promise对象</span></span><br><span class="line">        promise.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(response.data)</span><br><span class="line">            <span class="comment">// console.log(response.data)</span></span><br><span class="line">        <span class="comment">// 如果请求失败了，不调用reject(reason)，而是提示异常信息（统一处理异常）   </span></span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            message.error(<span class="string">&#x27;请求出错了：&#x27;</span>+error.message)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跨域通信⭐"><a href="#跨域通信⭐" class="headerlink" title="跨域通信⭐"></a>跨域通信⭐</h2><p><strong>同源策略</strong>：用于隔离潜在恶意文件的安全机制。</p><p>同源是指”<strong>协议</strong>+<strong>域名</strong>+<strong>端口</strong>“三者相同，<strong>即便两个不同的域名指向同一个ip地址，也非同源</strong>。</p><p><strong>同源策略限制内容有：</strong></p><ul><li><code>Cookie</code>、<code>LocalStorage</code>、<code>IndexedDB</code> 等存储性内容</li><li><code>DOM</code> 节点</li><li><code>AJAX</code> 请求</li></ul><p>但是有的标签是允许跨域加载资源：</p><ul><li><code>&lt;img src=XXX&gt;</code></li><li><code>&lt;link href=XXX&gt;</code></li><li><code>&lt;script src=XXX&gt;</code></li></ul><p><strong>当协议、域名、端口号中任意一个不相同时，都算作不同域</strong>。不同域之间相互请求资源，就算作“跨域”。</p><p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong>。</p><h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h3><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p><code>JSON with Padding</code> JS函数包裹JSON数据。</p><p><strong>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</strong></p><p><code>&lt;script&gt;</code> 标签中type的默认属性是<code>text/javascript</code>,<strong>会把收到的文本内容当成JS代码进行执行</strong>。</p><p>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。</p><p><strong>缺点是仅支持get方法，具有局限性；不安全，可能会遭受XSS攻击。</strong></p><p><strong>JSONP的实现流程</strong></p><ul><li>声明一个回调函数，其函数名(如<code>jsonpCallback</code>)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</li><li>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给<code>&lt;script&gt;</code>的<code>src</code>，还要在这个地址中向服务器传递该函数名（可以通过问号传参:<code>?callback=jsonpCallback</code>）。</li><li>服务器接收到请求后，需要进行特殊的处理：把<strong>传递进来的函数名</strong>和它需要给你的<strong>数据</strong>拼接成一个<strong>字符串</strong>。</li><li>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（<code>jsonpCallback</code>），对返回的数据进行操作。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去创建一个script标签</span></span><br><span class="line"><span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">//script的src属性设置接口地址 并带一个callback回调函数名称</span></span><br><span class="line">script.src = <span class="string">&quot;http://127.0.0.1:8888/index.php?callback=jsonpCallback&quot;</span>;</span><br><span class="line"><span class="comment">//插入到页面</span></span><br><span class="line"><span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"><span class="comment">//通过定义函数名去接收后台返回数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonpCallback</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//注意  jsonp返回的数据是json对象可以直接使用</span></span><br><span class="line">    <span class="comment">// 例如服务器的json字符串为 &#x27;&#123;&quot;msg&quot;:&quot;用户名设置成功&quot;&#125;&#x27;</span></span><br><span class="line">    <span class="comment">// 实际返回的字符串 &#x27;callback(&#123;&quot;msg&quot;:&quot;用户名设置成功&quot;&#125;)&#x27;</span></span><br><span class="line">    <span class="comment">// 浏览器接收后，执行callback(&#123;&quot;msg&quot;:&quot;用户名设置成功&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 此时的参数就是一个json对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS（Cross-Origin Resource Sharing），跨域资源共享。</p><p>CORS是官方的跨域解决方案，需要浏览器和后端同时支持。</p><p>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 CORS。 <strong>该属性表示哪些域名可以访问资源，如果设置通配符<code>*</code>则表示所有网站都可以访问资源。</strong></p><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><p><strong>简单请求</strong></p><ul><li>请求方法是 <code>HEAD</code>、<code>GET</code>、<code>POST</code> 三种之一；</li><li>HTTP 头信息不超过右边着几个字段：<ul><li><code>Accept</code>、</li><li><code>Accept-Language</code>、</li><li><code>Content-Language</code>、</li><li><code>Last-Event-ID</code></li><li><code>Content-Type</code> 只限于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>；</li></ul></li></ul><p>需要这些条件是为了兼容表单，因为历史上表单一直可以跨域。</p><p>浏览器直接发出<strong>CORS请求</strong>，具体来说就是在头信息中增加<code>Origin</code>字段，表示请求来源来自哪个域(协议+域名+端口)，服务器根据这个值决定是否同意请求。如果同意，返回的响应会多出以下响应头信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//juejin.com // 和 Orign 一致  这个字段是必须的</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span> <span class="comment">// 表示是否允许发送 Cookie  这个字段是可选的</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar <span class="comment">// 指定返回其他字段的值   这个字段是可选的</span></span><br></pre></td></tr></table></figure><p>在简单请求中服务器至少需要设置：<code>Access-Control-Allow-Origin</code> 字段。</p><p><strong>复杂请求</strong></p><ul><li><p>不符合以上条件的请求，比如请求方法是 <code>PUT</code> 或 <code>DELETE</code>，或 <code>Content-Type</code> 值为 <code>application/json</code>。</p></li><li><p>浏览器会在正式通信之前，发送一次 <strong>HTTP 预检</strong> <code>OPTIONS</code> 请求，先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 请求方法和头信息字段（服务器返回的响应头会包含允许的域名、方法等）。只有得到肯定答复，浏览器才会发出正式的 <code>XHR</code> 请求，否则报错。</p></li><li><p>预检请求的方法是<code>OPTIONS</code>，它的头信息中有几个字段</p><ul><li><code>Origin</code>: 表示请求来自哪个域，这个字段是必须的</li><li><code>Access-Control-Request-Method</code>：列出CORS请求会用到哪些HTTP方法，这个字段是必须的</li><li><code>Access-Control-Request-Headers</code>： 指定CORS请求会额外发送的头信息字段，用逗号隔开</li></ul></li><li><p>OPTIONS请求次数过多也会损耗性能，所以要尽量减少OPTIONS请求，可以让服务器在请求返回头部添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Max-Age: <span class="built_in">Number</span> <span class="comment">// 数字 单位是秒</span></span><br></pre></td></tr></table></figure><p>表示预检请求的返回结果可以被缓存多久，在这个时间范围内再请求就不需要预检了。不过这个缓存只对完全一样的URL才会生效。</p></li></ul><h5 id="关于CORS的-cookie-问题"><a href="#关于CORS的-cookie-问题" class="headerlink" title="关于CORS的 cookie 问题"></a>关于CORS的 cookie 问题</h5><p>想要传递 <code>cookie</code> 需要满足 3 个条件</p><ul><li>web 请求设置<code>withCredentials</code></li></ul><p>这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 <code>withCredentials</code> 来进行传递 <code>cookie</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 xml 的设置方式</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// axios 设置方式</span></span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>2.<code>Access-Control-Allow-Credentials</code> 为 <code>true</code></p><p>3.<code>Access-Control-Allow-Origin</code>为<strong>非</strong> <code>*</code></p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>简单的说，一般给客户端做代理的都是正向代理，给服务器做代理的就是反向代理。</p><h5 id="Node中间件代理"><a href="#Node中间件代理" class="headerlink" title="Node中间件代理"></a>Node中间件代理</h5><p><strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong></p><p>代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点同域。</p><h5 id="React中配置代理"><a href="#React中配置代理" class="headerlink" title="React中配置代理"></a>React中配置代理</h5><p>在<code>package.json</code>中追加如下配置 :<code>&quot;proxy&quot;:http://localhost:5000</code></p><h5 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h5><p>配置一个代理服务器向服务器请求，再将数据返回给客户端，实质和CORS跨域原理一样，也需要配置请求响应头Access-Control-Allow-Origin等字段，只不过是在代理服务器配置。</p><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p><code>WebSocket</code>是<code>HTML5</code>的一个持久化的协议，它实现了<strong>浏览器与服务器的全双工通信</strong>，同时也是跨域的一种解决方案。</p><p><code>WebSocket</code>和<code>HTTP</code>都是<strong>应用层协议</strong>，都基于 <code>TCP</code> 协议。</p><p>但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。</p><p>同时，<code>WebSocket</code> 在建立连接时需要借助 <code>HTTP</code> 协议，连接建立好了之后 <code>client</code> 与 <code>server</code> 之间的双向通信就与 <code>HTTP</code> 无关了。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>postMessage（H5支持跨域的window属性）、location.hash + iframe</p><h2 id="XSS和CSRF"><a href="#XSS和CSRF" class="headerlink" title="XSS和CSRF"></a>XSS和CSRF</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p><code>Cross-Site Scripting</code>（跨站脚本攻击）简称 XSS，是一种<strong>代码注入攻击</strong>。</p><p>攻击者通过在<strong>目标网站</strong>上注入<strong>恶意脚本</strong>，使之在用户的<strong>浏览器</strong>上运行。</p><p>利用这些恶意脚本，攻击者可获取用户的敏感信息如<code>Cookie</code>、<code>SessionID</code> 等，进而危害数据安全。</p><p>简单来说,任何可以输入的地方都有可能引起,包括<strong>URL</strong>!</p><p>根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。</p><p><strong>存储型 XSS</strong>(又被称为持久性XSS)攻击</p><ul><li>常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</li><li>它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，</li><li><strong>它不需要用户手动触发</strong>。<strong>任何允许用户存储数据的web程序都可能存在存储型XSS漏洞</strong>，当攻击者提交一段XSS代码后，被服务器端接收并存储，当<strong>所有浏览者访问某个页面时都会被XSS</strong>。</li></ul><p>反射型 XSS (也被称为非持久性XSS)</p><ul><li>存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</li><li>常见于通过 URL 传递参数的功能，如网站搜索、跳转等。</li><li>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</li></ul><p>DOM 型 XSS</p><ul><li>取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</li></ul><h3 id="常用防范方法"><a href="#常用防范方法" class="headerlink" title="常用防范方法"></a>常用防范方法</h3><ul><li><strong>httpOnly:</strong> 在 <code>cookie</code> 中设置 <code>HttpOnly</code> 属性后，js脚本将无法读取到 cookie 信息。</li><li><strong>输入过滤:</strong> 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。不仅仅是<strong>前端</strong>负责，<strong>后端</strong>也要做相同的过滤检查。因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。</li><li><strong>转义 HTML:</strong> 如果拼接 HTML 是必要的，就需要对于<strong>引号</strong>，<strong>尖括号</strong>，斜杠进行转义,但这还不是很完善。</li><li><strong>白名单:</strong> 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</li></ul><ul><li><strong>纯前端渲染</strong><ul><li>浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。</li><li>然后浏览器执行 HTML 中的 JavaScript。</li><li>JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。</li></ul></li></ul><p>在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（<code>.innerText</code>），还是属性（<code>.setAttribute</code>），还是样式（<code>.style</code>）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。</p><p>但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 <code>onload</code> 事件和 <code>href</code> 中的 <code>javascript:xxx</code> 等）。</p><p>在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题,这时就需要对HTML进行充分的转义。</p><ul><li><strong>预防 DOM 型 XSS 攻击</strong></li></ul><p>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript代码本身不够严谨，把不可信的数据当作代码执行了。</p><p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等。</p><p>如果用 Vue/React 技术栈，并且不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患。</p><p>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>跨站请求伪造（Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种<strong>挟制用户在当前已登录的 Web 应用程序上执行非本意的操作</strong>的攻击方法。</p><h4 id="CSRF与-XSS-区别"><a href="#CSRF与-XSS-区别" class="headerlink" title="CSRF与 XSS 区别"></a>CSRF与 XSS 区别</h4><ul><li><strong>通常来说 CSRF 是由 XSS 实现的，CSRF 时常也被称为 XSRF（CSRF 实现的方式还可以是直接通过命令行发起请求等）。</strong></li><li>本质上讲，XSS 是代码注入问题，<strong>CSRF 是 HTTP 问题。</strong> XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。<strong>CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(Token验证可以避免)。</strong></li></ul><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><ul><li>验证码；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 CSRF，但是用户体验比较差。</li><li>Referer check；请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。</li><li>token；<strong>token 验证的 CSRF 防御机制是公认最合适的方案。</strong>若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。</li></ul><h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP UDP"></a>TCP UDP</h2><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li>在传送数据之前<strong>不需要先建立连接</strong>，远地主机在收到 UDP 报文后，<strong>不需要给出任何确认</strong>。</li><li>一般用于<strong>即时通信</strong>，比如： QQ 语音、 QQ 视频 、直播等等</li><li>基于<strong>UDP的QUIC</strong>协议可以实现类似TCP的可靠性传输</li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul><li>提供<strong>面向连接</strong>的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li>TCP 在传递数据之前，会有<strong>三次握手</strong>来建立连接，而且在数据传递时，有<strong>确认</strong>、<strong>窗口</strong>、<strong>重传</strong>、<strong>拥塞控制</strong>机制，在数据传完后，还会<strong>断开连接</strong>用来节约系统资源</li><li>由于 TCP 要提供可靠的，面向连接的传输服务，这难以避免增加了许多开销。</li><li>TCP 一般用于<strong>文件传输、发送和接收邮件、远程登录</strong>等场景。</li></ul><h3 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h3><ul><li>应用数据被分割成 TCP 认为<strong>最适合发送的数据块</strong>。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行<strong>排序</strong>，把有序数据传送给应用层。</li><li>TCP 将保持它首部和数据的<strong>检验和</strong>。这是一个端到端的检验和，目的是<strong>检测数据在传输过程中的任何变化</strong>。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端<strong>会丢弃重复的数据</strong>。</li><li><strong>流量控制：</strong>TCP 连接的每一方都有固定大小的缓冲空间，TCP 的<strong>接收端只允许发送端发送接收端缓冲区能接纳的数据</strong>。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是<strong>可变大小的滑动窗口协议</strong>。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。<ul><li>第一个响应包是<strong>14kb</strong>大小。这是<strong>慢开始</strong>的一部分，慢开始是一种均衡网络连接速度的算法。慢开始逐渐增加发送数据的数量直到达到网络的最大带宽。</li><li>拥塞控制算法使用这个<strong>发送包</strong>和<strong>确认帧流</strong>（客户端返回）来确定发送速率。</li></ul></li><li><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是<strong>每发完一个分组就停止发送，等待对方确认</strong>。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ul><h2 id="从URL输入到页面展现到底发生什么？⭐"><a href="#从URL输入到页面展现到底发生什么？⭐" class="headerlink" title="从URL输入到页面展现到底发生什么？⭐"></a>从URL输入到页面展现到底发生什么？⭐</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/btVsO0"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btVsO0.png" alt="btVsO0.png"></a></p><p>总体来说分为以下几个过程:</p><ul><li>解析URL并生成HTTP请求报文</li><li>DNS 解析：将域名解析成IP地址</li><li>TCP 三次握手建立连接、TLS三次握手 =》在HTTPS上建立安全连接</li><li>将HTTP报文添加TCP头部（源、目标端口、序号、窗口大小和状态位）生成TCP报文</li><li>添加IP包头（源、目标IP）和MAC包头（收发MAC地址）将数据封装成网络包</li><li>网卡驱动从IP模块获取到包之后，再次封装。</li><li>网卡会将包转为电信号，通过网线发送出去。</li><li>网络包经过交换机和路由器转发到达服务器</li><li>服务器将MAC、IP、TCP、HTTP头部一层层解析处理，将网页放入HTTP响应报文中，穿上TCP、IP、MAC头部返回</li><li>浏览器拿到HTTP响应报文后，将HTML和CSS解析出DOM 树和 CSS 规则树（<strong>CSSOM</strong>），两者生成渲染树进行页面绘制</li><li>断开TCP连接 ：TCP四次挥手</li></ul><h3 id="URL是什么？"><a href="#URL是什么？" class="headerlink" title="URL是什么？"></a>URL是什么？</h3><p>统一资源定位符，URI是统一资源标志符</p><p><strong>URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</strong></p><p>URL遵守以下的语法规则：<code>scheme://host.domain:port/path/filename</code></p><ul><li><strong>scheme</strong> - 定义因特网服务的类型。常见的协议有 <strong>http、https、ftp、file</strong>，其中最常见的类型是 http，而 <strong>https 则是进行加密的网络传输</strong>。</li><li><strong>host</strong> - 定义域主机（http 的默认主机是 <strong>www</strong>）</li><li><strong>domain</strong> - 定义因特网<strong>域名</strong>，比如 <code>w3school.com.cn</code></li><li><strong>port</strong> - 定义主机上的<strong>端口号</strong>（http 的默认端口号是 80）</li><li><strong>path</strong> - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</li><li><strong>filename</strong> - 定义文档/资源的名称</li></ul><p>当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是<code>/index.html</code>或者<code>/default.html</code>这些文件，这样就不会发生混乱了。</p><h3 id="域名解析（DNS）"><a href="#域名解析（DNS）" class="headerlink" title="域名解析（DNS）"></a>域名解析（DNS）</h3><p>委托操作系统将消息发送给Web服务器，<strong>需要查询服务器域名对应的IP地址。</strong></p><p>DNS服务器就<strong>专门保存了Web服务器域名与IP的对应关系</strong>。</p><p><strong>查询过程</strong></p><ul><li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li><li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器<strong>缓存</strong>中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li><li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li><li>本地DNS服务器向<strong>顶级域名服务器（.com）</strong>发送请求，返回相关的下一级的权威域名服务器的地址</li><li>本地DNS服务器向**权威域名服务器(.baidu.com)**发送请求，域名服务器返回对应的结果(<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>)</li><li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li><li>本地DNS服务器将返回结果返回给浏览器</li></ul><p>DNS解析是一个包含迭代查询和递归查询的过程。</p><p>一般<strong>我们向本地 DNS 服务器</strong>发送请求的方式就是<strong>递归查询</strong>，因为我们只需要发出<strong>一次请求</strong>，然后<strong>本地 DNS 服务器返回给我们最终的请求结果</strong>。而<strong>本地 DNS 服务器向其他域名服务器</strong>请求的过程是<strong>迭代查询</strong>的过程，因为<strong>每一次域名服务器只返回单次查询的结果，下一级的查询由本地 DNS 服务器自己进行</strong>。</p><p><strong>DNS负载均衡</strong></p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>TCP连接的建立，通常称为三次握手。</p><p>这个所谓的「连接」，只是双方计算机里<strong>维护一个状态机</strong>。</p><p><strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</strong></p><ul><li><strong>Socket</strong>:由<strong>IP地址</strong>和<strong>端口号</strong>组成</li><li><strong>序列号</strong>:用来解决乱序问题等</li><li><strong>窗口大小</strong>:用来做流量控制</li></ul><p><strong>三次握手</strong></p><ul><li>一开始，客户端和服务端都处于<code>CLOSED</code>状态。先是服务端<strong>主动监听某个端口</strong>，处于<code>LISTEN</code>状态。</li><li>客户端把第一个SYN 报文（包含序列号（client_isn ），<code>SYN</code> 标志位置为<code>1</code>）发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于<code>SYN-SENT</code>状态。</li><li>服务端收到客户端的<code>SYN</code>报文后，发送应答报文（包含自己序列号（server_isn）、确认序列（client_isn +1）、SYN和ACK置1）给客户端，该报文也不包含应用层数据，之后服务端处于<code>SYN-RCVD</code>状态。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文（确认序列（server_isn +1），ACK置1），这次报文<strong>可以携带客户到服务器的数据</strong>，之后客户端处于<code>ESTABLISHED</code> 状态。</li><li>服务器收到客户端的应答报文后，也进入<code>ESTABLISHED</code>状态。</li></ul><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/btndH0"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btndH0.png" alt="btndH0.png"></a></p><p><strong>为什么三次？</strong></p><p><strong>因为三次握手才能保证双方具有接收和发送的能力</strong>。</p><p><strong>通过三次握手能防止历史连接的建立（序列号），能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。</strong></p><p>不使用<strong>两次握手</strong>和<strong>四次握手</strong>的原因:</p><ul><li>两次握手︰无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号;</li><li>四次握手︰三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><h3 id="断开TCP连接-四次挥手"><a href="#断开TCP连接-四次挥手" class="headerlink" title="断开TCP连接 四次挥手"></a>断开TCP连接 四次挥手</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/btNzm8"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btNzm8.png" alt="btNzm8.png"></a></p><p><strong>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</strong></p><ul><li>客户端打算关闭连接，此时会发送<code>FIN</code> 报文（FIN置1），之后客户端进入<code>FIN_WAIT_1</code>状态。</li><li>服务端收到该报文后，就向客户端发送<code>ACK</code>应答报文，接着服务端进入<code>CLOSED_WAIT</code>状态；客户端收到服务端的<code>ACK</code>应答报文后，之后进入<code>FIN_WAIT_2</code>状态。</li><li>等待<strong>服务端处理完数据后</strong>，也向客户端发送<code>FIN</code> 报文，之后服务端进入<code>LAST_ACK</code>状态。</li><li>客户端收到服务端的<code>FIN</code> 报文后，回一个<code>ACK</code>应答报文，之后进入<code>TIME_WAIT</code>状态。</li><li>服务器收到了<code>ACK</code>应答报文后，就进入了<code>CLOSED</code>状态，至此<strong>服务端已经完成连接的关闭</strong>。</li><li>客户端在经过<code>2MSL</code>一段时间后，自动进入<code>CLOSED</code>状态，至此<strong>客户端也完成连接的关闭</strong>。</li></ul><p>你可以看到，每个方向都需要一个<code>FIN</code>和一个<code>ACK</code>，因此通常被称为<strong>四次挥手</strong>。</p><p><strong>主动关闭连接的，才有TIME_WAIT状态</strong>。</p><p><strong>为什么挥手需要四次</strong>?</p><p>再来回顾下四次挥手双方发FIN 包的过程，就能理解为什么需要四次了。</p><ul><li>关闭连接时，客户端向服务端发送<code>FIN</code> 时，仅仅表示<strong>客户端不再发送数据了但是还能接收数据</strong>。</li><li>服务器收到客户端的<code>FIN</code>报文时，先回一个<code>ACK</code>应答报文，而服务端可能还有数据需要处理和发送，等<br>服务端不再发送数据时，才发送<code>FIN</code>报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，<strong>服务端通常需要等待完成数据的发送和处理</strong>，所以服务端的<code>ACK</code>和 <code>FIN</code>一般都会分开发送，从而比三次握手导致多了一次。</p><p><code>MSL</code>是<code>Maximum Segment Lifetime</code>，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><p>经过<code>2MSL</code>这个时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><p><code>TIME-WAIT</code>更重要的作用是<strong>等待足够的时间以确保最后的ACK能让被动关闭方接收，从而帮助其正常关闭</strong>。</p><h2 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h2><p>浏览器解析渲染页面分为一下五个步骤：</p><ul><li><p>根据 HTML 解析出 DOM 树</p><ul><li>图片/CSS不会影响解析</li><li><code>&lt;script&gt;</code>阻塞渲染并停止HTML的解析</li><li>预加载在后台检索资源，减少了阻塞</li></ul></li><li><p>根据 CSS 解析生成 CSS 规则树（<strong>CSSOM</strong>）</p></li><li><p>结合 DOM 树和 CSS 规则树，生成渲染树</p><ul><li><code>&lt;head&gt;</code>和它的<strong>子节点</strong>以及任何具有<code>display: none</code>样式的结点，不会出现在Render树上</li><li><code>visibility: hidden</code>的节点会出现在Render树上</li></ul></li><li><p>根据渲染树计算每一个节点的信息</p></li><li><p>根据计算好的信息绘制页面</p><ul><li>第一次确定节点的大小和位置称为布局。</li><li>随后对节点大小和位置的重新计算称为回流。</li><li>将内容提升到GPU上的层（而不是CPU上的主线程）可以提高绘制和重新绘制性能。</li><li>有一些特定的属性和元素可以实例化一个层，包括<code>&lt;video&gt;</code>和<code>&lt;canvas&gt;</code>，任何CSS属性为<code>opacity</code>、3D <code>transform</code>等</li><li>分层确实可以提高重绘速度，但是它以<strong>内存管理</strong>为代价。</li><li>如果加载包含JavaScript（并且延迟到<code>onload</code>事件激发后执行），则<strong>主线程可能很忙</strong>，无法用于滚动、触摸和其他交互。</li></ul></li></ul><h2 id="浏览器的重绘与回流（Repaint、Reflow）"><a href="#浏览器的重绘与回流（Repaint、Reflow）" class="headerlink" title="浏览器的重绘与回流（Repaint、Reflow）"></a>浏览器的重绘与回流（Repaint、Reflow）</h2><h3 id="回流-重排reflow"><a href="#回流-重排reflow" class="headerlink" title="回流/重排reflow"></a>回流/重排reflow</h3><p>当Render Tree中<strong>部分或全部元素的尺寸、结构、或某些属性发生改变时</strong>，浏览器<strong>重新渲染部分或全部文档</strong>的过程。</p><h3 id="重绘Repaint"><a href="#重绘Repaint" class="headerlink" title="重绘Repaint"></a>重绘Repaint</h3><p>当页面中<strong>元素样式的改变并不影响它在文档流中的位置</strong>时（例如：<code>color、background-color、visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它。</p><p>重绘成本很高，<strong>因为浏览器必须验证 DOM 树中所有其他节点的可见性</strong>。</p><p>回流对性能甚至<strong>更为关键</strong>，因为它涉及<strong>影响页面一部分（或整个页面）布局的更改</strong>。</p><p>元素的回流会导致所有子元素和祖先元素以及 DOM 中跟随它的任何元素的后续<strong>回流</strong>。</p><p>在很多情况下，它们相当于<strong>重新布局整个页面</strong>。</p><p>不幸的是，很多事情都会引发回流。其中一些在编写 CSS 时特别相关：</p><ul><li>调整窗口大小</li><li>添加或删除样式表</li><li>内容更改，例如用户在输入框中键入文本</li><li>激活 CSS 伪类，例如 :hover（在 IE 中激活兄弟的伪类）</li><li>操作 DOM 的脚本</li></ul><h3 id="如何避免回流-重绘至少最小化它们对性能的影响？"><a href="#如何避免回流-重绘至少最小化它们对性能的影响？" class="headerlink" title="如何避免回流/重绘至少最小化它们对性能的影响？"></a>如何避免回流/重绘至少最小化它们对性能的影响？</h3><h4 id="在-dom-树中尽可能低地更改类"><a href="#在-dom-树中尽可能低地更改类" class="headerlink" title="在 dom 树中尽可能低地更改类"></a>在 dom 树中尽可能低地更改类</h4><p>将回流的范围限制在尽可能少的节点上</p><h4 id="避免设置多个内联样式"><a href="#避免设置多个内联样式" class="headerlink" title="避免设置多个内联样式"></a>避免设置多个内联样式</h4><p>避免设置多个内联样式，<strong>每个样式都会导致回流</strong>，样式应该组合在一个外部类中，当操作元素的类属性时，只会导致一个重排。</p><h4 id="应用动画到fixed或absolute的定位"><a href="#应用动画到fixed或absolute的定位" class="headerlink" title="应用动画到fixed或absolute的定位"></a>应用动画到fixed或absolute的定位</h4><p>它们<strong>不会影响其他元素的布局</strong>，因此它们<strong>只会导致重绘而不是完全回流</strong>。这成本要低得多。</p><h4 id="避免使用表格进行布局（或设置表格布局固定）"><a href="#避免使用表格进行布局（或设置表格布局固定）" class="headerlink" title="避免使用表格进行布局（或设置表格布局固定）"></a>避免使用表格进行布局（或设置表格布局固定）</h4><p>表格通常需要多次传递才能完全建立布局，即使是很小的更改也会导致表中所有其他节点的回流。</p><h4 id="避免频繁操作DOM"><a href="#避免频繁操作DOM" class="headerlink" title="避免频繁操作DOM"></a>避免频繁操作DOM</h4><ul><li>React的虚拟DOM的作用是将真实 DOM 的副本存储在内存中。当您修改 DOM 时，它首先将这些更改应用到内存中的 DOM。然后，使用它的差异算法，找出真正发生了什么变化。最后，它对更改进行批处理，并调用一次将它们应用到real-dom 上。因此，<strong>最大限度地减少了回流和重绘。</strong></li></ul><ul><li>也可以先为元素设置<code>display: none</code>（不会出现在Render树上，DOM操作不会引发回流和重绘），操作结束后再把它显示出来。</li></ul><h2 id="Cookie、Session、Token、JWT⭐"><a href="#Cookie、Session、Token、JWT⭐" class="headerlink" title="Cookie、Session、Token、JWT⭐"></a>Cookie、Session、Token、JWT⭐</h2><p>Cookie是<strong>服务器发送到用户浏览器</strong>并<strong>保存在本地的一小块数据</strong>，它会在<strong>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</strong>。</p><p>通常，它用于告知服务端两个请求是否来自同一浏览器，如<strong>保持用户的登录状态</strong>。Cookie 使基于<strong>无状态</strong>的HTTP协议记录稳定的状态信息成为了可能。</p><p>Cookie 主要用于以下三个方面：</p><ul><li><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li><strong>个性化设置</strong>（如用户自定义设置、主题等）</li><li><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</li></ul><p><strong>Session 是另一种记录服务器和客户端会话状态的机制</strong>，<strong>使服务端有状态化，可以记录会话信息</strong>。</p><p><strong>Session</strong> 是基于<code>cookie</code> 实现的<strong>，session 存储在服务器端</strong>，<code>sessionId</code> 会被<strong>存储到客户端的cookie 中</strong>。</p><p>第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个<code>Session ID</code>，以后每次请求把这个<code>Session ID</code>发送到服务器，服务器就知道你是谁了。</p><p>Token 是<strong>令牌</strong>，<strong>访问资源接口（API）时所需要的资源凭证</strong>。Token <strong>使服务端无状态化，不会存储会话信息。</strong></p><p><strong>JWT</strong> （JSON Web Token）</p><p><code>Token</code>：<code>头部（Header）</code>、<code>载荷（Payload）</code>、<code>签名（Signature）</code>，并以<code>.</code>进行拼接。</p><p>其中头部和载荷都是以<code>JSON</code>格式存放数据，只是进行了编码。</p><p>签名是对头部和载荷内容进行签名，加密后存储于客户端，服务端只需要使用密钥解密进行校验（即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</p><h2 id="Cookie、sessionStorage、localStorage-详解及应用场景⭐"><a href="#Cookie、sessionStorage、localStorage-详解及应用场景⭐" class="headerlink" title="Cookie、sessionStorage、localStorage 详解及应用场景⭐"></a>Cookie、sessionStorage、localStorage 详解及应用场景⭐</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是<strong>服务器发送到用户浏览器</strong>并<strong>保存在本地的一小块数据</strong>，它会在<strong>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</strong>。</p><p>通常，它用于告知服务端两个请求是否来自同一浏览器，如<strong>保持用户的登录状态</strong>。Cookie 使基于<strong>无状态</strong>的HTTP协议记录稳定的状态信息成为了可能。<strong>HTTP本质是无状态的，使用Cookies可以创建有状态的会话。</strong></p><h3 id="localStorage-amp-amp-sessionStorage"><a href="#localStorage-amp-amp-sessionStorage" class="headerlink" title="localStorage &amp;&amp; sessionStorage"></a>localStorage &amp;&amp; sessionStorage</h3><blockquote><p>Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在，而Web Storage仅仅是为了在本地“存储”数据而生。</p><p>即<code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p></blockquote><p><code>Web Storage</code>是为了在本地“存储”数据而生。<code>HTML5</code>中的<code>Web Storage</code>包括了两种存储方式：<code>sessionStorage</code>和<code>localStorage</code>。只要有效期和作用域，浏览器每次访问的时候都会将<code>Storage</code>载入到内存里</p><h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><p>IndexedDB 是一种底层 API，用于在客户端存储大量的结构化数据（也包括文件/二进制大型对象（blobs））。该 API 使用索引实现对数据的高性能搜索。虽然Web Storage在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th align="center">特性</th><th align="center">cookie</th><th align="center">localStorage</th><th align="center">sessionStorage</th><th align="center">indexDB</th></tr></thead><tbody><tr><td align="center">数据生命周期</td><td align="center">一般由服务器生成，会话期 Cookie/持久性 Cookie可以设置过期时间</td><td align="center">除非被清理，否则一直存在</td><td align="center">页面关闭就清理</td><td align="center">除非被清理，否则一直存在</td></tr><tr><td align="center">数据存储大小</td><td align="center">4K(数量20+，取决于浏览器)</td><td align="center">5M</td><td align="center">5M</td><td align="center">无限</td></tr><tr><td align="center">与服务端通信</td><td align="center">每次都会携带在header中，对于请求性能影响</td><td align="center">不参与</td><td align="center">不参与</td><td align="center">不参与</td></tr></tbody></table><p>Cookie 主要用于以下三个方面：</p><ul><li><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li><strong>个性化设置</strong>（如用户自定义设置、主题等）</li><li><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</li></ul><p>Cookie <strong>曾一度用于客户端数据的存储</strong>，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，<strong>会带来额外的性能开销（尤其是在移动环境下）</strong>。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 <code>Web storage API</code>（本地存储和会话存储）或 <code>IndexedDB</code> 。</p><h2 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p><strong>样式表放在顶部</strong>，<strong>将脚本放在底部</strong>，<strong>减少重绘</strong>，<strong>按需加载</strong>，<strong>模块化</strong></p><p>前端工程化严重的当下，轻量化的框架慢慢被遗忘掉了。并不是所有的业务场景都适合使用工程化框架，<strong>react/vue 并不轻量</strong>。</p><p>NetWork 分析 瀑布图</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>服务端配置gzip压缩后可大大缩减资源大小。</p><p>图片压缩。</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>中文（内容分发网络），服务器是中心化的，CDN是“去中心化的”。</p><p>举个简单的例子：</p><blockquote><p>以前买火车票大家都只能去火车站买，后来我们买火车票就可以在楼下的火车票代售点买了。</p></blockquote><p>所以静态资源度建议放在CDN上，可以加快资源加载的速度。</p><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种非常好的优化网页性能的方式。</p><p>当可视区域没有滚到资源需要加载的地方时候，可视区域外的资源就不会加载。</p><p>可以减少服务器负载，常适用于图片很多，页面较长的业务场景中。img的loading属性</p><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>和前面说的DNS预查询一样，可以将即将要用到的资源或者即将要握手的地址提前告知浏览器让浏览器利用还在解析HTML计算样式的时间去提前准备好。</p><p>使用link的<code>preload</code>属性预加载一个资源。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>as属性可以指定预加载的类型，除了style还支持很多类型，常用的一般是<code>style</code>和<code>script</code>，<code>css</code>和<code>js</code>。</p><h3 id="iconfont"><a href="#iconfont" class="headerlink" title="iconfont"></a>iconfont</h3><p>中文（图标字体），现在比较流行的一种用法。使用字体图表有几种好处</p><ul><li>矢量</li><li>轻量</li><li>易修改</li><li>不占用图片资源请求。</li></ul><h3 id="组件渲染"><a href="#组件渲染" class="headerlink" title="组件渲染"></a>组件渲染</h3><p>拿react举例，组件分割方面不要太深。需要控制组件的渲染，尤其是深层组件的render。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存的原理就是更快读写的存储介质+减少IO+减少CPU计算=性能优化。而性能优化的第一定律就是：优先考虑使用缓存。</p><p>缓存的主要手段有：浏览器缓存、CDN、反向代理、本地缓存、分布式缓存、数据库缓存。</p><h1 id="基于Android的电子词典设计"><a href="#基于Android的电子词典设计" class="headerlink" title="基于Android的电子词典设计"></a>基于Android的电子词典设计</h1><h2 id="单词数据的爬取"><a href="#单词数据的爬取" class="headerlink" title="单词数据的爬取"></a>单词数据的爬取</h2><blockquote><p>借助Python的Requests库和lxml库</p></blockquote><h3 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h3><p>Requests构建HTTP的请求头<strong>伪装成浏览器与词典网站进行通信</strong>，<strong>发起请求</strong>和<strong>获取响应内容</strong>，对应的方法为<strong>get</strong>方法。主要是获得相应url对应的html。</p><h3 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h3><p>XPath，全称 XML Path Language，即<strong>XML路径语言</strong>，它是一门在XML文档中查找信息的语言。</p><p>使用XPath做相应的信息抽取，即<strong>解析获取到的html</strong>。Python为此提供了<strong>lxml第三方库</strong>。</p><p>XPath以<strong>XML树结构</strong>为基础，能够在数据的结构树中查找各类节点，比如属性节点、文本节点和元素节点等等。</p><p>在检查元素中右键即可复制它的XPath路径，分析规律并且结合XPath的表达式语法，就可获取相关文本内容。</p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>使用<code>Multiprocessing</code>的<code>Pool</code>方法，设置一定数量的进程放在进程池中提供给用户调用。</p><p>新请求提交时，首先判断池有没有满，若没有满，就开辟一个新进程执行，若已满就等待池中的某个进程结束。</p><p>Pool类适用于需要执行的目标比较多而且手动限制进程数量又非常复杂的情况。</p><p>本项目设置一定进程数量的进程池，通过循环将所有需要爬虫的单词异步执行，也就是非阻塞的方式。</p><p>执行完毕后，关闭进程池并继续执行主进程。</p><h3 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h3><p>当时遇到的问题<strong>多进程爬取的数据无法同时向SQLite数据库中保存</strong>，因此先爬取内容到<code>TXT</code>，再保存到数据库中。</p><p>在Python中导入SQLite3模块，打开或连接数据库，若没有数据库则新建；然后，创建游标对象，使用它的execute()方法执行SQL命令，即创建表和插入数据；最后，关闭游标和连接并提交事务。</p><h2 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h2><p>根布局就是<code>DrawerLayout</code>，在根布局之后又主要分为两大部分，第一部分就是我们主界面的内容，第二部分是左边滑出的布局，这里用NavitationView来代替。</p><p>线性布局（<code>LinearLayout</code>）和相对布局（<code>RelativeLayout</code>）实现。</p><p>线性布局是将界面中的全部控件按照<strong>水平</strong>或<strong>竖直</strong>方向进行排列，同时它也是最基本的布局方式。</p><p>相对布局则是通过控件之间的<strong>相对位置</strong>关系实现控件的摆放，有利于适配不同屏幕大小的手机，因此使用更为普遍。</p><p>一般布局都是用<code>dp</code>，字体用<code>sp</code>（手机字体调大了，APP的字体会随之变大）来布局的，用来<strong>适配移动端分辨率</strong>。</p><h2 id="API或SDK"><a href="#API或SDK" class="headerlink" title="API或SDK"></a>API或SDK</h2><p>调用百度API实现句子翻译的功能。</p><p>调用讯飞开放平台的SDK实现语音输入的功能。</p><p>调用Stanford Core NLP的JAR文件实现句子分析（词性分析和词形还原）。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>API 全称 Application Programming Interface，即<strong>「应用程序接口」</strong>。</p><p>一般是指一些预先定义的<strong>函数</strong>，目的是供应用程序与开发人员基于某软件或硬件得以访问一组程序的能力，而又无需访问源码，或理解内部工作机制的细节。</p><h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><p>SDK 全称 Software Development Kit，<strong>软件开发工具包</strong>。</p><p>一般都是一些软件工程师为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件时的开发工具的集合。</p><p>通俗来讲就是<strong>第三方服务商提供的实现产品软件某项功能的工具包</strong>。例如 JDK 就是一种 SDK。</p><p>SDK 相当于开发集成工具环境，API 就是数据接口。API 可以在 SDK 提供的“环境”里请求。同样的，这里的“环境”也是一个抽象的概念。如果不使用 SDK，也可以直接调用 API，只不过，这个环境就要由开发者自己实现了。</p><p><strong>API 在更多场合下更像是 SDK 的一个子集</strong>，他们的区别如下：</p><ul><li>API 通常是一个<strong>函数</strong>，有特定的功能；而 SDK 是一个很多功能函数的<strong>集合体</strong>，更像是一个<strong>工具包</strong>。</li><li>API 通常扮演<strong>数据接口</strong>的形象，SDK 相当于一个<strong>工具环境</strong>，通常是需要在 SDK 的环境下调用 APl。</li><li><strong>SDK 相较于 API 封装层次更高</strong>。</li></ul><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过<strong>分离关注点</strong>的方式来组织代码结构，优化我们的开发效率。</p><p>比如说我们实验室在以前项目开发的时候，使用单页应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，当时一旦项目变得复杂，那么整个文件就会变得冗长，混乱，这样对我们的项目开发和后期的项目维护是非常不利的。</p><p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了<strong>观察者模式</strong>，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p><p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 <strong>View 层和 Model 层耦合在一起</strong>，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 <strong>View 层和 Model 层的解耦</strong>。MVC 中的 Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此我们可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p><p>MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的数据绑定，<strong>将 View 和 Model 的同步更新给自动化了</strong>。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如 vue 是通过使用数据劫持和发布订阅者模式来实现的这一功能。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p>发布订阅与观察者没什么区别。真正的区别在于，<strong>发布订阅模式</strong>实现的是一种<strong>多对多</strong>的关系，在发布者与订阅者之间需要有一个<strong>中介者</strong>，发布者发布事件名和参数到中间者，中间者向事件集中的订阅者发送参数。<br>而<strong>观察者</strong>是一种<strong>一对多</strong>的关系，所有的在同一被观察者身上绑定的观察者只能接受同一个被观察者的消息。</p><h3 id="Android-MVVM"><a href="#Android-MVVM" class="headerlink" title="Android MVVM"></a>Android MVVM</h3><blockquote><p><strong>View：</strong>XML布局文件。 <strong>Model：</strong>实体模型（数据的获取、存储、数据状态变化）。 <strong>Controller：</strong>对应于Activity，处理数据、业务和UI。</p></blockquote><p>从上面这个结构来看，Android本身的设计还是符合MVC架构的，但是<strong>Android中纯粹作为View的XML视图功能太弱，我们大量处理View的逻辑只能写在Activity中，这样Activity就充当了View和Controller两个角色</strong>，直接导致Activity中的代码大爆炸。相信大多数Android开发者都遇到过一个Acitivty数以千行的代码情况吧！所以，更贴切的说法是，这个MVC结构最终其实只是一个<strong>Model-View（Activity:View&amp;Controller）</strong>的结构。</p><blockquote><p>**View: **对应于Activity和XML，负责View的绘制以及与用户交互。 **Model: **实体模型。 **ViewModel: **负责完成View与Model间的交互，负责业务逻辑。</p></blockquote><p>Android为此提供了一套架构组件，主要有LiveData、ViewModel 和Room。</p><ul><li>LiveData是用来构建数据对象，当基础数据库改变时会通知视图；</li><li>ViewModel是用来存储和管理与界面相关的数据，这些数据在应用跳转时不会被销毁；</li><li>Room是一个SQLite对象映射库，它可以轻松地将SQLite表数据转换为Java对象，主要负责底层数据库的处理，本文调用其中的Dao接口来执行数据库增删改查等操作，利用 Database创建和管理数据库。同时，Room可以为SQLite语句提供编译时检查，并能够返回RxJava、Flowable和LiveData可观察对象。</li><li>Repository是一个仓库类，介于视图层与数据映射层（数据访问层）之间。它的作用是让视图层感觉不到数据访问层的存在，提供了一个类似集合的接口给视图层进行访问。</li></ul><p>采用MVVM模式最大的优点就是编写代码是思路明确，<strong>视图层与模型层完全解耦</strong>，方便后期的管理与维护，在代码中的其他地方使用数据库相关的操作只需一行代码，极其方便。</p><h1 id="React商城后台管理系统"><a href="#React商城后台管理系统" class="headerlink" title="React商城后台管理系统"></a>React商城后台管理系统</h1><p>因为是静态站点，所以完全是客户端部分，那么在使用路由的时候如果不在意美观，尽可能地使用Hash路由，这样跳转会没有任何问题。因为browserRouter依赖于服务端支持，使用它的话访问会出现404 not Found.</p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p>Hexo：一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>Github Pages：简单点来说，就是它为你的项目提供一个访问站点，并且直接指向你的仓库，你仓库更新，站点网站自动更新。</p><p>Github Pages可以被认为是用户编写的、托管在Github上的静态网页。使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。此外还可以绑定自己的域名。</p><p>Butterfly：主题。</p><p>npm：安装各种依赖。</p><p>性能优化：</p><p>图片压缩，cdn加速</p><p>jsDelivr ：它原生支持使用 GitHub 项目里的资源，什么都不用配置，更重要的是免费，在国内有节点，而且速度还不错（官网上也把 works in China 作为一个卖点的）。</p><p>因为页面自身还是在 GitHub Pages 托管，有时候首个请求还是会挺久才返回。</p><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><ol><li>TypeScript是JavaScript的超集。</li><li>它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。</li><li>TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。</li><li>TS完全兼容JS，换言之，任何的JS代码都可以直接当成TS使用。</li><li>相较于JS而言，TS拥有了<strong>静态类型</strong>，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。</li><li>TypeScript支持面向对象的编程特性，比如类、接口、继承、泛型等等。</li></ol><h1 id="渠道"><a href="#渠道" class="headerlink" title="渠道"></a>渠道</h1><p>B站、MDN和官网（React、React Router）、掘金/知乎、阮一峰博客</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leslie Waong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesliewaong.top/posts/f3b98ae9.html">https://lesliewaong.top/posts/f3b98ae9.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lesliewaong.top" target="_blank">Leslie Waong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CSS/">CSS</a><a class="post-meta__tags" href="/tags/HTML/">HTML</a><a class="post-meta__tags" href="/tags/JS/">JS</a><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/4.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/b976e516.html"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/6.webp" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法题（JS）</div></div></a></div><div class="next-post pull-right"><a href="/posts/a9ba4134.html"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/2.webp" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaScript基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/6bfa7aba.html" title="纯CSS3实现卡通人物眼睛的动画特效"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-16</div><div class="title">纯CSS3实现卡通人物眼睛的动画特效</div></div></a></div><div><a href="/posts/2eec1551.html" title="HTML和CSS基础"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/4.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-08</div><div class="title">HTML和CSS基础</div></div></a></div><div><a href="/posts/3e6a4f74.html" title="CSS盒模型、BFC和清除浮动"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-12</div><div class="title">CSS盒模型、BFC和清除浮动</div></div></a></div><div><a href="/posts/c0a854fc.html" title="CSS选择器及优先级"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-13</div><div class="title">CSS选择器及优先级</div></div></a></div><div><a href="/posts/74bc18a0.html" title="三栏布局"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-15</div><div class="title">三栏布局</div></div></a></div><div><a href="/posts/28d62aa4.html" title="居中布局与Flex"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/11.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-14</div><div class="title">居中布局与Flex</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Leslie Waong</div><div class="author-info__description">BUPT</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lesliewaong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lesliewaong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1138964397&amp;website=www.qtxml.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">红雨漂泊泛起了回忆怎么潜</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML-amp-CSS"><span class="toc-text">HTML&amp;CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3%E2%AD%90"><span class="toc-text">语义化的理解⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE"><span class="toc-text">常用的一些语义化标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%AB%E6%BB%A5%E7%94%A8%E7%9A%84%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE"><span class="toc-text">被滥用的语义化标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML5%E6%96%B0%E5%A2%9E"><span class="toc-text">HTML5新增</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lt-img-gt-%E7%9A%84title%E5%92%8Calt%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">&lt;img&gt;的title和alt有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#H5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%E2%AD%90"><span class="toc-text">H5的新特性有哪些⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iframe%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">iframe优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#iframe%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">iframe的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iframe%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">iframe的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8Bsrc%E4%B8%8Ehref%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">简述一下src与href的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E9%81%93%E7%9A%84%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C%E4%BC%9A%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">知道的网页制作会用到的图片格式有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inline%EF%BC%8Cblock%EF%BC%8Cinline-block%E7%9A%84%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="toc-text">inline，block，inline-block的区别⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0-block"><span class="toc-text">块级元素(block)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-inline"><span class="toc-text">行内元素(inline)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%9D%97%E5%85%83%E7%B4%A0-inline-block"><span class="toc-text">行内块元素(inline-block)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E4%B8%8E%E5%9D%97%E7%8A%B6%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">行内元素与块状元素之间的转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%E2%AD%90"><span class="toc-text">居中布局⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD"><span class="toc-text">水平居中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-text">垂直居中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-text">水平垂直居中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flex%E2%AD%90"><span class="toc-text">Flex⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-text">容器属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flex-flow"><span class="toc-text">flex-flow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#justify-content"><span class="toc-text">justify-content</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#align-items"><span class="toc-text">align-items</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#align-content"><span class="toc-text">align-content</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">项目的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#align-self"><span class="toc-text">align-self</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flex"><span class="toc-text">flex</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E2%AD%90"><span class="toc-text">三栏布局⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E5%8A%A8"><span class="toc-text">浮动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D"><span class="toc-text">绝对定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flexbox%E5%B8%83%E5%B1%80"><span class="toc-text">Flexbox布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80table"><span class="toc-text">表格布局table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80-grid"><span class="toc-text">网格布局 grid</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%A4%E8%AF%86%E2%AD%90"><span class="toc-text">对CSS盒模型的认识⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E7%9B%92%E5%AD%90%EF%BC%88Block-box%EF%BC%89-%E5%92%8C-%E5%86%85%E8%81%94%E7%9B%92%E5%AD%90%EF%BC%88Inline-box%EF%BC%89"><span class="toc-text">块级盒子（Block box） 和 内联盒子（Inline box）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCSS-%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">什么是CSS 盒模型?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%92%8CIE%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-text">标准盒模型和IE盒子模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFC%E2%AD%90"><span class="toc-text">BFC⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">BFC的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90BFC"><span class="toc-text">如何生成BFC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">BFC 的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3margin%E9%87%8D%E5%8F%A0"><span class="toc-text">解决margin重叠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%BD%B1%E5%93%8D%EF%BC%88%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%EF%BC%89"><span class="toc-text">清除浮动影响（高度塌陷）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E4%B8%ADlink%E5%92%8C-import%E5%8C%BA%E5%88%AB"><span class="toc-text">CSS中link和@import区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#less%E2%AD%90"><span class="toc-text">less⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#script%E6%A0%87%E7%AD%BE%E7%9A%84defer%E5%92%8Casync%E5%B1%9E%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">script标签的defer和async属性有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#async%E6%A0%87%E8%AE%B0"><span class="toc-text">async标记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer%E6%A0%87%E8%AE%B0"><span class="toc-text">defer标记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B0%E5%BA%95%E8%AF%A5%E7%94%A8%E5%93%AA%E4%B8%AA%E6%A0%87%E8%AE%B0"><span class="toc-text">到底该用哪个标记</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7%E2%AD%90"><span class="toc-text">CSS选择器优先级⭐</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%AFCSS3%E5%AE%9E%E7%8E%B0%E5%8D%A1%E9%80%9A%E4%BA%BA%E7%89%A9%E7%9C%BC%E7%9D%9B%E7%9A%84%E5%8A%A8%E7%94%BB%E7%89%B9%E6%95%88%E2%AD%90"><span class="toc-text">纯CSS3实现卡通人物眼睛的动画特效⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80"><span class="toc-text">自适应布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1px%E8%BE%B9%E6%A1%86%E9%97%AE%E9%A2%98"><span class="toc-text">1px边框问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEmeta%E6%A0%87%E7%AD%BEviewport"><span class="toc-text">通过设置meta标签viewport</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87transform-scale-%E7%BC%A9%E6%94%BE%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">通过transform: scale()缩放（推荐）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%8F%A3"><span class="toc-text">视口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E9%80%82%E9%85%8D%E6%96%B9%E6%B3%95"><span class="toc-text">解决适配方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rem%E9%80%82%E9%85%8D"><span class="toc-text">rem适配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vw%EF%BC%8Cvh%E5%B8%83%E5%B1%80"><span class="toc-text">vw，vh布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80"><span class="toc-text">媒体查询 响应式布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#px%E4%B8%BA%E4%B8%BB%EF%BC%8Cvx%E5%92%8Cvxxx%EF%BC%88vw-vh-vmax-vmin%EF%BC%89%E4%B8%BA%E8%BE%85%EF%BC%8C%E6%90%AD%E9%85%8D%E4%B8%80%E4%BA%9Bflex%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">px为主，vx和vxxx（vw&#x2F;vh&#x2F;vmax&#x2F;vmin）为辅，搭配一些flex（推荐）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E6%A1%86"><span class="toc-text">边框</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8border%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-text">利用border画三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#border-radius"><span class="toc-text">border-radius</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#box-shadow"><span class="toc-text">box-shadow</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filter"><span class="toc-text">filter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#position"><span class="toc-text">position</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">层叠上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E5%8A%A8%E7%94%BB"><span class="toc-text">CSS动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transform"><span class="toc-text">transform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#animation"><span class="toc-text">animation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#keyframes"><span class="toc-text">@keyframes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-duration"><span class="toc-text">animation-duration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-timing-function"><span class="toc-text">animation-timing-function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-delay"><span class="toc-text">animation-delay</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-iteration-count"><span class="toc-text">animation-iteration-count</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-direction"><span class="toc-text">animation-direction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-fill-mode"><span class="toc-text">animation-fill-mode</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB-%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-text">伪类&#x2F;伪元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB"><span class="toc-text">伪类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-text">伪元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JacaScript"><span class="toc-text">JacaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80"><span class="toc-text">语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%BB%A3%E7%A0%81-vs-%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81"><span class="toc-text">解释代码 vs 编译代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BB%A3%E7%A0%81-vs-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-text">服务器端代码 vs 客户端代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%AD%90"><span class="toc-text">数据类型⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-7-1"><span class="toc-text">8种数据类型: 7+1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-text">类型判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84"><span class="toc-text">判断数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#amp"><span class="toc-text">&#x3D;&#x3D;&#x3D; &amp; &#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Number"><span class="toc-text">Number</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-0-2-0-3"><span class="toc-text">0.1 + 0.2 !&#x3D;&#x3D; 0.3?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-text">严格模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%E2%AD%90"><span class="toc-text">作用域与闭包⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E2%AD%90"><span class="toc-text">原型与原型链⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93%E2%AD%90"><span class="toc-text">DOM事件总结⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BA%A7%E5%88%AB"><span class="toc-text">DOM事件的级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-text">DOM事件模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81-api-%E6%96%B9%E6%B3%95"><span class="toc-text">Event对象的常见 api 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-text">事件委托</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E5%90%91%E2%AD%90"><span class="toc-text">this指向⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E2%AD%90"><span class="toc-text">JS数组常用方法总结⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-text">实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-text">实例方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for%E2%80%A6in%E5%92%8Cfor%E2%80%A6of%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">for…in和for…of有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B0%83%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">对调两个变量的多种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E6%B3%95"><span class="toc-text">解构赋值法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E6%B3%95"><span class="toc-text">临时变量法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%87%8F%E6%B3%95"><span class="toc-text">加减法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%B3%95"><span class="toc-text">数组法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B3%95"><span class="toc-text">对象法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%E6%B3%95"><span class="toc-text">按位异或法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E2%AD%90"><span class="toc-text">浅拷贝和深拷贝⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arguments"><span class="toc-text">arguments</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES6"><span class="toc-text">ES6+</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BigInt"><span class="toc-text">BigInt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol"><span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class%E4%B8%8E%E7%BB%A7%E6%89%BF%E2%AD%90"><span class="toc-text">Class与继承⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B0%83%E7%94%A8"><span class="toc-text">类定义与调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">严格模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="toc-text">构造函数与方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-%E5%AD%97%E6%AE%B5"><span class="toc-text">属性&#x2F;字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="toc-text">箭头函数与普通函数区别⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let%E3%80%81const%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="toc-text">let、const和var的区别⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#var"><span class="toc-text">var</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#let"><span class="toc-text">let</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-text">const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87"><span class="toc-text">变量提升和函数提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82"><span class="toc-text">函数传参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">模块化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">Iterator 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%EF%BC%8CWeakSet%EF%BC%8CMap%E5%92%8CWeakMap"><span class="toc-text">Set，WeakSet，Map和WeakMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakSet"><span class="toc-text">WeakSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakMap"><span class="toc-text">WeakMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-text">异步编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%AD%90"><span class="toc-text">事件循环机制⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95%E3%80%81%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-text">展开语法、剩余参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81"><span class="toc-text">手写代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E2%AD%90"><span class="toc-text">new⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call%E3%80%81apply%E3%80%81bind%E5%8C%BA%E5%88%AB"><span class="toc-text">call、apply、bind区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-call"><span class="toc-text">模拟实现 call</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81"><span class="toc-text">防抖&#x2F;节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof"><span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-1"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-text">原型链继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">借用构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-text">原型式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-text">寄生式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-text">寄生组合式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%85%A5%E6%96%B9%E5%BC%8F%E7%BB%A7%E6%89%BF%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-text">混入方式继承多个对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6%E7%B1%BB%E7%BB%A7%E6%89%BFextends"><span class="toc-text">ES6类继承extends</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise"><span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-text">如何实现数组扁平化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B0%E6%96%B9%E6%B3%95-flat-depth"><span class="toc-text">ES6提供的新方法 flat(depth)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce%E6%96%B9%E6%B3%95-%E9%80%92%E5%BD%92"><span class="toc-text">reduce方法 递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E9%93%BA%E6%95%B0%E7%BB%84%E8%BD%AC%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="toc-text">平铺数组转树形结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84shuffle"><span class="toc-text">随机打乱数组shuffle</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">计算机网络和浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">计算机网络体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-text">传输层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="toc-text">网络接口层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-text">数据链路层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-text">物理层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BD%91%E7%BB%9C%E8%A6%81%E5%88%86%E5%B1%82%EF%BC%9F"><span class="toc-text">为什么网络要分层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-text">网络通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E2%AD%90"><span class="toc-text">HTTP⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E6%96%B9%E6%B3%95"><span class="toc-text">HTTP方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GET-%E4%B8%8E-POST"><span class="toc-text">GET 与 POST</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F"><span class="toc-text">参数传递方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E4%B8%8D%E5%90%8C"><span class="toc-text">参数长度限制不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%92%8C%E5%B9%82%E7%AD%89"><span class="toc-text">安全和幂等</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8D%E5%90%8C%EF%BC%88%E4%BC%A0%E8%BE%93%E7%9A%84%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="toc-text">安全性不同（传输的角度）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%B8%8D%E5%90%8C"><span class="toc-text">缓存机制不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%B6%88%E8%80%97%E4%B8%8D%E5%90%8C"><span class="toc-text">时间消耗不同</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HEAD"><span class="toc-text">HEAD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUT"><span class="toc-text">PUT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DELETE"><span class="toc-text">DELETE</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%BC%93%E5%AD%98"><span class="toc-text">HTTP缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%EF%BC%88%E5%BC%BA%E7%BC%93%E5%AD%98%E3%80%81%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%89"><span class="toc-text">基本流程（强缓存、协商缓存）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-text">缓存发展历程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89Etag"><span class="toc-text">为什么要有Etag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%88%B7%E6%96%B0%E7%9A%84%E8%AF%B7%E6%B1%82%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">不同刷新的请求执行过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%89%B9%E6%80%A7"><span class="toc-text">HTTP特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%88%83%E5%89%91"><span class="toc-text">双刃剑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS"><span class="toc-text">HTTP和HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-text">区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E4%BC%98%E7%82%B9"><span class="toc-text">HTTPS优点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86"><span class="toc-text">混合加密</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-text">数字证书</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95"><span class="toc-text">摘要算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E8%BF%9E%E6%8E%A5"><span class="toc-text">HTTPS连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1%E3%80%81HTTP-2%E3%80%81HTTP-3%E6%BC%94%E5%8F%98"><span class="toc-text">HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3演变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-1"><span class="toc-text">HTTP&#x2F;1.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-2"><span class="toc-text">HTTP&#x2F;2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-3"><span class="toc-text">HTTP&#x2F;3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax%E2%AD%90"><span class="toc-text">Ajax⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9FAjax"><span class="toc-text">原生Ajax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fetch"><span class="toc-text">Fetch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise%E5%B0%81%E8%A3%85axios"><span class="toc-text">Promise封装axios</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E2%AD%90"><span class="toc-text">跨域通信⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">跨域解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSONP"><span class="toc-text">JSONP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS"><span class="toc-text">CORS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ECORS%E7%9A%84-cookie-%E9%97%AE%E9%A2%98"><span class="toc-text">关于CORS的 cookie 问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86"><span class="toc-text">代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Node%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-text">Node中间件代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#React%E4%B8%AD%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86"><span class="toc-text">React中配置代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">Nginx反向代理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocket"><span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XSS%E5%92%8CCSRF"><span class="toc-text">XSS和CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS"><span class="toc-text">XSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%98%B2%E8%8C%83%E6%96%B9%E6%B3%95"><span class="toc-text">常用防范方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF"><span class="toc-text">CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CSRF%E4%B8%8E-XSS-%E5%8C%BA%E5%88%AB"><span class="toc-text">CSRF与 XSS 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1"><span class="toc-text">防御</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-UDP"><span class="toc-text">TCP UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-text">TCP 协议如何保证可靠传输</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%E2%AD%90"><span class="toc-text">从URL输入到页面展现到底发生什么？⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URL%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">URL是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%EF%BC%88DNS%EF%BC%89"><span class="toc-text">域名解析（DNS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">TCP三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E5%BC%80TCP%E8%BF%9E%E6%8E%A5-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">断开TCP连接 四次挥手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2"><span class="toc-text">浏览器解析渲染页面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81%EF%BC%88Repaint%E3%80%81Reflow%EF%BC%89"><span class="toc-text">浏览器的重绘与回流（Repaint、Reflow）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%B5%81-%E9%87%8D%E6%8E%92reflow"><span class="toc-text">回流&#x2F;重排reflow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BB%98Repaint"><span class="toc-text">重绘Repaint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81-%E9%87%8D%E7%BB%98%E8%87%B3%E5%B0%91%E6%9C%80%E5%B0%8F%E5%8C%96%E5%AE%83%E4%BB%AC%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-text">如何避免回流&#x2F;重绘至少最小化它们对性能的影响？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-dom-%E6%A0%91%E4%B8%AD%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%8E%E5%9C%B0%E6%9B%B4%E6%94%B9%E7%B1%BB"><span class="toc-text">在 dom 树中尽可能低地更改类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E8%AE%BE%E7%BD%AE%E5%A4%9A%E4%B8%AA%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F"><span class="toc-text">避免设置多个内联样式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%8A%A8%E7%94%BB%E5%88%B0fixed%E6%88%96absolute%E7%9A%84%E5%AE%9A%E4%BD%8D"><span class="toc-text">应用动画到fixed或absolute的定位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E8%A1%A8%E6%A0%BC%E8%BF%9B%E8%A1%8C%E5%B8%83%E5%B1%80%EF%BC%88%E6%88%96%E8%AE%BE%E7%BD%AE%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80%E5%9B%BA%E5%AE%9A%EF%BC%89"><span class="toc-text">避免使用表格进行布局（或设置表格布局固定）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E9%A2%91%E7%B9%81%E6%93%8D%E4%BD%9CDOM"><span class="toc-text">避免频繁操作DOM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E2%AD%90"><span class="toc-text">Cookie、Session、Token、JWT⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie%E3%80%81sessionStorage%E3%80%81localStorage-%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E2%AD%90"><span class="toc-text">Cookie、sessionStorage、localStorage 详解及应用场景⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie"><span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#localStorage-amp-amp-sessionStorage"><span class="toc-text">localStorage &amp;&amp; sessionStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IndexedDB"><span class="toc-text">IndexedDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">前端性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC"><span class="toc-text">基本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9"><span class="toc-text">压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CDN"><span class="toc-text">CDN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">懒加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">预加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iconfont"><span class="toc-text">iconfont</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-text">组件渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-text">缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EAndroid%E7%9A%84%E7%94%B5%E5%AD%90%E8%AF%8D%E5%85%B8%E8%AE%BE%E8%AE%A1"><span class="toc-text">基于Android的电子词典设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E7%88%AC%E5%8F%96"><span class="toc-text">单词数据的爬取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Requests"><span class="toc-text">Requests</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XPath"><span class="toc-text">XPath</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-text">多进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQLite"><span class="toc-text">SQLite</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1"><span class="toc-text">界面设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API%E6%88%96SDK"><span class="toc-text">API或SDK</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-text">API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDK"><span class="toc-text">SDK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM"><span class="toc-text">MVVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-MVVM"><span class="toc-text">Android MVVM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">React商城后台管理系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%9A%E5%AE%A2"><span class="toc-text">博客</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript"><span class="toc-text">TypeScript</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%A0%E9%81%93"><span class="toc-text">渠道</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/d7c881ac.html" title="Express"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/5.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="Express"></a><div class="content"><a class="title" href="/posts/d7c881ac.html" title="Express">Express</a><time datetime="2022-03-15T08:11:03.000Z" title="发表于 2022-03-15 16:11:03">2022-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/783ce8a9.html" title="移动端适配"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/15.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="移动端适配"></a><div class="content"><a class="title" href="/posts/783ce8a9.html" title="移动端适配">移动端适配</a><time datetime="2022-03-12T07:04:52.000Z" title="发表于 2022-03-12 15:04:52">2022-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/50cb7bb5.html" title="Cookie、Session、Token、JWT"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/3.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="Cookie、Session、Token、JWT"></a><div class="content"><a class="title" href="/posts/50cb7bb5.html" title="Cookie、Session、Token、JWT">Cookie、Session、Token、JWT</a><time datetime="2022-03-11T03:11:11.000Z" title="发表于 2022-03-11 11:11:11">2022-03-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5c76f87e.html" title="XSS和CSRF"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/12.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="XSS和CSRF"></a><div class="content"><a class="title" href="/posts/5c76f87e.html" title="XSS和CSRF">XSS和CSRF</a><time datetime="2022-03-10T04:01:23.000Z" title="发表于 2022-03-10 12:01:23">2022-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/bb028bb1.html" title="HTML语义化"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/11.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="HTML语义化"></a><div class="content"><a class="title" href="/posts/bb028bb1.html" title="HTML语义化">HTML语义化</a><time datetime="2022-03-04T03:14:22.000Z" title="发表于 2022-03-04 11:14:22">2022-03-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Leslie Waong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:""},null))},e=()=>{twikoo.getCommentsCount({envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))},n=(n=!1)=>{"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})};btf.loadComment(document.getElementById("twikoo-wrap"),n)})()</script></div><div class="aplayer no-destroy" data-id="6995412795" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="auto" data-autoplay="true" muted></div><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":0,"vOffset":0},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body></html>