<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>前端 | Leslie Waong</title><meta name="keywords" content="CSS,HTML,JS,框架,计算机网络,浏览器"><meta name="author" content="Leslie Waong"><meta name="copyright" content="Leslie Waong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTML&amp;CSS语义化的理解⭐语义化，指选择合乎语义的标签，使文本内容的结构化，便于开发者阅读、维护和写出更优雅的代码，同时让浏览器的爬虫和辅助技术更好的解析。 常用的一些语义化标签 &lt;h1&gt;~&lt;h6&gt; ，标题 &lt;p&gt; 段落 &lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;，无序、有序列表 &lt;table&gt;、&lt;thead&amp;"><meta property="og:type" content="article"><meta property="og:title" content="前端"><meta property="og:url" content="https://lesliewaong.top/posts/f3b98ae9.html"><meta property="og:site_name" content="Leslie Waong"><meta property="og:description" content="HTML&amp;CSS语义化的理解⭐语义化，指选择合乎语义的标签，使文本内容的结构化，便于开发者阅读、维护和写出更优雅的代码，同时让浏览器的爬虫和辅助技术更好的解析。 常用的一些语义化标签 &lt;h1&gt;~&lt;h6&gt; ，标题 &lt;p&gt; 段落 &lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;，无序、有序列表 &lt;table&gt;、&lt;thead&amp;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/8.webp"><meta property="article:published_time" content="2021-07-12T05:14:52.000Z"><meta property="article:modified_time" content="2022-04-08T07:30:01.194Z"><meta property="article:author" content="Leslie Waong"><meta property="article:tag" content="CSS"><meta property="article:tag" content="HTML"><meta property="article:tag" content="JS"><meta property="article:tag" content="框架"><meta property="article:tag" content="计算机网络"><meta property="article:tag" content="浏览器"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/8.webp"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg"><link rel="canonical" href="https://lesliewaong.top/posts/f3b98ae9"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"一年之内的产物",messageNext:"技术可能存在过期"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Leslie Waong",link:"链接: ",source:"来源: Leslie Waong",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"前端",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-04-08 15:30:01"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px");const a=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};a(),document.addEventListener("pjax:complete",a)})(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Leslie Waong" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">109</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/8.webp)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leslie Waong</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-12T05:14:52.000Z" title="发表于 2021-07-12 13:14:52">2021-07-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-08T07:30:01.194Z" title="更新于 2022-04-08 15:30:01">2022-04-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">82.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>280分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="前端"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML&amp;CSS"></a>HTML&amp;CSS</h1><h2 id="语义化的理解⭐"><a href="#语义化的理解⭐" class="headerlink" title="语义化的理解⭐"></a>语义化的理解⭐</h2><p><strong>语义化</strong>，指选择合乎语义的标签，使<strong>文本内容的结构化</strong>，便于<strong>开发者阅读</strong>、<strong>维护和写出更优雅的代码，同时让浏览器的爬虫和辅助技术更好的解析。</strong></p><h3 id="常用的一些语义化标签"><a href="#常用的一些语义化标签" class="headerlink" title="常用的一些语义化标签"></a>常用的一些语义化标签</h3><ul><li><code>&lt;h1&gt;~&lt;h6&gt;</code> ，标题</li><li><code>&lt;p&gt;</code> 段落</li><li><code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>，无序、有序列表</li><li><code>&lt;table&gt;</code>、<code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;td&gt;</code>、<code>&lt;th&gt;</code>、<code>&lt;caption&gt;</code>， 表格</li></ul><h3 id="被滥用的语义化标签"><a href="#被滥用的语义化标签" class="headerlink" title="被滥用的语义化标签"></a>被滥用的语义化标签</h3><ul><li><p><code>p</code>：不要用来增加额外的空白段落，应使用<code>CSS</code>的<code>margin/padding</code>来实现；</p></li><li><p><code>&lt;h1&gt;~&lt;h6&gt;</code>：该标签可以使文本字体变大，变粗，但如果文本<strong>并非是标题</strong>，应该使用<code>CSS font-weight font-size</code>；</p></li><li><p>不要将<code>&lt;b&gt;</code>元素与 <code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>或<code>&lt;mark&gt;</code>元素混淆。</p><ul><li><code>&lt;strong&gt;</code>用来对一个句子的部分增加<strong>重要性</strong>。（粗体）</li><li><code>&lt;em&gt;</code>用于改变一个句子的意思，<strong>强调</strong>某些文本。（斜体）</li><li><code>&lt;mark&gt;</code>表示上下文的<strong>关联性</strong>。（高亮）</li><li><code>&lt;b&gt;</code>用于吸引读者的注意到该元素的内容上，仅在没有其他合适的元素时使用它，如摘要中的关键字（粗体）</li></ul><p>如果不是出于语义目的而使用 <code>&lt;b&gt;</code> 元素，那么让文本显示粗体更好的方式是使用将 CSS 的 <code>font-weight</code> 属性设置为 <code>&quot;bold&quot;</code>。</p></li></ul><h3 id="HTML5新增"><a href="#HTML5新增" class="headerlink" title="HTML5新增"></a>HTML5新增</h3><p><code>header</code>：头部,包裹目录部分、搜索框、一个nav或者任何相关的logo</p><p><code>main</code>：主体,唯一的，其后代元素常常包括<code>&lt;article&gt;</code></p><p><code>nav</code>：导航,一般和<code>ul</code>、<code>li</code>配合做导航栏</p><p><code>footer</code>：底部,通常包含作者、版权信息或者相关链接等</p><p><code>aside</code>：侧边栏,作为主要内容的附属信息，如索引，词条列表</p><p><code>article</code>：独立文章,通常带有标题，当article内嵌article时，里外层的内容应该是相关的</p><p><code>section</code>：独立区块,它是整体的一部分，或者是文章的一节，一般来说section也会带有标题</p><p><code>div</code>：作为一个没有任何语义，仅仅是用来构建结构的元素，是<strong>最适合做容器的标签。</strong></p><h2 id="lt-img-gt-的title和alt有什么区别"><a href="#lt-img-gt-的title和alt有什么区别" class="headerlink" title="&lt;img&gt;的title和alt有什么区别"></a><code>&lt;img&gt;</code>的<code>title</code>和<code>alt</code>有什么区别</h2><ul><li>通常当鼠标滑动到元素上的时候显示<code>title</code>。</li><li><code>alt</code>是<code>&lt;img&gt;</code>的<strong>特有属性</strong>，是<strong>图片内容的等价描述</strong>，用于图片无法加载时显示、读屏器阅读图片。可提高图片可访问性，除了纯装饰图片外都必须设置有意义的值，<strong>搜索引擎</strong>会重点分析。</li></ul><h2 id="H5的新特性有哪些⭐"><a href="#H5的新特性有哪些⭐" class="headerlink" title="H5的新特性有哪些⭐"></a>H5的新特性有哪些⭐</h2><ul><li><p>新增语义化标签。</p></li><li><p>H5提供了<code>sessionStorage</code>、<code>localStorage</code>和<code>indexedDB</code>加强本地存储。</p></li><li><p>input标签新增属性:</p><ul><li><p>placeholder属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>autofocus属性，页面只能有一个,自动获得焦点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">autofocus</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>canvas</code> 是 HTML5 新定义的标签，通过使用脚本（通常是 JavaScript）绘制图形。<code>&lt;canvas&gt;</code> 标签只是图形容器，相当于一个画布，<code>canvas</code> 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成，相当于使用画笔在画布上画画。</p><p>默认情况下，<code>&lt;canvas&gt;</code> 没有边框和内容。默认是一个 300*150 的画布，所以我们创建了 <code>&lt;canvas&gt;</code> 之后要对其设置宽高。</p><p>我们可以通过html属性‘width’，‘height’来设置canvas的宽高，不可以通过 css 属性来设置宽高。因为通过 css 属性设置的宽高会使 canvas 内的图像按照 300*150 时的比例放大或缩小。</p></li><li><p>地理(<code>Geolocation</code>) API</p></li><li><p>音频、视频API(<code>audio</code>,<code>video</code>)</p></li><li><p><code>webworker</code>, <code>websocket</code></p><ul><li><p><code>webworker</code>是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。</p></li><li><p><code>WebSocket</code> 使用<code>ws</code>或<code>wss</code>协议，<code>Websocket</code>是一个<strong>持久化的协议</strong>，相对于HTTP这种非持久的协议来说。WebSocket API最伟大之处在于<strong>服务器和客户端可以在给定的时间范围内的任意时刻，相互推送信息</strong>。<code>WebSocket</code>并<strong>不限于以Ajax(或XHR)方式通信</strong>，因为Ajax技术需要客户端发起请求，而WebSocket服务器和客户端可以彼此相互推送信息；XHR受到域的限制，而<code>WebSocket</code><strong>允许跨域通信</strong>。</p></li></ul></li></ul><h2 id="iframe优缺点"><a href="#iframe优缺点" class="headerlink" title="iframe优缺点"></a>iframe优缺点</h2><p>iframe可以在一个网站里面嵌入另一个网站的内容。</p><h3 id="iframe的优点"><a href="#iframe的优点" class="headerlink" title="iframe的优点"></a>iframe的优点</h3><ul><li>iframe能够原封不动的把嵌入的网页展现出来。</li><li>如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。</li><li>网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。</li><li>如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。</li></ul><h3 id="iframe的缺点"><a href="#iframe的缺点" class="headerlink" title="iframe的缺点"></a>iframe的缺点</h3><ul><li>会产生很多页面，不容易管理。</li><li>iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。</li><li>代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以<strong>使用iframe会不利于搜索引擎优化。</strong></li><li>iframe 里面的样式、脚本资源，会增加请求次数，对于大型网站是不可取的。</li><li>iframe 会阻碍页面的 <code>onload</code> 事件，给用户页面加载很慢的感觉。</li></ul><h2 id="简述一下src与href的区别"><a href="#简述一下src与href的区别" class="headerlink" title="简述一下src与href的区别"></a>简述一下src与href的区别</h2><ul><li><code>src</code>是<code>source</code>的缩写，<strong>指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置</strong>；在请求<code>src</code>资源时会将其指向的资源下载并应用到文档内，例如<code>js</code>脚本，<code>img</code>图片和<code>iframe</code>等元素</li><li>img、script、input、iframe</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> =<span class="string">”js.js”</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>js脚本阻塞渲染并不是因为他是src引入的，而是因为他有可能改变DOM树或CSSOM树。</p><p>是否阻塞跟href和src没有关系，跟浏览器实现最佳体检的设计有关。</p></blockquote><ul><li><code>href</code>是<code>Hypertext Reference</code>的缩写，<strong>指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接</strong></li><li>link、a</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">”common.css”</span> <span class="attr">rel</span>=<span class="string">”stylesheet”/</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。</p></blockquote><h2 id="知道的网页制作会用到的图片格式有哪些"><a href="#知道的网页制作会用到的图片格式有哪些" class="headerlink" title="知道的网页制作会用到的图片格式有哪些"></a>知道的网页制作会用到的图片格式有哪些</h2><p><code>png-8</code>，<code>png-24</code>，<code>jpeg</code>，<code>gif</code>，<code>svg</code></p><p>Webp：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。</p><p>在<strong>质量相同</strong>的情况下，<code>WebP</code>格式图像的体积要比JPEG格式图像小<code>40%</code></p><h2 id="inline，block，inline-block的区别⭐"><a href="#inline，block，inline-block的区别⭐" class="headerlink" title="inline，block，inline-block的区别⭐"></a>inline，block，inline-block的区别⭐</h2><blockquote><p>HTML 标准中块级元素和行内元素的区别至高出现在 4.01 标准中。在 HTML5，这种区别被一个更复杂的内容类别代替。</p><p>”块级“类别大致相当于 HTML5 中的<code>Flow content(流内容)</code>类别，而”行内“类别相当于 HTML5 中的<code>Phrasing content(短语内容)</code>类别，不过除了这两个还有其他类别。</p></blockquote><p>行内元素：</p><ul><li>一般情况下<strong>只能包含数据和其他行内元素</strong>。</li><li>一般是<strong>内容的容器</strong>。</li></ul><p>块级元素：</p><ul><li><strong>包含行内元素和其他块级元素</strong>。</li><li>适合做<strong>布局</strong>。</li></ul><h3 id="块级元素-block"><a href="#块级元素-block" class="headerlink" title="块级元素(block)"></a>块级元素(block)</h3><ul><li><p>水平（独占一行，<strong>占据其父元素（容器）的整个水平空间</strong>），垂直空间等于其<strong>内容高度</strong>，因此创建了一个“块”。</p></li><li><p><strong>可以设置宽高</strong>。即使设置宽度也还是<strong>独占一行</strong>。</p><p>当指定了 <code>width</code> 和 <code>height</code> 的值时，内容超出块级元素的尺寸就会<strong>溢出</strong>，这时块级元素要呈现什么行为要看其 <code>overflow</code> 的值（<code>visible,hidden,scroll</code>)</p></li><li><p>可以设置<code>margin</code>和<code>padding</code>属性。</p></li></ul><p>举例：</p><p><code>h1-h6、div、p</code></p><p><code>（HTML5）header、footer、article、aside、section</code></p><h3 id="行内元素-inline"><a href="#行内元素-inline" class="headerlink" title="行内元素(inline)"></a>行内元素(inline)</h3><ul><li><p><strong>可以多个标签存在一行</strong></p></li><li><p><strong>对宽高属性值不生效</strong>，<strong>完全靠内容撑开宽高</strong>。</p></li><li><p>竖直方向的<code>margin</code>不起作用。</p></li><li><p>行内元素竖直方向的<code>padding</code>会起作用，不过就像脱离了标准流一样，并不会占据位置，并且还把其他元素给盖住了。</p><p>但是，假如inline的元素没有内容，“<code>padding-top、padding-bottom</code>“将不起作用。如果想要起作用，只需要给<code>padding-left</code>或者<code>padding-right</code>设置一个值，或者当inline的元素有内容时就会起作用。</p></li></ul><p>举例：</p><p><code>span</code>、<code>button</code>、<code>input</code>等</p><h3 id="行内块元素-inline-block"><a href="#行内块元素-inline-block" class="headerlink" title="行内块元素(inline-block)"></a>行内块元素(inline-block)</h3><ul><li><p><strong>既可以设置宽高，又可以和其他行内元素并排</strong>。</p></li><li><p>当<code>inline-block</code>碰到同类（inline-block)时，谁的上下margin、padding或line-height大，就听谁的。除非它是inline，因为inline的竖直方向margin是不起作用的，且inline的竖直方向padding是不占空间的。</p></li><li><p><code>inline</code>和<code>inline-block</code>会引起<strong>间距</strong>。这个间距是有<strong>空格</strong>或<strong>换行</strong>导致的。解决方法一：<strong>将空格直接删除，放到一行</strong></p></li></ul><h3 id="行内元素与块状元素之间的转换"><a href="#行内元素与块状元素之间的转换" class="headerlink" title="行内元素与块状元素之间的转换"></a>行内元素与块状元素之间的转换</h3><ul><li><strong>float:</strong> 行内=&gt;块。</li><li><strong>position:</strong> <code>position:absolute/fixed</code>，行内=&gt;块。</li><li><strong>display:</strong><ul><li><code>display:inline;</code></li><li><code>display:block;</code></li><li><code>display:inline-block;</code></li></ul></li></ul><h2 id="居中布局⭐"><a href="#居中布局⭐" class="headerlink" title="居中布局⭐"></a>居中布局⭐</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ul><li><p><code>text-align: center</code></p><ul><li>设置<strong>块元素或表格单元格</strong>中<strong>内容</strong>的水平对齐方式。</li><li><strong>不能直接用于行内元素</strong> 。</li><li>另外，这个内容不一定是行内元素，块元素中有h1(块元素)一样可以实现效果。</li></ul></li><li><p><code>margin: 0 auto</code></p><ul><li>计算元素对应方向上应该获得的<strong>剩余空间</strong>大小。</li><li>因为块级元素设置宽度后仍占据一行空间，<code>margin: 0 auto</code>会将这一行的剩余空间平均分配给左右外边距。</li><li><code>margin:auto</code> 能使<strong>块级元素</strong>水平居中，但是不能垂直居中，因为<strong>垂直方向上默认没有剩余的空间</strong>。</li><li><code>margin:auto</code> <strong>行内元素</strong>既不能水平居中也不能垂直居中，因为行内元素<strong>水平垂直方向上默认都没有剩余的空间</strong>。</li></ul></li></ul><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ul><li><code>line-height: 父元素高度</code><ul><li>适合文本。</li></ul></li></ul><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><ul><li><code>flex + justify-content + align-items</code></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但对<strong>子元素图片、文字</strong>都有时，<strong>竖直方向</strong>的对齐会有差异，可以<strong>父元素开启Flex布局</strong>，图片子元素设置<code>align-self: center;</code>，文字子元素使用<code>line-height</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">align-self</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>absolute + transform</code></li></ul><p><code>top,left</code>跟根据<strong>父元素的宽和高</strong>偏移的。<code>top: 50%;left: 50%;</code> 元素左上角居中。</p><p><code>transform: translate(-50%, -50%);</code>是根据<strong>自身的宽高</strong>偏移的。</p><p><strong>注意子元素是否存在margin</strong>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wp</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;  </span><br><span class="line">&#125;     </span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li><strong>网格布局（Grid）</strong>是最强大的 CSS 布局方案。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    justify-items: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.small</span> &#123;</span><br><span class="line">    justify-self: center;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他：</p><p><code>absolute(top:50%;left:50%;) + 负margin</code></p><p><code>absolute(top:0;left:0;right:0;bottom:0;)+margin:auto</code></p><h2 id="Flex⭐"><a href="#Flex⭐" class="headerlink" title="Flex⭐"></a>Flex⭐</h2><p>Flex是Flexible Box的缩写，翻译成中文就是“弹性盒子”，用来为盒模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。</p><p>采用Flex布局的元素，被称为Flex容器(flex container)，简称“容器”。</p><p>其所有子元素自动成为容器成员，成为Flex项目(Flex item)，简称“项目”。</p><p>容器默认存在两根主轴：<strong>水平方向</strong>主轴(main axis)和垂直方向交叉轴(cross axis)，<strong>默认项目按主轴排列</strong>。</p><h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p><strong>flex-direction（主轴的方向）和flex-wrap（换行）的简写，默认row nowrap</strong></p><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p><strong>定义项目在主轴上的对齐方式。</strong></p><p><code>justify-content:center</code> 默认用作水平居中</p><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p><strong>定义在交叉轴上的对齐方式</strong></p><p><code>align-items:center</code> 默认用作垂直居中</p><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p><strong>定义多根轴线的对齐方式</strong> 必须通过<code>flex-wrap</code>先有多根轴线</p><h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>允许单个项目有与其他项目不一样的对齐方式，常用于居中布局。</p><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p><strong>==flex-grow，flex-shrink和flex-basis的简写==</strong></p><blockquote><p>默认值为0 1 auto，<strong>第一个属性必须</strong>，后两个属性可选。</p></blockquote><p>flex-grow定义项目的放大比例（<strong>容器宽度&gt;元素总宽度时如何伸展</strong>），<code>flex-grow：1</code>或<code>flex：1</code>，经常用作自适应布局。</p><p>flex-shrink定义了项目的缩小比例（<strong>容器宽度&lt;元素总宽度时如何收缩</strong>），默认为1，即如果空间不足，该项目将缩小。</p><p>flex-basis设置的是<strong>元素在主轴上的初始尺寸</strong>，所谓的初始尺寸就是元素在<code>flex-grow</code>和<code>flex-shrink</code>生效前的尺寸。浏览器根据这个属性，计算主轴是否有多余空间。</p><p>一些属性有：</p><ul><li>flex: 1 = flex: 1 1 0%</li><li>flex: 2 = flex: 2 1 0%</li><li>flex: auto = flex: 1 1 auto</li><li>flex: none = flex: 0 0 auto，常用于固定尺寸不伸缩</li></ul><p><code>flex:1</code> 和 <code>flex:auto</code> 的区别，可以归结于<code>flex-basis:0</code>和<code>flex-basis:auto</code>的区别。</p><p>当设置为<code>0</code>时（绝对弹性元素），此时相当于告诉<code>flex-grow</code>和<code>flex-shrink</code>在伸缩的时候不需要考虑我的尺寸。</p><p>当设置为<code>auto</code>时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑。</p><h2 id="三栏布局⭐"><a href="#三栏布局⭐" class="headerlink" title="三栏布局⭐"></a>三栏布局⭐</h2><blockquote><p>问题：假设容器的高度默认100px，请写出<strong>三栏布局</strong>，其中左栏、右栏的宽度各为300px，中间的宽度自适应。</p></blockquote><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>左侧设置<strong>左浮动</strong>，右侧设置<strong>右浮动</strong>即可，中间会自动地自适应。</p><p>兼容性较好；脱离文档流，浮动带来影响。</p><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>左侧设置为绝对定位， <code>left：0px</code>。右侧设置为绝对定位， <code>right：0px</code>。</p><p>中间设置为绝对定位，<code>left 和right 都为300px</code>，即可。中间的宽度会自适应。</p><p>快捷；脱离文档流。</p><h3 id="Flexbox布局"><a href="#Flexbox布局" class="headerlink" title="Flexbox布局"></a>Flexbox布局</h3><p>将父容器设置<code>display：flex</code>，侧边栏大小固定后，将内容区<code>flex：1</code>，内容区则会自动放大占满剩余空间。</p><p>比较完美的解决了浮动和绝对定位的问题。在移动端比较常用。可能有兼容性问题（IE）。</p><h3 id="表格布局table"><a href="#表格布局table" class="headerlink" title="表格布局table"></a>表格布局table</h3><p>设置整个容器的宽度为<code>100%</code>，<code>display: table;</code>，设置三个部分均为表格单元<code>display: table-cell;</code>，然后左边的单元格为 <code>300px</code>，右边的单元格为 <code>300px</code>，即可。中间的单元格会自适应。</p><p>兼容性非常好；三个部分都当成了<strong>单元格</strong>来对待，此时，如果中间的部分变高了，其会部分也会被迫调整高度。</p><h3 id="网格布局-grid"><a href="#网格布局-grid" class="headerlink" title="网格布局 grid"></a>网格布局 grid</h3><p>设置容器为网格布局<code>display: grid</code>，宽度为<code>100%</code>，并设置<code>grid-template-columns: 300px auto 300px</code>。</p><p>CSS3中引入的布局，功能强大。</p><h2 id="对CSS盒模型的认识⭐"><a href="#对CSS盒模型的认识⭐" class="headerlink" title="对CSS盒模型的认识⭐"></a>对CSS盒模型的认识⭐</h2><h3 id="块级盒子（Block-box）-和-内联盒子（Inline-box）"><a href="#块级盒子（Block-box）-和-内联盒子（Inline-box）" class="headerlink" title="块级盒子（Block box） 和 内联盒子（Inline box）"></a>块级盒子（Block box） 和 内联盒子（Inline box）</h3><p>在 CSS 中我们广泛地使用两种“盒子” —— <strong>块级盒子</strong> (<strong>block box</strong>) 和 <strong>内联盒子</strong> (<strong>inline box</strong>)。这两种盒子会在<strong>页面流</strong>（page flow）和<strong>元素之间的关系</strong>方面表现出不同的行为:</p><p>一个被定义成块级的（block）盒子会表现出以下行为:</p><ul><li>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，<strong>在绝大数情况下意味着盒子会和父容器一样宽</strong></li><li>每个盒子都会<strong>换行</strong></li><li><code>width</code>和 <code>height</code> 属性可以发挥作用</li><li>内边距（<code>padding</code>）, 外边距（<code>margin</code>） 和 边框（<code>border</code>） 会将其他元素从当前盒子周围“推开”</li></ul><p>除非特殊指定，诸如标题(<code>&lt;h1&gt;</code>等)和段落(<code>&lt;p&gt;</code>)默认情况下都是块级的盒子。</p><p>如果一个盒子对外显示为 <code>inline</code>，那么他的行为如下:</p><ul><li>盒子<strong>不会产生换行</strong>。</li><li><code>width</code>和 <code>height</code> 属性将不起作用。</li><li><strong>垂直方向的内边距、外边距以及边框</strong>会被应用但是<strong>不会</strong>把其他处于 <code>inline</code> 状态的盒子推开。</li><li><strong>水平方向的内边距、外边距以及边框</strong>会被应用且<strong>会</strong>把其他处于 <code>inline</code> 状态的盒子推开。</li></ul><p>用做链接的 <code>&lt;a&gt;</code> 元素、 <code>&lt;span&gt;</code>、 <code>&lt;em&gt;</code> 以及 <code>&lt;strong&gt;</code> 都是默认处于 <code>inline</code> 状态的。</p><p>我们通过对盒子<code>display</code> 属性的设置，比如 <code>inline</code> 或者 <code>block</code> ，来控制盒子的外部显示类型。</p><h3 id="什么是CSS-盒模型"><a href="#什么是CSS-盒模型" class="headerlink" title="什么是CSS 盒模型?"></a>什么是CSS 盒模型?</h3><p>完整的 CSS 盒模型应用于<strong>块级盒子</strong>，<strong>内联盒子只使用盒模型中定义的部分内容</strong>。</p><p>模型定义了盒的每个部分 —— <code>margin外边距</code>, <code>border边框</code>, <code>padding内边距</code>和 <code>content内容区</code> —— 合在一起就可以创建我们在页面上看到的内容。</p><h3 id="标准盒模型和IE盒子模型"><a href="#标准盒模型和IE盒子模型" class="headerlink" title="标准盒模型和IE盒子模型"></a>标准盒模型和IE盒子模型</h3><p>CSS标准盒模型和IE盒模型的区别：</p><ul><li><p>在 <strong>标准盒子模型</strong>中，<strong>width 和 height 指的是内容区域</strong>的宽度和高度。</p></li><li><p><strong>IE盒子模型</strong>中，<strong>width 和 height 指的是内容区域+padding+border</strong>的宽度和高度。</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置当前盒子为 标准盒模型（默认） */</span></span><br><span class="line"><span class="attribute">box-sizing</span>: content-box;</span><br><span class="line"><span class="comment">/* 设置当前盒子为 IE盒模型 */</span></span><br><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br></pre></td></tr></table></figure><h2 id="BFC⭐"><a href="#BFC⭐" class="headerlink" title="BFC⭐"></a>BFC⭐</h2><h3 id="BFC的概念"><a href="#BFC的概念" class="headerlink" title="BFC的概念"></a>BFC的概念</h3><p><strong>块级格式化上下文（Block Formatting Context，BFC）</strong> 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p><p><code>BFC</code>是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。</p><h3 id="如何生成BFC"><a href="#如何生成BFC" class="headerlink" title="如何生成BFC"></a>如何生成BFC</h3><ul><li><p><code>overflow: 不为visible，可以让属性是 hidden、auto</code>。【最常用】</p></li><li><p>浮动中：<code>float</code>的属性值不为none。意思是，<code>只要设置了浮动，当前元素就创建了BFC</code>。</p></li><li><p>绝对定位：<code>posiiton</code>是<code>absolute</code>或<code>fixed</code>。</p></li><li><p><code>display</code>为<code>inline-block</code>, <code>table-cell</code>, <code>table-caption</code>, <code>flex</code>, <code>inline-flex</code>、<code>grid</code>等</p></li></ul><h3 id="BFC-的应用"><a href="#BFC-的应用" class="headerlink" title="BFC 的应用"></a>BFC 的应用</h3><h4 id="解决margin重叠"><a href="#解决margin重叠" class="headerlink" title="解决margin重叠"></a>解决margin重叠</h4><p><strong>标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin</strong>(水平方向的margin是可以叠加的）。</p><p>且只会发生在块级元素，行内元素和行内块元素不会出现。</p><p><strong>儿子和父亲在竖直方向上为一个margin</strong>。</p><p>当父元素和子元素发生 margin 重叠时，解决办法：<strong>给子元素或父元素创建BFC</strong>。</p><h4 id="清除浮动影响（高度塌陷）"><a href="#清除浮动影响（高度塌陷）" class="headerlink" title="清除浮动影响（高度塌陷）"></a>清除浮动影响（高度塌陷）</h4><p><strong>父元素不设置高度默认是被子元素撑开的</strong>，当<strong>子元素浮动</strong>后，其会完全<strong>脱离文档流</strong>。</p><p>子元素从文档流中脱离，将会无法撑起父元素的高度，<strong>导致父元素的高度丢失</strong>。</p><p>父元素高度丢失以后，其下的元素会自动上移，导致<strong>页面的布局混乱</strong>。</p><p><strong>解决方案</strong></p><ul><li><p>给父亲增加 <code>overflow=hidden</code>属性即可，因为计算BFC的高度时，浮动元素也参与计算。</p></li><li><p>给父亲设置高度。正所谓<strong>有高度的盒子，才能关住浮动</strong>。</p></li><li><p><strong>伪元素+clear</strong></p><ul><li><p><code>clear</code> 属性指定一个元素是否必须移动(清除浮动后)到<strong>在它之前的浮动元素下面</strong>。</p></li><li><p><strong>要被清除的相关浮动元素</strong>指的是在相同<strong>块级格式化上下文</strong>中的<strong>前置浮动</strong>。</p></li><li><p>具体方法：</p><ul><li><p>给<strong>浮动元素的容器</strong>添加一个<code>clearfix</code>的class。</p></li><li><p>然后给这个class添加一个<code>::after</code>(用来创建一个伪元素，作为已选中元素的最后一个子元素)，</p></li><li><p>内容为空即没有高度看不到，但<code>display: block;</code>宽度仍然占满父元素，方便判断之前的左右浮动以清理。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block; <span class="comment">/* 确保该元素是一个块级元素 */</span></span><br><span class="line">    <span class="attribute">clear</span>: both;<span class="comment">/*清除浮动*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="CSS中link和-import区别"><a href="#CSS中link和-import区别" class="headerlink" title="CSS中link和@import区别"></a>CSS中link和@import区别</h2><p><strong>1.从属关系区别</strong><br><code>@import</code>是 <strong>CSS</strong> 提供的语法规则，只有<strong>导入样式表</strong>的作用；<code>link</code>是<strong>HTML</strong>提供的标签，不仅可以<strong>加载 CSS 文件</strong>，还可以<strong>定义 RSS、rel 连接属性</strong>等。</p><p><strong>2.加载顺序区别</strong><br>加载页面时，<code>link</code>标签引入的 CSS 被同时加载；<code>@import</code>引入的 CSS 将<strong>在页面加载完毕后被加载</strong>。</p><p><strong>3.兼容性区别</strong><br><code>@import</code>是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；<code>link</code>标签作为 HTML 元素，不存在兼容性问题。</p><p>操控DOM和样式的权重暂不理解。</p><h2 id="less⭐"><a href="#less⭐" class="headerlink" title="less⭐"></a>less⭐</h2><p>less是一门css的预处理语言</p><ul><li>less是一个css的增强版，通过less可以<strong>编写更少的代码实现更强大的样式</strong>，添加了许多的新特性：像对<strong>变量</strong>的支持、对<strong>mixin</strong>的支持… …</li><li>less的语法大体上和css语法一致，但是less中增添了许多对css的扩展，所以浏览器无法直接执行less代码，要执行必须向将<strong>less转换为css</strong>，然后再由浏览器执行</li></ul><p>特点</p><ul><li><strong>结构写的更加清晰</strong></li><li>变量 <code>@变量名</code></li><li><code>&amp;</code> 表示外层的父元素 <code>&amp;::after</code> <code>&amp;:hover</code></li><li><code>:extend()</code> 对当前选择器扩展指定选择器的样式（选择器分组）</li></ul><h2 id="script标签的defer和async属性有什么区别"><a href="#script标签的defer和async属性有什么区别" class="headerlink" title="script标签的defer和async属性有什么区别"></a>script标签的defer和async属性有什么区别</h2><h3 id="async标记"><a href="#async标记" class="headerlink" title="async标记"></a>async标记</h3><p>async标记告诉浏览器在等待js下载期间可以去干其他事，当js下载完成后会<strong>立即(尽快)执行</strong>，<strong>多条js可以并行下载</strong>。</p><p>async的好处是让多条js不会互相等待，<strong>下载期间浏览器会去干其他事(继续解析HTML等)<strong>，</strong>异步下载，异步执行</strong>。</p><h3 id="defer标记"><a href="#defer标记" class="headerlink" title="defer标记"></a>defer标记</h3><p>与async一样，defer标记告诉浏览器在等待js下载期间可以去干其他事，<strong>多条js可以并行下载</strong>，不过当js下载完成之后<strong>不会立即执行</strong>，而是会等待解析完整个HTML之后在开始执行，而且多条defer标记的js会<strong>按照顺序执行</strong>。</p><h3 id="到底该用哪个标记"><a href="#到底该用哪个标记" class="headerlink" title="到底该用哪个标记"></a>到底该用哪个标记</h3><p>如果两个script之间<strong>没有依赖关系</strong>并且<strong>无需等待页面解析</strong>的更加适合使用<code>async</code>，反之如果两个script之间<strong>有依赖关系</strong>，或者希望<strong>优先解析HTML</strong>，则<code>defer</code>更加适合。</p><p>defer脚本会在文档渲染完毕后，<code>DOMContentLoaded</code>事件调用前执行。</p><h2 id="CSS选择器优先级⭐"><a href="#CSS选择器优先级⭐" class="headerlink" title="CSS选择器优先级⭐"></a>CSS选择器优先级⭐</h2><p>CSS 中的权重，指的是<strong>选择器的优先级</strong>。</p><p>对同一HTML元素设置样式时，不同选择器的优先级不同，<strong>优先级低的样式将被高优先级的样式层叠掉</strong>。</p><p>CSS 权重优先级顺序简单表示为：</p><p><code>!important &gt; 内联样式(style=&quot;&quot;) &gt; ID (#id属性值) &gt; 类(.class属性值)、伪类(:nth-child())、属性([属性名]) &gt; 标签名(p&#123;&#125;)、伪元素(::after) &gt; 通配符(*)</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.red</span> <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: red;&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.green</span> <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: green;&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;green&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>p: 颜色<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>.red p</code>和<code>.green p</code>的选择器权重相同，那么谁在后面，最后就应用谁。所以最后是绿色。</p><p>如果<code>red</code>换成id选择器或者添加<code>!important</code>，就会变成红色。</p><p>对于同一个元素设置z-index不会对选择器权重产生影响，另外<code>z-index</code> 属性设定了一个<strong>定位元素及其后代元素</strong>或 <strong>flex 项目</strong>的 z-order。 当元素之间重叠的时候， z-index 较大的元素会覆盖较小的元素在上层进行显示。</p><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p><code>transparent</code> 关键字表示一个完全透明的颜色，即该颜色看上去将是背景色。</p><p>从技术上说，它是带有阿尔法通道为最小值的黑色，是 <code>rgba(0,0,0,0)</code> 的简写。</p><p><strong>RGB</strong></p><p>颜色可以使用红-绿-蓝（red-green-blue (RGB)）模式的两种方式被定义。</p><p>RGB颜色可以通过以<code>#</code>为前缀的<strong>十六进制字符</strong>和<strong>函数</strong>（<code>rgb()</code>、<code>rgba()</code>）标记表示。</p><p>在CSS 颜色标准 4 中，<code>rgba()</code>是<code>rgb()</code>的别称。在实行第4级标准的浏览器中，它们接受相同的参数，作用效果也相同。</p><p><code>rgb[a](R, G, B[, A])</code></p><p><code>rgb[a](R G B[ / A])</code> CSS 颜色级别 4 支持用空格分开的值。</p><p><code>R</code>（红）、<code>G</code>（绿）、<code>B</code> （蓝）可以是数字或百分比，255相当于100%。</p><p><code>A</code>（alpha）可以是<code>0</code>到<code>1</code>之间的数字，或者百分比，数字<code>1</code>相当于<code>100%</code>（完全不透明）。</p><p><strong>HSL</strong></p><p>颜色也可以使用 <code>hsl()</code> 函数符被定义为<strong>色相</strong>-<strong>饱和度</strong>-<strong>亮度</strong>（Hue-saturation-lightness）模式。</p><p>HSL 相比 RGB 的优点是更加直观：你可以估算你想要的颜色，然后微调。它也更易于创建相称的颜色集合。</p><p>（通过保持相同的色相并改变亮度/暗度和饱和度）。</p><p>HSL 颜色通过功能<code>hsl()</code>和<code>hsla()</code>符号表示。</p><p>从 CSS 颜色级别 4 开始，<code>hsla()</code>是<code>hsl()</code>在实现 4 级标准的浏览器中，它们接受相同的参数并以相同的方式运行。</p><p><code>hsl[a](H, S, L[, A])</code> <code>hsl[a](H S L[ / A])</code></p><p><code>H</code>(hue) 是度数deg，<code>S</code>（饱和度）和<code>L</code>（亮度）是百分比。</p><h2 id="HTML-页面的生命周期"><a href="#HTML-页面的生命周期" class="headerlink" title="HTML 页面的生命周期"></a>HTML 页面的生命周期</h2><p>HTML 页面的生命周期包含三个重要事件：</p><ul><li><strong>DOMContentLoaded</strong> —— <strong>浏览器已完全加载 HTML，并构建了 DOM 树</strong>，但像 <code>&lt;img&gt;</code> 和样式表之类的外部资源可能尚未加载完成。</li><li><strong>load</strong> —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。</li><li><strong>beforeunload/unload</strong> —— 当用户正在离开页面时。</li></ul><p>每个事件都是有用的：</p><ul><li>DOMContentLoaded 事件 —— DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。</li><li>load 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知了。</li><li>beforeunload 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。</li><li>unload 事件 —— 用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。</li></ul><h3 id="DOMContentLoaded-和脚本"><a href="#DOMContentLoaded-和脚本" class="headerlink" title="DOMContentLoaded 和脚本"></a>DOMContentLoaded 和脚本</h3><p>当浏览器处理一个 HTML 文档，并在文档中遇到 <code>&lt;script&gt;</code> 标签时，就会在继续构建 DOM 之前运行它。</p><p>这是一种防范措施，因为脚本可能想要修改 DOM，甚至对其执行 document.write 操作，所以 <strong>DOMContentLoaded 必须等待脚本执行结束</strong>。</p><p>此规则有两个例外：</p><ul><li>具有 <code>async</code> 特性的脚本<strong>不会阻塞</strong> DOMContentLoaded。</li><li>使用 <code>document.createElement(&#39;script&#39;)</code> 动态生成并添加到网页的脚本也<strong>不会阻塞</strong> DOMContentLoaded。</li></ul><h3 id="DOMContentLoaded-和样式"><a href="#DOMContentLoaded-和样式" class="headerlink" title="DOMContentLoaded 和样式"></a>DOMContentLoaded 和样式</h3><p><strong>外部样式表不会影响 DOM，因此 DOMContentLoaded 不会等待它们</strong>。</p><p>但这里有一个陷阱。<strong>如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成</strong>。</p><p>原因是，脚本可能想要获取元素的坐标和其他与样式相关的属性。因此，它必须等待样式加载完成。</p><p><strong>当 DOMContentLoaded 等待脚本时，它现在也在等待脚本前面的样式</strong>。</p><h3 id="浏览器内建的自动填充"><a href="#浏览器内建的自动填充" class="headerlink" title="浏览器内建的自动填充"></a>浏览器内建的自动填充</h3><p>Firefox，Chrome 和 Opera 都会在 DOMContentLoaded 中自动填充表单。</p><p>例如，如果页面有一个带有登录名和密码的表单，并且浏览器记住了这些值，那么在 DOMContentLoaded 上，浏览器会尝试自动填充它们（如果得到了用户允许）。</p><p>因此，如果 DOMContentLoaded 被需要加载很长时间的脚本延迟触发，那么自动填充也会等待。你可能在某些网站上看到过（如果你使用浏览器自动填充）—— 登录名/密码字段不会立即自动填充，而是在页面被完全加载前会延迟填充。这实际上是 DOMContentLoaded 事件之前的延迟。</p><h3 id="window-onload"><a href="#window-onload" class="headerlink" title="window.onload"></a>window.onload</h3><p>当<strong>整个页面，包括样式、图片和其他资源被加载完成时</strong>，会触发 window 对象上的 <strong>load</strong> 事件。可以通过 <strong>onload 属性</strong>获取此事件。</p><h3 id="window-onunload"><a href="#window-onunload" class="headerlink" title="window.onunload"></a>window.onunload</h3><p>当访问者离开页面时，window 对象上的 <strong>unload</strong> 事件就会被触发。我们可以在那里做一些不涉及延迟的操作，例如关闭相关的弹出窗口。</p><p>有一个值得注意的特殊情况是发送分析数据。</p><p>假设我们收集有关页面使用情况的数据：鼠标点击，滚动，被查看的页面区域等。</p><p>自然地，当用户要离开的时候，我们希望通过 unload 事件将数据保存到我们的服务器上。</p><p>有一个特殊的 navigator.sendBeacon(url, data) 方法可以满足这种需求。</p><p>它在后台发送数据，转换到另外一个页面不会有延迟：浏览器离开页面，但仍然在执行 sendBeacon。</p><p>当 sendBeacon 请求完成时，浏览器可能已经离开了文档，所以就无法获取服务器响应（对于分析数据来说通常为空）。</p><p>还有一个 keep-alive 标志，该标志用于在 fetch 方法中为通用的网络请求执行此类“离开页面后”的请求。你可以在 Fetch API 一章中找到更多相关信息。</p><p>如果我们要取消跳转到另一页面的操作，在这里做不到。但是我们可以使用另一个事件 —— onbeforeunload。</p><h3 id="window-onbeforeunload"><a href="#window-onbeforeunload" class="headerlink" title="window.onbeforeunload"></a>window.onbeforeunload</h3><p>如果<strong>访问者触发了离开页面的导航（navigation）或试图关闭窗口</strong>，beforeunload 处理程序将要求进行更多确认。</p><p>如果我们要取消事件，浏览器会询问用户是否确定。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>页面生命周期事件：</p><ul><li>当 DOM 准备就绪时，document 上的 DOMContentLoaded 事件就会被触发。在这个阶段，我们可以将 JavaScript 应用于元素。<ul><li>诸如 <code>&lt;script&gt;...&lt;/script&gt;</code> 或 <code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code> 之类的脚本会阻塞 DOMContentLoaded，浏览器将等待它们执行结束。</li><li>图片和其他资源仍然可以继续被加载。</li></ul></li><li>当页面和所有资源都加载完成时，window 上的 load 事件就会被触发。我们很少使用它，因为通常无需等待那么长时间。</li><li>当用户想要离开页面时，window 上的 beforeunload 事件就会被触发。如果我们取消这个事件，浏览器就会询问我们是否真的要离开（例如，我们有未保存的更改）。</li><li>当用户最终离开时，window 上的 unload 事件就会被触发。在处理程序中，我们只能执行不涉及延迟或询问用户的简单操作。正是由于这个限制，它很少被使用。我们可以使用 navigator.sendBeacon 来发送网络请求。</li></ul><h2 id="margin-与-padding"><a href="#margin-与-padding" class="headerlink" title="margin 与 padding"></a>margin 与 padding</h2><p><code>margin</code>控制的是元素外部空出的空间。相反，<code>padding</code>操作元素内部空出的空间。</p><p>设置百分比都是相对于包含块的<strong>宽度</strong>。</p><h1 id="纯CSS3实现卡通人物眼睛的动画特效"><a href="#纯CSS3实现卡通人物眼睛的动画特效" class="headerlink" title="纯CSS3实现卡通人物眼睛的动画特效"></a>纯CSS3实现卡通人物眼睛的动画特效</h1><p>整体主要是利用边框和圆角进行绘制。</p><ul><li><p>左眼勾玉：span设置圆角，它伪元素设置边框实现</p></li><li><p>右眼轮回圈：边框+圆角+层叠等级</p></li><li><p>木叶标志：边框+圆角</p></li><li><p>胡须：边框三角形</p></li><li><p>眼睛效果：<code>box-shadow</code>+<code>border-radius</code>获得眼睛轮廓和内眼影，外眼影<code>filter: drop-shadow</code></p></li></ul><p>具体设置数值参考他人，自己主要是换成了vw，vh进行自适应适配。</p><p>动画：</p><ul><li>眼睛：animation+transform（旋转、缩放）+opacity（不透明度）+定位</li><li>hover鼠标移入，写轮眼 无限旋转 轮回眼 缩放 反向交替执行</li></ul><h2 id="自适应布局"><a href="#自适应布局" class="headerlink" title="自适应布局"></a>自适应布局</h2><p>网页在各终端上的展示效果就像缩放设计稿图片一样，在不同屏幕上等比缩放，每一个元素与整体比例保持不变，真实还原设计稿。</p><h3 id="1px边框问题"><a href="#1px边框问题" class="headerlink" title="1px边框问题"></a>1px边框问题</h3><p><strong>dpr(物理像素和设备独立像素（逻辑像素）的比值）可以用来解释不同分辨率手机呈现页面的精细度的差异</strong>，但并不能解释1px问题。</p><p><strong>多（2，3）倍的设计图设计了1px的边框，在手机上缩小呈现时，由于css最低只支持显示1px大小，导致边框太粗的效果。（ps：ios较新版已支持0.5px，安卓不支持，这里暂且忽略）。</strong></p><h4 id="通过设置meta标签viewport"><a href="#通过设置meta标签viewport" class="headerlink" title="通过设置meta标签viewport"></a>通过设置meta标签viewport</h4><p>如果设置<strong>content的width就等于设计图大小750px</strong>，然后通过<strong>动态设置initial-scale值让网页整体缩放</strong>，就能实现效果了。</p><h4 id="通过transform-scale-缩放（推荐）"><a href="#通过transform-scale-缩放（推荐）" class="headerlink" title="通过transform: scale()缩放（推荐）"></a>通过transform: scale()缩放（推荐）</h4><p>具体的scale缩放比例取决于你是<strong>几倍设计图尺寸下的1px</strong>。</p><h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><p>视口(viewport)代表当前可见的计算机图形区域。在Web浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的UI， 菜单栏等——即指你正在浏览的文档的那一部分。</p><p>而移动端则较为复杂，它涉及到三个视口：布局视口（Layout Viewport）、视觉视口（Visual Viewport）和理想视口（Ideal Viewport）。</p><p>布局视口使视口与移动端浏览器屏幕宽度完全独立开。CSS 布局将会根据它来进行计算，并被它约束。</p><p>视觉视口是用户当前看到的区域，用户可以通过缩放操作视觉视口，同时不会影响布局视口。</p><p>理想视口对设备而言是最理想的布局视口尺寸。显示在理想视口中的网站具有最理想的宽度，用户无需进行缩放。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="解决适配方法"><a href="#解决适配方法" class="headerlink" title="解决适配方法"></a>解决适配方法</h3><h4 id="rem适配"><a href="#rem适配" class="headerlink" title="rem适配"></a>rem适配</h4><p><code>em</code>：在 <code>font-size</code> 中使用是相对于<strong>父元素的字体大小</strong>，在<strong>其他属性</strong>中使用是相对于<strong>自身的字体大小</strong>，如 width。</p><p>区别在于使用rem为元素设定字体大小时，仍然是相对大小，但<strong>相对的只是HTML根元素</strong>。</p><p>这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到<strong>只修改根元素就成比例地调整所有字体大小</strong>，又可以避免字体大小逐层复合的连锁反应。</p><h4 id="vw，vh布局"><a href="#vw，vh布局" class="headerlink" title="vw，vh布局"></a>vw，vh布局</h4><p>vh、vw方案即将视觉视口宽度 window.innerWidth和视觉视口高度 window.innerHeight 等分为 100 份。</p><p>像<code>vw</code>、<code>vh</code>，比较容易混淆的一个单位是<code>%</code>，不过百分比宽泛的讲是相对于<strong>父元素</strong>。</p><p>视口单位主要包括以下4个：</p><ul><li><strong>vw</strong>：1vw等于视口宽度的1%。</li><li><strong>vh</strong>：1vh等于视口高度的1%。</li><li><strong>vmin</strong>：选取vw和vh中最小的那个。</li><li><strong>vmax</strong>：选取vw和vh中最大的那个。</li></ul><p><strong>缺点</strong>：用户失去了放缩任何使用<code>vw</code>单位的元素的能力。</p><p>vh和vw方案和rem类似也是相当麻烦需要做单位转化，而且px转换成vw不一定能完全整除，因此有一定的像素差。</p><p>不过在工程化的今天，webpack解析css 的时候用postcss-loader 有个postcss-px-to-viewport能自动实现px到vw的转化</p><h4 id="媒体查询-响应式布局"><a href="#媒体查询-响应式布局" class="headerlink" title="媒体查询 响应式布局"></a>媒体查询 响应式布局</h4><p><code>@media 查询规则&#123;&#125;</code>通过媒体查询，可以为不同的设备，或设备不同状态来分别设置样式</p><h4 id="px为主，vx和vxxx（vw-vh-vmax-vmin）为辅，搭配一些flex（推荐）"><a href="#px为主，vx和vxxx（vw-vh-vmax-vmin）为辅，搭配一些flex（推荐）" class="headerlink" title="px为主，vx和vxxx（vw/vh/vmax/vmin）为辅，搭配一些flex（推荐）"></a>px为主，vx和vxxx（vw/vh/vmax/vmin）为辅，搭配一些flex（推荐）</h4><h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><h3 id="利用border画三角形"><a href="#利用border画三角形" class="headerlink" title="利用border画三角形"></a>利用border画三角形</h3><p><code>border</code>可以用于设置一个或多个以下属性的值: <code>border-width</code>, <code>border-style</code>, <code>border-color</code></p><p>本质还是利用了盒模型，<strong>每个边框都是梯形</strong>，当<strong>内容区宽高为0</strong>时就成三角形。</p><p>最简单：内容区宽高为0，border设置大小但颜色透明，单独给一个边框颜色。四个边框分别设置会得到更多不同形状的三角形。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">125px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left-color</span>: aqua;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日常用的更多可能是利用伪元素，<code>content: &#39;&#39;;</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div5</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-top-color</span>:  white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h3><p><code>border-radius</code>允许你设置元素的外边框圆角当使用<strong>一个半径时确定一个圆形</strong>,当使用<strong>两个半径时确定一个椭圆</strong></p><p>这个(椭)圆与边框的交集形成圆角效果。</p><p>该属性是一个简写属性,是为了将这四个属性 <code>border-top-left-radius</code> 、<code>border-top-right-radius</code> 、<code>border-bottom-right-radius</code>和 <code>border-bottom-left-radius</code> 简写为一个属性。</p><p>即使元素<strong>没有边框</strong>,圆角也可以用到 <code>background</code> 上面。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 右上和左下设置圆角*/</span></span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">12vmin</span> <span class="number">0</span> <span class="number">12vmin</span>;</span><br><span class="line"><span class="comment">/* 圆形*/</span></span><br><span class="line"><span class="attribute">width</span>: <span class="number">60vmin</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">60vmin</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br></pre></td></tr></table></figure><h3 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h3><p>用于在元素的框架上添加阴影效果。你可以在同一个元素上设置多个阴影效果，并用逗号将他们分隔开。该属性可设置的值包括<code>阴影的X轴偏移量</code>、<code>Y轴偏移量</code>、<code>模糊半径</code>、<code>扩散半径</code>和<code>颜色</code>。</p><p>如果元素同时设置了 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius"><code>border-radius</code></a>属性 ，那么阴影也会有圆角效果。</p><p>如果没有指定<code>inset</code>，默认阴影在边框外，即阴影向外扩散。</p><p>使用 <code>inset</code> 关键字会使得阴影落在盒子内部，此时阴影会在边框之内 (即使是透明边框）、背景之上、内容之下。</p><p>ios中<code>box-shadow</code>容易出现bug，一种方式是设置<code>border: none;</code>，使用<code>box-shadow</code>和<code>border-radius</code>可以获得类似<strong>边框</strong>的效果。</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。</p><p>drop-shadow()为输入图像添加投影效果。投影实际上是输入图像的alpha蒙版的一个模糊的、偏移的版本，用特定的颜色绘制并合成在图像下面。</p><p><code>drop-shadow()</code>在ios中也会出现bug，但在一些地方又能正常显示，因此尚未找到原因和解决方法。</p><h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p>：<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>这四个属性要生效的话,必须得设置<code>相对定位/绝对定位</code>，即<code>position：relative;</code>或者<code>position：absolute;</code>，也就是说<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>是为<code>相对定位/绝对定位</code>而生的。</p><p>子绝父相就是：子元素为绝对定位(<code>position：absolute;</code>)，父元素为相对定位<code>position：relative;</code>。</p><p><strong>absolute</strong>元素会<strong>被移出正常文档流</strong>，并不为元素预留空间，通过指定元素相对于<strong>最近的非 static 定位祖先元素的偏移</strong>，来确定元素位置。</p><p><strong>fixed</strong>元素会<strong>被移出正常文档流</strong>，并不为元素预留空间，而是通过指定元素相对于<strong>屏幕视口（viewport）</strong>的位置来指定元素位置。</p><h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><p>元素提升为一个比较特殊的图层，在三维空间中 <strong>(z轴)</strong> 高出普通元素一等。</p><ul><li>触发条件<ul><li>根层叠上下文(<code>html</code>)</li><li><code>position</code></li><li>css3属性</li></ul></li><li>层叠等级：层叠上下文在z轴上的排序<ul><li><strong>在同一层叠上下文中，层叠等级才有意义</strong> 先处理子元素，作为整体传递，父元素再与其兄弟元素层叠。</li><li><code>z-index</code>的优先级最高，行内，浮动，块，<code>z-index</code>为负，背景/边框</li></ul></li></ul><h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>**<code>transform</code>**属性允许你旋转<code>rotate()</code>，缩放<code>scale()</code>，倾斜或平移<code>translate()</code>给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。</p><p><strong><code>transform-origin</code></strong> 属性让你更改一个元素变形的原点。（默认的转换原点是 <code>center</code>)</p><blockquote><p>transform对定位元素的影响</p></blockquote><p>当给一个元素加上<code>transform</code>属性的时候，这个元素就会具有<code>relative</code>的特性,所以<strong>若一个元素的父元素拥有tranform属性，那么子元素在使用定位属性的时候要注意。</strong></p><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>简写属性。</p><h4 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h4><p>后边指定动画名称<code>animation-name</code></p><p>关键帧 <strong><code>@keyframes</code></strong> at-rule 规则通过在动画序列中定义关键帧（或waypoints）的样式来<strong>控制CSS动画序列中的中间步骤</strong>。</p><p><code>0%</code>/<code>from</code> 和<code>100%</code>/<code>to</code></p><h4 id="animation-duration"><a href="#animation-duration" class="headerlink" title="animation-duration"></a>animation-duration</h4><p>指定一个<strong>动画周期的时长</strong>。</p><h4 id="animation-timing-function"><a href="#animation-timing-function" class="headerlink" title="animation-timing-function"></a>animation-timing-function</h4><p>定义CSS动画在每一动画周期中<strong>执行的节奏</strong> 可能值为一或多个 <code>&lt;timing-function&gt;</code> 。</p><p>对于关键帧动画来说,<code>timing function</code>作用于<strong>一个关键帧周期</strong>而非整个动画周期,即从关键帧开始开始,到关键帧结束结束。</p><h4 id="animation-delay"><a href="#animation-delay" class="headerlink" title="animation-delay"></a>animation-delay</h4><p>定义动画于何时开始，即<strong>从动画应用在元素上到动画开始的这段时间的长度</strong>。</p><h4 id="animation-iteration-count"><a href="#animation-iteration-count" class="headerlink" title="animation-iteration-count"></a>animation-iteration-count</h4><p>定义动画在结束前运行的<strong>次数</strong> 。可以是1次/无限循环<code>infinite</code>.</p><h4 id="animation-direction"><a href="#animation-direction" class="headerlink" title="animation-direction"></a>animation-direction</h4><p>指示动画是否<strong>反向播放</strong>。</p><h4 id="animation-fill-mode"><a href="#animation-fill-mode" class="headerlink" title="animation-fill-mode"></a>animation-fill-mode</h4><p>设置CSS动画在<strong>执行之前和之后如何将样式应用于其目标</strong>。</p><h2 id="伪类-伪元素"><a href="#伪类-伪元素" class="headerlink" title="伪类/伪元素"></a>伪类/伪元素</h2><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p><strong>伪类</strong>是选择器的一种，它用于选择处于<strong>特定状态</strong>的元素。</p><p><code>:first-child</code> 第一个子元素，<code>:last-child</code>，最后一个子元素 <code>:nth-child()</code> 选中第n个子元素。</p><p><code>:hover</code>- 这仅适用于用户在元素上<strong>移动鼠标</strong>，通常是<strong>链接</strong>。</p><p><code>:focus</code> - 仅在用户通过<strong>单击或使用键盘控件</strong>来适用元素。</p><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p><strong><code>::before</code></strong>/<code>::after</code>用来创建一个伪元素，作为已选中元素的<strong>第一个</strong>/<strong>最后一个子元素</strong>。通常会配合<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content"><code>content</code></a>属性来为该元素添加装饰内容。这个虚拟元素<strong>默认是行内元素</strong>。</p><p><strong><code>::before</code></strong>/<code>::after</code>表示法是在<strong>CSS 3</strong>中引入的，<code>::</code>符号是用来区分<strong>伪类</strong>和伪元素的。支持CSS3的浏览器同时也都支持CSS2中引入的表示法<code>:before</code>/<code>:after</code>。</p><h1 id="JacaScript"><a href="#JacaScript" class="headerlink" title="JacaScript"></a>JacaScript</h1><h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><h3 id="解释代码-vs-编译代码"><a href="#解释代码-vs-编译代码" class="headerlink" title="解释代码 vs 编译代码"></a>解释代码 vs 编译代码</h3><p>在<strong>解释型</strong>语言中，代码<strong>自上而下</strong>运行，且<strong>实时返回运行结果</strong>。</p><p>代码在由浏览器执行前，<strong>不需要将其转化为其他形式</strong>。代码将直接以<strong>文本格式（text form）</strong>被接收和处理。</p><p>相对的，<strong>编译型</strong>语言需要先将代码<strong>转化（编译）</strong>成另一种形式才能运行。</p><p>比如 C/C++ 先被<strong>编译成汇编语言</strong>，然后才能由计算机运行。程序将以<strong>二进制</strong>的格式运行，这些二进制内容是由程序源代码产生的。</p><p><strong>JavaScript 是轻量级解释型语言</strong>。</p><p>浏览器接受到JavaScript代码，并以代码自身的文本格式运行它。</p><p>技术上，几乎所有 JavaScript 转换器都运用了一种叫做<strong>即时编译（just-in-time compiling）</strong>的技术；</p><p>当 JavaScript 源代码被执行时，它会被编译成<strong>二进制</strong>的格式，使代码<strong>运行速度更快</strong>。</p><p>尽管如此，JavaScript 仍然是一门解释型语言，因为<strong>编译过程发生在代码运行中，而非之前</strong>。</p><h3 id="服务器端代码-vs-客户端代码"><a href="#服务器端代码-vs-客户端代码" class="headerlink" title="服务器端代码 vs 客户端代码"></a>服务器端代码 vs 客户端代码</h3><p>客户端代码是在用户的电脑上运行的代码，在浏览一个网页时，它的客户端代码就会被下载，然后由浏览器来运行并展示。</p><p>这就是<strong>客户端JavaScript</strong>。</p><p>而服务器端代码在服务器上运行，接着运行结果才由浏览器下载并展示出来。</p><p>流行的服务器端 web 语言包括：PHP、Python、Ruby、ASP.NET 以及…… JavaScript！</p><p><strong>JavaScript 也可用作服务器端语言</strong>，比如现在流行的 Node.js 环境。</p><h2 id="基于类-vs-基于原型的语言"><a href="#基于类-vs-基于原型的语言" class="headerlink" title="基于类 vs 基于原型的语言"></a>基于类 vs 基于原型的语言</h2><p><strong>基于类的面向对象语言</strong>，比如 Java 和 C++，是构建在两个不同实体之上的：类和实例。</p><ul><li>一个<strong>类(class)<strong>定义了</strong>某一对象集合所具有的特征性属性</strong>（可以将 Java 中的方法和域以及 C++ 中的成员都视作属性）。<strong>类是抽象的，而不是其所描述的对象集合中的任何特定的个体。</strong></li><li>另一方面，<strong>一个实例(instance)是一个类的实例化</strong>。<strong>实例具有和其父类完全一致的属性</strong>，不多也不少。</li></ul><p><strong>基于原型的语言（如 JavaScript）</strong>并不存在这种区别：它<strong>只有对象</strong>。</p><p>基于原型的语言具有所谓**原型对象(prototypical object)**的概念。</p><p><strong>原型对象可以作为一个模板，新对象可以从中获得原始的属性。</strong></p><p>任何对象都可以指定其自身的属性，既可以是创建时也可以在运行时创建。</p><p>而且，<strong>任何对象都可以作为另一个对象的原型(prototype)，从而允许后者共享前者的属性</strong>。</p><table><thead><tr><th align="left">基于类的（Java）</th><th align="left">基于原型的（JavaScript）</th></tr></thead><tbody><tr><td align="left">类和实例是不同的事物。</td><td align="left">所有对象均为实例。</td></tr><tr><td align="left">通过类定义来定义类；通过构造器方法来实例化类。</td><td align="left">通过构造器函数来定义和创建一组对象。</td></tr><tr><td align="left">通过 <code>new</code> 操作符创建单个对象。</td><td align="left">相同。</td></tr><tr><td align="left">通过类定义来定义现存类的子类，从而构建对象的层级结构。</td><td align="left">指定一个对象作为原型并且与构造函数一起构建对象的层级结构</td></tr><tr><td align="left">遵循类链继承属性。</td><td align="left">遵循原型链继承属性。</td></tr><tr><td align="left">类定义指定类的所有实例的<strong>所有</strong>属性。无法在运行时动态添加属性。</td><td align="left">构造器函数或原型指定实例的<strong>初始</strong>属性集。允许动态地向单个的对象或者整个对象集中添加或移除属性。</td></tr></tbody></table><h2 id="Js中的堆栈"><a href="#Js中的堆栈" class="headerlink" title="Js中的堆栈"></a>Js中的堆栈</h2><p>堆<code>heap</code>是<strong>动态分配</strong>的内存，<strong>大小不定</strong>也<strong>不会自动释放</strong>，栈<code>stack</code>为<strong>自动分配</strong>的内存空间，在代码执行过程中<strong>自动释放</strong>。</p><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>在栈内存中提供一个供<code>Js</code>代码执行的环境，关于<strong>作用域</strong>以及<strong>函数的调用</strong>都是栈内存中执行的。</p><p><code>Js</code>中基本数据类型<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Null</code>、<code>Undefined</code>、<code>Symbol</code>、<code>BigInt</code>，</p><ul><li><strong>占用空间小且大小固定</strong>，<strong>值直接保存在栈内存中，是按值访问</strong>，</li><li>对于<code>Object</code>引用类型，其<strong>指针放置于栈内存中</strong>，<strong>指向堆内存的实际地址</strong>，是通过<strong>引用</strong>访问。</li></ul><p>关于调用栈，每调用一个函数，解释器就会把该函数添加进调用栈并开始执行；</p><p>正在调用栈中执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行；</p><p>当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码；</p><p>当分配的调用栈空间被占满时，会引发<strong>堆栈溢出</strong>错误。</p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>引用类型<code>Object</code>的变量<strong>占据空间大且大小不固定</strong>，堆内存中存储<strong>实际对象</strong>，在栈内存中存储对象的指针。</p><p>对于对象的访问是按引用访问的，在堆区的内存不会随着程序的运行而自动释放，这就需要实现<strong>垃圾回收机制</strong><code>GC</code>。</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>需要注意的是在<code>Js</code>中没有类似于<code>C</code>中的<code>free()</code>函数去手动释放内存，对于堆区内存回收全部需要通过<code>Js</code>的垃圾回收机制去实现。<br>在栈区中执行的变量等是通过值访问，当其作用域销毁后变量也就随之销毁，</p><p>而使用引用访问的堆区变量，在一个作用域消失后还可能在外层作用域或者其他作用域仍然存在引用，不能直接销毁，</p><p>此时就需要通过算法计算该堆区变量是否属于不再需要的变量，从而决定是否需要进行内存回收，</p><p>在<code>Js</code>中主要有<strong>引用计数</strong>与<strong>标记清除</strong>两种垃圾回收算法。</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>对于引用计数垃圾回收算法，把对象是否不再需要简化定义为<strong>该对象有没有其他变量或对象引用到它</strong>，如果没有引用指向该对象，该对象将被垃圾回收机制回收。</p><p>在这里，对象的概念不仅特指<code>JavaScript</code>对象，还包括函数作用域或者全局词法作用域。</p><p>引用计数垃圾回收算法使用比较少，主要是在<code>IE6</code>与<code>IE7</code>等低版本<code>IE</code>浏览器中使用。</p><p>但是对于引用计数垃圾回收算法有个限制，当对象<strong>循环引用</strong>时，就会造成<strong>内存泄漏</strong>，也就是引用计数垃圾回收算法无法处理循环引用的对象。</p><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>对于标记清除垃圾回收算法，把对象是否不再需要简化定义为<strong>该对象是否可以获得</strong>。</p><p>该算法设置一个叫做根<code>root</code>的对象，在<code>Javascript</code>里根是全局对象，垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象，以此不断向下查找。</p><p><strong>从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象</strong>，这样便解决了循环引用的问题。</p><p>所有现代浏览器都使用了标记清除垃圾回收算法，所有对<code>JavaScript</code>垃圾回收算法的改进都是基于标记清除算法的改进。</p><ul><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都<strong>加上标记</strong>。</li><li>然后，它会<strong>去掉</strong>运行环境中的变量以及被环境中变量所引用的变量的标记。</li><li>此后，<strong>依然有标记</strong>的变量就被视为准备删除的变量，原因是<strong>在运行环境中已经无法访问到这些变量了</strong>。</li><li>最后，垃圾收集器完成内存清除工作，<strong>销毁那些带标记的值并回收它们所占用的内存空间</strong>。</li></ul><h2 id="数据类型⭐"><a href="#数据类型⭐" class="headerlink" title="数据类型⭐"></a>数据类型⭐</h2><blockquote><p>JavaScript 是一种<strong>弱类型</strong>或者说<strong>动态</strong>语言。</p><p>这意味着你<strong>不用提前声明变量</strong>的类型，在程序<strong>运行</strong>过程中，<strong>类型会被自动确定</strong>。</p><p>这也意味着你可以使用<strong>同一个变量保存不同类型的数据</strong>。</p></blockquote><h3 id="8种数据类型-7-1"><a href="#8种数据类型-7-1" class="headerlink" title="8种数据类型: 7+1"></a>8种数据类型: 7+1</h3><ul><li>原始类型(值不可变，栈)：<code>Undefined</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>BigInt</code>、<code>Symbol</code>、<code>Null</code></li><li>引用数据类型（堆，地址：栈）：<code>Object</code>（几乎所有通过 <code>new</code> 创建的东西：Array、Set、Date）</li></ul><h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><p><strong>typeof</strong>（操作符，非函数）：</p><p>对于<strong>原始类型</strong>，除 <code>null</code> （遗留已久的 bug）都可以正确判断；对于引用类型，除 <code>function</code> 外，都会返回 <code>&#39;object&#39;</code>。返回值为 <code>string</code> （小写）。<code>typeof</code> 未定义的变量返回 <code>&#39;undefined&#39;</code>。</p><p><strong>instanceof</strong></p><p>用于检测构造函数的 <code>prototype</code> 属性是否出现在<strong>某个实例对象的原型链上</strong>。只能判断<strong>引用类型</strong>。</p><p>常用来判断 <code>A</code> 是否为 <code>B</code> 的实例。返回布尔值。</p><p><code>instanceof</code> 和多全局对象(例如：多个 frame 或多个 window 之间的交互)</p><p><strong>多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。</strong></p><p><strong>Object.prototype.toString.call()</strong> <strong>toString.call()</strong></p><p>精准判断数据类型 。统一返回格式<code>&#39;[object Xxx]&#39;</code> 的字符串</p><h3 id="判断数组"><a href="#判断数组" class="headerlink" title="判断数组"></a>判断数组</h3><ul><li><p><code>Array.isArray()</code></p></li><li><p><code>Object.prototype.toString.call()</code> 进行判断，此方式兼容性最好</p></li><li><p><code>instanceof</code></p><p>多个 frame 或多个 window 之间的交互不适用。</p></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><blockquote><p>隐式（自动）/显式强转（开发人员）</p></blockquote><p><strong>在 JS 中只会转换为以下 3 种类型</strong></p><ul><li><code>Number</code> 类型：</li><li>强转：<ul><li><code>Number()</code><ul><li>字符串：<strong>空字符串变为0</strong>，如果出现<strong>任何一个非有效数字字符</strong>，结果都是<code>NaN</code></li><li>布尔转换为数字 true-&gt;1 false-&gt;0</li><li><code>null-&gt;0</code> <code>undefined-&gt;NaN</code></li><li>Symbol<strong>无法</strong>转换为数字，<code>BigInt去除“n”</code></li><li><strong>对象</strong>：通常转换成<code>NaN</code>(除了只包含<code>单个数值的数组或空数组</code>)<ul><li>{}：先转字符串<code>&#39;[object Object]&#39;</code>再转数字<code>NaN</code></li><li>[1,2]：先转字符串<code>&#39;1,2&#39;</code>再转数字<code>NaN</code></li></ul></li></ul></li><li><code>parseInt(string, radix)</code>：逐个解析字符，并返回一个整数。当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</li><li><code>parseFloat(string)</code>：指定字符串中的首个字符是否是数字。是，解析，直到到达数字的末端为止返回该数字。</li></ul></li><li>隐式：<ul><li>比较操作（&gt;, &lt;, &lt;=, &gt;=）</li><li>按位操作（| &amp; ^ ~）</li><li>算数操作（- + * / %）， <strong>注意</strong>：当 + 操作存在任意的操作数是 string 类型时，不会触发number 类型的隐式转换</li></ul></li><li><code>String</code> 类型：</li><li>强转：<code>String()</code> / <code>toString()</code>(数组方法)</li><li>隐式：有 <code>+</code> 运算符并且有一个操作数是 <code>string/object</code> 类型</li><li><code>Boolean</code> 类型:<ul><li>强转：<code>Boolean()</code></li><li>隐式：逻辑判断或者有逻辑运算符（|| &amp;&amp; !），逻辑运算符内部转换和比较，实际返回原始操作数值<ul><li><strong>false</strong>：<code>0</code> <code>NaN</code> <code>&quot;&quot;</code> <code>null</code> <code>undefined</code>，其余都是true</li></ul></li></ul></li></ul><h3 id="amp"><a href="#amp" class="headerlink" title="=== &amp; =="></a><code>=== &amp; ==</code></h3><ul><li><code>===</code> 是严格相等，要求数据类型和值都要相等；<code>==</code> 只需要值相等。</li><li><code>==</code> 会发生隐式类型转换，<code>===</code> 不会发生隐式类型转换。</li></ul><p><code>==</code>类型转换规则</p><ul><li>两个<strong>对象</strong>，比较引用 <code>&#123;&#125;==&#123;&#125; //false</code></li><li>null/undefined和其他任何值都不相等，但<code>null==undefined //true</code></li><li><code>NaN==NaN //false</code></li><li>一个<strong>对象</strong>，另一个是<strong>数字或字符串</strong>，会尝试使用<strong>对象方法转换为原始值</strong> <code>[] == 0 // true</code></li><li>当<strong>数字</strong>与<strong>字符串</strong>进行比较时，会尝试<strong>将字符串转换为数字值</strong>。<code>&#39;1222&#39;==1222 // true</code></li><li>操作数之一是<strong>Boolean</strong>，则将<strong>布尔操作数转换为1或0</strong> <code>true == 2 // false</code></li></ul><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a><code>Object.is()</code></h3><p>判断两个值是否为同一个值。如果满足以下条件则两个值相等:</p><ul><li>都是 <code>undefined</code></li><li>都是 <code>null</code></li><li>都是 <code>true</code> 或 <code>false</code></li><li>都是相同长度的字符串且相同字符按相同顺序排列</li><li>都是相同对象（意味着每个对象有同一个引用）</li><li>都是数字且<ul><li>都是 <code>+0</code></li><li>都是 <code>-0</code></li><li>都是 <code>NaN</code></li><li>或都是非零而且非 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a> 且为同一个值</li></ul></li></ul><p>与<code>==</code>运算<em>不同。</em> <code>==</code> 运算符在判断相等前对两边的变量(如果它们不是同一类型) 进行强制转换, 而 <code>Object.is</code>不会强制转换两边的值。</p><p>与<code>===</code>运算也不相同。 <code>===</code> 运算符 (也包括 <code>==</code> 运算符) 将数字 <code>-0</code> 和 <code>+0</code> 视为相等 ，而将<code>Number.NaN</code>与<code>NaN</code>视为不相等.</p><h2 id="“1”-”2”-”3”-map-parseInt-的输出结果是多少"><a href="#“1”-”2”-”3”-map-parseInt-的输出结果是多少" class="headerlink" title="[“1”,”2”,”3”].map(parseInt)的输出结果是多少?"></a>[“1”,”2”,”3”].map(parseInt)的输出结果是多少?</h2><p>这个网红题考察的就是 <code>parseInt</code> 有两个参数。 <code>map</code> 传入的函数可执行三个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ele   遍历的元素</span></span><br><span class="line"><span class="comment">// index 遍历的元素索引</span></span><br><span class="line"><span class="comment">// arr   数组</span></span><br><span class="line">arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">ele, index, arr</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>[‘1’,’2’,’3’].map(parseInt)相当于执行了以下三次过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;2&#x27;</span>, <span class="number">1</span>, [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;3&#x27;</span>, <span class="number">2</span>, [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br></pre></td></tr></table></figure><ul><li><code>parseInt(&#39;1&#39;, 0, [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;])</code>: radix为0时，默认取10，最后返回<code>1</code></li><li><code>parseInt(&#39;2&#39;, 1, [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;])</code>: radix取值为2~36，如果该参数小于 2 或者大于 36，返回<code>NaN</code></li><li><code>parseInt(&#39;3&#39;, 2, [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;])</code>: radix取值为2，二进制只包括0，1，返回<code>NaN</code></li></ul><p>如果想返回[1,2,3]，<code>[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;].map(n=&gt;parseInt(n))</code></p><p><strong>最简单的方案</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>].map(<span class="built_in">Number</span>)</span><br></pre></td></tr></table></figure><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>基于 IEEE 754 标准的<strong>双精度 64 位</strong>二进制格式的值（<code>-(2^53 -1) 到 2^53 -1</code>）。<strong>它并没有为整数给出一种特定的类型</strong>。</p><p>除了能够表示浮点数外，还有一些带符号的值：<code>+Infinity</code>，<code>-Infinity</code> 和 <code>NaN</code> (非数值，Not-a-Number)。</p><p>要检查值是否大于或小于 <code>+/-Infinity</code>，你可以使用常量<code>Number.MAX_VALUE</code> 和 <code>Number.MIN_VALUE</code>。</p><p>另外在 ECMAScript 6 中，你也可以通过 <code>Number.isSafeInteger()</code>方法还有 <code>Number.MAX_SAFE_INTEGER</code>和 <code>Number.MIN_SAFE_INTEGER</code>来检查值是否在双精度浮点数的取值范围内。</p><p><strong>超出这个范围，JavaScript 中的数字不再安全了。</strong></p><h3 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1 + 0.2 !== 0.3?"></a>0.1 + 0.2 !== 0.3?</h3><p>导致这样的问题是因为 <code>JavaScript</code> 中使用基于<strong>IEEE 754标准</strong>的<strong>浮点数</strong>运算，所以会产生舍入误差。</p><p>也就是说所有遵循 <code>IEEE 754</code> 标准的语言进行浮点数运算的时候，都会有这个问题。</p><p>双精度浮点数使用<strong>64 bit</strong>来进行存储。</p><p><strong>计算机中用二进制来存储小数，而大部分小数转成二进制之后都是无限循环的值，因此存在取舍问题，也就是精度丢失。</strong></p><p><strong>不管是浮点数计算的计算结果错误和大整数的计算结果错误，最终都可以归结到JS的精度只有53位（尾数只能存储53位的有效数字）。</strong></p><blockquote><p>解决方案</p></blockquote><ol><li>使用 <code>JavaScript</code> 提供的<strong>最小精度值</strong>判断误差是否在该值范围内<br><code>Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON</code></li><li>使用别人的轮子,例如：<code>math.js</code></li></ol><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p><code>use strict</code></p><p>全局变量必须<strong>显式声明</strong></p><p><strong>禁止（函数中）this指向全局对象，而是指向undefined</strong></p><p><strong>禁止删除变量</strong></p><p>禁止了<strong>不在脚本或者函数层面上</strong>的函数声明</p><p>禁止<strong>变量</strong>、<strong>对象属性</strong>或<strong>函数参数</strong>重名</p><p>禁止动态绑定</p><p><strong>限制了arguments对象</strong>：不允许对arguments赋值，arguments不再跟踪参数的变化</p><h2 id="作用域与闭包⭐"><a href="#作用域与闭包⭐" class="headerlink" title="作用域与闭包⭐"></a>作用域与闭包⭐</h2><blockquote><p>个人总结：（对内保护，对外引用）闭包是函数执行形成私有作用域，对内，对于私有作用域内的私有变量，起到保护作用，外界无法直接对其进行访问和操作；对外，私有作用域可以通过作用域链查找，对外部作用域进行访问查找。如果形成对外部作用域引用，则会阻止引擎的垃圾回收器释放当前被引用的内存空间。因此，可能会导致内存泄漏，需要特别关注。</p></blockquote><p><strong>一个函数</strong>和对其周围状态（<strong>lexical environment，词法环境</strong>）的<strong>引用</strong>捆绑在一起，这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）。</p><p><strong>每当创建一个函数，闭包就会在函数创建的同时被创建出来。</strong></p><p>也就是说，闭包让你可以在一个<strong>内层函数</strong>中<strong>访问到其外层函数的作用域</strong>。</p><p>内部函数对外部函数中定义的<strong>所有变量和函数</strong>有完全访问权，以及<strong>外部函数可以访问的所有其他变量和函数</strong>，这样就形成了<strong>作用域链</strong>。</p><p><strong>当内部函数以某种方式于外部函数之外的任何作用域执行时</strong>，就会看到一个可观察的闭包。</p><p>由于内部函数可以通过闭包访问外部函数的作用域，所以<strong>外部函数中定义的变量和函数的存活时间就可以长于外部函数的执行时间</strong>。</p><p>本质就是<strong>上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放</strong>。</p><p>就导致上级作用域内的变量，<strong>等到下级作用域执行完以后才正常得到释放</strong>。</p><p><strong>优点</strong></p><ul><li>可以<strong>从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用</strong>。</li><li><strong>避免使用全局变量</strong>。</li><li>把变量存到独立的作用域，作为<strong>私有成员</strong>存在。</li></ul><p><strong>缺点</strong></p><ul><li>对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以<strong>使用不当会导致内存泄漏</strong>。</li><li>对处理速度具有负面影响。<strong>闭包的层级决定了引用的外部变量在查找时经过的作用域链长度</strong>。</li></ul><p><strong>应用</strong></p><ul><li><p><strong>用闭包模拟私有方法</strong> 模块模式：将共享环境创建于一个立即执行的匿名函数体内。这个环境中包含私有项无法在这个匿名函数外部直接访问，必须通过匿名函数返回的公共函数访问。</p></li><li><p><strong>在循环中创建闭包</strong>：在<code>for</code>循环并未具备局部作用域，因此内层函数中的循环变量i都是外层函数的一个局部变量，循环结束后该变量是一个唯一值，可以使用<strong>立即执行匿名函数</strong>再创建一个闭包，将循环变量保存；或者使用<strong>let</strong>形成块作用域来保存每次的循环变量。</p></li><li><p><strong>高阶函数与柯里化</strong></p><blockquote><p>简单来说，高阶函数是一个接收函数作为参数或将函数作为输出返回的函数。</p><p>柯里化是指一个函数，它接收函数 A，并且能返回一个新的函数，这个新的函数能够处理函数 A 的剩余参数。</p></blockquote></li><li><p><strong>节流与防抖</strong></p></li></ul><h2 id="原型与原型链⭐"><a href="#原型与原型链⭐" class="headerlink" title="原型与原型链⭐"></a>原型与原型链⭐</h2><p><code>JS</code>中所有对象都具有一个<code>__proto__</code>隐式原型属性，指向该对象的原型对象。</p><p>每个函数都有一个<code>prototype</code>属性，指向原型对象，原型对象有个<code>constructor</code>属性，指向该函数。</p><p>所有的对象（除了Object原型对象）本质上都是通过<code>new 函数</code>创建的。</p><p>实例对象的隐式原型属性<code>__proto__</code>指向其构造函数的原型属性<code>prototype</code>。</p><p><strong>所有的函数（Object、Array）都是对象</strong>，本质上都是通过<code>new Function</code>创建的。</p><p>所有函数(包括<code>Function</code>)的隐式原型<code>__proto__</code>指向<code>Function</code>的原型（<code>Function.prototype</code>）。</p><p>所有函数（包括Function）的原型对象(默认是Object实例对象)都指向（<code>__proto__</code>）Object的原型对象。</p><p>Object的原型对象指向<code>null</code>。</p><p>实例对象在查找属性时，如果查找不到，就会沿着<code>__proto__</code>隐式原型去与对象关联的原型上查找，如果还查找不到，就去找原型的原型，直至查到最顶层null，这也就是原型链的概念。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/46q4cF"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/09/26/46q4cF.png" alt="46q4cF.png"></a></p><h2 id="DOM事件总结⭐"><a href="#DOM事件总结⭐" class="headerlink" title="DOM事件总结⭐"></a>DOM事件总结⭐</h2><h3 id="DOM事件的级别"><a href="#DOM事件的级别" class="headerlink" title="DOM事件的级别"></a>DOM事件的级别</h3><p><strong>DOM0的写法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种事件绑定的方式，如果绑定多个，则后面的会覆盖掉前面的</span></span><br><span class="line">element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是在 js 中的写法；如果要在html中写，写法是：在onclick属性中，加 js 语句。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;hello&#x27;);&quot;</span>&gt;</span>我是按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p><strong>DOM2的写法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高版本浏览器</span></span><br><span class="line">element.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// IE8及以下版本浏览器。IE11和谷歌浏览器等不支持</span></span><br><span class="line">element.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的第三参数中，<strong>true</strong>表示事件在<strong>捕获阶段</strong>触发，<strong>false</strong>表示事件在<strong>冒泡阶段</strong>触发（默认）。</p><p><code>addEventListener()</code>中的<code>this</code>，是<strong>绑定事件的对象</strong>；如果写箭头函数是<strong>window</strong>。</p><p>绑定多个响应函数执行顺序是：<strong>先绑定先执行</strong>。</p><p><strong>DOM3的写法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>DOM3中，增加了很多事件类型，比如<strong>鼠标事件</strong>、<strong>键盘事件</strong>等。</p><h3 id="DOM事件模型"><a href="#DOM事件模型" class="headerlink" title="DOM事件模型"></a>DOM事件模型</h3><p><strong>DOM事件模型</strong>讲的就是<strong>捕获和冒泡</strong>。</p><ul><li><p>捕获：从上往下。事件会从最外层开始发生，直到最具体的元素。</p></li><li><p>冒泡：从下（目标元素）往上。事件会从最内层的元素开始发生，一直向上传播到<code>Window</code> 对象。</p></li></ul><p><strong>DOM事件流</strong>讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。</p><p>完整的事件流，分三个阶段：</p><ul><li><p><strong>捕获</strong>：从 <code>window</code> 对象传到 <strong>目标元素</strong>。</p></li><li><p><strong>目标阶段</strong>：事件通过捕获，到达目标元素，这个阶段就是目标阶段。</p></li><li><p><strong>冒泡</strong>：从<strong>目标元素</strong>传到 <code>Window</code> 对象。</p></li></ul><p>捕获阶段，事件依次传递的顺序是：<code>window</code> –&gt; <code>document</code> –&gt; <code>html</code>–&gt; <code>body</code> –&gt; 父元素、子元素、目标元素。</p><p>冒泡的流程与捕获的流程相反。</p><p><strong>事件捕获优先于事件冒泡</strong>。</p><h3 id="Event对象的常见-api-方法"><a href="#Event对象的常见-api-方法" class="headerlink" title="Event对象的常见 api 方法"></a>Event对象的常见 api 方法</h3><p><strong>Event 对象代表事件的状态</strong>，当dom tree中某个事件被触发的时候，会同时自动产生一个<strong>用来描述事件所有的相关信息</strong>（比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态）的对象。</p><p>阻止默认事件<code>event.preventDefault();</code> 如阻止了链接的默认跳转</p><p>阻止冒泡 <code>event.stopPropagation();</code></p><h3 id="事件委托（代理）"><a href="#事件委托（代理）" class="headerlink" title="事件委托（代理）"></a>事件委托（代理）</h3><p>事件委派指将事件统一绑定给元素的<strong>共同的祖先元素</strong>，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。事件委派是利用了<strong>冒泡</strong>，通过委派可以减少事件绑定的次数，提高程序的性能。</p><p><code>event.currentTarget</code> 返回<strong>绑定事件的元素</strong>。在事件委托中，一般是【祖先元素】。<br><code>event.target</code> 返回<strong>触发事件的元素</strong>。在事件委托中，一般是【子元素】。</p><p><strong>应用场景</strong></p><p>例如我们有<code>10</code>个<code>&lt;li&gt;</code>标签，每个标签有一个<code>uid</code>作为判断用户点击的区别，使用冒泡就不需要为每个<code>&lt;li&gt;</code>绑定点击事件，可以把点击事件绑定到<code>&lt;ul&gt;</code>上，通过<code>event.target</code>获得触发事件的元素，称为事件委托。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;u1&quot;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    alert(e.target.getAttribute(<span class="string">&#x27;uid&#x27;</span>));<span class="comment">//返回元素上一个指定的属性值。</span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><h2 id="this指向⭐"><a href="#this指向⭐" class="headerlink" title="this指向⭐"></a>this指向⭐</h2><p>目的就是指向<strong>函数</strong>运行时（箭头函数除外）所在的环境。</p><p>总结了<code>this</code>的绑定规则总共是有下面5种：请记住一点：==谁调用这个函数或方法,this关键字就指向谁。==</p><ul><li><p>默认绑定（严格/非严格模式）</p><ul><li>无论是否在严格模式下，在全局执行环境中（在任何函数体外部）<code>this</code> 都指向全局对象。</li><li>非严格模式，函数中 <code>this</code> 的值默认指向全局对象，浏览器中就是<code>window</code>。</li><li>严格模式下，<code>this</code> 会保持为 <code>undefined</code>。</li><li><code>this</code> 在类中的表现与在函数中类似，在类的构造函数中，<code>this</code> 是一个常规对象。类中所有非静态的方法都会被添加到 <code>this</code> 的原型。静态方法不是 this 的属性，它们只是类自身的属性。</li><li>派生类的构造函数没有初始的 <code>this</code> 绑定。在构造函数中调用 <code>super()</code>会生成一个 <code>this</code> 绑定，并相当于获得基类的this。</li></ul></li><li><p>隐式绑定</p><ul><li>当<strong>函数作为对象的属性</strong>存在，通过<strong>对象属性执行函数</strong>时，此时隐式绑定规则会将<code>this</code>绑定到对象上。</li><li>赋值或函数传参（隐式赋值），会丢失该this绑定。</li></ul></li><li><p>显式绑定</p><ul><li><strong>通过 <code>call</code> <code>apply</code> <code>bind</code>绑定</strong></li></ul></li><li><p>new绑定</p><ul><li>当一个函数用作<strong>构造函数</strong>时（使用<code>new</code>关键字），它的<code>this</code>被绑定到<strong>正在构造的新对象</strong>。</li><li>当构造函数<strong>返回值为对象</strong>时，直接返回这个对象；否则返回<strong>new创建的对象</strong>。</li></ul></li><li><p>ES6箭头函数绑定</p><ul><li>通过<strong>作用域链</strong>查到<strong>外层作用域的 this</strong> ，且指向<strong>函数定义时的 this</strong> 而非执行时</li></ul></li></ul><p>判断this指向顺序：new、call/apply/bind、隐式绑定、默认绑定</p><h2 id="JS数组常用方法总结⭐"><a href="#JS数组常用方法总结⭐" class="headerlink" title="JS数组常用方法总结⭐"></a>JS数组常用方法总结⭐</h2><p>常见的数组定义：<strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p><p>==JavaScript 数组的长度和元素类型都是非固定的。==</p><p>因为数组的<strong>长度可随时改变</strong>，并且其数据<strong>在内存中也可以不连续</strong>（存储相同类型元素内存连续）。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><code>Array.from()</code> 从一个<strong>类数组</strong>或<strong>可迭代对象</strong>创建一个<strong>新的</strong>、<strong>浅拷贝</strong>的Array实例。</p><p><code>Array.isArray()</code>判断数组</p><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><p><code>Array.prototype.length</code></p><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p><strong>改变原数组</strong>的方法(9个):</p><ul><li><code>push(element1, ...)</code>：<strong>末尾</strong>+1/多，并返回<code>length</code></li><li><code>pop()</code>：<strong>删除最后一个元素</strong>，并<strong>返回该元素的值</strong>。</li><li><code>unshift(element1, ...)</code>：<strong>开头</strong>+1/多，并返回<code>length</code></li><li><code>shift()</code>：<strong>删除第一个元素</strong>，并<strong>返回该元素的值</strong>。</li><li><code>splice(开始,删除个数,新元素1...)</code>：<strong>删除</strong>或<strong>替换</strong>现有元素或者<strong>原地添加</strong>新的元素来修改数组,并<strong>以数组形式返回被删除的元素</strong></li><li><code>sort([比较函数])</code>：<strong>原地算法</strong>对数组的元素进行排序，并返回数组。比较函数返回值&gt;0,交换a、b。升序排列：<code>arr.sort((a,b)=&gt;a - b)</code></li><li><code>reverse()</code>：翻转数组</li><li><code>fill(1,0,this.length)</code>：用一个<strong>固定值</strong>填充一个数组中从<strong>起始索引</strong>到<strong>终止索引</strong>内的全部元素。<strong>不包括终止索引</strong>。返回<strong>修改后的数组</strong>。</li></ul><p><strong>不改变原数组</strong>的方法(8个):</p><ul><li><code>slice(begin,end)</code>：返回一个新的数组对象(一个<code>[begin,end)</code>决定的原数组的<strong>浅拷贝</strong>）</li><li><code>join(&#39;&#39;)</code>：将一个数组（或一个<strong>类数组对象</strong>）的所有元素连接成一个<strong>字符串</strong>并返回这个字符串。默认<code>,</code>分隔。</li><li><code>concat(arr1,...)</code>：合并数组，<strong>浅拷贝</strong></li><li><code>indexOf(searchElement, fromIndex)</code>：返回在数组中可以找到一个<strong>给定元素的第一个索引</strong>，如果不存在，则返回<code>-1</code>。严格相等<code>===</code>搜索元素。不能识别<code>NaN</code>。</li><li><code>includes</code>：判断一个数组是否包含一个指定的值，返回布尔值。</li></ul><p><strong>遍历</strong>方法(12个):</p><ul><li><p><code>forEach</code>：对数组的每个元素执行一次给定的函数。<code>array.forEach(function(currentValue, index, arr), thisArg)</code></p><ul><li>无法中途退出循环，只能用<code>return</code>退出本次回调，进行下一次回调。</li><li>它总是返回 <code>undefined</code>值,即使你return了一个值。</li></ul></li><li><p><code>map</code>：创建一个<strong>新数组</strong>，其结果是<strong>该数组中的每个元素都调用一个提供的函数后返回的结果</strong>。</p><ul><li><code>let new_array = arr.map(function(currentValue, index, arr), thisArg)</code></li></ul></li><li><p><code>filter</code>：返回一个<strong>新数组</strong>, 其包含<strong>通过所提供函数实现的测试的所有元素</strong>。</p><ul><li><code>let new_array = arr.filter(function(currentValue, index, arr), thisArg)</code></li></ul></li><li><p><code>reduce</code>：对累加器和数组中的每个元素（<strong>从左到右</strong>）应用一个函数，最终合并为一个值。</p><ul><li><code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code></li><li>如果 <code>initialValue</code> 在调用 reduce 时被提供，那么<strong>第一个</strong> <code>total</code> 将等于 <code>initialValue</code>，此时 <code>currentValue</code> 等于数组中的<strong>第一个值</strong>；</li><li>如果 <code>initialValue</code> 未被提供，那么 <code>total</code> 等于数组中的<strong>第一个值</strong>，<code>currentValue</code> 等于数组中的<strong>第二个值</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组求和 </span></span><br><span class="line"><span class="keyword">let</span> sum = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 将二维数组转化为一维 将数组元素展开</span></span><br><span class="line"><span class="keyword">let</span> flattened = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].reduce(</span><br><span class="line">    <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.concat(b),</span><br><span class="line">    []</span><br><span class="line">);</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p><code>find</code>:用于找出<strong>第一个符合条件</strong>的数组成员，并<strong>返回该成员</strong>，如果没有符合条件的成员，则返回<code>undefined</code>。</p><ul><li><code>let new_array = arr.find(function(currentValue, index, arr), thisArg)</code></li></ul></li><li><p><code>keys/values/entries</code></p><ul><li>遍历<strong>键名</strong>、遍历<strong>键值</strong>、遍历<strong>键名+键值</strong></li><li>在<code>for..of</code>中如果遍历中途要退出，可以使用<code>break</code>退出循环。</li></ul></li></ul><h2 id="for…in和for…of有什么区别？"><a href="#for…in和for…of有什么区别？" class="headerlink" title="for…in和for…of有什么区别？"></a>for…in和for…of有什么区别？</h2><p><code>for…of</code> 是<code>ES6</code>新增的遍历方式，允许遍历一个含有<code>iterator</code>接口的数据结构（数组等）并且返回各项的值，和ES3中的<code>for…in</code>的区别如下：</p><ul><li><code>for…of</code> 遍历获取的是对象的<strong>键值</strong>，<code>for…in</code> 获取的是对象的<strong>键名</strong>；</li><li><code>for… in</code> 会遍历对象的整个<strong>原型链</strong>，性能非常差不推荐使用，而 <code>for … of</code> <strong>只遍历当前对象</strong>不会遍历原型链；</li><li>对于数组的遍历，<code>for…in</code> 会返回<strong>数组中所有可枚举的属性</strong>(包括原型链上可枚举的属性)，<code>for…of</code> 只返回数组的<strong>下标对应的属性值</strong>；</li></ul><p>总结： <code>for...in</code> 循环主要是为了<strong>遍历对象</strong>而生，不适用于遍历数组；<code>for...of</code> 循环可以用来<strong>遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象</strong>。</p><h2 id="对调两个变量的多种方法"><a href="#对调两个变量的多种方法" class="headerlink" title="对调两个变量的多种方法"></a>对调两个变量的多种方法</h2><h3 id="解构赋值法"><a href="#解构赋值法" class="headerlink" title="解构赋值法"></a>解构赋值法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">3</span>,b=<span class="number">5</span>;</span><br><span class="line">[a,b]=[b,a];</span><br></pre></td></tr></table></figure><h3 id="临时变量法"><a href="#临时变量法" class="headerlink" title="临时变量法"></a>临时变量法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">3</span>,b=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> c=a;</span><br><span class="line">a=b;</span><br><span class="line">b=c;</span><br></pre></td></tr></table></figure><h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">3</span>,b=<span class="number">5</span>;</span><br><span class="line">a=a+b;</span><br><span class="line">b=a-b;</span><br><span class="line">a=a-b;</span><br></pre></td></tr></table></figure><h3 id="数组法"><a href="#数组法" class="headerlink" title="数组法"></a>数组法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">3</span>,b=<span class="number">5</span>;</span><br><span class="line">a=[a,b];</span><br><span class="line">b=a[<span class="number">0</span>];</span><br><span class="line">a=a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">a=[b,b=a][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h3 id="对象法"><a href="#对象法" class="headerlink" title="对象法"></a>对象法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">3</span>,b=<span class="number">5</span>;</span><br><span class="line">a=&#123;<span class="attr">a</span>:b,<span class="attr">b</span>:a&#125;;</span><br><span class="line">b=a.b;</span><br><span class="line">a=a.a;</span><br></pre></td></tr></table></figure><h3 id="按位异或法"><a href="#按位异或法" class="headerlink" title="按位异或法"></a>按位异或法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">3</span>,b=<span class="number">5</span>;</span><br><span class="line">a=a^b;</span><br><span class="line">b=b^a;</span><br><span class="line">a=a^b;</span><br></pre></td></tr></table></figure><h2 id="浅拷贝和深拷贝⭐"><a href="#浅拷贝和深拷贝⭐" class="headerlink" title="浅拷贝和深拷贝⭐"></a>浅拷贝和深拷贝⭐</h2><p>对象直接赋值的情况，不涉及任何拷贝。此时为<strong>同一个引用</strong>。</p><p>浅拷贝只能拷贝<strong>一层对象</strong>。如果有对象的<strong>嵌套</strong>，那么浅拷贝将无能为力。</p><p><strong>浅拷贝：</strong></p><ul><li><strong>concat()</strong></li><li><strong>slice()</strong></li><li><strong>…展开运算符</strong></li><li><strong>Array.from</strong></li><li><strong>Object.assign(target, …sources)</strong> 拷贝的是<strong>对象的属性的引用</strong></li></ul><p><strong>深拷贝:</strong></p><p><code>JSON.parse(JSON.stringify(object))</code></p><ol><li>无法解决<code>循环引用</code>的问题。举个例子：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">val</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a.target = a;</span><br></pre></td></tr></table></figure><p>拷贝a会出现系统栈溢出，因为出现了<code>无限递归</code>的情况。</p><ol start="2"><li>无法拷贝一些<code>特殊的对象</code>，诸如 RegExp, Date, Set, Map等。</li><li>无法拷贝<code>函数</code>。</li><li>会忽略 undefined、symbol等</li></ol><p>第三方最完善的深拷贝方法是 <a href="https://link.juejin.cn/?target=https://www.lodashjs.com/">Lodash</a> 库的 <a href="https://link.juejin.cn/?target=https://www.lodashjs.com/docs/lodash.cloneDeep"><code>_.cloneDeep()</code></a> 方法。</p><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p><strong>封装实参的对象</strong></p><ul><li>arguments是一个<strong>类数组</strong>对象,它也可以通过索引来操作数据，也可以获取长度。</li><li>在调用函数时，我们所传递的实参都会在arguments中保存</li><li><code>arguments.length</code>可以用来获取实参的长度</li><li><code>arguments[0]</code> 表示第一个实参，<code>arguments[1]</code> 表示第二个实参 。。。</li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;正则&quot;</span>,<span class="string">&quot;匹配模式&quot;</span>);<span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/正则表达式/</span>匹配模式          <span class="comment">// 字面量</span></span><br></pre></td></tr></table></figure><p>匹配模式可以是</p><ul><li><code>i</code> 忽略大小写</li><li><code>g</code> 全局匹配模式</li></ul><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><p><strong>开头结尾</strong></p><p><code>^</code> 表示开头</p><p><code>$</code> 表示结尾</p><p>如果在正则表达式中同时使用<code>^ $</code>则要求字符串必须完全符合正则表达式</p><p><strong>或</strong></p><p>使用 <code>|</code> 表示或者的意思</p><p><code>[]</code>里的内容也是或的关系</p><ul><li>[ab] == a|b</li><li>[a-z] 任意小写字母</li><li>[A-Z] 任意大写字母</li><li>[A-z] 任意字母</li><li>[0-9] 任意数字</li><li>[^ ] 除了</li></ul><p><strong>量词</strong></p><p>通过量词可以设置一个内容出现的次数</p><p>量词只对它<strong>前边的一个内容</strong>起作用</p><ul><li><code>&#123;n&#125;</code> 正好出现n次</li><li><code>&#123;m,n&#125;</code> 出现m-n次</li><li><code>&#123;m,&#125;</code> m次以上</li></ul><ul><li><code>+</code> 至少一个，相当于{1,}</li></ul><ul><li><code>*</code> 0个或多个，相当于{0,}</li><li><code>?</code> 0个或1个，相当于{0,1}</li></ul><p><strong>转义字符</strong></p><p>在正则表达式中使用<code>\</code>作为转义字符</p><h3 id="正则表达式的方法"><a href="#正则表达式的方法" class="headerlink" title="正则表达式的方法"></a>正则表达式的方法</h3><p><code>test()</code></p><p>使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果符合则返回true，否则返回false</p><p><code>reg.test(str)</code></p><h3 id="字符串和正则相关的方法"><a href="#字符串和正则相关的方法" class="headerlink" title="字符串和正则相关的方法"></a>字符串和正则相关的方法</h3><p><code>split()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据任意字母来将字符串拆分为一个数组</span></span><br><span class="line"><span class="keyword">var</span> result = str.split(<span class="regexp">/[A-z]/</span>);</span><br></pre></td></tr></table></figure><p><code>search()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搜索字符串中是否含有abc 或 aec 或 afc</span></span><br><span class="line"><span class="comment">// 如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1</span></span><br><span class="line">result = str.search(<span class="regexp">/a[bef]c/</span>);</span><br></pre></td></tr></table></figure><p><code>match()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从一个字符串中将符合条件的内容提取出来</span></span><br><span class="line"><span class="comment">// 默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索</span></span><br><span class="line"><span class="comment">// 我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容</span></span><br><span class="line">str = <span class="string">&quot;1a2a3a4a5e6f7A8B9C&quot;</span>;</span><br><span class="line">result = str.match(<span class="regexp">/[a-z]/ig</span>);</span><br></pre></td></tr></table></figure><p><code>replace()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串中指定内容替换为新的内容,默认只会替换第一个</span></span><br><span class="line">result = str.replace(<span class="regexp">/[a-z]/gi</span> , <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="Js选择器"><a href="#Js选择器" class="headerlink" title="Js选择器"></a>Js选择器</h2><p>JS选择器常用的有<code>getElementById()</code>、<code>getElementsByClassName()</code>、<code>getElementsByName()</code>、<code>getElementsByTagName()</code>、<code>querySelector()</code>、<code>querySelectorAll()</code>。</p><h3 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById"></a>getElementById</h3><p>通过<code>id</code>来定位，返回对指定<code>id</code>的第一个对象的引用，返回类型为<code>HTMLDivElement</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;t1&quot;</span>&gt;</span>T1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> t1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;t1&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(t1); <span class="comment">// &lt;div id=&quot;t1&quot;&gt;D1&lt;/div&gt;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(t1)); <span class="comment">// [object HTMLDivElement]</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName"></a>getElementsByClassName</h3><p>通过<code>class</code>属性来定位，返回文档中指定<code>class</code>属性值的元素的引用，返回类型为<code>HTMLCollection</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;t2&quot;</span>&gt;</span>D2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;t2&quot;</span>&gt;</span>D3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> t2List = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;t2&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(t2List); <span class="comment">// HTMLCollection(2) [div.t2, div.t2]</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 使用for循环遍历</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,n=t2List.length;i&lt;n;++i) <span class="built_in">console</span>.log(t2List[i]);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// HTMLCollection的prototype中没有forEach方法，遍历需要使用Array的prototype中forEach通过call绑定对象实例并传参</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Array</span>.prototype.forEach.call(t2List,<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v) ); </span></span><br><span class="line"><span class="javascript">    <span class="comment">// HTMLCollection的prototype中没有map方法，也需要使用Array的prototype中forEach通过call绑定对象实例并传参</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Array</span>.prototype.map.call(t2List,<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v) ); </span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="getElementsByName"><a href="#getElementsByName" class="headerlink" title="getElementsByName"></a>getElementsByName</h3><p>通过<code>name</code>属性来定位，返回文档中指定<code>name</code>属性值的元素的引用，返回类型为<code>NodeList</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">name</span>=<span class="string">&quot;t3&quot;</span>&gt;</span>D4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">name</span>=<span class="string">&quot;t3&quot;</span>&gt;</span>D5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> t3List = <span class="built_in">document</span>.getElementsByName(<span class="string">&quot;t3&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(t3List); <span class="comment">// NodeList(2) [div, div]</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可直接使用forEach进行遍历</span></span></span><br><span class="line"><span class="javascript">    t3List.forEach( <span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v) ); </span></span><br><span class="line"><span class="javascript">    <span class="comment">// NodeList的prototype中没有map方法，使用map的场景也需要借助Array的prototype中map通过call绑定对象实例并传参</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Array</span>.prototype.map.call(t3List,<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v) ); </span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName"></a>getElementsByTagName</h3><p>通过标签的名字来定位，返回文档中指定标签的元素的引用，返回类型为<code>HTMLCollection</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;t4&quot;</span>&gt;</span>P6<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;t4&quot;</span>&gt;</span>P7<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> t4List = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;p&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(t4List); <span class="comment">// HTMLCollection(2) [p, p]</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Array</span>.prototype.forEach.call(t4List, <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;<span class="built_in">console</span>.log(v);&#125;); </span></span><br><span class="line"><span class="javascript">    <span class="built_in">Array</span>.prototype.map.call(t4List,<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;<span class="built_in">console</span>.log(v);&#125; ); </span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector"></a>querySelector</h3><p>通过<code>CSS</code>选择器来定位，返回文档中匹配指定<code>CSS</code>选择器的第一个元素的引用，返回类型为<code>HTMLDivElement</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;t5&quot;</span>&gt;</span>D8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> t5 = <span class="built_in">document</span>.querySelector(<span class="string">&quot;div .t5&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(t5); <span class="comment">// &lt;div class=&quot;t5&quot;&gt;D8&lt;/div&gt;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(t5)); <span class="comment">// [object HTMLDivElement]</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll"></a>querySelectorAll</h3><p>通过<code>CSS</code>选择器来定位，返回文档中匹配指定<code>CSS</code>选择器的所有元素的引用，返回类型为<code>NodeList</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;t6&quot;</span>&gt;</span>D9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>D10<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>D11<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">     <span class="keyword">var</span> t6List = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;#t6 ~ div&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(t6List); <span class="comment">// NodeList(2)[div, div]</span></span></span><br><span class="line"><span class="javascript">    t6List.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;<span class="built_in">console</span>.log(v);&#125;); </span></span><br><span class="line"><span class="javascript">    <span class="built_in">Array</span>.prototype.map.call(t6List,<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;<span class="built_in">console</span>.log(v);&#125; ); </span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Js中Date对象"><a href="#Js中Date对象" class="headerlink" title="Js中Date对象"></a>Js中Date对象</h2><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>不同于类 C 语言，<strong>JavaScript 字符串是不可更改的</strong>。</p><p>这意味着字符串一旦被创建，就不能被修改。</p><p>但是，可以基于对原始字符串的操作来<strong>创建新的字符串</strong>。例如：</p><ul><li>获取一个字符串的子串可通过选择个别字母或者使用 <code>String.substr()</code>。</li><li>两个字符串的连接使用连接操作符 (<code>+</code>) 或者<code>String.concat()</code>。</li></ul><h3 id="字符访问"><a href="#字符访问" class="headerlink" title="字符访问"></a>字符访问</h3><p>有两种方法可以访问字符串中的单个字符。首先是 <code>charAt()</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">&#x27;cat&#x27;</span>.charAt(<span class="number">1</span>) <span class="comment">// returns &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p>另一种方法（在 ECMAScript 5 中引入）是将字符串视为类似数组的对象，其中单个字符对应于数字索引：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">&#x27;cat&#x27;</span>[<span class="number">1</span>] <span class="comment">// returns &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p>当使用括号表示法进行字符访问时，<strong>尝试删除这些属性或为这些属性赋值将不会成功</strong>。所涉及的属性既不可写也不可配置。</p><h3 id="基本字符串和字符串对象的区别"><a href="#基本字符串和字符串对象的区别" class="headerlink" title="基本字符串和字符串对象的区别"></a>基本字符串和字符串对象的区别</h3><p>字符串字面量 (通过<strong>单引号或双引号</strong>定义) 和 直接调用 String 方法(<strong>没有通过 new 生成字符串对象实例</strong>)的字符串都是<strong>基本字符串</strong>。</p><p>JavaScript会<strong>自动将基本字符串转换为字符串对象</strong>，只有将基本字符串转化为字符串对象之后才可以<strong>使用字符串对象的方法</strong>。</p><p><strong>当基本字符串需要调用一个字符串对象才有的方法或者查询值的时候</strong>(基本字符串是没有这些方法的)，JavaScript 会自动将基本字符串转化为字符串对象并且调用相应的方法或者执行查询。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s_prim = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s_obj = <span class="keyword">new</span> <span class="built_in">String</span>(s_prim);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s_prim); <span class="comment">// Logs &quot;string&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s_obj);  <span class="comment">// Logs &quot;object&quot;</span></span><br></pre></td></tr></table></figure><p>当使用 <code>eval</code>时，基本字符串和字符串对象也会产生不同的结果。</p><p><code>eval</code> 会将基本字符串作为源代码处理; 而字符串对象则被看作对象处理, 返回对象。 例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;2 + 2&quot;</span>;               <span class="comment">// creates a string primitive</span></span><br><span class="line">s2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;2 + 2&quot;</span>);   <span class="comment">// creates a String object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(s1));      <span class="comment">// returns the number 4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(s2));      <span class="comment">// returns the string &quot;2 + 2&quot;</span></span><br></pre></td></tr></table></figure><p>由于上述原因, 当一段代码在需要使用基本字符串的时候却使用了字符串对象就会导致执行失败(虽然一般情况下程序员们并不需要考虑这样的问题)。</p><p>利用 <code>valueOf</code>方法，我们可以将字符串对象转换为其对应的基本字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(eval(s2.valueOf())); // returns the number 4</span><br></pre></td></tr></table></figure><h3 id="长文字字符串"><a href="#长文字字符串" class="headerlink" title="长文字字符串"></a>长文字字符串</h3><p>有时，您的代码将包含很长的字符串。您可能希望在源代码中专门将字符串分成多行而不影响实际的字符串内容，而不是让行无休止地继续下去，或者随编辑器的一时兴起而换行。有两种方法可以做到这一点。</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>您可以使用<code>+</code>运算符将多个字符串附加在一起，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> longString = <span class="string">&quot;This is a very long string which needs &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;to wrap across multiple lines because &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;otherwise my code is unreadable.&quot;</span></span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p><code>\</code>您可以在每行末尾 使用反斜杠字符 ( ) 来指示字符串将在下一行继续。确保反斜杠后没有空格或任何其他字符（换行符除外）或缩进；否则它将无法正常工作。</p><p>该表格如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> longString = <span class="string">&quot;This is a very long string which needs \</span></span><br><span class="line"><span class="string">to wrap across multiple lines because \</span></span><br><span class="line"><span class="string">otherwise my code is unreadable.&quot;</span></span><br></pre></td></tr></table></figure><p>上述两种方法都会产生相同的字符串。</p><h3 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h3><p>模板字面量是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为“模板字符串”。</p><p>模板字符串使用<strong>反引号</strong>来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（<code>$&#123;expression&#125;</code>）的占位符。</p><p>占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。</p><p>在模版字符串内使用反引号时，需要在它前面加<strong>转义符（\）</strong>。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><p><code>s.length</code> 可以用来获取字符串的长度</p></li><li><p><code>s.charAt(i)</code> 可以返回字符串中指定位置i的字符</p></li><li><p><code>s.concat(s1,...)</code>可以用来连接两个或多个字符串，作用和<code>+</code>一样</p></li><li><p><code>s.indexOf(searchvalue,fromindex)</code>该方法可以检索一个字符串中是否含有指定内容</p><ul><li>如果字符串中含有该内容，则会返回其<strong>第一次出现的索引</strong></li><li>如果没有找到指定的内容，则返回**-1**</li><li>可以指定一个第二个参数，指定<strong>开始查找的位置</strong></li></ul></li><li><p><code>s.slice(a,b)</code> 可以从字符串中截取指定的内容,不会影响原字符串，而是将<strong>截取到内容返回</strong></p><ul><li>参数：[a,b)</li><li>如果省略第二个参数，则会截取到后边所有的</li><li>也可以传递一个负数作为参数，<strong>负数的话将会从后边计算</strong></li></ul></li><li><p><code>s.substring(a,b)</code>可以用来截取一个字符串，<strong>和slice()类似</strong></p><ul><li><p>不同的是这个方法<strong>不能接受负值</strong>作为参数，如果传递了一个负值，则默认使用0</p></li><li><p>而且他还<strong>自动调整参数的位置</strong>，如果第二个参数小于第一个，则自动交换</p></li></ul></li><li><p><code>s.split(&quot;&quot;)</code>可以将一个字符串拆分为一个数组</p><ul><li><p>需要一个<strong>字符串</strong>作为参数，将会根据该字符串去拆分数组</p></li><li><p>如果传递一个<strong>空串</strong>作为参数，则会将每个字符都拆分为数组中的一个元素</p></li></ul></li></ul><ul><li><p><code>toUpperCase()</code> 将一个字符串转换为<strong>大写</strong>并返回</p></li><li><p><code>toLowerCase()</code> 将一个字符串转换为<strong>小写</strong>并返回</p></li></ul><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p><code>eval()</code> 函数会将传入的字符串当做 JavaScript 代码进行执行。</p><p>如果 <code>eval()</code> 的参数不是字符串， <code>eval()</code> 会将参数原封不动地返回。在下面的例子中，<code>String</code> 构造器被指定，而 <code>eval()</code> 返回了 <code>String</code> 对象而不是执行字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;2 + 2&quot;</span>)); <span class="comment">// 返回了包含&quot;2 + 2&quot;的字符串对象</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;2 + 2&quot;</span>);             <span class="comment">// returns 4</span></span><br></pre></td></tr></table></figure><h3 id="永远不要使用-eval！"><a href="#永远不要使用-eval！" class="headerlink" title="永远不要使用 eval！"></a>永远不要使用 <code>eval</code>！</h3><p><code>eval()</code> 是一个危险的函数， 它使用与调用者相同的权限执行代码。</p><p>如果你用 <code>eval()</code> 运行的字符串代码被恶意方（不怀好意的人）修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。更重要的是，第三方代码可以看到某一个 <code>eval()</code> 被调用时的作用域，这也有可能导致一些不同方式的攻击。相似的 <code>Function</code>就不容易被攻击。</p><p><code>eval()</code> 通常比其他替代方法更慢，因为它必须调用 JS 解释器，而许多其他结构则可被现代 JS 引擎进行优化。</p><p>此外，现代JavaScript解释器将javascript转换为机器代码。 这意味着任何变量命名的概念都会被删除。 因此，任意一个eval的使用都会强制浏览器进行冗长的变量名称查找，以确定变量在机器代码中的位置并设置其值。 另外，新内容将会通过 <code>eval()</code> 引进给变量， 比如更改该变量的类型，因此会强制浏览器重新执行所有已经生成的机器代码以进行补偿。 但是，（谢天谢地）存在一个非常好的eval替代方法：只需使用window.Function。</p><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6+"></a>ES6+</h1><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p><code>ES6</code>允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 基本</span></span><br><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]]; <span class="comment">//嵌套</span></span><br><span class="line"><span class="keyword">let</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 可忽略</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b] = []; <span class="comment">// a = 1, b = undefined // 不完全解构</span></span><br><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 剩余运算符</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 字符串等</span></span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;; <span class="comment">// 对象模型的解构 前后两个kay需对应</span></span><br></pre></td></tr></table></figure><h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><p><code>BigInt</code>类型是 JavaScript 中的一个基础的数值类型，可以<strong>用任意精度表示整数</strong>。</p><p>使用 BigInt，您可以<strong>安全地存储和操作大整数，甚至可以超过数字的安全整数限制</strong>。</p><p>BigInt 是通过在整数末尾附加 <code>n</code>或调用构造函数来创建的。</p><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol是 ECMAScript 第6版新定义的。符号类型是<strong>唯一</strong>的并且是<strong>不可修改</strong>的, 并且也可以<strong>用来作为 Object 的 key 的值</strong>。</p><h2 id="Class与继承⭐"><a href="#Class与继承⭐" class="headerlink" title="Class与继承⭐"></a>Class与继承⭐</h2><p><strong>类是用于创建对象的模板。</strong>JS中的类建立在<strong>原型</strong>上，但也具有某些语法和语义未与ES5类相似语义共享。</p><h3 id="类定义与调用"><a href="#类定义与调用" class="headerlink" title="类定义与调用"></a>类定义与调用</h3><p><strong>类表达式</strong>和<strong>类声明</strong>。<strong>类声明不会提升</strong>。</p><p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p><h3 id="严格模式-1"><a href="#严格模式-1" class="headerlink" title="严格模式"></a>严格模式</h3><p>类的主体都执行在<strong>严格模式</strong>下，与普通构造函数不同。</p><p>当调用静态或原型方法时<strong>没有指定 this的值</strong>，那么方法内的 this值将被置为 **<code>undefined</code>**。</p><h3 id="构造函数与方法"><a href="#构造函数与方法" class="headerlink" title="构造函数与方法"></a>构造函数与方法</h3><p><code>constructor</code>（<strong>构造函数</strong>）方法是一个特殊的方法，这种方法用于<strong>创建和初始化</strong>一个由<code>class</code>创建的对象。</p><p>一个构造函数可以使用 <code>super</code> 关键字来<strong>调用一个父类的构造函数</strong>，从而获得父类的this。</p><p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。</p><p>事实上，<strong>类的所有非静态方法</strong>都定义在类的<code>prototype</code>属性上面。</p><p>因此，<strong>在类的实例上面调用方法，其实就是调用原型上的方法</strong>。</p><p>另外，类的内部所有定义的方法，都是<strong>不可枚举的（non-enumerable）</strong>。这一点与 ES5 的行为不一致。</p><p><code>static</code> 关键字用来定义一个类的一个静态方法。调用静态方法不需要<strong>实例化</strong>该类，但<strong>不能通过一个类实例调用静态方法</strong>。静态方法通常用于<strong>为一个应用程序创建工具函数</strong>。</p><h3 id="属性-字段"><a href="#属性-字段" class="headerlink" title="属性/字段"></a>属性/字段</h3><p><strong>实例的属性</strong>必须定义在<strong>类的方法里</strong>，静态的或原型的数据属性必须定义在<strong>类定义的外面</strong>。</p><p><strong>字段声明</strong>（实验性功能）</p><ul><li><p>公有字段：预先声明字段，类定义变得更加自我记录，并且字段始终存在。这个字段<strong>可以用也可以不用默认值来声明</strong>。</p></li><li><p>私有字段（<code>#</code>） 它们只能在类里面中读取或写入。</p></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><code>extends</code> 关键字在类声明或类表达式中用于创建一个类作为另一个类的一个子类。</p><p>如果子类中定义了构造函数，那么它必须先调用 <code>super()</code> 才能使用 <code>this</code> 。</p><p><code>super</code> 关键字用于<strong>调用对象的父对象上的方法。</strong></p><p>也可以继承传统的基于函数的“类”，但不能继承<strong>常规对象（不可构造的）</strong>。</p><p>如果要继承常规对象，可以改用<code>Object.setPrototypeOf()</code>：</p><p><code>Object.setPrototypeOf(obj, proto);</code>直接修改已有对象的原型。</p><h2 id="箭头函数与普通函数区别⭐"><a href="#箭头函数与普通函数区别⭐" class="headerlink" title="箭头函数与普通函数区别⭐"></a>箭头函数与普通函数区别⭐</h2><p><strong>箭头函数表达式</strong>的语法比<strong>函数表达式</strong>更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。</p><p>箭头函数表达式<strong>更适用于那些本来需要匿名函数的地方</strong>，并且它<strong>不能用作构造函数</strong>。</p><ol><li>箭头函数<strong>没有自己的this</strong>，它是<strong>通过作用域链查到外层作用域的this</strong>，且指向函数<strong>定义时</strong>的this而<strong>非执行时</strong>。</li><li><strong>不可以用作构造函数</strong>，<strong>不能使用new命令</strong>，否则会报错。同时，箭头函数<strong>没有prototype属性</strong>。</li><li>箭头函数<strong>没有arguments对象</strong>，如果要用，使用<strong>rest参数</strong>（<code>...args</code>）代替。</li><li><strong>不可以使用yield命令</strong>，因此箭头函数<strong>不能用作Generator函数</strong>。</li><li><strong>不能用call/apply/bind修改this指向</strong>，但<strong>可以通过修改外层作用域的this来间接修改</strong>。</li></ol><h2 id="let、const和var的区别⭐"><a href="#let、const和var的区别⭐" class="headerlink" title="let、const和var的区别⭐"></a>let、const和var的区别⭐</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul><li><p>存在<strong>变量提升</strong>，即变量可以在声明之前调用，值为<code>undefined</code>。</p></li><li><p>可以<strong>重复声明</strong>，第一次用来声明，后面只是重新赋值。</p></li><li><p>在<strong>函数</strong>中使用var声明变量的时候，该变量是<strong>局部</strong>的；对于声明在任何函数外（<strong>特别注意if和for中</strong>）的变量来说是<strong>全局</strong>的。</p></li></ul><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li><p>不存在变量提升，let声明变量前，该变量不能使用（<strong>暂时性死区</strong>）。</p></li><li><p>在<strong>块级作用域</strong>内有效。</p></li><li><p>let不允许在<strong>相同作用域</strong>中重复声明，注意是相同作用域，不同作用域有重复声明不会报错。</p></li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul><li><p><strong>不存在变量提升</strong>。</p></li><li><p><strong>存在块级作用域</strong>。</p></li><li><p><strong>同一作用域不允许重复声明变量</strong>。</p></li><li><p>声明一个只读的常量。一旦声明，<strong>常量的值就不能改变</strong>。const并不是变量的值不能改动，而是<strong>变量指向的内存地址所保存的数据不得改动</strong>。例如，在引用内容是对象的情况下，这意味着<strong>可以改变对象的内容</strong>。</p></li></ul><blockquote><p>全局中用<strong>let</strong>和<strong>const</strong>声明的变量存在<strong>Script</strong>上，用<strong>var</strong>声明的存在<strong>Global</strong>上（浏览器一般用<strong>Window</strong>表示）</p></blockquote><h3 id="变量提升和函数提升"><a href="#变量提升和函数提升" class="headerlink" title="变量提升和函数提升"></a>变量提升和函数提升</h3><ul><li><p><strong>所有的声明都会提升到作用域的最顶上去</strong>。</p></li><li><p>同一个变量只会<strong>声明一次</strong>，其他的会被忽略掉。</p></li><li><p><strong>函数声明的优先级高于变量声明的优先级</strong>，并且函数声明和函数定义的部分一起被提升。</p></li><li><p><strong>函数表达式声明的函数</strong>，相当于<strong>变量提升</strong>，如果使用<strong>const</strong>或<strong>let</strong>，则无法提升。</p></li></ul><h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><p>当函数中隐式声明一个变量时：</p><ul><li><p><strong>该变量和参数同名</strong>，该变量为<strong>局部变量</strong>。</p><p>函数传参相当于在内部声明了一个局部变量（<code>var param = param;</code>）</p><ul><li>实参如果是<strong>对象</strong>，就把该对象的<strong>地址</strong>赋给这个局部变量，可以通过地址<strong>修改外层对象的属性</strong>，但如果重新赋给该变量一个<strong>新的对象</strong>，不会覆盖外层对象</li><li>实参如果是<strong>原始类型</strong>就把值赋给该变量，<strong>修改该变量不会影响外层变量</strong>。</li></ul></li><li><p>函数<strong>没有参数</strong>，通过<strong>作用域链</strong>向外一直找到<strong>全局作用域</strong>，如果有该变量，说明该变量只是在其他地方进行了声明。</p></li><li><p>若没有找到，此时<strong>隐式声明了一个全局变量（window上）</strong>，且不会进行变量提升。</p></li></ul><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>早期JavaScript 程序本来很小，它们大多被用来执行独立的脚本任务，在你的 web 页面需要的地方提供一定交互，所以一般不需要多大的脚本。过了几年，我们现在有了运行大量 JavaScript 脚本的复杂程序，还有一些被用在其他环境（例如 <code>Node.js</code>）。</p><p>因此，近年来，有必要开始考虑提供一种<strong>将 JavaScript 程序拆分为可按需导入的单独模块的机制</strong>。</p><ul><li>避免命名冲突(减少命名空间污染)</li><li>更好的分离, 按需加载</li><li>更高复用性</li><li>高可维护性</li></ul><p>早期 全局函数 对象 IIFE(闭包) 缺点：引入多个<code>&lt;script&gt;</code>请求过多、依赖模糊、难以维护</p><p>通过<strong>模块化规范</strong>解决</p><p>CommonJS 服务端 同步</p><p>AMD 异步 开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</p><p>CMD与AMD规范很相似 依赖就近，延迟执行，可以很容易在Node.js中运行 依赖SPM 打包，模块的加载逻辑偏重。</p><p><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</strong>。</p><p>CommonJS 用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用<code>exports</code>），用<code>require</code>加载模块。</p><p>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</p><p>CommonJS 模块是运行时加载（对象），ES6 模块是编译时输出接口。</p><p>ES6模块化</p><p>export 导出<strong>函数</strong>，<code>var</code>，<code>let</code>，<code>const</code>, 和<strong>类</strong>。</p><p><code>import</code> <code>from</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;main.mjs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>模块自动使用严格模式和自动延迟加载。</p><p><code>export default</code></p><p><code>as</code></p><p><code>import * as Module</code> 创建模块对象</p><p><code>export &#123; name &#125; from &#39;x.mjs&#39;</code> 合并模块</p><p>动态加载模块 将<code>import()</code>作为函数调用，将其传递给模块的路径作为参数。 它返回一个 <code>promise</code>，它用一个<strong>模块对象</strong>来实现，让你可以访问该对象的导出。</p><h2 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h2><p>遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。</p><p>任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><p>Iterator 的作用有三个：</p><ul><li>一是为各种数据结构，提供一个统一的、简便的访问接口；</li><li>二是使得数据结构的成员能够按某种次序排列；</li><li>三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</li></ul><p>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p><p>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</p><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。</p><p>具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。</p><p>其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p><p>原生具备 Iterator 接口的数据结构如下。</p><ul><li><strong>Array</strong></li><li><strong>Map</strong></li><li><strong>Set</strong></li><li><strong>String</strong></li><li>TypedArray</li><li><strong>函数的 arguments 对象</strong></li><li>NodeList 对象</li></ul><p><strong>调用 Iterator 接口的场合：</strong></p><ul><li><p>对数组和 Set 结构进行<strong>解构赋值</strong>时，会默认调用<code>Symbol.iterator</code>方法。</p></li><li><p><strong>扩展运算符</strong>（…）也会调用默认的 Iterator 接口。</p></li></ul><p>实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...iterable];</span><br></pre></td></tr></table></figure><ul><li><p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p></li><li><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。</p><ul><li><p>for…of</p></li><li><p>Array.from()</p></li><li><p>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</p></li><li><p>Promise.all()</p></li><li><p>Promise.race()</p></li></ul></li></ul><h2 id="Set，WeakSet，Map和WeakMap"><a href="#Set，WeakSet，Map和WeakMap" class="headerlink" title="Set，WeakSet，Map和WeakMap"></a>Set，WeakSet，Map和WeakMap</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>值的集合（键和值相同，且唯一）</p><p><strong>方法</strong>：<code>add</code> <code>delete</code> <code>has</code>（布尔值） <code>clear</code> 属性：<code>size</code></p><p><strong>实现了iterator接口</strong></p><ul><li><p>可以使用<code>for…of…</code>进行遍历 <code>keys()</code>，<code>values()</code>(默认)，<code>entries()</code></p></li><li><p>遍历顺序就是<strong>插入顺序</strong></p></li><li><p><code>forEach</code>（键值、键名、集合本身），用于对每个成员执行某种操作，没有返回值</p></li><li><p>扩展运算符（<code>...</code>）</p></li><li><p>数组的<code>map</code>和<code>filter</code>方法也可以<strong>间接</strong>用于 Set 了 <code>new Set([...set].map(x =&gt; x * 2))</code></p></li></ul><p><strong>应用</strong></p><p><strong>去重</strong></p><p><code>Set</code>函数可以接受一个数组（或者具有 <code>iterable</code> 接口的其他数据结构）作为参数，用来初始化。</p><p>数组去重：<code>Array.from(new Set(array))</code>或<code>[...new Set(array)]</code></p><p>字符串去重：<code>[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)</code></p><p>set中所有<code>NaN</code>值都是相等的。</p><p><strong>交并差</strong></p><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>值只能是<strong>对象</strong></p><p><strong>弱引用：</strong>如果其他对象都不再引用该对象，那么<strong>垃圾回收机制会自动回收该对象所占用的内存</strong>，不考虑该对象还存在于 WeakSet 之中。</p><p>由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，所以<strong>不可遍历</strong> 。</p><p>方法：<code>add</code> <code>delete</code> <code>has</code></p><p>使用场景：<strong>储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏</strong>。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><strong>键值对</strong>的<strong>有序</strong>列表，而键和值都可以是<strong>任意类型</strong></p><p>方法：<code>set(key, value)</code>、<code>get(key)</code>（键对应的值）、<code>has(key)</code>（布尔值）、 <code>delete(key)</code>、 <code>clear</code> 属性：<code>size</code></p><p>遍历大致同Set，只是set的键值相同。Map初始化传入的应该至少是一个二维数组。<code>entries()</code>（默认，[键，值]）</p><p><strong>Object 和 map 的比较</strong></p><ul><li><p>map 只包含<strong>显式插入的键</strong>；Object <strong>原型链</strong>上的键名有可能和你自己在对象上的设置的键名产生冲突。</p></li><li><p>map 键可以是<strong>任意值</strong>；Object 的键必须是一个 <code>String</code> （其他类型键会转换为字符串，如对象=&gt;<code>&#39;[object Object]&#39;</code>）或是<code>Symbol</code>。<strong>不是有效的JavaScript标识符的属性名</strong>(如，具有空格或连字符的属性名，或以数字开头的属性名)<strong>只能使用方括号</strong>符号访问。</p></li><li><p>map 键 有序（插入）；Object 的键是<strong>无序</strong>的。自ECMAScript 2015规范以来，对象确实保留了字符串和Symbol键的创建顺序； 因此，在<strong>只有字符串键的对象</strong>上进行迭代将按插入顺序产生键。</p></li><li><p>键值对个数 map size；Object无。</p></li><li><p>map 可迭代； Object 需要以某种方式获得键。</p></li><li><p>map在<strong>频繁增删键值对</strong>的场景下表现更好。</p></li></ul><p><strong>对象和map互换</strong></p><ul><li>对象转为 Map 可以通过<code>Object.entries()</code>。 <code>new Map(Object.entries(obj))</code></li><li>map 转为对象。如果所有Map的键都是字符串，它可以无损地转为对象。<code>Object.create(null); obj[k] = v;</code></li></ul><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>键名只能<strong>对象</strong></p><p><strong>弱引用的只是键名</strong>，<strong>无法遍历</strong></p><p>方法：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code></p><p>应用：<strong>DOM 节点作为键名</strong>，防止内存泄漏；部署私有属性；<strong>深拷贝循环引用</strong></p><h2 id="异步编程⭐"><a href="#异步编程⭐" class="headerlink" title="异步编程⭐"></a>异步编程⭐</h2><p><strong>JavaScript是一种同步的、阻塞的、单线程的语言</strong>，在这种语言中，一次只能执行一个操作。</p><p>但web浏览器定义了函数和API，允许我们当某些事件发生时不是按照同步方式，而是<strong>异步地调用函数</strong>(比如，时间的推移，用户通过鼠标的交互，或者获取网络数据)。这意味着您的代码可以同时做几件事情，而不需要停止或阻塞主线程。</p><p>通过 <code>Web workers</code>可以把一些任务交给一个名为<code>worker</code>的单独的线程，这样就可以同时运行多个JavaScript代码块。</p><p>web workers有用但也有局限。如<strong>不能访问 DOM— 不能让一个worker直接更新UI</strong>。</p><h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><p>异步callbacks 其实就是<strong>函数</strong>，只不过是作为<strong>参数</strong>传递给那些在后台执行的其他函数。</p><p>如：异步callback 就是<code>addEventListener()</code>第二个参数。</p><p>当我们把<strong>回调函数作为一个参数传递给另一个函数时，仅仅是把回调函数定义作为参数传递过去</strong> — <strong>回调函数并没有立刻执行，回调函数会在包含它的函数的某个地方异步执行，包含函数负责在合适的时候执行回调函数</strong>。</p><p>不是所有的回调函数都是异步的 — <strong>有一些是同步的</strong>。一个例子就是使用 <code>Array.prototype.forEach()</code>来遍历数组。</p><h3 id="setTimeout-amp-setInterval"><a href="#setTimeout-amp-setInterval" class="headerlink" title="setTimeout() &amp; setInterval()"></a>setTimeout() &amp; setInterval()</h3><ul><li><p><code>setTimeout()</code>在<strong>指定的时间后</strong>执行一段代码。</p></li><li><p><code>setInterval()</code>以<strong>固定的时间间隔</strong>，重复运行一段代码。</p></li><li><p><code>requestAnimationFrame()</code>setInterval()的现代版本;在浏览器下一次重新绘制显示之前执行指定的代码块，从而允许动画在<strong>适当的帧率</strong>下运行，而不管它在什么环境中运行。</p></li></ul><p>这些函数设置的异步代码实际上在<strong>主线程</strong>上运行（在其指定的计时器过去之后）。</p><p><strong>指定的时间（或延迟）不能保证在指定的确切时间之后执行，而是最短的延迟执行时间</strong>。<strong>在主线程上的堆栈为空之前，传递给这些函数的回调将无法运行。</strong></p><p>可以通过调用<code>clearTimeout()</code>，将<code>setTimeout()</code>调用的<strong>标识符</strong>作为参数传递给它，从而在超时运行之前取消。</p><p>通过将<code>setInterval()</code>调用返回的标识符传递给<code>clearInterval()</code>函数可以清除intervals。</p><p><strong>递归setTimeout()和setInterval()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">setTimeout</span>(run, <span class="number">100</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>上述代码的两个版本之间的差异是微妙的。</p><ul><li>递归 <code>setTimeout()</code> 保证<strong>执行之间的延迟相同</strong>，例如在上述情况下为100ms。 代码将运行，然后在它再次运行之前等待100ms，因此无论代码运行多长时间，间隔都是相同的。</li><li>使用 <code>setInterval()</code> 的示例有些不同。 <strong>我们选择的间隔包括执行我们想要运行的代码所花费的时间</strong>。假设代码需要40毫秒才能运行 - 然后间隔最终只有60毫秒。</li><li>当递归使用 <code>setTimeout()</code> 时，每次迭代都可以在运行下一次迭代之前计算不同的延迟。 换句话说，第二个参数的值可以指定在再次运行代码之前等待的不同时间（以毫秒为单位）。</li></ul><p>当<strong>你的代码有可能比你分配的时间间隔，花费更长时间运行时</strong>，最好使用递归的 <code>setTimeout()</code> - 这将使执行之间的时间间隔保持不变，无论代码执行多长时间，你不会得到错误。</p><p><code>requestAnimationFrame()</code>是一种<strong>允许您以给定当前浏览器/系统的最佳帧速率重复且高效地运行函数</strong>的方法。除非您需要特定的速率帧，否则您应该尽可能使用它而不要去使用<code>setInterval()/recursive setTimeout()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// Drawing code goes here</span></span><br><span class="line">   requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><h3 id="Promise⭐"><a href="#Promise⭐" class="headerlink" title="Promise⭐"></a>Promise⭐</h3><p>本质上，Promise 是一个<strong>对象</strong>，代表<strong>操作的中间状态</strong> —— 正如它的单词含义 ‘<strong>承诺</strong>‘ ，它<strong>保证在未来可能返回某种结果</strong>。</p><p>虽然 Promise 并不保证操作在何时完成并返回结果，但是它保证当结果可用时，你的代码能正确处理结果，当结果不可用时，你的代码同样会被执行，来优雅的处理错误。</p><h4 id="与旧式回调相比"><a href="#与旧式回调相比" class="headerlink" title="与旧式回调相比"></a>与旧式回调相比</h4><p><code>Promise</code>是专门为异步操作而设计的，与旧式回调相比具有许多优点:</p><ul><li>您可以<strong>使用多个then()操作将多个异步操作链接在一起，并将其中一个操作的结果作为输入传递给下一个操作</strong>。避免<strong>回调地狱</strong>（如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差）。</li><li><code>Promise</code>总是严格按照它们放置在事件队列中的<strong>顺序调用</strong>。</li><li>错误处理要好得多——所有的错误都由块末尾的一个<code>.catch()</code>块处理，而不是在“金字塔”的每一层单独处理。</li></ul><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p><strong>创建promise时</strong>，它既不是成功也不是失败状态。这个状态叫作<strong>pending</strong>（待定）。</p><p>当<strong>promise返回</strong>时，称为 <strong>resolved</strong>（已解决）。</p><ul><li>一个成功<strong>resolved</strong>的promise称为<strong>fullfilled</strong>（<strong>实现</strong>）。它返回一个值，可以通过将<code>.then()</code>块链接到promise链的末尾来访问该值。<code>.then()</code>块中的执行程序函数将包含promise的返回值。</li><li>一个不成功<strong>resolved</strong>的promise被称为<strong>rejected</strong>（<strong>拒绝</strong>）了。它返回一个原因（<strong>reason</strong>），一条错误消息，说明为什么拒绝promise。可以通过将<code>.catch()</code>块链接到promise链的末尾来访问此原因。</li></ul><p>状态只能由 <code>Pending --&gt; Fulfilled</code> 或者 <code>Pending --&gt; Rejected</code>，且<strong>一旦发生改变不可二次修改</strong>。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123; <span class="comment">/* executor */</span></span><br><span class="line">    <span class="comment">// 执行代码 需要指明resolve与reject的回调位置</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>executor</code>是带有<code>resolve</code>和<code>reject</code>两个参数的函数。</p><p><code>Promise</code>构造函数执行时立即调用<code>executor</code>函数，<code>resolve</code>和<code>reject</code>两个函数作为参数传递给<code>executor</code>。</p><p><code>resolve</code>和<code>reject</code>函数被调用时，分别将<code>promise</code>的状态改为完成<code>fulfilled</code>或失败<code>rejected</code>。</p><p><code>executor</code>内部通常会执行一些异步操作，一旦异步操作执行完毕，要么调用<code>resolve</code>函数来将<code>promise</code>状态改成<code>fulfilled</code>，要么调用<code>reject</code>函数将<code>promise</code>的状态改为<code>rejected</code>。</p><p>如果在<code>executor</code>函数中抛出一个错误，那么该<code>promise</code>状态为<code>rejected</code>，<code>executor</code>函数的返回值被忽略。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h5 id="Promise-all-iterable"><a href="#Promise-all-iterable" class="headerlink" title="Promise.all(iterable)"></a>Promise.all(iterable)</h5><p>这个方法返回一个新的<code>promise</code>对象</p><ul><li>该<code>promise</code>对象在<code>iterable</code>参数对象里所有的<code>promise</code>对象<strong>都成功</strong>的时候才会触发成功</li><li>一旦有任何一个<code>iterable</code>里面的<code>promise</code>对象失败则立即触发该<code>promise</code>对象的失败。</li><li>这个新的<code>promise</code>对象在触发成功状态以后，会把一个包含<code>iterable</code>里所有<code>promise</code>返回值的数组作为成功回调的返回值，顺序跟<code>iterable</code>的顺序保持一致。</li><li>如果这个新的<code>promise</code>对象触发了失败状态，它会把<code>iterable</code>里第一个触发失败的<code>promise</code>对象的错误信息作为它的失败错误信息。</li><li><code>Promise.all</code>方法常被用于处理多个<code>promise</code>对象的状态集合。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&quot;success1&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&quot;success2&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);      <span class="comment">// 成功状态 //[&quot;success1&quot;, &quot;success2&quot;]</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1,p3,p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);      <span class="comment">// 失败状态 // fail</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="Promise-race-iterable"><a href="#Promise-race-iterable" class="headerlink" title="Promise.race(iterable)"></a>Promise.race(iterable)</h5><p>当<code>iterable</code>参数里的任意一个子<code>promise</code>被成功或失败后，父<code>promise</code>马上也会用子<code>promise</code>的成功返回值或失败详情作为参数调用父<code>promise</code>绑定的相应句柄，并返回该<code>promise</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">  &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// p1先获得结果，那么就执行p1的回调</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="Promise.resolve(value)"></a>Promise.resolve(value)</h5><p>返回一个状态由给定<code>value</code>决定的<code>Promise</code>对象。</p><ul><li>如果该值是<code>thenable</code>(即，带有<code>then</code>方法的对象)，返回的<code>Promise</code>对象的最终状态由<code>then</code>方法执行决定；</li><li>否则的话(该<code>value</code>为空，基本类型或者不带<code>then</code>方法的对象),返回的<code>Promise</code>对象状态为<code>fulfilled</code>，并且将该<code>value</code>传递给对应的<code>then</code>方法。</li><li>通常而言，如果你不知道一个值是否是<code>Promise</code>对象，使用<code>Promise.resolve(value)</code>来返回一个<code>Promise</code>对象,这样就能将该<code>value</code>以<code>Promise</code>对象形式使用。不要在解析为自身的<code>thenable</code>上调用<code>Promise.resolve</code>，这将导致无限递归，因为它试图展平无限嵌套的<code>promise</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该值为空或基本类型，直接返回一个fulfilled状态的Promise对象</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">promise.then(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num); <span class="comment">// 1</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve(p1);</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2); <span class="comment">// true</span></span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果该值带有then方法的对象，返回的Promise对象的最终状态由then方法执行决定</span></span><br><span class="line"><span class="keyword">var</span> thenable = &#123;<span class="attr">then</span>: <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="number">1</span>)&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 1</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="Promise-reject-reason"><a href="#Promise-reject-reason" class="headerlink" title="Promise.reject(reason)"></a>Promise.reject(reason)</h5><p>返回一个状态为失败的<code>Promise</code>对象，并将给定的失败信息传递给对应的处理方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.reject(<span class="string">&quot;err&quot;</span>);</span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// err</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h4><h5 id="Promise-prototype-then-onFulfilled-onRejected"><a href="#Promise-prototype-then-onFulfilled-onRejected" class="headerlink" title="Promise.prototype.then(onFulfilled, onRejected)"></a>Promise.prototype.then(onFulfilled, onRejected)</h5><p>添加解决<code>fulfillment</code>和拒绝<code>rejection</code>回调到当前<code>promise</code>,返回一个新的<code>promise</code>,将以回调的返回值来<code>resolve</code>。</p><h5 id="Promise-prototype-catch-onRejected"><a href="#Promise-prototype-catch-onRejected" class="headerlink" title="Promise.prototype.catch(onRejected)"></a>Promise.prototype.catch(onRejected)</h5><p>添加一个拒绝<code>rejection</code>回调到当前<code>promise</code>,返回一个新的<code>promise</code>。当这个回调函数被调用，新<code>promise</code>将以它的返回值来<code>resolve</code>，否则如果当前<code>promise</code>进入<code>fulfilled</code>状态，则以当前<code>promise</code>的完成结果作为新<code>promise</code>的完成结果。</p><h5 id="Promise-prototype-finally-onFinally"><a href="#Promise-prototype-finally-onFinally" class="headerlink" title="Promise.prototype.finally(onFinally)"></a>Promise.prototype.finally(onFinally)</h5><p>添加一个事件处理回调于当前<code>promise</code>对象，并且在原<code>promise</code>对象解析完毕后，返回一个新的<code>promise</code>对象。回调会在当前<code>promise</code>运行完毕后被调用，无论当前<code>promise</code>的状态是完成<code>fulfilled</code>还是失败<code>rejected</code>。</p><h3 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h3><p>es2017的新语法，async/await就是<code>generator</code> + <code>promise</code>的语法糖</p><p><code>async</code> 函数就是将 Generator 函数的星号（<code>*</code>）替换成 <code>async</code>，将 <code>yield</code> 替换成 <code>await</code>，仅此而已。</p><p>相对于 Generator 的改进主要集中集中在：</p><ul><li><strong>内置执行器</strong></li><li><strong>更好的语义化</strong></li><li><strong>Promise 的返回值</strong></li></ul><p>到这里大家会发现，Async/Await 本质也是 Promise 的语法糖：Async 函数返回了 Promise 对象。</p><p>async/await 和 Promise 的关系非常的巧妙，<strong>await必须在async内使用</strong>，<strong>并装饰一个Promise对象</strong>，<strong>async返回的也是一个Promise对象</strong>。</p><p>await 关键字使JavaScript运行时暂停于此行，允许其他代码在此期间执行，直到异步函数调用返回其结果。</p><p><code>await</code> 关键字<strong>会阻塞其后的代码</strong>，直到promise完成，就像执行同步操作一样。<strong>它确实可以允许其他任务在此期间继续运行，但您自己的代码被阻塞。</strong></p><h2 id="事件循环机制⭐"><a href="#事件循环机制⭐" class="headerlink" title="事件循环机制⭐"></a>事件循环机制⭐</h2><blockquote><p>事件循环负责收集事件（包括用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。然后它执行所有处于等待中的 JavaScript 任务（宏任务），然后是微任务，然后在开始下一次循环之前执行一些必要的渲染和绘制操作。</p></blockquote><p>任务的执行模式</p><ul><li><p>同步：连续性、阻塞</p></li><li><p>异步</p><ul><li>宏任务（Macrotask，Task，宿主（浏览器、Node）发起）：script（整体代码块）、setTimeout、setInterval</li><li>微任务（Microtask，Jobs， JS 自身发起）：Promise.[ then/catch/finally ]、queueMicrotask</li></ul></li></ul><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bt7ZTO"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/bt7ZTO.png" alt="bt7ZTO.png"></a></p><ol><li>判断宏任务队列是否为空<ul><li>不空 –&gt; 执行最早进入队列的任务 –&gt; 执行下一步</li><li>空 –&gt; 执行下一步</li></ul></li><li>判断微任务队列是否为空<ul><li>不空 –&gt; 执行最早进入队列的任务 –&gt; <strong>继续检查微任务队列空不空</strong></li><li>空 –&gt; 执行下一步</li></ul></li></ol><p><strong>如何理解 script（整体代码块）是个宏任务呢</strong></p><p>script标签在设置defer和async属性可以异步执行，可以看作是一个异步任务。</p><p>同时存在两个 script 代码块，会首先在执行<strong>第一个 script 代码块中的同步代码</strong>，如果这个过程中创建了微任务并进入了微任务队列，第一个 script 同步代码执行完之后，会首先去<strong>清空微任务队列</strong>，再去开启<strong>第二个 script 代码块</strong>的执行。所以这里应该就可以理解 script（整体代码块）为什么会是宏任务。</p><p>首次执行<strong>宏队列中会有 script（整体代码块）任务</strong>，所以实际上就是 Js 解析完成后，在异步任务中，会<strong>先执行完所有的微任务</strong>。需要注意的是，<strong>新创建的微任务会立即进入微任务队列排队执行，不需要等待下一次轮回</strong>。</p><p>所谓任务，浅显来说就是<strong>代码块开始执行的入口</strong>(确切地说，是函数栈的入口，但是栈的概念较为复杂，不表)。</p><p>而在 <code>JS</code> 里，除了“<code>script</code>整体代码块”之外，<strong>所有代码块的入口都是“回调函数”</strong>，回调函数被注册到事件后不会马上被执行，而是保存在一个神秘的的地方，保存起来待执行的才能算“任务”，然后才有宏/微任务之分。</p><p>“<code>script</code>整体代码块”的特殊之处，在于<strong>它的入口不是回调函数</strong>，但是我们可以想象它被装在一个隐形的函数里，作为回调函数被注册到某个事件里（大概是它解析完成之后会触发的一个事件），这时候这个隐形的函数就成为了一个任务。</p><p>浏览器<code>UI</code>是多线程的，异步任务借助浏览器的线程和<code>JavaScript</code>的执行机制实现。</p><p><strong>queueMicrotask</strong></p><p><strong>可以安全的引入微任务而避免使用额外的技巧</strong>。由晦涩地使用 promise 去创建微任务而带来的风险就可以被避免了。举例来说，当使用 promise 创建微任务时，由回调抛出的异常被报告为 rejected promises 而不是标准异常。同时，创建和销毁 promise 带来了事件和内存方面的额外开销，这是正确入列微任务的函数应该避免的。</p><h2 id="展开语法、剩余参数"><a href="#展开语法、剩余参数" class="headerlink" title="展开语法、剩余参数"></a>展开语法、剩余参数</h2><ul><li><strong>展开语法</strong>（扩展运算符<code>...</code>）是将<strong>数组</strong>或者<strong>可迭代对象</strong>拆分成逗号分隔的参数序列。</li><li><strong>剩余参数</strong>语法允许我们<strong>将一个不定数量的参数表示为一个数组</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  alert(theArgs.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>展开语法:<code>...</code>，剩余参数：<code>theArgs</code></p><p>剩余（Rest）语法看起来和扩展（Spread）语法完全一样。在某种程度上，剩余语法与扩展语法相反。扩展语法将数组“展开”为其元素，而剩余语法收集多个元素并将它们“压缩”为单个元素。</p><p>剩余参数和 <code>arguments</code>对象之间的区别主要有三个：</p><ul><li>剩余参数只包含那些没有对应形参的实参，而 <code>arguments</code> 对象包含了传给函数的所有实参。</li><li><code>arguments</code>对象不是一个真正的数组，而剩余参数是真正的 <code>Array</code>实例，也就是说你能够在它上面直接使用所有的数组方法，比如 <code>sort</code>，<code>map</code>，<code>forEach</code>或<code>pop</code>。</li><li><code>arguments</code>对象还有一些附加的属性 （如<code>callee</code>属性）。</li></ul><h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><p><strong>调用生成器函数会返回一个生成器对象，每次调用生成器对象的 next 方法会执行函数到下一次 yield 关键字停止执行，并且返回一个 <code>&#123; value: Value, done: boolean &#125;</code>的对象。</strong></p><p><strong>当我们为 next 传递值进行调用时，传入的值会被当作上一次生成器函数暂停时 yield 关键字的返回值处理。</strong></p><p>生成器<code>generator</code>是<code>ES6</code>标准引入的新的数据类型，一个<code>generator</code>看上去像一个函数，但可以返回多次，通过<code>yield</code>关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul><li><code>Generator.prototype.next()</code>：返回一个由<code>yield</code>表达式生成的值。</li><li><code>Generator.prototype.return()</code>：返回给定的值并结束生成器。</li><li><code>Generator.prototype.throw()</code>：向生成器抛出一个错误。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用<code>function*</code>声明方式会定义一个生成器函数<code>generator function</code>，它返回一个<code>Generator</code>对象。</p><p>可以把它理解成，<code>Generator</code>函数是一个状态机，封装了多个内部状态，执行<code>Generator</code>函数会返回一个遍历器对象。</p><p>调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的迭代器<code>iterator</code>对象，他是一个<strong>指向内部状态对象的指针</strong>。</p><p>当这个迭代器的<code>next()</code>方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现<code>yield</code>的位置为止，<code>yield</code>后紧跟迭代器要返回的值，也就是指针就会从函数头部或者上一次停下来的地方开始执行到下一个<code>yield</code>。</p><p>或者如果用的是<code>yield*</code>，则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。</p><p><code>next()</code>方法返回一个对象，这个对象包含两个属性：<code>value</code>和<code>done</code>，</p><ul><li><code>value</code>属性表示本次<code>yield</code>表达式的返回值，</li><li><code>done</code>属性为布尔类型，表示生成器后续是否还有<code>yield</code>语句，即生成器函数是否已经执行完毕并返回。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// f &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 11, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 21, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 31, done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: undefined, done: true&#125; // 可以无限next()，但是value总为undefined，done总为true</span></span><br></pre></td></tr></table></figure><p>调用<code>next()</code>方法时，如果传入了参数，那么这个参数会传给上一条执行的<code>yield</code>语句左边的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(y);</span><br><span class="line">    <span class="keyword">yield</span> x + y;</span><br><span class="line">    <span class="built_in">console</span>.log(x,y);</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// f &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 11, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="number">50</span>)); <span class="comment">// &#123;value: 51, done: false&#125; // y被赋值为50</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 31, done: true&#125; // x,y 1,50</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>若显式指明<code>return</code>方法给定返回值，则返回该值并结束遍历<code>Generator</code>函数，若未显式指明<code>return</code>的值，则返回<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// f &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 11, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 21, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 31, done: false&#125; // 注意此处的done为false</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p><code>yield*</code>表达式表示<code>yield</code>返回一个遍历器对象，用于在<code>Generator</code>函数内部，调用另一个 <code>Generator</code>函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">callee</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">300</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">yield</span>* callee();</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// f &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 11, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 100, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 200, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: 31, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h5 id="异步操作的同步化表达"><a href="#异步操作的同步化表达" class="headerlink" title="异步操作的同步化表达"></a>异步操作的同步化表达</h5><p><code>yield</code>表达式可以暂停函数执行，<code>next</code>方法用于恢复函数执行，这使得<code>Generator</code>函数非常适合将异步任务同步化。</p><h1 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h1><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p><strong>递归</strong>的思路去实现一个深拷贝方法。WeakMap解决<strong>循环引用</strong>。</p><p>假设我们使用的 Map，那么 <code>foo</code> 对象和我们深拷贝内部的 <code>const map = new Map()</code> 创建的 <code>map</code> 对象一直都是强引用关系，那么在程序结束之前，<code>foo</code> 不会被回收，其占用的内存空间一直不会被释放。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝简易版本</span></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function"><span class="params">source</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 WeakMap 对象，记录已拷贝过的对象</span></span><br><span class="line">    <span class="keyword">const</span> weakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">    <span class="comment">//拷贝（递归）</span></span><br><span class="line">    <span class="keyword">const</span> copy = <span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 当输入为函数或基本数据类型时，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">&#x27;function&#x27;</span> || !isObject(input)) <span class="keyword">return</span> input;</span><br><span class="line">        <span class="comment">// 针对已拷贝过的对象，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (weakmap.has(input)) &#123;</span><br><span class="line">            <span class="keyword">return</span> weakmap.get(input)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是数组(toString.call)还是对象(typeof 注意null)</span></span><br><span class="line">        <span class="keyword">const</span> output = isArray(input) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="comment">// 记录每次拷贝的对象(需要放在递归引用的前面)</span></span><br><span class="line">        weakmap.set(input, output);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> input) &#123;</span><br><span class="line">            <span class="comment">// 如果key是对象的自有属性</span></span><br><span class="line">            <span class="keyword">if</span> (input.hasOwnProperty(key)) &#123;</span><br><span class="line">                <span class="comment">// 递归调用深拷贝方法</span></span><br><span class="line">                output[key] = copy(input[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new⭐"><a href="#new⭐" class="headerlink" title="new⭐"></a>new⭐</h2><p><strong>new 运算符</strong>用于创建一个给定构造函数的实例对象。</p><p><strong>new</strong> 关键字会进行如下的操作：</p><ol><li>创建一个空的简单JavaScript对象（即<code>&#123;&#125;</code>）；</li><li>将该对象的<code>__proto__</code>指向构造函数原型<code>prototype</code>；</li><li>将步骤1新创建的对象作为<code>this</code>的上下文执行构造函数 ；</li><li>如果<strong>构造函数没有返回对象</strong>，则返回<code>this</code>（新创建的对象）。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化后 new 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1、通过call，this指向了arguments(封装实参的对象)，shift删除并获得arguments中第一个参数——构造函数</span></span><br><span class="line">  Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 2、创建一个空的对象并将该对象的__proto__指向构造函数原型</span></span><br><span class="line">  <span class="comment">// obj.__proto__ 影响性能，不建议用</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(Con.prototype);</span><br><span class="line">  <span class="comment">// 3、绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">  <span class="keyword">let</span> ret = Con.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 4、优先返回构造函数返回的对象</span></span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>shift/unshift</code> 方法并不局限于数组：这个方法能够通过 <code>call()</code> 或 <code>apply()</code>方法作用于类似数组的对象上。</p><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><p>**<code>Object.create()</code>**方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</p><table><thead><tr><th>比较</th><th>new</th><th>Object.create</th></tr></thead><tbody><tr><td>构造函数</td><td>保留原构造函数属性</td><td>丢失原构造函数属性</td></tr><tr><td>原型链</td><td>原构造函数prototype属性</td><td>原构造函数/（对象）本身</td></tr><tr><td>作用对象</td><td>function</td><td>function和object</td></tr></tbody></table><p>利用一个<strong>空对象</strong>作为中介，将<strong>某个对象直接赋值给空对象构造函数的原型</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>object()对传入其中的对象执行了一次<code>浅复制</code>，<strong>将构造函数F的原型直接指向传入的对象</strong>。</p><h2 id="call、apply、bind区别"><a href="#call、apply、bind区别" class="headerlink" title="call、apply、bind区别"></a>call、apply、bind区别</h2><ul><li>三者都可以改变函数的<code>this</code>对象指向</li><li>三者第一个参数都是<code>this</code>要指向的对象，如果如果没有这个参数或参数为<code>undefined</code>或<code>null</code>，则默认指向全局<code>window</code></li><li>三者都可以传参，但是<code>apply</code>是数组，而<code>call</code>是参数列表，且<code>apply</code>和<code>call</code>是一次性传入参数，而<code>bind</code>可以分为多次传入</li><li><code>bind</code>是返回绑定this之后的函数，<code>apply</code>、<code>call</code> 则是立即执行</li></ul><h3 id="模拟实现-call"><a href="#模拟实现-call" class="headerlink" title="模拟实现 call"></a>模拟实现 call</h3><ul><li><strong>将函数设置为绑定对象的属性</strong></li><li>执行函数</li><li>删除对象的这个属性</li><li>将返回值返回</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._call = <span class="function"><span class="keyword">function</span> (<span class="params">context,...args</span>) </span>&#123;<span class="comment">// 拓展Function原型，使用Rest操作符接收剩余参数</span></span><br><span class="line">    <span class="comment">// 非严格模式下, 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中就是 window 对象)</span></span><br><span class="line">    <span class="comment">// 值为原始值(数字，字符串，布尔值)的 this 会指向该原始值的自动包装对象(用 Object() 转换）</span></span><br><span class="line">    context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>; </span><br><span class="line">    <span class="comment">// 将函数fn设为对象的属性</span></span><br><span class="line">    <span class="comment">// newCall由函数调用，此时的this指向函数，是一种隐式绑定</span></span><br><span class="line">    context.fn = <span class="built_in">this</span>; </span><br><span class="line">    <span class="comment">// 执行该函数</span></span><br><span class="line">    <span class="keyword">const</span> result = context.fn(...args); </span><br><span class="line">    <span class="comment">// 删除该函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="comment">// 将返回值返回</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟实现-apply"><a href="#模拟实现-apply" class="headerlink" title="模拟实现 apply"></a>模拟实现 apply</h3><p>跟call思路类似，主要是第二个参数是一个数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">    context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>; </span><br><span class="line">    <span class="comment">// 将函数设为对象的属性</span></span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 执行该函数</span></span><br><span class="line">    <span class="keyword">const</span> result = context.fn(...arr);</span><br><span class="line">    <span class="comment">// 删除该函数  </span></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="comment">// 将返回值返回</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟实现bind"><a href="#模拟实现bind" class="headerlink" title="模拟实现bind"></a>模拟实现bind</h3><p>利用了闭包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._bind = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args1</span>) </span>&#123; <span class="comment">// 拓展Function原型，使用Rest操作符接收剩余参数</span></span><br><span class="line">    <span class="comment">// 箭头函数不会生成自身作用域下的this，会从自己的作用域链的上一层继承this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args2</span>) =&gt;</span> &#123; </span><br><span class="line">        context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>;  </span><br><span class="line">        context.fn = <span class="built_in">this</span>; <span class="comment">// 调用箭头函数时的this指向的是调用者也就是函数对象，将函数对象赋值给context对象的一个属性</span></span><br><span class="line">        <span class="keyword">const</span> result = context.fn(...args1, ...args2); <span class="comment">// 调用context.fn时，fn中的this指针指向的是context，并使用Spread操作符展开参数传参</span></span><br><span class="line">        <span class="keyword">delete</span> context.fn; <span class="comment">// 删除context对象的fn属性</span></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 将返回值返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>; <span class="comment">// 定义一个全局变量</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">2</span>&#125; <span class="comment">// 定义一个对象用来绑定</span></span><br><span class="line"><span class="keyword">var</span> funct = <span class="function"><span class="keyword">function</span>(<span class="params">b, c</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.a,b,c); <span class="keyword">return</span> <span class="number">1</span>; &#125;; <span class="comment">// 定义一个函数用来执行</span></span><br><span class="line"></span><br><span class="line">funct(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1 1 2  // 直接执行，相当于window.funct(1, 2)，this绑定于window</span></span><br><span class="line">funct._call(obj, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 2 1 2 // 使用call将this绑定到obj对象</span></span><br><span class="line">funct._apply(obj, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 2 1 2 // 使用apply将this绑定到obj对象</span></span><br><span class="line"><span class="keyword">var</span> bindFunct = funct._bind(obj, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 使用bind将this绑定到obj对象，bind方法返回一个原函数的拷贝，并拥有指定的this值和初始参数。</span></span><br><span class="line">bindFunct(); <span class="comment">// 2 1 2 </span></span><br></pre></td></tr></table></figure><h2 id="防抖-节流"><a href="#防抖-节流" class="headerlink" title="防抖/节流"></a>防抖/节流</h2><p>作用都是为了<strong>防止函数被高频调用。</strong></p><p>当函数会进行<code>DOM</code>操作或者具有<strong>请求服务器</strong>等行为并且作为高频事件，就需要进行<strong>事件处理函数执行频率的控制</strong>，否则会造成大量的<strong>资源浪费</strong>致使<strong>性能下降</strong>，当然无论是防抖与节流实质上并没有减少事件触发次数，而是通过<strong>减少事件处理函数的执行次数</strong>从而提高性能。</p><p><strong>应用场景</strong></p><ul><li><p>防抖</p><ul><li><p>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。</p></li><li><p>window触发<code>resize</code>的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次。</p><p><code>resize</code> CSS 属性允许你控制一个元素的可调整大小性。</p></li></ul></li><li><p>节流</p><ul><li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li><li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li></ul></li></ul><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><h4 id="非立即防抖"><a href="#非立即防抖" class="headerlink" title="非立即防抖"></a>非立即防抖</h4><p>当持续触发事件的时候，事件处理函数是完全不执行的，等<strong>最后一次触发结束的一段时间之后，再去执行</strong>。</p><p>最常见的例子就是<strong>搜索</strong>建议功能，当用户进行持续输入时，并不会请求服务器进行搜索建议的计算，直至用户输入完成后的<code>N</code>毫秒后才会将数据传输至后端并返回搜索建议。<br>实现思路：<strong>每次触发事件时都取消之前的延时调用方法并重设定时器</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">wait, funct, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 闭包里存变量timer</span></span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 箭头函数，this指向即为debounce中的this</span></span><br><span class="line">    <span class="comment">// 谁调用debounce,this最终指向谁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 每次触发事件时都取消之前的延时调用方法并重设定时器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> funct(...args), wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onclick = debounce(<span class="number">300</span>, <span class="function">(<span class="params">a</span>) =&gt;</span> <span class="built_in">console</span>.log(a), <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="立即防抖"><a href="#立即防抖" class="headerlink" title="立即防抖"></a>立即防抖</h4><p>当持续触发事件的时候，事件处理函数会<strong>立即执行</strong>，然后不再执行事件处理函数，直至<strong>最后一次事件触发之后的一段时间后才允许再次执行事件处理函数</strong>。<br>实现思路：<strong>判断是否存在定时器，没有则执行事件处理函数，然后无论是否已经存在定时器都需要重设定时器</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">wait, funct, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!timer)  funct(...args);</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> timer = <span class="literal">null</span>, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onclick = debounce(<span class="number">300</span>, <span class="function">(<span class="params">a</span>) =&gt;</span> <span class="built_in">console</span>.log(a), <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>当事件持续触发时，节流操作可以稀释事件处理函数执行频率，假设在<code>1s</code>内<code>onmousemove</code>事件触发了<code>100</code>次，通过节流就可以使得<code>onmousemove</code>事件的事件处理函数每<code>100ms</code>触发一次，也就是在<code>1s</code>内<code>onmousemove</code>事件的事件处理函数只执行<code>10</code>次。</p><h5 id="时间戳实现"><a href="#时间戳实现" class="headerlink" title="时间戳实现"></a>时间戳实现</h5><p>实现思路：通过<strong>时间戳</strong>记录上次事件处理函数执行时间，事件触发时若时间差大于执行周期则执行事件处理函数并赋值执行时间为当前时间戳。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">wait, funct, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">if</span>(now - previous &gt; wait)&#123;</span><br><span class="line">            funct(...args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onclick = throttle(<span class="number">1000</span>, <span class="function">(<span class="params">a</span>) =&gt;</span> <span class="built_in">console</span>.log(a), <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h5 id="定时器实现"><a href="#定时器实现" class="headerlink" title="定时器实现"></a>定时器实现</h5><p>实现思路：判断是否存在定时器，没有则执行事件处理函数并重设定时器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">wait, funct, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">            funct(...args);</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> timer = <span class="literal">null</span>, wait);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onclick = throttle(<span class="number">1000</span>, <span class="function">(<span class="params">a</span>) =&gt;</span> <span class="built_in">console</span>.log(a), <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="Ajax⭐"><a href="#Ajax⭐" class="headerlink" title="Ajax⭐"></a>Ajax⭐</h2><p>一种异步请求数据的web开发技术，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。</p><h3 id="原生Ajax"><a href="#原生Ajax" class="headerlink" title="原生Ajax"></a>原生Ajax</h3><blockquote><p>XMLHttpRequest（XHR）对象用于与服务器交互。</p></blockquote><ul><li><p>创建<code>XMLHttpRequest</code> 对象。<code>const xhr = new XMLHttpRequest()</code></p></li><li><p>使用<code>open</code>方法设置请求的参数。<code>xhr.open(method, url, 是否异步)</code>。</p><ul><li><p><code>get</code>可以把请求参数拼接在<code>url</code></p></li><li><p>默认异步</p></li><li><p>如果想要使用<code>post</code>提交数据,必须添加此行。</p><p><code>xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</code></p></li></ul></li><li><p>注册<code>onreadystatechange</code>事件，<strong>状态改变时就会调用</strong>。</p><ul><li><code>xhr.readyState===4</code> 请求已完成，且响应已就绪。存有 <code>XMLHttpRequest</code> 的状态。从 0 到 4 发生变化。</li><li><code>(xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300) || xhr.status === 304</code> 304：服务器端资源未改变，可直接使用客户端未过期的缓存。</li></ul></li><li><p>发送请求。</p><ul><li><code>get</code>请求：<code>xhr.send()</code></li><li><code>post</code>请求：将数据通过<code>send</code>方法传递 <code>xhr.send(&#39;name=fox&amp;age=18&#39;);</code></li></ul></li><li><p>获取返回的数据，更新UI。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ajax = <span class="function">(<span class="params">method, url, data</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(method,url);</span><br><span class="line">        <span class="keyword">if</span> (method.toUpperCase() === <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">            xhr.setRequestHeader(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onreadystatechange = <span class="function">()=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> ((xhr.status&gt;=<span class="number">200</span> &amp;&amp; xhr.status&lt;<span class="number">300</span>) || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">                    resolve(xhr.responseText);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(xhr.status);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">ajax(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;https://www.baidu.com&quot;</span>,[]).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p>fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。</p><h3 id="Promise封装axios"><a href="#Promise封装axios" class="headerlink" title="Promise封装axios"></a>Promise封装axios</h3><p>axios是一个基于<code>promise</code>的<code>HTTP</code>库，可以用在<code>浏览器</code>或者<code>node.js</code>中。</p><p>axios是通过promise实现对ajax技术的一种封装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; message &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url,data=&#123;&#125;,type=<span class="string">&#x27;GET&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> promise;</span><br><span class="line">        <span class="comment">// 执行异步ajax请求</span></span><br><span class="line">        <span class="keyword">if</span>(type===<span class="string">&#x27;GET&#x27;</span>)&#123;<span class="comment">//发GET请求</span></span><br><span class="line">            promise=axios.get(url,&#123;</span><br><span class="line">                <span class="attr">params</span>:data</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//发POST请求</span></span><br><span class="line">            promise=axios.post(url,data)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果请求成功了，调用resolve(value)</span></span><br><span class="line">        <span class="comment">// 该方法返回一个以response.data值解析后的Promise对象</span></span><br><span class="line">        promise.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(response.data)</span><br><span class="line">            <span class="comment">// console.log(response.data)</span></span><br><span class="line">        <span class="comment">// 如果请求失败了，不调用reject(reason)，而是提示异常信息（统一处理异常）   </span></span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            message.error(<span class="string">&#x27;请求出错了：&#x27;</span>+error.message)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><ol><li><code>instanceof</code> 判断<strong>对象的原型链上是否存在构造函数的原型</strong>。只能判断引用类型。</li><li><code>instanceof</code> 常用来判断 <code>A</code> 是否为 <code>B</code> 的实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instanceof 的内部实现 </span></span><br><span class="line"><span class="keyword">const</span> instance_of = <span class="function">(<span class="params">Case,Constructor</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 基本数据类型返回false</span></span><br><span class="line">    <span class="comment">// 兼容一下函数对象</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">typeof</span>(Case) !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span>(Case) !== <span class="string">&#x27;function&#x27;</span>) || Case === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> CaseProto = <span class="built_in">Object</span>.getPrototypeOf(Case);<span class="comment">//返回指定对象的原型</span></span><br><span class="line">    <span class="comment">// let CaseProto = Case.__proto__;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 查到原型链顶端，仍未查到，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (CaseProto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 找到相同的原型</span></span><br><span class="line">        <span class="keyword">if</span> (CaseProto === Constructor.prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// CaseProto = CaseProto.__proto__;</span></span><br><span class="line">        CaseProto = <span class="built_in">Object</span>.getPrototypeOf(CaseProto);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何获取到一个实例对象的原型对象？</p><ul><li>从 <code>构造函数</code> 获得原型对象：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造函数.prototype</span><br></pre></td></tr></table></figure><ul><li>从 <code>对象实例</code> 获得 <code>父级原型对象</code>：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法一：对象实例.__proto__        【 有兼容性问题，不建议使用】</span><br><span class="line">方法二：<span class="built_in">Object</span>.getPrototypeOf( 对象实例 )</span><br></pre></td></tr></table></figure><h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>通过将<strong>子类的原型对象指向父类的实例</strong>，实现继承访问父类属性方法等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line">SubType.prototype.constructor = SubType; <span class="comment">// 修复constructor使符合原型链规定</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>原型链方案存在的缺点：</p><ul><li>由于所有SubType实例原型都指向同一个SuperType实例, 因此<strong>对某个SubType实例的来自父类的引用类型变量修改会影响所有的SubType实例</strong>。</li><li>在创建子类实例时无法向父类构造传参, 即没有实现super()的功能。</li></ul><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>构造函数继承，即在<strong>子类的构造函数中执行父类的构造函数，并为其绑定子类的this</strong>，让父类的构造函数把成员属性和方法都挂到子类的this上去，这样既<strong>能避免实例之间共享一个原型实例，又能向父类构造方法传参</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color=[<span class="string">&quot;red&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;blue&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承自SuperType</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.color.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">alert(instance1.color);<span class="comment">//&quot;red,green,blue,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.color);<span class="comment">//&quot;red,green,blue&quot;</span></span><br></pre></td></tr></table></figure><p>核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用<code>SuperType</code>构造函数，于是<code>SubType</code>的每个实例都会将<code>SuperType</code>中的属性复制一份。</p><p>缺点：</p><ul><li>只能继承父类的<strong>实例</strong>属性和方法，不能继承<strong>原型</strong>属性/方法</li><li>无法实现复用，每个子类实际上是调用父类来生成的实例</li></ul><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合上述两种方法就是组合继承。用原型链实现对<strong>原型</strong>属性和方法的继承，用借用构造函数技术来实现<strong>实例</strong>属性的继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="comment">// 第二次调用SuperType()</span></span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="comment">// 构建原型链</span></span><br><span class="line"><span class="comment">// 第一次调用SuperType()</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line"><span class="comment">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span></span><br><span class="line">SubType.prototype.constructor = SubType; </span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line">instance1.sayName(); <span class="comment">//&quot;Nicholas&quot;;</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//&quot;red,blue,green&quot;</span></span><br><span class="line">instance2.sayName(); <span class="comment">//&quot;Greg&quot;;</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性<code>name</code>，<code>color</code>。</li><li>第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性<code>name</code>，<code>color</code>。</li></ul><p>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象<code>SubType.prototype</code>的两个同名属性。所以，组合模式的缺点就是在<strong>使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</strong></p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p><strong>解决构造函数被执行两次</strong>的问题, 我们将<strong>指向父类实例改为指向父类原型</strong>, 减去一次构造函数的执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(superType.prototype); <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">  prototype.constructor = subType;                    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">  subType.prototype = prototype;                      <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类初始化实例属性和原型属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将子类的原型对象指向父类原型</span></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类原型属性</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;xyc&quot;</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;lxy&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">instance1.colors.push(<span class="string">&quot;2&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]</span></span><br><span class="line">instance1.colors.push(<span class="string">&quot;3&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;]</span></span><br></pre></td></tr></table></figure><p>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code> 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code> 和<code>isPrototypeOf()</code></p><p><strong>这是最成熟的方法，也是现在库实现的方法</strong>。</p><h3 id="ES6类继承extends"><a href="#ES6类继承extends" class="headerlink" title="ES6类继承extends"></a>ES6类继承extends</h3><p><code>extends</code>关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中<code>constructor</code>表示构造函数，一个类中只能有一个构造函数，有多个会报出<code>SyntaxError</code>错误,如果没有显式指定构造方法，则会添加默认的 <code>constructor</code>方法，使用例子如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getter</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.calcArea()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Method</span></span><br><span class="line">    <span class="function"><span class="title">calcArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rectangle.area);</span><br><span class="line"><span class="comment">// 输出 200</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(length, length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Square&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> Square(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(square.area);</span><br><span class="line"><span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建 MyPromise.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义三个常量表示状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"><span class="comment">// 新建 MyPromise 类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共字段存储状态和结果变量</span></span><br><span class="line">    <span class="comment">// 储存状态的变量，初始值是pending</span></span><br><span class="line">    status = PENDING;</span><br><span class="line">    <span class="comment">// 成功之后的值</span></span><br><span class="line">    value = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 失败之后的原因</span></span><br><span class="line">    reason = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 存储成功回调函数</span></span><br><span class="line">    onFulfilledCallbacks = [];</span><br><span class="line">    <span class="comment">// 存储失败回调函数</span></span><br><span class="line">    onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果直接调用的话，普通函数resolve和reject内部this指向的是undefined</span></span><br><span class="line">        <span class="comment">// 用箭头函数就可以让this指向当前实例对象</span></span><br><span class="line">        <span class="comment">// 更改成功后的状态</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = FULFILLED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">                <span class="built_in">this</span>.value = value;<span class="comment">// 保存成功之后的值</span></span><br><span class="line">                <span class="comment">// resolve里面将所有成功的回调拿出来执行</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">this</span>.onFulfilledCallbacks.length) &#123;</span><br><span class="line">                    <span class="comment">// Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空</span></span><br><span class="line">                    <span class="built_in">this</span>.onFulfilledCallbacks.shift()(value)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更改失败后的状态</span></span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = REJECTED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">                <span class="built_in">this</span>.reason = reason;<span class="comment">// 保存失败后的原因</span></span><br><span class="line">                <span class="comment">// reject里面将所有失败的回调拿出来执行</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">this</span>.onRejectedCallbacks.length) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.onRejectedCallbacks.shift()(reason);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// executor 是一个执行器，进入会立即执行</span></span><br><span class="line">        <span class="comment">// 并传入resolve和reject方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// 如果有错误，就直接执行reject</span></span><br><span class="line">            reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不传，就使用默认函数</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了链式调用这里直接创建一个MyPromise，并在后面return出去</span></span><br><span class="line">        <span class="comment">// promise有暂时性死区，初始化之后才能使用</span></span><br><span class="line">        <span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 这里的内容在执行器中，会立即执行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">                <span class="comment">// 创建一个微任务等待 promise 完成初始化</span></span><br><span class="line">                queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取成功回调函数的执行结果</span></span><br><span class="line">                        <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                        <span class="comment">// 传入 resolvePromise 集中处理</span></span><br><span class="line">                        resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">                <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">                queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                        resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">                <span class="comment">// 等到执行成功失败函数的时候再传递</span></span><br><span class="line">                <span class="built_in">this</span>.onFulfilledCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                            resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                            reject(error);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                            resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                            reject(error);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 封装一个函数统一处理回调函数的执行结果 </span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, result, resolve, reject</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 如果相等了，说明return的是自己，抛出类型错误并返回</span></span><br><span class="line">                <span class="keyword">if</span> (promise === result) &#123;</span><br><span class="line">                    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断result是不是 MyPromise 实例对象</span></span><br><span class="line">                <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                    <span class="comment">// 执行 result，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span></span><br><span class="line">                    <span class="comment">// result.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span></span><br><span class="line">                    <span class="comment">// 简化之后</span></span><br><span class="line">                    result.then(resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 普通值</span></span><br><span class="line">                    resolve(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line">    <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// resolve 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果这个值是一个 promise ，那么将返回这个 promise </span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则返回的promise将以此值完成。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(value);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reject 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//all 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;<span class="comment">//记录resolve次数</span></span><br><span class="line">        <span class="keyword">let</span> result = [];<span class="comment">// 输入的所有promise的resolve回调的结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">                MyPromise.resolve(p).then(</span><br><span class="line">                    <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                        index++;</span><br><span class="line">                        result[i] = val;</span><br><span class="line">                        <span class="comment">//所有then执行后, resolve结果,结果为一个数组</span></span><br><span class="line">                        <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">                            resolve(result);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="comment">//有一个Promise被reject时，MyPromise的状态变为reject</span></span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">                <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">                MyPromise.resolve(p).then(resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//finally方法</span></span><br><span class="line">    <span class="function"><span class="title">finally</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">            <span class="comment">// MyPromise.resolve执行回调,并在then中return结果传递给后面的Promise</span></span><br><span class="line">            <span class="function"><span class="params">value</span> =&gt;</span> MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> value),    </span><br><span class="line">            <span class="comment">// reject同理         </span></span><br><span class="line">            <span class="function"><span class="params">reason</span> =&gt;</span> MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)  </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//allSettled方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">allSettled</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (promises.length === <span class="number">0</span>) <span class="keyword">return</span> MyPromise.resolve([])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = []; <span class="comment">//输入的所有promise的resolve回调的结果</span></span><br><span class="line">            <span class="keyword">let</span> count = promises.length;</span><br><span class="line"></span><br><span class="line">            promises.forEach(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">                MyPromise.resolve(promise).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                    result[index] = &#123;</span><br><span class="line">                        <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">                        value</span><br><span class="line">                    &#125;</span><br><span class="line">                    count--;</span><br><span class="line">                    <span class="comment">// resolve after all are settled</span></span><br><span class="line">                    <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                    result[index] = &#123;</span><br><span class="line">                        <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">                        reason</span><br><span class="line">                    &#125;</span><br><span class="line">                    count--;</span><br><span class="line">                    <span class="comment">// resolve after all are settled</span></span><br><span class="line">                    <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拷贝数组"><a href="#拷贝数组" class="headerlink" title="拷贝数组"></a>拷贝数组</h2><p>浅拷贝（只能拷贝一层对象（数组）。）</p><ul><li><strong>concat()</strong> <code>let newArr = arr.concat();</code></li><li><strong>slice()</strong> <code>let newArr = arr.slice();</code></li><li><strong>…展开运算符</strong> <code>let newArr = [...arr];</code></li><li><strong>Array.from</strong> <code>let newArr3 = Array.from(arr);</code></li></ul><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><h3 id="最简单Set"><a href="#最简单Set" class="headerlink" title="最简单Set"></a>最简单Set</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line">    <span class="comment">// return Array.from(new Set(arr));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="indexOf-includes-for-forEach"><a href="#indexOf-includes-for-forEach" class="headerlink" title="indexOf/includes+for/forEach"></a>indexOf/includes+for/forEach</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newArr = [];</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// if(newArr.indexOf(v) === -1)  newArr.push(v);</span></span><br><span class="line">        <span class="keyword">if</span>(!newArr.includes(v)) newArr.push(v);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="filter配合indexOf"><a href="#filter配合indexOf" class="headerlink" title="filter配合indexOf"></a>filter配合indexOf</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 将原数组中每一个首次出现的元素存入新数组</span></span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item,index,arr</span>) =&gt;</span> arr.indexOf(item)===index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reduce配合includes"><a href="#reduce配合includes" class="headerlink" title="reduce配合includes"></a>reduce配合includes</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// res最初是[],遍历每一个元素，如果不在res中就放入，最后返回res</span></span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">res,cur</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!res.includes(cur))res.push(cur);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,[])  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原数组直接去重"><a href="#原数组直接去重" class="headerlink" title="原数组直接去重"></a>原数组直接去重</h3><p><code>sort</code> 排序后，使用快慢指针的思想</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);<span class="comment">//升序排序</span></span><br><span class="line">    <span class="keyword">let</span> slow = <span class="number">1</span>,fast =<span class="number">1</span>;<span class="comment">//快慢指针起始点都是第二个</span></span><br><span class="line">    <span class="keyword">while</span>(fast&lt;arr.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[fast] !== arr[fast-<span class="number">1</span>])&#123;</span><br><span class="line">            arr[slow++] = arr[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.length = slow;<span class="comment">// 去重后数组长度,原数组多余部分会被删除</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何实现数组扁平化"><a href="#如何实现数组扁平化" class="headerlink" title="如何实现数组扁平化"></a>如何实现数组扁平化</h2><p>数组扁平化就是把多维数组转化成一维数组。</p><h3 id="ES6提供的新方法-flat-depth"><a href="#ES6提供的新方法-flat-depth" class="headerlink" title="ES6提供的新方法 flat(depth)"></a>ES6提供的新方法 flat(depth)</h3><p>不会改变原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,[<span class="number">5</span>]]]];  </span><br><span class="line">a.flat(<span class="number">4</span>-<span class="number">1</span>); <span class="comment">// [1,2,3,4,5]  a是4维数组</span></span><br><span class="line">a.flat(<span class="literal">Infinity</span>); <span class="comment">// [1,2,3,4,5]  a是4维数组</span></span><br></pre></td></tr></table></figure><h3 id="reduce方法-递归"><a href="#reduce方法-递归" class="headerlink" title="reduce方法 递归"></a>reduce方法 递归</h3><p>这里使用的是数组的reduce方法，需要注意的是reduce方法，我们传递了两个参数，<br>第一个参数就是就是处理扁平化的箭头函数<br>第二个参数是一个空数组，也是作为遍历的开始。（res）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flatten = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">res,next</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res.concat(<span class="built_in">Array</span>.isArray(next)?flatten(next):next);</span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平铺数组转树形结构"><a href="#平铺数组转树形结构" class="headerlink" title="平铺数组转树形结构"></a>平铺数组转树形结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">	&#123; <span class="attr">id</span>: <span class="string">&#x27;001&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;节点1&#x27;</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">id</span>: <span class="string">&#x27;0011&#x27;</span>, <span class="attr">parentId</span>: <span class="string">&#x27;001&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;节点1-1&#x27;</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">id</span>: <span class="string">&#x27;00111&#x27;</span>, <span class="attr">parentId</span>: <span class="string">&#x27;0011&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;节点1-1-1&#x27;</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">id</span>: <span class="string">&#x27;002&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;节点2&#x27;</span> &#125;,</span><br><span class="line">  ]</span><br><span class="line"><span class="keyword">const</span> generateTree = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">		item.chidren = arr.filter(<span class="function"><span class="params">item1</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> item.id === item1.parentId</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span> item.parentId === <span class="literal">undefined</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(generateTree(arr))</span><br></pre></td></tr></table></figure><h2 id="随机打乱数组shuffle"><a href="#随机打乱数组shuffle" class="headerlink" title="随机打乱数组shuffle"></a>随机打乱数组shuffle</h2><p>Fisher–Yates shuffle 洗牌算法可以做到理论上的完全乱序</p><p>lodash.js 中的 shuffle 函数也使用此算法实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shuffle = <span class="function"><span class="params">arr</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> point =arr.length-<span class="number">1</span>;point&gt;=<span class="number">0</span>;point--)&#123;</span><br><span class="line">        <span class="comment">// Math.random() [0,1)</span></span><br><span class="line">        index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*point);</span><br><span class="line">        [arr[index],arr[point]]=[arr[point],arr[index]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算机网络和浏览器"><a href="#计算机网络和浏览器" class="headerlink" title="计算机网络和浏览器"></a>计算机网络和浏览器</h1><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><strong>TCP/IP</strong>体系结构相当于将<strong>OSI</strong>体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p><p>教学时经常把TCP/IP体系结构的<strong>网络接口层</strong>分成了<strong>物理层</strong>和<strong>数据链路层</strong>。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/q8fbgs"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/24/q8fbgs.png" alt="q8fbgs.png"></a></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong> 只需要专注于为用户提供应用功能，不用去关心数据是如何传输的。</p><p>协议：DNS、HTTP等</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p><strong>负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。</p><p><strong>运输层主要使用以下两种协议：</strong></p><ol><li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p><strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong></p><p>IP协议</p><ul><li><strong>寻址</strong>：告诉我们去往下一个目的地该朝哪个方向走。配合<strong>子网掩码</strong>才能算出IP地址的<strong>网络号</strong>和<strong>主机号</strong>。在寻址的过程中，先匹配到相同的网络号，才会去找对应的主机。</li><li><strong>路由</strong>：是根据「下一个目的地」选择路径。</li></ul><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><ul><li>通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）</li><li>主要为网络层提供链路级别传输的服务</li><li><strong>作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）</strong></li></ul><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><ul><li><p><strong>实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong>。</p></li><li><p>当数据准备要从设备发送到网络时，需要把数据包转换成光/电信号，让其可以在物理介质中传输，</p></li><li><p>它主要是为数据链路层提供二进制传输的职务。</p></li></ul><h3 id="为什么网络要分层？"><a href="#为什么网络要分层？" class="headerlink" title="为什么网络要分层？"></a>为什么网络要分层？</h3><ul><li><strong>各层之间相互独立</strong></li><li><strong>提高了整体灵活性</strong> 高内聚，低耦合</li><li><strong>大问题化小</strong></li></ul><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><ul><li>两台电脑可以通过一根<strong>网线</strong>直接连接，进行通信。</li><li>机器一多，可以把网线都接到<strong>集线器</strong>（<strong>物理层</strong>）上，但是集线器会不管三七二十一进行<strong>广播</strong>。</li><li>不想广播，可以用（二层）<strong>交换机</strong>（<strong>数据链路层</strong>），又叫多端口网桥，它比较聪明，会自我学习生产<strong>MAC地址表</strong>，知道消息发到哪，那就<strong>不需要广播</strong>啦。</li><li><strong>互联网</strong>电脑这么多，交换机MAC地址表总不能全放下吧。改用<strong>路由器</strong>（<strong>网络层</strong>），也叫<strong>三层交换机</strong>，通过网段的方式定位要把消息转发到哪，就不需要像交换机那样苦哈哈一条条记录MAC地址啦（具有<strong>MAC地址</strong>和<strong>IP地址</strong>）。</li><li>路由器和光猫之间是好搭档，<strong>光猫</strong>负责把光纤里的光信号转换成电信号给路由器。</li><li>现在一般情况下，家里已经不用集线器和交换机了，<strong>大部分路由器也支持交换机的功能</strong>。所以可以看到，家里的台式机电脑一般就连到一个路由器，再连个光猫就够能快乐上网了。</li></ul><h2 id="HTTP⭐"><a href="#HTTP⭐" class="headerlink" title="HTTP⭐"></a>HTTP⭐</h2><p>HTTP：<strong>超文本传输协议</strong>。</p><p><strong>HTTP是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><p><strong>请求报文包括：</strong></p><ul><li><strong>请求行</strong>：包括<strong>请求方法</strong>、<strong>请求的URL</strong>、<strong>HTTP协议及版本</strong>。</li><li><strong>请求头</strong>：一大堆的键值对。</li><li><strong>空行</strong>指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。</li><li><strong>请求体</strong>：数据部分。</li></ul><p>响应报文包括：</p><ul><li><strong>状态行</strong>：<strong>HTTP协议及版本</strong>、<strong>状态码</strong>及<strong>状态描述</strong>。</li><li><strong>响应头</strong></li><li><strong>空行</strong></li><li><strong>响应体</strong></li></ul><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p><strong>1xx</strong>类状态码属于<strong>提示信息</strong>，是协议处理中的一种<strong>中间状态</strong>，实际用到的比较少。</p><p><strong>2xx</strong>类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li><strong>200 OK</strong> 是最常见的成功状态码，表示一切正常。</li></ul><p><strong>3xx</strong>类状态码表示客户端请求的资源发送了变动，需要客户端用新的URL重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li><p><strong>301 Moved Permanently</strong> 表示<strong>永久重定向</strong>，说明请求的资源已经不存在了，需改用新的URL再次访问。</p></li><li><p><strong>302 Found</strong> 表示<strong>临时重定向</strong>，说明请求的资源还在，但暂时需要用另一个URL来访问。</p><ul><li><strong>301</strong>和<strong>302</strong>都会在响应头里使用字段<strong>Location</strong>，指明后续要跳转的URL，浏览器会自动重定向新的URL。</li></ul></li><li><p><strong>304 Not Modified</strong> 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称<strong>缓存重定向</strong>，用于缓存控制。</p></li></ul><p><strong>4xx</strong>类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是<strong>错误码</strong>的含义。</p><ul><li><strong>400 Bad Request</strong> 表示客户端请求的报文有错误，但只是个笼统的错误</li><li><strong>403 Forbidden</strong> 表示<strong>服务器禁止访问资源</strong>，并不是客户端的请求出错。</li><li><strong>404 Not Found</strong> 表<strong>示请求的资源在服务器上不存在或未找到</strong>，所以无法提供给客户端。</li></ul><p><strong>5xx</strong>类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于<strong>服务器端的错误码</strong>。</p><p>项目静态网页状态码 <code>404 &amp; 405</code></p><p><strong>405 Method Not Allowed</strong>表明服务器禁止了使用当前 HTTP 方法的请求。绝大多数web服务器，都不允许静态文件响应POST请求。原项目使用正向代理发送跨域请求，所以静态网页没有完成代理转发。</p><h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><p><strong>根据场景合理使用各个方法，可以起到优化性能、增加网络安全的效果。</strong></p><h4 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h4><p><code>GET</code>方法的含义是<strong>请求从服务器获取资源</strong>，这个资源可以是静态的文本、页面、图片视频等。</p><p>而<code>POST</code>方法则是相反操作，它向<code>URI</code>指定的资源提交数据，数据就放在报文的<code>body</code>里。</p><h5 id="参数传递方式"><a href="#参数传递方式" class="headerlink" title="参数传递方式"></a>参数传递方式</h5><ul><li>GET 的参数一般是通过 <code>?</code> 跟在 URL 后面的，多个参数通过 <code>&amp;</code> 连接</li><li>POST 的参数一般是包含在 <code>request body</code> 中的</li></ul><h5 id="参数长度限制不同"><a href="#参数长度限制不同" class="headerlink" title="参数长度限制不同"></a>参数长度限制不同</h5><p>GET 和 POST 传递参数的长度不同：</p><ul><li>get传送的数据量较小，不能大于2KB。</li><li>post传送的数据量较大，一般被默认为不受限制。</li></ul><p>在这里我们要明确一点：<strong>HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。</strong></p><p>服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。</p><h5 id="安全和幂等"><a href="#安全和幂等" class="headerlink" title="安全和幂等"></a>安全和幂等</h5><ul><li>在HTTP 协议里，<strong>所谓的「安全」是指请求方法不会「破坏」服务器上的资源</strong>。</li><li><strong>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</strong></li></ul><p>那么很明显<strong>GET方法就是安全且幂等</strong>的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</p><p><strong>POST</strong>因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以不<strong>是幂等</strong>的。</p><h5 id="安全性不同（传输的角度）"><a href="#安全性不同（传输的角度）" class="headerlink" title="安全性不同（传输的角度）"></a>安全性不同（传输的角度）</h5><p>因为参数传递方式的不同，所以 GET 和 POST 的安全性不同：GET 比 POST 更不安全，因为参数直接暴露在URL上，所以 GET 不能用来传递敏感信息。</p><blockquote><p>从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文，要想安全传输，就只有加密，也就是 HTTPS。</p></blockquote><h5 id="缓存机制不同"><a href="#缓存机制不同" class="headerlink" title="缓存机制不同"></a>缓存机制不同</h5><p>这个需要从以下几点来说明：</p><ul><li>GET 请求会<strong>被浏览器主动cache</strong>，而 POST 不会，除非手动设置。</li><li>GET 请求参数<strong>会被完整保留在浏览器历史记录里</strong>，而 POST 中的参数不会被保留。</li><li>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。</li><li>GET 在<strong>浏览器回退时是无害的</strong>，而 POST 会再次提交请求。</li></ul><h5 id="时间消耗不同"><a href="#时间消耗不同" class="headerlink" title="时间消耗不同"></a>时间消耗不同</h5><p>GET 和 POST 请求时间的不同主要是因为：</p><ul><li>GET 产生<strong>一个</strong> TCP 数据包；</li><li>POST 产生<strong>两个</strong> TCP 数据包。</li></ul><p>对于 GET 方式的请求，浏览器会把 <strong>header 和 data</strong> 一并发送出去，服务器响应 200（返回数据）；而对于 POST，浏览器先发送 <strong>header</strong>，服务器响应 <strong>100 continue</strong>，浏览器再发送 <strong>data</strong>，服务器响应 200 ok（返回数据）。</p><p>在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将不传回资源的本文部分，只返回<strong>头部消息</strong>。</p><p>HEAD 方法的使用场景</p><ul><li>在不获取资源的情况下，了解资源的一些信息，比如资源类型；</li><li>通过查看响应中的状态码，可以确定资源是否存在；</li><li>通过查看首部，测试资源是否被修改。</li></ul><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>PUT 方法用于将数据发送到服务器来创建/更新资源。</p><p>PUT 与 POST 方法的区别在于，<strong>PUT 方法是幂等的</strong>：<strong>调用一次与连续调用多次是等价的（即没有副作用）</strong>。</p><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>DELETE 方法就是请求服务器删除指定 URL 所对应的资源。</p><h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><blockquote><p>浏览器缓存(Brower Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力。</p><p>http缓存机制主要在<strong>http响应头</strong>中设定，响应头中相关字段为<code>Expires</code>、<code>Cache-Control</code>、<code>Last-Modified</code>、<code>Etag</code>。</p></blockquote><h4 id="基本流程（强缓存、协商缓存）"><a href="#基本流程（强缓存、协商缓存）" class="headerlink" title="基本流程（强缓存、协商缓存）"></a>基本流程（强缓存、协商缓存）</h4><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/qZJSgJ"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/20/qZJSgJ.png" alt="qZJSgJ.png"></a></p><p>在第一次请求时，没有缓存，直接向服务器发送请求，服务器会将页面<strong>最后修改时间</strong>通过<code>Last-Modified</code>标识由服务器发送给客户端，客户端记录修改时间；服务器还会生成一个<code>Etag</code>，并发送给客户端。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/qZJpv9"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/20/qZJpv9.png" alt="qZJpv9.png"></a></p><p>第二次浏览器请求某一资源时：</p><ul><li>强缓存 <code>Cache-Control</code>（max-age,优先级高）、<code>Expires</code>(GMT）=&gt; 判断<strong>是否过期</strong></li></ul><p>​ <strong>没过期则直接从缓存中获取资源信息</strong>，<strong>不会与服务器进行通信</strong>。</p><ul><li><p>协商缓存 <strong>由服务器来确定缓存资源是否可用</strong></p><ul><li><p>客户端：<code>If-None-Match</code>头将先前服务器端发送过来的<code>Etag</code>发送给服务器；</p><p>服务会对比这个客户端发过来的<code>Etag</code>是否与服务器的相同。</p><ul><li>若<strong>相同</strong>，返回状态<code>304</code>，客户端<strong>继续使用本地缓存</strong>。</li><li>若<strong>不相同</strong>，返回状态为<code>200</code>，客户端重新解析服务器端返回的数据。</li></ul></li></ul><ul><li>如果没有<code>Etag</code>，客户端还会通过<code>If-Modified-Since</code>头将先前服务器端发过来的<strong>最后修改时间戳</strong>发送给服务器<ul><li>如果不是最新的，则返回最新的内容，<code>200</code>。</li><li>如果是最新的，则返回<code>304</code>，客户端继续使用本地缓存。</li></ul></li></ul></li></ul><h4 id="缓存发展历程"><a href="#缓存发展历程" class="headerlink" title="缓存发展历程"></a>缓存发展历程</h4><p>强缓存有缺点，比如说，设置了<code>expires</code>，<code>GMT</code>格式，但是浏览器的时间可以改变，因此就通过<code>cache-control</code>返回一个<strong>相对时间</strong>来。但是假如说<strong>资源并没有更新</strong>，但是强缓存时间过期了，那就需要重新拉去资源，因此就有了<code>Last-Modify</code>，但是last-modified的时间单位是<code>s</code>，当1s内有资源修改，那浏览器返回的最后修改时间和上次的修改时间相同，那就不会重新拉取资源，因此推出了<code>Etag</code>，通过比对资源内容来判断是否修改。</p><h4 id="为什么要有Etag"><a href="#为什么要有Etag" class="headerlink" title="为什么要有Etag"></a>为什么要有Etag</h4><p>HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p><ul><li>一些文件也许会周期性的更改，但是他的**内容并不改变(仅仅改变的修改时间)**，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</li><li>某些文件<strong>修改非常频繁</strong>，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是<code>s</code>级的；</li><li>某些服务器<strong>不能精确的得到文件的最后修改时间</strong>。</li></ul><p>Last-Modified与ETag是可以一起使用的，<strong>服务器会优先验证ETag</strong>。</p><h4 id="不同刷新的请求执行过程"><a href="#不同刷新的请求执行过程" class="headerlink" title="不同刷新的请求执行过程"></a>不同刷新的请求执行过程</h4><ul><li><p><strong>浏览器地址栏中写入URL，回车 / 普通刷新F5</strong></p><p>不同浏览器和不同类型资源缓存方式不同，个人理解：</p><ul><li>返回200，并显示从缓存中获取，则为强缓存（虽然没有发出真实的 http 请求）。</li><li>返回304，说明是协商缓存命中走<strong>缓存</strong>。</li></ul></li><li><p><strong>强制刷新Ctrl+F5</strong> 删除缓存，重新请求。</p></li></ul><h3 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p><strong>简单<code>header（key-value） + body</code>、灵活和易于扩展（应用层(OSI第七层)，下层可随意变化）、应用广泛和跨平台</strong>。</p><h4 id="双刃剑"><a href="#双刃剑" class="headerlink" title="双刃剑"></a>双刃剑</h4><p>无状态</p><ul><li>不需要额外的资源来记录状态信息</li><li>完成有关联性的操作时会非常麻烦</li></ul><p>明文传输</p><ul><li>调试工作带了极大的便利性</li><li>毫无隐私可言，很容易就能被窃取</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>HTTP比较严重的缺点就是不安全:</p><ul><li>**通信使用明文（不加密)**，内容可能会被窃听。</li><li><strong>不验证通信方的身份</strong>，因此有可能遭遇伪装。</li><li><strong>无法证明报文的完整性</strong>，所以有可能已遭篡改。</li></ul><p>HTTP的安全问题，可以用<strong>HTTPS</strong>的方式解决，也就是通过引入<strong>SSL/TLS</strong>层，使得在安全上达到了极致。</p><h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>HTTP是<strong>超文本传输协议</strong>，信息是<strong>明文传输</strong>，存在安全风险的问题。HTTPS则解决HTTP不安全的缺陷，<strong>在TCP和HTTP之间加入了SSL/TLS安全协议</strong>，使得报文能够<strong>加密</strong>传输。</li><li>HTTP 连接建立相对简单，<strong>TCP三次握手</strong>之后便可进行HTTP的报文传输。而 HTTPS在<strong>TCP三次握手</strong>之后，还需进行<strong>SSL/TLS的握手</strong>过程，才可进入加密报文传输。</li><li>HTTP的端口号是<strong>80</strong>，HTTPS的端口号是<strong>443</strong>。</li><li>HTTPS 协议需要<strong>向CA(证书权威机构）申请数字证书</strong>，来保证服务器的身份是可信的。</li></ul><blockquote><p>SSL和TLS？</p></blockquote><p>这两实际上是一个东西。很多相关的文章都把这两者并列称呼(SSL/TLS)，因为这两者可以视作<strong>同一个东西的不同阶段</strong>。</p><h4 id="HTTPS优点"><a href="#HTTPS优点" class="headerlink" title="HTTPS优点"></a>HTTPS优点</h4><h5 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h5><p>通过<strong>混合加密</strong>的方式可以保证信息的<strong>机密性</strong>，解决了窃听的风险。</p><p>HTTPS采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的<strong>混合加密</strong>方式:</p><ul><li>在<strong>通信建立前</strong>采用<strong>非对称加密</strong>的方式<strong>交换</strong>「会话秘钥」，后续就不再使用非对称加密。</li><li>在<strong>通信过程中</strong>全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul><p>采用「混合加密」的方式的原因:</p><blockquote><p>对称加密：加密和解密使用的是同一个密钥。</p><p>RSA（非对称加密算法）：双方必须协商一对密钥，一个私钥一个公钥。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。</p></blockquote><p>对称加密运算速度快，但最开始仍可能被拦截，发送信息依然不安全，非对称加密足够安全，但运算速度慢。</p><p><strong>使用非对称加密的方法将加密算法的对称密钥发送过去</strong>，之后就可以使用使用这个密钥，利用<strong>对称密钥</strong>来通信了。</p><h5 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h5><p><strong>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</strong></p><p>这就存在些问题，<strong>如何保证公钥不被篡改和信任度?</strong></p><p>所以这里就需要借助第三方权威机构<code>CA</code>(数字证书认证机构)﹐将<strong>服务器公钥放在数字证书</strong>（由数字证书认证机构颁发)中，只要证书是可信的，公钥就是可信的。</p><p>通过数字证书的方式保证服务器公钥的身份，解决<strong>冒充</strong>的风险。</p><h5 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h5><p><strong>摘要算法</strong>用来实现<strong>完整性</strong>，能够为数据生成独一无二的<strong>指纹</strong>﹐用于校验数据的完整性，解决了<strong>篡改</strong>的风险。</p><p>客户端在发送明文之前会通过<strong>摘要算法</strong>算出明文的<strong>指纹</strong>，发送的时候把<strong>指纹＋明文</strong>一同加密成密文后，发送给服务器，服务器解密后，用<strong>相同的摘要算法</strong>算出发送过来的明文，通过比较客户端携带的<strong>指纹</strong>和当前算出的<strong>指纹</strong>做比较，若<strong>指纹</strong>相同，说明数据是完整的。</p><h4 id="HTTPS连接"><a href="#HTTPS连接" class="headerlink" title="HTTPS连接"></a>HTTPS连接</h4><p>SSL/TLS协议基本流程∶</p><ul><li><strong>客户端向服务器索要并验证服务器的公钥</strong>。</li><li>双方协商生产<strong>会话秘钥</strong>。</li><li>双方采用<strong>会话秘钥</strong>进行加密通信。</li></ul><p>前两步也就是SSL/TLS的建立过程，也就是握手阶段。</p><p>整个SSL/TLS的握手阶段全部结束后，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用<strong>会话秘钥加密内容。</strong></p><p>SSL/TLS 1.2需要4次握手，SSL/TLS 1.3优化了过程，<strong>只需要3次握手</strong>。</p><h3 id="HTTP-1-1、HTTP-2、HTTP-3演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3演变" class="headerlink" title="HTTP/1.1、HTTP/2、HTTP/3演变"></a>HTTP/1.1、HTTP/2、HTTP/3演变</h3><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><p>HTTP/1.1相比HTTP/1.0性能上的改进︰</p><ul><li>使用TCP<strong>长连接</strong>的方式改善了<strong>HTTP/1.0短连接</strong>造成的性能开销。<ul><li><strong>减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载</strong>。</li><li><strong>只要任意一端没有明确提出断开连接，则保持TCP连接状态。</strong></li></ul></li><li>支持<strong>管道（pipeline)网络传输</strong>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li><li>缓存Etag</li></ul><p>但HTTP/1.1还是有性能瓶颈︰</p><ul><li><strong>请求/响应头部(Header)未经压缩就发送</strong>，首部信息越多延迟越大。只能压缩<code>Body</code>的部分;</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>;</li><li><strong>没有请求优先级控制</strong>;</li><li>请求只能从客户端开始，<strong>服务器只能被动响应</strong>。</li></ul><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p><strong>HTTP/2协议是大多基于HTTPS的，所以HTTP/2的安全性也是有保障的。</strong></p><p>那HTTP/2相比HTTP/1.1 性能上的改进︰</p><ul><li><p><strong>头部压缩</strong>（HPACK算法）</p><ul><li>HTTP/2会<strong>压缩头</strong>(Header)。</li><li>如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</li></ul></li><li><p><strong>二进制格式</strong></p><ul><li>不再是纯文本形式的报文，而是全面采用了<strong>二进制格式</strong></li><li>直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</li></ul></li><li><p><strong>数据流</strong></p><ul><li>HTTP/2的数据包<strong>不是按顺序发送的</strong>，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</li><li>每个请求或回应的所有数据包，称为一个数据流（<strong>Stream</strong> )。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。</li><li>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</li></ul></li><li><p><strong>多路复用</strong></p><ul><li>HTTP/2是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。</li><li>移除了HTTP/1.1中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。</li></ul></li><li><p><strong>服务器推送</strong></p><ul><li>HTTP/2还在一定程度上改善了传统的「请求-应答」工作模式，服务不再是被动地响应，<strong>也可以主动向客户端发送消息</strong>。</li><li>举例来说，在浏览器刚请求HTML的时候，就提前把可能会用到的JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送(<strong>Server Push</strong>，也叫<strong>Cache Push</strong>)。</li></ul></li></ul><h4 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h4><p>HTTP/2主要的问题在于，<strong>多个HTTP请求在复用一个TCP连接</strong>，下层的TCP协议是不知道有多少个HTTP请求的。</p><p>所以<strong>一旦发生了丢包现象，就会触发TCP的重传机制</strong>，这样在一个TCP连接中的<strong>所有的HTTP请求都必须等待这个丢了的包被重传回来</strong>。</p><ul><li>HTTP/1.1中的管道（pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了。</li><li>HTTP/2多个请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的HTTP请求。</li></ul><p>这都是<strong>基于TCP传输层</strong>的问题，所以<strong>HTTP/3把HTTP下层的TCP协议改成了UDP</strong>!</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/btsh6J"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btsh6J.png" alt="btsh6J.png"></a></p><p>UDP是<strong>不管顺序，也不管丢包的</strong>，所以<strong>不会出现HTTP/1.1的队头阻塞和HTTP/2的一个丢包全部重传问题</strong>。</p><p>大家都知道UDP是不可靠传输的，但<strong>基于UDP的QUIC协议可以实现类似TCP的可靠性传输</strong>。</p><ul><li>QUIC有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，<strong>其他流不会受到影响</strong>。</li><li>TLS3升级成了最新的<strong>1.3</strong>版本，头部压缩算法也升级成了<strong>QPack</strong> 。</li><li>HTTPS要建立一个连接，要花费6次交互，先是建立三次握手，然后是TLS/1.3的三次握手。QUIC直接把以往的TCP和 TLS/1.3的6次交互<strong>合并成了3次，减少了交互次数</strong>。</li></ul><p>所以，QUIC是一个在UDP之上的<strong>伪</strong>TCP+ TLS+ HTTP/2的多路复用的协议。</p><p>QUIC是新协议，对于很多网络设备，根本不知道什么是QUIC，只会当做UDP，这样会出现新的问题。所以HTTP/3现在普及的进度非常的缓慢，不知道未来UDP是否能够逆袭TCP。</p><h2 id="跨域通信⭐"><a href="#跨域通信⭐" class="headerlink" title="跨域通信⭐"></a>跨域通信⭐</h2><p><strong>同源策略</strong>：用于隔离潜在恶意文件的安全机制。</p><p>同源是指”<strong>协议</strong>+<strong>域名</strong>+<strong>端口</strong>“三者相同，<strong>即便两个不同的域名指向同一个ip地址，也非同源</strong>。</p><p><strong>同源策略限制内容有：</strong></p><ul><li><code>Cookie</code>、<code>LocalStorage</code>、<code>IndexedDB</code> 等存储性内容</li><li><code>DOM</code> 节点</li><li><code>AJAX</code> 请求</li></ul><p>但是有的标签是允许跨域加载资源：</p><ul><li><code>&lt;img src=XXX&gt;</code></li><li><code>&lt;link href=XXX&gt;</code></li><li><code>&lt;script src=XXX&gt;</code></li></ul><p><strong>当协议、域名、端口号中任意一个不相同时，都算作不同域</strong>。不同域之间相互请求资源，就算作“跨域”。</p><p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong>。</p><h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h3><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p><code>JSON with Padding</code> JS函数包裹JSON数据。</p><p><strong>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</strong></p><p><code>&lt;script&gt;</code> 标签中type的默认属性是<code>text/javascript</code>,<strong>会把收到的文本内容当成JS代码进行执行</strong>。</p><p>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。</p><p><strong>缺点是仅支持get方法，具有局限性；不安全，可能会遭受XSS攻击。</strong></p><p><strong>JSONP的实现流程</strong></p><ul><li>声明一个回调函数，其函数名(如<code>jsonpCallback</code>)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</li><li>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给<code>&lt;script&gt;</code>的<code>src</code>，还要在这个地址中向服务器传递该函数名（可以通过问号传参:<code>?callback=jsonpCallback</code>）。</li><li>服务器接收到请求后，需要进行特殊的处理：把<strong>传递进来的函数名</strong>和它需要给你的<strong>数据</strong>拼接成一个<strong>字符串</strong>。</li><li>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（<code>jsonpCallback</code>），对返回的数据进行操作。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去创建一个script标签</span></span><br><span class="line"><span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">//script的src属性设置接口地址 并带一个callback回调函数名称</span></span><br><span class="line">script.src = <span class="string">&quot;http://127.0.0.1:8888/index.php?callback=jsonpCallback&quot;</span>;</span><br><span class="line"><span class="comment">//插入到页面</span></span><br><span class="line"><span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"><span class="comment">//通过定义函数名去接收后台返回数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonpCallback</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//注意  jsonp返回的数据是json对象可以直接使用</span></span><br><span class="line">    <span class="comment">// 例如服务器的json字符串为 &#x27;&#123;&quot;msg&quot;:&quot;用户名设置成功&quot;&#125;&#x27;</span></span><br><span class="line">    <span class="comment">// 实际返回的字符串 &#x27;callback(&#123;&quot;msg&quot;:&quot;用户名设置成功&quot;&#125;)&#x27;</span></span><br><span class="line">    <span class="comment">// 浏览器接收后，执行callback(&#123;&quot;msg&quot;:&quot;用户名设置成功&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 此时的参数就是一个json对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS（Cross-Origin Resource Sharing），跨域资源共享。</p><p>CORS是官方的跨域解决方案，需要浏览器和后端同时支持。</p><p>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 CORS。 <strong>该属性表示哪些域名可以访问资源，如果设置通配符<code>*</code>则表示所有网站都可以访问资源。</strong></p><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><p><strong>简单请求</strong></p><ul><li>请求方法是 <code>HEAD</code>、<code>GET</code>、<code>POST</code> 三种之一；</li><li>HTTP 头信息不超过右边着几个字段：<ul><li><code>Accept</code>、</li><li><code>Accept-Language</code>、</li><li><code>Content-Language</code>、</li><li><code>Last-Event-ID</code></li><li><code>Content-Type</code> 只限于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>；</li></ul></li></ul><p>需要这些条件是为了兼容表单，因为历史上表单一直可以跨域。</p><p>浏览器直接发出<strong>CORS请求</strong>，具体来说就是在头信息中增加<code>Origin</code>字段，表示请求来源来自哪个域(协议+域名+端口)，服务器根据这个值决定是否同意请求。如果同意，返回的响应会多出以下响应头信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//juejin.com // 和 Orign 一致  这个字段是必须的</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span> <span class="comment">// 表示是否允许发送 Cookie  这个字段是可选的</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar <span class="comment">// 指定返回其他字段的值   这个字段是可选的</span></span><br></pre></td></tr></table></figure><p>在简单请求中服务器至少需要设置：<code>Access-Control-Allow-Origin</code> 字段。</p><p><strong>复杂请求</strong></p><ul><li><p>不符合以上条件的请求，比如请求方法是 <code>PUT</code> 或 <code>DELETE</code>，或 <code>Content-Type</code> 值为 <code>application/json</code>。</p></li><li><p>浏览器会在正式通信之前，发送一次 <strong>HTTP 预检</strong> <code>OPTIONS</code> 请求，先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 请求方法和头信息字段（服务器返回的响应头会包含允许的域名、方法等）。只有得到肯定答复，浏览器才会发出正式的 <code>XHR</code> 请求，否则报错。</p></li><li><p>预检请求的方法是<code>OPTIONS</code>，它的头信息中有几个字段</p><ul><li><code>Origin</code>: 表示请求来自哪个域，这个字段是必须的</li><li><code>Access-Control-Request-Method</code>：列出CORS请求会用到哪些HTTP方法，这个字段是必须的</li><li><code>Access-Control-Request-Headers</code>： 指定CORS请求会额外发送的头信息字段，用逗号隔开</li></ul></li><li><p>OPTIONS请求次数过多也会损耗性能，所以要尽量减少OPTIONS请求，可以让服务器在请求返回头部添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Max-Age: <span class="built_in">Number</span> <span class="comment">// 数字 单位是秒</span></span><br></pre></td></tr></table></figure><p>表示预检请求的返回结果可以被缓存多久，在这个时间范围内再请求就不需要预检了。不过这个缓存只对完全一样的URL才会生效。</p></li></ul><h5 id="关于CORS的-cookie-问题"><a href="#关于CORS的-cookie-问题" class="headerlink" title="关于CORS的 cookie 问题"></a>关于CORS的 cookie 问题</h5><p>想要传递 <code>cookie</code> 需要满足 3 个条件</p><ul><li>web 请求设置<code>withCredentials</code></li></ul><p>这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 <code>withCredentials</code> 来进行传递 <code>cookie</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 xml 的设置方式</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// axios 设置方式</span></span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>2.<code>Access-Control-Allow-Credentials</code> 为 <code>true</code></p><p>3.<code>Access-Control-Allow-Origin</code>为<strong>非</strong> <code>*</code></p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>简单的说，一般给客户端做代理的都是正向代理，给服务器做代理的就是反向代理。</p><h5 id="Node中间件代理"><a href="#Node中间件代理" class="headerlink" title="Node中间件代理"></a>Node中间件代理</h5><p><strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong></p><p>代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点同域。</p><h5 id="React中配置代理"><a href="#React中配置代理" class="headerlink" title="React中配置代理"></a>React中配置代理</h5><p>在<code>package.json</code>中追加如下配置 :<code>&quot;proxy&quot;:http://localhost:5000</code></p><h5 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h5><p>配置一个代理服务器向服务器请求，再将数据返回给客户端，实质和CORS跨域原理一样，也需要配置请求响应头Access-Control-Allow-Origin等字段，只不过是在代理服务器配置。</p><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p><code>WebSocket</code>是<code>HTML5</code>的一个持久化的协议，它实现了<strong>浏览器与服务器的全双工通信</strong>，同时也是跨域的一种解决方案。</p><p><code>WebSocket</code>和<code>HTTP</code>都是<strong>应用层协议</strong>，都基于 <code>TCP</code> 协议。</p><p>但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。</p><p>同时，<code>WebSocket</code> 在建立连接时需要借助 <code>HTTP</code> 协议，连接建立好了之后 <code>client</code> 与 <code>server</code> 之间的双向通信就与 <code>HTTP</code> 无关了。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>postMessage（H5支持跨域的window属性）、location.hash + iframe</p><h2 id="XSS和CSRF"><a href="#XSS和CSRF" class="headerlink" title="XSS和CSRF"></a>XSS和CSRF</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p><code>Cross-Site Scripting</code>（跨站脚本攻击）简称 XSS，是一种<strong>代码注入攻击</strong>。</p><p>攻击者通过在<strong>目标网站</strong>上注入<strong>恶意脚本</strong>，使之在用户的<strong>浏览器</strong>上运行。</p><p>利用这些恶意脚本，攻击者可获取用户的敏感信息如<code>Cookie</code>、<code>SessionID</code> 等，进而危害数据安全。</p><p>简单来说,任何可以输入的地方都有可能引起,包括<strong>URL</strong>!</p><p>根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。</p><p><strong>存储型 XSS</strong>(又被称为持久性XSS)攻击</p><ul><li>常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</li><li>它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，</li><li><strong>它不需要用户手动触发</strong>。<strong>任何允许用户存储数据的web程序都可能存在存储型XSS漏洞</strong>，当攻击者提交一段XSS代码后，被服务器端接收并存储，当<strong>所有浏览者访问某个页面时都会被XSS</strong>。</li></ul><p>反射型 XSS (也被称为非持久性XSS)</p><ul><li>存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</li><li>常见于通过 URL 传递参数的功能，如网站搜索、跳转等。</li><li>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</li></ul><p>DOM 型 XSS</p><ul><li>取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</li></ul><h3 id="常用防范方法"><a href="#常用防范方法" class="headerlink" title="常用防范方法"></a>常用防范方法</h3><ul><li><strong>httpOnly:</strong> 在 <code>cookie</code> 中设置 <code>HttpOnly</code> 属性后，js脚本将无法读取到 cookie 信息。</li><li><strong>输入过滤:</strong> 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。不仅仅是<strong>前端</strong>负责，<strong>后端</strong>也要做相同的过滤检查。因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。</li><li><strong>转义 HTML:</strong> 如果拼接 HTML 是必要的，就需要对于<strong>引号</strong>，<strong>尖括号</strong>，斜杠进行转义,但这还不是很完善。</li><li><strong>白名单:</strong> 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</li></ul><ul><li><strong>纯前端渲染</strong><ul><li>浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。</li><li>然后浏览器执行 HTML 中的 JavaScript。</li><li>JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。</li></ul></li></ul><p>在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（<code>.innerText</code>），还是属性（<code>.setAttribute</code>），还是样式（<code>.style</code>）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。</p><p>但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 <code>onload</code> 事件和 <code>href</code> 中的 <code>javascript:xxx</code> 等）。</p><p>在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题,这时就需要对HTML进行充分的转义。</p><ul><li><strong>预防 DOM 型 XSS 攻击</strong></li></ul><p>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript代码本身不够严谨，把不可信的数据当作代码执行了。</p><p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等。</p><p>如果用 Vue/React 技术栈，并且不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患。</p><p>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>跨站请求伪造（Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种<strong>挟制用户在当前已登录的 Web 应用程序上执行非本意的操作</strong>的攻击方法。</p><h4 id="CSRF与-XSS-区别"><a href="#CSRF与-XSS-区别" class="headerlink" title="CSRF与 XSS 区别"></a>CSRF与 XSS 区别</h4><ul><li><strong>通常来说 CSRF 是由 XSS 实现的，CSRF 时常也被称为 XSRF（CSRF 实现的方式还可以是直接通过命令行发起请求等）。</strong></li><li>本质上讲，XSS 是代码注入问题，<strong>CSRF 是 HTTP 问题。</strong> XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。<strong>CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(Token验证可以避免)。</strong></li></ul><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><ul><li>验证码；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 CSRF，但是用户体验比较差。</li><li>Referer check；请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。</li><li>token；<strong>token 验证的 CSRF 防御机制是公认最合适的方案。</strong>若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。</li></ul><h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP UDP"></a>TCP UDP</h2><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li>在传送数据之前<strong>不需要先建立连接</strong>，远地主机在收到 UDP 报文后，<strong>不需要给出任何确认</strong>。</li><li>一般用于<strong>即时通信</strong>，比如： QQ 语音、 QQ 视频 、直播等等</li><li>基于<strong>UDP的QUIC</strong>协议可以实现类似TCP的可靠性传输</li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul><li>提供<strong>面向连接</strong>的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li>TCP 在传递数据之前，会有<strong>三次握手</strong>来建立连接，而且在数据传递时，有<strong>确认</strong>、<strong>窗口</strong>、<strong>重传</strong>、<strong>拥塞控制</strong>机制，在数据传完后，还会<strong>断开连接</strong>用来节约系统资源</li><li>由于 TCP 要提供可靠的，面向连接的传输服务，这难以避免增加了许多开销。</li><li>TCP 一般用于<strong>文件传输、发送和接收邮件、远程登录</strong>等场景。</li></ul><h3 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h3><ul><li>应用数据被分割成 TCP 认为<strong>最适合发送的数据块</strong>。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行<strong>排序</strong>，把有序数据传送给应用层。</li><li>TCP 将保持它首部和数据的<strong>检验和</strong>。这是一个端到端的检验和，目的是<strong>检测数据在传输过程中的任何变化</strong>。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端<strong>会丢弃重复的数据</strong>。</li><li><strong>流量控制：</strong>TCP 连接的每一方都有固定大小的缓冲空间，TCP 的<strong>接收端只允许发送端发送接收端缓冲区能接纳的数据</strong>。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是<strong>可变大小的滑动窗口协议</strong>。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。<ul><li>第一个响应包是<strong>14kb</strong>大小。这是<strong>慢开始</strong>的一部分，慢开始是一种均衡网络连接速度的算法。慢开始逐渐增加发送数据的数量直到达到网络的最大带宽。</li><li>拥塞控制算法使用这个<strong>发送包</strong>和<strong>确认帧流</strong>（客户端返回）来确定发送速率。</li></ul></li><li><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是<strong>每发完一个分组就停止发送，等待对方确认</strong>。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ul><h2 id="从URL输入到页面展现到底发生什么？⭐"><a href="#从URL输入到页面展现到底发生什么？⭐" class="headerlink" title="从URL输入到页面展现到底发生什么？⭐"></a>从URL输入到页面展现到底发生什么？⭐</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/btVsO0"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btVsO0.png" alt="btVsO0.png"></a></p><p>总体来说分为以下几个过程:</p><ul><li>解析URL并生成HTTP请求报文</li><li>DNS 解析：将域名解析成IP地址</li><li>TCP 三次握手建立连接、TLS三次握手 =》在HTTPS上建立安全连接</li><li>将HTTP报文添加TCP头部（源、目标端口、序号、窗口大小和状态位）生成TCP报文</li><li>添加IP包头（源、目标IP）和MAC包头（收发MAC地址）将数据封装成网络包</li><li>网卡驱动从IP模块获取到包之后，再次封装。</li><li>网卡会将包转为电信号，通过网线发送出去。</li><li>网络包经过交换机和路由器转发到达服务器</li><li>服务器将MAC、IP、TCP、HTTP头部一层层解析处理，将网页放入HTTP响应报文中，穿上TCP、IP、MAC头部返回</li><li>浏览器拿到HTTP响应报文后，将HTML和CSS解析出DOM 树和 CSS 规则树（<strong>CSSOM</strong>），两者生成渲染树进行页面绘制</li><li>断开TCP连接 ：TCP四次挥手</li></ul><h3 id="URL是什么？"><a href="#URL是什么？" class="headerlink" title="URL是什么？"></a>URL是什么？</h3><p>统一资源定位符，URI是统一资源标志符</p><p><strong>URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</strong></p><p>URL遵守以下的语法规则：<code>scheme://host.domain:port/path/filename</code></p><ul><li><strong>scheme</strong> - 定义因特网服务的类型。常见的协议有 <strong>http、https、ftp、file</strong>，其中最常见的类型是 http，而 <strong>https 则是进行加密的网络传输</strong>。</li><li><strong>host</strong> - 定义域主机（http 的默认主机是 <strong>www</strong>）</li><li><strong>domain</strong> - 定义因特网<strong>域名</strong>，比如 <code>w3school.com.cn</code></li><li><strong>port</strong> - 定义主机上的<strong>端口号</strong>（http 的默认端口号是 80）</li><li><strong>path</strong> - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</li><li><strong>filename</strong> - 定义文档/资源的名称</li></ul><p>当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是<code>/index.html</code>或者<code>/default.html</code>这些文件，这样就不会发生混乱了。</p><h3 id="域名解析（DNS）"><a href="#域名解析（DNS）" class="headerlink" title="域名解析（DNS）"></a>域名解析（DNS）</h3><p>委托操作系统将消息发送给Web服务器，<strong>需要查询服务器域名对应的IP地址。</strong></p><p>DNS服务器就<strong>专门保存了Web服务器域名与IP的对应关系</strong>。</p><p><strong>查询过程</strong></p><ul><li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li><li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器<strong>缓存</strong>中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li><li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li><li>本地DNS服务器向<strong>顶级域名服务器（.com）</strong>发送请求，返回相关的下一级的权威域名服务器的地址</li><li>本地DNS服务器向**权威域名服务器(.baidu.com)**发送请求，域名服务器返回对应的结果(<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>)</li><li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li><li>本地DNS服务器将返回结果返回给浏览器</li></ul><p>DNS解析是一个包含迭代查询和递归查询的过程。</p><p>一般<strong>我们向本地 DNS 服务器</strong>发送请求的方式就是<strong>递归查询</strong>，因为我们只需要发出<strong>一次请求</strong>，然后<strong>本地 DNS 服务器返回给我们最终的请求结果</strong>。而<strong>本地 DNS 服务器向其他域名服务器</strong>请求的过程是<strong>迭代查询</strong>的过程，因为<strong>每一次域名服务器只返回单次查询的结果，下一级的查询由本地 DNS 服务器自己进行</strong>。</p><p><strong>DNS负载均衡</strong></p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>TCP连接的建立，通常称为三次握手。</p><p>这个所谓的「连接」，只是双方计算机里<strong>维护一个状态机</strong>。</p><p><strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</strong></p><ul><li><strong>Socket</strong>:由<strong>IP地址</strong>和<strong>端口号</strong>组成</li><li><strong>序列号</strong>:用来解决乱序问题等</li><li><strong>窗口大小</strong>:用来做流量控制</li></ul><p><strong>三次握手</strong></p><ul><li>一开始，客户端和服务端都处于<code>CLOSED</code>状态。先是服务端<strong>主动监听某个端口</strong>，处于<code>LISTEN</code>状态。</li><li>客户端把第一个SYN 报文（包含序列号（client_isn ），<code>SYN</code> 标志位置为<code>1</code>）发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于<code>SYN-SENT</code>状态。</li><li>服务端收到客户端的<code>SYN</code>报文后，发送应答报文（包含自己序列号（server_isn）、确认序列（client_isn +1）、SYN和ACK置1）给客户端，该报文也不包含应用层数据，之后服务端处于<code>SYN-RCVD</code>状态。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文（确认序列（server_isn +1），ACK置1），这次报文<strong>可以携带客户到服务器的数据</strong>，之后客户端处于<code>ESTABLISHED</code> 状态。</li><li>服务器收到客户端的应答报文后，也进入<code>ESTABLISHED</code>状态。</li></ul><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/btndH0"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btndH0.png" alt="btndH0.png"></a></p><p><strong>为什么三次？</strong></p><p><strong>因为三次握手才能保证双方具有接收和发送的能力</strong>。</p><p><strong>通过三次握手能防止历史连接的建立（序列号），能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。</strong></p><p>不使用<strong>两次握手</strong>和<strong>四次握手</strong>的原因:</p><ul><li>两次握手︰无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号;</li><li>四次握手︰三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><h3 id="断开TCP连接-四次挥手"><a href="#断开TCP连接-四次挥手" class="headerlink" title="断开TCP连接 四次挥手"></a>断开TCP连接 四次挥手</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/btNzm8"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btNzm8.png" alt="btNzm8.png"></a></p><p><strong>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</strong></p><ul><li>客户端打算关闭连接，此时会发送<code>FIN</code> 报文（FIN置1），之后客户端进入<code>FIN_WAIT_1</code>状态。</li><li>服务端收到该报文后，就向客户端发送<code>ACK</code>应答报文，接着服务端进入<code>CLOSED_WAIT</code>状态；客户端收到服务端的<code>ACK</code>应答报文后，之后进入<code>FIN_WAIT_2</code>状态。</li><li>等待<strong>服务端处理完数据后</strong>，也向客户端发送<code>FIN</code> 报文，之后服务端进入<code>LAST_ACK</code>状态。</li><li>客户端收到服务端的<code>FIN</code> 报文后，回一个<code>ACK</code>应答报文，之后进入<code>TIME_WAIT</code>状态。</li><li>服务器收到了<code>ACK</code>应答报文后，就进入了<code>CLOSED</code>状态，至此<strong>服务端已经完成连接的关闭</strong>。</li><li>客户端在经过<code>2MSL</code>一段时间后，自动进入<code>CLOSED</code>状态，至此<strong>客户端也完成连接的关闭</strong>。</li></ul><p>你可以看到，每个方向都需要一个<code>FIN</code>和一个<code>ACK</code>，因此通常被称为<strong>四次挥手</strong>。</p><p><strong>主动关闭连接的，才有TIME_WAIT状态</strong>。</p><p><strong>为什么挥手需要四次</strong>?</p><p>再来回顾下四次挥手双方发FIN 包的过程，就能理解为什么需要四次了。</p><ul><li>关闭连接时，客户端向服务端发送<code>FIN</code> 时，仅仅表示<strong>客户端不再发送数据了但是还能接收数据</strong>。</li><li>服务器收到客户端的<code>FIN</code>报文时，先回一个<code>ACK</code>应答报文，而服务端可能还有数据需要处理和发送，等<br>服务端不再发送数据时，才发送<code>FIN</code>报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，<strong>服务端通常需要等待完成数据的发送和处理</strong>，所以服务端的<code>ACK</code>和 <code>FIN</code>一般都会分开发送，从而比三次握手导致多了一次。</p><p><code>MSL</code>是<code>Maximum Segment Lifetime</code>，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><p>经过<code>2MSL</code>这个时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><p><code>TIME-WAIT</code>更重要的作用是<strong>等待足够的时间以确保最后的ACK能让被动关闭方接收，从而帮助其正常关闭</strong>。</p><h2 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h2><p>浏览器解析渲染页面分为一下五个步骤：</p><ul><li><p>根据 HTML 解析出 DOM 树</p><ul><li>图片/CSS不会影响解析</li><li><code>&lt;script&gt;</code>阻塞渲染并停止HTML的解析</li><li>预加载在后台检索资源，减少了阻塞</li></ul></li><li><p>根据 CSS 解析生成 CSS 规则树（<strong>CSSOM</strong>）</p></li><li><p>结合 DOM 树和 CSS 规则树，生成渲染树</p><ul><li><code>&lt;head&gt;</code>和它的<strong>子节点</strong>以及任何具有<code>display: none</code>样式的结点，不会出现在Render树上</li><li><code>visibility: hidden</code>的节点会出现在Render树上</li></ul></li><li><p>根据渲染树计算每一个节点的信息</p></li><li><p>根据计算好的信息绘制页面</p><ul><li>第一次确定节点的大小和位置称为布局。</li><li>随后对节点大小和位置的重新计算称为回流。</li><li>将内容提升到GPU上的层（而不是CPU上的主线程）可以提高绘制和重新绘制性能。</li><li>有一些特定的属性和元素可以实例化一个层，包括<code>&lt;video&gt;</code>和<code>&lt;canvas&gt;</code>，任何CSS属性为<code>opacity</code>、3D <code>transform</code>等</li><li>分层确实可以提高重绘速度，但是它以<strong>内存管理</strong>为代价。</li><li>如果加载包含JavaScript（并且延迟到<code>onload</code>事件激发后执行），则<strong>主线程可能很忙</strong>，无法用于滚动、触摸和其他交互。</li></ul></li></ul><h2 id="浏览器的重绘与回流（Repaint、Reflow）"><a href="#浏览器的重绘与回流（Repaint、Reflow）" class="headerlink" title="浏览器的重绘与回流（Repaint、Reflow）"></a>浏览器的重绘与回流（Repaint、Reflow）</h2><h3 id="回流-重排reflow"><a href="#回流-重排reflow" class="headerlink" title="回流/重排reflow"></a>回流/重排reflow</h3><p>当Render Tree中<strong>部分或全部元素的尺寸、结构、或某些属性发生改变时</strong>，浏览器<strong>重新渲染部分或全部文档</strong>的过程。</p><h3 id="重绘Repaint"><a href="#重绘Repaint" class="headerlink" title="重绘Repaint"></a>重绘Repaint</h3><p>当页面中<strong>元素样式的改变并不影响它在文档流中的位置</strong>时（例如：<code>color、background-color、visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它。</p><p>重绘成本很高，<strong>因为浏览器必须验证 DOM 树中所有其他节点的可见性</strong>。</p><p>回流对性能甚至<strong>更为关键</strong>，因为它涉及<strong>影响页面一部分（或整个页面）布局的更改</strong>。</p><p>元素的回流会导致所有子元素和祖先元素以及 DOM 中跟随它的任何元素的后续<strong>回流</strong>。</p><p>在很多情况下，它们相当于<strong>重新布局整个页面</strong>。</p><p>不幸的是，很多事情都会引发回流。其中一些在编写 CSS 时特别相关：</p><ul><li>调整窗口大小</li><li>添加或删除样式表</li><li>内容更改，例如用户在输入框中键入文本</li><li>激活 CSS 伪类，例如 :hover（在 IE 中激活兄弟的伪类）</li><li>操作 DOM 的脚本</li></ul><h3 id="如何避免回流-重绘至少最小化它们对性能的影响？"><a href="#如何避免回流-重绘至少最小化它们对性能的影响？" class="headerlink" title="如何避免回流/重绘至少最小化它们对性能的影响？"></a>如何避免回流/重绘至少最小化它们对性能的影响？</h3><h4 id="在-dom-树中尽可能低地更改类"><a href="#在-dom-树中尽可能低地更改类" class="headerlink" title="在 dom 树中尽可能低地更改类"></a>在 dom 树中尽可能低地更改类</h4><p>将回流的范围限制在尽可能少的节点上</p><h4 id="避免设置多个内联样式"><a href="#避免设置多个内联样式" class="headerlink" title="避免设置多个内联样式"></a>避免设置多个内联样式</h4><p>避免设置多个内联样式，<strong>每个样式都会导致回流</strong>，样式应该组合在一个外部类中，当操作元素的类属性时，只会导致一个重排。</p><h4 id="应用动画到fixed或absolute的定位"><a href="#应用动画到fixed或absolute的定位" class="headerlink" title="应用动画到fixed或absolute的定位"></a>应用动画到fixed或absolute的定位</h4><p>它们<strong>不会影响其他元素的布局</strong>，因此它们<strong>只会导致重绘而不是完全回流</strong>。这成本要低得多。</p><h4 id="避免使用表格进行布局（或设置表格布局固定）"><a href="#避免使用表格进行布局（或设置表格布局固定）" class="headerlink" title="避免使用表格进行布局（或设置表格布局固定）"></a>避免使用表格进行布局（或设置表格布局固定）</h4><p>表格通常需要多次传递才能完全建立布局，即使是很小的更改也会导致表中所有其他节点的回流。</p><h4 id="避免频繁操作DOM"><a href="#避免频繁操作DOM" class="headerlink" title="避免频繁操作DOM"></a>避免频繁操作DOM</h4><ul><li>React的虚拟DOM的作用是将真实 DOM 的副本存储在内存中。当您修改 DOM 时，它首先将这些更改应用到内存中的 DOM。然后，使用它的差异算法，找出真正发生了什么变化。最后，它对更改进行批处理，并调用一次将它们应用到real-dom 上。因此，<strong>最大限度地减少了回流和重绘。</strong></li></ul><ul><li>也可以先为元素设置<code>display: none</code>（不会出现在Render树上，DOM操作不会引发回流和重绘），操作结束后再把它显示出来。</li></ul><h2 id="Cookie、Session、Token、JWT⭐"><a href="#Cookie、Session、Token、JWT⭐" class="headerlink" title="Cookie、Session、Token、JWT⭐"></a>Cookie、Session、Token、JWT⭐</h2><p>Cookie是<strong>服务器发送到用户浏览器</strong>并<strong>保存在本地的一小块数据</strong>，它会在<strong>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</strong>。</p><p>通常，它用于告知服务端两个请求是否来自同一浏览器，如<strong>保持用户的登录状态</strong>。Cookie 使基于<strong>无状态</strong>的HTTP协议记录稳定的状态信息成为了可能。</p><p>Cookie 主要用于以下三个方面：</p><ul><li><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li><strong>个性化设置</strong>（如用户自定义设置、主题等）</li><li><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</li></ul><p><strong>Session 是另一种记录服务器和客户端会话状态的机制</strong>，<strong>使服务端有状态化，可以记录会话信息</strong>。</p><p><strong>Session</strong> 是基于<code>cookie</code> 实现的<strong>，session 存储在服务器端</strong>，<code>sessionId</code> 会被<strong>存储到客户端的cookie 中</strong>。</p><p>第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个<code>Session ID</code>，以后每次请求把这个<code>Session ID</code>发送到服务器，服务器就知道你是谁了。</p><p>Token 是<strong>令牌</strong>，<strong>访问资源接口（API）时所需要的资源凭证</strong>。Token <strong>使服务端无状态化，不会存储会话信息。</strong></p><p><strong>JWT</strong> （JSON Web Token）</p><p>结构：<code>头部（Header）</code>、<code>载荷（Payload）</code>、<code>签名（Signature）</code>，并以<code>.</code>进行拼接。</p><p>其中头部和载荷都是以<code>JSON</code>格式存放数据，只是进行了编码。</p><p>签名是对头部和载荷内容进行签名，加密后存储于客户端，服务端只需要使用密钥解密进行校验（即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</p><h2 id="Cookie、sessionStorage、localStorage-详解及应用场景⭐"><a href="#Cookie、sessionStorage、localStorage-详解及应用场景⭐" class="headerlink" title="Cookie、sessionStorage、localStorage 详解及应用场景⭐"></a>Cookie、sessionStorage、localStorage 详解及应用场景⭐</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是<strong>服务器发送到用户浏览器</strong>并<strong>保存在本地的一小块数据</strong>，它会在<strong>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</strong>。</p><p>通常，它用于告知服务端两个请求是否来自同一浏览器，如<strong>保持用户的登录状态</strong>。Cookie 使基于<strong>无状态</strong>的HTTP协议记录稳定的状态信息成为了可能。<strong>HTTP本质是无状态的，使用Cookies可以创建有状态的会话。</strong></p><h3 id="localStorage-amp-amp-sessionStorage"><a href="#localStorage-amp-amp-sessionStorage" class="headerlink" title="localStorage &amp;&amp; sessionStorage"></a>localStorage &amp;&amp; sessionStorage</h3><blockquote><p>Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在，而Web Storage仅仅是为了在本地“存储”数据而生。</p><p>即<code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p></blockquote><p><code>Web Storage</code>是为了在本地“存储”数据而生。<code>HTML5</code>中的<code>Web Storage</code>包括了两种存储方式：<code>sessionStorage</code>和<code>localStorage</code>。只要有效期和作用域，浏览器每次访问的时候都会将<code>Storage</code>载入到内存里</p><h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><p>IndexedDB 是一种底层 API，用于在客户端存储大量的结构化数据（也包括文件/二进制大型对象（blobs））。该 API 使用索引实现对数据的高性能搜索。虽然Web Storage在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th align="center">特性</th><th align="center">cookie</th><th align="center">localStorage</th><th align="center">sessionStorage</th><th align="center">indexDB</th></tr></thead><tbody><tr><td align="center">数据生命周期</td><td align="center">一般由服务器生成，会话期 Cookie/持久性 Cookie可以设置过期时间</td><td align="center">除非被清理，否则一直存在</td><td align="center">页面关闭就清理</td><td align="center">除非被清理，否则一直存在</td></tr><tr><td align="center">数据存储大小</td><td align="center">4K(数量20+，取决于浏览器)</td><td align="center">5M</td><td align="center">5M</td><td align="center">无限</td></tr><tr><td align="center">与服务端通信</td><td align="center">每次都会携带在header中，对于请求性能影响</td><td align="center">不参与</td><td align="center">不参与</td><td align="center">不参与</td></tr></tbody></table><p>Cookie 主要用于以下三个方面：</p><ul><li><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li><strong>个性化设置</strong>（如用户自定义设置、主题等）</li><li><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</li></ul><p>Cookie <strong>曾一度用于客户端数据的存储</strong>，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，<strong>会带来额外的性能开销（尤其是在移动环境下）</strong>。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 <code>Web storage API</code>（本地存储和会话存储）或 <code>IndexedDB</code> 。</p><h2 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h2><h3 id="性能检测"><a href="#性能检测" class="headerlink" title="性能检测"></a>性能检测</h3><p><code>Lighthouse</code>是谷歌开发并开源的<code>web</code>性能测试工具，用于改进网络应用的质量，可以将其作为一个<code>Chrome</code>扩展程序运行，或从命令行运行。只需要为其提供一个需要审查的地址，<code>Lighthouse</code>就会对页面进行一连串的测试，生成一个有关页面性能的报告。在浏览器的调试工具中默认就存在<code>lighthouse</code>选项，只需要切换至<code>lighthouse</code>，在右侧的选项区选中需要的选项。点击生成报告。</p><p><code>Network</code>面板是一个常被用到的工具，通过它可以获取到网站所有资源的请求情况，包括加载时间，尺寸大小，优先级设置以及<code>HTTP</code>缓存等信息。可以帮助开发者发现可能由于未进行有效压缩而导致资源尺寸过大的问题，未配置缓存策略导致二次请求加载时间过长的问题。</p><p>使用<code>Performance</code>面板主要对网站应用的运行时性能表现进行检测和分析，包括页面的每秒帧数，<code>CPU</code>的消耗和各种请求花费的时间。</p><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p><strong>样式表放在顶部</strong>，<strong>将脚本放在底部</strong>，<strong>减少重绘</strong>，<strong>按需加载</strong>，<strong>模块化</strong></p><p>前端工程化严重的当下，轻量化的框架慢慢被遗忘掉了。并不是所有的业务场景都适合使用工程化框架，<strong>react/vue 并不轻量</strong>。</p><p>NetWork 分析 瀑布图</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>服务端配置gzip压缩后可大大缩减资源大小。</p><p>图片压缩。</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>中文（内容分发网络），服务器是中心化的，CDN是“去中心化的”。</p><p>举个简单的例子：</p><blockquote><p>以前买火车票大家都只能去火车站买，后来我们买火车票就可以在楼下的火车票代售点买了。</p></blockquote><p>所以静态资源度建议放在CDN上，可以加快资源加载的速度。</p><p><strong>CDN加速的本质是缓存加速</strong>。将服务器上存储的静态内容缓存在CDN节点上，当访问这些静态内容时，无需访问服务器源站，就近访问CDN节点即可获取相同内容，从而达到加速的效果，同时减轻服务器源站的压力。</p><p>静态资源是指在不同请求中访问到的数据都相同的静态文件。例如：图片、视频、网站中的文件（html、css、js）、软件安装包、apk文件、压缩包文件等。</p><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种非常好的优化网页性能的方式。</p><p>当可视区域没有滚到资源需要加载的地方时候，可视区域外的资源就不会加载。</p><p>可以减少服务器负载，常适用于图片很多，页面较长的业务场景中。img的loading属性</p><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>和前面说的DNS预查询一样，可以将即将要用到的资源或者即将要握手的地址提前告知浏览器让浏览器利用还在解析HTML计算样式的时间去提前准备好。</p><p>使用link的<code>preload</code>属性预加载一个资源。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>as属性可以指定预加载的类型，除了style还支持很多类型，常用的一般是<code>style</code>和<code>script</code>，<code>css</code>和<code>js</code>。</p><h3 id="iconfont"><a href="#iconfont" class="headerlink" title="iconfont"></a>iconfont</h3><p>中文（图标字体），现在比较流行的一种用法。使用字体图表有几种好处</p><ul><li>矢量</li><li>轻量</li><li>易修改</li><li>不占用图片资源请求。</li></ul><h3 id="组件渲染"><a href="#组件渲染" class="headerlink" title="组件渲染"></a>组件渲染</h3><p>拿react举例，组件分割方面不要太深。需要控制组件的渲染，尤其是深层组件的render。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存的原理就是更快读写的存储介质+减少IO+减少CPU计算=性能优化。而性能优化的第一定律就是：优先考虑使用缓存。</p><p>缓存的主要手段有：浏览器缓存、CDN、反向代理、本地缓存、分布式缓存、数据库缓存。</p><h1 id="基于Android的电子词典设计"><a href="#基于Android的电子词典设计" class="headerlink" title="基于Android的电子词典设计"></a>基于Android的电子词典设计</h1><h2 id="单词数据的爬取"><a href="#单词数据的爬取" class="headerlink" title="单词数据的爬取"></a>单词数据的爬取</h2><blockquote><p>借助Python的Requests库和lxml库</p></blockquote><h3 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h3><p>Requests构建HTTP的请求头<strong>伪装成浏览器与词典网站进行通信</strong>，<strong>发起请求</strong>和<strong>获取响应内容</strong>，对应的方法为<strong>get</strong>方法。主要是获得相应url对应的html。</p><h3 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h3><p>XPath，全称 XML Path Language，即<strong>XML路径语言</strong>，它是一门在XML文档中查找信息的语言。</p><p>使用XPath做相应的信息抽取，即<strong>解析获取到的html</strong>。Python为此提供了<strong>lxml第三方库</strong>。</p><p>XPath以<strong>XML树结构</strong>为基础，能够在数据的结构树中查找各类节点，比如属性节点、文本节点和元素节点等等。</p><p>在检查元素中右键即可复制它的XPath路径，分析规律并且结合XPath的表达式语法，就可获取相关文本内容。</p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>使用<code>Multiprocessing</code>的<code>Pool</code>方法，设置一定数量的进程放在进程池中提供给用户调用。</p><p>新请求提交时，首先判断池有没有满，若没有满，就开辟一个新进程执行，若已满就等待池中的某个进程结束。</p><p>Pool类适用于需要执行的目标比较多而且手动限制进程数量又非常复杂的情况。</p><p>本项目设置一定进程数量的进程池，通过循环将所有需要爬虫的单词异步执行，也就是非阻塞的方式。</p><p>执行完毕后，关闭进程池并继续执行主进程。</p><h3 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h3><p>当时遇到的问题<strong>多进程爬取的数据无法同时向SQLite数据库中保存</strong>，因此先爬取内容到<code>TXT</code>，再保存到数据库中。</p><p>在Python中导入SQLite3模块，打开或连接数据库，若没有数据库则新建；然后，创建游标对象，使用它的execute()方法执行SQL命令，即创建表和插入数据；最后，关闭游标和连接并提交事务。</p><h2 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h2><p>根布局就是<code>DrawerLayout</code>，在根布局之后又主要分为两大部分，第一部分就是我们主界面的内容，第二部分是左边滑出的布局，这里用NavitationView来代替。</p><p>线性布局（<code>LinearLayout</code>）和相对布局（<code>RelativeLayout</code>）实现。</p><p>线性布局是将界面中的全部控件按照<strong>水平</strong>或<strong>竖直</strong>方向进行排列，同时它也是最基本的布局方式。</p><p>相对布局则是通过控件之间的<strong>相对位置</strong>关系实现控件的摆放，有利于适配不同屏幕大小的手机，因此使用更为普遍。</p><p>一般布局都是用<code>dp</code>，字体用<code>sp</code>（手机字体调大了，APP的字体会随之变大）来布局的，用来<strong>适配移动端分辨率</strong>。</p><h2 id="API或SDK"><a href="#API或SDK" class="headerlink" title="API或SDK"></a>API或SDK</h2><p>调用百度API实现句子翻译的功能。</p><p>调用讯飞开放平台的SDK实现语音输入的功能。</p><p>调用Stanford Core NLP的JAR文件实现句子分析（词性分析和词形还原）。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>API 全称 Application Programming Interface，即<strong>「应用程序接口」</strong>。</p><p>一般是指一些预先定义的<strong>函数</strong>，目的是供应用程序与开发人员基于某软件或硬件得以访问一组程序的能力，而又无需访问源码，或理解内部工作机制的细节。</p><h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><p>SDK 全称 Software Development Kit，<strong>软件开发工具包</strong>。</p><p>一般都是一些软件工程师为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件时的开发工具的集合。</p><p>通俗来讲就是<strong>第三方服务商提供的实现产品软件某项功能的工具包</strong>。例如 JDK 就是一种 SDK。</p><p>SDK 相当于开发集成工具环境，API 就是数据接口。API 可以在 SDK 提供的“环境”里请求。同样的，这里的“环境”也是一个抽象的概念。如果不使用 SDK，也可以直接调用 API，只不过，这个环境就要由开发者自己实现了。</p><p><strong>API 在更多场合下更像是 SDK 的一个子集</strong>，他们的区别如下：</p><ul><li>API 通常是一个<strong>函数</strong>，有特定的功能；而 SDK 是一个很多功能函数的<strong>集合体</strong>，更像是一个<strong>工具包</strong>。</li><li>API 通常扮演<strong>数据接口</strong>的形象，SDK 相当于一个<strong>工具环境</strong>，通常是需要在 SDK 的环境下调用 APl。</li><li><strong>SDK 相较于 API 封装层次更高</strong>。</li></ul><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过<strong>分离关注点</strong>的方式来组织代码结构，优化我们的开发效率。</p><p>比如说我们实验室在以前项目开发的时候，使用单页应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，当时一旦项目变得复杂，那么整个文件就会变得冗长，混乱，这样对我们的项目开发和后期的项目维护是非常不利的。</p><p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了<strong>观察者模式</strong>，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p><p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 <strong>View 层和 Model 层耦合在一起</strong>，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 <strong>View 层和 Model 层的解耦</strong>。MVC 中的 Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此我们可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p><p>MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的数据绑定，<strong>将 View 和 Model 的同步更新给自动化了</strong>。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如 vue 是通过使用数据劫持和发布订阅者模式来实现的这一功能。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p>发布订阅与观察者没什么区别。真正的区别在于，<strong>发布订阅模式</strong>实现的是一种<strong>多对多</strong>的关系，在发布者与订阅者之间需要有一个<strong>中介者</strong>，发布者发布事件名和参数到中间者，中间者向事件集中的订阅者发送参数。<br>而<strong>观察者</strong>是一种<strong>一对多</strong>的关系，所有的在同一被观察者身上绑定的观察者只能接受同一个被观察者的消息。</p><h3 id="Android-MVVM"><a href="#Android-MVVM" class="headerlink" title="Android MVVM"></a>Android MVVM</h3><blockquote><p><strong>View：</strong>XML布局文件。 <strong>Model：</strong>实体模型（数据的获取、存储、数据状态变化）。 <strong>Controller：</strong>对应于Activity，处理数据、业务和UI。</p></blockquote><p>从上面这个结构来看，Android本身的设计还是符合MVC架构的，但是<strong>Android中纯粹作为View的XML视图功能太弱，我们大量处理View的逻辑只能写在Activity中，这样Activity就充当了View和Controller两个角色</strong>，直接导致Activity中的代码大爆炸。相信大多数Android开发者都遇到过一个Acitivty数以千行的代码情况吧！所以，更贴切的说法是，这个MVC结构最终其实只是一个<strong>Model-View（Activity:View&amp;Controller）</strong>的结构。</p><blockquote><p>**View: **对应于Activity和XML，负责View的绘制以及与用户交互。 **Model: **实体模型。 **ViewModel: **负责完成View与Model间的交互，负责业务逻辑。</p></blockquote><p>Android为此提供了一套架构组件，主要有LiveData、ViewModel 和Room。</p><ul><li>LiveData是用来构建数据对象，当基础数据库改变时会通知视图；</li><li>ViewModel是用来存储和管理与界面相关的数据，这些数据在应用跳转时不会被销毁；</li><li>Room是一个SQLite对象映射库，它可以轻松地将SQLite表数据转换为Java对象，主要负责底层数据库的处理，本文调用其中的Dao接口来执行数据库增删改查等操作，利用 Database创建和管理数据库。同时，Room可以为SQLite语句提供编译时检查，并能够返回RxJava、Flowable和LiveData可观察对象。</li><li>Repository是一个仓库类，介于视图层与数据映射层（数据访问层）之间。它的作用是让视图层感觉不到数据访问层的存在，提供了一个类似集合的接口给视图层进行访问。</li></ul><p>采用MVVM模式最大的优点就是编写代码是思路明确，<strong>视图层与模型层完全解耦</strong>，方便后期的管理与维护，在代码中的其他地方使用数据库相关的操作只需一行代码，极其方便。</p><h1 id="One-Piece-商城后台管理系统"><a href="#One-Piece-商城后台管理系统" class="headerlink" title="One Piece 商城后台管理系统"></a>One Piece 商城后台管理系统</h1><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><ol><li>此项目为一个<strong>前后台分离</strong>的<strong>后台管理的 SPA</strong>（单页面应用）, 包括前端 PC 应用和后端应用</li><li>包括<strong>用户管理</strong> / <strong>商品管理</strong> / <strong>权限管理</strong>等功能模块</li><li>前端: 使用 <strong>React 全家桶（函数式组件、react-router V6）</strong> + <strong>Antd（v4）</strong> + <strong>Axios</strong> + <strong>ES6</strong> + <strong>Webpack</strong> 等技术</li><li>后端: 使用 <strong>Node</strong> + <strong>Express</strong> + <strong>Mongodb</strong> 等技术</li><li>采用<strong>模块化</strong>、<strong>组件化</strong>、<strong>工程化</strong>的模式开发</li></ol><p>使用<code>create-react-app</code>(脚手架)搭建项目。</p><p><code>create-react-app</code> 是react 官方提供的用于搭建基于<code>react</code>+<code>webpack</code>+<code>es6</code> 项目的脚手架</p><p><code>antd</code> 是基于 Ant Design 设计体系的 <strong>React UI 组件库</strong>，主要用于研发企业级中后台产品。</p><p><code>craco</code>一个对 create-react-app 进行<strong>自定义配置</strong>的社区解决方案</p><h2 id="后端数据"><a href="#后端数据" class="headerlink" title="后端数据"></a>后端数据</h2><p>Node + Express + Mongodb等技术。</p><p>Node.js 使用 JavaScript 语言开发服务器端应用；</p><p>Express是基于 Node.js平台，快速、开放、极简的 Web 开发框架；</p><p>MongoDB 是一个基于分布式文件存储的数据库。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p><h2 id="模块化、组件化、工程化"><a href="#模块化、组件化、工程化" class="headerlink" title="模块化、组件化、工程化"></a>模块化、组件化、工程化</h2><h3 id="模块化-1"><a href="#模块化-1" class="headerlink" title="模块化"></a>模块化</h3><p>后端：<strong>CommonJS</strong> :<code>module.exports</code>、<code>require</code>方法用于加载模块。</p><p>前端：<strong>ES6</strong> 模块化语法：export 和 import；</p><h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><p><code>webpack</code>最热门的前端资源模块化管理和打包工具、</p><p><code>create-react-app</code> 脚手架初始化react 项目开发、</p><p><code>ESLint</code> 插件化的 JavaScript 代码检测工具</p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>其中以React的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。</p><p>理解:<strong>用来实现局部功能效果的代码和资源的集合(html/css/js/img等等)</strong></p><p>为什么要用组件:一个界面的功能复杂</p><p>作用:<strong>复用编码,简化项目编码,提高运行效率</strong></p><p>当应用是以多组件的方式实现,这个应用就是组件化的应用。</p><h2 id="天气API"><a href="#天气API" class="headerlink" title="天气API"></a>天气API</h2><p>和风天气（不需要跨域处理） get请求 天气图标使用图标字体。</p><h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><h3 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h3><h4 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h4><p><code>flex + justify-content + align-items</code></p><h4 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h4><p><code>margin: 0 auto</code></p><h4 id="图片与文字在一行内的居中问题"><a href="#图片与文字在一行内的居中问题" class="headerlink" title="图片与文字在一行内的居中问题"></a>图片与文字在一行内的居中问题</h4><p>父元素开启Flex并设置<code>align-items: center</code>，图片可以正常居中，但文字不行，文字（h1中）会自动添加一个下边距，应该是文字与图片对齐方式不同导致的。</p><p>一种方法是文字里添加<code>margin-bottom:0;</code></p><p>另一种方法是图片和文字采用不同方法居中，父元素开启Flex使它们都在一行，但不设置<code>align-items: center</code>，给图片设置<code>align-self:center;</code>使其垂直居中，文字设置<code>line-height值等于父元素的height</code>。</p><h3 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h3><blockquote><p>气泡背景原理：</p></blockquote><p><strong>background</strong>可以设置多个，默认地，每个背景图像在水平和垂直方向上<strong>重复</strong>。因此，通过设置多个背景图像的<strong>位置</strong>和<strong>大小</strong>产生重叠效果。</p><p>气泡：<code>radial-gradient</code>+<code>rgba</code></p><p>开始和结束的透明度都设为0。通过两个确定位置的固定色值（有一定透明度的白色），实现渐变效果。</p><p><code>radial-gradient(rgba(255,255,255,0) 0, rgba(255,255,255,.15) 30%, rgba(255,255,255,.3) 32%, rgba(255,255,255,0) 33%)</code></p><blockquote><p>边框</p></blockquote><p><code>box-shadow</code> 内外阴影效果。</p><blockquote><p>背景毛玻璃</p></blockquote><p><code>backdrop-filter: blur(5px);</code></p><p>该属性可以让你为一个元素后面区域添加图形效果（如模糊或颜色偏移）。 因为它适用于元素背后的所有元素，为了看到效果，必须使元素或其背景至少部分透明。</p><blockquote><p>头像旋转</p></blockquote><p><code>animation</code>+<code>transform: rotate</code></p><h3 id="预加载动画"><a href="#预加载动画" class="headerlink" title="预加载动画"></a>预加载动画</h3><p>在index.html中的<code>div root</code>中先填充加载元素，通过css设置样式</p><p>多个<code>span</code> <code>animation</code> <code>animation-delay</code> <code>opacity</code> <code>background</code> 无限循环</p><p>等react组件加载完成后就会覆盖</p><h2 id="类式组件与函数式组件"><a href="#类式组件与函数式组件" class="headerlink" title="类式组件与函数式组件"></a>类式组件与函数式组件</h2><blockquote><p>因为React-Router v6正式版的更新，类式路由组件很多功能不易完成，比如无法直接操作history。</p><p>另外React-Router官方推荐使用函数式组件。</p></blockquote><h2 id="React-Router-v6-新特性"><a href="#React-Router-v6-新特性" class="headerlink" title="React-Router v6 新特性"></a>React-Router v6 新特性</h2><h3 id="SPA的理解"><a href="#SPA的理解" class="headerlink" title="SPA的理解"></a>SPA的理解</h3><ul><li>单页Web应用（single page web application，SPA）。</li><li>整个应用只有<strong>一个完整的页面</strong>。</li><li>点击页面中的链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部更新。</strong></li><li>数据都需要通过ajax请求获取, 并在前端异步展现。</li></ul><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>React Router v6 大量使用<a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-intro.html">React hooks</a>。官方明确推荐<strong>函数式组件</strong>了。</p><p><code>Routes</code>是以前 <code>Switch</code> 组件的升级版，它包括相对路由和链接、自动路由排名、嵌套路由和布局等功能。</p><p><code>component</code>重命名为<code>element</code>。</p><p>v6的<code>&lt;Routes&gt;</code>元素下的所有<code>&lt;Route path</code>&gt;和<code>&lt;Link to&gt;</code>值都是<strong>自动相对于它们的父路由渲染的</strong>，而且忽略当前URL中的尾部斜杠。头部斜杠代变绝对路径。</p><p>中小型项目<strong>嵌套路由可集中显示</strong>，在需要显示的地方使用<code>&lt;Outlet /&gt;</code>作为占位符。</p><p>若<strong>分别显示</strong>，具有后代路由（在其他组件中定义）的路由在其路径中使用尾随<code>*</code> 。</p><p>“默认子路由”：<code>index</code>（不写path）表示索引路由共享父路径。这就是重点——它没有路径。</p><p>“未找到”路由：<code>path=&#39;*&#39;</code>表示路径都不匹配时。具有最弱的优先级。</p><p>v6 提供了 <strong>Navigate</strong> 组件，以前版本中的<code>Redirect</code>组件也消失了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  根组件(函数式)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;login&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Login</span> /&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Admin</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">index</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;category&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Category</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;product&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Product</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">index</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ProductHome</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;detail&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ProductDetail</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;addupdate&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ProductAddUpdate</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;user&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">User</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;role&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Role</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;charts-bar&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Bar</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;charts-pie&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Pie</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;charts-line&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Line</span> /&gt;</span>&#125; /&gt;    </span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;/* 以上路径都不匹配时 */&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;*&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">NotFound</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后台管理的路由组件</span></span><br><span class="line"><span class="comment"> *  */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Admin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> user = memoryUtils.user</span><br><span class="line">    <span class="comment">// 如果内存没有存储user ==&gt; 当前没有登陆</span></span><br><span class="line">    <span class="keyword">if</span> (!user || !user._id) &#123;</span><br><span class="line">        <span class="comment">// 自动跳转到登陆(在render()中) Navigate替代Redirect</span></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&#x27;/login&#x27;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        ...     </span><br><span class="line">        &lt;Outlet /&gt;&#123;<span class="comment">/* 占位符 */</span>&#125;</span><br><span class="line">    	...</span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v6 <strong>无法直接访问history实例</strong>，将useHistory更改为 <strong>useNavigate</strong>（兼容性和体验）。</p><p>useNavigate返回一个函数用来实现编程式导航。</p><p>传入数值进行前进或后退，类似于5.x中的 history.go()方法 <code>navigate(-1)</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useNavigate &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录的路由组件(函数式组件)</span></span><br><span class="line"><span class="comment"> * 类式路由组件在onFinish中拿不到history</span></span><br><span class="line"><span class="comment"> *  */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Login</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> navigate = useNavigate();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交表单且数据验证成功后回调事件</span></span><br><span class="line">    <span class="keyword">const</span> onFinish = <span class="keyword">async</span> values =&gt; &#123;</span><br><span class="line">			...</span><br><span class="line">            <span class="comment">// 跳转到管理界面 (不需要再回退回到登陆)</span></span><br><span class="line">            navigate(<span class="string">&#x27;/&#x27;</span>, &#123; <span class="attr">replace</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">       ...</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v5:<strong>withRouter</strong>高阶组件:包装非路由组件, 返回一个新的组件，新的组件向非路由组件传递3个属性: <code>history/location/match</code></p><p>v6:<strong>非路由组件</strong>使用<code>useLocation</code>也可得到<code>location</code>对象，<code>withRouter</code>不再使用。<code>useLocation().pathname</code>得到当前路径名。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> location =useLocation();</span><br><span class="line"><span class="keyword">const</span> path = location.pathname;</span><br><span class="line"></span><br><span class="line"><span class="comment">// location对象</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">hash</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;hvfbi1fy&quot;</span></span><br><span class="line">    <span class="attr">pathname</span>: <span class="string">&quot;/role&quot;</span></span><br><span class="line">    <span class="attr">search</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">state</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>useRoutes</code>钩子是一个路由API，它允许你使用<strong>JavaScript对象</strong>而不是React元素来声明和组合路由。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> element = useRoutes([</span><br><span class="line">    <span class="comment">// 这些与您提供给 &lt;Route&gt; 的props相同</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;dashboard&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Dashboard</span> /&gt;</span></span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;invoices&quot;</span>,</span><br><span class="line">      <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Invoices</span> /&gt;</span></span>,</span><br><span class="line">      <span class="comment">// 嵌套路由使用 children 属性，这也与 &lt;Route&gt; 相同</span></span><br><span class="line">      children: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;:id&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Invoice</span> /&gt;</span></span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;sent&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">SentInvoices</span> /&gt;</span></span> &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Not found routes work as you&#x27;d expect</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;*&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">NotFound</span> /&gt;</span></span> &#125;,</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回的元素将呈现整个元素层次结构及其所需的所有适当上下文</span></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Link</strong></p><p>标签体内容也是一种特殊的标签属性。</p><p>在 v5 中，不以 / 开头的 <code>&lt;Link to&gt;</code> 值是不明确的； 这取决于当前的 URL 是什么。 例如，如果当前 URL 是 /users，则 v5 <code>&lt;Link to=&quot;me&quot;&gt;</code> 将呈现 <code>&lt;a href=&quot;/me&quot;&gt;</code>。 但是，如果当前 URL 有一个结尾斜杠，例如 /users/，则相同的 <code>&lt;Link to=&quot;me&quot;&gt;</code> 将呈现 <code>&lt;a href=&quot;/users/me&quot;&gt;</code>。 这使得很难预测链接的行为方式，因此在 v5 中，我们建议您从根 URL（使用 match.url）构建链接，而不是使用相对的 <code>&lt;Link to&gt;</code> 值。</p><p>React Router v6 修复了这种歧义。 在 v6 中，<code>&lt;Link to=&quot;me&quot;&gt;</code> 将始终呈现相同的 <code>&lt;a href&gt;</code>，而不管当前的 URL。</p><p>例如，在 <code>&lt;Route path=&quot;users&quot;&gt;</code> 中呈现的 <code>&lt;Link to=&quot;me&quot;&gt;</code> 将始终呈现指向 /users/me 的链接，无论当前 URL 是否具有尾部斜杠。</p><p>当您想“向上”链接回父路由时，请在 <code>&lt;Link to&gt;</code> 值中使用前导 <code>..</code> 段，类似于您在 <code>&lt;a href&gt;</code> 中所做的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;users&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Users</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;:id&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">UserProfile</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Users</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;/* This links to /users - the current route */&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;.&quot;</span>&gt;</span>Users<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;users.map(user =&gt; (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;/* This links to /users/:id - the child route */&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;user.id&#125;</span>&gt;</span>&#123;user.name&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserProfile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;/* This links to /users - the parent route */&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;..&quot;</span>&gt;</span>All Users<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;/* This links to /users/:id - the current route */&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;.&quot;</span>&gt;</span>User Profile<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;/* This links to /users/mj - a &quot;sibling&quot; route */&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;../mj&quot;</span>&gt;</span>MJ<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由参数传递"><a href="#路由参数传递" class="headerlink" title="路由参数传递"></a>路由参数传递</h3><h4 id="param参数"><a href="#param参数" class="headerlink" title="param参数"></a>param参数</h4><ul><li>在<code>Route组件</code>中的<code>path属性</code>中定义路径参数</li><li>在组件内通过<code>useParams</code> hook访问路径参数</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义参数</span></span><br><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/foo/:id&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;Foo&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line">&lt;/BrowserRouter&gt;</span><br><span class="line"><span class="comment">// 传递参数</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">LinkButton</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> navigate(`addupdate/$&#123;product.id&#125;`)&#125; &gt;</span></span><br><span class="line"><span class="xml">    修改</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">LinkButton</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 提取参数</span></span><br><span class="line"><span class="keyword">import</span> &#123; useParams &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> params = useParams();</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;params.id&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>个人理解：param参数适合传递一个参数时使用。</strong></p><p><strong>useMatch</strong>()</p><ol><li><p>作用：返回当前匹配信息，对标5.x中的路由组件的<code>match</code>属性。</p></li><li><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/login/:page/:pageSize&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Login</span> /&gt;</span></span>&#125;/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;/login/1/10&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Login</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> match = useMatch(<span class="string">&#x27;/login/:x/:y&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(match) <span class="comment">//输出match对象</span></span><br><span class="line">  <span class="comment">//match对象内容如下：</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  	&#123;</span></span><br><span class="line"><span class="comment">      params: &#123;x: &#x27;1&#x27;, y: &#x27;10&#x27;&#125;</span></span><br><span class="line"><span class="comment">      pathname: &quot;/LoGin/1/10&quot;  </span></span><br><span class="line"><span class="comment">      pathnameBase: &quot;/LoGin/1/10&quot;</span></span><br><span class="line"><span class="comment">      pattern: &#123;</span></span><br><span class="line"><span class="comment">      	path: &#x27;/login/:x/:y&#x27;, </span></span><br><span class="line"><span class="comment">      	caseSensitive: false, </span></span><br><span class="line"><span class="comment">      	end: false</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  	<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="search参数-amp-sate参数"><a href="#search参数-amp-sate参数" class="headerlink" title="search参数&amp;sate参数"></a>search参数&amp;sate参数</h4><p>Location：这是一个 React Router 特定的对象，它基于内置浏览器的 window.location 对象。 它代表“用户在哪里”。 它主要是 URL 的对象表示，但比这更多。</p><p>location state：与 URL 中未编码的位置保持一致的值。 很像哈希或搜索参数（在 URL 中编码的数据），但不可见地存储在浏览器的内存中。</p><p>您可以通过两种方式设置<code>location state</code>在<code>&lt;Link&gt;</code>上或<code>navigate</code>上，在下一路由组件中你可以用<code>useLocation</code>来访问它。</p><p><code>useLocation()</code>既可以获得<code>state</code>参数，也可以获得<code>search</code>参数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinkButton onClick=&#123;<span class="function">() =&gt;</span> navigate(<span class="string">&#x27;addupdate?name=tom&amp;age=18&#x27;</span>, &#123; <span class="attr">state</span>: product &#125;)&#125; &gt;</span><br><span class="line">    修改</span><br><span class="line">&lt;/LinkButton&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isUpdate = location.state</span><br><span class="line"><span class="keyword">const</span> search = location.search</span><br><span class="line"><span class="built_in">console</span>.log(search) <span class="comment">// ?name=tom&amp;age=18</span></span><br><span class="line"><span class="built_in">console</span>.log(isUpdate) <span class="comment">// &#123;status: 1, imgs: Array(2), _id: &#x27;5e12b97de31bb727e4b0e349&#x27;, name: &#x27;联想ThinkPad 翼4809&#x27;, desc: &#x27;年度重量级新品，X390、T490全新登场 更加轻薄机身设计9&#x27;, …&#125;</span></span><br></pre></td></tr></table></figure><p><strong>个人理解：state参数适合传js对象。</strong></p><p><code>search</code>参数一般使用<code>useSearchParams()</code>进行获取和修改。</p><ol><li>作用：用于读取和修改当前位置的 URL 中的查询字符串。</li><li>返回一个包含两个值的数组，内容分别为：当前的seaech参数、更新search的函数。</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [search,setSearch] = useSearchParams()</span><br><span class="line"><span class="keyword">const</span> age = search.get(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> name = search.get(<span class="string">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>个人理解：search参数适合传可能会被修改的参数。</strong></p><h2 id="Antd-v3升级成v4"><a href="#Antd-v3升级成v4" class="headerlink" title="Antd v3升级成v4"></a>Antd v3升级成v4</h2><h4 id="去除-Form-create"><a href="#去除-Form-create" class="headerlink" title="去除 Form.create"></a>去除 Form.create</h4><p>v4 的 Form 不再需要通过 <code>Form.create()</code> 创建上下文。Form 组件现在自带数据域，因而 <code>getFieldDecorator</code> 也不再需要，直接写入 Form.Item 即可：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// antd v4</span></span><br><span class="line"><span class="keyword">const</span> Demo = <span class="function">() =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Form</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Form.Item</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">rules</span>=<span class="string">&#123;[&#123;</span> <span class="attr">required:</span> <span class="attr">true</span> &#125;]&#125;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Input</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>由于移除了 <code>Form.create()</code>，原本的 <code>onFieldsChange</code> 等方法移入 Form 中，通过 <code>fields</code> 对 Form 进行控制。</p><h4 id="表单控制调整"><a href="#表单控制调整" class="headerlink" title="表单控制调整"></a>表单控制调整</h4><p>Form 自带表单控制实体，如需要调用 form 方法，可以通过 <code>Form.useForm()</code> 创建 <strong>Form 实体</strong>进行操作：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// antd v4</span></span><br><span class="line"><span class="keyword">const</span> Demo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [form] = Form.useForm();</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    form.setFieldsValue(&#123;</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&#x27;Bamboo&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Form</span> <span class="attr">form</span>=<span class="string">&#123;form&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Form.Item</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">rules</span>=<span class="string">&#123;[&#123;</span> <span class="attr">required:</span> <span class="attr">true</span> &#125;]&#125;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Input</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于 class component，也可以通过 <code>ref</code> 获得实体：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// antd v4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  formRef = React.createRef();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.formRef.current.setFieldsValue(&#123;</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&#x27;Bamboo&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Form</span> <span class="attr">ref</span>=<span class="string">&#123;this.formRef&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Form.Item</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">rules</span>=<span class="string">&#123;[&#123;</span> <span class="attr">required:</span> <span class="attr">true</span> &#125;]&#125;&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Input</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="onFinish-替代-onSubmit"><a href="#onFinish-替代-onSubmit" class="headerlink" title="onFinish 替代 onSubmit"></a>onFinish 替代 onSubmit</h4><p>对于表单校验，过去版本需要通过监听 <code>onSubmit</code> 事件手工触发 <code>validateFields</code>。新版直接使用 <code>onFinish</code> 事件，该事件仅当校验通过后才会执行：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// antd v4</span></span><br><span class="line"><span class="keyword">const</span> Demo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> onFinish = <span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Received values of form: &#x27;</span>, values);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Form</span> <span class="attr">onFinish</span>=<span class="string">&#123;onFinish&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Form.Item</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">rules</span>=<span class="string">&#123;[&#123;</span> <span class="attr">required:</span> <span class="attr">true</span> &#125;]&#125;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Input</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="初始化调整"><a href="#初始化调整" class="headerlink" title="初始化调整"></a>初始化调整</h4><p>此外，我们将 <code>initialValue</code> 从字段中移到 Form 中。以避免同名字段设置 <code>initialValue</code> 的冲突问题：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// antd v4</span></span><br><span class="line"><span class="keyword">const</span> Demo = <span class="function">() =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Form</span> <span class="attr">initialValues</span>=<span class="string">&#123;&#123;</span> <span class="attr">username:</span> &#x27;<span class="attr">Bamboo</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Form.Item</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">rules</span>=<span class="string">&#123;[&#123;</span> <span class="attr">required:</span> <span class="attr">true</span> &#125;]&#125;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Input</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在 v3 版本中，修改未操作的字段 <code>initialValue</code> 会同步更新字段值，这是一个 BUG。但是由于被长期作为一个 feature 使用，因而我们一直没有修复。在 v4 中，该 BUG 已被修复。<code>initialValue</code> 只有在初始化以及重置表单时生效。</p><h4 id="validateFields-不再支持-callback"><a href="#validateFields-不再支持-callback" class="headerlink" title="validateFields 不再支持 callback"></a>validateFields 不再支持 callback</h4><p><code>validateFields</code> 会返回 Promise 对象，因而你可以通过 <code>async/await</code> 或者 <code>then/catch</code> 来执行对应的错误处理。不再需要判断 <code>errors</code> 是否为空：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// antd v4</span></span><br><span class="line">validateFields().then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Do something with value</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><ul><li>echarts echarts-for-react</li><li>bizcharts</li></ul><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="登录数据持久化"><a href="#登录数据持久化" class="headerlink" title="登录数据持久化"></a>登录数据持久化</h3><p>默认使用最高级管理员登录，该管理员名称和密码为默认值，且拥有最高权限。通过向后端发送用户名和密码，后端返回用户信息，其中密码在后端使用<strong>md5</strong>加密格式返回，然后将用户信息保存在内存和<code>localStorage</code>中（store.js），每次打开该网站时就从localStorage中读取数据到内存，实现登录数据持久化。</p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>根据首次登录后端传回的权限信息，前端渲染前先进行检查，在左侧导航栏展示的内容<strong>递归（map）</strong>遍历检查是否拥有展示权限。</p><p>后端其实并没有保存登录状态。不同的用户只能操作自己可见的内容。</p><h3 id="输入校验"><a href="#输入校验" class="headerlink" title="输入校验"></a>输入校验</h3><p><strong>正则</strong></p><p><code>/^[a-zA-Z0-9_]+$/</code>用户名必须是英文,数字和下划线组成</p><p><code>/^[a-zA-Z0-9_]+$/.test(value)</code></p><h3 id="跨域和Ajax"><a href="#跨域和Ajax" class="headerlink" title="跨域和Ajax"></a>跨域和Ajax</h3><p>React中配置代理</p><p>在<code>package.json</code>中追加如下配置 :<code>&quot;proxy&quot;:http://localhost:5000</code></p><p>Promise封装axios</p><h3 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h3><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><ul><li><p>【父组件】给【子组件】传递数据：通过<code>props</code>传递</p></li><li><p>【子组件】给【父组件】传递数据：通过<code>props</code>传递，<strong>要求父提前给子传递一个函数</strong></p><p>该项目中将<code>useState</code>的更新函数传给子组件，将数据作为函数参数传回父组件用来更新状态</p></li><li><p>【子组件】给【父组件】传递函数/方法</p><ul><li><code>useRef</code>: 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 ref 对象在组件的整个生命周期内持续存在。一个常见的用例便是命令式地访问子组件。</li><li><code>useImperativeHandle</code>:可以让你在使用 <code>ref</code> 时<strong>自定义暴露给父组件的实例值</strong>。比如暴露子组件的某个方法。<code>useImperativeHandle</code> 应当与<code>React.forwardRef</code> 一起使用：</li></ul></li></ul><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>因为是静态站点，所以完全是<strong>客户端部分</strong>，那么在使用路由的时候如果不在意美观，尽可能地使用<strong>Hash</strong>路由，这样跳转会没有任何问题。因为<strong>BrowserRouter依赖于服务端支持</strong>，使用它的话访问会出现404 not Found.</p><blockquote><p>由于最开时搭建项目没有考虑发布问题，而且v6版本的’/‘代变绝对路径，输入<a target="_blank" rel="noopener" href="https://lesliewaong.github.io/react-admin-client%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%B7%B3%E8%BD%AC%E8%87%B3https://Lesliewaong.github.io/%EF%BC%8C%E4%BA%8E%E6%98%AF%E4%BD%BF%E7%94%A8HashRouter%E6%9D%A5%E4%BB%A3%E6%9B%BFBrowserRouter%E8%BF%9B%E8%A1%8C%E5%8F%91%E5%B8%83%E3%80%82">https://Lesliewaong.github.io/react-admin-client会自动跳转至https://Lesliewaong.github.io/，于是使用HashRouter来代替BrowserRouter进行发布。</a></p></blockquote><h3 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h3><blockquote><p>这一种很自然，比如 <code>/</code> 对应 <code>Home页</code> ，<code>/about</code> 对应 <code>About 页</code>，但是<code>这样的设计需要服务器端渲染</code>，因为<code>用户可能直接访问任何一个 URL，服务器端必须能对 /的访问返回 HTML，也要对 /about的访问返回 HTML</code>。BrowserRouter支持这种URL。</p></blockquote><p>①基于<code>history</code>模式：页面跳转原理是使用了HTML5为浏览器全局的history对象新增了两个API，包括 history.pushState、history.replaceState；和vue router的history模式实现一致<br>②更加优雅： 直接拼接路径；如：<code>www.abc.com/xx</code><br>③<strong>后端需做请求处理</strong>： 切换路由后，请求接口路径会发生变化，后端需要配合，做处理</p><h3 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h3><blockquote><p>这一种看起来不自然，但是实现更简单。</p><p><code>只有一个路径 /，通过 URL 后面的 # 部分来决定路由</code>，<code>/#/</code> 对应 Home 页，<code>/#/about</code> 对应 About 页。</p><p>因为URL中<code>#</code>之后的部分是不会发送给服务器的，所以，<code>无论哪个 URL，最后都是访问服务器的 / 路径，服务器也只需要返回同样一份 HTML</code>就可以，<code>然后由浏览器端解析#后的部分，完成浏览器端渲染</code>。HashRouter支持这种URL。</p></blockquote><p>①<strong>基于hash模式</strong>：页面跳转原理是使用了location.hash、location.replace；和vue router的hash模式实现一致。<br>②<strong>比较丑</strong>：在域名后，先拼接<code>/#</code>，再拼接路径；也就是利用锚点，实现路由的跳转；如：<code>www.abc.com/#/xx</code></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><strong>HashRouter</strong>：<strong>项目部署在内网</strong>：如To B的项目、本公司业务人员用的项目等等。</p><p><strong>BrowserRouter</strong>：<strong>项目部署在公网</strong>：如To C的项目、面向大众的项目，url路径美观点当然更好，但后端需要做处理。</p><h3 id="GitHub-Pages发布静态页面"><a href="#GitHub-Pages发布静态页面" class="headerlink" title="GitHub Pages发布静态页面"></a>GitHub Pages发布静态页面</h3><p><code>package.json</code> 打包好的build文件夹上传gh-pages分支</p><h2 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h2><h3 id="自定义hook实现搜索防抖"><a href="#自定义hook实现搜索防抖" class="headerlink" title="自定义hook实现搜索防抖"></a>自定义hook实现搜索防抖</h3><p><strong>Input</strong> <code>event.target.value</code> 获取输入值 ，<strong>useState</strong> 更新此时的搜索状态 。</p><p>自定义 hook <strong>useDebounce</strong></p><p>debounce一般使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lodash</span></span><br><span class="line"><span class="keyword">import</span> debounce <span class="keyword">from</span> <span class="string">&#x27;lodash/debounce&#x27;</span></span><br><span class="line">debounce(<span class="function">()=&gt;</span>search(value), <span class="number">500</span>)</span><br><span class="line"><span class="comment">// 自定义</span></span><br><span class="line"><span class="keyword">const</span> debounceFn =<span class="function">(<span class="params">fn, wait=<span class="number">1000</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(fn, wait);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [value, setValue] = useState(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&lt;!--搜索函数--&gt;</span><br><span class="line"><span class="keyword">const</span> search = <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">    &lt;!--调用接口--&gt;</span><br><span class="line">&#125;</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    debounceFn(<span class="function">()=&gt;</span>search(params))</span><br><span class="line">&#125;, [value])</span><br></pre></td></tr></table></figure><p>测试发现这一套在useEffect里是行不通的，每次组件重新渲染，都会执行一遍所有的hooks，每次都创建了新的定时器，定时器无法按规定清除，这样debounce高阶函数里面的timer就不能起到缓存的作用。timer不可靠，debounce的核心就被破坏了。</p><p>使用useCallback返回回调函数的 memoized 版本，<strong>该回调函数仅在某个依赖项改变时才会更新</strong>，通过设置空数组，使debounce高阶函数里面的timer唯一。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debounceFn = useCallback(</span><br><span class="line">    debounce(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">        callback()</span><br><span class="line">    &#125;, <span class="number">1000</span>),</span><br><span class="line">    []</span><br><span class="line">)</span><br><span class="line">&lt;!--value值变化触发--&gt;</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    debounceFn(<span class="function">()=&gt;</span>search(params))</span><br><span class="line">&#125;, [value])</span><br></pre></td></tr></table></figure><p>也可以借助useEffect自定义useDebounce ，关键<strong>React 会在执行当前 effect 之前对上一个effect进行清除</strong>。</p><p>当首次渲染时，执行effect延时后执行一次搜索操作，可以通过给value赋初值跳过这次搜索请求，之后每当输入时，value就会变化，每次变化先清除上一次effect的timer，然后建立新的timer等待执行，当输入停止后搜索函数在延时后就会发送请求，实现防抖。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理方案四 useEffect自定义hooks</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDebounce</span>(<span class="params">fn, delay, dep=[]</span>) </span>&#123;</span><br><span class="line">   useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> timer;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(fn, delay);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">()=&gt;</span><span class="built_in">clearTimeout</span>(timer); <span class="comment">// 这里用到useEffect清除的能力 类似于componentWillUnmount</span></span><br><span class="line">   &#125;, [...dep]</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useDebounce</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">useDebounce(<span class="function">()=&gt;</span>search(value), <span class="number">500</span>, [value])</span><br></pre></td></tr></table></figure><p>使用useRef保证<strong>多次渲染之间保证唯一值的纽带</strong>。将timer通过useRef创建。</p><p>useRef 会在所有的 render 中保持对返回值的唯一引用。因为所有对<code>ref</code>的赋值和取值拿到的都是最终的状态，并不会因为不同的 render 中存在不同的隔离。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理方案五 useRef自定义hooks</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDebounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> timer = useRef(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer.current);</span><br><span class="line">        timer.current = <span class="built_in">setTimeout</span>(fn, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useDebounce</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">const</span> debounceSearch = useDebounce(<span class="function">() =&gt;</span> handleParams(params), <span class="number">500</span>)</span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;debounceSearch()&#125;,[value]</span><br></pre></td></tr></table></figure><h3 id="刷新后父级菜单的展开问题"><a href="#刷新后父级菜单的展开问题" class="headerlink" title="刷新后父级菜单的展开问题"></a>刷新后父级菜单的展开问题</h3><p>Menu可以通过<code>defaultOpenKeys</code>设置当前的菜单是否展开。</p><p>需求：如果点击了一个子菜单后，再刷新时该子菜单对应的上一级菜单是展开的。</p><p>方法：</p><ul><li><p>拿到当前路径（location属性中的<code>pathname</code>）</p><ul><li>withRouter高阶组件包装非路由组件, 返回一个新的组件。新的组件向非路由组件传递3个属性: <code>history/location/match</code></li><li>v6:使用<code>useLocation</code>即可得到location属性，withRouter不再使用。</li></ul></li><li><p>当存在子Item时，通过find和indexOf判断是否有与当前请求路径匹配的子Item，如果匹配就将父item设置展开。</p></li><li><p>由于需要将所有菜单遍历判断与当前路径是否匹配，而且OpenKeys的属性需要在组件渲染完成前得到，但我们仅希望刷新时调用一次，得到初始openKey，而不希望<strong>路由跳转</strong>等操作也执行该函数。</p></li><li><p>所以使用useMemo和useRef进行优化。使用useRef是因为pathname是个随路由跳转变化的值，放到useMemo中，如果不加入依赖数组会有警告。使用useRef也可以存储最新的pathname，而且不用加入依赖。</p><p><code>const pathRef = useRef(path);</code></p><p>``pathRef.current=path;`</p></li></ul><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="为什么选择使用框架而不是原生"><a href="#为什么选择使用框架而不是原生" class="headerlink" title="为什么选择使用框架而不是原生?"></a>为什么选择使用框架而不是原生?</h2><p>框架的好处:</p><ol><li><strong>组件化</strong>: 其中以 React 的组件化最为彻底,甚至可以到<strong>函数级</strong>别的原子组件,高度的组件化可以是我们的工程<strong>易于维护、易于组合拓展</strong>。</li><li><strong>天然分层</strong>: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。</li><li><strong>生态</strong>: 现在主流前端框架都<strong>自带生态</strong>,不管是<strong>数据流管理架构</strong>还是 <strong>UI 库</strong>都有成熟的解决方案。</li><li><strong>开发效率</strong>: 现代前端框架都默认<strong>自动更新DOM</strong>,而非我们手动操作,解放了开发者的手动DOM成本,提高开发效率,从根本上解决了UI 与状态同步问题。</li></ol><p>常见框架：<strong>Angular React Vue Svelte</strong></p><h2 id="React-vs-Vue"><a href="#React-vs-Vue" class="headerlink" title="React vs Vue"></a>React vs Vue</h2><p>React 与 Vue 存在很多共同点，例如他们都是 JavaScript 的 <strong>UI 框架</strong>，专注于创造前端的富应用。</p><p>不同于早期的 JavaScript 框架“功能齐全”，Reat 与 Vue 只有<strong>框架的骨架</strong>，其他的功能如<strong>路由、状态管理</strong>等是框架分离的组件。</p><ul><li><p>React组件倾向于使用<code>jsx</code>语法，all in js，<strong>将html与css全都融入javaScript</strong>，jsx语法相对来说更加灵活。</p></li><li><p>vue仍然是拥抱经典的**html(结构)+css(表现)+js(行为)**的形式，vue鼓励开发者使用<code>template</code>模板，并提供指令供开发者使用如v-if、v-show、v-for等指令，因此在开发vue应用的时候会有一种在写经典web应用（结构、表现、行为分离）的感觉。</p></li><li><p>React 整体是<strong>函数式</strong>的思想，在 React 中是<strong>单向数据流</strong>，推崇结合 immutable 来实现<strong>数据不可变</strong>。</p></li><li><p>而 Vue 的思想是<strong>响应式</strong>的，也就是基于是<strong>数据可变</strong>的，通过对每一个属性建立 <strong>Watcher</strong> 来监听，当属性变化的时候，响应式的更新对应的虚拟 DOM。</p></li><li><p>如上，所以 React 的性能优化需要手动去做。</p></li></ul><p><strong>React优势</strong></p><ul><li><strong>灵活的结构和可扩展性</strong>。</li><li><strong>丰富的JavaScript库</strong>。</li><li>发展： React得到了<code>Facebook</code>专业开发人员的支持，他们不断寻找改进方法。</li><li>Web或移动平台： React提供<code>React Native</code>平台，可通过相同的React组件模型为<code>iOS</code>和<code>Android</code>开发本机呈现的应用程序。</li></ul><p><code>react</code>在中后台项目中由于在<strong>处理复杂的业务逻辑或组件的复用问题</strong>比<code>vue</code>优雅而被人认可，但这种优雅是要有成本代价的，它更需要团队技术整体比较给力，领头大佬的设计与把关能力要更优秀，因此开发成本更大。</p><p><code>vue</code><strong>更友好更易上手</strong>的写法著称，渐进式的框架、更友好的api、更亲民的设计让开发成本大大下降而效率大大提升。</p><p><code>vue</code>与<code>react</code>在发展长河中越发成熟，深思熟虑后觉得<strong>两者不管在移动端或大型中后台都是非常可行的</strong>，其实框架本无好坏之分，我们更应该思考的是团队想要用什么技术栈、自己喜欢与擅长什么技术栈。</p><h2 id="什么是JSX？"><a href="#什么是JSX？" class="headerlink" title="什么是JSX？"></a>什么是JSX？</h2><p>JSX 是<strong>JavaScript XML</strong> 的简写。是 React 使用的一种文件，它利用 JavaScript 的表现力和类似 HTML 的模板语法。这使得 HTML 文件非常容易理解。此文件能使应用非常可靠，并能够提高其性能。</p><p>浏览器只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX。所以为了使浏览器能够读取 JSX，首先，需要用像 <strong>Babel</strong> 这样的 JSX 转换器将 JSX 文件转换为 JavaScript 对象，然后再将其传给浏览器。</p><p>React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。</p><p>React 并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式，而是通过<strong>将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离</strong>。</p><p><strong>React不强制要求使用 JSX</strong>，但是大多数人发现，<strong>在 JavaScript 代码中将 JSX 和 UI 放在一起时，会在视觉上有辅助作用</strong>。它还可以使 React <strong>显示更多有用的错误和警告消息</strong>。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li><p>在<strong>属性</strong>中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用<strong>引号（对于字符串值）</strong>或<strong>大括号（对于表达式）</strong>中的一个，对于同一属性<strong>不能同时使用这两种符号</strong>。</p></li><li><p>标签中混入<strong>JS表达式</strong>时要用<code>&#123;&#125;</code></p></li><li><p>样式的类名指定不要用<code>class</code>,要用<code>className</code></p></li><li><p>内联样式,要用<code>style=&#123;&#123;key:value&#125;&#125;</code>的形式(<code>双&#123;&#125;代表对象,单&#123;&#125;代表表达式</code>)去写</p></li><li><p>只有一个<strong>根标签</strong>(整个虚拟DOM在外层有且仅有一个容器包裹)</p></li><li><p>标签必须<strong>闭合</strong></p></li></ul><p>在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。</p><p>也就是说，你可以在 <code>if</code> 语句和 <code>for</code> 循环的代码块中使用 JSX，将 JSX 赋值给变量，把 JSX 当作参数传入，以及从函数中返回 JSX。</p><p>因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 <code>camelCase</code>（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。</p><p>React DOM 在渲染所有输入内容之前，默认会进行<strong>转义</strong>。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 <strong>XSS（cross-site-scripting, 跨站脚本）</strong>攻击。</p><p>实际上，JSX 仅仅只是 <code>React.createElement(component, props, ...children)</code> 函数的语法糖。如下 JSX 代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyButton color=<span class="string">&quot;blue&quot;</span> shadowSize=&#123;<span class="number">2</span>&#125;&gt;</span><br><span class="line">  Click Me</span><br><span class="line">&lt;/MyButton&gt;</span><br></pre></td></tr></table></figure><p>会编译为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  MyButton,</span><br><span class="line">  &#123;<span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>, <span class="attr">shadowSize</span>: <span class="number">2</span>&#125;,</span><br><span class="line">  <span class="string">&#x27;Click Me&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果没有子节点，你还可以使用自闭合的标签形式，如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;sidebar&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>会编译为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">&#x27;sidebar&#x27;</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><blockquote><p>干前端的都知道DOM操作是性能杀手，因为操作DOM会引起页面的回流或者重绘。相比起来，通过多一些预先计算来减少DOM的操作要划算的多。</p><p>但是，“使用虚拟DOM会更快”这句话并不一定适用于所有场景。例如：一个页面就有一个按钮，点击一下，数字加一，那肯定是直接操作DOM更快。使用虚拟DOM无非白白增加了计算量和代码量。即使是复杂情况，浏览器也会对我们的DOM操作进行优化，大部分浏览器会根据我们操作的时间和次数进行批量处理，所以直接操作DOM也未必很慢。</p><p>那么为什么现在的框架都使用虚拟DOM呢？因为使用虚拟DOM可以提高代码的性能下限，并极大的优化大量操作DOM时产生的性能损耗。同时这些框架也保证了，即使在少数虚拟DOM不太给力的场景下，性能也在我们接受的范围内。</p></blockquote><p>Virtual DOM 是一种编程概念。在这个概念里， UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫做<strong>协调</strong>。</p><p>这种方式赋予了 React 声明式的 API：您告诉 React 希望让 UI 是什么状态，React 就确保 DOM 匹配该状态。这使您可以从属性操作、事件处理和手动 DOM 更新这些在构建应用程序时必要的操作中解放出来。</p><p>与其将 “Virtual DOM” 视为一种技术，不如说它是一种模式，人们提到它时经常是要表达不同的东西。在 React 的世界里，术语 “Virtual DOM” 通常与 React 元素关联在一起，因为它们都是代表了用户界面的对象。而 React 也使用一个名为 “fibers” 的内部对象来存放组件树的附加信息。上述二者也被认为是 React 中 “Virtual DOM” 实现的一部分。</p><h3 id="虚拟DOM实现原理"><a href="#虚拟DOM实现原理" class="headerlink" title="虚拟DOM实现原理?"></a>虚拟DOM实现原理?</h3><p>Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。</p><ul><li>每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。</li><li>然后计算之前 DOM 表示与新表示的之间的差异。</li><li>完成计算后，将只用实际更改的内容更新 real DOM。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myId = <span class="string">&#x27;aTgUiGu&#x27;</span></span><br><span class="line"><span class="keyword">const</span> myData = <span class="string">&#x27;HeLlo,rEaCt&#x27;</span></span><br><span class="line"><span class="comment">//1.创建虚拟DOM</span></span><br><span class="line"><span class="keyword">const</span> VDOM = (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span> <span class="attr">id</span>=<span class="string">&#123;myId.toLowerCase()&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span>&#x27;<span class="attr">white</span>&#x27;,<span class="attr">fontSize:</span>&#x27;<span class="attr">29px</span>&#x27;&#125;&#125;&gt;</span>&#123;myData.toLowerCase()&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span> <span class="attr">id</span>=<span class="string">&#123;myId.toUpperCase()&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span>&#x27;<span class="attr">white</span>&#x27;,<span class="attr">fontSize:</span>&#x27;<span class="attr">29px</span>&#x27;&#125;&#125;&gt;</span>&#123;myData.toLowerCase()&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//2.渲染虚拟DOM到页面</span></span><br><span class="line">ReactDOM.render(VDOM,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="什么是-“React-Fiber”？"><a href="#什么是-“React-Fiber”？" class="headerlink" title="什么是 “React Fiber”？"></a>什么是 “React Fiber”？</h3><p>Fiber 是 React 16 中新的协调引擎。它的主要目的是使 Virtual DOM 可以进行<strong>增量式渲染</strong>。</p><p><strong>协程和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制</strong>。</p><p>React Fiber 的思想和协程的概念是契合的: <strong>React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染</strong>。</p><h2 id="diff-算法-协调"><a href="#diff-算法-协调" class="headerlink" title="diff 算法/协调"></a>diff 算法/协调</h2><p>在某一时间节点调用 React 的 <code>render()</code> 方法，会创建一棵由 React 元素组成的树。在下一次 <code>state</code> 或 <code>props</code> 更新时，相同的 <code>render()</code> 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何高效的更新 UI，以保证当前 UI 与最新的树保持同步。</p><p>此算法有一些通用的解决方案，即<strong>生成将一棵树转换成另一棵树的最小操作次数</strong>。然而，即使使用最优的算法，该算法的复杂程度仍为 <code>O(n^3 )</code>，其中 n 是树中元素的数量。</p><p>如果在 React 中使用该算法，那么展示 1000 个元素则需要 10 亿次的比较。这个开销实在是太过高昂。于是 React 在以下两个假设的基础之上提出了一套 <code>O(n)</code> 的启发式算法：</p><ol><li><strong>两个不同类型的元素会产生出不同的树</strong>；</li><li>开发者可以通过设置 <code>key</code> 属性，来告知<strong>渲染哪些子元素在不同的渲染下可以保存不变</strong>；</li></ol><p>在实践中，我们发现以上假设在几乎所有实用的场景下都成立。</p><h3 id="Diffing-算法"><a href="#Diffing-算法" class="headerlink" title="Diffing 算法"></a>Diffing 算法</h3><p>当对比两棵树时，React 首先比较两棵树的根节点。不同类型的根节点元素会有不同的形态。</p><h4 id="对比不同类型的元素"><a href="#对比不同类型的元素" class="headerlink" title="对比不同类型的元素"></a>对比不同类型的元素</h4><p><strong>当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树。</strong>举个例子，当一个元素从 <code>&lt;a&gt;</code> 变成 <code>&lt;img&gt;</code>，从 <code>&lt;Article&gt;</code> 变成 <code>&lt;Comment&gt;</code>，或从 <code>&lt;Button&gt;</code> 变成 <code>&lt;div&gt;</code> 都会触发一个完整的重建流程。</p><p>当卸载一棵树时，对应的 DOM 节点也会被销毁。组件实例将执行 <code>componentWillUnmount()</code> 方法。当建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中。组件实例将执行 <code>UNSAFE_componentWillMount()</code> 方法，紧接着 <code>componentDidMount()</code> 方法。所有与之前的树相关联的 state 也会被销毁。</p><p>在根节点以下的组件也会被卸载，它们的状态会被销毁。比如，当比对以下更变时：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>React 会销毁 <code>Counter</code> 组件并且重新装载一个新的组件。</p><blockquote><p>注意：</p><p>这些方法被认为是过时的，在新的代码中应该避免使用它们：</p><ul><li><code>UNSAFE_componentWillMount()</code></li></ul></blockquote><h4 id="对比同一类型的元素"><a href="#对比同一类型的元素" class="headerlink" title="对比同一类型的元素"></a>对比同一类型的元素</h4><p><strong>当对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。</strong>比如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;before&quot;</span> title=<span class="string">&quot;stuff&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;after&quot;</span> <span class="attr">title</span>=<span class="string">&quot;stuff&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>通过对比这两个元素，React 知道只需要修改 DOM 元素上的 <code>className</code> 属性。</p><p>当更新 <code>style</code> 属性时，React 仅更新有所更变的属性。比如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&#123;&#123;<span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="attr">fontWeight</span>: <span class="string">&#x27;bold&#x27;</span>&#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span> &#x27;<span class="attr">green</span>&#x27;, <span class="attr">fontWeight:</span> &#x27;<span class="attr">bold</span>&#x27;&#125;&#125; /&gt;</span></span></span><br></pre></td></tr></table></figure><p>通过对比这两个元素，React 知道只需要修改 DOM 元素上的 <code>color</code> 样式，无需修改 <code>fontWeight</code>。</p><p>在处理完当前节点之后，React 继续对子节点进行递归。</p><h4 id="对比同类型的组件元素"><a href="#对比同类型的组件元素" class="headerlink" title="对比同类型的组件元素"></a>对比同类型的组件元素</h4><p>当一个组件更新时，组件实例会保持不变，因此可以在不同的渲染时保持 state 一致。React 将更新该组件实例的 props 以保证与最新的元素保持一致，并且调用该实例的 <code>UNSAFE_componentWillReceiveProps()</code>、<code>UNSAFE_componentWillUpdate()</code> 以及 <code>componentDidUpdate()</code> 方法。</p><p>下一步，调用 <code>render()</code> 方法，diff 算法将在之前的结果以及新的结果中进行递归。</p><blockquote><p>注意：</p><p>这些方法已过时，在新代码中应避免使用它们：</p><ul><li><code>UNSAFE_componentWillUpdate()</code></li><li><code>UNSAFE_componentWillReceiveProps()</code></li></ul></blockquote><h4 id="对子节点进行递归"><a href="#对子节点进行递归" class="headerlink" title="对子节点进行递归"></a>对子节点进行递归</h4><p>默认情况下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。</p><p>在子元素列表末尾新增元素时，更新开销比较小。比如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>third<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>React 会先匹配两个 <code>&lt;li&gt;first&lt;/li&gt;</code> 对应的树，然后匹配第二个元素 <code>&lt;li&gt;second&lt;/li&gt;</code> 对应的树，最后插入第三个元素的 <code>&lt;li&gt;third&lt;/li&gt;</code> 树。</p><p>如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Connecticut<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>React 并不会意识到应该保留 <code>&lt;li&gt;Duke&lt;/li&gt;</code> 和 <code>&lt;li&gt;Villanova&lt;/li&gt;</code>，而是会重建每一个子元素。这种情况会带来性能问题。</p><h4 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h4><p>为了解决上述问题，React 引入了 <code>key</code> 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。</p><p><strong>虚拟DOM中key的作用：</strong></p><ul><li><p>简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。</p></li><li><p>详细的说: 当状态中的数据发生变化时，react会根据<strong>新数据</strong>生成<strong>新的虚拟DOM,</strong> 随后React进行<strong>新虚拟DOM</strong>与<strong>旧虚拟DOM</strong>的diff比较，比较规则如下：</p><ul><li><p>旧虚拟DOM中找到了与新虚拟DOM相同的key：</p><ul><li>若虚拟DOM中内容没变, 直接使用之前的真实DOM</li><li>若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM</li></ul></li><li><p>旧虚拟DOM中未找到与新虚拟DOM相同的key</p><ul><li>根据数据创建新的真实DOM，随后渲染到到页面</li></ul></li></ul></li></ul><p><strong>用index作为key可能会引发的问题：</strong></p><ul><li><p>若对数据进行：<strong>逆序添加、逆序删除</strong>等破坏顺序操作：会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但<strong>效率低</strong>。</p></li><li><p>如果结构中还包含<strong>输入类的DOM</strong>：会产生错误DOM更新 ==&gt; <strong>界面有问题</strong>。</p></li><li><p>注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</p></li></ul><p><strong>开发中如何选择key?:</strong></p><ul><li><p><strong>最好使用每条数据的唯一标识作为key</strong>, 比如id、手机号、身份证号、学号等唯一值。</p></li><li><p><strong>如果确定只是简单的展示数据，用index也是可以的</strong>。</p></li></ul><h2 id="两种组件定义区别"><a href="#两种组件定义区别" class="headerlink" title="两种组件定义区别"></a>两种组件定义区别</h2><p><strong>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</strong></p><p>在不违反上述规则的情况下，state 允许 React 组件随用户操作、网络响应或者其他变化而动态更改输出内容。</p><h3 id="函数式声明组件"><a href="#函数式声明组件" class="headerlink" title="函数式声明组件"></a>函数式声明组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1.创建函数式组件</span><br><span class="line">function MyComponent()&#123;</span><br><span class="line">    console.log(this); //此处的this是undefined，因为babel编译后开启了严格模式</span><br><span class="line">    return &lt;h2&gt;我是用函数定义的组件(适用于【简单组件】的定义)&lt;/h2&gt;</span><br><span class="line">&#125;</span><br><span class="line">//2.渲染组件到页面</span><br><span class="line">ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#x27;test&#x27;))</span><br></pre></td></tr></table></figure><p>执行了<code>ReactDOM.render(&lt;MyComponent/&gt;.......)</code>之后，发生了什么？</p><ul><li>React解析组件标签，找到了MyComponent组件。</li><li>发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。</li></ul><h3 id="类式组件-有状态-state"><a href="#类式组件-有状态-state" class="headerlink" title="类式组件(有状态 state)"></a>类式组件(有状态 state)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//1.创建类式组件</span><br><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        //render是放在哪里的？—— MyComponent的原型对象上，供实例使用。</span><br><span class="line">        //render中的this是谁？—— MyComponent的实例对象 &lt;=&gt; MyComponent组件实例对象。</span><br><span class="line">        console.log(&#x27;render中的this:&#x27;,this);</span><br><span class="line">        return &lt;h2&gt;我是用类定义的组件&lt;/h2&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//2.渲染组件到页面</span><br><span class="line">ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#x27;test&#x27;))</span><br></pre></td></tr></table></figure><p>执行了<code>ReactDOM.render(&lt;MyComponent/&gt;.......)</code>之后，发生了什么？</p><ul><li><p>React解析组件标签，找到了MyComponent组件。</p></li><li><p>发现组件是使用类定义的，随后<strong>new出来该类的实例</strong>，并<strong>通过该实例调用到原型上的render方法</strong>。</p></li><li><p>将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。</p></li></ul><blockquote><p>类的方法默认开启了局部严格模式</p></blockquote><p>组件中的<strong>render方法中的this为组件实例对象</strong></p><p>但组件自定义方法中this为<code>undefined</code>,如何解决?</p><p>a) 强制绑定this:通过函数对象的<code>bind()</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造器调用几次？ ———— 1次</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;constructor&#x27;</span>);</span><br><span class="line">        <span class="built_in">super</span>(props)</span><br><span class="line">        <span class="comment">//初始化状态</span></span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">isHot</span>:<span class="literal">false</span>,<span class="attr">wind</span>:<span class="string">&#x27;微风&#x27;</span>&#125;</span><br><span class="line">        <span class="comment">//解决changeWeather中this指向问题,也可以在调用处直接使用</span></span><br><span class="line">        <span class="built_in">this</span>.changeWeather = <span class="built_in">this</span>.changeWeather.bind(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//render调用几次？ ———— 1+n次 1是初始化的那次 n是状态更新的次数</span></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;render&#x27;</span>);</span><br><span class="line">        <span class="comment">//读取状态</span></span><br><span class="line">        <span class="keyword">const</span> &#123;isHot,wind&#125; = <span class="built_in">this</span>.state</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span>今天天气很&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;，&#123;wind&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//changeWeather调用几次？ ———— 点几次调几次</span></span><br><span class="line">    <span class="function"><span class="title">changeWeather</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//changeWeather放在哪里？ ———— Weather的原型对象上，供实例使用</span></span><br><span class="line">        <span class="comment">//由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用</span></span><br><span class="line">        <span class="comment">//类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;changeWeather&#x27;</span>);</span><br><span class="line">        <span class="comment">//获取原来的isHot值</span></span><br><span class="line">        <span class="keyword">const</span> isHot = <span class="built_in">this</span>.state.isHot</span><br><span class="line">        <span class="comment">//严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换。</span></span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">isHot</span>:!isHot&#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！</span></span><br><span class="line">        <span class="comment">//this.state.isHot = !isHot //这是错误的写法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.渲染组件到页面</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Weather</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>))</span><br></pre></td></tr></table></figure><p>b) 箭头函数<code>推荐</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">	<span class="comment">//初始化状态</span></span><br><span class="line">   <span class="comment">//类中可以直接写赋值语句,如下代码的含义是：给Weather的实例对象添加一个属性 state</span></span><br><span class="line">	state = &#123;<span class="attr">isHot</span>:<span class="literal">false</span>,<span class="attr">wind</span>:<span class="string">&#x27;微风&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> &#123;isHot,wind&#125; = <span class="built_in">this</span>.state</span><br><span class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span>今天天气很&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;，&#123;wind&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自定义方法————要用赋值语句的形式+箭头函数</span></span><br><span class="line">	changeWeather = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> isHot = <span class="built_in">this</span>.state.isHot</span><br><span class="line">		<span class="built_in">this</span>.setState(&#123;<span class="attr">isHot</span>:!isHot&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.渲染组件到页面</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Weather</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul><li>通过<code>onXxx</code>属性指定事件处理函数(注意大小写)<ul><li>React使用的是<strong>自定义(合成)事件,而不是使用的原生DOM事件</strong>—-为了更好的<strong>兼容性</strong></li><li>React中的事件是通过<strong>事件委托</strong>的方式处理的(委托给组件最外层的元素)—-为了更<strong>高效</strong></li></ul></li><li>通过<code>event.target</code>得到发生事件的DOM元素对象 —–<strong>不要过度使用ref</strong></li></ul><ul><li>React的所有事件都挂载在<code>document</code>中，当真实dom触发后冒泡到document后才会对react事件进行处理</li><li><strong>所以原生的事件会先执行，然后执行react合成事件，最后执行真正在document上挂载的事件</strong>。</li></ul><h2 id="正确地使用-State"><a href="#正确地使用-State" class="headerlink" title="正确地使用 State"></a>正确地使用 State</h2><p>关于 <code>setState()</code> 你应该了解三件事：</p><h3 id="不要直接修改-State"><a href="#不要直接修改-State" class="headerlink" title="不要直接修改 State"></a>不要直接修改 State</h3><p>例如，此代码不会重新渲染组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="built_in">this</span>.state.comment = <span class="string">&#x27;Hello&#x27;</span>;</span><br></pre></td></tr></table></figure><p>而是应该使用 <code>setState()</code>:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;<span class="attr">comment</span>: <span class="string">&#x27;Hello&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><p>构造函数是唯一可以给 <code>this.state</code> 赋值的地方。</p><h3 id="State-的更新可能是异步的"><a href="#State-的更新可能是异步的" class="headerlink" title="State 的更新可能是异步的"></a>State 的更新可能是异步的</h3><p>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用。</p><p>因为 <code>this.props</code> 和 <code>this.state</code> 可能会<strong>异步更新</strong>，所以你<strong>不要依赖他们的值来更新下一个状态</strong>。</p><p>例如，此代码可能会无法更新计数器：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="built_in">this</span>.state.counter + <span class="built_in">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要解决这个问题，可以让 <code>setState()</code> 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">counter</span>: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>上面使用了箭头函数，不过使用普通的函数也同样可以：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function"><span class="keyword">function</span>(<span class="params">state, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">counter</span>: state.counter + props.increment</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>setState更新状态的2种写法</strong></p><ul><li><p><code>setState(stateChange, [callback])</code>——对象式的setState</p><ul><li>stateChange为<strong>状态改变对象</strong>(该对象可以体现出状态的更改)</li><li>callback是可选的回调函数, 它在状态更新完毕（状态更新是异步的）、界面也更新后(render调用后)才被调用</li></ul></li><li><p><code>setState(updater, [callback])</code>——函数式的setState</p><ul><li>updater为<strong>返回stateChange对象的函数</strong>。</li><li>updater可以接收到state和props。</li><li>callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。</li></ul></li></ul><p>总结:</p><ul><li>对象式的setState是函数式的setState的简写方式(<code>语法糖</code>)</li><li>使用原则：<ul><li>如果<strong>新状态不依赖于原状态</strong> =&gt; 使用<strong>对象</strong>方式</li><li>如果<strong>新状态依赖于原状态</strong> =&gt; 使用<strong>函数</strong>方式</li><li>如果<strong>需要在setState()执行后获取最新的状态数据, 要在第二个callback函数中读取</strong></li></ul></li></ul><h3 id="State-的更新会被合并"><a href="#State-的更新会被合并" class="headerlink" title="State 的更新会被合并"></a>State 的更新会被合并</h3><p>当你调用 <code>setState()</code> 的时候，React 会把你提供的对象合并到当前的 state。</p><p>例如，你的 state 包含几个独立的变量：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        <span class="attr">posts</span>: [],      </span><br><span class="line">        <span class="attr">comments</span>: []    </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以分别调用 <code>setState()</code> 来单独地更新它们：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    fetchPosts().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            <span class="attr">posts</span>: response.posts      </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    fetchComments().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            <span class="attr">comments</span>: response.comments      </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的合并是<strong>浅合并</strong>，所以 <code>this.setState(&#123;comments&#125;)</code> 完整保留了 <code>this.state.posts</code>， 但是完全替换了 <code>this.state.comments</code>。</p><h2 id="React-Refs-and-the-DOM揭秘"><a href="#React-Refs-and-the-DOM揭秘" class="headerlink" title="React Refs and the DOM揭秘"></a>React Refs and the DOM揭秘</h2><h3 id="什么是Ref"><a href="#什么是Ref" class="headerlink" title="什么是Ref"></a>什么是Ref</h3><p>在典型的React数据流理念中，父组件跟子组件的交互都是通过传递属性(properties)实现的。如果父组件需要修改子组件，只需要将新的属性传递给子组件，由子组件来实现具体的绘制逻辑。</p><p>在特殊的情况下，如果你需要<strong>命令式(imperatively)的修改子组件</strong>，React也提供了应急的处理办法–Ref。</p><p>Ref 既支持修改<strong>DOM元素</strong>，也支持修改<strong>自定义的组件</strong>。</p><h3 id="什么是声明式编程-Declarative-Programming"><a href="#什么是声明式编程-Declarative-Programming" class="headerlink" title="什么是声明式编程(Declarative Programming)"></a>什么是声明式编程(Declarative Programming)</h3><p>声明式编程的特点是<strong>只描述要实现的结果</strong>，而不关心如何一步一步实现的，而命令式编程则相反，必须<strong>每个步骤都写清楚</strong>。</p><p>我们可以根据语义直观的理解代码的功能是：针对数组的每一个元素，将它的值打印出来。不必关心实现其的细节。</p><p>而命令式编程必须将每行代码读懂，然后再整合起来理解总体实现的功能。</p><p>React有2个基石设计理念：一个是声明式编程，一个是函数式编程。</p><p>声明式编程的特点体现在2方面：</p><ul><li>组件定义的时候，<strong>所有的实现逻辑都封装在组件的内部，通过state管理，对外只暴露属性</strong>。</li><li>组件使用的时候，组件调用者通<strong>过传入不同属性的值来达到展现不同内容的效果</strong>。一切效果都是事先定义好的，至于效果是怎么实现的，组件调用者不需要关心。</li></ul><p>因此，在使用React的时候，<strong>一般很少需要用到Ref</strong>。那么，Ref的使用场景又是什么？</p><h3 id="Ref使用场景"><a href="#Ref使用场景" class="headerlink" title="Ref使用场景"></a>Ref使用场景</h3><p>简单理解就是，<strong>控制一些DOM原生的效果，如输入框的聚焦效果和选中效果等；触发一些命令式的动画；集成第三方的DOM库</strong>。最后还补了一句：如果要实现的功能可以通过声明式的方式实现，就不要借助Ref。</p><p>refs是React组件中非常特殊的props， 可以附加到任何一个组件上，从字面意思上看，<strong>ref即reference，组件被调用时会创建一个该组件的实例，而ref就会指向这个实例</strong>。</p><h3 id="Ref用法"><a href="#Ref用法" class="headerlink" title="Ref用法"></a>Ref用法</h3><blockquote><p>如果<strong>作用在原生的DOM元素上，通过Ref获取的是DOM元素，可以直接操作DOM的API</strong>。</p><p>如果<strong>作用在自定义组件，Ref获取的是组件的实例，可以直接操作组件内的任意方法</strong>。</p></blockquote><h4 id="创建-Refs"><a href="#创建-Refs" class="headerlink" title="创建 Refs"></a>创建 Refs</h4><p>Refs 是使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素。</p><p>在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.myRef = React.createRef();  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span>;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问-Refs"><a href="#访问-Refs" class="headerlink" title="访问 Refs"></a>访问 Refs</h4><p>当 ref 被传递给 <code>render</code> 中的元素时，对该节点的引用可以在 ref 的 <code>current</code> 属性中被访问。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="built_in">this</span>.myRef.current;</span><br></pre></td></tr></table></figure><p>ref 的值根据节点的类型而有所不同：</p><ul><li>当 <code>ref</code> 属性用于 <strong>HTML 元素</strong>时，构造函数中使用 <code>React.createRef()</code> 创建的 <code>ref</code> 接收底层 DOM 元素作为其 <code>current</code> 属性。</li><li>当 <code>ref</code> 属性用于<strong>自定义 class 组件</strong>时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性。</li><li><strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为他们<strong>没有实例</strong>。</li></ul><h5 id="为-DOM-元素添加-ref"><a href="#为-DOM-元素添加-ref" class="headerlink" title="为 DOM 元素添加 ref"></a>为 DOM 元素添加 ref</h5><p>以下代码使用 <code>ref</code> 去存储 DOM 节点的引用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="comment">// 创建一个 ref 来存储 textInput 的 DOM 元素</span></span><br><span class="line">        <span class="built_in">this</span>.textInput = React.createRef();    </span><br><span class="line">        <span class="built_in">this</span>.focusTextInput = <span class="built_in">this</span>.focusTextInput.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">focusTextInput</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 直接使用原生 API 使 text 输入框获得焦点</span></span><br><span class="line">        <span class="comment">// 注意：我们通过 &quot;current&quot; 来访问 DOM 节点</span></span><br><span class="line">        <span class="built_in">this</span>.textInput.current.focus();  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 告诉 React 我们想把 &lt;input&gt; ref 关联到</span></span><br><span class="line">        <span class="comment">// 构造器里创建的 `textInput` 上</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">ref</span>=<span class="string">&#123;this.textInput&#125;</span> /&gt;</span>        </span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">value</span>=<span class="string">&quot;Focus the text input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">onClick</span>=<span class="string">&#123;this.focusTextInput&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 会在组件挂载时给 <code>current</code> 属性传入 DOM 元素，并在组件卸载时传入 <code>null</code> 值。</p><p><code>ref</code> 会在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 生命周期钩子触发前更新。</p><h5 id="为-class-组件添加-Ref"><a href="#为-class-组件添加-Ref" class="headerlink" title="为 class 组件添加 Ref"></a>为 class 组件添加 Ref</h5><p>如果我们想包装上面的 <code>CustomTextInput</code>，来模拟它挂载之后立即被点击的操作，我们可以使用 ref 来获取这个自定义的 input 组件并手动调用它的 <code>focusTextInput</code> 方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoFocusTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.textInput = React.createRef();  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.textInput.current.focusTextInput();  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">CustomTextInput</span> <span class="attr">ref</span>=<span class="string">&#123;this.textInput&#125;</span> /&gt;</span></span>    </span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，这仅在 <code>CustomTextInput</code> 声明为 class 时才有效：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Refs-与函数组件"><a href="#Refs-与函数组件" class="headerlink" title="Refs 与函数组件"></a>Refs 与函数组件</h5><p>默认情况下，<strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为它们没有实例。</p><p>如果要在函数组件中使用 <code>ref</code>，你可以使用 <code>forwardRef</code>（可与 <code>useImperativeHandle</code>结合使用），或者可以将该组件转化为 class 组件。</p><p>不管怎样，你可以<strong>在函数组件内部使用 <code>ref</code> 属性</strong>，只要它<strong>指向一个 DOM 元素或 class 组件</strong>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里必须声明 textInput，这样 ref 才可以引用它  </span></span><br><span class="line">    <span class="keyword">const</span> textInput = useRef(<span class="literal">null</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        textInput.current.focus();  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">ref</span>=<span class="string">&#123;textInput&#125;</span> /&gt;</span>      </span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">value</span>=<span class="string">&quot;Focus the text input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Refs-转发"><a href="#Refs-转发" class="headerlink" title="Refs 转发"></a>Refs 转发</h3><p>Ref 转发是一项将<code>ref</code>自动地通过组件传递到其一子组件的技巧。</p><p>对于大多数应用中的组件来说，这通常不是必需的。但其对某些组件，尤其是可重用的组件库是很有用的。</p><p><strong>Ref 转发是一个可选特性，其允许某些组件接收 <code>ref</code>，并将其向下传递（换句话说，“转发”它）给子组件。</strong></p><p><code>React.forwardRef(render)</code>的返回值是<code>react</code>组件，接收的参数是一个 <code>render</code>函数，函数签名为<code>render(props, ref)</code>，第二个参数将其接受的ref属性<strong>转发</strong>到<code>render</code>返回的组件中。</p><p>这项技术并不常见，但在以下两种场景中特别有用:</p><ul><li>转发 <code>ref</code>到组件内部的<code>DOM</code>节点上</li><li>在高阶组件中转发<code>ref</code></li></ul><h2 id="React组件通信如何实现"><a href="#React组件通信如何实现" class="headerlink" title="React组件通信如何实现?"></a>React组件通信如何实现?</h2><blockquote><p>由于<code>React</code>是单向数据流，主要思想是组件不会改变接收的数据，只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值。因此，可以看到通信过程中，数据的存储位置都是存放在上级位置中。</p></blockquote><p>React组件间通信方式:</p><ul><li><strong>父组件</strong>向<strong>子组件</strong>通讯: 父组件可以向子组件通过传 <strong>props</strong> 的方式，向子组件进行通讯</li><li><strong>子组件</strong>向<strong>父组件</strong>通讯: <strong>props+回调</strong>的方式,父组件向子组件传递props进行通讯，此props为<strong>作用域为父组件自身的函数</strong>，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中</li><li>兄弟组件通信: <strong>找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信息进行通信</strong></li><li>跨层级通信: <code>Context</code>设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言,对于<strong>跨越多层的全局数据</strong>通过<code>Context</code>通信再适合不过</li><li>发布订阅模式: <strong>发布者发布事件，订阅者监听事件并做出反应</strong>,我们可以通过引入event模块进行通信</li><li>全局状态管理工具: 借助<code>Redux</code>或者<code>Mobx</code>等全局状态管理工具进行通信,这种工具会<strong>维护一个全局状态中心Store,并根据不同的事件产生新的状态</strong></li></ul><p>比较好的搭配方式</p><ul><li>父子组件：props</li><li>兄弟组件：消息订阅-发布、集中式管理</li><li>祖孙组件(跨级组件)：消息订阅-发布、集中式管理、Context(开发用的少，封装插件用的多)</li></ul><h2 id="你真的了解-React-生命周期吗？"><a href="#你真的了解-React-生命周期吗？" class="headerlink" title="你真的了解 React 生命周期吗？"></a>你真的了解 React 生命周期吗？</h2><p>React 生命周期很多人都了解，但通常我们所了解的都是 <strong>单个组件</strong> 的生命周期，但针对 <strong>Hooks 组件、多个关联组件</strong>（父子组件和兄弟组件） 的生命周期又是怎么样？</p><p>关于 <strong>组件</strong> ，我们这里指的是 <code>React.Component</code> 以及 <code>React.PureComponent</code> ，但是否包括 Hooks 组件？</p><h3 id="Hooks-组件"><a href="#Hooks-组件" class="headerlink" title="Hooks 组件"></a>Hooks 组件</h3><p><strong>函数组件</strong> 的本质是函数，没有 state 的概念的，因此<strong>不存在生命周期</strong>一说，仅仅是一个 <strong>render 函数</strong>而已。</p><p>但是引入 <strong>Hooks</strong> 之后就变得不同了，它能让组件在不使用 class 的情况下使用 state 以及其他的 React特性，相比与 class 的生命周期概念来说，它更接近于实现状态同步，而不是响应生命周期事件。但我们可以利用 <code>useState</code>、 <code>useEffect()</code> 和 <code>useLayoutEffect()</code> 来模拟实现生命周期。</p><p>即：<strong>Hooks 组件更接近于实现状态同步，而不是响应生命周期事件</strong>。</p><p>下面，是具体的 生命周期 与 Hooks 的<strong>对应关系</strong>：</p><table><thead><tr><th>class 组件</th><th>Hooks /函数式组件</th></tr></thead><tbody><tr><td>constructor</td><td>useState</td></tr><tr><td>getDerivedStateFromProps</td><td>useState 里面 update 函数</td></tr><tr><td>shouldComponentUpdate</td><td>useMemo</td></tr><tr><td>render</td><td>函数本身</td></tr><tr><td>componentDidMount</td><td>useEffect</td></tr><tr><td>componentDidUpdate</td><td>useEffect</td></tr><tr><td>componentWillUnmount</td><td>useEffect 里面返回的函数</td></tr></tbody></table><h3 id="单个组件的生命周期"><a href="#单个组件的生命周期" class="headerlink" title="单个组件的生命周期"></a>单个组件的生命周期</h3><p>常用</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="C:\Users\Lesliewaong\AppData\Roaming\Typora\typora-user-images\image-20220404152552689.png" alt="image-20220404152552689"></p><p>完整版</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="C:\Users\Lesliewaong\AppData\Roaming\Typora\typora-user-images\image-20220404152649393.png" alt="image-20220404152649393"></p><h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>当<strong>组件实例被创建并插入 DOM 中</strong>时，其生命周期调用顺序如下：</p><ul><li><strong><code>constructor()</code></strong></li><li><code>static getDerivedStateFromProps()</code></li><li><strong><code>render()</code></strong></li><li><strong><code>componentDidMount()</code></strong></li></ul><blockquote><p>注意:</p><p>下述生命周期方法即将过时，在新代码中应该避免使用它们：</p><ul><li><code>UNSAFE_componentWillMount()</code></li></ul></blockquote><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>当<strong>组件的 props 或 state 发生变化时会触发更新</strong>。组件更新的生命周期调用顺序如下：</p><ul><li><code>static getDerivedStateFromProps()</code></li><li><code>shouldComponentUpdate()</code></li><li><strong><code>render()</code></strong></li><li><code>getSnapshotBeforeUpdate()</code></li><li><strong><code>componentDidUpdate()</code></strong></li></ul><blockquote><p>注意:</p><p>下述方法即将过时，在新代码中应该避免使用它们：</p><ul><li><code>UNSAFE_componentWillUpdate()</code></li><li><code>UNSAFE_componentWillReceiveProps()</code></li></ul></blockquote><h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><p>当<strong>组件从 DOM 中移除时</strong>会调用如下方法：</p><ul><li><strong><code>componentWillUnmount()</code></strong></li></ul><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>当<strong>渲染过程，生命周期，或子组件的构造函数中抛出错误时</strong>，会调用如下方法：</p><ul><li><code>static getDerivedStateFromError()</code></li><li><code>componentDidCatch()</code></li></ul><h4 id="常用的生命周期方法"><a href="#常用的生命周期方法" class="headerlink" title="常用的生命周期方法"></a>常用的生命周期方法</h4><h5 id="render"><a href="#render" class="headerlink" title="render"></a>render</h5><p><code>render()</code> 方法是 class 组件中唯一必须实现的方法。</p><p>当 <code>render</code> 被调用时，它会检查 <code>this.props</code> 和 <code>this.state</code> 的变化并返回以下类型之一：</p><ul><li><strong>React 元素</strong>。通常通过 JSX 创建。例如，<code>&lt;div /&gt;</code> 会被 React 渲染为 <strong>DOM 节点</strong>，<code>&lt;MyComponent /&gt;</code> 会被 React 渲染为<strong>自定义组件</strong>，无论是 <code>&lt;div /&gt;</code> 还是 <code>&lt;MyComponent /&gt;</code> 均为 React 元素。</li><li><strong>数组或 fragments</strong>。 使得 render 方法可以返回多个元素。</li><li><strong>Portals</strong>。可以渲染子节点到不同的 DOM 子树中。</li><li><strong>字符串或数值类型</strong>。它们在 DOM 中会被渲染为<strong>文本节点</strong></li><li><strong>布尔类型或 <code>null</code><strong>。</strong>什么都不渲染</strong>。（主要用于支持返回 <code>test &amp;&amp; &lt;Child /&gt;</code> 的模式，其中 test 为布尔类型。)</li></ul><p><code>render()</code> 函数应该为<strong>纯函数</strong>，这意味着在<strong>不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互</strong>。</p><p>如需与浏览器进行交互，请在 <code>componentDidMount()</code> 或其他生命周期方法中执行你的操作。保持 <code>render()</code> 为纯函数，可以使组件更容易思考。</p><blockquote><p>注意</p><p>如果 <code>shouldComponentUpdate()</code> 返回 false，则不会调用 <code>render()</code>。</p></blockquote><h5 id="constructor-props"><a href="#constructor-props" class="headerlink" title="constructor(props)"></a>constructor(props)</h5><p><strong>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。</strong></p><p>在 React 组件挂载之前，会调用它的构造函数。在为 React.Component 子类实现构造函数时，应在其他语句之前调用 <code>super(props)</code>。否则，<code>this.props</code> 在构造函数中可能会出现未定义的 bug。</p><p>通常，在 React 中，构造函数仅用于以下两种情况：</p><ul><li>通过给 <code>this.state</code> 赋值对象来<strong>初始化内部 state</strong>。</li><li><strong>为事件处理函数绑定实例</strong>。</li></ul><p>在 <code>constructor()</code> 函数中<strong>不要调用 <code>setState()</code> 方法</strong>。</p><p>如果你的组件需要使用内部 state，请直接在构造函数中为 <strong><code>this.state</code> 赋值初始 state</strong>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(props);</span><br><span class="line">  <span class="comment">// 不要在这里调用 this.setState()</span></span><br><span class="line">  <span class="built_in">this</span>.state = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能在构造函数中直接为 <code>this.state</code> 赋值。如需在其他方法中赋值，你应使用 <code>this.setState()</code> 替代。</p><p>要<strong>避免在构造函数中引入任何副作用或订阅</strong>。如遇到此场景，请将对应的操作放置在 <code>componentDidMount</code> 中。</p><p><strong>注意</strong></p><p><strong>避免将 props 的值复制给 state！这是一个常见的错误：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line"> <span class="built_in">super</span>(props);</span><br><span class="line"> <span class="comment">// 不要这样做</span></span><br><span class="line"> <span class="built_in">this</span>.state = &#123; <span class="attr">color</span>: props.color &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此做毫无必要（你可以直接使用 <code>this.props.color</code>），同时还产生了 bug（更新 prop 中的 <code>color</code> 时，并不会影响 state）。</p><h5 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h5><p><code>componentDidMount()</code> 会在<strong>组件挂载后（插入 DOM 树中）立即调用</strong>。</p><p><strong>依赖于 DOM 节点的初始化</strong>应该放在这里。如需<strong>通过网络请求获取数据</strong>，此处是实例化请求的好地方。</p><p>这个方法是<strong>比较适合添加订阅</strong>的地方。如果添加了订阅，请不要忘记在 <code>componentWillUnmount()</code> 里<strong>取消订阅</strong>。</p><p>你可以在 <code>componentDidMount()</code> 里**直接调用 <code>setState()</code>**。</p><p>它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。</p><p>如此保证了即使在 <code>render()</code> 两次调用的情况下，用户也不会看到中间状态。</p><p>请谨慎使用该模式，因为它会导致性能问题。</p><p>通常，你应该在 <code>constructor()</code> 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理。</p><h5 id="componentDidUpdate-prevProps-prevState-snapshot"><a href="#componentDidUpdate-prevProps-prevState-snapshot" class="headerlink" title="componentDidUpdate(prevProps, prevState, snapshot)"></a>componentDidUpdate(prevProps, prevState, snapshot)</h5><p><code>componentDidUpdate()</code> 会在<strong>更新后会被立即调用</strong>。首次渲染不会执行此方法。</p><p>当组件更新后，可以在此处对 DOM 进行操作。</p><p>如果你<strong>对更新前后的 props 进行了比较，也可以选择在此处进行网络请求</strong>。（例如，当 props 未发生变化时，则不会执行网络请求）。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidUpdate</span>(<span class="params">prevProps</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 典型用法（不要忘记比较 props）：</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.props.userID !== prevProps.userID) &#123;</span><br><span class="line">    <span class="built_in">this</span>.fetchData(<span class="built_in">this</span>.props.userID);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以在 <code>componentDidUpdate()</code> 中<strong>直接调用 <code>setState()</code><strong>，但请注意</strong>它必须被包裹在一个条件语句里</strong>，正如上述的例子那样进行处理，否则会导致死循环。</p><p>它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。不要将 props “镜像”给 state，请考虑直接使用 props。</p><p>如果组件实现了 <code>getSnapshotBeforeUpdate()</code> 生命周期（不常用），则它的返回值将作为 <code>componentDidUpdate()</code> 的第三个参数 “snapshot” 参数传递。否则此参数将为 undefined。</p><blockquote><p>注意</p><p>如果 <code>shouldComponentUpdate()</code>返回值为 false，则不会调用 <code>componentDidUpdate()</code>。</p></blockquote><h5 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h5><p><code>componentWillUnmount()</code> 会在<strong>组件卸载及销毁之前直接调用</strong>。</p><p>在此方法中执行必要的清理操作，例如，<strong>清除 timer</strong>，<strong>取消网络请求</strong>或<strong>清除</strong>在 <code>componentDidMount()</code> 中创建的<strong>订阅</strong>等。</p><p><code>componentWillUnmount()</code> 中<strong>不应调用 <code>setState()</code><strong>，因为</strong>该组件将永远不会重新渲染</strong>。</p><p>组件实例卸载后，将永远不会再挂载它。</p><h4 id="不常用的生命周期方法"><a href="#不常用的生命周期方法" class="headerlink" title="不常用的生命周期方法"></a>不常用的生命周期方法</h4><p>本节中的生命周期方法并不太常用。它们偶尔会很方便，但是大部分情况下组件可能都不需要它们。</p><h5 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h5><p>根据 <code>shouldComponentUpdate()</code> 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。</p><p>默认行为是 <strong>state 每次发生变化组件都会重新渲染</strong>。大部分情况下，你应该遵循默认行为。</p><p><strong>当 props 或 state 发生变化时</strong>，<code>shouldComponentUpdate()</code> 会在渲染执行之前被调用。返回值默认为 true。</p><p>首次渲染或使用 <code>forceUpdate()</code> 时不会调用该方法。</p><p>此方法仅作为<strong>性能优化的方式</strong>而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。</p><p>你应该<strong>考虑使用内置的 <code>PureComponent</code> 组件</strong>，而不是手动编写 <code>shouldComponentUpdate()</code>。</p><p><code>PureComponent</code> 会<strong>对 props 和 state 进行浅层比较</strong>，并减少了跳过必要更新的可能性。</p><h5 id="static-getDerivedStateFromProps-props-state"><a href="#static-getDerivedStateFromProps-props-state" class="headerlink" title="static getDerivedStateFromProps(props, state)"></a>static getDerivedStateFromProps(props, state)</h5><p><code>getDerivedStateFromProps</code> 会在<strong>调用 render 方法之前调用</strong>，并且在<strong>初始挂载及后续更新时都会被调用</strong>。</p><p>它应<strong>返回一个对象来更新 state</strong>，如果返回 <code>null</code> 则不更新任何内容。</p><p>此方法适用于罕见的用例，即 <strong>state 的值在任何时候都取决于 props</strong>。例如，实现 <code>&lt;Transition&gt;</code> 组件可能很方便，该组件会比较当前组件与下一组件，以决定针对哪些组件进行转场动画。</p><p>派生状态会导致代码冗余，并使组件难以维护。 确保你已熟悉这些简单的替代方案：</p><ul><li>如果你需要<strong>执行副作用</strong>（例如，数据提取或动画）以响应 props 中的更改，请改用 <code>componentDidUpdate</code>。</li><li>如果只想在 <strong>prop 更改时重新计算某些数据</strong>，请使用 memoization helper 代替。</li><li>如果你想<strong>在 prop 更改时“重置”某些 state</strong>，请考虑使组件完全受控或使用 <code>key</code> 使组件完全不受控 代替。</li></ul><p>此方法无权访问组件实例。如果你需要，可以通过提取组件 props 的纯函数及 class 之外的状态，在<code>getDerivedStateFromProps()</code>和其他 class 方法之间重用代码。</p><p>请注意，不管原因是什么，都会在<strong>每次</strong>渲染前触发此方法。这与 <code>UNSAFE_componentWillReceiveProps</code> 形成对比，后者仅在父组件重新渲染时触发，而不是在内部调用 <code>setState</code> 时。</p><h5 id="getSnapshotBeforeUpdate-prevProps-prevState"><a href="#getSnapshotBeforeUpdate-prevProps-prevState" class="headerlink" title="getSnapshotBeforeUpdate(prevProps, prevState)"></a>getSnapshotBeforeUpdate(prevProps, prevState)</h5><p><code>getSnapshotBeforeUpdate()</code> 在<strong>最近一次渲染输出（提交到 DOM 节点）之前调用</strong>。</p><p>它<strong>使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）</strong>。</p><p>此生命周期方法的任何返回值将作为参数传递给 <code>componentDidUpdate()</code>。</p><p>此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。</p><p>应返回 snapshot 的值（或 <code>null</code>）。</p><h4 id="过时的生命周期方法"><a href="#过时的生命周期方法" class="headerlink" title="过时的生命周期方法"></a>过时的生命周期方法</h4><p>以下生命周期方法标记为“过时”。这些方法仍然有效，但不建议在新代码中使用它们。</p><h5 id="UNSAFE-componentWillMount"><a href="#UNSAFE-componentWillMount" class="headerlink" title="UNSAFE_componentWillMount()"></a>UNSAFE_componentWillMount()</h5><blockquote><p>注意</p><p>此生命周期之前名为 <code>componentWillMount</code>。该名称将继续使用至 React 17。</p></blockquote><p><code>UNSAFE_componentWillMount()</code> 在<strong>挂载之前被调用</strong>。</p><p>它在 <code>render()</code> 之前调用，因此在此方法中同步调用 <code>setState()</code> 不会触发额外渲染。</p><p>通常，我们建议使用 <code>constructor()</code> 来初始化 state。</p><p>避免在此方法中引入任何副作用或订阅。如遇此种情况，请改用 <code>componentDidMount()</code>。</p><p>此方法是服务端渲染唯一会调用的生命周期函数。</p><h5 id="UNSAFE-componentWillReceiveProps-nextProps"><a href="#UNSAFE-componentWillReceiveProps-nextProps" class="headerlink" title="UNSAFE_componentWillReceiveProps(nextProps)"></a>UNSAFE_componentWillReceiveProps(nextProps)</h5><blockquote><p>注意</p><p>此生命周期之前名为 <code>componentWillReceiveProps</code>。该名称将继续使用至 React 17。</p><p>使用此生命周期方法通常会出现 bug 和不一致性：</p><ul><li>如果你需要<strong>执行副作用</strong>（例如，数据提取或动画）以响应 props 中的更改，请改用 <code>componentDidUpdate</code>生命周期。</li><li>如果你使用 <code>componentWillReceiveProps</code> <strong>仅在 prop 更改时重新计算某些数据</strong>，请使用 memoization helper 代替。</li><li>如果你使用 <code>componentWillReceiveProps</code> 是为了<strong>在 prop 更改时“重置”某些 state</strong>，请考虑使组件完全受控或使用 <code>key</code> 使组件完全不受控代替。</li></ul></blockquote><p><code>UNSAFE_componentWillReceiveProps()</code> 会在<strong>已挂载的组件接收新的 props 之前被调用</strong>。</p><p>如果你需要更新状态以响应 prop 更改（例如，重置它），你可以比较 <code>this.props</code> 和 <code>nextProps</code> 并在此方法中使用 <code>this.setState()</code> 执行 state 转换。</p><p>请注意，如果父组件导致组件重新渲染，即使 props 没有更改，也会调用此方法。如果只想处理更改，请确保进行当前值与变更值的比较。</p><p>在挂载过程中，React 不会针对初始 props 调用 <code>UNSAFE_componentWillReceiveProps()</code>。组件只会在组件的 props 更新时调用此方法。调用 <code>this.setState()</code> 通常不会触发 <code>UNSAFE_componentWillReceiveProps()</code>。</p><h5 id="UNSAFE-componentWillUpdate-nextProps-nextState"><a href="#UNSAFE-componentWillUpdate-nextProps-nextState" class="headerlink" title="UNSAFE_componentWillUpdate(nextProps, nextState)"></a>UNSAFE_componentWillUpdate(nextProps, nextState)</h5><blockquote><p>注意</p><p>此生命周期之前名为 <code>componentWillUpdate</code>。该名称将继续使用至 React 17。</p></blockquote><p>当组件收到新的 props 或 state 时，会在渲染之前调用 <code>UNSAFE_componentWillUpdate()</code>。使用此作为在更新发生之前执行准备更新的机会。初始渲染不会调用此方法。</p><p>注意，你不能此方法中调用 <code>this.setState()</code>；在 <code>UNSAFE_componentWillUpdate()</code> 返回之前，你也不应该执行任何其他操作（例如，dispatch Redux 的 action）触发对 React 组件的更新</p><p>通常，此方法可以替换为 <code>componentDidUpdate()</code>。如果你在此方法中读取 DOM 信息（例如，为了保存滚动位置），则可以将此逻辑移至 <code>getSnapshotBeforeUpdate()</code> 中。</p><blockquote><p>注意</p><p>如果 <code>shouldComponentUpdate()</code> 返回 false，则不会调用 <code>UNSAFE_componentWillUpdate()</code>。</p></blockquote><h3 id="其他-API"><a href="#其他-API" class="headerlink" title="其他 API"></a>其他 API</h3><p>不同于上述生命周期方法（React 主动调用），以下方法是你可以在组件中调用的方法。</p><p>只有两个方法：<code>setState()</code> 和 <code>forceUpdate()</code>。</p><h4 id="setState-updater-callback"><a href="#setState-updater-callback" class="headerlink" title="setState(updater, [callback])"></a>setState(updater, [callback])</h4><p><code>setState()</code> 将<strong>对组件 state 的更改排入队列，并通知 React 需要使用更新后的 state 重新渲染此组件及其子组</strong>件。</p><p>这是<strong>用于更新用户界面以响应事件处理器和处理服务器数据的主要方式</strong>。</p><p>将 <code>setState()</code> 视为<strong>请求</strong>而<strong>不是立即更新组件的命令</strong>。</p><p>为了更好的感知性能，React 会<strong>延迟调用</strong>它，然后通过一次传递更新多个组件。React 并不会保证 state 的变更会立即生效。</p><h4 id="component-forceUpdate-callback"><a href="#component-forceUpdate-callback" class="headerlink" title="component.forceUpdate(callback)"></a>component.forceUpdate(callback)</h4><p>默认情况下，当组件的 state 或 props 发生变化时，组件将重新渲染。</p><p>如果 <code>render()</code> 方法依赖于其他数据，则可以调用 <code>forceUpdate()</code> 强制让组件重新渲染。</p><p>调用 <code>forceUpdate()</code> 将致使组件调用 <code>render()</code> 方法，此操作会跳过该组件的 <code>shouldComponentUpdate()</code>。</p><p>但<strong>其子组件会触发正常的生命周期方法</strong>，包括 <code>shouldComponentUpdate()</code> 方法。如果标记发生变化，React 仍将只更新 DOM。</p><p>通常你应该避免使用 <code>forceUpdate()</code>，尽量在 <code>render()</code> 中使用 <code>this.props</code> 和 <code>this.state</code>。</p><h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><blockquote><p>一系列以 <code>“use”</code> 作为开头的方法，它们提供了让你可以完全避开 <code>class式写法</code>，在函数式组件中完成生命周期、状态管理、逻辑复用等几乎全部组件开发工作的能力。</p></blockquote><p>在没有 hooks 之前，我们使用函数定义的组件中，<strong>不能使用 React 的 state、各种生命周期钩子类组件的特性</strong>。</p><p>在 React 16.8 之后，推出了新功能： Hooks，<strong>通过 hooks 我们可以再函数定义的组件中使用类组件的特性</strong>。</p><p><strong>好处:</strong></p><ul><li><strong>跨组件复用</strong>: 其实render props / <strong>HOC</strong> 也是为了复用，相比于它们，Hooks 作为官方的底层 API，最为轻量，而且改造成本小，不会影响原来的组件层次结构和传说中的<strong>嵌套地狱</strong>；</li><li>相比而言，<strong>类组件的实现更为复杂</strong><ul><li><strong>不同的生命周期会使逻辑变得分散且混乱，不易维护和管理</strong>；</li><li><strong>时刻需要关注this的指向问题</strong>；</li><li><strong>代码复用代价高</strong>，<strong>高阶组件</strong>的使用经常会使整个组件树变得臃肿；</li></ul></li><li><strong>状态与 UI 隔离</strong>: 正是由于 Hooks 的特性，状态逻辑会变成更小的粒度，并且极容易被抽象成一个<strong>自定义 Hooks</strong>，组件中的状态和 UI 变得更为清晰和隔离。</li></ul><h3 id="Hook-规则"><a href="#Hook-规则" class="headerlink" title="Hook 规则"></a>Hook 规则</h3><h4 id="只在最顶层使用-Hook"><a href="#只在最顶层使用-Hook" class="headerlink" title="只在最顶层使用 Hook"></a>只在最顶层使用 Hook</h4><p><strong>不要在循环，条件或嵌套函数中调用 Hook，</strong> 确保总是在你的 <strong>React 函数的最顶层以及任何 return 之前调用他们</strong>。</p><p>遵守这条规则，你就能<strong>确保 Hook 在每一次渲染中都按照同样的顺序被调用</strong>。</p><p>这让 React 能够在多次的 <code>useState</code> 和 <code>useEffect</code> 调用之间保持 hook 状态的正确。</p><h4 id="只在-React-函数中调用-Hook"><a href="#只在-React-函数中调用-Hook" class="headerlink" title="只在 React 函数中调用 Hook"></a>只在 React 函数中调用 Hook</h4><p><strong>不要在普通的 JavaScript 函数中调用 Hook。</strong>你可以：</p><ul><li>在 <strong>React 的函数组件</strong>中调用 Hook</li><li>在<strong>自定义 Hook</strong> 中调用其他 Hook</li></ul><p>遵循此规则，<strong>确保组件的状态逻辑在代码中清晰可见</strong>。</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>我们可以在单个组件中使用多个 <strong>State Hook</strong> 或 <strong>Effect Hook</strong>。</p><p>那么 React 怎么知道哪个 state 对应哪个 <code>useState</code>？答案是 React 靠的是 <strong>Hook 调用的顺序</strong>。</p><p><strong>这也是为什么 Hook 需要在我们组件的最顶层调用。</strong>如果我们想要有条件地执行一个 effect，可以将判断放到 Hook 的内部。</p><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><h4 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h4><blockquote><p>用于定义组件的 State，类似类定义中 <code>this.state</code> 的功能。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(initialState);</span><br></pre></td></tr></table></figure><ul><li><p><code>useState()</code> 方法里面唯一的参数<code>initialState</code>就是<strong>初始 state</strong>。</p><p>不同于 class 的是，我们可以按照需要使用数字或字符串对其进行赋值，而<strong>不一定是对象</strong>。</p></li><li><p>返回值为：<strong>当前 state</strong> 以及<strong>更新 state 的函数</strong>。</p><p>这与 class 里面 <code>this.state.count</code> 和 <code>this.setState</code> 类似，唯一区别就是你需要成对的获取它们。</p></li></ul><p><code>setState</code> 函数用于更新 state。它接收一个<strong>新的 state 值</strong>并将<strong>组件的一次重新渲染加入队列</strong>。</p><p>在后续的重新渲染中，<code>useState</code> 返回的第一个值将始终是<strong>更新后最新的 state</strong>。</p><blockquote><p>React 会确保 <code>setState</code> 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>setState</code>。</p></blockquote><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><h5 id="能用其他状态计算出来就不用单独声明状态。"><a href="#能用其他状态计算出来就不用单独声明状态。" class="headerlink" title="能用其他状态计算出来就不用单独声明状态。"></a>能用其他状态计算出来就不用单独声明状态。</h5><p>一个 state 必须不能通过其它 state/props 直接计算出来，否则就不用定义 state。</p><h5 id="保证数据源唯一"><a href="#保证数据源唯一" class="headerlink" title="保证数据源唯一"></a>保证数据源唯一</h5><p>在项目中同一个数据，保证只存储在一个地方。</p><p>不要既存在 redux 中，又在组件中定义了一个 state 存储。</p><p>不要既存在父级组件中，又在当前组件中定义了一个 state 存储。</p><p>不要既存在 url query 中，又在组件中定义了一个 state 存储。</p><h5 id="useState-适当合并"><a href="#useState-适当合并" class="headerlink" title="useState 适当合并"></a>useState 适当合并</h5><p>如果我们想使用多个 state 变量，它允许我们<strong>给不同的 state 变量取不同的名称</strong>。</p><p>State 变量可以很好地存储<strong>对象和数组</strong>，因此，你仍然可以将<strong>相关数据</strong>分为一组。</p><p>然而，不像 class 中的 <code>this.setState</code>，<strong>更新 state 变量总是替换它而不是合并它</strong>。</p><p>同样含义的变量可以合并成一个 state，代码可读性会提升很多：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [userInfo, setUserInfo] = useState(&#123;</span><br><span class="line">  firstName,</span><br><span class="line">  lastName,</span><br><span class="line">  school,</span><br><span class="line">  age,</span><br><span class="line">  address</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [weather, setWeather] = useState();</span><br><span class="line"><span class="keyword">const</span> [room, setRoom] = useState();</span><br></pre></td></tr></table></figure><p>当然这种方式我们在变更变量时，一定不要忘记带上老的字段，比如我们只想修改 <code>firstName</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setUserInfo(<span class="function"><span class="params">s</span>=&gt;</span> (&#123;</span><br><span class="line">  ...s,</span><br><span class="line">  fristName,</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>其实如果是 React Class 组件，state 是会自动合并的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  firstName</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="函数式更新"><a href="#函数式更新" class="headerlink" title="函数式更新"></a>函数式更新</h5><p>如果新的 state 需要通过使用<strong>先前的 state</strong> 计算得出，那么可以将函数传递给 <code>setState</code>。</p><p>该函数将接收先前的 state，并返回一个更新后的值。下面的计数器组件示例展示了 <code>setState</code> 的两种用法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(initialCount);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      Count: &#123;count&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(initialCount)&#125;&gt;Reset<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“+” 和 “-” 按钮采用函数式形式，因为被更新的 state 需要基于之前的 state。</p><p>但是“重置”按钮则采用普通形式，因为它总是把 count 设置回初始值。</p><p>如果你的<strong>更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过</strong>。</p><p>与 class 组件中的 <code>setState</code> 方法不同，<code>useState</code> 不会自动合并更新对象。你可以用函数式的 <code>setState</code> 结合<strong>展开运算符</strong>来达到合并更新对象的效果。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(&#123;&#125;);</span><br><span class="line">setState(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 也可以使用 Object.assign</span></span><br><span class="line">  <span class="keyword">return</span> &#123;...prevState, ...updatedValues&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>useReducer</code> 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。</p><h5 id="惰性初始-state"><a href="#惰性初始-state" class="headerlink" title="惰性初始 state"></a>惰性初始 state</h5><p><code>initialState</code> 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。</p><p>如果初始 state 需要通过<strong>复杂计算</strong>获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> initialState = someExpensiveComputation(props);</span><br><span class="line">  <span class="keyword">return</span> initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="跳过-state-更新"><a href="#跳过-state-更新" class="headerlink" title="跳过 state 更新"></a>跳过 state 更新</h5><p>调用 State Hook 的更新函数并传入当前的 state 时，React 将跳过子组件的渲染及 effect 的执行。</p><p>（React 使用 <code>Object.is</code> 比较算法来比较 state。）</p><p>需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code> 来进行优化。</p><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><blockquote><p>数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。不管你知不知道这些操作，或是“副作用”这个名字，应该都在组件中使用过它们。</p><p>如果你熟悉 React class 的生命周期函数，你可以把 <code>useEffect</code> Hook 看做 <code>componentDidMount</code>，<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 这三个函数的组合。</p><p>在 React 组件中有两种常见副作用操作：需要清除的和不需要清除的。我们来更仔细地看一下他们之间的区别。</p></blockquote><h4 id="无需清除的-effect"><a href="#无需清除的-effect" class="headerlink" title="无需清除的 effect"></a>无需清除的 effect</h4><p>有时候，我们只想<strong>在 React 更新 DOM 之后运行一些额外的代码。</strong>比如<strong>发送网络请求</strong>，<strong>手动变更 DOM</strong>，<strong>记录日志</strong>，这些都是常见的无需清除的操作。</p><p><strong><code>useEffect</code> 做了什么？</strong></p><p>通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行某些操作。</p><p>React 会保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它。</p><p><strong>为什么在组件内部调用 <code>useEffect</code>？</strong></p><p>将 <code>useEffect</code> 放在组件内部让我们可以在 effect 中直接访问 <code>state</code> 变量（或其他 <code>props</code>）。</p><p>我们不需要特殊的 API 来读取它 —— 它已经保存在函数作用域中。</p><p><strong>Hook使用了 JavaScript 的闭包机制</strong>，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。</p><p><strong><code>useEffect</code> 会在每次渲染后都执行吗？</strong></p><p>是的，默认情况下，它在<strong>第一次渲染之后</strong>和<strong>每次更新之后</strong>都会执行。</p><p>你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。</p><p>React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。</p><blockquote><p>与 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 不同，使用 <code>useEffect</code> 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 <code>useLayoutEffect</code> Hook 供你使用，其 API 与 <code>useEffect</code> 相同。</p></blockquote><h4 id="需要清除的-effect"><a href="#需要清除的-effect" class="headerlink" title="需要清除的 effect"></a>需要清除的 effect</h4><p>之前，我们研究了如何使用不需要清除的副作用，还有一些副作用是需要清除的。例如<strong>订阅外部数据源</strong>。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！</p><p><strong>为什么要在 effect 中返回一个函数？</strong></p><p>这是 effect 可选的清除机制。每个 effect 都可以返回一个<strong>清除函数</strong>。</p><p>如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</p><p><strong>React 何时清除 effect？</strong></p><p>React 会在<strong>组件卸载</strong>的时候执行清除操作。</p><p>正如之前学到的，effect 在每次渲染的时候都会执行。</p><p>这就是为什么 <strong>React 会在执行当前 effect 之前对上一个 effect 进行清除</strong>。</p><blockquote><p>并不是必须为 effect 中返回的函数命名。这里我们将其命名为 <code>cleanup</code> 是为了表明此函数的目的，但其实也可以返回一个箭头函数或者给起一个别的名字。</p></blockquote><h4 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h4><h5 id="使用多个-Effect-实现关注点分离"><a href="#使用多个-Effect-实现关注点分离" class="headerlink" title="使用多个 Effect 实现关注点分离"></a>使用多个 Effect 实现关注点分离</h5><p>使用 Hook 其中一个目的就是要<strong>解决 class 中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题</strong>。</p><p><strong>Hook 允许我们按照代码的用途分离他们，</strong> 而不是像生命周期函数那样。</p><p>React 将按照 effect 声明的顺序依次调用组件中的每一个 effect。</p><h5 id="通过跳过-Effect-进行性能优化"><a href="#通过跳过-Effect-进行性能优化" class="headerlink" title="通过跳过 Effect 进行性能优化"></a>通过跳过 Effect 进行性能优化</h5><p>在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题。</p><p>在 class 组件中，我们可以通过在 <code>componentDidUpdate</code> 中添加对 <code>prevProps</code> 或 <code>prevState</code> 的比较逻辑解决：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevState.count !== <span class="built_in">this</span>.state.count) &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;<span class="built_in">this</span>.state.count&#125;</span> times`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是很常见的需求，所以它被内置到了 <code>useEffect</code> 的 Hook API 中。</p><p>如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React <strong>跳过</strong>对 effect 的调用，只要传递数组作为 <code>useEffect</code> 的第二个可选参数即可：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// 仅在 count 更改时更新</span></span><br></pre></td></tr></table></figure><p>如果你要使用此优化方式，请确保数组中包含了<strong>所有外部作用域中会随时间变化并且在 effect 中使用的变量</strong>，否则你的代码会引用到<strong>先前渲染中的旧变量</strong>。</p><p>要记住 effect 外部的函数使用了哪些 props 和 state 很难。</p><p>这也是为什么 <strong>通常你会想要在 effect 内部去声明它所需要的函数。</strong></p><p><strong>只有</strong> 当函数（以及它所调用的函数）<strong>不引用 props、state 以及由它们衍生而来的值时</strong>，你才能放心地把它们从依赖列表中省略。</p><p><strong>如果出于某些原因你无法 把一个函数移动到 effect 内部，还有一些其他办法：</strong></p><ul><li><strong>你可以尝试把那个函数移动到你的组件之外</strong>。那样一来，这个函数就肯定不会依赖任何 props 或 state，并且也不用出现在依赖列表中了。</li><li>如果你所调用的方法是一个纯计算，并且可以在渲染时调用，你可以 <strong>转而在 effect 之外调用它，</strong> 并让 effect 依赖于它的返回值。</li><li>万不得已的情况下，你可以 <strong>把函数加入 effect 的依赖但把它的定义包裹</strong> 进 <code>useCallback</code>Hook。这就<strong>确保了它不随渲染而改变</strong>，除非它自身的依赖发生了改变：</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProductPage</span>(<span class="params">&#123; productId &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ✅ 用 useCallback 包裹以避免随渲染发生改变  </span></span><br><span class="line">    <span class="keyword">const</span> fetchProduct = useCallback(<span class="function">() =&gt;</span> &#123;    </span><br><span class="line">        <span class="comment">// ... Does something with productId ...  </span></span><br><span class="line">    &#125;, [productId]); <span class="comment">// ✅ useCallback 的所有依赖都被指定了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ProductDetails</span> <span class="attr">fetchProduct</span>=<span class="string">&#123;fetchProduct&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProductDetails</span>(<span class="params">&#123; fetchProduct &#125;</span>) </span>&#123;</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fetchProduct();</span><br><span class="line">    &#125;, [fetchProduct]); <span class="comment">// ✅ useEffect 的所有依赖都被指定了</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在上面的案例中，我们 <strong>需要</strong> 让函数出现在依赖列表中。</p><p>这确保了 <code>ProductPage</code> 的 <code>productId</code> prop 的变化会自动触发 <code>ProductDetails</code> 的重新获取。</p><h5 id="如果我的-effect-的依赖频繁变化，我该怎么办？"><a href="#如果我的-effect-的依赖频繁变化，我该怎么办？" class="headerlink" title="如果我的 effect 的依赖频繁变化，我该怎么办？"></a>如果我的 effect 的依赖频繁变化，我该怎么办？</h5><p>有时候，你的 effect 可能会使用一些频繁变化的值。你可能会忽略依赖列表中 state，但这通常会引起 Bug：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            setCount(count + <span class="number">1</span>); <span class="comment">// 这个 effect 依赖于 `count` state    </span></span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">    &#125;, []); <span class="comment">// 🔴 Bug: `count` 没有被指定为依赖</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入空的依赖数组 <code>[]</code>，意味着该 hook 只在组件挂载时运行一次，并非重新渲染时。</p><p>但如此会有问题，在 <code>setInterval</code> 的回调中，<code>count</code> 的值不会发生变化。</p><p>因为当 effect 执行时，我们会创建一个闭包，并将 <code>count</code> 的值被保存在该闭包当中，且初值为 <code>0</code>。</p><p>每隔一秒，回调就会执行 <code>setCount(0 + 1)</code>，因此，<code>count</code> 永远不会超过 1。</p><p>指定 <code>[count]</code> 作为依赖列表就能修复这个 Bug，但会导致每次改变发生时定时器都被重置。</p><p>事实上，每个 <code>setInterval</code> 在被清除前（类似于 <code>setTimeout</code>）都会调用一次。但这并不是我们想要的。</p><p>要解决这个问题，我们可以使用 <code>setState</code> 的函数式更新形式。它允许我们<strong>指定 state 该如何改变而不用引用当前 state</strong>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>); <span class="comment">// ✅ 在这不依赖于外部的 `count` 变量    </span></span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">    &#125;, []); <span class="comment">// ✅ 我们的 effect 不使用组件作用域中的任何变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（<code>setCount</code> 函数的身份是被确保稳定的，所以可以放心的省略掉）</p><p>此时，<code>setInterval</code> 的回调依旧每秒调用一次，但每次 <code>setCount</code> 内部的回调取到的 <code>count</code> 是最新值（在回调中变量命名为 <code>c</code>）。</p><p>在一些更加复杂的场景中（比如<strong>一个 state 依赖于另一个 state</strong>），尝试用 <code>useReducer</code> Hook把 state 更新逻辑移到 effect 之外。</p><p><strong><code>useReducer</code> 的 <code>dispatch</code> 的身份永远是稳定的</strong> —— 即使 reducer 函数是定义在组件内部并且依赖 props。</p><p>万不得已的情况下，如果你想要类似 class 中的 <code>this</code> 的功能，你可以<strong>使用一个 ref</strong> 来保存一个<strong>可变的变量</strong>。</p><p>然后你就可以对它进行读写了。举个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把最新的 props 保存在一个 ref 中  </span></span><br><span class="line">    <span class="keyword">const</span> latestProps = useRef(props);  </span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;    </span><br><span class="line">        latestProps.current = props;  </span><br><span class="line">    &#125;);</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 在任何时候读取最新的 props      </span></span><br><span class="line">            <span class="built_in">console</span>.log(latestProps.current);   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(tick, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">    &#125;, []); <span class="comment">// 这个 effect 从不会重新执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅当你实在找不到更好办法的时候才这么做，因为依赖于变更会使得组件更难以预测。</p><h5 id="effect-的执行时机"><a href="#effect-的执行时机" class="headerlink" title="effect 的执行时机"></a>effect 的执行时机</h5><p>与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 不同的是，传给 <code>useEffect</code> 的函数会<strong>在浏览器完成布局与绘制之后</strong>，在一个延迟事件中被调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因为绝大多数操作不应阻塞浏览器对屏幕的更新。</p><p>然而，<strong>并非所有 effect 都可以被延迟执行</strong>。例如，一个对用户可见的 DOM 变更就必须在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别。）React 为此提供了一个额外的 <code>useLayoutEffect</code>Hook 来处理这类 effect。它和 <code>useEffect</code> 的结构相同，区别只是<strong>调用时机不同</strong>。</p><p>此外，从 React 18 开始，当它是离散的用户输入（如点击）的结果时，或者当它是由 <code>flushSync</code>]包装的更新结果时，传递给 <code>useEffect</code> 的函数将在屏幕布局和绘制<strong>之前</strong>同步执行。这种行为便于事件系统或 <code>flushSync</code>的调用者观察该效果的结果。</p><blockquote><p>这只影响传递给 <code>useEffect</code> 的函数被调用时 — 在这些 effect 中执行的更新仍会被推迟。这与 <code>useLayoutEffect</code>不同，后者会立即启动该函数并处理其中的更新。</p></blockquote><p>即使在 <code>useEffect</code> 被推迟到浏览器绘制之后的情况下，它也能保证在任何新的渲染前启动。React 在开始新的更新前，总会先刷新之前的渲染的 effect。</p><h5 id="自己理解"><a href="#自己理解" class="headerlink" title="自己理解"></a>自己理解</h5><p>依赖的值可以设置多个，只要有一个更新，就会执行effect。</p><p><strong>放到 deps 数组中的变量变化时，就会触发 useEffect 函数执行。</strong></p><ul><li>一种方法是在依赖中只放入需要触发函数执行的变量，选择性忽略 <code>eslint-plugin-react-hooks</code> 插件的警告。<code>// eslint-disable-next-line</code></li><li>另一种方法是在依赖中写全所有外部作用域中会随时间变化并且在 effect 中使用的变量，如果effect有条件触发，自己写if判断，而不是靠依赖数组。<strong>即具体逻辑是否执行应该在内部自己判断，而不是交给react。</strong></li></ul><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><ul><li><p><strong>多次渲染之间保证唯一值的纽带</strong>。</p><p>useRef 会在所有的 render 中保持对返回值的唯一引用。因为所有对<code>ref</code>的赋值和取值拿到的都是最终的状态，并不会因为不同的 render 中存在不同的隔离。</p></li><li><p><strong>获取 Dom 元素</strong>，在 Function Component 中我们可以通过 useRef 来获取对应的 Dom 元素。</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = useRef(initialValue);</span><br></pre></td></tr></table></figure><p><code>useRef</code> 返回一个<strong>可变的 ref 对象</strong>，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。</p><p>返回的 ref 对象在组件的<strong>整个生命周期内</strong>持续存在。</p><p>一个常见的用例便是命令式地访问子组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span></span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputEl&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上，<code>useRef</code> 就像是可以在其 <code>.current</code> 属性中保存一个可变值的“盒子”。</p><p>你应该熟悉 ref 这一种访问 DOM的主要方式。</p><p>如果你将 ref 对象以 <code>&lt;div ref=&#123;myRef&#125; /&gt;</code> 形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 <code>.current</code> 属性设置为相应的 DOM 节点。</p><p>然而，<code>useRef()</code> 比 <code>ref</code> 属性更有用。它可以很方便地<strong>保存任何可变值</strong>，其类似于在 class 中使用实例字段的方式。</p><p>这是因为它创建的是一个<strong>普通Javascript 对象</strong>。</p><p>而 <code>useRef()</code> 和自建一个 <code>&#123;current: ...&#125;</code> 对象的唯一区别是，<code>useRef</code> 会在<strong>每次渲染时返回同一个 ref 对象</strong>。</p><p>请记住，当 ref 对象内容发生变化时，<code>useRef</code> 并不会通知你。变更 <code>.current</code> 属性不会引发组件重新渲染。</p><p>如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref来实现。</p><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>返回一个<code>memoized</code>回调函数。</p><p>把内联回调函数及依赖项数组作为参数传入 <code>useCallback</code>，它将返回该回调函数的 memoized 版本，<strong>该回调函数仅在某个依赖项改变时才会更新</strong>。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 <code>shouldComponentUpdate</code>）的子组件时，它将非常有用。</p><p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p><h4 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h4><p>获取 DOM 节点的位置或是大小的基本方式是使用<code>callback ref</code>。</p><p>每当 ref 被附加到一个另一个节点，React 就会调用 callback。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MeasureExample</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [height, setHeight] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> measuredRef = useCallback(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      setHeight(node.getBoundingClientRect().height);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">&#123;measuredRef&#125;</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>The above header is &#123;Math.round(height)&#125;px tall<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个案例中，我们没有选择使用 <code>useRef</code>，因为<strong>当 ref 是一个对象时它并不会把当前 ref 的值的变化通知到我们</strong>。</p><p>使用 callback ref 可以确保即便子组件延迟显示被测量的节点 (比如为了响应一次点击)，我们依然能够在父组件接收到相关的信息，以便更新测量结果。</p><p>注意到我们传递了 <code>[]</code> 作为 <code>useCallback</code> 的依赖列表。这确保了 ref callback 不会在再次渲染时改变，因此 React 不会在非必要的时候调用它。</p><p>在此示例中，当且仅当组件挂载和卸载时，callback ref 才会被调用，因为渲染的 <code>&lt;h1&gt;</code> 组件在整个重新渲染期间始终存在。</p><h4 id="关于使用"><a href="#关于使用" class="headerlink" title="关于使用"></a>关于使用</h4><p>在项目中不要随意useCallback，一些场景下，不仅没有提升性能，反而让代码可读性变的很差。</p><p>useCallback 可以记住函数，避免函数重复生成，这样函数在传递给子组件时，可以避免子组件重复渲染，提高性能。</p><p>但我们要注意，提高性能还必须有另外一个条件，子组件必须使用了 <code>shouldComponentUpdate</code> 或者 <code>React.memo</code> 来忽略同样的参数重复渲染。</p><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p>返回一个memoized 值。</p><p>把“创建”函数和依赖项数组作为参数传入 <code>useMemo</code>，它仅会在某个依赖项改变时才重新计算 memoized 值。</p><p>这种优化有助于避免在每次渲染时都进行高开销的计算。</p><p>记住，传入 <code>useMemo</code> 的函数会在<strong>渲染期间</strong>执行。</p><p>请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴，而不是 <code>useMemo</code>。</p><p>如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值。</p><p><strong>你可以把 <code>useMemo</code> 作为性能优化的手段，但不要把它当成语义上的保证。</strong></p><p><code>useMemo</code> Hook 使得控制具体子节点何时更新变得更容易，减少了对纯组件的需要。</p><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure><ul><li>ref 表示需要<strong>被赋值的 ref 对象</strong>。</li><li>createHandle 函数的<strong>返回值</strong>作为 <code>ref.current</code> 的值。</li><li>deps 依赖数组，依赖发生变化会重新执行 createHandle 函数。</li></ul><blockquote><p>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用。</p></blockquote><p>当然，在日常 React 开发中可能会存在这样一种情况。<strong>我们希望在父组件中调用子组件的方法</strong>，虽然 React 官方并不推荐这样声明式的写法，但是有时候我们不得不这样做。</p><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure><p><code>useState</code>的替代方案。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。）</p><p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 <strong>state 逻辑较复杂且包含多个子值</strong>，或者<strong>下一个 state 依赖于之前的 state</strong> 等。并且，使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数 。</p><p>以下是用 reducer 重写 <code>useState</code>一节的计数器示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      Count: &#123;state.count&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>React 会确保 <code>dispatch</code> 函数的标识是稳定的，并且不会在组件重新渲染时改变。这就是为什么可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>dispatch</code>。</p></blockquote><h4 id="指定初始-state"><a href="#指定初始-state" class="headerlink" title="指定初始 state"></a>指定初始 state</h4><p>有两种不同初始化 <code>useReducer</code> state 的方式，你可以根据使用场景选择其中的一种。</p><p>将初始 state 作为第二个参数传入 <code>useReducer</code> 是最简单的方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(</span><br><span class="line">    reducer,</span><br><span class="line">    &#123;<span class="attr">count</span>: initialCount&#125;  </span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>React 不使用 <code>state = initialState</code> 这一由 Redux 推广开来的参数约定。有时候初始值依赖于 props，因此需要在调用 Hook 时指定。如果你特别喜欢上述的参数约定，可以通过调用 <code>useReducer(reducer, undefined, reducer)</code> 来模拟 Redux 的行为，但我们不鼓励你这么做。</p></blockquote><h4 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h4><p>你可以选择惰性地创建初始 state。为此，需要将 <code>init</code> 函数作为 <code>useReducer</code> 的第三个参数传入，这样初始 state 将被设置为 <code>init(initialArg)</code>。</p><p>这么做可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initialCount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: initialCount&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;reset&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> init(action.payload);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialCount, init);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      Count: &#123;state.count&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;reset&#x27;, payload: initialCount&#125;)&#125;&gt;</span></span><br><span class="line"><span class="xml">        Reset</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="跳过-dispatch"><a href="#跳过-dispatch" class="headerlink" title="跳过 dispatch"></a>跳过 dispatch</h4><p>如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。</p><p>（React 使用 <code>Object.is</code> 比较算法来比较 state。）</p><p>需要注意的是，React 可能仍需要在跳过渲染前再次渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code> 来进行优化。</p><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><h3 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h3><p>通过自定义 Hook，可以将<strong>组件逻辑</strong>提取到<strong>可重用的函数</strong>中。</p><p><strong>自定义 Hook 是一个函数，其名称以 “<code>use</code>” 开头，函数内部可以调用其他的 Hook。</strong></p><p><strong>自定义 Hook 必须以 “<code>use</code>” 开头吗？</strong></p><p>必须如此。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了<strong>Hook的规则</strong>。</p><p><strong>在两个组件中使用相同的 Hook 会共享 state 吗？</strong></p><p>不会。自定义 Hook 是一种<strong>重用状态逻辑</strong>的机制(例如设置为订阅并存储当前值)，所以<strong>每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的</strong>。</p><p>我们可以在一个组件中多次调用 <code>useState</code> 和 <code>useEffect</code>，它们是完全独立的。</p><h2 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h2><h3 id="React-PureComponent"><a href="#React-PureComponent" class="headerlink" title="React.PureComponent"></a>React.PureComponent</h3><p><code>React.Component</code> 是使用ES6 classes方式定义 React 组件的基类：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>React.PureComponent</code> 与 <code>React.Component</code>很相似。</p><p>两者的区别在于 <code>React.Component</code>并未实现 <code>shouldComponentUpdate()</code>，而 <code>React.PureComponent</code> 中以<strong>浅层对比</strong> <code>prop</code> 和 <code>state</code> 的方式来实现了该函数。</p><p>如果赋予 React 组件相同的 props 和 state，<code>render()</code> 函数会渲染相同的内容，那么在某些情况下使用 <code>React.PureComponent</code> 可提高性能。</p><h3 id="React-memo-1"><a href="#React-memo-1" class="headerlink" title="React.memo"></a>React.memo</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = React.memo(<span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>React.memo</code> 为高阶组件。</p><p>如果你的组件在相同 <code>props</code> 的情况下渲染相同的结果，那么你可以通过将其包装在 <code>React.memo</code> 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。</p><p>这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p><p><code>React.memo</code> <strong>仅检查 props 变更</strong>。</p><p>如果函数组件被 <code>React.memo</code> 包裹，且其实现中拥有 <code>useState</code>，<code>useReducer</code>或 <code>useContext</code> 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。</p><p>默认情况下其只会对复杂对象做<strong>浅层对比</strong>，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areEqual</span>(<span class="params">prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果把 nextProps 传入 render 方法的返回结果与</span></span><br><span class="line"><span class="comment">  将 prevProps 传入 render 方法的返回结果一致则返回 true，</span></span><br><span class="line"><span class="comment">  否则返回 false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(MyComponent, areEqual);</span><br></pre></td></tr></table></figure><p>此方法仅作为<strong>性能优化</strong>的方式而存在。但请不要依赖它来“阻止”渲染，因为这会产生 bug。</p><blockquote><p>与 class 组件中 <code>shouldComponentUpdate()</code>方法不同的是，如果 props 相等，<code>areEqual</code> 会返回 <code>true</code>；如果 props 不相等，则返回 <code>false</code>。这与 <code>shouldComponentUpdate</code> 方法的返回值相反。</p></blockquote><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p><h2 id="setState-是同步，还是异步的？"><a href="#setState-是同步，还是异步的？" class="headerlink" title="setState 是同步，还是异步的？"></a>setState 是同步，还是异步的？</h2><p>在React中，如果是<strong>由React引发的事件处理</strong>（比如通过onClick引发的事件处理），调用setState<strong>不会同步</strong>更新this.state，除此之外的setState调用会同步执行this.state 。所谓“除此之外”，指的是绕过React<strong>通过addEventListener</strong>直接添加的事件处理函数，还有通过<strong>setTimeout/setInterval</strong>产生的异步调用。</p><p>setState的“异步”并不是说内部由异步代码实现，其实<strong>本身执行的过程和代码都是同步的</strong>，<strong>只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值</strong>，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的<code>callback</code>拿到更新后的结果。</p><p>综上，setState 只在<strong>合成事件和 hook()</strong> 中是“异步”的，在 <strong>原生事件和 setTimeout</strong> 中都是同步的。</p><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="redux理解"><a href="#redux理解" class="headerlink" title="redux理解"></a>redux理解</h2><ol><li>redux是一个专门用于做<strong>状态管理的JS库</strong>(不是react插件库)。</li><li>它可以用在react, angular, vue等项目中, 但基本与react配合使用。</li><li>作用: 集中式管理react应用中多个组件<strong>共享</strong>的状态。</li></ol><h3 id="什么情况下需要使用redux"><a href="#什么情况下需要使用redux" class="headerlink" title="什么情况下需要使用redux"></a>什么情况下需要使用redux</h3><ol><li>某个组件的状态，需要让其他组件可以随时拿到（共享）。</li><li>一个组件需要改变另一个组件的状态（通信）。</li><li>总体原则：能不用就不用, 如果不用比较吃力才考虑使用。</li></ol><h3 id="redux工作流程"><a href="#redux工作流程" class="headerlink" title="redux工作流程"></a>redux工作流程</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5W48UO"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/24/5W48UO.png" alt="5W48UO.png"></a></p><h2 id="redux的三个核心概念"><a href="#redux的三个核心概念" class="headerlink" title="redux的三个核心概念"></a>redux的三个核心概念</h2><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><ul><li><p><strong>动作的对象</strong></p></li><li><p>包含2个属性</p><p>type：标识属性, 值为字符串, 唯一, 必要属性</p><p>data：数据属性, 值类型任意, 可选属性</p></li><li><p>例子：<code>&#123; type: &#39;ADD_STUDENT&#39;,data:&#123;name: &#39;tom&#39;,age:18&#125; &#125;</code></p></li></ul><h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><ul><li><p><strong>用于初始化状态、加工状态</strong>。</p></li><li><p>加工时，根据旧的state和action， 产生新的state的<strong>纯函数</strong></p><ul><li>纯函数:一类特别的函数: 只要是同样的输入(实参)，必定得到同样的输出(返回)</li><li>必须遵守以下一些约束<ul><li><strong>不得改写参数数据</strong> <code>preState.unshift(data)</code></li><li>不会产生任何副作用，例如网络请求，输入和输出设备</li><li>不能调用<code>Date.now()</code>或者<code>Math.random()</code>等不纯的方法</li></ul></li></ul></li><li><p>redux的<strong>reducer函数必须是一个纯函数</strong></p></li></ul><h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><ul><li><p><strong>将state、action、reducer联系在一起的对象</strong></p></li><li><p>如何得到此对象?</p><ul><li><code>import &#123;createStore&#125; from &#39;redux&#39;</code></li><li><code>import reducer from &#39;./reducers&#39;</code></li><li><code>const store = createStore(reducer)</code></li></ul></li><li><p>此对象的功能?</p><ul><li><p><code>getState()</code>: 得到state</p></li><li><p><code>dispatch(action)</code>: 分发action, 触发reducer调用, 产生新的state</p></li><li><p><code>subscribe(listener)</code>: 注册监听, 当产生了新的state时, 自动调用</p></li></ul></li></ul><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p>Hexo：一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>Github Pages：简单点来说，就是它为你的项目提供一个访问站点，并且直接指向你的仓库，你仓库更新，站点网站自动更新。</p><p>Github Pages可以被认为是用户编写的、托管在Github上的静态网页。使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。此外还可以绑定自己的域名。</p><p>Butterfly：主题。</p><p>npm：安装各种依赖。</p><p>性能优化：</p><p>图片压缩，cdn加速</p><p>jsDelivr ：它原生支持使用 GitHub 项目里的资源，什么都不用配置，更重要的是免费，在国内有节点，而且速度还不错（官网上也把 works in China 作为一个卖点的）。</p><p>因为页面自身还是在 GitHub Pages 托管，有时候首个请求还是会挺久才返回。</p><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><ol><li>TypeScript是JavaScript的超集。</li><li>它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。</li><li>TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。</li><li>TS完全兼容JS，换言之，任何的JS代码都可以直接当成TS使用。</li><li>相较于JS而言，TS拥有了<strong>静态类型</strong>，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。</li><li>TypeScript支持面向对象的编程特性，比如类、接口、继承、泛型等等。</li></ol><h1 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li>创建型模式，共五种：<strong>工厂方法模式、抽象工厂模式</strong>、<strong>单例模式</strong>、建造者模式、<strong>原型模式。</strong></li><li>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>操作系统（Operating System，缩写：OS）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石。</p><p>简单来讲，操作系统就是一种复杂的软件，相当于软件管家。</p><p>操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。</p><p><strong>操作系统的核心概念都是对具体物理硬件的抽象</strong>，主要有如下：</p><ul><li>进程（线程）：<strong>进程（线程）是操作系统对CPU的抽象</strong></li><li>虚拟内存（地址空间）：<strong>虚拟内存是操作系统对物理内存的抽象</strong></li><li>文件：<strong>文件是操作系统对物理磁盘的抽象</strong></li><li>多线程(multithreading)：是指从软件或者硬件上实现多个线程并发执行的技术</li><li>CPU 核心(core)：它是 CPU 的大脑，它接收指令，并执行计算或运算以满足这些指令。一个 CPU 可以有多个内核</li><li>图形处理器(Graphics Processing Unit)：又称显示核心、视觉处理器、显示芯片或绘图芯片</li><li>缓存命中(cache hit)：当应用程序或软件请求数据时，会首先发生缓存命中</li><li>RAM((Random Access Memory)：随机存取存储器，也叫主存，是与 CPU 直接交换数据的内部存储器</li><li>ROM (Read Only Memory)：只读存储器是一种半导体存储器，其特性是一旦存储数据就无法改变或删除</li><li>进程间通信(interprocess communication)： 指至少两个进程或线程间传送数据或信号的一些技术或方法</li></ul><p><strong>进程和线程</strong></p><ul><li>进程是<strong>系统进行资源分配和调度的一个独立单位</strong>。</li><li>线程是<strong>CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位</strong>。</li><li><strong>一个进程至少由一个线程组成</strong>。</li></ul><p>线程自己基本上<strong>不拥有系统资源</strong>，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程<strong>共享进程所拥有的全部资源</strong>。</p><p><strong>浏览器是多进程的</strong></p><p>它主要包括以下进程：</p><ul><li><strong>Browser 进程</strong>：浏览器的主进程，唯一，负责创建和销毁其它进程、网络资源的下载与管理、浏览器界面的展示、前进后退等。</li><li><strong>GPU 进程</strong>：用于 3D 绘制等，最多一个。</li><li><strong>第三方插件进程</strong>：每种类型的插件对应一个进程，仅当使用该插件时才创建。</li><li><strong>浏览器渲染进程（浏览器内核）</strong>：内部是<strong>多线程</strong>的，<strong>每打开一个新网页就会创建一个进程</strong>，主要用于页面渲染，脚本执行，事件处理等。</li></ul><p><strong>渲染进程（浏览器内核）</strong></p><p>浏览器的渲染进程是<strong>多线程</strong>的，<strong>页面的渲染，JavaScript 的执行，事件的循环</strong>，都在这个进程内进行：</p><ul><li><strong>GUI 渲染线程</strong>：负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。</li><li><strong>JavaScript 引擎线程</strong>：也称为 JavaScript 内核，负责处理 Javascript 脚本程序、解析 Javascript 脚本、运行代码等。（例如 V8 引擎）</li><li><strong>事件触发线程</strong>：用来控制浏览器事件循环，注意这不归 JavaScript 引擎线程管，当事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。</li><li><strong>定时触发器线程</strong>：传说中的 setInterval 与 setTimeout 所在线程，注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms 。</li><li><strong>异步 http 请求线程</strong>：在 XMLHttpRequest 连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li></ul><p>注意，<strong>GUI 渲染线程与 JavaScript 引擎线程是互斥的</strong>，当 JavaScript 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JavaScript 引擎空闲时立即被执行。所以如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><p><strong>单线程的JavaScript</strong></p><p>所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。</p><h1 id="渠道"><a href="#渠道" class="headerlink" title="渠道"></a>渠道</h1><p>B站、MDN（建议英文，中译有误）和官网（React、React Router）、掘金/知乎、阮一峰博客</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leslie Waong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesliewaong.top/posts/f3b98ae9.html">https://lesliewaong.top/posts/f3b98ae9.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lesliewaong.top" target="_blank">Leslie Waong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CSS/">CSS</a><a class="post-meta__tags" href="/tags/HTML/">HTML</a><a class="post-meta__tags" href="/tags/JS/">JS</a><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/8.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/b976e516.html"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/7.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法题（JS）</div></div></a></div><div class="next-post pull-right"><a href="/posts/a9ba4134.html"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/4.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaScript基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/6bfa7aba.html" title="纯CSS3实现卡通人物眼睛的动画特效"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-16</div><div class="title">纯CSS3实现卡通人物眼睛的动画特效</div></div></a></div><div><a href="/posts/2eec1551.html" title="HTML和CSS基础"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-08</div><div class="title">HTML和CSS基础</div></div></a></div><div><a href="/posts/c0a854fc.html" title="CSS选择器及优先级"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-13</div><div class="title">CSS选择器及优先级</div></div></a></div><div><a href="/posts/3e6a4f74.html" title="CSS盒模型、BFC和清除浮动"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-12</div><div class="title">CSS盒模型、BFC和清除浮动</div></div></a></div><div><a href="/posts/74bc18a0.html" title="三栏布局"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-15</div><div class="title">三栏布局</div></div></a></div><div><a href="/posts/28d62aa4.html" title="居中布局与Flex"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-14</div><div class="title">居中布局与Flex</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Leslie Waong</div><div class="author-info__description">BUPT</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">109</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lesliewaong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lesliewaong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1138964397&amp;website=www.qtxml.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">红雨漂泊泛起了回忆怎么潜</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML-amp-CSS"><span class="toc-text">HTML&amp;CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3%E2%AD%90"><span class="toc-text">语义化的理解⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE"><span class="toc-text">常用的一些语义化标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%AB%E6%BB%A5%E7%94%A8%E7%9A%84%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE"><span class="toc-text">被滥用的语义化标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML5%E6%96%B0%E5%A2%9E"><span class="toc-text">HTML5新增</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lt-img-gt-%E7%9A%84title%E5%92%8Calt%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">&lt;img&gt;的title和alt有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#H5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%E2%AD%90"><span class="toc-text">H5的新特性有哪些⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iframe%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">iframe优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#iframe%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">iframe的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iframe%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">iframe的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8Bsrc%E4%B8%8Ehref%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">简述一下src与href的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E9%81%93%E7%9A%84%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C%E4%BC%9A%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">知道的网页制作会用到的图片格式有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inline%EF%BC%8Cblock%EF%BC%8Cinline-block%E7%9A%84%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="toc-text">inline，block，inline-block的区别⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0-block"><span class="toc-text">块级元素(block)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-inline"><span class="toc-text">行内元素(inline)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%9D%97%E5%85%83%E7%B4%A0-inline-block"><span class="toc-text">行内块元素(inline-block)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E4%B8%8E%E5%9D%97%E7%8A%B6%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">行内元素与块状元素之间的转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%E2%AD%90"><span class="toc-text">居中布局⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD"><span class="toc-text">水平居中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-text">垂直居中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-text">水平垂直居中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flex%E2%AD%90"><span class="toc-text">Flex⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-text">容器属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flex-flow"><span class="toc-text">flex-flow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#justify-content"><span class="toc-text">justify-content</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#align-items"><span class="toc-text">align-items</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#align-content"><span class="toc-text">align-content</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">项目的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#align-self"><span class="toc-text">align-self</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flex"><span class="toc-text">flex</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E2%AD%90"><span class="toc-text">三栏布局⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E5%8A%A8"><span class="toc-text">浮动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D"><span class="toc-text">绝对定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flexbox%E5%B8%83%E5%B1%80"><span class="toc-text">Flexbox布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80table"><span class="toc-text">表格布局table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80-grid"><span class="toc-text">网格布局 grid</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%A4%E8%AF%86%E2%AD%90"><span class="toc-text">对CSS盒模型的认识⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E7%9B%92%E5%AD%90%EF%BC%88Block-box%EF%BC%89-%E5%92%8C-%E5%86%85%E8%81%94%E7%9B%92%E5%AD%90%EF%BC%88Inline-box%EF%BC%89"><span class="toc-text">块级盒子（Block box） 和 内联盒子（Inline box）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCSS-%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">什么是CSS 盒模型?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%92%8CIE%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-text">标准盒模型和IE盒子模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFC%E2%AD%90"><span class="toc-text">BFC⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">BFC的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90BFC"><span class="toc-text">如何生成BFC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">BFC 的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3margin%E9%87%8D%E5%8F%A0"><span class="toc-text">解决margin重叠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%BD%B1%E5%93%8D%EF%BC%88%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%EF%BC%89"><span class="toc-text">清除浮动影响（高度塌陷）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E4%B8%ADlink%E5%92%8C-import%E5%8C%BA%E5%88%AB"><span class="toc-text">CSS中link和@import区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#less%E2%AD%90"><span class="toc-text">less⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#script%E6%A0%87%E7%AD%BE%E7%9A%84defer%E5%92%8Casync%E5%B1%9E%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">script标签的defer和async属性有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#async%E6%A0%87%E8%AE%B0"><span class="toc-text">async标记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer%E6%A0%87%E8%AE%B0"><span class="toc-text">defer标记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B0%E5%BA%95%E8%AF%A5%E7%94%A8%E5%93%AA%E4%B8%AA%E6%A0%87%E8%AE%B0"><span class="toc-text">到底该用哪个标记</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7%E2%AD%90"><span class="toc-text">CSS选择器优先级⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2"><span class="toc-text">颜色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">HTML 页面的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOMContentLoaded-%E5%92%8C%E8%84%9A%E6%9C%AC"><span class="toc-text">DOMContentLoaded 和脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOMContentLoaded-%E5%92%8C%E6%A0%B7%E5%BC%8F"><span class="toc-text">DOMContentLoaded 和样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%BB%BA%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85"><span class="toc-text">浏览器内建的自动填充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window-onload"><span class="toc-text">window.onload</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window-onunload"><span class="toc-text">window.onunload</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window-onbeforeunload"><span class="toc-text">window.onbeforeunload</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#margin-%E4%B8%8E-padding"><span class="toc-text">margin 与 padding</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%AFCSS3%E5%AE%9E%E7%8E%B0%E5%8D%A1%E9%80%9A%E4%BA%BA%E7%89%A9%E7%9C%BC%E7%9D%9B%E7%9A%84%E5%8A%A8%E7%94%BB%E7%89%B9%E6%95%88"><span class="toc-text">纯CSS3实现卡通人物眼睛的动画特效</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80"><span class="toc-text">自适应布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1px%E8%BE%B9%E6%A1%86%E9%97%AE%E9%A2%98"><span class="toc-text">1px边框问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEmeta%E6%A0%87%E7%AD%BEviewport"><span class="toc-text">通过设置meta标签viewport</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87transform-scale-%E7%BC%A9%E6%94%BE%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">通过transform: scale()缩放（推荐）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%8F%A3"><span class="toc-text">视口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E9%80%82%E9%85%8D%E6%96%B9%E6%B3%95"><span class="toc-text">解决适配方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rem%E9%80%82%E9%85%8D"><span class="toc-text">rem适配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vw%EF%BC%8Cvh%E5%B8%83%E5%B1%80"><span class="toc-text">vw，vh布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80"><span class="toc-text">媒体查询 响应式布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#px%E4%B8%BA%E4%B8%BB%EF%BC%8Cvx%E5%92%8Cvxxx%EF%BC%88vw-vh-vmax-vmin%EF%BC%89%E4%B8%BA%E8%BE%85%EF%BC%8C%E6%90%AD%E9%85%8D%E4%B8%80%E4%BA%9Bflex%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">px为主，vx和vxxx（vw&#x2F;vh&#x2F;vmax&#x2F;vmin）为辅，搭配一些flex（推荐）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E6%A1%86"><span class="toc-text">边框</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8border%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-text">利用border画三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#border-radius"><span class="toc-text">border-radius</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#box-shadow"><span class="toc-text">box-shadow</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filter"><span class="toc-text">filter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#position"><span class="toc-text">position</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">层叠上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E5%8A%A8%E7%94%BB"><span class="toc-text">CSS动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transform"><span class="toc-text">transform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#animation"><span class="toc-text">animation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#keyframes"><span class="toc-text">@keyframes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-duration"><span class="toc-text">animation-duration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-timing-function"><span class="toc-text">animation-timing-function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-delay"><span class="toc-text">animation-delay</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-iteration-count"><span class="toc-text">animation-iteration-count</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-direction"><span class="toc-text">animation-direction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#animation-fill-mode"><span class="toc-text">animation-fill-mode</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB-%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-text">伪类&#x2F;伪元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB"><span class="toc-text">伪类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-text">伪元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JacaScript"><span class="toc-text">JacaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80"><span class="toc-text">语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%BB%A3%E7%A0%81-vs-%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81"><span class="toc-text">解释代码 vs 编译代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BB%A3%E7%A0%81-vs-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-text">服务器端代码 vs 客户端代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB-vs-%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-text">基于类 vs 基于原型的语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Js%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88"><span class="toc-text">Js中的堆栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%8C%BA"><span class="toc-text">栈区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%8C%BA"><span class="toc-text">堆区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-text">引用计数算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">标记清除算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%AD%90"><span class="toc-text">数据类型⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-7-1"><span class="toc-text">8种数据类型: 7+1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-text">类型判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84"><span class="toc-text">判断数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#amp"><span class="toc-text">&#x3D;&#x3D;&#x3D; &amp; &#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-is"><span class="toc-text">Object.is()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C1%E2%80%9D-%E2%80%9D2%E2%80%9D-%E2%80%9D3%E2%80%9D-map-parseInt-%E7%9A%84%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-text">[“1”,”2”,”3”].map(parseInt)的输出结果是多少?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Number"><span class="toc-text">Number</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-0-2-0-3"><span class="toc-text">0.1 + 0.2 !&#x3D;&#x3D; 0.3?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-text">严格模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%E2%AD%90"><span class="toc-text">作用域与闭包⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E2%AD%90"><span class="toc-text">原型与原型链⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93%E2%AD%90"><span class="toc-text">DOM事件总结⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BA%A7%E5%88%AB"><span class="toc-text">DOM事件的级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-text">DOM事件模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81-api-%E6%96%B9%E6%B3%95"><span class="toc-text">Event对象的常见 api 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%BB%A3%E7%90%86%EF%BC%89"><span class="toc-text">事件委托（代理）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E5%90%91%E2%AD%90"><span class="toc-text">this指向⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E2%AD%90"><span class="toc-text">JS数组常用方法总结⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-text">实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-text">实例方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for%E2%80%A6in%E5%92%8Cfor%E2%80%A6of%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">for…in和for…of有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B0%83%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">对调两个变量的多种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E6%B3%95"><span class="toc-text">解构赋值法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E6%B3%95"><span class="toc-text">临时变量法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%87%8F%E6%B3%95"><span class="toc-text">加减法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%B3%95"><span class="toc-text">数组法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B3%95"><span class="toc-text">对象法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%E6%B3%95"><span class="toc-text">按位异或法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E2%AD%90"><span class="toc-text">浅拷贝和深拷贝⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arguments"><span class="toc-text">arguments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">创建正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8"><span class="toc-text">常用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">正则表达式的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">字符串和正则相关的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Js%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-text">Js选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#getElementById"><span class="toc-text">getElementById</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getElementsByClassName"><span class="toc-text">getElementsByClassName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getElementsByName"><span class="toc-text">getElementsByName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getElementsByTagName"><span class="toc-text">getElementsByTagName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#querySelector"><span class="toc-text">querySelector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#querySelectorAll"><span class="toc-text">querySelectorAll</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Js%E4%B8%ADDate%E5%AF%B9%E8%B1%A1"><span class="toc-text">Js中Date对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BF%E9%97%AE"><span class="toc-text">字符访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">基本字符串和字符串对象的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E6%96%87%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">长文字字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-text">方法二</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">模板字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eval"><span class="toc-text">eval</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8-eval%EF%BC%81"><span class="toc-text">永远不要使用 eval！</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES6"><span class="toc-text">ES6+</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-text">解构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigInt"><span class="toc-text">BigInt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol"><span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class%E4%B8%8E%E7%BB%A7%E6%89%BF%E2%AD%90"><span class="toc-text">Class与继承⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B0%83%E7%94%A8"><span class="toc-text">类定义与调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">严格模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="toc-text">构造函数与方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-%E5%AD%97%E6%AE%B5"><span class="toc-text">属性&#x2F;字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="toc-text">箭头函数与普通函数区别⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let%E3%80%81const%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="toc-text">let、const和var的区别⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#var"><span class="toc-text">var</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#let"><span class="toc-text">let</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-text">const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87"><span class="toc-text">变量提升和函数提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82"><span class="toc-text">函数传参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">模块化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">Iterator 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%EF%BC%8CWeakSet%EF%BC%8CMap%E5%92%8CWeakMap"><span class="toc-text">Set，WeakSet，Map和WeakMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakSet"><span class="toc-text">WeakSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakMap"><span class="toc-text">WeakMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E2%AD%90"><span class="toc-text">异步编程⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83"><span class="toc-text">异步回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setTimeout-amp-setInterval"><span class="toc-text">setTimeout() &amp; setInterval()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise%E2%AD%90"><span class="toc-text">Promise⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E6%97%A7%E5%BC%8F%E5%9B%9E%E8%B0%83%E7%9B%B8%E6%AF%94"><span class="toc-text">与旧式回调相比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-text">状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-all-iterable"><span class="toc-text">Promise.all(iterable)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-race-iterable"><span class="toc-text">Promise.race(iterable)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-resolve-value"><span class="toc-text">Promise.resolve(value)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-reject-reason"><span class="toc-text">Promise.reject(reason)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">原型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-prototype-then-onFulfilled-onRejected"><span class="toc-text">Promise.prototype.then(onFulfilled, onRejected)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-prototype-catch-onRejected"><span class="toc-text">Promise.prototype.catch(onRejected)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-prototype-finally-onFinally"><span class="toc-text">Promise.prototype.finally(onFinally)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Async-await"><span class="toc-text">Async&#x2F;await</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%AD%90"><span class="toc-text">事件循环机制⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95%E3%80%81%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-text">展开语法、剩余参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator%E5%87%BD%E6%95%B0"><span class="toc-text">Generator函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-text">实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E5%90%8C%E6%AD%A5%E5%8C%96%E8%A1%A8%E8%BE%BE"><span class="toc-text">异步操作的同步化表达</span></a></li></ol></li></ol></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81"><span class="toc-text">手写代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E2%AD%90"><span class="toc-text">new⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-create"><span class="toc-text">Object.create()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call%E3%80%81apply%E3%80%81bind%E5%8C%BA%E5%88%AB"><span class="toc-text">call、apply、bind区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-call"><span class="toc-text">模拟实现 call</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-apply"><span class="toc-text">模拟实现 apply</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0bind"><span class="toc-text">模拟实现bind</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81"><span class="toc-text">防抖&#x2F;节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96"><span class="toc-text">防抖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E7%AB%8B%E5%8D%B3%E9%98%B2%E6%8A%96"><span class="toc-text">非立即防抖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E9%98%B2%E6%8A%96"><span class="toc-text">立即防抖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%B5%81"><span class="toc-text">节流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E5%AE%9E%E7%8E%B0"><span class="toc-text">时间戳实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">定时器实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax%E2%AD%90"><span class="toc-text">Ajax⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9FAjax"><span class="toc-text">原生Ajax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fetch"><span class="toc-text">Fetch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise%E5%B0%81%E8%A3%85axios"><span class="toc-text">Promise封装axios</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof"><span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-1"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-text">原型链继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">借用构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-text">寄生组合式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6%E7%B1%BB%E7%BB%A7%E6%89%BFextends"><span class="toc-text">ES6类继承extends</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise"><span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%BB%84"><span class="toc-text">拷贝数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-text">数组去重</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95Set"><span class="toc-text">最简单Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#indexOf-includes-for-forEach"><span class="toc-text">indexOf&#x2F;includes+for&#x2F;forEach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filter%E9%85%8D%E5%90%88indexOf"><span class="toc-text">filter配合indexOf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce%E9%85%8D%E5%90%88includes"><span class="toc-text">reduce配合includes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E6%95%B0%E7%BB%84%E7%9B%B4%E6%8E%A5%E5%8E%BB%E9%87%8D"><span class="toc-text">原数组直接去重</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-text">如何实现数组扁平化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B0%E6%96%B9%E6%B3%95-flat-depth"><span class="toc-text">ES6提供的新方法 flat(depth)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce%E6%96%B9%E6%B3%95-%E9%80%92%E5%BD%92"><span class="toc-text">reduce方法 递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E9%93%BA%E6%95%B0%E7%BB%84%E8%BD%AC%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="toc-text">平铺数组转树形结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84shuffle"><span class="toc-text">随机打乱数组shuffle</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">计算机网络和浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">计算机网络体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-text">传输层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="toc-text">网络接口层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-text">数据链路层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-text">物理层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BD%91%E7%BB%9C%E8%A6%81%E5%88%86%E5%B1%82%EF%BC%9F"><span class="toc-text">为什么网络要分层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-text">网络通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E2%AD%90"><span class="toc-text">HTTP⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E6%96%B9%E6%B3%95"><span class="toc-text">HTTP方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GET-%E4%B8%8E-POST"><span class="toc-text">GET 与 POST</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F"><span class="toc-text">参数传递方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E4%B8%8D%E5%90%8C"><span class="toc-text">参数长度限制不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%92%8C%E5%B9%82%E7%AD%89"><span class="toc-text">安全和幂等</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8D%E5%90%8C%EF%BC%88%E4%BC%A0%E8%BE%93%E7%9A%84%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="toc-text">安全性不同（传输的角度）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%B8%8D%E5%90%8C"><span class="toc-text">缓存机制不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%B6%88%E8%80%97%E4%B8%8D%E5%90%8C"><span class="toc-text">时间消耗不同</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HEAD"><span class="toc-text">HEAD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUT"><span class="toc-text">PUT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DELETE"><span class="toc-text">DELETE</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%BC%93%E5%AD%98"><span class="toc-text">HTTP缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%EF%BC%88%E5%BC%BA%E7%BC%93%E5%AD%98%E3%80%81%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%89"><span class="toc-text">基本流程（强缓存、协商缓存）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-text">缓存发展历程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89Etag"><span class="toc-text">为什么要有Etag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%88%B7%E6%96%B0%E7%9A%84%E8%AF%B7%E6%B1%82%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">不同刷新的请求执行过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%89%B9%E6%80%A7"><span class="toc-text">HTTP特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%88%83%E5%89%91"><span class="toc-text">双刃剑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS"><span class="toc-text">HTTP和HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-text">区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E4%BC%98%E7%82%B9"><span class="toc-text">HTTPS优点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86"><span class="toc-text">混合加密</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-text">数字证书</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95"><span class="toc-text">摘要算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E8%BF%9E%E6%8E%A5"><span class="toc-text">HTTPS连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1%E3%80%81HTTP-2%E3%80%81HTTP-3%E6%BC%94%E5%8F%98"><span class="toc-text">HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3演变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-1"><span class="toc-text">HTTP&#x2F;1.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-2"><span class="toc-text">HTTP&#x2F;2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-3"><span class="toc-text">HTTP&#x2F;3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E2%AD%90"><span class="toc-text">跨域通信⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">跨域解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSONP"><span class="toc-text">JSONP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS"><span class="toc-text">CORS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ECORS%E7%9A%84-cookie-%E9%97%AE%E9%A2%98"><span class="toc-text">关于CORS的 cookie 问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86"><span class="toc-text">代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Node%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-text">Node中间件代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#React%E4%B8%AD%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86"><span class="toc-text">React中配置代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">Nginx反向代理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocket"><span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XSS%E5%92%8CCSRF"><span class="toc-text">XSS和CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS"><span class="toc-text">XSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%98%B2%E8%8C%83%E6%96%B9%E6%B3%95"><span class="toc-text">常用防范方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF"><span class="toc-text">CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CSRF%E4%B8%8E-XSS-%E5%8C%BA%E5%88%AB"><span class="toc-text">CSRF与 XSS 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1"><span class="toc-text">防御</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-UDP"><span class="toc-text">TCP UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-text">TCP 协议如何保证可靠传输</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%E2%AD%90"><span class="toc-text">从URL输入到页面展现到底发生什么？⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URL%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">URL是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%EF%BC%88DNS%EF%BC%89"><span class="toc-text">域名解析（DNS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">TCP三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E5%BC%80TCP%E8%BF%9E%E6%8E%A5-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">断开TCP连接 四次挥手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2"><span class="toc-text">浏览器解析渲染页面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81%EF%BC%88Repaint%E3%80%81Reflow%EF%BC%89"><span class="toc-text">浏览器的重绘与回流（Repaint、Reflow）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%B5%81-%E9%87%8D%E6%8E%92reflow"><span class="toc-text">回流&#x2F;重排reflow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BB%98Repaint"><span class="toc-text">重绘Repaint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81-%E9%87%8D%E7%BB%98%E8%87%B3%E5%B0%91%E6%9C%80%E5%B0%8F%E5%8C%96%E5%AE%83%E4%BB%AC%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-text">如何避免回流&#x2F;重绘至少最小化它们对性能的影响？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-dom-%E6%A0%91%E4%B8%AD%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%8E%E5%9C%B0%E6%9B%B4%E6%94%B9%E7%B1%BB"><span class="toc-text">在 dom 树中尽可能低地更改类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E8%AE%BE%E7%BD%AE%E5%A4%9A%E4%B8%AA%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F"><span class="toc-text">避免设置多个内联样式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%8A%A8%E7%94%BB%E5%88%B0fixed%E6%88%96absolute%E7%9A%84%E5%AE%9A%E4%BD%8D"><span class="toc-text">应用动画到fixed或absolute的定位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E8%A1%A8%E6%A0%BC%E8%BF%9B%E8%A1%8C%E5%B8%83%E5%B1%80%EF%BC%88%E6%88%96%E8%AE%BE%E7%BD%AE%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80%E5%9B%BA%E5%AE%9A%EF%BC%89"><span class="toc-text">避免使用表格进行布局（或设置表格布局固定）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E9%A2%91%E7%B9%81%E6%93%8D%E4%BD%9CDOM"><span class="toc-text">避免频繁操作DOM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E2%AD%90"><span class="toc-text">Cookie、Session、Token、JWT⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie%E3%80%81sessionStorage%E3%80%81localStorage-%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E2%AD%90"><span class="toc-text">Cookie、sessionStorage、localStorage 详解及应用场景⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie"><span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#localStorage-amp-amp-sessionStorage"><span class="toc-text">localStorage &amp;&amp; sessionStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IndexedDB"><span class="toc-text">IndexedDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">前端性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B"><span class="toc-text">性能检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC"><span class="toc-text">基本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9"><span class="toc-text">压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CDN"><span class="toc-text">CDN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">懒加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">预加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iconfont"><span class="toc-text">iconfont</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-text">组件渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-text">缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EAndroid%E7%9A%84%E7%94%B5%E5%AD%90%E8%AF%8D%E5%85%B8%E8%AE%BE%E8%AE%A1"><span class="toc-text">基于Android的电子词典设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E7%88%AC%E5%8F%96"><span class="toc-text">单词数据的爬取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Requests"><span class="toc-text">Requests</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XPath"><span class="toc-text">XPath</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-text">多进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQLite"><span class="toc-text">SQLite</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1"><span class="toc-text">界面设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API%E6%88%96SDK"><span class="toc-text">API或SDK</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-text">API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDK"><span class="toc-text">SDK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM"><span class="toc-text">MVVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-MVVM"><span class="toc-text">Android MVVM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#One-Piece-%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">One Piece 商城后台管理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">项目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE"><span class="toc-text">后端数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">模块化、组件化、工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96-1"><span class="toc-text">模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">工程化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="toc-text">组件化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A9%E6%B0%94API"><span class="toc-text">天气API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2"><span class="toc-text">界面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80"><span class="toc-text">居中布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Flex"><span class="toc-text">Flex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#margin"><span class="toc-text">margin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E4%B8%8E%E6%96%87%E5%AD%97%E5%9C%A8%E4%B8%80%E8%A1%8C%E5%86%85%E7%9A%84%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98"><span class="toc-text">图片与文字在一行内的居中问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2"><span class="toc-text">登录界面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB"><span class="toc-text">预加载动画</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%BC%8F%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="toc-text">类式组件与函数式组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-Router-v6-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">React-Router v6 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SPA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">SPA的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-text">基础使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">路由参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#param%E5%8F%82%E6%95%B0"><span class="toc-text">param参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#search%E5%8F%82%E6%95%B0-amp-sate%E5%8F%82%E6%95%B0"><span class="toc-text">search参数&amp;sate参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Antd-v3%E5%8D%87%E7%BA%A7%E6%88%90v4"><span class="toc-text">Antd v3升级成v4</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E9%99%A4-Form-create"><span class="toc-text">去除 Form.create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E6%8E%A7%E5%88%B6%E8%B0%83%E6%95%B4"><span class="toc-text">表单控制调整</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#onFinish-%E6%9B%BF%E4%BB%A3-onSubmit"><span class="toc-text">onFinish 替代 onSubmit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%B0%83%E6%95%B4"><span class="toc-text">初始化调整</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#validateFields-%E4%B8%8D%E5%86%8D%E6%94%AF%E6%8C%81-callback"><span class="toc-text">validateFields 不再支持 callback</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-text">数据可视化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-text">功能实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">登录数据持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-text">权限管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%A1%E9%AA%8C"><span class="toc-text">输入校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E5%92%8CAjax"><span class="toc-text">跨域和Ajax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E9%80%9A%E4%BF%A1"><span class="toc-text">父子通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#props"><span class="toc-text">props</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83"><span class="toc-text">发布</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BrowserRouter"><span class="toc-text">BrowserRouter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashRouter"><span class="toc-text">HashRouter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GitHub-Pages%E5%8F%91%E5%B8%83%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2"><span class="toc-text">GitHub Pages发布静态页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96"><span class="toc-text">项目优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89hook%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E9%98%B2%E6%8A%96"><span class="toc-text">自定义hook实现搜索防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E5%90%8E%E7%88%B6%E7%BA%A7%E8%8F%9C%E5%8D%95%E7%9A%84%E5%B1%95%E5%BC%80%E9%97%AE%E9%A2%98"><span class="toc-text">刷新后父级菜单的展开问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React"><span class="toc-text">React</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E6%A1%86%E6%9E%B6%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8E%9F%E7%94%9F"><span class="toc-text">为什么选择使用框架而不是原生?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-vs-Vue"><span class="toc-text">React vs Vue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJSX%EF%BC%9F"><span class="toc-text">什么是JSX？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%99"><span class="toc-text">规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM"><span class="toc-text">虚拟DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">虚拟DOM实现原理?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-%E2%80%9CReact-Fiber%E2%80%9D%EF%BC%9F"><span class="toc-text">什么是 “React Fiber”？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#diff-%E7%AE%97%E6%B3%95-%E5%8D%8F%E8%B0%83"><span class="toc-text">diff 算法&#x2F;协调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Diffing-%E7%AE%97%E6%B3%95"><span class="toc-text">Diffing 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">对比不同类型的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%90%8C%E4%B8%80%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">对比同一类型的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%84%E4%BB%B6%E5%85%83%E7%B4%A0"><span class="toc-text">对比同类型的组件元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E5%AD%90%E8%8A%82%E7%82%B9%E8%BF%9B%E8%A1%8C%E9%80%92%E5%BD%92"><span class="toc-text">对子节点进行递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Keys"><span class="toc-text">Keys</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E7%BB%84%E4%BB%B6%E5%AE%9A%E4%B9%89%E5%8C%BA%E5%88%AB"><span class="toc-text">两种组件定义区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E5%A3%B0%E6%98%8E%E7%BB%84%E4%BB%B6"><span class="toc-text">函数式声明组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%BC%8F%E7%BB%84%E4%BB%B6-%E6%9C%89%E7%8A%B6%E6%80%81-state"><span class="toc-text">类式组件(有状态 state)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-text">事件处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%9C%B0%E4%BD%BF%E7%94%A8-State"><span class="toc-text">正确地使用 State</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9-State"><span class="toc-text">不要直接修改 State</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#State-%E7%9A%84%E6%9B%B4%E6%96%B0%E5%8F%AF%E8%83%BD%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84"><span class="toc-text">State 的更新可能是异步的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#State-%E7%9A%84%E6%9B%B4%E6%96%B0%E4%BC%9A%E8%A2%AB%E5%90%88%E5%B9%B6"><span class="toc-text">State 的更新会被合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-Refs-and-the-DOM%E6%8F%AD%E7%A7%98"><span class="toc-text">React Refs and the DOM揭秘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRef"><span class="toc-text">什么是Ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B-Declarative-Programming"><span class="toc-text">什么是声明式编程(Declarative Programming)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ref%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">Ref使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ref%E7%94%A8%E6%B3%95"><span class="toc-text">Ref用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Refs"><span class="toc-text">创建 Refs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-Refs"><span class="toc-text">访问 Refs</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA-DOM-%E5%85%83%E7%B4%A0%E6%B7%BB%E5%8A%A0-ref"><span class="toc-text">为 DOM 元素添加 ref</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA-class-%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0-Ref"><span class="toc-text">为 class 组件添加 Ref</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Refs-%E4%B8%8E%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6"><span class="toc-text">Refs 与函数组件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Refs-%E8%BD%AC%E5%8F%91"><span class="toc-text">Refs 转发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">React组件通信如何实现?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3-React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%97%EF%BC%9F"><span class="toc-text">你真的了解 React 生命周期吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hooks-%E7%BB%84%E4%BB%B6"><span class="toc-text">Hooks 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">单个组件的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD"><span class="toc-text">挂载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0"><span class="toc-text">更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD"><span class="toc-text">卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-text">常用的生命周期方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#render"><span class="toc-text">render</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#constructor-props"><span class="toc-text">constructor(props)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#componentDidMount"><span class="toc-text">componentDidMount()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#componentDidUpdate-prevProps-prevState-snapshot"><span class="toc-text">componentDidUpdate(prevProps, prevState, snapshot)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#componentWillUnmount"><span class="toc-text">componentWillUnmount()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-text">不常用的生命周期方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#shouldComponentUpdate-nextProps-nextState"><span class="toc-text">shouldComponentUpdate(nextProps, nextState)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#static-getDerivedStateFromProps-props-state"><span class="toc-text">static getDerivedStateFromProps(props, state)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#getSnapshotBeforeUpdate-prevProps-prevState"><span class="toc-text">getSnapshotBeforeUpdate(prevProps, prevState)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%97%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-text">过时的生命周期方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#UNSAFE-componentWillMount"><span class="toc-text">UNSAFE_componentWillMount()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UNSAFE-componentWillReceiveProps-nextProps"><span class="toc-text">UNSAFE_componentWillReceiveProps(nextProps)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UNSAFE-componentWillUpdate-nextProps-nextState"><span class="toc-text">UNSAFE_componentWillUpdate(nextProps, nextState)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-API"><span class="toc-text">其他 API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#setState-updater-callback"><span class="toc-text">setState(updater, [callback])</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#component-forceUpdate-callback"><span class="toc-text">component.forceUpdate(callback)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hook"><span class="toc-text">Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook-%E8%A7%84%E5%88%99"><span class="toc-text">Hook 规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E5%9C%A8%E6%9C%80%E9%A1%B6%E5%B1%82%E4%BD%BF%E7%94%A8-Hook"><span class="toc-text">只在最顶层使用 Hook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E5%9C%A8-React-%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8-Hook"><span class="toc-text">只在 React 函数中调用 Hook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useState"><span class="toc-text">useState</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%A6%81"><span class="toc-text">概要</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%83%BD%E7%94%A8%E5%85%B6%E4%BB%96%E7%8A%B6%E6%80%81%E8%AE%A1%E7%AE%97%E5%87%BA%E6%9D%A5%E5%B0%B1%E4%B8%8D%E7%94%A8%E5%8D%95%E7%8B%AC%E5%A3%B0%E6%98%8E%E7%8A%B6%E6%80%81%E3%80%82"><span class="toc-text">能用其他状态计算出来就不用单独声明状态。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%94%AF%E4%B8%80"><span class="toc-text">保证数据源唯一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#useState-%E9%80%82%E5%BD%93%E5%90%88%E5%B9%B6"><span class="toc-text">useState 适当合并</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%9B%B4%E6%96%B0"><span class="toc-text">函数式更新</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B-state"><span class="toc-text">惰性初始 state</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%B3%E8%BF%87-state-%E6%9B%B4%E6%96%B0"><span class="toc-text">跳过 state 更新</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useEffect"><span class="toc-text">useEffect</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E9%9C%80%E6%B8%85%E9%99%A4%E7%9A%84-effect"><span class="toc-text">无需清除的 effect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B8%85%E9%99%A4%E7%9A%84-effect"><span class="toc-text">需要清除的 effect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-1"><span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA-Effect-%E5%AE%9E%E7%8E%B0%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB"><span class="toc-text">使用多个 Effect 实现关注点分离</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%B7%B3%E8%BF%87-Effect-%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">通过跳过 Effect 进行性能优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E7%9A%84-effect-%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A2%91%E7%B9%81%E5%8F%98%E5%8C%96%EF%BC%8C%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">如果我的 effect 的依赖频繁变化，我该怎么办？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#effect-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA"><span class="toc-text">effect 的执行时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%90%86%E8%A7%A3"><span class="toc-text">自己理解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useRef"><span class="toc-text">useRef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useCallback"><span class="toc-text">useCallback</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-2"><span class="toc-text">补充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">关于使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useMemo"><span class="toc-text">useMemo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useImperativeHandle"><span class="toc-text">useImperativeHandle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useReducer"><span class="toc-text">useReducer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B-state"><span class="toc-text">指定初始 state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">惰性初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%BF%87-dispatch"><span class="toc-text">跳过 dispatch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useContext"><span class="toc-text">useContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89hook"><span class="toc-text">自定义hook</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-memo"><span class="toc-text">React.memo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#React-PureComponent"><span class="toc-text">React.PureComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-memo-1"><span class="toc-text">React.memo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Context"><span class="toc-text">Context</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setState-%E6%98%AF%E5%90%8C%E6%AD%A5%EF%BC%8C%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84%EF%BC%9F"><span class="toc-text">setState 是同步，还是异步的？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redux"><span class="toc-text">Redux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redux%E7%90%86%E8%A7%A3"><span class="toc-text">redux理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8redux"><span class="toc-text">什么情况下需要使用redux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redux%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">redux工作流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redux%E7%9A%84%E4%B8%89%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">redux的三个核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#action"><span class="toc-text">action</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reducer"><span class="toc-text">reducer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#store"><span class="toc-text">store</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%9A%E5%AE%A2"><span class="toc-text">博客</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript"><span class="toc-text">TypeScript</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1"><span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%A0%E9%81%93"><span class="toc-text">渠道</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/f0ca7a3c.html" title="基于类 vs 基于原型的语言"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/5.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="基于类 vs 基于原型的语言"></a><div class="content"><a class="title" href="/posts/f0ca7a3c.html" title="基于类 vs 基于原型的语言">基于类 vs 基于原型的语言</a><time datetime="2022-03-22T03:32:47.000Z" title="发表于 2022-03-22 11:32:47">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d7c881ac.html" title="Express"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/6.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="Express"></a><div class="content"><a class="title" href="/posts/d7c881ac.html" title="Express">Express</a><time datetime="2022-03-15T08:11:03.000Z" title="发表于 2022-03-15 16:11:03">2022-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/783ce8a9.html" title="移动端适配"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/2.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="移动端适配"></a><div class="content"><a class="title" href="/posts/783ce8a9.html" title="移动端适配">移动端适配</a><time datetime="2022-03-12T07:04:52.000Z" title="发表于 2022-03-12 15:04:52">2022-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/50cb7bb5.html" title="Cookie、Session、Token、JWT"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/14.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="Cookie、Session、Token、JWT"></a><div class="content"><a class="title" href="/posts/50cb7bb5.html" title="Cookie、Session、Token、JWT">Cookie、Session、Token、JWT</a><time datetime="2022-03-11T03:11:11.000Z" title="发表于 2022-03-11 11:11:11">2022-03-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5c76f87e.html" title="XSS和CSRF"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/10.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="XSS和CSRF"></a><div class="content"><a class="title" href="/posts/5c76f87e.html" title="XSS和CSRF">XSS和CSRF</a><time datetime="2022-03-10T04:01:23.000Z" title="发表于 2022-03-10 12:01:23">2022-03-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Leslie Waong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:""},null))},e=()=>{twikoo.getCommentsCount({envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))},n=(n=!1)=>{"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})};btf.loadComment(document.getElementById("twikoo-wrap"),n)})()</script></div><div class="aplayer no-destroy" data-id="6995412795" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="auto" data-autoplay="true" muted></div><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":0,"vOffset":0},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body></html>