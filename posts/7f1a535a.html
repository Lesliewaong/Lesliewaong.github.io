<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>React相关问题 | Leslie Waong</title><meta name="keywords" content="React,框架"><meta name="author" content="Leslie Waong"><meta name="copyright" content="Leslie Waong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="为什么选择使用框架而不是原生?框架的好处:  组件化: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。 天然分层: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。 生态: 现在主流前端框架都自带生态,不管是数据流管理架构还是"><meta property="og:type" content="article"><meta property="og:title" content="React相关问题"><meta property="og:url" content="https://lesliewaong.top/posts/7f1a535a.html"><meta property="og:site_name" content="Leslie Waong"><meta property="og:description" content="为什么选择使用框架而不是原生?框架的好处:  组件化: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。 天然分层: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。 生态: 现在主流前端框架都自带生态,不管是数据流管理架构还是"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/12.jpg"><meta property="article:published_time" content="2021-12-01T07:22:27.000Z"><meta property="article:modified_time" content="2022-03-17T09:44:10.486Z"><meta property="article:author" content="Leslie Waong"><meta property="article:tag" content="React"><meta property="article:tag" content="框架"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/12.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg"><link rel="canonical" href="https://lesliewaong.top/posts/7f1a535a"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"一年之内的产物",messageNext:"技术可能存在过期"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Leslie Waong",link:"链接: ",source:"来源: Leslie Waong",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"React相关问题",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-03-17 17:44:10"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px");const a=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};a(),document.addEventListener("pjax:complete",a)})(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Leslie Waong" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/12.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leslie Waong</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">React相关问题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-01T07:22:27.000Z" title="发表于 2021-12-01 15:22:27">2021-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-17T09:44:10.486Z" title="更新于 2022-03-17 17:44:10">2022-03-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="React相关问题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="为什么选择使用框架而不是原生"><a href="#为什么选择使用框架而不是原生" class="headerlink" title="为什么选择使用框架而不是原生?"></a>为什么选择使用框架而不是原生?</h1><p>框架的好处:</p><ol><li><strong>组件化</strong>: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。</li><li><strong>天然分层</strong>: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。</li><li><strong>生态</strong>: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案。</li><li><strong>开发效率</strong>: 现代前端框架都默认自动更新DOM,而非我们手动操作,解放了开发者的手动DOM成本,提高开发效率,从根本上解决了UI 与状态同步问题。</li></ol><h1 id="什么是JSX？"><a href="#什么是JSX？" class="headerlink" title="什么是JSX？"></a>什么是JSX？</h1><p>JSX 是JavaScript XML 的简写。是 React 使用的一种文件，它利用 JavaScript 的表现力和类似 HTML 的模板语法。这使得 HTML 文件非常容易理解。此文件能使应用非常可靠，并能够提高其性能。</p><p>浏览器只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX。所以为了使浏览器能够读取 JSX，首先，需要用像 Babel 这样的 JSX 转换器将 JSX 文件转换为 JavaScript 对象，然后再将其传给浏览器。</p><h1 id="深入diff-算法"><a href="#深入diff-算法" class="headerlink" title="深入diff 算法"></a>深入diff 算法</h1><p>diff 作为 Virtual DOM 的加速器，其算法上的改进优化是React页面渲染的基础和性能保障。</p><p>React 中醉值得称道的莫过于Virtual DOM与diff的完美结合，尤其是其高效的diff算法，可以帮助我们在页面蔌渲染的时候，计算出Virtual DOM真正变化的部分，并只针对该部分进行的原生DOM操作，而不是渲染整个页面，从而保证了每次操作后，页面的高效渲染。</p><h3 id="一-传统的-diff-算法"><a href="#一-传统的-diff-算法" class="headerlink" title="一. 传统的 diff 算法"></a>一. 传统的 diff 算法</h3><p>计算一个树形结构转换成另一个树形结构的最少操作，是一个复杂且值得研究的问题，传统 diff 算法通过循环递归的方法对节点进行操作，算法复杂度 为<code>O(n^3)</code>，其中n为树中节点的总数，这效率太低了，如果 React 只是单纯的引入 diff 算法，而没有任何的优化的话，其效率远远无法满足前端渲染所需要的性能。那么React 是如何实现一个高效、稳定的 diff 算法。</p><h3 id="二-React中diff算法"><a href="#二-React中diff算法" class="headerlink" title="二. React中diff算法"></a>二. React中diff算法</h3><ul><li>把树形结构按照层级分解，只比较同级元素。</li><li>给列表结构的每个单元添加唯一的<code>key</code>属性，方便比较。</li><li><code>React</code> 只会匹配相同 <code>class</code> 的 <code>component</code>（这里面的<code>class</code>指的是组件的名字）</li><li>合并操作，调用 <code>component</code> 的 <code>setState</code> 方法的时候, <code>React</code> 将其标记为 - <code>dirty</code>.到每一个事件循环结束, <code>React</code> 检查所有标记 <code>dirty</code>的 <code>component</code>重新绘制.</li><li>选择性子树渲染。开发人员可以重写<code>shouldComponentUpdate</code>提高<code>diff</code>的性能</li></ul><h3 id="三-diff-源码解读"><a href="#三-diff-源码解读" class="headerlink" title="三. diff 源码解读"></a>三. diff 源码解读</h3><p>React 将 Virtual DOM 树转换为 actual DOM 树的最小操作的过程称为<strong>调和</strong>， diff 算法便是调和的结果，React 通过制定大胆的策略，将 <code>O(n^3)</code>的时间复杂度转换成 <code>O(n)</code>。</p><h4 id="1-diff-策略"><a href="#1-diff-策略" class="headerlink" title="1. diff 策略"></a>1. diff 策略</h4><p>下面是 React diff 算法的 3 个策略：</p><ul><li>策略一：Web UI 中 DOM 节点跨层级的移动操作特别少。可以忽略不计。</li><li>策略二：拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。</li><li>策略三：对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</li></ul><p>基于以上三个策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化。</p><h4 id="2-tree-diff"><a href="#2-tree-diff" class="headerlink" title="2. tree diff"></a>2. tree diff</h4><p>对于策略一，React 对树的算法进行了简单明了的优化，即对树进行分层比较，两颗树只会对同一层级的节点进行比较。</p><p>既然 DOM 节点跨层级的移动，可以少到忽略不计，针对这种现象，React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只对相同层级的DOM节点进行比较，即同一父节点下的所有子节点，当发现该节点已经不存在时，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个DOM树的比较。</p><p>那么就会有这样的问题：</p><p><strong>如果出现了 DOM 节点跨层级的移动操作，diff 会有怎样的表现喃？</strong></p><p>我们举个例子看一下：</p><p>如下图2-1，A节点（包括其子节点）整个需要跨层级移动到D节点下，React会如何操作喃？ <img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/2019020115283720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1bmFoYWlqaWFv,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <strong>图2-1 DOM层级变换</strong></p><p>由于 React 只会简单的考虑同层级节点的位置变换，对于不同层级的节点，只有创建和删除操作。当根节点R发现子节点中A消失了，就会直接销毁A；当D节点发现多了一个子节点A，就会创建新的A子节点（包括其子节点）。执行的操作为：</p><p>create A —&gt; create B —&gt; create C —&gt; delete A</p><p>所以。当出现节点跨级移动时，并不会像想象中的那样执行移动操作，而是以 A 为根节点的整个树被整个重新创建，这是影响 React 性能的操作，所以 <strong>官方建议不要进行 DOM 节点跨层级的操作</strong>。</p><blockquote><p>在开发组件中，保持稳定的 DOM 结构有助于性能的提升。例如，可以通过CSS隐藏或显示节点，而不是真正的移除或添加 DOM 节点。</p></blockquote><h4 id="3-component-diff"><a href="#3-component-diff" class="headerlink" title="3. component diff"></a>3. component diff</h4><p>React 是基于组件构建应用的，对于组件间的比较所采取的策略也是非常简洁、高效的。</p><ul><li>如果是同一类型的组件，按照原策略继续比较 Virtual DOM 树即可</li><li>如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点</li><li>对于同一类型下的组件，有可能其 Virtual DOM 没有任何变化，如果能确切知道这一点，那么就可以节省大量的 diff 算法时间。因此， React 允许用户通过 <code>shouldComponentUpdate()</code>来判断该组件是否需要大量 diff 算法分析。</li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20190201152905802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1bmFoYWlqaWFv,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <strong>图3-1 component diff</strong></p><p>如上图3-1，当 D 组件变成 G 时，即使这两个组件结构相似，但一旦 React 判断D和G是两个不同类型的组件时，就不会再比较这两个组件的结构，直接进行删除组件D， 重新创建组件G及其子组件。虽然这两个组件是不同类型单结构类似，diff 算法会影响性能，正如 React 官方博客所言：</p><p><strong>不同类型的组件很少存在相似 DOM 树的情况，因此，这种极端因素很难在实际开发过程中造成重大影响。</strong></p><h4 id="4-element-diff"><a href="#4-element-diff" class="headerlink" title="4. element diff"></a>4. element diff</h4><p>当节点处于同一层级时，diff 提供三种节点操作：</p><ul><li>INSERT_MARKUP（插入）：如果新的组件类型不在旧集合里，即全新的节点，需要对新节点执行插入操作。</li><li>MOVE_EXISTING （移动）：旧集合中有新组件类型，且 element 是可更新的类型，generatorComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。</li><li>REMOVE_NODE （删除）：旧组件类型，在新集合里也有，但对应的 elememt 不同则不能直接复用和更新，需要执行删除操作，或者旧组件不在新集合里的，也需要执行删除操作。</li></ul><p>下面三个例子加深我们的理解</p><p>例1：旧集合A、B、C、D四个节点，更新后的新集合为B、A、D、C节点，对新旧集合进行 diff 算法差异化对比，发现 B!=A，则创建并插入B节点到新集合，并删除旧集合中A，以此类推，创建A、D、C，删除 B、C、D。如下图4-1 <img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20190201152945879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1bmFoYWlqaWFv,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <strong>图4-1 节点 diff</strong></p><p>React发现这样操作非常繁琐冗余，因为这些集合里含有相同的节点，只是节点位置发生了变化而已，却发生了繁琐的删除、创建操作，实际上只需要对这些节点进行简单的位置移动即可。</p><p><strong>针对这一现象，React 提出了优化策略：</strong></p><p><strong>允许开发者对同一层级的同组子节点，添加唯一key进行区分，虽然只是小小的改动，但性能上却发生了翻天覆地的变化。</strong></p><blockquote><p>例2：看下图</p></blockquote><p>进行对新旧集合的 diff 差异化对比，通过 key 发现新旧集合中包含的节点是一样的，所以可以通过简单的位置移动就可以更新为新集合，React 给出的 diff 结果为：B、D不做任何操作，A、C移动即可。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20190201153009142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1bmFoYWlqaWFv,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <strong>图4-2 对节点进行 diff 差异化对比</strong></p><p>步骤：</p><ul><li>初始化，lastIndex = 0， nextIndex = 0</li><li>从新集合取出节点B，发现旧集合中也有节点B，并且B.__mountIndex = 1，lastIndex = 0，不满足 B._mountIndex &lt; lastIndex，则不对B操作，并且更新 lastIndex= Math.max(prevChild._mountIndex, lastIndex)，并将B的位置更新为新集合中的位置prevChild._mountIndex = nextIndex，即B._mountIndex = 0, nextIndex ++ 进入下一步</li><li>从新集合取出节点A，发现旧集合中也有节点A，并且A.__mountIndex = 0，lastIndex = 1，满足 A._mountIndex &lt; lastIndex，则对A进行移动操作，enqueue( updates, makeMove(prevChild, lastPlacedNode, nextIndex))并且更新 lastIndex= Math.max(prevChild._mountIndex, lastIndex)，并将A的位置更新为新集合中的位置prevChild._mountIndex = nextIndex，即A._mountIndex = 1, nextIndex ++ 进入下一步</li><li>依次进行操作</li></ul><blockquote><p>例3：看下图</p></blockquote><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20190201153056179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1bmFoYWlqaWFv,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <strong>图4-3 创建、移动、删除节点</strong></p><p>可以看出在这个例子中，有新增的节点，还有需要删除的节点，具体怎么操作，请大胆的尝试一下吧。</p><h1 id="虚拟DOM的优劣如何"><a href="#虚拟DOM的优劣如何" class="headerlink" title="虚拟DOM的优劣如何?"></a>虚拟DOM的优劣如何?</h1><p>优点:</p><ul><li><strong>保证性能下限</strong>: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限</li><li><strong>无需手动操作DOM</strong>: 虚拟DOM的diff和patch都是在一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率</li><li><strong>跨平台</strong>: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等</li></ul><p>缺点:</p><ul><li><strong>无法进行极致优化</strong>: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化,比如VScode采用直接手动操作DOM的方式进行极端的性能优化</li></ul><h2 id="虚拟DOM实现原理"><a href="#虚拟DOM实现原理" class="headerlink" title="虚拟DOM实现原理?"></a>虚拟DOM实现原理?</h2><p>Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。</p><ul><li>每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。</li><li>然后计算之前 DOM 表示与新表示的之间的差异。</li><li>完成计算后，将只用实际更改的内容更新 real DOM。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myId = <span class="string">&#x27;aTgUiGu&#x27;</span></span><br><span class="line"><span class="keyword">const</span> myData = <span class="string">&#x27;HeLlo,rEaCt&#x27;</span></span><br><span class="line"><span class="comment">//1.创建虚拟DOM</span></span><br><span class="line"><span class="keyword">const</span> VDOM = (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span> <span class="attr">id</span>=<span class="string">&#123;myId.toLowerCase()&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span>&#x27;<span class="attr">white</span>&#x27;,<span class="attr">fontSize:</span>&#x27;<span class="attr">29px</span>&#x27;&#125;&#125;&gt;</span>&#123;myData.toLowerCase()&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span> <span class="attr">id</span>=<span class="string">&#123;myId.toUpperCase()&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span>&#x27;<span class="attr">white</span>&#x27;,<span class="attr">fontSize:</span>&#x27;<span class="attr">29px</span>&#x27;&#125;&#125;&gt;</span>&#123;myData.toLowerCase()&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//2.渲染虚拟DOM到页面</span></span><br><span class="line">ReactDOM.render(VDOM,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>))</span><br></pre></td></tr></table></figure><h1 id="两种组件定义区别"><a href="#两种组件定义区别" class="headerlink" title="两种组件定义区别"></a>两种组件定义区别</h1><h3 id="①函数式声明组件"><a href="#①函数式声明组件" class="headerlink" title="①函数式声明组件"></a>①函数式声明组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1.创建函数式组件</span><br><span class="line">function MyComponent()&#123;</span><br><span class="line">    console.log(this); //此处的this是undefined，因为babel编译后开启了严格模式</span><br><span class="line">    return &lt;h2&gt;我是用函数定义的组件(适用于【简单组件】的定义)&lt;/h2&gt;</span><br><span class="line">&#125;</span><br><span class="line">//2.渲染组件到页面</span><br><span class="line">ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#x27;test&#x27;))</span><br></pre></td></tr></table></figure><p>执行了<code>ReactDOM.render(&lt;MyComponent/&gt;.......)</code>之后，发生了什么？</p><ul><li>React解析组件标签，找到了MyComponent组件。</li><li>发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。</li></ul><h3 id="②类式组件-有状态-state"><a href="#②类式组件-有状态-state" class="headerlink" title="②类式组件(有状态 state)"></a>②类式组件(有状态 state)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//1.创建类式组件</span><br><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        //render是放在哪里的？—— MyComponent的原型对象上，供实例使用。</span><br><span class="line">        //render中的this是谁？—— MyComponent的实例对象 &lt;=&gt; MyComponent组件实例对象。</span><br><span class="line">        console.log(&#x27;render中的this:&#x27;,this);</span><br><span class="line">        return &lt;h2&gt;我是用类定义的组件(适用于【复杂组件】的定义)&lt;/h2&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//2.渲染组件到页面</span><br><span class="line">ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#x27;test&#x27;))</span><br></pre></td></tr></table></figure><p>执行了<code>ReactDOM.render(&lt;MyComponent/&gt;.......)</code>之后，发生了什么？</p><ul><li><p>React解析组件标签，找到了MyComponent组件。</p></li><li><p>发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法。</p></li><li><p>将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。</p></li></ul><p>组件中的<code>render</code>是放在哪里的？</p><p>​ <strong>MyComponent的原型对象上，供实例使用。</strong></p><p>组件中的<code>render</code>中的<code>this</code>是谁？</p><p>​ <strong>MyComponent的实例对象 &lt;=&gt; MyComponent组件实例对象。</strong></p><p>组件自定义方法中this为<code>undefined</code>,如何解决?</p><p>a) 强制绑定this:通过函数对象的<code>bind()</code></p><p>b) 箭头函数<code>推荐</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">	<span class="comment">//初始化状态</span></span><br><span class="line">	state = &#123;<span class="attr">isHot</span>:<span class="literal">false</span>,<span class="attr">wind</span>:<span class="string">&#x27;微风&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> &#123;isHot,wind&#125; = <span class="built_in">this</span>.state</span><br><span class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span>今天天气很&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;，&#123;wind&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自定义方法————要用赋值语句的形式+箭头函数</span></span><br><span class="line">	changeWeather = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> isHot = <span class="built_in">this</span>.state.isHot</span><br><span class="line">		<span class="built_in">this</span>.setState(&#123;<span class="attr">isHot</span>:!isHot&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.渲染组件到页面</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Weather</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>))</span><br></pre></td></tr></table></figure><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><ul><li><p>通过<code>onXxx</code>属性指定事件处理函数(注意大小写)</p><ul><li>React使用的是<strong>自定义(合成)事件,而不是使用的原生DOM事件</strong>—-为了更好的<strong>兼容性</strong></li><li>React中的事件是通过<strong>事件委托</strong>的方式处理的(委托给组件最外层的元素)—-为了更<strong>高效</strong></li></ul></li><li><p>通过<code>event.target</code>得到发生事件的DOM元素对象 —–<strong>不要过度使用ref</strong></p></li></ul><h1 id="正确地使用-State"><a href="#正确地使用-State" class="headerlink" title="正确地使用 State"></a>正确地使用 State</h1><p>关于 <code>setState()</code> 你应该了解三件事：</p><h3 id="不要直接修改-State"><a href="#不要直接修改-State" class="headerlink" title="不要直接修改 State"></a>不要直接修改 State</h3><p>例如，此代码不会重新渲染组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="built_in">this</span>.state.comment = <span class="string">&#x27;Hello&#x27;</span>;</span><br></pre></td></tr></table></figure><p>而是应该使用 <code>setState()</code>:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;<span class="attr">comment</span>: <span class="string">&#x27;Hello&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><p>构造函数是唯一可以给 <code>this.state</code> 赋值的地方。</p><h3 id="State-的更新可能是异步的"><a href="#State-的更新可能是异步的" class="headerlink" title="State 的更新可能是异步的"></a>State 的更新可能是异步的</h3><p>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用。</p><p>因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p><p>例如，此代码可能会无法更新计数器：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="built_in">this</span>.state.counter + <span class="built_in">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要解决这个问题，可以让 <code>setState()</code> 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">counter</span>: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>上面使用了<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>，不过使用普通的函数也同样可以：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function"><span class="keyword">function</span>(<span class="params">state, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">counter</span>: state.counter + props.increment</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>setState更新状态的2种写法</strong></p><ul><li><p><code>setState(stateChange, [callback])</code>——对象式的setState</p><ul><li>stateChange为状态改变对象(该对象可以体现出状态的更改)</li><li>callback是可选的回调函数, 它在状态更新完毕（状态更新是异步的）、界面也更新后(render调用后)才被调用</li></ul></li><li><p>setState(updater, [callback])——函数式的setState</p><ul><li>updater为返回stateChange对象的函数。</li><li>updater可以接收到state和props。</li><li>callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。</li></ul></li></ul><p>总结:</p><ul><li>对象式的setState是函数式的setState的简写方式(<code>语法糖</code>)</li><li>使用原则：<ul><li>如果新状态不依赖于原状态 =&gt; 使用对象方式</li><li>如果新状态依赖于原状态 =&gt; 使用函数方式</li><li>如果需要在setState()执行后获取最新的状态数据, 要在第二个callback函数中读取</li></ul></li></ul><h3 id="State-的更新会被合并"><a href="#State-的更新会被合并" class="headerlink" title="State 的更新会被合并"></a>State 的更新会被合并</h3><p>当你调用 <code>setState()</code> 的时候，React 会把你提供的对象合并到当前的 state。</p><p>例如，你的 state 包含几个独立的变量：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        <span class="attr">posts</span>: [],      </span><br><span class="line">        <span class="attr">comments</span>: []    </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以分别调用 <code>setState()</code> 来单独地更新它们：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    fetchPosts().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            <span class="attr">posts</span>: response.posts      </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    fetchComments().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            <span class="attr">comments</span>: response.comments      </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的合并是浅合并，所以 <code>this.setState(&#123;comments&#125;)</code> 完整保留了 <code>this.state.posts</code>， 但是完全替换了 <code>this.state.comments</code>。</p><h1 id="React-Refs-and-the-DOM揭秘"><a href="#React-Refs-and-the-DOM揭秘" class="headerlink" title="React Refs and the DOM揭秘"></a>React Refs and the DOM揭秘</h1><h2 id="什么是Ref"><a href="#什么是Ref" class="headerlink" title="什么是Ref"></a>什么是Ref</h2><p>在典型的React数据流理念中，父组件跟子组件的交互都是通过传递属性(properties)实现的。如果父组件需要修改子组件，只需要将新的属性传递给子组件，由子组件来实现具体的绘制逻辑。</p><p>在特殊的情况下，如果你需要<strong>命令式(imperatively)的修改子组件</strong>，React也提供了应急的处理办法–Ref。</p><p>Ref 既支持修改<strong>DOM元素</strong>，也支持修改<strong>自定义的组件</strong>。</p><h2 id="什么是声明式编程-Declarative-Programming"><a href="#什么是声明式编程-Declarative-Programming" class="headerlink" title="什么是声明式编程(Declarative Programming)"></a>什么是声明式编程(Declarative Programming)</h2><p>值得一提的是当中声明式编程(Declarative Programming)和命令式编程(Imperative Programming)的区别。</p><p>声明式编程的特点是只描述要实现的结果，而不关心如何一步一步实现的，而命令式编程则相反，必须每个步骤都写清楚。</p><p>我们可以根据语义直观的理解代码的功能是：针对数组的每一个元素，将它的值打印出来。不必关心实现其的细节。</p><p>而命令式编程必须将每行代码读懂，然后再整合起来理解总体实现的功能。</p><p>React有2个基石设计理念：一个是声明式编程，一个是函数式编程。函数式编程以后有机会再展开讲。声明式编程的特点体现在2方面：</p><p>组件定义的时候，所有的实现逻辑都封装在组件的内部，通过state管理，对外只暴露属性。</p><p>组件使用的时候，组件调用者通过传入不同属性的值来达到展现不同内容的效果。一切效果都是事先定义好的，至于效果是怎么实现的，组件调用者不需要关心。</p><p>因此，在使用React的时候，一般很少需要用到Ref。那么，Ref的使用场景又是什么？</p><h2 id="Ref使用场景"><a href="#Ref使用场景" class="headerlink" title="Ref使用场景"></a>Ref使用场景</h2><p>简单理解就是，控制一些DOM原生的效果，如输入框的聚焦效果和选中效果等；触发一些命令式的动画；集成第三方的DOM库。最后还补了一句：如果要实现的功能可以通过声明式的方式实现，就不要借助Ref。</p><p>通常我们会利用 render 方法得到一个 App 组件的实例，然后就可以对它做一些操作。但在组件内，JSX 是不会返回一个组件的实例的，它只是一个ReactElement，只是告诉你，React被挂载的组件应该涨什么样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myApp = <span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><p>refs就是由此而生，它是React组件中非常特殊的props， 可以附加到任何一个组件上，从字面意思上看，ref即reference，组件被调用时会创建一个该组件的实例，而ref就会指向这个实例。</p><h2 id="Ref用法"><a href="#Ref用法" class="headerlink" title="Ref用法"></a>Ref用法</h2><p>如果作用在原生的DOM元素上，通过Ref获取的是DOM元素，可以直接操作DOM的API：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;    </span><br><span class="line">        <span class="built_in">super</span>(props);        </span><br><span class="line">        <span class="built_in">this</span>.focusTextInput = <span class="built_in">this</span>.focusTextInput.bind(<span class="built_in">this</span>);  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="title">focusTextInput</span>(<span class="params"></span>)</span> &#123;    </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.myTextInput !== <span class="literal">null</span>) &#123;         </span><br><span class="line">            <span class="built_in">this</span>.textInput.current.focus();    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;    </span><br><span class="line">        <span class="keyword">return</span> (      </span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>        </span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;(ref)</span> =&gt;</span> this.myTextInput = ref&#125; /&gt;        </span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Focus the text input&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.focusTextInput&#125;/</span>&gt;</span>      </span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>    </span><br><span class="line"></span><br><span class="line">        );  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果作用在自定义组件，Ref获取的是组件的实例，可以直接操作组件内的任意方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoFocusTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;    </span><br><span class="line">        <span class="built_in">super</span>(props);    </span><br><span class="line">        <span class="built_in">this</span>.textInput = React.createRef();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;    </span><br><span class="line">        <span class="built_in">this</span>.textInput.current.focusTextInput();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;    </span><br><span class="line">        <span class="keyword">return</span> (      </span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">CustomTextInput</span> <span class="attr">ref</span>=<span class="string">&#123;this.textInput&#125;</span> /&gt;</span></span>    </span><br><span class="line">        );  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ref总结"><a href="#Ref总结" class="headerlink" title="Ref总结"></a>Ref总结</h2><p>为了防止内存泄漏，当卸载一个组件时，组件里所有的refs就会变成null。</p><p>值得注意的是，<code>findDOMNode</code> 和 <code>refs</code> 都无法用于无状态组件中。因为，无状态组件挂载时只是方法调用，并没有创建实例。</p><p>对于 React 组件来讲，refs 会指向一个组件类实例，所以可以调用该类定义的任何方法。如果需要访问该组件的真实DOM ，可以用 ReactDOM 。findDOMNode来找到DOM节点，但并不推荐这样做，因为这大部分情况下都打破了封装性，而且通常都能用更清晰的方法在React中构建代码。</p><h1 id="React组件通信如何实现"><a href="#React组件通信如何实现" class="headerlink" title="React组件通信如何实现?"></a>React组件通信如何实现?</h1><p>React组件间通信方式:</p><ul><li><strong>父组件</strong>向<strong>子组件</strong>通讯: 父组件可以向子组件通过传 <strong>props</strong> 的方式，向子组件进行通讯</li><li><strong>子组件</strong>向<strong>父组件</strong>通讯: <strong>props+回调</strong>的方式,父组件向子组件传递props进行通讯，此props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中</li><li>兄弟组件通信: <strong>找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信息进行通信</strong></li><li>跨层级通信: <code>Context</code>设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过<code>Context</code>通信再适合不过</li><li>发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入event模块进行通信</li><li>全局状态管理工具: 借助<code>Redux</code>或者<code>Mobx</code>等全局状态管理工具进行通信,这种工具会维护一个全局状态中心Store,并根据不同的事件产生新的状态</li></ul><p>比较好的搭配方式</p><ul><li>父子组件：props</li><li>兄弟组件：消息订阅-发布、集中式管理</li><li>祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(开发用的少，封装插件用的多)</li></ul><h1 id="你真的了解-React-生命周期吗？"><a href="#你真的了解-React-生命周期吗？" class="headerlink" title="你真的了解 React 生命周期吗？"></a>你真的了解 React 生命周期吗？</h1><p>React 生命周期很多人都了解，但通常我们所了解的都是 <strong>单个组件</strong> 的生命周期，但针对 <strong>Hooks 组件、多个关联组件</strong>（父子组件和兄弟组件） 的生命周期又是怎么样？</p><p>关于 <strong>组件</strong> ，我们这里指的是 <code>React.Component</code> 以及 <code>React.PureComponent</code> ，但是否包括 Hooks 组件？</p><h2 id="一、Hooks-组件"><a href="#一、Hooks-组件" class="headerlink" title="一、Hooks 组件"></a>一、Hooks 组件</h2><p><strong>函数组件</strong> 的本质是函数，没有 state 的概念的，因此<strong>不存在生命周期</strong>一说，仅仅是一个 <strong>render 函数</strong>而已。</p><p>但是引入 <strong>Hooks</strong> 之后就变得不同了，它能让组件在不使用 class 的情况下使用 state 以及其他的 React特性，相比与 class 的生命周期概念来说，它更接近于实现状态同步，而不是响应生命周期事件。但我们可以利用 <code>useState</code>、 <code>useEffect()</code> 和 <code>useLayoutEffect()</code> 来模拟实现生命周期。</p><p>即：<strong>Hooks 组件更接近于实现状态同步，而不是响应生命周期事件</strong>。</p><p>下面，是具体的 生命周期 与 Hooks 的<strong>对应关系</strong>：</p><ul><li><p><code>constructor</code>：函数组件不需要构造函数，我们可以通过调用 <strong><code>useState</code> 来初始化 state</strong>。如果计算的代价比较昂贵，也可以传一个函数给 <code>useState</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [num, UpdateNum] = useState(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>getDerivedStateFromProps</code>：一般情况下，我们不需要使用它，我们可以在<strong>渲染过程中更新 state</strong>，以达到实现 <code>getDerivedStateFromProps</code> 的目的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ScrollView</span>(<span class="params">&#123;row&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [isScrollingDown, setIsScrollingDown] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">let</span> [prevRow, setPrevRow] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (row !== prevRow) &#123;</span><br><span class="line">    <span class="comment">// Row 自上次渲染以来发生过改变。更新 isScrollingDown。</span></span><br><span class="line">    setIsScrollingDown(prevRow !== <span class="literal">null</span> &amp;&amp; row &gt; prevRow);</span><br><span class="line">    setPrevRow(row);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Scrolling down: <span class="subst">$&#123;isScrollingDown&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 会立即退出第一次渲染并用更新后的 state 重新运行组件以避免耗费太多性能。</p></li><li><p><code>shouldComponentUpdate</code>：可以用 <strong><code>React.memo</code></strong> 包裹一个组件来对它的 <code>props</code> 进行浅比较</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = React.memo(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 具体的组件</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：**<code>React.memo</code> 等效于 <code>PureComponent</code>**，它只浅比较 props。这里也可以使用 <code>useMemo</code> 优化每一个节点。</p><p><code>PureComponent</code>重写了<code>shouldComponentUpdate()</code>, 只有state或props数据有变化才返回true。</p><p>只是进行state和props数据的<code>浅比较</code>, 如果只是数据对象内部数据变了, 返回false。</p></li><li><p><code>render</code>：这是函数组件体本身。</p></li><li><p><code>componentDidMount</code>, <code>componentDidUpdate</code>： <code>useLayoutEffect</code> 与它们两的调用阶段是一样的。但是，我们推荐你<strong>一开始先用 useEffect</strong>，只有当它出问题的时候再尝试使用 <code>useLayoutEffect</code>。<code>useEffect</code> 可以表达所有这些的组合。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// componentDidMount</span></span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 需要在 componentDidMount 执行的内容</span></span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容</span></span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 需要在 count 更改时 componentDidUpdate（先于 document.title = ... 执行，遵守先清理后更新）</span></span><br><span class="line">    <span class="comment">// 以及 componentWillUnmount 执行的内容       </span></span><br><span class="line">  &#125; <span class="comment">// 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关</span></span><br><span class="line">&#125;, [count]); <span class="comment">// 仅在 count 更改时更新</span></span><br></pre></td></tr></table></figure><p><strong>请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 <code>useEffect</code>，因此会使得额外操作很方便</strong></p></li><li><p><code>componentWillUnmount</code>：相当于 <code>useEffect</code> 里面返回的 <code>cleanup</code> 函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// componentDidMount/componentWillUnmount</span></span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 需要在 componentDidMount 执行的内容</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 需要在 componentWillUnmount 执行的内容      </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure></li><li><p><code>componentDidCatch</code> and <code>getDerivedStateFromError</code>：目前<strong>还没有</strong>这些方法的 Hook 等价写法，但很快会加上。</p></li></ul><p>为方便记忆，大致汇总成表格如下。</p><table><thead><tr><th>class 组件</th><th>Hooks 组件</th></tr></thead><tbody><tr><td>constructor</td><td>useState</td></tr><tr><td>getDerivedStateFromProps</td><td>useState 里面 update 函数</td></tr><tr><td>shouldComponentUpdate</td><td>useMemo</td></tr><tr><td>render</td><td>函数本身</td></tr><tr><td>componentDidMount</td><td>useEffect</td></tr><tr><td>componentDidUpdate</td><td>useEffect</td></tr><tr><td>componentWillUnmount</td><td>useEffect 里面返回的函数</td></tr><tr><td>componentDidCatch</td><td>无</td></tr><tr><td>getDerivedStateFromError</td><td>无</td></tr></tbody></table><h2 id="二、单个组件的生命周期"><a href="#二、单个组件的生命周期" class="headerlink" title="二、单个组件的生命周期"></a>二、单个组件的生命周期</h2><h3 id="1-生命周期"><a href="#1-生命周期" class="headerlink" title="1. 生命周期"></a>1. 生命周期</h3><h4 id="V16-3-之前"><a href="#V16-3-之前" class="headerlink" title="V16.3 之前"></a>V16.3 之前</h4><p>我们可以将生命周期分为三个阶段：</p><ul><li>挂载阶段</li><li>组件更新阶段</li><li>卸载阶段</li></ul><p>分开来讲：</p><ol><li>挂载阶段<ul><li><code>constructor</code>：避免将 props 的值复制给 state</li><li><code>componentWillMount</code></li><li><code>render</code>：react 最重要的步骤，创建虚拟 dom，进行 diff 算法，更新 dom 树都在此进行</li><li><code>componentDidMount</code></li></ul></li><li>组件更新阶段<ul><li><code>componentWillReceiveProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code></li><li><code>render</code></li><li><code>componentDidUpdate</code></li></ul></li><li>卸载阶段<ul><li><code>componentWillUnMount</code></li></ul></li></ol><p>这种生命周期会存在一个问题，那就是当更新复杂组件的最上层组件时，调用栈会很长，如果在进行复杂的操作时，就可能长时间阻塞主线程，带来不好的用户体验，<strong>Fiber</strong> 就是为了解决该问题而生。</p><h4 id="V16-3-之后"><a href="#V16-3-之后" class="headerlink" title="V16.3 之后"></a>V16.3 之后</h4><p><strong>Fiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新。</strong></p><p>对于异步渲染，分为两阶段：</p><ul><li><code>reconciliation</code>：<ul><li><code>componentWillMount</code></li><li><code>componentWillReceiveProps</code></li><li><code>shouldConmponentUpdate</code></li><li><code>componentWillUpdate</code></li></ul></li><li><code>commit</code><ul><li><code>componentDidMount</code></li><li><code>componentDidUpdate</code></li></ul></li></ul><p>其中，<code>reconciliation</code> 阶段是可以被打断的，所以 <code>reconcilation</code> 阶段执行的函数就会出现多次调用的情况，显然，这是不合理的。</p><p>所以 V16.3 引入了新的 API 来解决这个问题：</p><ol><li><p><code>static getDerivedStateFromProps</code>： 该函数在<strong>挂载阶段和组件更新阶段</strong>都会执行，即<strong>每次获取新的<code>props</code> 或 <code>state</code> 之后都会被执行</strong>，**在挂载阶段用来代替<code>componentWillMount</code>**；在组件更新阶段配合 <code>componentDidUpdate</code>，可以覆盖 <code>componentWillReceiveProps</code> 的所有用法。</p><p>同时它是一个静态函数，所以函数体内不能访问 <code>this</code>，会根据 <code>nextProps</code> 和 <code>prevState</code> 计算出预期的状态改变，返回结果会被送给 <code>setState</code><strong>，返回 <code>null</code> 则说明不需要更新 <code>state</code>，并且这个返回是必须的</strong>。</p></li><li><p><code>getSnapshotBeforeUpdate</code>: 该函数会在 <strong><code>render</code> 之后， DOM 更新前</strong>被调用，用于读取最新的 DOM 数据。</p><p>返回一个值，<strong>作为 <code>componentDidUpdate</code> 的第三个参数</strong>；配合 <code>componentDidUpdate</code>, 可以覆盖<code>componentWillUpdate</code> 的所有用法。</p></li></ol><p>注意：V16.3 中只用在组件挂载或组件 <code>props</code> 更新过程才会调用，即如果是因为自身 setState 引发或者forceUpdate 引发，而不是由父组件引发的话，那么<code>static getDerivedStateFromProps</code>也不会被调用，在 V16.4 中更正为都调用。</p><p>即更新后的生命周期为：</p><ol><li>挂载阶段<ul><li><code>constructor</code></li><li><code>static getDerivedStateFromProps</code></li><li><code>render</code></li><li><code>componentDidMount</code></li></ul></li><li>更新阶段<ul><li><code>static getDerivedStateFromProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>render</code></li><li><code>getSnapshotBeforeUpdate</code></li><li><code>componentDidUpdate</code></li></ul></li><li>卸载阶段<ul><li><code>componentWillUnmount</code></li></ul></li></ol><h3 id="2-生命周期，误区"><a href="#2-生命周期，误区" class="headerlink" title="2. 生命周期，误区"></a>2. 生命周期，误区</h3><p><strong>误解一：</strong><code>getDerivedStateFromProps</code> 和 <code>componentWillReceiveProps</code> 只会在 <code>props</code> <strong>改变</strong> 时才会调用</p><p>实际上，<strong>只要父级重新渲染，<code>getDerivedStateFromProps</code> 和 <code>componentWillReceiveProps</code> 都会重新调用，不管 <code>props</code> 有没有变化</strong>。所以，在这两个方法内直接将 props 赋值到 state 是不安全的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">phone</span>: <span class="built_in">this</span>.props.phone &#125;;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">phone</span>: e.target.value &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; phone &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> <span class="attr">value</span>=<span class="string">&#123;phone&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 不要这样做。</span></span><br><span class="line">    <span class="comment">// 这会覆盖掉之前所有的组件内 state 更新！</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">phone</span>: nextProps.phone &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用了 setInterval，</span></span><br><span class="line">    <span class="comment">// 每秒钟都会更新一下 state.count</span></span><br><span class="line">    <span class="comment">// 这将导致 App 每秒钟重新渲染一次</span></span><br><span class="line">    <span class="built_in">this</span>.interval = <span class="built_in">setInterval</span>(</span><br><span class="line">      <span class="function">() =&gt;</span></span><br><span class="line">        <span class="built_in">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">          <span class="attr">count</span>: prevState.count + <span class="number">1</span></span><br><span class="line">        &#125;)),</span><br><span class="line">      <span class="number">1000</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.interval);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">          Start editing to see some magic happen :)</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">PhoneInput</span> <span class="attr">phone</span>=<span class="string">&#x27;call me!&#x27;</span> /&gt;</span> </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">          This component will re-render every second. Each time it renders, the</span></span><br><span class="line"><span class="xml">          text you type will be reset. This illustrates a derived state</span></span><br><span class="line"><span class="xml">          anti-pattern.</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们可以在 父组件App 中 <code>shouldComponentUpdate</code> 比较 props 的 email 是不是修改再决定要不要重新渲染，但是如果子组件接受多个 props（较为复杂），就很难处理，而且 <code>shouldComponentUpdate</code> 主要是用来性能提升的，不推荐开发者操作 <code>shouldComponetUpdate</code>（可以使用 <code>React.PureComponet</code>）。</p><p>我们也可以使用 <strong>在 props 变化后修改 state</strong>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">phone</span>: <span class="built_in">this</span>.props.phone</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 只要 props.phone 改变，就改变 state</span></span><br><span class="line">    <span class="keyword">if</span> (nextProps.phone !== <span class="built_in">this</span>.props.phone) &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        <span class="attr">phone</span>: nextProps.phone</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种也会导致一个问题，当 props 较为复杂时，props 与 state 的关系不好控制，可能导致问题</p><p>解决方案一：<strong>完全可控的组件</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PhoneInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;props.onChange&#125;</span> <span class="attr">value</span>=<span class="string">&#123;props.phone&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>完全由 props 控制，不派生 state</strong></p><p>解决方案二：<strong>有 key 的非可控组件</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">phone</span>: <span class="built_in">this</span>.props.defaultPhone &#125;;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">phone</span>: event.target.value &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.phone&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;PhoneInput</span><br><span class="line">  defaultPhone=&#123;<span class="built_in">this</span>.props.user.phone&#125;</span><br><span class="line">  key=&#123;<span class="built_in">this</span>.props.user.id&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>当 <code>key</code> 变化时， React 会<strong>创建一个新的而不是更新一个既有的组件</strong></p><p><strong>误解二</strong>：将 props 的值直接复制给 state</p><p><strong>应避免将 props 的值复制给 state</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line"> <span class="built_in">super</span>(props);</span><br><span class="line"> <span class="comment">// 千万不要这样做</span></span><br><span class="line"> <span class="comment">// 直接用 props，保证单一数据源</span></span><br><span class="line"> <span class="built_in">this</span>.state = &#123; <span class="attr">phone</span>: props.phone &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、多个组件的执行顺序"><a href="#三、多个组件的执行顺序" class="headerlink" title="三、多个组件的执行顺序"></a>三、多个组件的执行顺序</h2><h3 id="1-父子组件"><a href="#1-父子组件" class="headerlink" title="1. 父子组件"></a>1. 父子组件</h3><ul><li><p><strong>挂载阶段</strong></p><p>分 <strong>两个</strong> 阶段：</p><ul><li>第 <strong>一</strong> 阶段，由父组件开始执行到自身的 <code>render</code>，解析其下有哪些子组件需要渲染，并对其中 <strong>同步的子组件</strong> 进行创建，按 <strong>递归顺序</strong> 挨个执行各个子组件至 <code>render</code>，生成到父子组件对应的 Virtual DOM 树，并 commit 到 DOM。</li><li>第 <strong>二</strong> 阶段，此时 DOM 节点已经生成完毕，组件挂载完成，开始后续流程。先依次触发同步子组件各自的 <code>componentDidMount</code>，最后触发父组件的。</li></ul><p><strong>注意</strong>：如果父组件中包含异步子组件，则会在父组件挂载完成后被创建。</p><p>所以执行顺序是：</p><p>父组件 getDerivedStateFromProps —&gt; 同步子组件 getDerivedStateFromProps —&gt; 同步子组件 componentDidMount —&gt; 父组件 componentDidMount —&gt; 异步子组件 getDerivedStateFromProps —&gt; 异步子组件 componentDidMount</p></li><li><p><strong>更新阶段</strong></p><p><strong>React 的设计遵循单向数据流模型</strong> ，也就是说，数据均是由父组件流向子组件。</p><ul><li><p>第 <strong>一</strong> 阶段，由父组件开始，执行</p><ol><li><code>static getDerivedStateFromProps</code></li><li><code>shouldComponentUpdate</code></li></ol><p>更新到自身的 <code>render</code>，解析其下有哪些子组件需要渲染，并对 <strong>子组件</strong> 进行创建，按 <strong>递归顺序</strong> 挨个执行各个子组件至 <code>render</code>，生成到父子组件对应的 Virtual DOM 树，并与已有的 Virtual DOM 树 比较，计算出 <strong>Virtual DOM 真正变化的部分</strong> ，并只针对该部分进行的原生DOM操作。</p></li><li><p>第 <strong>二</strong> 阶段，此时 DOM 节点已经生成完毕，组件挂载完成，开始后续流程。先依次触发同步子组件以下函数，最后触发父组件的。</p><ol><li><code>getSnapshotBeforeUpdate()</code></li><li><code>componentDidUpdate()</code></li></ol><p>React 会按照上面的顺序依次执行这些函数，每个函数都是各个子组件的先执行，然后才是父组件的执行。</p><p>所以执行顺序是：</p><p>父组件 getDerivedStateFromProps —&gt; 父组件 shouldComponentUpdate —&gt; 子组件 getDerivedStateFromProps —&gt; 子组件 shouldComponentUpdate —&gt; 子组件 getSnapshotBeforeUpdate —&gt; 父组件 getSnapshotBeforeUpdate —&gt; 子组件 componentDidUpdate —&gt; 父组件 componentDidUpdate</p></li></ul></li><li><p><strong>卸载阶段</strong></p><p><code>componentWillUnmount()</code>，顺序为 <strong>父组件的先执行，子组件按照在 JSX 中定义的顺序依次执行各自的方法</strong>。</p><p><strong>注意</strong> ：如果卸载旧组件的同时伴随有新组件的创建，新组件会先被创建并执行完 <code>render</code>，然后卸载不需要的旧组件，最后新组件执行挂载完成的回调。</p></li></ul><h3 id="2-兄弟组件"><a href="#2-兄弟组件" class="headerlink" title="2. 兄弟组件"></a>2. 兄弟组件</h3><ul><li><p><strong>挂载阶段</strong></p><p>若是同步路由，它们的创建顺序和其在共同父组件中定义的先后顺序是 <strong>一致</strong> 的。</p><p>若是异步路由，它们的创建顺序和 js 加载完成的顺序一致。</p></li><li><p><strong>更新阶段、卸载阶段</strong></p><p>兄弟节点之间的通信主要是经过父组件（Redux 和 Context 也是通过改变父组件传递下来的 <code>props</code> 实现的），<strong>满足React 的设计遵循单向数据流模型</strong>， <strong>因此任何两个组件之间的通信，本质上都可以归结为父子组件更新的情况</strong> 。</p><p>所以，兄弟组件更新、卸载阶段，请参考 <strong>父子组件</strong>。</p></li></ul><h1 id="react-vue中的key"><a href="#react-vue中的key" class="headerlink" title="react/vue中的key"></a>react/vue中的key</h1><blockquote><p>经典面试题:</p><p>1). react/vue中的key有什么作用？（key的内部原理是什么？）</p><p>2). 为什么遍历列表时，key最好不要用index?</p></blockquote><p><strong>虚拟DOM中key的作用：</strong></p><ul><li><p>简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。</p></li><li><p>详细的说: 当状态中的数据发生变化时，react会根据<strong>新数据</strong>生成<strong>新的虚拟DOM,</strong> 随后React进行<strong>新虚拟DOM</strong>与<strong>旧虚拟DOM</strong>的diff比较，比较规则如下：</p><ul><li><p>旧虚拟DOM中找到了与新虚拟DOM相同的key：</p><ul><li>若虚拟DOM中内容没变, 直接使用之前的真实DOM</li><li>若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM</li></ul></li><li><p>旧虚拟DOM中未找到与新虚拟DOM相同的key</p><ul><li>根据数据创建新的真实DOM，随后渲染到到页面</li></ul></li></ul></li></ul><p><strong>用index作为key可能会引发的问题：</strong></p><ul><li><p>若对数据进行：逆序添加、逆序删除等破坏顺序操作：会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</p></li><li><p>如果结构中还包含输入类的DOM：会产生错误DOM更新 ==&gt; 界面有问题。</p></li><li><p>注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</p></li></ul><p><strong>开发中如何选择key?:</strong></p><ul><li><p>最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。</p></li><li><p>如果确定只是简单的展示数据，用index也是可以的。</p></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leslie Waong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesliewaong.top/posts/7f1a535a.html">https://lesliewaong.top/posts/7f1a535a.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lesliewaong.top" target="_blank">Leslie Waong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/React/">React</a><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/12.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/46aec6b.html"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/14.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hook</div></div></a></div><div class="next-post pull-right"><a href="/posts/e4b955ad.html"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/5.webp" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">React-Router v6</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/d8a440d1.html" title="React"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/12.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-07</div><div class="title">React</div></div></a></div><div><a href="/posts/46aec6b.html" title="Hook"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-02</div><div class="title">Hook</div></div></a></div><div><a href="/posts/e4b955ad.html" title="React-Router v6"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/5.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-01</div><div class="title">React-Router v6</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Leslie Waong</div><div class="author-info__description">BUPT</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">104</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lesliewaong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lesliewaong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1138964397&amp;website=www.qtxml.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">红雨漂泊泛起了回忆怎么潜</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E6%A1%86%E6%9E%B6%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8E%9F%E7%94%9F"><span class="toc-text">为什么选择使用框架而不是原生?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJSX%EF%BC%9F"><span class="toc-text">什么是JSX？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5diff-%E7%AE%97%E6%B3%95"><span class="toc-text">深入diff 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E4%BC%A0%E7%BB%9F%E7%9A%84-diff-%E7%AE%97%E6%B3%95"><span class="toc-text">一. 传统的 diff 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-React%E4%B8%ADdiff%E7%AE%97%E6%B3%95"><span class="toc-text">二. React中diff算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-diff-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-text">三. diff 源码解读</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-diff-%E7%AD%96%E7%95%A5"><span class="toc-text">1. diff 策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-tree-diff"><span class="toc-text">2. tree diff</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-component-diff"><span class="toc-text">3. component diff</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-element-diff"><span class="toc-text">4. element diff</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM%E7%9A%84%E4%BC%98%E5%8A%A3%E5%A6%82%E4%BD%95"><span class="toc-text">虚拟DOM的优劣如何?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">虚拟DOM实现原理?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E7%BB%84%E4%BB%B6%E5%AE%9A%E4%B9%89%E5%8C%BA%E5%88%AB"><span class="toc-text">两种组件定义区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E5%87%BD%E6%95%B0%E5%BC%8F%E5%A3%B0%E6%98%8E%E7%BB%84%E4%BB%B6"><span class="toc-text">①函数式声明组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E7%B1%BB%E5%BC%8F%E7%BB%84%E4%BB%B6-%E6%9C%89%E7%8A%B6%E6%80%81-state"><span class="toc-text">②类式组件(有状态 state)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-text">事件处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%9C%B0%E4%BD%BF%E7%94%A8-State"><span class="toc-text">正确地使用 State</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9-State"><span class="toc-text">不要直接修改 State</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#State-%E7%9A%84%E6%9B%B4%E6%96%B0%E5%8F%AF%E8%83%BD%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84"><span class="toc-text">State 的更新可能是异步的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#State-%E7%9A%84%E6%9B%B4%E6%96%B0%E4%BC%9A%E8%A2%AB%E5%90%88%E5%B9%B6"><span class="toc-text">State 的更新会被合并</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React-Refs-and-the-DOM%E6%8F%AD%E7%A7%98"><span class="toc-text">React Refs and the DOM揭秘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRef"><span class="toc-text">什么是Ref</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B-Declarative-Programming"><span class="toc-text">什么是声明式编程(Declarative Programming)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ref%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">Ref使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ref%E7%94%A8%E6%B3%95"><span class="toc-text">Ref用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ref%E6%80%BB%E7%BB%93"><span class="toc-text">Ref总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">React组件通信如何实现?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3-React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%97%EF%BC%9F"><span class="toc-text">你真的了解 React 生命周期吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Hooks-%E7%BB%84%E4%BB%B6"><span class="toc-text">一、Hooks 组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8D%95%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">二、单个组件的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">1. 生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#V16-3-%E4%B9%8B%E5%89%8D"><span class="toc-text">V16.3 之前</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V16-3-%E4%B9%8B%E5%90%8E"><span class="toc-text">V16.3 之后</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E8%AF%AF%E5%8C%BA"><span class="toc-text">2. 生命周期，误区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">三、多个组件的执行顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6"><span class="toc-text">1. 父子组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6"><span class="toc-text">2. 兄弟组件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react-vue%E4%B8%AD%E7%9A%84key"><span class="toc-text">react&#x2F;vue中的key</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/28d62aa4.html" title="居中布局与Flex"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/8.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="居中布局与Flex"></a><div class="content"><a class="title" href="/posts/28d62aa4.html" title="居中布局与Flex">居中布局与Flex</a><time datetime="2022-04-02T10:14:52.000Z" title="发表于 2022-04-02 18:14:52">2022-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/24025dd2.html" title="原型和继承"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/11.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="原型和继承"></a><div class="content"><a class="title" href="/posts/24025dd2.html" title="原型和继承">原型和继承</a><time datetime="2022-04-01T11:12:22.000Z" title="发表于 2022-04-01 19:12:22">2022-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9a4e49b6.html" title="let、const和var的区别"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/3.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="let、const和var的区别"></a><div class="content"><a class="title" href="/posts/9a4e49b6.html" title="let、const和var的区别">let、const和var的区别</a><time datetime="2022-04-01T04:22:32.000Z" title="发表于 2022-04-01 12:22:32">2022-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/90460439.html" title="this指向与箭头函数"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/12.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="this指向与箭头函数"></a><div class="content"><a class="title" href="/posts/90460439.html" title="this指向与箭头函数">this指向与箭头函数</a><time datetime="2022-03-30T13:01:02.000Z" title="发表于 2022-03-30 21:01:02">2022-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/447bd1ff.html" title="DOM事件总结"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/13.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="DOM事件总结"></a><div class="content"><a class="title" href="/posts/447bd1ff.html" title="DOM事件总结">DOM事件总结</a><time datetime="2022-03-29T12:11:52.000Z" title="发表于 2022-03-29 20:11:52">2022-03-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Leslie Waong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:""},null))},e=()=>{twikoo.getCommentsCount({envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))},n=(n=!1)=>{"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})};btf.loadComment(document.getElementById("twikoo-wrap"),n)})()</script></div><div class="aplayer no-destroy" data-id="6995412795" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="auto" data-autoplay="true" muted></div><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":0,"vOffset":0},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body></html>