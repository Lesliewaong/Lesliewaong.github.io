<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>前端常见面试题 | Leslie Waong</title><meta name="keywords" content="CSS,HTML,JS,框架,计算机网络,浏览器"><meta name="author" content="Leslie Waong"><meta name="copyright" content="Leslie Waong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTML&amp;CSS语义化的理解 用正确的标签做正确的事情！ HTML语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析； 在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。  &lt;img&gt;的title和alt有什么区别 通常当鼠标滑动">
<meta property="og:type" content="article">
<meta property="og:title" content="前端常见面试题">
<meta property="og:url" content="https://lesliewaong.top/posts/1d0f8d42.html">
<meta property="og:site_name" content="Leslie Waong">
<meta property="og:description" content="HTML&amp;CSS语义化的理解 用正确的标签做正确的事情！ HTML语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析； 在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。  &lt;img&gt;的title和alt有什么区别 通常当鼠标滑动">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/17/Ti4hV0.jpg">
<meta property="article:published_time" content="2021-07-12T05:14:52.000Z">
<meta property="article:modified_time" content="2021-12-29T15:15:31.675Z">
<meta property="article:author" content="Leslie Waong">
<meta property="article:tag" content="CSS">
<meta property="article:tag" content="HTML">
<meta property="article:tag" content="JS">
<meta property="article:tag" content="框架">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="浏览器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s4.ax1x.com/2021/12/17/Ti4hV0.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg"><link rel="canonical" href="https://lesliewaong.top/posts/1d0f8d42"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"一年之内的产物","messageNext":"技术可能存在过期"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Leslie Waong","link":"链接: ","source":"来源: Leslie Waong","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端常见面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-29 23:15:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Leslie Waong" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/item/N1/"><i class="fa-fw fa fa-star"></i><span> 火影1</span></a></li><li><a class="site-page child" href="/item/N2/"><i class="fa-fw fa fa-star"></i><span> 火影2</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s4.ax1x.com/2021/12/17/Ti4hV0.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leslie Waong</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/item/N1/"><i class="fa-fw fa fa-star"></i><span> 火影1</span></a></li><li><a class="site-page child" href="/item/N2/"><i class="fa-fw fa fa-star"></i><span> 火影2</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端常见面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-12T05:14:52.000Z" title="发表于 2021-07-12 13:14:52">2021-07-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-29T15:15:31.675Z" title="更新于 2021-12-29 23:15:31">2021-12-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">36.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>125分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端常见面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML&amp;CSS"></a>HTML&amp;CSS</h1><h2 id="语义化的理解"><a href="#语义化的理解" class="headerlink" title="语义化的理解"></a>语义化的理解</h2><ul>
<li><strong>用正确的标签做正确的事情</strong>！</li>
<li>HTML语义化就是让页面的内容<strong>结构化</strong>，便于对浏览器、搜索引擎解析；</li>
<li>在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。</li>
<li>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，<strong>利于 SEO</strong>。</li>
<li>使阅读源代码的人对网站更容易将网站分块，<strong>便于阅读维护理解</strong>。</li>
</ul>
<h2 id="lt-img-gt-的title和alt有什么区别"><a href="#lt-img-gt-的title和alt有什么区别" class="headerlink" title="&lt;img&gt;的title和alt有什么区别"></a><code>&lt;img&gt;</code>的<code>title</code>和<code>alt</code>有什么区别</h2><ul>
<li>通常当鼠标滑动到元素上的时候显示<code>title</code></li>
<li><code>alt</code>是<code>&lt;img&gt;</code>的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提高图片可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</li>
</ul>
<h2 id="H5的新特性有哪些"><a href="#H5的新特性有哪些" class="headerlink" title="H5的新特性有哪些"></a>H5的新特性有哪些</h2><ul>
<li><p>新语义元素 <code>header</code>(头部),<code>main</code>(主体),<code>nav</code>(导航),<code>footer</code>(底部),<code>aside</code>(侧边栏),<code>article</code>(独立文章),<code>section</code> (独立区块)。总体来说，这些标签就是div标签的语义化转化，过去我们曾用div来包裹某个块或者说组件，现在H5使用这些标签实现语义化，<strong>有利于代码可读性和SEO（搜索引擎优化）</strong>。</p>
</li>
<li><p>H5提供了<code>sessionStorage</code>、<code>localStorage</code>和<code>indexedDB</code>加强本地存储。</p>
</li>
<li><p>表单新增功能</p>
<p>以往input中的name和value要随着form表单一起提交，form表单必须包裹input , 而现在可以通过input的form属性綁定</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;testform&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">form</span>=<span class="string">testform</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>placeholder属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>autofocus属性，页面只能有一个,自动获得焦点</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">autofocus</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>还有type为email、number等，但是实际项目中一般使用自定义，所以这里不提。</p>
</li>
</ul>
<ul>
<li><p>画布(<code>Canvas</code>) API <code>&lt;canvas&gt;</code> 元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成.</p>
</li>
<li><p>地理(<code>Geolocation</code>) API</p>
</li>
<li><p>音频、视频API(<code>audio</code>,<code>video</code>)</p>
</li>
<li><p>拖放API </p>
<p>拖放是一种常见的特性，即抓取对象以后拖到另一个位置。在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。</p>
<p>拖放的过程分为源对象和目标对象。源对象是指你即将拖动元素，而目标对象则是指拖动之后要放置的目标位置。</p>
</li>
<li><p><code>webworker</code>, <code>websocket</code></p>
<ul>
<li><p><code>webworker</code>是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。</p>
</li>
<li><p><code>WebSocket</code> 使用<code>ws</code>或<code>wss</code>协议，<code>Websocket</code>是一个持久化的协议，相对于HTTP这种非持久的协议来说。WebSocket API最伟大之处在于服务器和客户端可以在给定的时间范围内的任意时刻，相互推送信息。<code>WebSocket</code>并不限于以Ajax(或XHR)方式通信，因为Ajax技术需要客户端发起请求，而WebSocket服务器和客户端可以彼此相互推送信息；XHR受到域的限制，而<code>WebSocket</code>允许跨域通信。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Socket实例</span></span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:8080&#x27;</span>);</span><br><span class="line"><span class="comment">// 打开Socket</span></span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 发送一个初始化消息</span></span><br><span class="line">  socket.send(<span class="string">&#x27;I am the client and I\&#x27;m listening!&#x27;</span>);</span><br><span class="line">  <span class="comment">// 监听消息</span></span><br><span class="line">  socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Client received a message&#x27;</span>,event);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 监听Socket的关闭</span></span><br><span class="line">  socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Client notified socket has closed&#x27;</span>,event);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 关闭Socket....</span></span><br><span class="line">  <span class="comment">//socket.close()</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="iframe有那些缺点"><a href="#iframe有那些缺点" class="headerlink" title="iframe有那些缺点"></a>iframe有那些缺点</h2><ul>
<li><code>iframe</code>会阻塞主页面的<code>Onload</code>事件；</li>
<li>搜索引擎的检索程序无法解读这种页面，不利于<code>SEO</code>;</li>
<li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li>
<li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code></li>
<li>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li>
</ul>
<h2 id="简述一下src与href的区别"><a href="#简述一下src与href的区别" class="headerlink" title="简述一下src与href的区别"></a>简述一下src与href的区别</h2><ul>
<li><code>src</code>用于替换当前元素，<code>href</code>用于在当前文档和引用资源之间确立联系。</li>
<li><code>src</code>是<code>source</code>的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求<code>src</code>资源时会将其指向的资源下载并应用到文档内，例如<code>js</code>脚本，<code>img</code>图片和<code>frame</code>等元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src =”js.js”&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部</p>
</blockquote>
<ul>
<li><code>href</code>是<code>Hypertext Reference</code>的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=”common.css” rel=”stylesheet”/&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。</p>
</blockquote>
<h2 id="知道的网页制作会用到的图片格式有哪些"><a href="#知道的网页制作会用到的图片格式有哪些" class="headerlink" title="知道的网页制作会用到的图片格式有哪些"></a>知道的网页制作会用到的图片格式有哪些</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">png-8`，`png-24`，`jpeg`，`gif`，`svg</span><br></pre></td></tr></table></figure>

<p>但是上面的那些都不是面试官想要的最后答案。面试官希望听到是Webp。（是否有关注新技术，新鲜事物）</p>
<blockquote>
<p>科普一下Webp：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。</p>
</blockquote>
<p>在质量相同的情况下，<code>WebP</code>格式图像的体积要比JPEG格式图像小<code>40%</code></p>
<h2 id="居中布局⭐"><a href="#居中布局⭐" class="headerlink" title="居中布局⭐"></a>居中布局⭐</h2><ul>
<li>水平居中<ul>
<li>行内元素: <code>text-align: center</code></li>
<li>块级元素: <code>margin: 0 auto</code></li>
<li><code>absolute + transform</code></li>
<li><code>flex + justify-content: center</code></li>
</ul>
</li>
<li>垂直居中<ul>
<li><code>line-height: height</code></li>
<li><code>absolute + transform</code></li>
<li><code>flex + align-items: center</code></li>
<li><code>table</code></li>
</ul>
</li>
<li>水平垂直居中<ul>
<li><code>absolute + transform</code></li>
<li><code>flex + justify-content + align-items</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>补充</p>
</blockquote>
<h3 id="inline-，-block，-inline-blockd的区别"><a href="#inline-，-block，-inline-blockd的区别" class="headerlink" title="inline ， block， inline-blockd的区别"></a>inline ， block， inline-blockd的区别</h3><p><strong>块元素block</strong></p>
<ul>
<li>块元素会在页面中<strong>独占一行</strong>(自上向下垂直排列)</li>
<li>默认宽度是父元素的全部（会把父元素撑满）</li>
<li>默认高度是被内容撑开（子元素）</li>
<li><strong>能够改变元素的height，width的值</strong>。</li>
<li>可以设置padding，margin的各个属性值，top，left，bottom，right都能够产生边距效果。</li>
<li><code>button,div , dl ,dt ,form , h1 ,h2 ,h3 , h4 ,h5 ,hr ,li ,ul ,table系列，button；</code></li>
</ul>
<p><strong>行内元素inline</strong></p>
<ul>
<li>行内元素<strong>不会独占页面的一行</strong>，只占自身的大小</li>
<li>行内元素在页面中左向右水平排列，如果一行之中不能容纳下所有的行内元素，则元素会换到第二行继续自左向右排列（书写习惯一致）</li>
<li><strong>不能更改元素的height，width的值</strong>，大小由内容撑开。</li>
<li>可以使用padding，margin的left和right产生边距效果，但是top和bottom就不行。</li>
<li><code>img ,a ,input ,textarea ,b ,br ,span, select ,label ,map ,strong ;</code></li>
</ul>
<p><strong>行内块元素 inline-block</strong> </p>
<p><strong>既可以设置宽度和高度又不会独占一行</strong></p>
<h3 id="absolute-transform"><a href="#absolute-transform" class="headerlink" title="absolute + transform"></a>absolute + transform</h3><p><code>top,left</code>跟根据<strong>父元素的宽和高</strong>偏移的。</p>
<p><code>transform: translate(-50%, -50%);</code>是根据<strong>自身的宽高</strong>偏移的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  positioin: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  positioin: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p><strong>绝对定位absolute</strong></p>
<p>绝对定位元素是相对于其<strong>包含块</strong>进行定位的，包含块就是<strong>离它最近的开启了定位的祖先元素</strong>，如果所有的祖先元素都没有开启定位则根元素就是它的包含块。</p>
<p><strong>固定定位fixed</strong></p>
<p>也是一种绝对定位，唯一不同的是固定定位永远参照于<strong>浏览器的视口</strong>进行定位，固定定位的元素不会随网页的滚动条滚动。</p>
<p><strong>粘滞定位sticky</strong></p>
<p>和相对定位的特点基本一致，不同的是粘滞定位可以在元素到达某个位置时将其固定。</p>
<h2 id="Flex⭐"><a href="#Flex⭐" class="headerlink" title="Flex⭐"></a>Flex⭐</h2><blockquote>
<p>Flex是Flexible Box的缩写，翻译成中文就是“弹性盒子”，用来为盒模型提供最大的灵活性。任何一个容器都可以指定为Flex布局</p>
</blockquote>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>采用Flex布局的元素，被称为Flex容器(flex container)，简称“容器”。</p>
<p>其所有子元素自动成为容器成员，成为Flex项目(Flex item)，简称“项目”。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o4UXgP"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2021/12/09/o4UXgP.png" alt="o4UXgP.png"></a></p>
<p>容器默认存在两根主轴：水平方向主轴(main axis)和垂直方向交叉轴(cross axis)，默认项目按主轴排列。</p>
<ul>
<li>main start/main end：主轴开始位置/结束位置；</li>
<li>cross start/cross end：交叉轴开始位置/结束位置；</li>
<li>main size/cross size：单个项目占据主轴/交叉轴的空间；</li>
</ul>
<h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p><strong>决定主轴的方向（即项目的排列方向）</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">   <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>row（默认）：主轴水平方向，起点在左端；</li>
<li>row-reverse：主轴水平方向，起点在右端；</li>
<li>column：主轴垂直方向，起点在上边沿；</li>
<li>column-reserve：主轴垂直方向，起点在下边沿。</li>
</ul>
<h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p><strong>定义换行情况</strong></p>
<blockquote>
<p>默认情况下，项目都排列在一条轴线上，但有可能一条轴线排不下。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">   <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>nowrap（默认）：不换行；</li>
<li>wrap：换行，第一行在上方；</li>
<li>wrap-reverse：换行，第一行在下方。</li>
</ul>
<h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p><strong>flex-direction和flex-wrap的简写，默认row nowrap</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p><strong>定义项目在主轴上的对齐方式。</strong></p>
<blockquote>
<p>对齐方式与轴的方向有关，本文中假设主轴从左到右。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">   <span class="attribute">justify-content</span>: start | end | flex-start | flex-end | center | left | right | space-between | space-around | space-evenly | stretch | safe | unsafe | baseline | first baseline | last baseline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>flex-start（默认值）：左对齐；</p>
</li>
<li><p>flex-end：右对齐；</p>
</li>
</ul>
<ul>
<li><p>center：居中；<strong>常用作水平居中</strong></p>
</li>
<li><p>space-between：两端对齐，项目之间间隔相等；</p>
</li>
<li><p>space-around：每个项目两侧的间隔相等，即项目之间的间隔比项目与边框的间隔大一倍。</p>
</li>
</ul>
<h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p><strong>定义在交叉轴上的对齐方式</strong></p>
<blockquote>
<p>对齐方式与交叉轴的方向有关，假设交叉轴从上到下。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>flex-start：起点对齐；</li>
<li>flex-end：终点对齐；</li>
<li>center：中点对齐；<strong>常用作垂直居中</strong></li>
<li>baseline：项目的第一行文字的基线对齐；</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p><strong>定义多根轴线的对齐方式</strong></p>
<blockquote>
<p>如果项目只有一根轴线，该属性不起作用。<br>所以，容器必须设置flex-wrap：···；</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>flex-start：与交叉轴的起点对齐；</p>
</li>
<li><p>flex-end：与交叉轴的终点对齐；</p>
</li>
<li><p>center：与交叉轴的中点对齐；</p>
</li>
<li><p>space-between：与交叉轴的两端对齐，轴线之间的间隔平均分布；</p>
</li>
<li><p>space-around：每根轴线两侧的间隔相等，即轴线之间的间隔比轴线与边框的间隔大一倍；</p>
</li>
<li><p>stretch（默认值）：轴线占满整个交叉轴。</p>
</li>
</ul>
<h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p><strong>==flex-grow，flex-shrink和flex-basis的简写==</strong></p>
<blockquote>
<p>默认值为0 1 auto，<strong>第一个属性必须</strong>，后两个属性可选。</p>
</blockquote>
<p>可以用 <code>flex:auto;</code> 代替 <code>flex: 1 1 auto;</code>；可以用 <code>flex: none;</code>代替 <code>flex: 0 0 auto</code>；</p>
<h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p><strong>定义项目的放大比例</strong></p>
<blockquote>
<p>默认值为0，即如果空间有剩余，也不放大。<br>可以是小数，按比例占据<strong>剩余空间</strong>。</p>
</blockquote>
<p><code>flex-grow：1</code>或<code>flex：1</code>，经常用作自适应布局</p>
<h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p><strong>定义项目的缩小比例</strong></p>
<blockquote>
<p>默认值都为1，即如果空间不足将等比例缩小。<br>如果有一个项目的值为0，其他项目为1，当空间不足时，该项目不缩小。<br>负值对该属性无效，容器不应该设置flex-wrap。</p>
</blockquote>
<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p><strong>定义在分配多余空间之前，项目占据的主轴空间。</strong></p>
<blockquote>
<p>默认值为auto，浏览器根据此属性检查主轴是否有多余空间。</p>
</blockquote>
<h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p><strong>允许单个项目与其他项目有不一样的对齐方式</strong> </p>
<blockquote>
<p>默认值为auto，表示继承父元素的align-items属性，并可以覆盖align-items属性。</p>
</blockquote>
<h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p><strong>定义项目的排列顺序。</strong></p>
<blockquote>
<p>数值越小，排列越靠前，默认为0，可以是负值。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: &lt;整数&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="flex-grow-1"><a href="#flex-grow-1" class="headerlink" title="flex-grow"></a>flex-grow</h4><h2 id="页面布局⭐"><a href="#页面布局⭐" class="headerlink" title="页面布局⭐"></a>页面布局⭐</h2><blockquote>
<p>问题：假设容器的高度默认100px，请写出<strong>三栏布局</strong>，其中左栏、右栏的宽度各为300px，中间的宽度自适应。</p>
</blockquote>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>方法1、浮动：</strong></p>
<p>左侧设置左浮动，右侧设置右浮动即可，中间会自动地自适应。</p>
<p><strong>方法2、绝对定位：</strong></p>
<p>左侧设置为绝对定位，  <code>left：0px</code>。右侧设置为绝对定位， <code>right：0px</code>。中间设置为绝对定位，<code>left 和right 都为300px</code>，即可。中间的宽度会自适应。</p>
<p>使用<code>article</code>标签作为容器，包裹左、中、右三个部分。</p>
<p><strong>方法3、flexbox布局</strong></p>
<p><code>flex：1</code>即为<code>flex-grow：1</code>，经常用作自适应布局，将父容器的<code>display：flex</code>，侧边栏大小固定后，将内容区<code>flex：1</code>，内容区则会自动放大占满剩余空间。</p>
<p><strong>方法4、表格布局 table</strong></p>
<p>设置整个容器的宽度为<code>100%</code>，设置三个部分均为表格，然后左边的单元格为 <code>300px</code>，右边的单元格为 <code>300px</code>，即可。中间的单元格会自适应。</p>
<p><strong>方法5、网格布局 grid</strong></p>
<p>设置容器为网格布局<code>display: grid</code>，宽度为<code>100%</code> 设置网格为三列，并设置每列的宽度<code>grid-template-columns: 300px auto 300px</code>。</p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5mDMKs"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/12/5mDMKs.gif" alt="5mDMKs.gif"></a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">html</span> *&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span> <span class="selector-tag">article</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 1.浮动 */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* .layout.float表示交集选择器，空格表示后代选择器 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.float</span> <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.float</span> <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: blue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.float</span> <span class="selector-class">.center</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 2.绝对定位 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.absolute</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">            <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 【重要】中间的区域，左侧定位300px，右侧定位为300px，即可完成。宽度会自适应 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.center</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">            <span class="attribute">left</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">right</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">            <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: blue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 3.flex */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* 绝对布局导致脱离文档流，因此上边距300px是从方法一中还在文档流的元素开始算 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.flex</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-top</span>: <span class="number">230px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.flex</span> <span class="selector-class">.left-center-right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.flex</span> <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.flex</span> <span class="selector-class">.center</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.flex</span> <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: blue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 4.表格 */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* 重要：设置容器为表格布局，宽度为100% */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.left-center-right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: table;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 重要：设置三个模块为表格里的单元*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.left-center-right</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: table-cell;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.center</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: blue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 5.网格 */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* 重要：设置容器为网格布局，宽度为100% */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* 设置网格为三列，并设置每列的宽度。即可。 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.left-center-right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: grid;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="comment">/* grid-template-rows: 100px; */</span></span></span><br><span class="line"><span class="css">            grid-template-<span class="attribute">columns</span>: <span class="number">300px</span> auto <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.center</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: blue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方法一：浮动 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        元素设置浮动以后，会完全从文档流中脱离，不再占用文档流的位置，</span></span><br><span class="line"><span class="comment">         所以元素下边的还在文档流中的元素会自动向上移动 </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 输入 section.layout.float，即可生成 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;layout float&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 用article标签包裹左、中、右三个部分 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;left-center-right&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">                left</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">                right</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>浮动<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                center</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方法二：绝对定位 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;layout absolute&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;left-center-right&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">                left</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>绝对定位<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                center</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">                right</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方法三：flex --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;layout flex&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;left-center-right&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">                我是 left</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>flex布局<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                我是 center</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">                我是 right</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方法四、表格 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;layout table&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;left-center-right&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">                left</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>表格布局<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                center</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">                right</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方法五、网格 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;layout grid&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;left-center-right&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">                left</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>网格布局<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                center</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">                right</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><h4 id="五种方法的对比"><a href="#五种方法的对比" class="headerlink" title="五种方法的对比"></a>五种方法的对比</h4><ul>
<li><p>五种方法的优缺点</p>
</li>
<li><p>考虑中间模块的高度问题</p>
</li>
<li><p>兼容性问题：实际开发中，哪个最实用？</p>
</li>
</ul>
<p>方法1：浮动：</p>
<ul>
<li><p>优点：兼容性较好。</p>
</li>
<li><p>缺点：浮动是<strong>脱离文档流</strong>的，如果处理不好，会带来很多问题。有些时候需要<strong>清除浮动</strong>，需要很好的处理浮动周边元素的关系。</p>
</li>
</ul>
<p>方法:2：绝对定位</p>
<ul>
<li><p>优点：快捷。</p>
</li>
<li><p>缺点：<strong>布局脱离文档流，意味着下面的子元素也要脱离文档流</strong>，导致这个方案的有效性是比较差的。</p>
</li>
</ul>
<p>方法3：flex 布局</p>
<ul>
<li>优点：<strong>比较完美的解决了浮动和绝对定位的问题。在移动端比较常用</strong>。</li>
<li>缺点：兼容性比较差，不兼容<strong>IE8</strong>及以下的版本。因为这个是<strong>CSS3</strong>中新增的display的属性值。</li>
</ul>
<p>方法4：表格布局</p>
<ul>
<li><p>优点：<strong>表格布局在很多场景中很实用，兼容性非常好</strong>。因为IE8不支持 flex，此时可以尝试表格布局。</p>
</li>
<li><p>缺点：因为三个部分都当成了<strong>单元格</strong>来对待，此时，如果中间的部分变高了，其会部分也会被迫调整高度。但是，在很多场景下，我们并不需要两侧的高度增高。</p>
</li>
</ul>
<p>方法5：网格布局</p>
<ul>
<li>CSS3中引入的布局，很好用。代码量简化了很多。</li>
</ul>
<p>PS：面试提到网格布局，说明我们对新技术是有追求的。</p>
<h4 id="如果题目中去掉高度已知"><a href="#如果题目中去掉高度已知" class="headerlink" title="如果题目中去掉高度已知"></a>如果题目中去掉高度已知</h4><p>问题：题目中，如果去掉高度已知，我们往中间的模块里塞很多内容，让中间的模块撑开。会发生什么变化？</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5my7i6"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/12/5my7i6.gif" alt="5my7i6.gif"></a></p>
<h4 id="页面布局的变通"><a href="#页面布局的变通" class="headerlink" title="页面布局的变通"></a>页面布局的变通</h4><p>三栏布局</p>
<ul>
<li>左右宽度固定，中间自适应</li>
<li>上下高度固定，中间自适应</li>
</ul>
<p>两栏布局</p>
<ul>
<li>左宽度固定，右自适应</li>
<li>右宽度固定，左自适应</li>
<li>上宽度固定，下自适应</li>
<li>下宽度固定，上自适应</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>涉及到的知识点：</p>
<p>（1）语义化掌握到位：每个区域用<code>section</code>、<code>article</code>代表容器、<code>div</code>代表块儿。如果通篇都用 div，那就是语义化没掌握好。</p>
<p>（2）页面布局理解深刻。</p>
<p>（3）CSS基础知识扎实。</p>
<p>（4）思维灵活且积极上进。题目中可以通过<code>网格布局</code>来体现。</p>
<p>（5）代码书写规范。注意命名。</p>
<h2 id="对CSS盒模型的认识⭐"><a href="#对CSS盒模型的认识⭐" class="headerlink" title="对CSS盒模型的认识⭐"></a>对CSS盒模型的认识⭐</h2><blockquote>
<p>专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面：</p>
<p>（1）基本概念：content、padding、margin。</p>
<p>（2）标准盒模型、IE盒模型的区别。</p>
<p>（3）CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。</p>
<p>（4）JS如何设置、获取盒模型对应的宽和高？</p>
<p>（5）实例题：根据盒模型解释<strong>边距重叠</strong>。</p>
<p>（6）BFC（边距重叠解决方案）或IFC。</p>
<p><strong>总结</strong>：以上几点，从上到下，知识点逐渐递增，知识面从理论、CSS、JS，又回到CSS理论。</p>
</blockquote>
<h3 id="标准盒模型和IE盒子模型"><a href="#标准盒模型和IE盒子模型" class="headerlink" title="标准盒模型和IE盒子模型"></a>标准盒模型和IE盒子模型</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5mcYjg"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/12/5mcYjg.jpg" alt="5mcYjg.jpg"></a><br><a target="_blank" rel="noopener" href="https://imgtu.com/i/5mcJgS"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/12/5mcJgS.jpg" alt="5mcJgS.jpg"></a></p>
<p>在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式：</p>
<ul>
<li>width和height：<strong>内容</strong>的宽度、高度（不是盒子的宽度、高度）。</li>
<li>padding：内边距。</li>
<li>border：边框。</li>
<li>margin：外边距。</li>
</ul>
<p>CSS盒模型和IE盒模型的区别：</p>
<ul>
<li>在 <strong>标准盒子模型</strong>中，<strong>width 和 height 指的是内容区域</strong>的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</li>
<li><strong>IE盒子模型</strong>中，<strong>width 和 height 指的是内容区域+border+padding</strong>的宽度和高度。</li>
</ul>
<h3 id="CSS如何设置这两种模型"><a href="#CSS如何设置这两种模型" class="headerlink" title="CSS如何设置这两种模型"></a>CSS如何设置这两种模型</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置当前盒子为 标准盒模型（默认） */</span></span><br><span class="line"><span class="attribute">box-sizing</span>: content-box;</span><br><span class="line"><span class="comment">/* 设置当前盒子为 IE盒模型 */</span></span><br><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br></pre></td></tr></table></figure>


<p>备注：盒子默认为标准盒模型。</p>
<h3 id="JS如何设置、获取盒模型对应的宽和高"><a href="#JS如何设置、获取盒模型对应的宽和高" class="headerlink" title="JS如何设置、获取盒模型对应的宽和高"></a>JS如何设置、获取盒模型对应的宽和高</h3><p><strong>方式一：通过DOM节点的 style 样式获取</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.style.width/height;</span><br></pre></td></tr></table></figure>

<p>缺点：通过这种方式，只能获取<strong>行内样式</strong>，不能获取<code>内嵌</code>的样式和<code>外链</code>的样式。</p>
<p>这种方式有局限性，但应该了解。</p>
<p><strong>方式二（通用型）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.getComputedStyle(element).width/height;</span><br></pre></td></tr></table></figure>


<p>方式二能兼容 Chrome、火狐。是通用型方式。</p>
<p><strong>方式三（IE独有的）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.currentStyle.width/height;</span><br></pre></td></tr></table></figure>

<p>和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。</p>
<p><strong>方式四</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.getBoundingClientRect().width/height;</span><br></pre></td></tr></table></figure>

<p>此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置。</p>
<p>此 api 可以拿到四个属性：left、top、width、height。</p>
<p><strong>总结：</strong></p>
<p>上面的四种方式，要求能说出来区别，以及哪个的通用型更强。</p>
<h3 id="margin塌陷-margin重叠"><a href="#margin塌陷-margin重叠" class="headerlink" title="margin塌陷/margin重叠"></a>margin塌陷/margin重叠</h3><p><strong>标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin</strong>(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。</p>
<p>PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有margin重叠的现象的。</p>
<p>我们来看几个例子。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        *&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.father</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="css">            <span class="comment">/* overflow: hidden; */</span></span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.son</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-top</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: blue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.brother</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;brother&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，儿子和兄弟的height是 100px，儿子magin-top 是50px，margin-bottom是20px，兄弟magin-top 是30px。竖直方向的margin不叠加，只取较大的值作为margin，所以中间20px塌陷在30px中。另外，此时父亲的height 是130px，而不是180px。因为儿子和父亲在竖直方向上，共一个margin。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5mxrPx"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/12/5mxrPx.png" alt="5mxrPx.png"></a><br><a target="_blank" rel="noopener" href="https://imgtu.com/i/5mx0aR"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/12/5mx0aR.png" alt="5mx0aR.png"></a></p>
<p>上方代码中，如果我们给父亲设置一个属性：<code>overflow: hidden</code>，就可以避免这个问题，此时父亲的高度是180px，这个用到的就是<strong>BFC</strong>。或者为父元素加一个<code>border: 2px solid red</code></p>
<p><strong>margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。</strong></p>
<p>所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的margin。</p>
<h3 id="BFC（边距重叠解决方案）"><a href="#BFC（边距重叠解决方案）" class="headerlink" title="BFC（边距重叠解决方案）"></a>BFC（边距重叠解决方案）</h3><h4 id="BFC的概念"><a href="#BFC的概念" class="headerlink" title="BFC的概念"></a>BFC的概念</h4><p>BFC（Block Formatting Context）：块级格式化上下文。是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p>
<h4 id="BFC-的原理-BFC的布局规则【非常重要】"><a href="#BFC-的原理-BFC的布局规则【非常重要】" class="headerlink" title="BFC 的原理/BFC的布局规则【非常重要】"></a>BFC 的原理/BFC的布局规则【非常重要】</h4><p>BFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括：</p>
<ul>
<li><p>BFC <strong>内部的</strong>子元素，在垂直方向，<strong>边距会发生重叠</strong>。</p>
</li>
<li><p>BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看<code>举例1</code>）</p>
</li>
<li><p><strong>BFC区域不与旁边的<code>float box</code>区域重叠</strong>。（可以用来清除浮动带来的影响——高度塌陷）。（稍后看<code>举例2</code>）</p>
</li>
<li><p>计算BFC的高度时，浮动的子元素也参与计算。（稍后看<code>举例3</code>）</p>
</li>
</ul>
<h4 id="如何生成BFC"><a href="#如何生成BFC" class="headerlink" title="如何生成BFC"></a>如何生成BFC</h4><p>有以下几种方法：</p>
<ul>
<li><p>方法1：<code>overflow: 不为visible，可以让属性是 hidden、auto</code>。【最常用】</p>
</li>
<li><p>方法2：浮动中：float的属性值不为none。意思是，<code>只要设置了浮动，当前元素就创建了BFC</code>。</p>
</li>
<li><p>方法3：定位中：只要posiiton的值不是static或者是relative即可，可以是<code>absolute</code>或<code>fixed</code>，也就生成了一个BFC。</p>
</li>
<li><p>方法4：<code>display</code>为<code>inline-block</code>, <code>table-cell</code>, <code>table-caption</code>, <code>flex</code>, <code>inline-flex</code></p>
</li>
</ul>
<h4 id="BFC-的应用"><a href="#BFC-的应用" class="headerlink" title="BFC 的应用"></a>BFC 的应用</h4><blockquote>
<p><strong>举例1：</strong>解决 margin 重叠</p>
</blockquote>
<p>当父元素和子元素发生 margin 重叠时，解决办法：<strong>给子元素或父元素创建BFC</strong>。</p>
<p>比如说，针对下面这样一个 div 结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的div结构中，如果父元素和子元素发生margin重叠，我们可以给子元素创建一个 BFC，就解决了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span> <span class="attr">style</span>=<span class="string">&quot;overflow: hidden&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为<strong>第二条：BFC区域是一个独立的区域，不会影响外面的元素</strong>。</p>
<blockquote>
<p><strong>举例2</strong>：BFC区域不与float区域重叠：</p>
</blockquote>
<p>针对下面这样一个div结构；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: pink;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">150px</span>;  <span class="comment">/*右侧标准流里的元素，比左侧浮动的元素要高*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;father-layout&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">        左侧，1234</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">        右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5nFuEF"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/12/5nFuEF.png" alt="5nFuEF.png"></a></p>
<p>上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。</p>
<p><strong>如果要解决这个问题，可以将右侧的元素创建BFC</strong>，因为<strong>第三条：BFC区域不与<code>float box</code>区域重叠</strong>。解决办法如下：（将right区域添加overflow属性）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span> <span class="attr">style</span>=<span class="string">&quot;overflow: hidden&quot;</span>&gt;</span></span><br><span class="line">    右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5nFKN4"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/12/5nFKN4.png" alt="5nFKN4.png"></a></p>
<p>上图表明，解决之后，<code>father-layout</code>的背景色显现出来了，说明问题解决了。</p>
<blockquote>
<p><strong>举例3：</strong>清除浮动</p>
</blockquote>
<p>现在有下面这样的结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>BFC<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.father</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: pink;</span></span><br><span class="line"><span class="css">            <span class="comment">/* overflow: hidden; */</span></span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.son</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">            hello son</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5niapn"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/12/5niapn.png" alt="5niapn.png"></a></p>
<p>上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓<strong>有高度的盒子，才能关住浮动</strong>。</p>
<blockquote>
<p>在浮动布局中，父元素的高度默认是被子元素撑开的，当子元素浮动后，其会完全脱离文档流。</p>
<p>子元素从文档流中脱离，将会无法撑起父元素的高度，导致父元素的高度丢失。</p>
<p>父元素高度丢失以后，其下的元素会自动上移，导致页面的布局混乱。</p>
</blockquote>
<p>如果想要清除浮动带来的影响，</p>
<p>方法一是<strong>给父亲设置高度</strong>，然后采用隔墙法。</p>
<p>方法二：<strong>clearfix（伪元素+clear）</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1 clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block; <span class="comment">/* 确保该元素是一个块级元素 */</span></span><br><span class="line">    <span class="attribute">clear</span>: both;<span class="comment">/*清除浮动*/</span></span><br></pre></td></tr></table></figure>

<p>方法三是 BFC：给父亲增加 <code>overflow=hidden</code>属性即可， 增加之后，效果如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5niNfs"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/12/5niNfs.png" alt="5niNfs.png"></a></p>
<p>为什么父元素成为BFC之后，就有了高度呢？这就回到了<strong>第四条：计算BFC的高度时，浮动元素也参与计算</strong>。意思是，<strong>在计算BFC的高度时，子元素的float box也会参与计算</strong>。</p>
<h2 id="CSS中link和-import区别"><a href="#CSS中link和-import区别" class="headerlink" title="CSS中link和@import区别"></a>CSS中link和@import区别</h2><p><strong>1.从属关系区别</strong><br><code>@import</code>是 CSS 提供的语法规则，只有导入样式表的作用；<code>link</code>是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。</p>
<p><strong>2.加载顺序区别</strong><br>加载页面时，<code>link</code>标签引入的 CSS 被同时加载；<code>@import</code>引入的 CSS 将在页面加载完毕后被加载。</p>
<p><strong>3.兼容性区别</strong><br><code>@import</code>是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；<code>link</code>标签作为 HTML 元素，不存在兼容性问题。</p>
<p><strong>4.DOM可控性区别</strong><br>可以通过 JS 操作 DOM ，插入<code>link</code>标签来改变样式；由于 DOM 方法是基于文档的，无法使用<code>@import</code>的方式插入样式。</p>
<p><strong>5.权重区别(该项有争议)</strong><br><code>link</code>引入的样式权重大于<code>@import</code>引入的样式。</p>
<h2 id="CSS选择器⭐"><a href="#CSS选择器⭐" class="headerlink" title="CSS选择器⭐"></a>CSS选择器⭐</h2><h3 id="选择器类别"><a href="#选择器类别" class="headerlink" title="选择器类别"></a>选择器类别</h3><table>
<thead>
<tr>
<th>选择器</th>
<th align="left">语法</th>
</tr>
</thead>
<tbody><tr>
<td>元素（标签）选择器</td>
<td align="left"><code>标签名&#123;&#125;</code> <code>p&#123;&#125;  h1&#123;&#125;  div&#123;&#125;</code></td>
</tr>
<tr>
<td>id选择器</td>
<td align="left"><code>#id属性值&#123;&#125;</code> <code>#box&#123;&#125; #red&#123;&#125;</code></td>
</tr>
<tr>
<td>类选择器</td>
<td align="left"><code>.class属性值&#123;&#125;</code></td>
</tr>
<tr>
<td>通配选择器</td>
<td align="left"><code>*</code> 选中页面中的所有元素</td>
</tr>
<tr>
<td>交集选择器</td>
<td align="left"><code>选择器1选择器2选择器3选择器n&#123;&#125;</code></td>
</tr>
<tr>
<td>选择器分组（并集选择器）</td>
<td align="left"><code>选择器1,选择器2,选择器3,选择器n&#123;&#125;</code></td>
</tr>
<tr>
<td>子元素选择器</td>
<td align="left"><code>父元素 &gt; 子元素</code></td>
</tr>
<tr>
<td>后代元素选择器</td>
<td align="left"><code>祖先 后代</code></td>
</tr>
<tr>
<td>选择下一个兄弟</td>
<td align="left"><code>前一个 + 下一个</code></td>
</tr>
<tr>
<td>选择下边所有的兄弟</td>
<td align="left"><code>兄 ~ 弟</code></td>
</tr>
<tr>
<td>属性选择器</td>
<td align="left"><code>[属性名]</code> <code>[属性名=属性值]</code> ……</td>
</tr>
<tr>
<td>伪类选择器</td>
<td align="left">伪类一般情况下都是使用<code>:</code>开头</td>
</tr>
<tr>
<td>伪元素选择器</td>
<td align="left">伪元素使用 <code>::</code> 开头</td>
</tr>
<tr>
<td>样式的继承</td>
<td align="left">为一个元素设置的样式同时也会应用到它的后代元素上</td>
</tr>
</tbody></table>
<p>补充：</p>
<ul>
<li><p>class是一个标签的属性，它和id类似，不同的是class可以重复使用</p>
</li>
<li><p>交集选择器选中同时复合多个条件的元素，最多只能够交2个。如果有元素选择器，必须使用元素选择器开头。</p>
</li>
<li><p>伪类用来描述一个元素的特殊状态，<code>:first-child</code> 第一个子元素，<code>:last-child</code>，最后一个子元素 <code>:nth-child()</code> 选中第n个子元素。</p>
</li>
<li><p>a元素的伪类。<code>:link</code> 用来表示没访问过的链接（正常的链接），<code>:visited</code> 用来表示访问过的链接（由于隐私的原因，所以visited这个伪类只能修改链接的颜色），<code>:hover</code> 用来表示鼠标移入的状态，<code>:active</code> 用来表示鼠标点击。</p>
</li>
<li><p>伪元素，表示页面中一些特殊的并不真实的存在的元素（特殊的位置）</p>
<ul>
<li><code>::first-letter</code> 表示第一个字母</li>
<li><code>::first-line</code> 表示第一行</li>
<li><code>::selection</code> 表示选中的内容</li>
<li><code>::before</code> 元素的开始 </li>
<li><code>::after</code> 元素的最后<ul>
<li><strong>before 和 after 必须结合content属性来使用</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>继承的设计是为了方便我们的开发，利用继承我们可以将一些通用的样式统一设置到共同的祖先元素上，这样只需设置一次即可让所有的元素都具有该样式。并不是所有的样式都会被继承。 比如：<strong>背景相关的，布局相关等的这些样式都不会被继承。</strong></p>
</li>
</ul>
<h3 id="选择器权重"><a href="#选择器权重" class="headerlink" title="选择器权重"></a>选择器权重</h3><p>CSS 中的权重，指的是<strong>选择器的优先级</strong>。</p>
<p>CSS 选择器的权重高，即选择器的优先级高。CSS 的优先级特性表现为，对同一 HTML 元素设置样式时，不同选择器的优先级不同，优先级低的样式将被高优先级的样式层叠掉。</p>
<p>CSS 权重优先级顺序简单表示为：</p>
<p><code>!important &gt; 内联样式 &gt; ID &gt; 类、伪类、属性 &gt; 标签名、伪元素  &gt; 通配符 &gt; 继承样式</code></p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>权重</th>
</tr>
</thead>
<tbody><tr>
<td>通配符 <code>*</code></td>
<td>0</td>
</tr>
<tr>
<td>标签 伪元素选择器<code>p&#123;&#125;  h1&#123;&#125;  div&#123;&#125;</code>/<code>::after, ::before</code></td>
<td>1</td>
</tr>
<tr>
<td>类/伪类/属性 <code>.class属性值</code> /<code>:nth-child()</code> / <code>[属性名]</code></td>
<td>10</td>
</tr>
<tr>
<td>ID <code>#id属性值&#123;&#125;</code></td>
<td>100</td>
</tr>
<tr>
<td>内联样式 <code>style=&quot;&quot;</code></td>
<td>1000</td>
</tr>
<tr>
<td>important  <code>.d1&#123; background-color: purple !important;&#125;</code></td>
<td>1/0(无穷大)</td>
</tr>
</tbody></table>
<h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><p>元素提升为一个比较特殊的图层，在三维空间中 <strong>(z轴)</strong> 高出普通元素一等。</p>
<ul>
<li>触发条件<ul>
<li>根层叠上下文(<code>html</code>)</li>
<li><code>position</code></li>
<li>css3属性<ul>
<li><code>flex</code></li>
<li><code>transform</code></li>
<li><code>opacity</code></li>
<li><code>filter</code></li>
<li><code>will-change</code></li>
<li><code>-webkit-overflow-scrolling</code></li>
</ul>
</li>
</ul>
</li>
<li>层叠等级：层叠上下文在z轴上的排序<ul>
<li>在同一层叠上下文中，层叠等级才有意义</li>
<li><code>z-index</code>的优先级最高</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o3dDRs"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/11/30/o3dDRs.png" alt="o3dDRs.png"></a></p>
<h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><p>过渡（transition）</p>
<ul>
<li><code>transition-property</code>: 属性</li>
<li><code>transition-duration</code>: 间隔</li>
<li><code>transition-timing-function</code>: 曲线</li>
<li><code>transition-delay</code>: 延迟</li>
<li>常用钩子: <code>transitionend</code></li>
</ul>
<p>动画（animation）</p>
<ul>
<li><code>animation-name</code>: 动画名称，对应<code>@keyframes</code></li>
<li><code>animation-duration</code>: 间隔</li>
<li><code>animation-timing-function</code>: 曲线</li>
<li><code>animation-delay</code>: 延迟</li>
<li><code>animation-iteration-count</code>: 次数<ul>
<li><code>infinite</code>: 循环动画</li>
</ul>
</li>
<li><code>animation-direction</code>: 方向<ul>
<li><code>alternate</code>: 反向播放</li>
</ul>
</li>
<li><code>animation-fill-mode</code>: 静止模式<ul>
<li><code>forwards</code>: 停止时，保留最后一帧</li>
<li><code>backwards</code>: 停止时，回到第一帧</li>
<li><code>both</code>: 同时运用 <code>forwards / backwards</code></li>
</ul>
</li>
<li>常用钩子: <code>animationend</code></li>
</ul>
<p><strong>变形（transform）</strong></p>
<p>就是指通过CSS来改变元素的形状或位置</p>
<ul>
<li><code>translate</code> 平移</li>
<li><code>scale</code>  缩放</li>
<li><code>rotate</code> 旋转</li>
</ul>
<h2 id="less⭐"><a href="#less⭐" class="headerlink" title="less⭐"></a>less⭐</h2><p>less是一门css的预处理语言</p>
<ul>
<li>less是一个css的增强版，通过less可以<strong>编写更少的代码实现更强大的样式</strong>，添加了许多的新特性：像对<strong>变量</strong>的支持、对<strong>mixin</strong>的支持… …</li>
<li>less的语法大体上和css语法一致，但是less中增添了许多对css的扩展，所以浏览器无法直接执行less代码，要执行必须向将<strong>less转换为css</strong>，然后再由浏览器执行</li>
</ul>
<p>特点</p>
<ul>
<li><p>结构写的更加清晰</p>
</li>
<li><p>变量 <code>@变量名</code></p>
</li>
<li><p><code>&amp;</code> 表示外层的父元素</p>
</li>
<li><p><code>:extend()</code> 对当前选择器扩展指定选择器的样式（选择器分组）</p>
</li>
<li><p>Mixins 混合</p>
<ul>
<li><p>直接对指定的样式进行引用，这里就相当于将p1的样式在这里进行了复制</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.p3</span>&#123;</span><br><span class="line">    <span class="selector-class">.p1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用类选择器时可以在选择器后边添加一个括号，这时我们实际上就创建了一个mixin</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.p4</span>()&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.p5</span>&#123;</span><br><span class="line">    <span class="selector-class">.p4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在混合函数中可以直接设置变量，调用混合函数，按顺序（或指定名称）传递参数，有默认值时可以不全部传值</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test</span>(<span class="variable">@w</span>:<span class="number">100px</span>,<span class="variable">@h</span>:<span class="number">200px</span>,<span class="variable">@bg-color</span>:red)&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">@w</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">@h</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="variable">@bg-color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="comment">//调用混合函数，按顺序传递参数</span></span><br><span class="line">    <span class="comment">// .test(200px,300px,#bfa);</span></span><br><span class="line">    <span class="selector-class">.test</span>(<span class="number">300px</span>);</span><br><span class="line">    <span class="comment">// .test(@bg-color:red, @h:100px, @w:300px);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="script标签的defer和async属性有什么区别"><a href="#script标签的defer和async属性有什么区别" class="headerlink" title="script标签的defer和async属性有什么区别"></a>script标签的defer和async属性有什么区别</h2><p>MDN关于defer和async属性的说明如下：</p>
<ol>
<li>不设置async和defer属性， 那么脚本会同步下载并执行， 阻塞后续dom的渲染</li>
<li>defer属性（延迟脚本），相当于告诉浏览器<strong>立即下载</strong>，但是<strong>延迟执行</strong>。 设置了defer属性的脚本会<strong>被延迟到整个页面都解析完毕后再运行</strong>，先于DOMContentLoaded事件执行，并且按照加载顺序执行。</li>
<li>async属性（异步脚本），不保证按序执行，<strong>可能会阻塞HTML解析</strong>，取决于脚本下载完成时HTML是否解析完毕。</li>
</ol>
<h2 id="CSS三角形"><a href="#CSS三角形" class="headerlink" title="CSS三角形"></a>CSS三角形</h2><p>伪元素+border属性(内容区不要设置宽高)</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-top</span>: <span class="number">20px</span> solid white;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">20px</span> solid transparent;</span><br></pre></td></tr></table></figure>

<h1 id="JacaScript"><a href="#JacaScript" class="headerlink" title="JacaScript"></a>JacaScript</h1><h2 id="内置类型⭐"><a href="#内置类型⭐" class="headerlink" title="内置类型⭐"></a>内置类型⭐</h2><blockquote>
<p><strong>数据类型其实是值的类型，所以值就是具体数据</strong>。<strong>变量是命名的存储容器，是值的容器</strong>。</p>
</blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ECMAScript 规范规定语言类型有六种 <code>Undefined，Null，Boolean，String，Number，和 Object</code>。 <code>Symbol</code>：ES6 引入的一种新的原始值，表示独一无二的值，主要为了解决属性名冲突问题。<code>BigInt</code> ：ES2020 新增加，是比 Number 类型的整数范围更大。</p>
<p>其中 Object 是引用类型（包括普通Object、Function、Array、Date、RegExp、Math），其他是基本类型。他们的划分方式其实是其是否可以表示为固定长度， 比如<code>Undefined，Null，Boolean，String，Number</code> 这些可以有<strong>固定长度</strong>，因此是<strong>基本类型</strong>，并且保存到了<strong>栈</strong>上。 <code>Object</code> 由于<strong>不可预知长度</strong>，并且可以 mutate，因此算引用类型，会被分配到了另一块区域，我们称之为<strong>堆（heap）</strong>。</p>
<blockquote>
<p>字符串是不可变的，因此被认为有固定长度。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IZyIN4"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/11/04/IZyIN4.jpg" alt="IZyIN4.jpg"></a></p>
<p>其实类型指的是<strong>值的类型</strong>，不是变量的类型，这是动态语言和静态语言的差异。 对于静态语言来说，我们可以限定一个变量的类型。但是对于 JS 这种<strong>动态类型的语言</strong>来说， 我们无法给变量限定类型，变量的类型是可变的。举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// &quot;number&quot;</span></span><br><span class="line"></span><br><span class="line">a = &#123;&#125;;</span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><blockquote>
<p>优点：能够快速区分基本数据类型 缺点：不能将Object、Array和Null区分，都返回object</p>
</blockquote>
<ol>
<li><p><code>typeof</code>的作用？</p>
<p>区分数据类型，可以返回7种数据类型：<code>number、string、boolean、undefined、object、function</code> ，以及 <code>ES6</code> 新增的 <code>symbol</code>，和最新的<code>bigint</code></p>
</li>
<li><p><code>typeof</code> 能正确区分数据类型吗？</p>
<p>不能。对于原始类型，除 <code>null</code> 都可以正确判断；对于引用类型，除 <code>function</code> 外，都会返回 <code>&quot;object&quot;</code></p>
</li>
<li><p><code>typeof</code> 注意事项</p>
<ul>
<li><code>typeof</code> 返回值为 <code>string</code> 格式，注意类似这种考题: <code>typeof(typeof(undefined)) -&gt; &quot;string&quot;</code></li>
<li><code>typeof</code> 未定义的变量不会报错，返回 <code>&quot;undefiend&quot;</code>。尝试去读一个未定义的变量的值其实会直接<code>Reference Error</code>。undefined 不是未定义，而是定义了但没有赋值。</li>
<li><code>typeof(null) -&gt; &quot;object&quot;</code>: 遗留已久的 <code>bug</code></li>
<li><code>typeof</code>无法区别数组与普通对象: <code>typeof([]) -&gt; &quot;object&quot;</code></li>
<li><code>typeof(NaN) -&gt; &quot;number&quot;</code></li>
<li><code>typeof</code> 的返回值之一为<code>&#39;function&#39;</code>，如果 <code>typeof</code> 为 <code>function</code>，那么 <code>typeof(typeof)</code> 会返回<code>&#39;function&#39;</code>，但是经测试，上述代码浏览器会抛出错误。因此可以证明 <code>typeof</code> 并非函数。<code>typeof</code> 是操作符。</li>
</ul>
</li>
</ol>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><blockquote>
<p>优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象 缺点：Number，Boolean，String基本数据类型不能判断</p>
</blockquote>
<ol>
<li><code>instanceof</code> 判断对象的原型链上是否存在构造函数的原型。只能判断引用类型。</li>
<li><code>instanceof</code> 常用来判断 <code>A</code> 是否为 <code>B</code> 的实例</li>
<li><code>instanceof</code>返回的是一个布尔值</li>
</ol>
<h4 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h4><blockquote>
<p>优点：精准判断数据类型 缺点：写法繁琐不容易记，推荐进行封装后使用</p>
</blockquote>
<p>因为<code>[2].toString()</code>调用的是数组的<code>toSting()</code>方法，而不是对象的<code>toSting()</code>方法。Array改写了Object的toString方法。</p>
<p><code>toSting.call()</code>实际上就是<code>Object.prototype.toSting.call()</code></p>
<p>调用该方法，统一返回格式<code>“[object Xxx]”</code> 的字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">toString.call(<span class="function">()=&gt;</span>&#123;&#125;)       <span class="comment">// [object Function]</span></span><br><span class="line">toString.call(&#123;&#125;)           <span class="comment">// [object Object]</span></span><br><span class="line">toString.call([])           <span class="comment">// [object Array]</span></span><br><span class="line">toString.call(<span class="string">&#x27;&#x27;</span>)           <span class="comment">// [object String]</span></span><br><span class="line">toString.call(<span class="number">22</span>)           <span class="comment">// [object Number]</span></span><br><span class="line">toString.call(<span class="literal">undefined</span>)    <span class="comment">// [object undefined]</span></span><br><span class="line">toString.call(<span class="literal">null</span>)         <span class="comment">// [object null]</span></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>)     <span class="comment">// [object Date]</span></span><br><span class="line">toString.call(<span class="built_in">Math</span>)         <span class="comment">// [object Math]</span></span><br><span class="line">toString.call(<span class="built_in">window</span>)       <span class="comment">// [object Window]</span></span><br></pre></td></tr></table></figure>

<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>Array是一种容器类型，如果你懂的函数式编程或者了解范型的话，你会非常熟悉这个概念。</p>
<p>Array是一种容器类型，可以容纳任何类型，包括自己。如果Array里面容纳Array就会得到一个多维数组。 事实上，JS中有一些类数组， 类数组会有一些数据的属性和方法，但是确实被阉割的，因此对待类数组要小心， 一个稳妥的方法是转化为数组，比如使用<code>Array.from(arrayLike)</code> ,还有一种方法是借方法， 比如<code>Array.prototype.map.call(arrayLike)</code>。</p>
<blockquote>
<p>其实你也可以用Array.prototype.slice.call(arrayLike) 来将类数组转化成数组。</p>
</blockquote>
<p>String 其实就是字符的有序集合，因此我们可以将String看作Char的数组，准确地说，<strong>String是一种类数组。</strong></p>
<h4 id="“1”-”2”-”3”-map-parseInt-的输出结果是多少"><a href="#“1”-”2”-”3”-map-parseInt-的输出结果是多少" class="headerlink" title="[“1”,”2”,”3”].map(parseInt)的输出结果是多少?"></a>[“1”,”2”,”3”].map(parseInt)的输出结果是多少?</h4><p>这个网红题考察的就是 <code>parseInt</code> 有两个参数。 <code>map</code> 传入的函数可执行三个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ele   遍历的元素</span></span><br><span class="line"><span class="comment">// index 遍历的元素索引</span></span><br><span class="line"><span class="comment">// arr   数组</span></span><br><span class="line">arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">ele, index, arr</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>[‘1’,’2’,’3’].map(parseInt)相当于执行了以下三次过程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>, [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;2&#x27;</span>, <span class="number">1</span>, [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;3&#x27;</span>, <span class="number">2</span>, [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>parseInt(&#39;1&#39;, 0, [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;])</code>: radix为0时，默认取10，最后返回<code>1</code></li>
<li><code>parseInt(&#39;2&#39;, 1, [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;])</code>: radix取值为2~36，如果该参数小于 2 或者大于 36，返回<code>NaN</code></li>
<li><code>parseInt(&#39;3&#39;, 2, [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;])</code>: radix取值为2，二进制只包括0，1，返回<code>NaN</code></li>
</ul>
<h4 id="如何让上述代码返回-1-2-3-，使用你能想到的最简单的方案-要求使用-map"><a href="#如何让上述代码返回-1-2-3-，使用你能想到的最简单的方案-要求使用-map" class="headerlink" title="如何让上述代码返回[1,2,3]，使用你能想到的最简单的方案(要求使用[].map())"></a>如何让上述代码返回[1,2,3]，使用你能想到的最简单的方案(要求使用[].map())</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>].map(<span class="built_in">Number</span>)</span><br></pre></td></tr></table></figure>

<h4 id="splice和slice你能说说有啥用和区别吗"><a href="#splice和slice你能说说有啥用和区别吗" class="headerlink" title="splice和slice你能说说有啥用和区别吗"></a>splice和slice你能说说有啥用和区别吗</h4><p><strong>slice：截取功能</strong></p>
<ul>
<li>截取<strong>数组</strong>为主，也可以截取<strong>字符串</strong></li>
<li>返回新的数组，<strong>包含截取的元素</strong></li>
<li><strong>不改变原数组</strong></li>
<li><strong>左开右闭</strong>，不写默认全部</li>
</ul>
<p><strong>splice()：数组增删查改</strong></p>
<ul>
<li>只能对数组增删查改，字符串无效</li>
<li>返回新的数组，内容是<strong>被删除的元素</strong></li>
<li>会<strong>改变原数组</strong></li>
<li><code>(开始位置的索引,删除的数量,传递一些新的元素)</code></li>
</ul>
<h4 id="怎么判断数组"><a href="#怎么判断数组" class="headerlink" title="怎么判断数组"></a>怎么判断数组</h4><ol>
<li><code>ES6</code> 提供的新方法 <code>Array.isArray()</code></li>
<li>如果不存在<code>Array.isArray()</code>呢？可以借助<code>Object.prototype.toString.call()</code> 进行判断，此方式兼容性最好</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray) &#123;</span><br><span class="line">    <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span>(o) === <span class="string">&#x27;object&#x27;</span> </span><br><span class="line">               &amp;&amp; <span class="built_in">Object</span>.prototype.toString.call(o) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>instanceof</code> 判断</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果为true，则arr为数组</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span></span><br></pre></td></tr></table></figure>

<p><code>instanceof</code> 判断数组类型如此之简单，为何不推荐使用？</p>
<p><code>instanceof</code> 操作符的问题在于，如果网页中存在多个 <code>iframe</code> ，那便会存在多个<code>Array</code>构造函数，此时判断是否是数组会存在问题。</p>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><h4 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1 + 0.2 !== 0.3?"></a>0.1 + 0.2 !== 0.3?</h4><p><code>0.1+0.3 === 0.4</code>？</p>
<p>JS 至今没有真正的整数，我们用的number事实上是浮点数。 JavaScript 明确地使用了“双精度”（也就是“64位二进制”）格式。</p>
<p>这部分常考的一个点是精度问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>为什么会这样？</li>
</ul>
<p>简单地说，0.1 和 0.2 的二进制表示形式是不精确的，所以它们相加时，结果不是精确地 0.3。而是<strong>非常接近的值</strong>：0.30000000000000004，但是如果你的比较失败了，“接近”是无关紧要的。</p>
<ul>
<li>如何解决？</li>
</ul>
<p>最常见的做法是使用一个很小的“错误舍入”值作为比较的 容差。 这个很小的值经常被称为“机械极小值（machine epsilon）”， 对于 JavaScript 来说这种 number 通常为 <code>Number.EPSILON</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numbersCloseEnoughToEqual</span>(<span class="params">n1,n2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs( n1 - n2 ) &lt; <span class="built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0.3</span>;</span><br><span class="line"></span><br><span class="line">numbersCloseEnoughToEqual( a, b );                    <span class="comment">// true</span></span><br><span class="line">numbersCloseEnoughToEqual( <span class="number">0.0000001</span>, <span class="number">0.0000002</span> );    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="number能表示的整数的最大范围"><a href="#number能表示的整数的最大范围" class="headerlink" title="number能表示的整数的最大范围"></a>number能表示的整数的最大范围</h4><ol>
<li>安全的整数范围：15位数以下</li>
<li>JavaScript 并不能表示任意位的整数，最大的整数是<code>Number.MAX_SAFE_INTEGER(9007199254740991)</code>，最小的整数是<code>Number.MIN_SAFE_INTEGER(-9007199254740991)</code></li>
<li>特别注意，很多ID是超出这个范围的，所以ID最好是用<code>string</code>，当ID超出<strong>15</strong>位数的话，就肯定要用字符串类型了。</li>
<li>超出会失准</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">9007199254740995</span></span><br><span class="line">a; <span class="comment">// 9007199254740996</span></span><br></pre></td></tr></table></figure>

<h3 id="undefined与null的区别"><a href="#undefined与null的区别" class="headerlink" title="undefined与null的区别?"></a>undefined与null的区别?</h3><ul>
<li><p>undefined代表<strong>定义未赋值</strong></p>
</li>
<li><p>nulll<strong>定义并赋值了, 只是值为null</strong></p>
</li>
<li><p>代码示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// undefined</span></span><br><span class="line">a = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// null</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>什么时候给变量赋值为null呢?</strong></p>
<ul>
<li><p>初始赋值, 表明将要赋值为对象,<code>可以用做约定俗成的占位符</code></p>
</li>
<li><p>结束前, <code>让对象成为垃圾对象</code>(被垃圾回收器回收)</p>
</li>
<li><p>代码示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//起始,可以用做约定俗成的占位符</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="literal">null</span>  <span class="comment">// 初始赋值为null, 表明将要赋值为对象</span></span><br><span class="line">  <span class="comment">//确定对象就赋值</span></span><br><span class="line">  b = [<span class="string">&#x27;atguigu&#x27;</span>, <span class="number">12</span>]</span><br><span class="line">  <span class="comment">//最后在不使用的时候,将其引用置空,就可以释放b这个对象占用的内存      ---当没有引用指向它的对象称为垃圾对象</span></span><br><span class="line">  b = <span class="literal">null</span> <span class="comment">// 让b指向的对象成为垃圾对象(被垃圾回收器回收) </span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>===</code> 是严格相等，要求数据类型和值都要相等；<code>==</code> 只需要值相等。</li>
<li><code>==</code> 会发生隐式类型转换，<code>===</code> 不会发生隐式类型转换。</li>
</ul>
<h3 id="查询某个对象是否有某个属性的方法"><a href="#查询某个对象是否有某个属性的方法" class="headerlink" title="查询某个对象是否有某个属性的方法"></a>查询某个对象是否有某个属性的方法</h3><h4 id="使用in关键字"><a href="#使用in关键字" class="headerlink" title="使用in关键字"></a>使用in关键字</h4><p>该方法可以判断对象的<strong>自有属性</strong>和<strong>继承来的属性</strong>是否存在。</p>
<h4 id="使用对象的hasOwnProperty-方法"><a href="#使用对象的hasOwnProperty-方法" class="headerlink" title="使用对象的hasOwnProperty()方法"></a>使用对象的hasOwnProperty()方法</h4><p>该方法<strong>只能判断自有属性</strong>是否存在，对于继承属性会返回false。</p>
<h4 id="使用undefined判断"><a href="#使用undefined判断" class="headerlink" title="使用undefined判断"></a>使用undefined判断</h4><p>自有属性和继承属性均可判断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;x:1&#125;;</span><br><span class="line">o.x!==undefined;    //true</span><br><span class="line">o.y!==undefined;    //false</span><br><span class="line">o.toString!==undefined  //true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该方法存在一个问题，如果属性的值就是undefined的话，该方法不能返回想要的结果，如下:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;x:undefined&#125;;</span><br><span class="line">o.x!==undefined;    //false，属性存在，但值是undefined</span><br><span class="line">o.y!==undefined;    //false</span><br><span class="line">o.toString!==undefined  //true</span><br></pre></td></tr></table></figure>

<h4 id="在条件语句中判断"><a href="#在条件语句中判断" class="headerlink" title="在条件语句中判断"></a>在条件语句中判断</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;&#125;;</span><br><span class="line">if(o.x) o.x+=1; //如果x是undefine,null,false,&quot; &quot;,0或NaN,它将保持不变</span><br></pre></td></tr></table></figure>

<h4 id="propertyIsEnumerable-NaN"><a href="#propertyIsEnumerable-NaN" class="headerlink" title="propertyIsEnumerable()"></a>propertyIsEnumerable()</h4><p>propertyIsEnumerable() 是hasOwnProperty() 的增强版，这个方法的用法与hasOwnProperty()相同，但当检测属性是<strong>自有属性(非继承)且这个属性是可枚举的</strong>，才会返回true。</p>
<h2 id="作用域与闭包⭐"><a href="#作用域与闭包⭐" class="headerlink" title="作用域与闭包⭐"></a>作用域与闭包⭐</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域(即<code>scope</code>, 其实更确切地说是<code>lexical scope</code>)就是一套变量访问规则，这些规则包括<strong>变量如何存储和访问，也就是规定了哪些变量可以被访问，哪些变量不可以被访问</strong>。</p>
<p>假设有如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&quot;number&quot;</span> || a <span class="keyword">instanceof</span> <span class="built_in">Number</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> b = a + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>我们来看下这段代码。 这段代码在 JS 引擎执行的时候究竟发生了什么？ 这里我画了个图：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IZfuPU"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/11/04/IZfuPU.jpg" alt="IZfuPU.jpg"></a></p>
<p>如上图，左边部分是编译器。 右半部分是作用域链。上述代码执行的具体过程大概是：</p>
<ul>
<li><p>JS 源代码经过语法分析，转化成 <code>tokens</code></p>
</li>
<li><p>tokens 经过语义分析，转化为 <code>AST(抽象语法树)</code></p>
</li>
<li><p>抽象语法树会被转化为字节码</p>
</li>
<li><p>JS 运行时开始运行这段上面生成代码</p>
</li>
<li><p>当代码执行到函数声明的时候，引擎会向 <code>scope chain</code> 询问(一个 RHS)，<code>foo</code> 是否已经声明 在这里是没有声明，会在当前 scope(也就是 <code>global scope</code>)创建一个 foo</p>
<blockquote>
<p>console 是 内置对象， 虽然不是我们声明的，但是它已经在全局作用域了。</p>
</blockquote>
</li>
<li><p>执行 foo。 引擎同样会询问 scope chain(一个 RHS)，foo 是否已经声明。 在这里是声明了，如果没声明会报<code>Reference Error</code>。</p>
</li>
<li><p>代码进到了 foo， 我们创建一个新的作用域，这个作用域指向全局作用域，从而形成作用域链。</p>
</li>
<li><p>下次引擎发送 RHS，如果当前作用域找到就返回，找不到就沿着链找，最终都找不到就报<code>Reference Error</code>， 过程类似原型链。</p>
</li>
</ul>
<blockquote>
<p>注意图中块级作用域的位置，这也就解释了，为什么块级作用域声明的变量在块外面是无法访问的。</p>
</blockquote>
<blockquote>
<p>上述过程忽略了一些细节，比如生成 optimized AST 和 optimized byte code 的过程</p>
</blockquote>
<p>事实上，作用域背后地原理是<code>词法环境</code>， 词法环境由两部分组成：</p>
<ol>
<li>环境记录， 这其实就是JavaScript用来存变量地地方，一个key-value对在这里被成为一个binding。</li>
<li>外部环境的引用</li>
</ol>
<p>其实它就是一个递归的数据结构，是不是有像刚才我们画的作用域？</p>
<p>我们需要特殊注意的是全局作用域，这是一个特殊的作用域，总是出现在作用域的最外层。全局作用域 对应的环境就是<code>全局环境</code>，全局作用域的<code>外部环境引用</code>是null。是不是感觉和原型链什么的都很像？</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。</p>
<p>从理论上来说<code>JS 中一切函数都有闭包</code>，其原因就是 JS 和大多数编程语言一样采用的是静态作用域.</p>
<p>但是我们通常谈论的是<code>可观察的</code>闭包，什么是可观察？ 我们来举个例子，这是一个<code>可观察</code>的闭包例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> c = <span class="string">&quot;closures&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&quot;number&quot;</span> || a <span class="keyword">instanceof</span> <span class="built_in">Number</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> b = a + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> func = foo();</span><br><span class="line">func(); <span class="comment">// &#x27;closures&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码foo作用域的c在foo的外侧被访问到了，这就是一个<code>可观察</code>的闭包.</p>
<p>为什么呢？ 这和上面的说的好像不太一样？ 不，是一样的。我同样画了一个图：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IZfM24"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/11/04/IZfM24.jpg" alt="IZfM24.jpg"></a></p>
<p>说的直白一点就是foo返回的函数<code>记住了ta被定义的时候的作用域</code>，因此你可以访问到foo里面定义的变量。 看起来好像是<code>突破了作用域的限制</code>，我们称之为<code>可观察</code>的闭包。</p>
<blockquote>
<p>当然没有被这个返回的函数引用的变量还是会被GC销毁</p>
</blockquote>
<h4 id="1）什么是闭包"><a href="#1）什么是闭包" class="headerlink" title="1）什么是闭包"></a>1）什么是闭包</h4><p><strong>函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包</strong>。</p>
<p>可以在内部函数访问到外部函数作用域。</p>
<p>使用闭包，一可以<strong>读取函数中的变量</strong>，二可以<strong>将函数中的变量存储在内存中，保护变量不被污染</strong>。</p>
<p>而正因闭包会把函数中的变量值存储在内存中，会对内存有消耗，所以不能滥用闭包，否则会影响网页性能，造成<strong>内存泄漏</strong>。</p>
<p>当不需要使用闭包时，要及时<strong>释放内存</strong>，可将内层函数对象的变量赋值为null。</p>
<h4 id="2）闭包原理"><a href="#2）闭包原理" class="headerlink" title="2）闭包原理"></a>2）闭包原理</h4><p>函数执行分成两个阶段(预编译阶段和执行阶段)。</p>
<ul>
<li>在预编译阶段，如果发现<strong>内部函数使用了外部函数的变量</strong>，则会在内存中创建一个“<strong>闭包</strong>”对象并保存对应变量值，如果已存在“闭包”，则只需要增加对应属性值即可。</li>
<li>执行完后，函数执行上下文会被销毁，函数对“闭包”对象的引用也会被销毁，但其内部函数还持用该“闭包”的引用，所以内部函数可以继续使用“外部函数”中的变量</li>
</ul>
<p>利用了函数作用域链的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁，直到内部函数被烧毁后才被销毁。</p>
<h4 id="3）优点"><a href="#3）优点" class="headerlink" title="3）优点"></a>3）优点</h4><ol>
<li>可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用</li>
<li>避免变量污染全局</li>
<li>把变量存到独立的作用域，作为私有成员存在</li>
</ol>
<h4 id="4）缺点"><a href="#4）缺点" class="headerlink" title="4）缺点"></a>4）缺点</h4><ol>
<li>对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏</li>
<li>对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度</li>
<li>可能获取到意外的值(captured value)</li>
</ol>
<h4 id="4）应用场景"><a href="#4）应用场景" class="headerlink" title="4）应用场景"></a>4）应用场景</h4><p><strong>应用场景一：</strong> 典型应用是模块封装，在各模块规范出现之前，都是用这样的方式防止变量污染全局。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Yideng = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这样声明为模块私有变量，外界无法直接访问</span></span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Yideng</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    Yideng.prototype.bar = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> foo;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Yideng;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p><strong>应用场景二：</strong> 在循环中创建闭包，防止取到意外的值。</p>
<p>如下代码，无论哪个元素触发事件，都会弹出 3。因为函数执行后引用的 i 是同一个，而 i 在循环结束后就是 3</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;id&#x27;</span> + i).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可用闭包解决</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCallback</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(num);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;id&#x27;</span> + i).onfocus = makeCallback(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用和操作符优先级⭐"><a href="#引用和操作符优先级⭐" class="headerlink" title="引用和操作符优先级⭐"></a>引用和操作符优先级⭐</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = a.x = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<ul>
<li>先输出{x:1}</li>
<li>再输出{x:{x:1}}</li>
</ul>
<p>解释：</p>
<p>解决这道题目的关键点有两个</p>
<ol>
<li>.操作符的的运算优先级问题, <code>.</code>的优先级高于赋值语句</li>
<li>能够明白浏览器的内存分配原理</li>
</ol>
<p>为了方便理解，我画了内存图。</p>
<p>当执行到以下代码的时候</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br></pre></td></tr></table></figure>

<p>内存图如图所示：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IZhGlQ"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/11/04/IZhGlQ.jpg" alt="IZhGlQ.jpg"></a></p>
<p>然后，我们将下面代码拆解为:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.x = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line">a = a.x;</span><br></pre></td></tr></table></figure>

<p>当执行到<code>a.x = &#123; x: 1 &#125;;</code>的时候，内存是这样的：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IZhJyj"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/11/04/IZhJyj.jpg" alt="IZhJyj.jpg"></a></p>
<p>最后，当执行到：<code>a = a.x;</code>的时候，内存图如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IZh8Sg"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/11/04/IZh8Sg.jpg" alt="IZh8Sg.jpg"></a></p>
<h2 id="原型与原型链⭐"><a href="#原型与原型链⭐" class="headerlink" title="原型与原型链⭐"></a>原型与原型链⭐</h2><p><code>JavaScript</code>所有的对象本质上都是通过<code>new 函数</code>创建的，包括对象字面量的形式定义对象(相当于<code>new Object()</code>的语法糖)。</p>
<p>所有的函数本质上都是通过<code>new Function</code>创建的，包括<code>Object</code>、<code>Array</code>等。</p>
<p>所有的函数都是对象。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Tkh7H1"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2021/12/17/Tkh7H1.png" alt="Tkh7H1.png"></a></p>
<ul>
<li>每个函数都有一个属性<code>prototype</code>，它就是原型，默认情况下它是一个普通<code>Object</code>对象，这个对象是调用该构造函数所创建的实例的原型。</li>
<li>JavaScript同样存在由原型指向构造函数的属性：<code>constructor</code>，即<code>Func.prototype.constructor --&gt; Func</code></li>
<li><code>JavaScript</code>中所有对象(除了<code>null</code>)都具有一个<code>__proto__</code>属性，该属性指向该对象的原型。</li>
</ul>
<p>实例对象在查找属性时，如果查找不到，就会沿着<code>__proto__</code>去与对象关联的原型上查找，如果还查找不到，就去找原型的原型，直至查到最顶层，这也就是原型链的概念。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TkhJ0I"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2021/12/17/TkhJ0I.png" alt="TkhJ0I.png"></a></p>
<ul>
<li><p>所有函数(包括<code>Function</code>)的<code>__proto__</code>指向<code>Function.prototype</code></p>
</li>
<li><p>自定义对象实例的<code>__proto__</code>指向构造函数的原型</p>
</li>
<li><p>函数的<code>prototype</code>的<code>__proto__</code>指向<code>Object.prototype</code></p>
</li>
<li><p><code>Object.prototype.__proto__ --&gt; null</code></p>
</li>
</ul>
<h2 id="原型和继承⭐"><a href="#原型和继承⭐" class="headerlink" title="原型和继承⭐"></a>原型和继承⭐</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是一种代码复用的方式。在面向对象编程中，继承是一个很重要的点。</p>
<p>在JS中继承背后的原理是原型<code>prototype</code>, 这种实现继承的方式，我们称之为原型继承。</p>
<h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><p>JS中一些全局内置函数，分别为Functon, Array, Object.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>); <span class="comment">// -&gt; ƒ Object() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>); <span class="comment">// -&gt; ƒ Array() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>); <span class="comment">// -&gt; ƒ Function() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>所有的数组对象，都是由全局内置函数Array创建的</li>
<li>所有的object对象，都是由全局内置函数Object创建的</li>
<li>所有的函数对象，都是由全局内置函数Function创建的</li>
</ul>
<p>其他也是同理，比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>.__proto__ === <span class="built_in">Number</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27;.__proto__ === String.prototype; // true</span></span><br><span class="line"><span class="string">true.__proto__ === Boolean.prototype; // true</span></span><br></pre></td></tr></table></figure>

<h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h3><p><code>__proto__</code>是一个内部属性，不建议对其进行直接操作。 而是建议通过<code>prototype</code>来进行操作。</p>
<p><code>一个对象的__proto__总是指向它的构造函数的prototype</code>。</p>
<blockquote>
<p>构造函数指的是创建这个对象的函数， 比如 foo = new Foo(), 那么Foo就是foo的构造函数。</p>
</blockquote>
<p>让我们来继续看一下上面的代码, 就不难理解了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>.__proto__ === <span class="built_in">Number</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27;.__proto__ === String.prototype; // true</span></span><br><span class="line"><span class="string">true.__proto__ === Boolean.prototype; // true</span></span><br></pre></td></tr></table></figure>

<p>除此我们需要注意一点，那就是<code>Object.prototype.__proto__</code> 值为 null。 其实也就是继承链的终点。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>为了能够明白原型链和继承，我们首先要知道“属性查找机制”。</p>
<p>当我们访问一个对象的属性的时候，引擎首先会在当前对象进行查找，如果找不到就会访问该对象的<code>__proto__</code>， 如果<code>__proto__</code>有了，就返回，如果没有则递归执行上述过程，直到<code>__proto__</code> 为 <code>null</code>。</p>
<p>对于如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.access</span><br></pre></td></tr></table></figure>

<p>引擎的内部逻辑大概是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__proto__ === null</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">__proto__ === Object.prototype</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">&#123; object literal &#125;</span><br></pre></td></tr></table></figure>

<p>如果用代码表示的话，大概是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">getProp</span>(<span class="params">obj, prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = obj;</span><br><span class="line">  <span class="keyword">while</span>(proto &amp;&amp; proto[prop] === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">    proto = proto.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> proto === <span class="literal">null</span> ? <span class="keyword">void</span> <span class="number">0</span> : obj[prop];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出这个继承的过程，直接依靠的是<code>__proto__</code>， 只不过就像我上面提到的<code>__proto__ 只是一个指向构造函数原型的引用</code>， 因此开发人员修改了构造函数的原型，就会影响到<code>__proto__</code>， 进而影响了对象的原型链。</p>
<p>当然你可以自己直接修改<code>__proto__</code>，但是不推荐！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto__.nickName = <span class="string">&#x27;lucifer&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// -&gt; &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.nickName); <span class="comment">// -&gt; lucifer</span></span><br></pre></td></tr></table></figure>

<p>整个过程如图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__proto__ === null</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">__proto__ === Object.prototype -&gt; nickName: &#x27;lucifer&#x27;</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">obj</span><br></pre></td></tr></table></figure>

<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>其实继承和原型这部分知识和new是强相关的。 我们有必要了解一下new的原理。</p>
<p>new 的原理很简单, 就是引擎内部新建一个空对象，然后将这个空对象的<code>__proto__</code> 指向构造函数的<code>prototype</code>.然后调用构造函数，去填充我们创建的空对象(如果有必要)。 最后将<code>this</code>指向我们刚刚创建的新对象。</p>
<p>如果用代码来表示，大概是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">constructor, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  obj.__proto__ = <span class="title">constructor</span>.<span class="title">prototype</span>;</span><br><span class="line">  <span class="keyword">const</span> ret = <span class="title">constructor</span>.<span class="title">call</span>(<span class="params">obj, ...args</span>);</span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="检测一下"><a href="#检测一下" class="headerlink" title="检测一下"></a>检测一下</h4><p>我们来看一段代码，来检测一下我们的学习成果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === Fn.prototype);</span><br><span class="line"><span class="comment">// -&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__.__proto__=== <span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="comment">// -&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__.__proto__.__proto__ === <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<p>用图来表示大概是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__proto__ === <span class="literal">null</span></span><br><span class="line">|</span><br><span class="line">|             </span><br><span class="line">__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">__proto__ === Fn.prototype</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">obj</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这一节我们讲解了原型prototype，属性查找机制，以及原型链。</p>
<p>我们直到了实现继承实际上是基于<code>__proto__</code>的，而不是prototype. 我们可以通过构造函数的原型从而修改对象的<code>__proto__</code>。</p>
<p>经过上面的讲解，如果你想实现继承也就不是难事了。</p>
<p>最后来两个思考题：</p>
<ul>
<li>如果我不使用继承来实现代码复用，而是直接挂载到当前对象（this）上，会有什么问题。</li>
<li>如果我们把对象的私有属性挂载到原型上会发生了什么？</li>
</ul>
<h2 id="DOM事件总结⭐"><a href="#DOM事件总结⭐" class="headerlink" title="DOM事件总结⭐"></a>DOM事件总结⭐</h2><blockquote>
<p><strong>知识点主要包括以下几个方面：</strong></p>
<ul>
<li><p>基本概念：DOM事件的级别</p>
<p>面试不会直接问你，DOM有几个级别。但会在题目中体现：“请用DOM2 ….”。</p>
</li>
<li><p>DOM事件模型、DOM事件流</p>
<p>面试官如果问你“<strong>DOM事件模型</strong>”，你不一定知道怎么回事。其实说的就是<strong>捕获和冒泡</strong>。</p>
<p><strong>DOM事件流</strong>，指的是事件传递的<strong>三个阶段</strong>。</p>
</li>
<li><p>描述DOM事件捕获的具体流程</p>
<p>讲的是事件的传递顺序。参数为false（默认）、参数为true，各自代表事件在什么阶段触发。</p>
</li>
<li><p>Event对象的常见应用（Event的常用api方法）</p>
<p>DOM事件的知识点，一方面包括事件的流程；</p>
<p>另一方面就是：怎么去注册事件，也就是监听用户的交互行为。第三点：在响应时，Event对象是非常重要的。</p>
</li>
<li><p>自定义事件（非常重要）</p>
<p>一般人可以讲出事件和注册事件，但是如果让你讲<strong>自定义事件</strong>，能知道的人，就更少了。</p>
</li>
<li><p>事件委托</p>
<p>业务中经常用到。</p>
</li>
</ul>
</blockquote>
<h3 id="DOM事件的级别"><a href="#DOM事件的级别" class="headerlink" title="DOM事件的级别"></a>DOM事件的级别</h3><p>DOM事件的级别，准确来说，是<strong>DOM标准</strong>定义的级别。包括：</p>
<p><strong>DOM0的写法：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种事件绑定的方式，如果绑定多个，则后面的会覆盖掉前面的</span></span><br><span class="line">element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是在 js 中的写法；如果要在html中写，写法是：在onclick属性中，加 js 语句。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;hello&#x27;);&quot;</span>&gt;</span>我是按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p><strong>DOM2的写法：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高版本浏览器</span></span><br><span class="line">element.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>【重要】上面的第三参数中，<strong>true</strong>表示事件在<strong>捕获阶段</strong>触发，<strong>false</strong>表示事件在<strong>冒泡阶段</strong>触发（默认）。如果不写，则默认为false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IE8及以下版本浏览器</span></span><br><span class="line">element.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>参数1：事件名的字符串(注意，有<strong>on</strong>)</li>
<li>参数2：回调函数：当事件触发时，该函数会被执行</li>
</ul>
<p>不同：</p>
<ul>
<li><p><code>addEventListener()</code>中的<code>this</code>，是<strong>绑定事件的对象</strong>。绑定多个响应函数执行顺序是：<strong>先绑定先执行</strong>。</p>
</li>
<li><p><code>attachEvent()</code>中的<code>this</code>是<strong>window</strong> 。绑定多个响应函数执行顺序是，<strong>后绑定先执行</strong>。</p>
</li>
</ul>
<p>兼容写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个函数，用来为指定元素绑定响应函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * addEventListener()中的this，是绑定事件的对象</span></span><br><span class="line"><span class="comment"> * attachEvent()中的this，是window</span></span><br><span class="line"><span class="comment"> *  需要统一两个方法this</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> *  element 要绑定事件的对象</span></span><br><span class="line"><span class="comment"> *  eventStr 事件的字符串(不要on)</span></span><br><span class="line"><span class="comment"> *  callback 回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myBind</span>(<span class="params">element , eventStr , callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(element.addEventListener)&#123;</span><br><span class="line">        <span class="comment">//大部分浏览器兼容的方式</span></span><br><span class="line">        element.addEventListener(eventStr , callback , <span class="literal">false</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * this是谁，由调用方式决定</span></span><br><span class="line"><span class="comment">         * callback.call(element)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//IE8及以下</span></span><br><span class="line">        element.attachEvent(<span class="string">&quot;on&quot;</span>+eventStr , <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//在匿名函数 function 中调用回调函数callback</span></span><br><span class="line">            callback.call(element);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：<strong>call()、apply()、bind() 都是用来重定义 this 这个对象的！</strong>bind 返回的是一个新的函数，你必须调用它才会被执行。</p>
<p><strong>DOM3的写法：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>DOM3中，增加了很多事件类型，比如鼠标事件、键盘事件等。</p>
<p>PS：为何事件没有DOM1的写法呢？因为，DOM1标准制定的时候，没有涉及与事件相关的内容。</p>
<p><strong>总结</strong>：关于“DOM事件的级别”，能回答出以上内容即可，不会出题目让你做。</p>
<h3 id="DOM事件模型、DOM事件流"><a href="#DOM事件模型、DOM事件流" class="headerlink" title="DOM事件模型、DOM事件流"></a>DOM事件模型、DOM事件流</h3><h4 id="DOM事件模型"><a href="#DOM事件模型" class="headerlink" title="DOM事件模型"></a>DOM事件模型</h4><p>DOM事件模型讲的就是<strong>捕获和冒泡</strong>，一般人都能回答出来。</p>
<ul>
<li><p>捕获：从上往下。</p>
</li>
<li><p>冒泡：从下（目标元素）往上。</p>
</li>
</ul>
<h4 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h4><p>DOM事件流讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。</p>
<p>类似于Android里面的事件传递。</p>
<p>完整的事件流，分三个阶段：</p>
<ul>
<li><p>（1）捕获：从 window 对象传到 目标元素。</p>
</li>
<li><p>（2）目标阶段：事件通过捕获，到达目标元素，这个阶段就是目标阶段。</p>
</li>
<li><p>（3）冒泡：从<strong>目标元素</strong>传到 Window 对象。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5KPszR"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/13/5KPszR.png" alt="5KPszR.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5KP6Q1"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/13/5KP6Q1.jpg" alt="5KP6Q1.jpg"></a></p>
<h4 id="描述DOM事件捕获的具体流程"><a href="#描述DOM事件捕获的具体流程" class="headerlink" title="描述DOM事件捕获的具体流程"></a>描述DOM事件捕获的具体流程</h4><h5 id="捕获的流程"><a href="#捕获的流程" class="headerlink" title="捕获的流程"></a>捕获的流程</h5><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5KPrW9"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/13/5KPrW9.png" alt="5KPrW9.png"></a></p>
<p><strong>说明</strong>：捕获阶段，事件依次传递的顺序是：window –&gt; document –&gt; html–&gt; body –&gt; 父元素、子元素、目标元素。</p>
<p>PS1：第一个接收到事件的对象是 <strong>window</strong>（有人会说body，有人会说html，这都是错误的）。</p>
<p>PS2：JS中涉及到DOM对象时，有两个对象最常用：window、doucument。它们俩也是最先获取到事件的。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;捕获 window&quot;</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;捕获 document&quot;</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.documentElement.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;捕获 html&quot;</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;捕获 body&quot;</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">fatherBox.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;捕获 father&quot;</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">childBox.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;捕获 child&quot;</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>补充一个知识点：</strong></p>
<p>在 js中：</p>
<ul>
<li><p>如果想获取 <code>body</code> 节点，方法是：<code>document.body</code>；</p>
</li>
<li><p>但是，如果想获取 <code>html</code>节点，方法是<code>document.documentElement</code>。</p>
</li>
</ul>
<h5 id="冒泡的流程"><a href="#冒泡的流程" class="headerlink" title="冒泡的流程"></a>冒泡的流程</h5><p>与捕获的流程相反</p>
<h3 id="Event对象的常见-api-方法"><a href="#Event对象的常见-api-方法" class="headerlink" title="Event对象的常见 api 方法"></a>Event对象的常见 api 方法</h3><p>用户做的是什么操作（比如，是敲键盘了，还是点击鼠标了），这些事件基本都是通过Event对象拿到的。这些都比较简单，我们就不讲了。我们来看看下面这几个方法：</p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault();</span><br></pre></td></tr></table></figure>

<p>解释：阻止默认事件。</p>
<p>比如，已知<code>&lt;a&gt;</code>标签绑定了click事件，此时，如果给<code>&lt;a&gt;</code>设置了这个方法，就阻止了链接的默认跳转。</p>
<h4 id="方法二：阻止冒泡"><a href="#方法二：阻止冒泡" class="headerlink" title="方法二：阻止冒泡"></a>方法二：阻止冒泡</h4><p>这个在业务中很常见。</p>
<p>有的时候，业务中不需要事件进行冒泡。比如说，业务这样要求：单击子元素做事件A，单击父元素做事件B，如果不阻止冒泡的话，出现的问题是：单击子元素时，子元素和父元素都会做事件A。这个时候，就要用到阻止冒泡了。</p>
<p>w3c的方法：（火狐、谷歌、IE11）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.stopPropagation();</span><br></pre></td></tr></table></figure>

<p>IE10以下则是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.cancelBubble = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>兼容代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">box3.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    alert(<span class="string">&quot;child&quot;</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在IE8及以下的浏览器中，是将事件对象作为**window对象的属性**保存的</span></span><br><span class="line">    event = event || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="comment">//阻止冒泡</span></span><br><span class="line">    <span class="keyword">if</span> (event &amp;&amp; event.stopPropagation) &#123;</span><br><span class="line">        event.stopPropagation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上方代码中，我们对box3进行了阻止冒泡，产生的效果是：事件不会继续传递到 father、grandfather、body了。</p>
<h4 id="方法三：设置事件优先级"><a href="#方法三：设置事件优先级" class="headerlink" title="方法三：设置事件优先级"></a>方法三：设置事件优先级</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.stopImmediatePropagation();</span><br></pre></td></tr></table></figure>

<p>这个方法比较长，一般人没听说过。解释如下：</p>
<p>比如说，我用addEventListener给某按钮同时注册了事件A、事件B。此时，如果我单击按钮，就会依次执行事件A和事件B。现在要求：单击按钮时，只执行事件A，不执行事件B。该怎么做呢？这是时候，就可以用到<code>stopImmediatePropagation</code>方法了。做法是：在事件A的响应函数中加入这句话。</p>
<p>大家要记住 event 有这个方法。</p>
<h4 id="属性4、属性5（事件委托中用到）"><a href="#属性4、属性5（事件委托中用到）" class="headerlink" title="属性4、属性5（事件委托中用到）"></a>属性4、属性5（事件委托中用到）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event.currentTarget   <span class="comment">//返回绑定事件的元素。在事件委托中，指的是【父元素】。</span></span><br><span class="line">event.target  <span class="comment">//返回触发事件的元素。在事件委托中，指的是【子元素】。</span></span><br></pre></td></tr></table></figure>

<p>上面这两个属性，在事件委托中经常用到。</p>
<p><strong>总结</strong>：上面这几项，非常重要，但是容易弄混淆。</p>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>自定义事件的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> Event(<span class="string">&#x27;clickTest&#x27;</span>);</span><br><span class="line">element.addEventListener(<span class="string">&#x27;clickTest&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;smyhvae&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素注册事件</span></span><br><span class="line">element.dispatchEvent(myEvent); <span class="comment">//注意，参数是写事件对象 myEvent，不是写 事件名 clickTest</span></span><br></pre></td></tr></table></figure>

<p>上面这个事件是定义完了之后，就直接自动触发了。在正常的业务中，这个事件一般是和别的事件结合用的。比如延时器设置按钮的动作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> Event(<span class="string">&#x27;clickTest&#x27;</span>);</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">&#x27;clickTest&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;smyhvae&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    element.dispatchEvent(myEvent); <span class="comment">//注意，参数是写事件对象 myEvent，不是写 事件名 clickTest</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>


<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委派指将事件统一绑定给元素的<strong>共同的祖先元素</strong>，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。  事件委派是利用了<strong>冒泡</strong>，通过委派可以减少事件绑定的次数，提高程序的性能。        </p>
<h2 id="this指向⭐"><a href="#this指向⭐" class="headerlink" title="this指向⭐"></a>this指向⭐</h2><blockquote>
<p>引言</p>
</blockquote>
<p>要理解<code>this</code>的设计，我们需要先了解<code>Javascript</code>中内存的数据结构；</p>
<p><code>Javascript</code>内置七种数据类型，可以分为<strong>基本数据类型</strong>和<strong>对象数据类型</strong>，在这里我们主要讲解一下<strong>对象数据类型</strong>在内存中的存储方式；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Heternally&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><code>Javascript</code>引擎在处理上面代码时，会在<strong>堆内存</strong>中，生成一个对象<code>&#123; name: &#39;Heternally&#39;&#125;</code>，然后把这个对象在内存中的地址赋值给变量<code>obj</code>。所以在读取<code>obj.name</code>时，需要先从变量<code>obj</code>拿到地址，然后再从对应地址中拿到对象，再返回它的<code>name</code>属性。</p>
<p>可能看到这里会有同学要问这跟<code>this</code>有啥关系，别急，接下来重点来啦：</p>
<p>对象的属性可能是一个函数，当引擎遇到对象属性是函数的情况，会将函数单独保存在<strong>堆</strong>中，然后再将函数的地址赋值给对象属性；而<code>Javascript</code>是允许在函数体内引用当前环境的其他变量，那么问题来了，函数可以在不同的运行环境执行，所以我们就需要一种机制，能够在函数内获得当前运行环境，由此诞生了<code>this</code>，<strong>它的设计目的就是指向函数运行时所在的环境。</strong></p>
<blockquote>
<p>如何正确判定this指向</p>
</blockquote>
<p>总结了<code>this</code>的绑定规则总共是有下面5种：请记住一点：==谁调用这个函数或方法,this关键字就指向谁。==</p>
<ul>
<li>1、默认绑定（严格/非严格模式）</li>
<li>2、隐式绑定</li>
<li>3、显式绑定</li>
<li>4、new绑定</li>
<li>5、ES6箭头函数绑定</li>
</ul>
<h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>在严格模式下，不能将全局对象<code>window</code>作为默认绑定，此时<code>this</code>会绑定到<code>undefined</code>，但是在严格模式下调用函数则不会影响默认绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;Heternally&quot;</span>;</span><br><span class="line">  foo(); </span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot read property &#x27;name&#x27; of undefined at fooCopy to clipboardErrorCopied</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Heternally&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span></span><br><span class="line">  foo();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Heternally</span></span><br></pre></td></tr></table></figure>

<h4 id="非严格模式"><a href="#非严格模式" class="headerlink" title="非严格模式"></a>非严格模式</h4><p>在非严格模式下，此时<code>this</code>就指向<strong>全局对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Heternally&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// Heternally</span></span><br></pre></td></tr></table></figure>

<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>当函数作为对象的属性存在，通过<strong>对象属性执行函数</strong>时，此时隐式绑定规则会将<code>this</code>绑定到对象上；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Heternally&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zl&#x27;</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// zl</span></span><br></pre></td></tr></table></figure>

<p>注意上面代码中函数执行方式是通过<strong>对象属性</strong>执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Heternally&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zl&#x27;</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// Heternally</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo1 = obj.foo; </span><br><span class="line"></span><br><span class="line">foo1(); <span class="comment">// Heternally</span></span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// zl</span></span><br></pre></td></tr></table></figure>

<p>由上面代码可以发现，通过<strong>赋值操作后执行函数</strong>，会应用默认绑定，此时在非严格模式下<code>this</code>会指向<strong>全局对象</strong>。</p>
<p>同样的，函数传参也是一种隐式赋值，此时在回调函数中会丢失<code>this</code>绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zl&#x27;</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Heternally&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Foo(obj.foo); <span class="comment">// Heternally</span></span><br></pre></td></tr></table></figure>

<h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p><strong>通过 <code>call</code> <code>apply</code> <code>bind</code>绑定</strong></p>
<p>相信同学们都知道这三个方法的作用，这边就主要拿<code>call</code>来举例；</p>
<blockquote>
<p>一句话介绍<code>call</code>：使用一个指定的<code>this</code>和若干个指定的参数调用某个函数或方法。</p>
</blockquote>
<p>在讲解<code>call</code>显示绑定之前，我们先想一下<code>call</code>做了哪些事儿。</p>
<ul>
<li>将函数设为对象的属性</li>
<li>指定函数的this，并进行传参</li>
<li>执行&amp;删除函数</li>
<li>判定如果没有指定要绑定的this，非严格模式下默认指向全局对象</li>
</ul>
<p>可以看到值调用<code>call</code>方法后，会将<code>this</code>绑定到指定对象，所以称为<strong>显示绑定</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Heternally&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Heternally1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;zl&#x27;</span>;</span><br><span class="line"></span><br><span class="line">foo.call(obj); <span class="comment">// Heternally  调用call方法后强行将foo函数的this指向来obj对象上</span></span><br><span class="line"></span><br><span class="line">foo.call(obj).call(obj1); <span class="comment">// Heternally  多次调用call方法，以第一次为准</span></span><br><span class="line"></span><br><span class="line">foo.call(obj1).call(obj); <span class="comment">// Heternally1</span></span><br><span class="line"></span><br><span class="line">foo.call();<span class="comment">// zl 没有传入指定对象，所以this默认指向全局对象</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果call、apply、bind的绑定对象是null或者undefined，那么实际上在调用时这些值都会被忽略，所以使用的是默认绑定规则</p>
</blockquote>
<h3 id="通过new绑定"><a href="#通过new绑定" class="headerlink" title="通过new绑定"></a>通过new绑定</h3><p>我们先看看构造函数在使用<code>new</code>后，执行了什么操作：</p>
<ul>
<li>它创建（构造）了一个全新的对象</li>
<li>它会被执行[[Prototype]]（也就是<code>__proto__</code>）链接</li>
<li>它使this指向新创建的对象</li>
<li>通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上</li>
<li>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用</li>
</ul>
<p>所以在使用<code>new</code>调用构造函数后，会构造一个新对象并将函数调用中的<code>this</code>绑定到新对象上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;zl&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;object&#x27;</span>,</span><br><span class="line">  <span class="attr">foo1</span>: <span class="keyword">new</span> foo(<span class="string">&#x27;Heternally&#x27;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar.foo1.name); <span class="comment">// Heternally</span></span><br></pre></td></tr></table></figure>

<p><strong>当构造函数返回值为对象时，直接返回这个对象；否则返回new创建的对象</strong></p>
<p>构造函数是存在返回值的，可以将函数的返回值分成三种情况：</p>
<ul>
<li>返回一个对象</li>
<li>没有返回值，即默认返回<code>undefined</code></li>
<li>返回基本数据类型</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、返回一个对象</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="string">&quot;Heternally&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line"></span><br><span class="line">bar.name; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">bar.age; <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、没有返回值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="string">&quot;Heternally&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line"></span><br><span class="line">bar.name; <span class="comment">// Heternally</span></span><br><span class="line"></span><br><span class="line">bar.age; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、返回基本数据类型</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="string">&quot;Heternally&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line"></span><br><span class="line">bar.name; <span class="comment">// Heternally</span></span><br><span class="line"></span><br><span class="line">bar.age; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>所以使用<code>new</code>绑定时，需要判断函数返回的值是否为一个对象，如果是对象，那么<code>this</code>会绑定到返回的对象上。</p>
<h3 id="ES6箭头函数绑定"><a href="#ES6箭头函数绑定" class="headerlink" title="ES6箭头函数绑定"></a>ES6箭头函数绑定</h3><p>ES6新增了一种函数类型：箭头函数，箭头函数调用时无法使用上面四种规则了，它和普通函数最不同的一点就是对于箭头函数的<code>this</code>指向，是根据它外层（函数/全局）作用域来决定。</p>
<p>它的 this 是通过作用域链查到外层作用域的 this ，且指向函数定义时的 this 而非执行时。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Heternally&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;text&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;zl&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo1 = foo();</span><br><span class="line">foo1(); <span class="comment">// zl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo2 = foo.call(obj);</span><br><span class="line">foo2(); <span class="comment">// Heternally</span></span><br><span class="line"></span><br><span class="line">foo2.call(obj1); <span class="comment">// Heternally 可以看到，箭头函数的`this`绑定后无法被修改</span></span><br></pre></td></tr></table></figure>

<h3 id="规则优先级"><a href="#规则优先级" class="headerlink" title="规则优先级"></a>规则优先级</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">new</span>绑定</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">this</span>绑定新的对象上</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、显示绑定 call/apply/bind</span><br><span class="line"><span class="keyword">var</span> obj = foo.call(bar);</span><br><span class="line"><span class="built_in">this</span>绑定到指定对象上，若指定对象为<span class="literal">null</span>/<span class="literal">undefined</span>或者没传，则使用默认绑定规则</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、隐式绑定</span><br><span class="line"><span class="keyword">var</span> obj = bar.foo();</span><br><span class="line"><span class="built_in">this</span>绑定到调用方法的对象上</span><br><span class="line">如果存在链式调用， <span class="built_in">this</span> 永远指向最后调用它的那个对象 </span><br><span class="line">隐式绑定丢失：起函数别名，通过别名运行；函数作为参数会造成隐式绑定丢失。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、默认绑定</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">this</span>在严格模式下绑定到<span class="literal">undefined</span></span><br><span class="line">在非严格模式下绑定到全局对象</span><br></pre></td></tr></table></figure>

<h2 id="你能讲一下事件循环机制吗？⭐"><a href="#你能讲一下事件循环机制吗？⭐" class="headerlink" title="你能讲一下事件循环机制吗？⭐"></a>你能讲一下事件循环机制吗？⭐</h2><ol>
<li>代码开始执行，创建一个<strong>全局调用栈</strong>，<code>script</code>作为宏任务执行</li>
<li>执行过程过<strong>同步任务立即执行</strong>，异步任务根据异步任务类型分别注册到<strong>微任务队列</strong>和<strong>宏任务队列</strong></li>
<li>同步任务执行完毕，查看微任务队列<ul>
<li>若存在微任务，将微任务队列全部执行(包括执行微任务过程中产生的新微任务)</li>
<li>若无微任务，查看宏任务队列，执行第一个宏任务，宏任务执行完毕，查看微任务队列，重复上述操作，直至宏任务队列为空</li>
</ul>
</li>
</ol>
<blockquote>
<p>补充</p>
</blockquote>
<p><strong>计算机中的同步</strong>是连续性的动作，上一步未完成前，下一步会发生堵塞，直至上一步完成后，下一步才可以继续执行。</p>
<p><code>JavaScript</code>的确是一门单线程语言，但是浏览器<code>UI</code>是多线程的，异步任务借助浏览器的线程和<code>JavaScript</code>的执行机制实现。 例如，<code>setTimeout</code>就借助浏览器定时器触发线程的计时功能来实现。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TkRGmq"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2021/12/17/TkRGmq.png" alt="TkRGmq.png"></a></p>
<ul>
<li><code>history traversal</code>任务（<code>h5</code>当中的历史操作）</li>
<li><code>process.nextTick</code>（<code>nodejs</code>中的一个异步操作）</li>
<li><code>MutationObserver</code>（<code>h5</code>里面增加的，用来监听<code>DOM</code>节点变化的）</li>
</ul>
<p>宏任务和微任务分别有各自的任务队列<code>Event Queue</code>，即宏任务队列和微任务队列。</p>
<h2 id="new-操作符做了哪些事情⭐"><a href="#new-操作符做了哪些事情⭐" class="headerlink" title="new 操作符做了哪些事情⭐"></a>new 操作符做了哪些事情⭐</h2><p>MDN 中对 new 的描述: 使用 new 来构建函数，会执行如下四部操作：</p>
<ul>
<li>创建一个空的简单 JavaScript 对象（即 {} ）；</li>
<li>为步骤1新创建的对象添加属性 <strong>proto</strong> ，将该属性链接至构造函数的原型对象 ；</li>
<li>将步骤1新创建的对象作为 this 的上下文 ；</li>
<li>如果该函数没有返回对象，则返回 this 。</li>
</ul>
<h2 id="call、apply、bind区别"><a href="#call、apply、bind区别" class="headerlink" title="call、apply、bind区别"></a>call、apply、bind区别</h2><ol>
<li>call() 和apply()的第一个参数相同，就是<strong>指定的对象</strong>。这个对象就是<strong>该函数的执行上下文</strong>。</li>
<li>call()和apply()的区别就在于，两者之间的参数。</li>
<li>call()在第一个参数之后的后续所有参数就是传入该函数的值。</li>
<li>apply() 只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。</li>
<li>bind() 方法和前两者不同在于：bind() 方法会返回执行上下文被改变的函数而不会立即执行，而前两者是直接执行该函数。他的参数和call()相同。</li>
</ol>
<h2 id="let-const-var-区别⭐"><a href="#let-const-var-区别⭐" class="headerlink" title="let const var 区别⭐"></a>let const var 区别⭐</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ol>
<li>存在<strong>变量提升</strong>  即变量可以在声明之前调用，值为<code>undefined</code></li>
<li>可以<strong>重复声明</strong></li>
<li>在<strong>函数</strong>中使用var声明变量的时候，该变量是<strong>局部</strong>的</li>
</ol>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ol>
<li>不存在变量提升，let声明变量前，该变量不能使用（<strong>暂时性死区</strong>）</li>
<li>let命令所在的代码块内有效，在<strong>块级作用域</strong>内有效</li>
<li>let不允许在<strong>相同作用域</strong>中重复声明，注意是相同作用域，不同作用域有重复声明不会报错</li>
</ol>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ol>
<li>不存在变量提升</li>
<li>存在块级作用域</li>
<li>同一作用域不允许重复声明变量</li>
<li>const声明一个只读的常量。一旦声明，常量的值就不能改变。const并不是变量的值不能改动，而是<strong>变量指向的内存地址所保存的数据不得改动</strong></li>
</ol>
<h2 id="变量提升和函数提升⭐"><a href="#变量提升和函数提升⭐" class="headerlink" title="变量提升和函数提升⭐"></a>变量提升和函数提升⭐</h2><p><strong>在js中只有两种作用域</strong></p>
<p>a：全局作用域</p>
<p>b：函数作用域</p>
<p>在ES6之前，js是没有块级作用域。</p>
<p>首先来解释一下什么是没有块级作用域?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>变量a是声明在if的{}里，但在js里面，因为没有块级作用域，所以此时的变量a的作用域是全局作用域。</p>
<p><strong>什么是变量提升?</strong></p>
<p>在我们的js中，代码的执行时分两步走的，1、解析 2、一步一步执行</p>
<p>那么变量提升就是<strong>变量声明会被提升到作用域的最顶上去</strong>，也就是该变量不管是在作用域的哪个地方声明的，都会提升到作用域的最顶上去。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// hello</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// undefined</span></span><br><span class="line">a=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>看几个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">10</span>;<span class="comment">// 全局变量：任何一个地方都可以访问，包括函数内部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">20</span>;<span class="comment">// 局部变量，而且会变量提升，就是把声明提升到作用域的最顶上去</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">// 调用fn</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稍作改动</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">10</span>;<span class="comment">// 全局变量：任何一个地方都可以访问，包括函数内部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 10</span></span><br><span class="line">    a=<span class="number">20</span>;<span class="comment">// 全局变量的重新赋值</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">// 调用fn</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p>再看一个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;<span class="comment">// 由于没有块级作用域，此处相当于在全局作用域重复声明了两次，第二次声明被忽略，仅用于赋值</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>什么是函数提升?</strong></p>
<p>函数声明式，会将函数的声明和定义一起提升到作用域的最顶上去。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn();<span class="comment">// 可正常调用</span></span><br><span class="line"><span class="built_in">console</span>.log(fn);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">// 可正常调用</span></span><br></pre></td></tr></table></figure>

<p>如果是这种写法:<strong>函数表达式声明的函数</strong>，相当于变量提升</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn();<span class="comment">// 可正常调用</span></span><br><span class="line"><span class="built_in">console</span>.log(fn);<span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">// 可正常调用</span></span><br></pre></td></tr></table></figure>

<p>优先级</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn);<span class="comment">// ƒ fn()&#123;&#125;</span></span><br><span class="line"><span class="comment">// var fn = function()&#123;&#125;; // 不可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> fn=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(fn);<span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p><strong>最后的总结:</strong></p>
<p>1:<strong>所有的声明都会提升到作用域的最顶上去</strong>。</p>
<p>2:同一个变量只会<strong>声明一次</strong>，其他的会被忽略掉。</p>
<p>3:<strong>函数声明的优先级高于变量声明的优先级</strong>，并且函数声明和函数定义的部分一起被提升。</p>
<h2 id="箭头函数与普通函数区别⭐"><a href="#箭头函数与普通函数区别⭐" class="headerlink" title="箭头函数与普通函数区别⭐"></a>箭头函数与普通函数区别⭐</h2><ol>
<li>箭头函数没有this，它的this是通过作用域链查到外层作用域的this，且指向函数定义时的this而非执行时。</li>
<li>不可以用作构造函数，不能使用new命令，否则会报错</li>
<li>箭头函数没有arguments对象，如果要用，使用rest参数代替</li>
<li>不可以使用yield命令，因此箭头函数不能用作Generator函数。</li>
<li>不能用call/apply/bind修改this指向，但可以通过修改外层作用域的this来间接修改。</li>
<li>箭头函数没有prototype属性。</li>
</ol>
<h2 id="for-…-of-遍历规则"><a href="#for-…-of-遍历规则" class="headerlink" title="for … of 遍历规则"></a>for … of 遍历规则</h2><p>一个数据结构只要部署了 <code>Symbol.iterator</code> 属性，就被视为具有 <code>iterator</code> 接口，就可以用 <code>for...of</code> 循环遍历它的成员。也就是说，<code>for...of</code> 循环内部调用的是数据结构的 <code>Symbol.iterator</code> 方法。</p>
<p><code>for...of</code> 循环可以使用的范围包括数组、<code>Set</code> 和 <code>Map</code> 结构、某些类似数组的对象（比如<code>arguments</code>对象、<code>DOM NodeList</code> 对象）、后文的 <code>Generator</code> 对象，以及字符串。</p>
<p><strong>for … of 可以遍历对象吗？</strong></p>
<p>所以通过上面的遍历规则可知，只要对象中部署 <code>Symbol.iterator</code> 属性，就可以遍历对象；否则，不可以。</p>
<h2 id="map与set⭐"><a href="#map与set⭐" class="headerlink" title="map与set⭐"></a>map与set⭐</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>ES6 提供了 Map 数据结构。它类似于对象，也是<strong>键值对</strong>的集合。</p>
<p>但是“键”的范围<strong>不限于字符串，各种类型的值（包括对象）都可以当作键。</strong></p>
<p>Map 也实现了<strong>iterator</strong> 接口，所以可以使用<strong>扩展运算符</strong>和<code>for…of…</code>进行遍历；</p>
<p>Map 的属性和方法：</p>
<ul>
<li>size 返回 Map 的元素个数；</li>
<li>set 增加一个新元素，返回当前 Map；</li>
<li>get <strong>返回键名对象的键值</strong>；</li>
<li>has 检测 Map 中是否包含某个元素，返回 boolean 值；</li>
<li>clear 清空集合，返回 undefined；</li>
</ul>
<h3 id="map与object区别"><a href="#map与object区别" class="headerlink" title="map与object区别"></a>map与object区别</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ol>
<li>map 只能通过 new 关键字和构造函数创建</li>
<li>object 可以使用字面量、构造函数、Object.crate的形式创建。</li>
</ol>
<h4 id="键值"><a href="#键值" class="headerlink" title="键值"></a>键值</h4><ol>
<li>object键值只能使用数组、字符串、符号作为键</li>
<li>map 的键值可以是任意类型</li>
</ol>
<h4 id="顺序与迭代"><a href="#顺序与迭代" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h4><ol>
<li>object的键值 key 的遍历顺序<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>
</ul>
</li>
<li>map 会维护键值对的插入顺序，因此遍历顺序就是插入顺序</li>
</ol>
<h3 id="map与weakMap的区别"><a href="#map与weakMap的区别" class="headerlink" title="map与weakMap的区别"></a>map与weakMap的区别</h3><p>WeakMap 结构与 Map 结构类似，也是用于<strong>生成键值对的集合</strong>。</p>
<ul>
<li>只接受<strong>对象</strong>作为键名（<strong>null 除外</strong>），不接受其他类型的值作为键名</li>
<li>键名是<strong>弱引用</strong>，键值可以是任意的，<strong>键名所指向的对象可以被垃圾回收，此时键名是无效的</strong></li>
<li><strong>不能遍历</strong>，方法有 get、set、has、delete</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>ES6 提供了新的数据结构 Set（集合）。它类似于数组，但成员的值都是<strong>唯一</strong>的，集合实现了 iterator接口，所以可以使用<strong>扩展运算符</strong>和<code>for…of…</code>进行遍历，集合的属性和方法：</p>
<ul>
<li>size 返回集合的元素个数；</li>
<li>add 增加一个新元素，返回当前集合；</li>
<li>delete 删除元素，返回 boolean 值；</li>
<li>has 检测集合中是否包含某个元素，返回 boolean 值；</li>
<li>clear 清空集合，返回 undefined；</li>
</ul>
<h3 id="set-与-weakSet-区别"><a href="#set-与-weakSet-区别" class="headerlink" title="set 与 weakSet 区别"></a>set 与 weakSet 区别</h3><p><code>WeakSet</code> 结构与 Set 类似，也是不重复的值的集合。</p>
<ol>
<li><code>WeakSet</code> 成员都是数组和类似数组的对象，若调用 <code>add()</code> 方法时传入了非数组和类似数组的对象的参数，就会抛出错误。</li>
<li><code>WeakSet</code> 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 <code>DOM</code> 节点，不容易造成内存泄漏。</li>
<li><code>WeakSet</code> 不可迭代，因此不能被用在 <code>for-of</code> 等循环中。</li>
<li><code>WeakSet</code> 没有 <code>size</code> 属性。</li>
</ol>
<h2 id="函数的柯里化"><a href="#函数的柯里化" class="headerlink" title="函数的柯里化"></a>函数的柯里化</h2><p>通过函数调用继续返回函数的方式,实现对此接受参数最后统一处理的函数编码形式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> &gt;</span><br><span class="line">	<span class="comment">/* function sum(a,b,c)&#123;</span></span><br><span class="line"><span class="comment">		return a+b+c</span></span><br><span class="line"><span class="comment">	&#125; */</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span><span class="function">(<span class="params">b</span>)=&gt;</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="function">(<span class="params">c</span>)=&gt;</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> a+b+c</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> result = sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line">	<span class="built_in">console</span>.log(result);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="计算机网络和浏览器"><a href="#计算机网络和浏览器" class="headerlink" title="计算机网络和浏览器"></a>计算机网络和浏览器</h1><h2 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h2><p>UDP 在传送数据之前<strong>不需要先建立连接</strong>，远地主机在收到 UDP 报文后，<strong>不需要给出任何确认</strong>。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（<strong>一般用于即时通信</strong>），比如： QQ语音、 QQ视频 、直播等等</p>
<p>TCP 提供<strong>面向连接</strong>的服务。在<strong>传送数据之前必须先建立连接，数据传送结束后要释放连接</strong>。 TCP 不提供广播或多播服务。由于 TCP 要提供<strong>可靠的，面向连接</strong>的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有<strong>三次握手</strong>来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于<strong>文件传输、发送和接收邮件、远程登录</strong>等场景。</p>
<h2 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h2><ul>
<li>URI(Uniform Resource Identifier) 是<strong>统一资源标志符</strong>，可以<strong>唯一标识一个资源</strong>。</li>
<li>URL(Uniform Resource Locator) 是<strong>统一资源定位符</strong>，可以提供该资源的<strong>路径</strong>。它是一种具体的 URI，即 <strong>URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源</strong>。</li>
</ul>
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。<strong>URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</strong></p>
<h2 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h2><ol>
<li><p>端口 ：HTTP 的 URL 由“<code>http://</code>”起始且默认使用端口<code>80</code>，而HTTPS的URL由“<code>https://</code>”起始且默认使用端口<code>443</code>。</p>
</li>
<li><p>安全性和资源消耗：</p>
<p>HTTP 协议运行在 <strong>TCP</strong> 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 <strong>SSL/TLS</strong> 之上的 HTTP 协议，<strong>SSL/TLS</strong> 运行在 <strong>TCP</strong> 之上。所有传输的内容都经过<strong>加密</strong>，加密采用<strong>对称加密</strong>，但对称加密的密钥用服务器方的证书进行了<strong>非对称加密</strong>。所以说，<strong>HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源</strong>。</p>
<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有 DES、AES 等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有 RSA、DSA 等。</li>
</ul>
</li>
</ol>
<h2 id="HTTP协议⭐"><a href="#HTTP协议⭐" class="headerlink" title="HTTP协议⭐"></a>HTTP协议⭐</h2><blockquote>
<p>一面要讲的内容：</p>
<ul>
<li><p>HTTP协议的主要特点</p>
</li>
<li><p>HTTP报文的组成部分</p>
</li>
<li><p>HTTP方法</p>
</li>
<li><p>get 和 post的区别</p>
</li>
<li><p>HTTP状态码</p>
</li>
<li><p>什么是持久连接</p>
</li>
<li><p>什么是管线化</p>
</li>
</ul>
<p>二面要讲的内容；</p>
<ul>
<li>缓存</li>
<li>CSRF攻击</li>
</ul>
</blockquote>
<h3 id="HTTP协议的主要特点"><a href="#HTTP协议的主要特点" class="headerlink" title="HTTP协议的主要特点"></a>HTTP协议的主要特点</h3><ul>
<li><p>简单快速</p>
</li>
<li><p>灵活</p>
</li>
<li><p><strong>无连接</strong></p>
</li>
<li><p><strong>无状态</strong></p>
</li>
</ul>
<p>通常我们要答出以上四个内容。如果实在记不住，一定要记得后面的两个：<strong>无连接、无状态</strong>。</p>
<p>我们分别来解释一下。</p>
<p><strong>简单快速</strong></p>
<p>每个资源（比如图片、页面）都通过 url 来定位。这都是固定的，在http协议中，处理起来也比较简单，想访问什么资源，直接输入url即可。</p>
<p><strong>灵活</strong></p>
<p>http协议的头部有一个<code>数据类型</code>，通过http协议，就可以完成不同数据类型的传输。</p>
<p><strong>无连接</strong></p>
<p>连接一次，就会断开，不会继续保持连接。</p>
<p><strong>无状态</strong></p>
<p>客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时，<strong>服务器端并没有记住之前的状态</strong>，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。</p>
<p>有的时候，我们访问网站时，网站能记住我们的账号，这个是通过其他的手段（比如 session）做到的，并不是http协议能做到的。</p>
<h3 id="HTTP报文的组成部分"><a href="#HTTP报文的组成部分" class="headerlink" title="HTTP报文的组成部分"></a>HTTP报文的组成部分</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5KMFne"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/13/5KMFne.png" alt="5KMFne.png"></a></p>
<p>在回答此问题时，我们要按照顺序回答：</p>
<ul>
<li><p>先回答的是，http报文包括：<strong>请求报文</strong>和<strong>响应报文</strong>。</p>
</li>
<li><p>再回答的是，每个报文包含什么部分。</p>
</li>
<li><p>最后回答，每个部分的内容是什么</p>
</li>
</ul>
<h4 id="请求报文包括："><a href="#请求报文包括：" class="headerlink" title="请求报文包括："></a>请求报文包括：</h4><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5KMk0H"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/13/5KMk0H.jpg" alt="5KMk0H.jpg"></a></p>
<ul>
<li><p>请求行：包括请求方法、请求的url、http协议及版本。</p>
</li>
<li><p>请求头：一大堆的键值对。</p>
</li>
<li><p><strong>空行</strong>指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。</p>
</li>
<li><p>请求体：数据部分。</p>
</li>
</ul>
<h4 id="响应报文包括："><a href="#响应报文包括：" class="headerlink" title="响应报文包括："></a>响应报文包括：</h4><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5KMPXD"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/13/5KMPXD.jpg" alt="5KMPXD.jpg"></a></p>
<ul>
<li>状态行：http协议及版本、状态码及状态描述。</li>
<li>响应头</li>
<li>空行</li>
<li>响应体</li>
</ul>
<h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><p>包括：</p>
<ul>
<li>GET：发送一个请求来取得服务器上的某一资源</li>
<li>POST：向<code>URL</code>指定的资源提交数据或附加新的数据</li>
<li>PUT：跟<code>POST</code>方法很像，也是想服务器提交数据。但是，它们之间有不同。<code>PUT</code>指定了资源在服务器上的位置，而<code>POST</code>没有</li>
<li>DELETE：删除服务器上的某资源</li>
<li>HEAD：只请求页面的首部</li>
<li>OPTIONS：它用于获取当前<code>URL</code>所支持的方法。如果请求成功，会有一个<code>Allow</code>的头包含类似<code>“GET,POST”</code>这样的信息</li>
<li>TRACE：<code>TRACE</code>方法被用于激发一个远程的，应用层的请求消息回路</li>
<li>CONNECT：把请求连接转换到透明的<code>TCP/IP</code>通道</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5KQEKU"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/13/5KQEKU.png" alt="5KQEKU.png"></a></p>
<p>区别有很多，如果记不住，面试时，至少要任意答出其中的三四条。</p>
<p>有一点要强调，<strong>get是相对不隐私的，而post是相对隐私的</strong>。</p>
<p>我们大概要记住以下几点：</p>
<ul>
<li>浏览器在回退时，get<strong>不会重新请求</strong>，但是post会重新请求。【重要】</li>
<li>get请求会被浏览器<strong>主动缓存</strong>，而post不会。【重要】</li>
<li>get请求的参数，会报<strong>保留</strong>在浏览器的<strong>历史记录</strong>里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。</li>
<li>get请求在url中传递的参数有大小限制，基本是2kb，不同的浏览器略有不同。而post没有注意。</li>
<li>get的参数是直接暴露在<strong>url</strong>上的，相对不安全。而post是放在<strong>请求体</strong>中的。</li>
</ul>
<h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><ul>
<li>1XX：信息状态码<ul>
<li><code>100 Continue</code> 继续，一般在发送<code>post</code>请求时，已发送了<code>http header</code>之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>
</ul>
</li>
<li>2XX：成功状态码<ul>
<li><code>200 OK</code> 正常返回信息</li>
<li><code>201 Created</code> 请求成功并且服务器创建了新的资源</li>
<li><code>202 Accepted</code> 服务器已接受请求，但尚未处理</li>
</ul>
</li>
<li>3XX：重定向<ul>
<li><code>301 Moved Permanently</code> 请求的网页已永久移动到新位置。</li>
<li><code>302 Found</code> 临时性重定向。</li>
<li><code>303 See Other</code> 临时性重定向，且总是使用 <code>GET</code> 请求新的 <code>URI</code>。</li>
<li><code>304 Not Modified</code> 自从上次请求后，请求的网页未修改过。</li>
</ul>
</li>
<li>4XX：客户端错误<ul>
<li><code>400 Bad Request</code> 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li>
<li><code>401 Unauthorized</code> 请求未授权。</li>
<li><code>403 Forbidden</code> 禁止访问。</li>
<li><code>404 Not Found</code> 找不到如何与 <code>URI</code> 相匹配的资源。</li>
</ul>
</li>
<li>5XX：服务器错误<ul>
<li><code>500 Internal Server Error</code> 最常见的服务器端错误。</li>
<li><code>503 Service Unavailable</code> 服务器端暂时无法处理请求（可能是过载或维护）。</li>
</ul>
</li>
</ul>
<p>http状态码分类：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5KlEWt"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/13/5KlEWt.png" alt="5KlEWt.png"></a></p>
<p>常见的http状态码：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5KleQf"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/13/5KleQf.png" alt="5KleQf.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5KlZSP"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/13/5KlZSP.png" alt="5KlZSP.png"></a></p>
<h3 id="持久链接-http长连接"><a href="#持久链接-http长连接" class="headerlink" title="持久链接/http长连接"></a>持久链接/http长连接</h3><ul>
<li><strong>轮询</strong>：<strong>http1.0</strong>中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。</li>
</ul>
<ul>
<li><strong>长连接</strong>：<strong>HTTP1.1</strong>中，通过使用<code>Connection:keep-alive</code>进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。</li>
</ul>
<p>注意，<strong>HTTP 1.1</strong>默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对<strong>每个请求仍然要单独发 header</strong>，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p>
<h4 id="长连接中的管线化"><a href="#长连接中的管线化" class="headerlink" title="长连接中的管线化"></a>长连接中的管线化</h4><p>长连接时，<strong>默认</strong>的请求这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求1 --&gt; 响应1 --&gt;请求2 --&gt; 响应2 --&gt; 请求3 --&gt; 响应3</span><br></pre></td></tr></table></figure>

<p>长连接中的管线化，请求是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求1 --&gt; 请求2 --&gt; 请求3 --&gt; 响应1 --&gt; 响应2 --&gt; 响应3</span><br></pre></td></tr></table></figure>


<p>管线化就是，我把现在的请求打包，一次性发过去，你也给我一次响应回来。</p>
<h2 id="跨域通信⭐"><a href="#跨域通信⭐" class="headerlink" title="跨域通信⭐"></a>跨域通信⭐</h2><blockquote>
<p>前端通信类的问题，主要包括以下内容：</p>
<ul>
<li><p>什么是<strong>同源策略</strong>及限制</p>
<p>同源策略是一个概念，就一句话。有什么限制，就三句话。能说出来即可。</p>
</li>
<li><p><strong>前后端如何通信</strong></p>
<p>如果你不准备，估计也就只能说出ajax。这个可以考察出知识面。</p>
</li>
<li><p>如何创建<strong>Ajax</strong></p>
<p>Ajax在前后端通信中经常用到。做业务时，可以借助第三方的库，比如vue框架里的库、jQuery也有封装好的方法。但如果让你用原生的js去实现，该怎么做？</p>
<p>这就是考察你的动手能力，以及框架原理的掌握。如果能写出来，可以体现出你的基本功。是加分项。</p>
</li>
<li><p><strong>跨域通信</strong>的几种方式</p>
<p>这部分非常重要。无非就是问你：什么是跨域、跨域有什么限制、<strong>跨域有几种方式</strong>。</p>
</li>
</ul>
</blockquote>
<h3 id="同源策略的概念和具体限制"><a href="#同源策略的概念和具体限制" class="headerlink" title="同源策略的概念和具体限制"></a>同源策略的概念和具体限制</h3><p><strong>同源策略</strong>：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。</p>
<p>具体解释：</p>
<p>（1）<code>源</code>包括三个部分：协议、域名、端口（http协议的默认端口是80）。如果有任何一个部分不同，则<code>源</code>不同，那就是跨域了。</p>
<p>（2）<code>限制</code>：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：</p>
<ul>
<li><strong>Cookie</strong>、<strong>LocalStorage</strong>和<strong>IndexDB</strong>无法获取。</li>
<li>无法获取和操作<strong>DOM</strong>。</li>
<li>不能发送<strong>Ajax</strong>请求。我们要注意，Ajax只适合<strong>同源</strong>的通信。</li>
</ul>
<h3 id="前后端如何通信"><a href="#前后端如何通信" class="headerlink" title="前后端如何通信"></a>前后端如何通信</h3><p>主要有以下几种方式：</p>
<ul>
<li><p><strong>Ajax</strong>：不支持跨域。</p>
</li>
<li><p><strong>WebSocket</strong>：不受同源策略的限制，支持跨域。</p>
</li>
<li><p><strong>CORS</strong>：不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：<strong>同时支持同源和跨域的Ajax</strong>。</p>
</li>
</ul>
<h3 id="如何创建Ajax"><a href="#如何创建Ajax" class="headerlink" title="如何创建Ajax"></a>如何创建Ajax</h3><p>在回答 Ajax 的问题时，要回答以下几个方面：</p>
<ul>
<li><p>1、XMLHttpRequest 的工作原理</p>
</li>
<li><p>2、兼容性处理</p>
<p>XMLHttpRequest只有在高级浏览器中才支持。在回答问题时，这个兼容性问题不要忽略。</p>
</li>
<li><p>3、事件的触发条件</p>
</li>
<li><p>4、事件的触发顺序</p>
<p>XMLHttpRequest有很多触发事件，每个事件是怎么触发的。</p>
</li>
</ul>
<h4 id="发送-Ajax-请求的五个步骤"><a href="#发送-Ajax-请求的五个步骤" class="headerlink" title="发送 Ajax 请求的五个步骤"></a>发送 Ajax 请求的五个步骤</h4><blockquote>
<p>XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。</p>
</blockquote>
<ul>
<li><p>创建<code>XMLHttpRequest</code> 对象。</p>
</li>
<li><p>使用<code>open</code>方法设置请求的参数。<code>open(method, url, 是否异步)</code>。</p>
</li>
<li><p>发送请求。</p>
</li>
<li><p>注册事件。 注册<code>onreadystatechange</code>事件，状态改变时就会调用。</p>
<p>如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。</p>
</li>
<li><p>获取返回的数据，更新UI。</p>
</li>
</ul>
<h4 id="发送-get-请求和-post-请求"><a href="#发送-get-请求和-post-请求" class="headerlink" title="发送 get 请求和 post 请求"></a>发送 get 请求和 post 请求</h4><p>get请求举例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Ajax 发送 get 请求<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;发送get_ajax请求&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;btnAjax&#x27;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 绑定点击事件</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#btnAjax&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 发送ajax 请求 需要 五步</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// （1）创建异步对象</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// （2）设置请求的参数。包括：请求的方法、请求的url。</span></span></span><br><span class="line"><span class="javascript">        xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;02-ajax.php&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// （3）发送请求</span></span></span><br><span class="line"><span class="javascript">        xhr.send();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//（4）注册事件。 onreadystatechange事件，状态改变时就会调用。</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。</span></span></span><br><span class="line"><span class="javascript">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 为了保证 数据 完整返回，我们一般会判断 两个值</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 5.在注册的事件中 获取 返回的 内容 并修改页面的显示</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&#x27;数据返回成功&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 数据是保存在 异步对象的 属性中</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(xhr.responseText);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 修改页面的显示</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.querySelector(<span class="string">&#x27;h1&#x27;</span>).innerHTML = xhr.responseText;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>post 请求举例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Ajax 发送 get 请求<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;发送put_ajax请求&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;btnAjax&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 异步对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置属性</span></span></span><br><span class="line"><span class="javascript">    xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;02.post.php&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 如果想要使用post提交数据,必须添加此行</span></span></span><br><span class="line"><span class="javascript">    xhr.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将数据通过send方法传递</span></span></span><br><span class="line"><span class="javascript">    xhr.send(<span class="string">&#x27;name=fox&amp;age=18&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 发送并接受返回值</span></span></span><br><span class="line"><span class="javascript">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 这步为判断服务器是否正确响应</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="javascript">            alert(xhr.responseText);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="onreadystatechange-事件"><a href="#onreadystatechange-事件" class="headerlink" title="onreadystatechange 事件"></a>onreadystatechange 事件</h4><p>注册 <code>onreadystatechange</code> 事件后，每当 <code>readyState</code> 属性改变时，就会调用 <code>onreadystatechange</code> 函数。</p>
<p><code>readyState</code>：（存有 <code>XMLHttpRequest</code> 的状态。从 0 到 4 发生变化）</p>
<ul>
<li><p>0: 请求未初始化</p>
</li>
<li><p>1: 服务器连接已建立</p>
</li>
<li><p>2: 请求已接收</p>
</li>
<li><p>3: 请求处理中</p>
</li>
<li><p>4: 请求已完成，且响应已就绪</p>
</li>
</ul>
<h4 id="事件的触发条件"><a href="#事件的触发条件" class="headerlink" title="事件的触发条件"></a>事件的触发条件</h4><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5KtjKI"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/13/5KtjKI.png" alt="5KtjKI.png"></a></p>
<h4 id="事件的触发顺序"><a href="#事件的触发顺序" class="headerlink" title="事件的触发顺序"></a>事件的触发顺序</h4><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5KtOxA"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/13/5KtOxA.png" alt="5KtOxA.png"></a></p>
<h3 id="跨域通信的几种方式"><a href="#跨域通信的几种方式" class="headerlink" title="跨域通信的几种方式"></a>跨域通信的几种方式</h3><p>方式如下：</p>
<ul>
<li><p>1、JSONP</p>
</li>
<li><p>2、WebSocket</p>
</li>
<li><p>3、CORS</p>
</li>
<li><p>4、Hash</p>
</li>
<li><p>5、postMessage</p>
</li>
</ul>
<p>上面这五种方式，在面试时，都要说出来。</p>
<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>面试会问：JSONP的原理是什么？怎么实现的？</p>
<p>在CORS和postMessage以前，我们一直都是通过JSONP来做跨域通信的。</p>
<p><strong>JSONP的原理</strong>：通过<code>&lt;script&gt;</code>标签的异步加载来实现的。比如说，实际开发中，我们发现，head标签里，可以通过<code>&lt;script&gt;</code>标签的src，里面放url，加载很多在线的插件。这就是用到了JSONP。</p>
<p><strong>JSONP的实现：</strong></p>
<ul>
<li>原理：<strong>动态创建一个script标签</strong>。利用script标签的<code>src</code>属性不受同源策略限制。因为所有的src属性和href属性都不受同源策略限制。可以请求第三方服务器数据内容。</li>
<li>步骤：</li>
</ul>
<ol>
<li>去创建一个script标签</li>
<li>script的src属性设置接口地址</li>
<li>接口参数,必须要带一个自定义函数名 要不然后台无法返回数据。</li>
<li>通过定义函数名去接收后台返回数据</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去创建一个script标签</span></span><br><span class="line"><span class="keyword">var</span>  script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">//script的src属性设置接口地址 并带一个callback回调函数名称</span></span><br><span class="line">script.src = <span class="string">&quot;http://127.0.0.1:8888/index.php?callback=jsonpCallback&quot;</span>;</span><br><span class="line"><span class="comment">//插入到页面</span></span><br><span class="line"><span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"><span class="comment">//通过定义函数名去接收后台返回数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonpCallback</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//注意  jsonp返回的数据是json对象可以直接使用</span></span><br><span class="line">    <span class="comment">//ajax  取得数据是json字符串需要转换成json对象才可以使用。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p><code>WebSocket</code> 使用<code>ws</code>或<code>wss</code>协议，<code>Websocket</code>是一个持久化的协议，相对于HTTP这种非持久的协议来说。WebSocket API最伟大之处在于服务器和客户端可以在给定的时间范围内的任意时刻，相互推送信息。<code>WebSocket</code>并不限于以Ajax(或XHR)方式通信，因为Ajax技术需要客户端发起请求，而WebSocket服务器和客户端可以彼此相互推送信息；XHR受到域的限制，而<code>WebSocket</code>允许跨域通信。</p>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><blockquote>
<p><strong>CORS是什么?</strong></p>
<p>CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持get和post请求。跨域资源共享标准新增了一组HTTP首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源</p>
<p><strong>CORS是怎么工作的?</strong></p>
<p>CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。</p>
</blockquote>
<p>CORS 可以理解成是<strong>既可以同步、也可以异步</strong>的Ajax。</p>
<p>fetch 是一个比较新的API，用来实现CORS通信。用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url（必选），options（可选）</span></span><br><span class="line">fetch(<span class="string">&#x27;/some/url/&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;  <span class="comment">//类似于 ES6中的promise</span></span><br><span class="line"></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 出错了，等价于 then 的第二个参数，但这样更好用更直观</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>另外，如果面试官问：“CORS为什么支持跨域的通信？”</p>
<p>答案：跨域时，浏览器会拦截Ajax请求，并在http头中加Origin。</p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>url的<code>#</code>后面的内容就叫Hash。<strong>Hash的改变，页面不会刷新</strong>。这就是用 Hash 做跨域通信的基本原理。</p>
<p>补充：url的<code>?</code>后面的内容叫Search。Search的改变，会导致页面刷新，因此不能做跨域通信。</p>
<p><strong>使用举例：</strong></p>
<p><strong>场景</strong>：我的页面 A 通过iframe或frame嵌入了跨域的页面 B。</p>
<p>现在，我这个A页面想给B页面发消息，怎么操作呢？</p>
<p>（1）首先，在我的A页面中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">var</span> B = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">B.src = B.src + <span class="string">&#x27;#&#x27;</span> + <span class="string">&#x27;jsonString&#x27;</span>;  <span class="comment">//我们可以把JS 对象，通过 JSON.stringify()方法转成 json字符串，发给 B</span></span><br></pre></td></tr></table></figure>

<p>（2）然后，在B页面中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B中的伪代码</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">//通过onhashchange方法监听，url中的 hash 是否发生变化</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">window</span>.location.hash;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="postMessage-方法"><a href="#postMessage-方法" class="headerlink" title="postMessage()方法"></a>postMessage()方法</h4><blockquote>
<p>H5中新增的postMessage()方法，可以用来做跨域通信。既然是H5中新增的，那就一定要提到。</p>
</blockquote>
<p><strong>场景</strong>：窗口 A (<code>http:A.com</code>)向跨域的窗口 B (<code>http:B.com</code>)发送信息。步骤如下。</p>
<p>（1）在A窗口中操作如下：向B窗口发送数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息</span></span><br><span class="line">Bwindow.postMessage(<span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;http://B.com&#x27;</span>); <span class="comment">//这里强调的是B窗口里的window对象</span></span><br></pre></td></tr></table></figure>

<p>（2）在B窗口中操作如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在窗口B中监听 message 事件</span></span><br><span class="line">Awindow.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;   <span class="comment">//这里强调的是A窗口里的window对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.origin);  <span class="comment">//获取 ：url。这里指：http://A.com</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.source);  <span class="comment">//获取：A window对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.data);    <span class="comment">//获取传过来的数据</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="从URL输入到页面展现到底发生什么？⭐"><a href="#从URL输入到页面展现到底发生什么？⭐" class="headerlink" title="从URL输入到页面展现到底发生什么？⭐"></a>从URL输入到页面展现到底发生什么？⭐</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5JDg5F"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/16/5JDg5F.png" alt="5JDg5F.png"></a></p>
<p>总体来说分为以下几个过程:</p>
<ul>
<li>DNS 解析:将域名解析成 IP 地址</li>
<li>TCP 连接：TCP 三次握手</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>断开连接：TCP 四次挥手</li>
</ul>
<h3 id="URL-到底是啥"><a href="#URL-到底是啥" class="headerlink" title="URL 到底是啥"></a>URL 到底是啥</h3><p>URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。</p>
<p>遵守以下的语法规则：<code>scheme://host.domain:port/path/filename</code></p>
<ul>
<li><strong>scheme</strong> - 定义因特网服务的类型。常见的协议有 <strong>http、https、ftp、file</strong>，其中最常见的类型是 http，而 <strong>https 则是进行加密的网络传输</strong>。</li>
<li><strong>host</strong> - 定义域主机（http 的默认主机是 <strong>www</strong>）</li>
<li><strong>domain</strong> - 定义因特网<strong>域名</strong>，比如 <code>w3school.com.cn</code></li>
<li><strong>port</strong> - 定义主机上的<strong>端口号</strong>（http 的默认端口号是 80）</li>
<li><strong>path</strong> - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</li>
<li><strong>filename</strong> - 定义文档/资源的名称</li>
</ul>
<h3 id="域名解析（DNS）"><a href="#域名解析（DNS）" class="headerlink" title="域名解析（DNS）"></a>域名解析（DNS）</h3><p>在浏览器输入网址后，首先要经过<strong>域名解析</strong>，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 <strong>IP 地址</strong>。</p>
<h4 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h4><p>IP 地址是指互联网协议地址，是 IP Address 的缩写。</p>
<p>IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。</p>
<p><strong>域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址</strong>。</p>
<p>用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。</p>
<p><strong>因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。</strong></p>
<p><strong>但要让计算机去理解名称，相对而言就变得困难了。</strong></p>
<p><strong>因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。</strong></p>
<h4 id="什么是域名解析"><a href="#什么是域名解析" class="headerlink" title="什么是域名解析"></a>什么是域名解析</h4><p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。</p>
<p><strong>DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录</strong>。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如 baidu.com  <span class="number">220</span>.<span class="number">114</span>.<span class="number">23</span>.<span class="number">56</span>（服务器外网<span class="built_in">IP</span>地址）<span class="number">80</span>（服务器端口号）</span><br></pre></td></tr></table></figure>

<h4 id="浏览器如何通过域名去查询-URL-对应的-IP-呢"><a href="#浏览器如何通过域名去查询-URL-对应的-IP-呢" class="headerlink" title="浏览器如何通过域名去查询 URL 对应的 IP 呢"></a>浏览器如何通过域名去查询 URL 对应的 IP 呢</h4><ul>
<li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li>
<li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</li>
<li>路由缓存：路由器也有 DNS 缓存。</li>
<li>ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li>
<li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5JruZV"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/16/5JruZV.png" alt="5JruZV.png"></a></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，</strong></p>
<p><strong>浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。</strong></p>
<p><strong>接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息、关闭 TCP 连接。</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5JrWo8"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/16/5JrWo8.png" alt="5JrWo8.png"></a></p>
<h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><p><strong>在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息</strong>。<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/5JrIzj"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/16/5JrIzj.png" alt="5JrIzj.png"></a></p>
<h4 id="TCP-三次握手的过程如下："><a href="#TCP-三次握手的过程如下：" class="headerlink" title="TCP 三次握手的过程如下："></a>TCP 三次握手的过程如下：</h4><ul>
<li><strong>客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口</strong>（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</li>
<li><strong>服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息</strong>（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</li>
<li><strong>客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”</strong>（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</li>
</ul>
<h4 id="为啥需要三次握手"><a href="#为啥需要三次握手" class="headerlink" title="为啥需要三次握手"></a>为啥需要三次握手</h4><p>谢希仁著《计算机网络》中讲“三次握手”的目的是“<strong>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</strong>”。</p>
<p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<h4 id="第-2-次握手传回了-ACK，为什么还要传回-SYN？"><a href="#第-2-次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="第 2 次握手传回了 ACK，为什么还要传回 SYN？"></a>第 2 次握手传回了 ACK，为什么还要传回 SYN？</h4><p>接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了建立并确认从服务端到客户端的通信。”</p>
<blockquote>
<p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h3 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h3><h3 id="服务器处理请求并返回-HTTP-报文"><a href="#服务器处理请求并返回-HTTP-报文" class="headerlink" title="服务器处理请求并返回 HTTP 报文"></a>服务器处理请求并返回 HTTP 报文</h3><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。<br><strong>web server 担任管控的角色</strong>，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5J6Yss"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/16/5J6Yss.png" alt="5J6Yss.png"></a></p>
<h4 id="MVC-后台处理阶段"><a href="#MVC-后台处理阶段" class="headerlink" title="MVC 后台处理阶段"></a>MVC 后台处理阶段</h4><p>后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。MVC 是一个设计模式，将应用程序分成三个核心部件：模型（model）– 视图（view）–控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/5J68zQ"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/16/5J68zQ.png" alt="5J68zQ.png"></a></p>
<blockquote>
<p>1、视图（view）</p>
</blockquote>
<p><strong>它是提供给用户的操作界面，是程序的外壳。</strong></p>
<blockquote>
<p>2、模型（model）</p>
</blockquote>
<p><strong>模型主要负责数据交互。</strong>在 MVC 的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据。</p>
<blockquote>
<p>3、控制器（controller）</p>
</blockquote>
<p><strong>它负责根据用户从”视图层”输入的指令，选取”模型层”中的数据，然后对其进行相应的操作，产生最终结果。</strong>控制器属于管理者角色，从视图接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示模型处理返回的数据。<br>这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。<br>至于这一阶段发生什么？简而言之，<strong>首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取 redis db 以及 MySQL 的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。</strong></p>
<h4 id="http-响应报文"><a href="#http-响应报文" class="headerlink" title="http 响应报文"></a>http 响应报文</h4><h3 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h3><p>浏览器拿到响应文本 HTML 后，接下来介绍下浏览器渲染机制</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5J63Rg"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/16/5J63Rg.png" alt="5J63Rg.png"></a></p>
<p>浏览器解析渲染页面分为一下五个步骤：</p>
<ul>
<li>根据 HTML 解析出 DOM 树</li>
<li>根据 CSS 解析生成 CSS 规则树（<strong>CSSOM</strong>）</li>
<li>结合 DOM 树和 CSS 规则树，生成渲染树</li>
<li>根据渲染树计算每一个节点的信息</li>
<li>根据计算好的信息绘制页面</li>
</ul>
<h3 id="断开连接-四次挥手"><a href="#断开连接-四次挥手" class="headerlink" title="断开连接 四次挥手"></a>断开连接 四次挥手</h3><p><strong>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手</strong>。<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/5J6JMj"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/16/5J6JMj.png" alt="5J6JMj.png"></a></p>
<ul>
<li><strong>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态</strong>。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li>
<li><strong>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态</strong>。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li>
<li><strong>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态</strong>。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li>
<li><strong>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭</strong>。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li>
</ul>
<p>断开一个 TCP 连接则需要“四次挥手”：</p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li>
</ul>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<h2 id="cookie、sessionStorage、localStorage-详解及应用场景⭐"><a href="#cookie、sessionStorage、localStorage-详解及应用场景⭐" class="headerlink" title="cookie、sessionStorage、localStorage 详解及应用场景⭐"></a>cookie、sessionStorage、localStorage 详解及应用场景⭐</h2><blockquote>
<p>Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在，而Web Storage仅仅是为了在本地“存储”数据而生。</p>
<p>即<code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p>
</blockquote>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><blockquote>
<p><code>Cookie</code>的作用是与服务器进行交互，作为<code>HTTP</code>规范的一部分而存在</p>
</blockquote>
<h4 id="了解cookie"><a href="#了解cookie" class="headerlink" title="了解cookie"></a>了解cookie</h4><ol>
<li>要表示唯一的一个<code>cookie</code>值需要：<code>name</code>、<code>domain</code>、<code>path</code></li>
<li>一个<code>cookie</code>就是一个小型的文本文件</li>
<li>虽然<code>cookie</code>保存在浏览器端，但是一般是在服务器端设置的。</li>
<li>可以在<code>HTTP</code>返回体里，通过设置<code>Set-Cookie</code>来告诉浏览器端所要存储的<code>cookie</code>。</li>
<li>用来保存客户浏览器请求服务器页面的请求信息</li>
</ol>
<h4 id="cookie的应用场景"><a href="#cookie的应用场景" class="headerlink" title="cookie的应用场景"></a>cookie的应用场景</h4><ul>
<li>简单来说，<code>Cookie</code>就是服务器暂存放在你的电脑里的资料（<code>.txt</code>格式的文本文件），好让服务器用来辨认你的计算机。当你在浏览网站的时候，<code>Web</code>服务器会先送一小小资料放在你的计算机上，<code>Cookie</code> 会把你在网站上所打的文字或是一些选择都记录下来。当下次你再访问同一个网站，Web服务器会先看看有没有它上次留下的<code>Cookie</code>资料，有的话，就会依据<code>Cookie</code>里的内容来判断使用者，送出特定的网页内容给你。</li>
<li>网站可以利用<code>cookie</code>跟踪统计用户访问该网站的习惯，比如什么时间访问，访问了哪些页面，在每个网页的停留时间等。利用这些信息，一方面是可以为用户提供个性化的服务，另一方面，也可以作为了解所有用户行为的工具，对于网站经营策略的改进有一定参考价值。</li>
<li>目前<code>Cookie</code>最广泛的是<strong>记录用户登录信息，这样下次访问时可以不需要输入自己的用户名、密码了——当然这种方便也存在用户信息泄密的问题，尤其在多个用户共用一台电脑时很容易出现这样的问题</strong>。</li>
</ul>
<h4 id="cookie缺点"><a href="#cookie缺点" class="headerlink" title="cookie缺点"></a>cookie缺点</h4><ul>
<li><code>Cookie</code><strong>数量和长度</strong>的限制。<code>IE6</code>或更低版本每个<code>domian</code>下最多<code>20</code>个<code>cookie</code>，<code>IE7</code>和之后的版本最多可以有 <code>50</code>个<code>cookie</code>，<code>Firefox</code>最多<code>50</code>个<code>cookie</code>，<code>chrome</code>和<code>Safari</code>没有做硬性限制，每个<code>cookie</code>长度不能超过<code>4KB</code>，否则会被截掉。</li>
<li><code>IE</code>和<code>Opera</code> 会<strong>清理</strong>近期最少使用的<code>cookie</code>，<code>Firefox</code>会随机清理<code>cookie</code>。这就导致不能永久储存信息。</li>
<li><strong>安全性问题</strong>。如果<code>cookie</code>被人拦截了，那人就可以取得所有的<code>session</code>信息。即使加密也与事无补，因为拦截者并不需要知道<code>cookie</code>的意义，他只要原样转发<code>cookie</code>就可以达到目的了。</li>
<li>并且每次你请求一个新的页面的时候，<code>cookie</code>只要满足作用域和作用路径，<code>Cookie</code>都会被发送过去，这样无形中<strong>浪费了带宽</strong>。</li>
</ul>
<h3 id="本地储存"><a href="#本地储存" class="headerlink" title="本地储存"></a>本地储存</h3><blockquote>
<p><code>Web Storage</code>是为了在本地“存储”数据而生。<code>HTML5</code>中的<code>Web Storage</code>包括了两种存储方式：<code>sessionStorage</code>和<code>localStorage</code></p>
</blockquote>
<h4 id="localStorage-amp-amp-sessionStorage"><a href="#localStorage-amp-amp-sessionStorage" class="headerlink" title="localStorage &amp;&amp; sessionStorage"></a>localStorage &amp;&amp; sessionStorage</h4><blockquote>
<p>只要有效期和作用域，浏览器每次访问的时候都会将<code>Storage</code>载入到内存里</p>
</blockquote>
<ul>
<li><code>localStorage</code>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</li>
<li><code>sessionStorage</code>用于本地存储一个会话（<code>session</code>）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此<code>sessionStorage</code>不是一种持久化的本地存储，仅仅是会话级别的存储。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，<code>sessionStorage</code>即被销毁。</li>
<li><code>localStorage</code>也受同源策略的限制。</li>
<li><code>localStorage</code>和<code>sessionStorage</code>都具有相同的操作方法，如<code>setItem</code>,<code>getItem</code>,<code>removeItem</code>,<code>clear</code>等方法，不像<code>cookie</code>需要前端开发者自己封装<code>setCookie</code>，<code>getCookie</code>。</li>
</ul>
<h4 id="localStorage应用场景"><a href="#localStorage应用场景" class="headerlink" title="localStorage应用场景"></a>localStorage应用场景</h4><p>常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。</p>
<h4 id="sessionStorage应用场景"><a href="#sessionStorage应用场景" class="headerlink" title="sessionStorage应用场景"></a>sessionStorage应用场景</h4><p>敏感账号一次性登录。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>区别</p>
</blockquote>
<ul>
<li>存储大小：<ul>
<li><code>cookie</code>数据大小不能超过4k</li>
<li><code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到5M或更大</li>
</ul>
</li>
<li>有期时间：<ul>
<li><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。</li>
<li><code>sessionStorage</code> 数据在当前浏览器窗口关闭后自动删除。</li>
<li><code>cookie</code> 设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">cookie</th>
<th align="center">localStorage</th>
<th align="center">sessionStorage</th>
<th align="center">indexDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据生命周期</td>
<td align="center">一般由服务器生成，可以设置过期时间</td>
<td align="center">除非被清理，否则一直存在</td>
<td align="center">页面关闭就清理</td>
<td align="center">除非被清理，否则一直存在</td>
</tr>
<tr>
<td align="center">数据存储大小</td>
<td align="center">4K</td>
<td align="center">5M</td>
<td align="center">5M</td>
<td align="center">无限</td>
</tr>
<tr>
<td align="center">与服务端通信</td>
<td align="center">每次都会携带在 header 中，对于请求性能影响</td>
<td align="center">不参与</td>
<td align="center">不参与</td>
<td align="center">不参与</td>
</tr>
</tbody></table>
<p><strong>总结一下</strong>：<code>cookie</code>数量和长度都有限制，<code>Web Storage</code>解决了这样的限制，且<code>localStorage</code>做到了永久储存。但是<code>Cookie</code>也是不可以或缺的：<code>Cookie</code>的作用是与服务器进行交互，作为<code>HTTP</code>规范的一部分而存在 ，而<code>Web Storage</code>仅仅是为了在本地“存储”数据而生。</p>
<h2 id="线程与进程⭐"><a href="#线程与进程⭐" class="headerlink" title="线程与进程⭐"></a>线程与进程⭐</h2><h3 id="为什么js是单线程的"><a href="#为什么js是单线程的" class="headerlink" title="为什么js是单线程的"></a>为什么js是单线程的</h3><ul>
<li>因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。</li>
<li>如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。</li>
</ul>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul>
<li><p>进程是系统进行资源分配和调度的一个独立单位 </p>
</li>
<li><p>线程是CPU调度的基本单位 </p>
</li>
<li><p>区别：</p>
<p>a. 进程有<strong>独立的地址空间</strong>，一个进程崩溃后不会对其他进程产生影响。<br>b. 线程有自己的<strong>堆栈和局部变量</strong>，但没有独立的地址空间。</p>
<p>c. 一个程序至少有一个进程，一个进程至少有一个线程</p>
<p>d. 两者都可以并发执行 </p>
</li>
</ul>
<p><strong>进程的状态</strong> </p>
<ul>
<li>进程状态有就绪，运行，阻塞这三种 </li>
<li>就绪即一个进程获得了所需资源，一旦得到处理机便可运行 </li>
<li>阻塞即一个进程正在等待某一事件发生而暂时停止运行 </li>
<li>运行转为就绪，比如时间片到；运行转为阻塞，比如等待IO请求的返回；阻塞转为就绪，比如IO结束 </li>
</ul>
<p><strong>进程调度算法的特点</strong> </p>
<ul>
<li>短作业优先，运行时间最短的优先 </li>
<li>先来先服务，即先来先运行 </li>
<li>时间片轮转，即每次一个进程运行一个时间片，不断切换 </li>
<li>优先级，即按优先级运行 </li>
<li>高响应比，即优先级随着等待时间的增长而提高，抢占式 </li>
</ul>
<p><strong>死锁</strong>：死锁是指一组争用系统资源或相互通信的进程被阻塞的现象。 </p>
<p><strong>产生死锁的四个必要条件：</strong></p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用。 </li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 </li>
<li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 </li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<h2 id="浏览器的重绘与回流（Repaint、Reflow）"><a href="#浏览器的重绘与回流（Repaint、Reflow）" class="headerlink" title="浏览器的重绘与回流（Repaint、Reflow）"></a>浏览器的重绘与回流（Repaint、Reflow）</h2><h3 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h3><ul>
<li>浏览器采用流式布局模型（<code>Flow Based Layout</code>）</li>
<li>浏览器会把<code>HTML</code>解析成<code>DOM</code>，把<code>CSS</code>解析成<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并就产生了渲染树（<code>Render Tree</code>）。</li>
<li>有了<code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</li>
<li>由于浏览器使用流式布局，对<code>Render Tree</code>的计算通常只需要遍历一次就可以完成，<strong>但<code>table</code>及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用<code>table</code>布局的原因之一</strong>。</li>
</ul>
<h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如<code>outline</code>, <code>visibility</code>, <code>color</code>、<code>background-color</code>等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。</p>
<h3 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h3><p>回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;error&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>我的组件<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>错误：<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>错误的描述…<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>错误纠正<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一步<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二步<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的HTML片段中，对该段落(<code>&lt;p&gt;</code>标签)回流将会引发强烈的回流，因为它是一个子节点。这也导致了祖先的回流（<code>div.error</code>和<code>body</code> – 视浏览器而定）。此外，<code>&lt;h5&gt;</code>和<code>&lt;ol&gt;</code>也会有简单的回流，因为其在DOM中在回流元素之后。<strong>大部分的回流将导致页面的重新渲染。</strong></p>
<p><strong>回流必定会发生重绘，重绘不一定会引发回流。</strong></p>
<h3 id="浏览器优化"><a href="#浏览器优化" class="headerlink" title="浏览器优化"></a>浏览器优化</h3><p>现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你<strong>获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值</strong>。</p>
<p>主要包括以下属性或方法：</p>
<ul>
<li><code>offsetTop</code>、<code>offsetLeft</code>、<code>offsetWidth</code>、<code>offsetHeight</code></li>
<li><code>scrollTop</code>、<code>scrollLeft</code>、<code>scrollWidth</code>、<code>scrollHeight</code></li>
<li><code>clientTop</code>、<code>clientLeft</code>、<code>clientWidth</code>、<code>clientHeight</code></li>
<li><code>width</code>、<code>height</code></li>
<li><code>getComputedStyle()</code></li>
<li><code>getBoundingClientRect()</code></li>
</ul>
<p>所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。</p>
<h3 id="减少重绘与回流"><a href="#减少重绘与回流" class="headerlink" title="减少重绘与回流"></a>减少重绘与回流</h3><ol>
<li><p>CSS</p>
<ul>
<li><p><strong>使用 <code>transform</code> 替代 <code>top</code></strong></p>
</li>
<li><p><strong>使用 <code>visibility</code> 替换 <code>display: none</code></strong> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</p>
</li>
<li><p><strong>避免使用<code>table</code>布局</strong>，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局。</p>
</li>
<li><p>**尽可能在<code>DOM</code>树的最末端改变<code>class</code>**，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。</p>
</li>
<li><p><strong>避免设置多层内联样式</strong>，CSS 选择符<strong>从右往左</strong>匹配查找，避免节点层级过多。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">div</span> &gt; <span class="selector-tag">a</span> &gt; <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 <code>span</code> 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 <code>span</code> 标签，然后找到 <code>span</code> 标签上的 <code>a</code> 标签，最后再去找到 <code>div</code> 标签，然后给符合这种条件的 <code>span</code> 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写<strong>过于具体</strong>的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证<strong>层级扁平</strong>。</p>
</li>
<li><p><strong>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上</strong>，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 <code>requestAnimationFrame</code>，详见<a target="_blank" rel="noopener" href="https://github.com/LuNaHaiJiao/blog/issues/30">探讨 requestAnimationFrame</a>。</p>
</li>
<li><p><strong>避免使用<code>CSS</code>表达式</strong>，可能会引发回流。</p>
</li>
<li><p><strong>将频繁重绘或者回流的节点设置为图层</strong>，图层能够阻止该节点的渲染行为影响别的节点，例如<code>will-change</code>、<code>video</code>、<code>iframe</code>等标签，浏览器会自动将该节点变为图层。</p>
</li>
<li><p><strong>CSS3 硬件加速（GPU加速）</strong>，使用css3硬件加速，可以让<code>transform</code>、<code>opacity</code>、<code>filters</code>这些动画不会引起回流重绘 。但是对于动画的其它属性，比如<code>background-color</code>这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</p>
</li>
</ul>
</li>
<li><p>JavaScript</p>
<ul>
<li><strong>避免频繁操作样式</strong>，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li>
<li>**避免频繁操作<code>DOM</code>**，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM操作</code>，最后再把它添加到文档中。</li>
<li><strong>避免频繁读取会引发回流/重绘的属性</strong>，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li><strong>对具有复杂动画的元素使用绝对定位</strong>，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
</li>
</ol>
<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><ol>
<li>TypeScript是JavaScript的超集。</li>
<li>它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。</li>
<li>TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。</li>
<li>TS完全兼容JS，换言之，任何的JS代码都可以直接当成TS使用。</li>
<li>相较于JS而言，TS拥有了<strong>静态类型</strong>，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。</li>
<li>TypeScript支持面向对象的编程特性，比如类、接口、继承、泛型等等。</li>
</ol>
<h1 id="基于Android的电子词典设计"><a href="#基于Android的电子词典设计" class="headerlink" title="基于Android的电子词典设计"></a>基于Android的电子词典设计</h1><h2 id="借助Python的Requests库和lxml库进行单词数据的爬取。"><a href="#借助Python的Requests库和lxml库进行单词数据的爬取。" class="headerlink" title="借助Python的Requests库和lxml库进行单词数据的爬取。"></a>借助Python的Requests库和lxml库进行单词数据的爬取。</h2><h3 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h3><p>Requests是一个功能强大、简单易用的HTTP请求库，主要用来发起请求和获取响应内容，对应的方法为get方法。首先，使用HTTP库向词典网站发起请求，即发送一个Request，其中包含请求方式、请求URL、请求头和请求体，其中构建HTTP的请求头的目的在于伪装成浏览器与词典网站进行通信，如果服务器能正常响应，则会得到一个Response，包含响应状态、响应头和响应体，最后通过Text方法即可得到网页的源代码。</p>
<h3 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h3><p>XPath，全称 XML Path Language，即XML路径语言，它是一门在XML文档中查找信息的语言。最初是用来搜寻XML文档的，但同样适用于HTML文档的搜索。所以在做爬虫时完全可以使用XPath做相应的信息抽取。Python为此提供了lxml第三方库。</p>
<p>XPath以XML树结构为基础，能够在数据的结构树中查找各类节点，比如属性节点、文本节点和元素节点等等。在检查元素中右键即可复制它的XPath路径，分析规律并且结合XPath的表达式语法，就可获取相关文本内容。</p>
<h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>使用Multiprocessing的Pool方法，设置一定数量的进程放在进程池中提供给用户调用。新请求提交时，首先判断池有没有满，若没有满，就开辟一个新进程执行，若已满就等待池中的某个进程结束。Pool类适用于需要执行的目标比较多而且手动限制进程数量又非常复杂的情况。本项目设置一定进程数量的进程池，通过循环将所有需要爬虫的单词异步执行，也就是非阻塞的方式。执行完毕后，关闭进程池并继续执行主进程。</p>
<h3 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h3><p>当时遇到的问题多进程爬取的数据无法同时向SQLite数据库中保存，因此先爬取内容到TXT，再保存到数据库中。</p>
<h2 id="基于Android提供的控件实现抽屉式导航和界面设计。"><a href="#基于Android提供的控件实现抽屉式导航和界面设计。" class="headerlink" title="基于Android提供的控件实现抽屉式导航和界面设计。"></a>基于Android提供的控件实现抽屉式导航和界面设计。</h2><p>根布局就是DrawerLayout，在根布局之后又主要分为两大部分，第一部分就是我们主界面的内容，第二部分是左边滑出的布局，这里用NavitationView来代替。</p>
<p>线性布局（LinearLayout）和相对布局（RelativeLayout）实现。线性布局是将界面中的全部控件按照水平或竖直方向进行排列，同时它也是最基本的布局方式。相对布局则是通过控件之间的相对位置关系实现控件的摆放，有利于适配不同屏幕大小的手机，因此使用更为普遍。</p>
<p>一般布局都是用dp，字体用sp（手机字体调大了，APP的字体会随之变大）来布局的，用来适配移动端分辨率。</p>
<h2 id="调用API或SDK实现语音输入、句子翻译和句子分析功能。"><a href="#调用API或SDK实现语音输入、句子翻译和句子分析功能。" class="headerlink" title="调用API或SDK实现语音输入、句子翻译和句子分析功能。"></a>调用API或SDK实现语音输入、句子翻译和句子分析功能。</h2><p>调用百度API实现句子翻译的功能，调用讯飞开放平台的SDK实现语音输入的功能，调用Stanford Core NLP的JAR文件实现句子分析（词性分析和词形还原）。</p>
<h2 id="使用MVVM架构模式实现视图层与模型层的解耦。"><a href="#使用MVVM架构模式实现视图层与模型层的解耦。" class="headerlink" title="使用MVVM架构模式实现视图层与模型层的解耦。"></a>使用MVVM架构模式实现视图层与模型层的解耦。</h2><p>Android在早期的开发应用中，Activity或Fragment承担了较多职责，不仅负责显示应用界面，还负责处理业务逻辑。</p>
<p>因此，Activity或Fragment非常容易变得复杂且臃肿，难以管理和维护。</p>
<p>随着Android开发技术的不断进步，Android应用架构的设计获得了越来越多的关注。</p>
<p>如今，Android的应用架构主要分为MVC、MVP和MVVM三种模式，本文主要使用了MVVM模式。</p>
<p>MVVM架构模式，该模式将应用分为三层：</p>
<ul>
<li>Model层的职责是提供数据，一般与数据库操作相关；</li>
<li>View层的职责是应用界面的展示，主要指用Activity或Fragment响应界面和展示数据；</li>
<li>ViewModel层的职责是处理业务逻辑。</li>
</ul>
<p>每一层的结构清晰，职责明确，开发的应用可以非常容易进行测试、维护和扩展，有利于模块化和简洁化。</p>
<p>Android为此提供了一套架构组件，主要有LiveData、ViewModel 和Room。</p>
<ul>
<li>LiveData是用来构建数据对象，当基础数据库改变时会通知视图；</li>
<li>ViewModel是用来存储和管理与界面相关的数据，这些数据在应用跳转时不会被销毁；</li>
<li>Room是一个SQLite对象映射库，它可以轻松地将SQLite表数据转换为Java对象，主要负责底层数据库的处理，本文调用其中的Dao接口来执行数据库增删改查等操作，利用 Database创建和管理数据库。同时，Room可以为SQLite语句提供编译时检查，并能够返回RxJava、Flowable和LiveData可观察对象。</li>
<li>Repository是一个仓库类，介于视图层与数据映射层（数据访问层）之间。它的作用是让视图层感觉不到数据访问层的存在，提供了一个类似集合的接口给视图层进行访问。</li>
</ul>
<p>采用MVVM模式最大的优点就是编写代码是思路明确，视图层与模型层完全解耦，方便后期的管理与维护，在代码中的其他地方使用数据库相关的操作只需一行代码，极其方便。</p>
<h1 id="React商城后台管理系统"><a href="#React商城后台管理系统" class="headerlink" title="React商城后台管理系统"></a>React商城后台管理系统</h1><h2 id="后端-仅使用"><a href="#后端-仅使用" class="headerlink" title="后端(仅使用)"></a>后端(仅使用)</h2><p>Node + Express + Mongodb等技术。</p>
<p>Node.js 使用 JavaScript 语言开发服务器端应用；Express是基于 Node.js平台，快速、开放、极简的 Web 开发框架；MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
<p>MySQL 是一个开源的关系数据库，其中的数据存于表中，数据中的某些属性可以跟其他表建立关系。MongoDB 也是开源的，但它属于文档型数据库。因此，它没有记录的概念，它的数据模不固定，所以它是一种动态灵活的数据库，可以插入大量数据。</p>
<p>在选定最佳数据库之前，特定的<strong>业务需求和项目的优先事项</strong>应当是清晰确定的，正如前文提到的，在处理大量数据方面，MongoDB 比 MySQL 更胜一筹。另外，在云计算服务和需求频繁变化的项目上，MongoDB 也是如此。</p>
<p>相反，MySQL 中数据结构和模式是固定的，因此保证了数据一致性和可靠性。使用 MySQL 还有一个好处，就是由于它支持基于 ACID 准则的事务操作，数据安全性更高。所以对于看重这些因素的项目来说，MySQL 是最合适的。</p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p>Less、弹性盒、浮动</p>
<p>Antdv3升级成v4</p>
<p><code>carco</code>自定义主题配置</p>
<p><code>antd</code> 是基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。</p>
<p>v4 的 Form 不再需要通过 <code>Form.create()</code> 创建上下文。Form 组件现在自带数据域，因而 <code>getFieldDecorator</code> 也不再需要，直接写入 Form.Item 即可；Form 自带表单控制实体，如需要调用 form 方法，可以通过 <code>Form.useForm()</code> 创建 Form 实体进行操作。</p>
<h3 id="天气API"><a href="#天气API" class="headerlink" title="天气API"></a>天气API</h3><h4 id="和风天气（不需要跨域处理）"><a href="#和风天气（不需要跨域处理）" class="headerlink" title="和风天气（不需要跨域处理）"></a>和风天气（不需要跨域处理）</h4><p>将和风天气图标安装在你的项目中，包括SVG图标、图标字体等等。</p>
<h3 id="前后台交互"><a href="#前后台交互" class="headerlink" title="前后台交互"></a>前后台交互</h3><p><strong>发送异步ajax请求的函数模块</strong></p>
<p>封装<code>axios</code>库</p>
<p>函数返回值<code>promise</code>对象</p>
<p>优化1: 统一处理请求异常?</p>
<p>在外层包一个自己创建的promise对象，在请求出错时, 不reject(error), 而是显示错误提示</p>
<p>优化2: 异步得到不是reponse, 而是response.data</p>
<p>在请求成功resolve时: resolve(response.data)</p>
<p><strong>jsonp</strong></p>
<h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h3><ul>
<li>作用?<ul>
<li>简化promise对象的使用: 不用再使用then()来指定成功/失败的回调函数</li>
<li>以同步编码(没有回调函数了)方式实现异步流程</li>
</ul>
</li>
<li>哪里写await?<ul>
<li>在返回promise的表达式左侧写await: 不想要promise, 想要promise异步执行的成功的value数据</li>
</ul>
</li>
<li>哪里写async?<ul>
<li>await所在函数(最近的)定义的左侧写async</li>
</ul>
</li>
</ul>
<h3 id="类式组件与函数式组件"><a href="#类式组件与函数式组件" class="headerlink" title="类式组件与函数式组件"></a>类式组件与函数式组件</h3><p>React Router v6 大量使用<a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-intro.html">React hooks</a>。</p>
<p>v6无法直接访问history实例。</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="SPA的理解"><a href="#SPA的理解" class="headerlink" title="SPA的理解"></a>SPA的理解</h4><ul>
<li>单页Web应用（single page web application，SPA）。</li>
<li>整个应用只有<strong>一个完整的页面</strong>。</li>
<li>点击页面中的链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部更新。</strong></li>
<li>数据都需要通过ajax请求获取, 并在前端异步展现。</li>
</ul>
<h4 id="BrowserRouter与HashRouter的区别"><a href="#BrowserRouter与HashRouter的区别" class="headerlink" title="BrowserRouter与HashRouter的区别"></a>BrowserRouter与HashRouter的区别</h4><p><strong>底层原理不一样</strong>：</p>
<ol>
<li><p>BrowserRouter使用的是<strong>H5的history API</strong>，不兼容IE9及以下版本。<code>但一般来说都用的这个</code></p>
</li>
<li><p>HashRouter使用的是<strong>URL的哈希值</strong>。</p>
</li>
</ol>
<p><strong>path表现形式不一样</strong></p>
<ol>
<li>BrowserRouter的路径中没有<code>#</code>,例如：<code>localhost:3000/demo/test</code></li>
<li>HashRouter的路径包含<code>#</code>,例如：<code>localhost:3000/#/demo/test</code></li>
</ol>
<p><strong>刷新后对路由state参数的影响</strong>(在v6中应该已经得到解决，不过官方推荐使用BrowserRouter)</p>
<ol>
<li>BrowserRouter没有任何影响，因为<code>state</code>保存在<code>history</code>对象中。</li>
<li>HashRouter<code>刷新后会导致路由state参数的丢失！！！</code></li>
</ol>
<p><strong>备注：HashRouter可以用于解决一些路径错误相关的问题。</strong></p>
<h4 id="React-Router-v6-新特性"><a href="#React-Router-v6-新特性" class="headerlink" title="React-Router v6 新特性"></a>React-Router v6 新特性</h4><p>React Router v6 大量使用<a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-intro.html">React hooks</a>。</p>
<p><code>Routes</code>是以前 <code>Switch</code> 组件的升级版，它包括相对路由和链接、自动路由排名、嵌套路由和布局等功能。</p>
<p><code>component</code>重命名为<code>element</code></p>
<p>中小型项目嵌套路由可集中显示，在需要显示的地方使用<code>&lt;Outlet /&gt;</code>作为占位符</p>
<p>若分别显示，具有后代路由（在其他组件中定义）的路由在其路径中使用尾随<code>*</code> </p>
<p>index（不写path）表示主路由，<code>path=&#39;*&#39;</code>表示路径都不匹配时。</p>
<p>v6 无法直接访问history实例，将useHistory更改为 useNavigate（兼容性和体验）。</p>
<p>v6 提供了 Navigate 组件，以前版本中的<code>Redirect</code>组件也消失了。</p>
<p>v5:withRouter高阶组件:包装非路由组件, 返回一个新的组件，新的组件向非路由组件传递3个属性: <code>history/location/match</code></p>
<p>v6:使用<code>useLocation</code>即可得到<code>location</code>属性，<code>withRouter</code>不再使用。useLocation().pathname得到当前路径名。</p>
<p>state传递参数，使用<code>useLocation</code>得到<code>location.state</code>。</p>
<p><code>useRoutes</code>钩子是一个路由API，它允许你使用JavaScript对象而不是React元素来声明和组合路由。</p>
<h3 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h3><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><ul>
<li><p>【父组件】给【子组件】传递数据：通过<code>props</code>传递</p>
</li>
<li><p>【子组件】给【父组件】传递数据：通过<code>props</code>传递，<strong>要求父提前给子传递一个函数</strong></p>
<p>该项目中与<code>useState</code>结合使用，用来更新状态</p>
</li>
<li><p>【子组件】给【父组件】传递函数/方法</p>
<ul>
<li><code>useRef</code>: 用于获取元素的原生DOM或者获取自定义组件所暴露出来的ref方法(父组件可以通过ref获取子组件，并调用相对应子组件中的方法)</li>
<li><code>useImperativeHandle</code>:在函数式组件中，用于定义暴露给父组件的ref方法。</li>
<li><code>React.forwardRef</code>: 将ref父类的ref作为参数传入函数式组件中，本身props只带有children这个参数，这样可以让子类转发父类的ref,当父类把ref挂在到子组件上时，子组件外部通过forwrardRef包裹，可以直接将父组件创建的ref挂在到子组件的某个dom元素上。</li>
</ul>
</li>
</ul>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>解决ajax跨域请求问题(<strong>开发时</strong>)</p>
<p>办法: <strong>配置代理</strong>  ==&gt; 只能解决开发环境</p>
<p>编码: package.json: <code>proxy: &quot;http://localhost:5000&quot;</code></p>
<p>对代理的理解</p>
<ul>
<li>是什么?<ul>
<li>具有特定功能的程序</li>
</ul>
</li>
<li>运行在哪?<ul>
<li>前台应用端</li>
<li>只能在开发时使用</li>
</ul>
</li>
<li>作用?<ul>
<li>解决开发时的ajax请求跨域问题</li>
<li>a. <strong>监视并拦截请求</strong>(3000)</li>
<li> b. <strong>转发请求</strong>(4000)</li>
</ul>
</li>
<li>配置代理<ul>
<li>告诉代理服务器一些信息: 比如转发的目标地址</li>
<li>开发环境: 前端工程师</li>
<li>生产环境: 后端工程师</li>
</ul>
</li>
</ul>
<h3 id="登录数据持久化"><a href="#登录数据持久化" class="headerlink" title="登录数据持久化"></a>登录数据持久化</h3><ul>
<li><p>storageUtils.js</p>
<ul>
<li>包含使用<code>localStorage</code>来保存user相关操作的工具模块</li>
<li>使用第三库<code>store.js</code><ul>
<li>简化编码</li>
<li>兼容不同的浏览器</li>
</ul>
</li>
</ul>
</li>
<li><p>memoryUtils.js</p>
<p>用来在内存中保存数据(user)的工具类</p>
</li>
</ul>
<h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><ul>
<li>echarts echarts-for-react</li>
<li>bizcharts</li>
</ul>
<h2 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h2><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><p>useEffect在外部定义函数，存在不安全的问题。</p>
<p>要记住 effect 外部的函数使用了哪些 props 和 state 很难。这也是为什么 <strong>通常你会想要在 effect 内部去声明它所需要的函数</strong>。</p>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>redux是专门做状态管理的独立第3方库, 不是react插件, 但一般都用在react项目中</p>
<p>对应用中状态进行集中式的管理(写/读)</p>
<p>与react-redux, redux-thunk等插件配合使用</p>
<h3 id="解决生产环境ajax跨域问题"><a href="#解决生产环境ajax跨域问题" class="headerlink" title="解决生产环境ajax跨域问题"></a>解决生产环境ajax跨域问题</h3><p>使用nginx的反向代理解决(一般由后台配置)</p>
<p>CORS: 允许浏览器端跨域</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leslie Waong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesliewaong.top/posts/1d0f8d42.html">https://lesliewaong.top/posts/1d0f8d42.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lesliewaong.top" target="_blank">Leslie Waong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CSS/">CSS</a><a class="post-meta__tags" href="/tags/HTML/">HTML</a><a class="post-meta__tags" href="/tags/JS/">JS</a><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a></div><div class="post_share"><div class="social-share" data-image="https://s4.ax1x.com/2021/12/17/Ti4hV0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/b976e516.html"><img class="prev-cover" src="https://s4.ax1x.com/2021/12/17/Ti4Oq1.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法题（JS）</div></div></a></div><div class="next-post pull-right"><a href="/posts/a9ba4134.html"><img class="next-cover" src="https://s4.ax1x.com/2021/12/17/Ti5ZIf.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaScript基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/8942b6ab.html" title="纯HTML/CSS项目——“宇智波•鸣人”"><img class="cover" src="https://s4.ax1x.com/2022/02/12/H0BbG9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-16</div><div class="title">纯HTML/CSS项目——“宇智波•鸣人”</div></div></a></div><div><a href="/posts/2eec1551.html" title="HTML和CSS基础"><img class="cover" src="https://s4.ax1x.com/2021/12/17/Ti4sPS.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-08</div><div class="title">HTML和CSS基础</div></div></a></div><div><a href="/posts/c0a854fc.html" title="CSS选择器及优先级"><img class="cover" src="https://s4.ax1x.com/2022/02/12/H0Bjr6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-13</div><div class="title">CSS选择器及优先级</div></div></a></div><div><a href="/posts/3e6a4f74.html" title="CSS盒模型、BFC和清除浮动"><img class="cover" src="https://s4.ax1x.com/2022/02/12/H0BvqK.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-12</div><div class="title">CSS盒模型、BFC和清除浮动</div></div></a></div><div><a href="/posts/74bc18a0.html" title="三栏布局"><img class="cover" src="https://s4.ax1x.com/2022/02/12/H0BT54.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-15</div><div class="title">三栏布局</div></div></a></div><div><a href="/posts/28d62aa4.html" title="居中布局与Flex"><img class="cover" src="https://s4.ax1x.com/2022/02/12/H0BHPJ.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-14</div><div class="title">居中布局与Flex</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Leslie Waong</div><div class="author-info__description">BUPT</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lesliewaong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lesliewaong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1138964397&amp;website=www.qtxml.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">红雨漂泊泛起了回忆怎么潜</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML-amp-CSS"><span class="toc-text">HTML&amp;CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">语义化的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lt-img-gt-%E7%9A%84title%E5%92%8Calt%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">&lt;img&gt;的title和alt有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#H5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">H5的新特性有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iframe%E6%9C%89%E9%82%A3%E4%BA%9B%E7%BC%BA%E7%82%B9"><span class="toc-text">iframe有那些缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8Bsrc%E4%B8%8Ehref%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">简述一下src与href的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E9%81%93%E7%9A%84%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C%E4%BC%9A%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">知道的网页制作会用到的图片格式有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%E2%AD%90"><span class="toc-text">居中布局⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inline-%EF%BC%8C-block%EF%BC%8C-inline-blockd%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">inline ， block， inline-blockd的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#absolute-transform"><span class="toc-text">absolute + transform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D"><span class="toc-text">定位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flex%E2%AD%90"><span class="toc-text">Flex⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-text">容器属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flex-direction"><span class="toc-text">flex-direction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flex-wrap"><span class="toc-text">flex-wrap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flex-flow"><span class="toc-text">flex-flow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#justify-content"><span class="toc-text">justify-content</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#align-items"><span class="toc-text">align-items</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#align-content"><span class="toc-text">align-content</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">项目的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flex"><span class="toc-text">flex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flex-grow"><span class="toc-text">flex-grow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flex-shrink"><span class="toc-text">flex-shrink</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flex-basis"><span class="toc-text">flex-basis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#align-self"><span class="toc-text">align-self</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#order"><span class="toc-text">order</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flex-grow-1"><span class="toc-text">flex-grow</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E2%AD%90"><span class="toc-text">页面布局⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%88%E6%9E%9C"><span class="toc-text">效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E4%BC%B8"><span class="toc-text">延伸</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">五种方法的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E9%A2%98%E7%9B%AE%E4%B8%AD%E5%8E%BB%E6%8E%89%E9%AB%98%E5%BA%A6%E5%B7%B2%E7%9F%A5"><span class="toc-text">如果题目中去掉高度已知</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E7%9A%84%E5%8F%98%E9%80%9A"><span class="toc-text">页面布局的变通</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%A4%E8%AF%86%E2%AD%90"><span class="toc-text">对CSS盒模型的认识⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%92%8CIE%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-text">标准盒模型和IE盒子模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%9E%8B"><span class="toc-text">CSS如何设置这两种模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E3%80%81%E8%8E%B7%E5%8F%96%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AE%BD%E5%92%8C%E9%AB%98"><span class="toc-text">JS如何设置、获取盒模型对应的宽和高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#margin%E5%A1%8C%E9%99%B7-margin%E9%87%8D%E5%8F%A0"><span class="toc-text">margin塌陷&#x2F;margin重叠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC%EF%BC%88%E8%BE%B9%E8%B7%9D%E9%87%8D%E5%8F%A0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%89"><span class="toc-text">BFC（边距重叠解决方案）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BFC%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">BFC的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFC-%E7%9A%84%E5%8E%9F%E7%90%86-BFC%E7%9A%84%E5%B8%83%E5%B1%80%E8%A7%84%E5%88%99%E3%80%90%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%E3%80%91"><span class="toc-text">BFC 的原理&#x2F;BFC的布局规则【非常重要】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90BFC"><span class="toc-text">如何生成BFC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFC-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">BFC 的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E4%B8%ADlink%E5%92%8C-import%E5%8C%BA%E5%88%AB"><span class="toc-text">CSS中link和@import区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E9%80%89%E6%8B%A9%E5%99%A8%E2%AD%90"><span class="toc-text">CSS选择器⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8%E7%B1%BB%E5%88%AB"><span class="toc-text">选择器类别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8%E6%9D%83%E9%87%8D"><span class="toc-text">选择器权重</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">层叠上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E5%8A%A8%E7%94%BB"><span class="toc-text">CSS动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#less%E2%AD%90"><span class="toc-text">less⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#script%E6%A0%87%E7%AD%BE%E7%9A%84defer%E5%92%8Casync%E5%B1%9E%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">script标签的defer和async属性有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-text">CSS三角形</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JacaScript"><span class="toc-text">JacaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E2%AD%90"><span class="toc-text">内置类型⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-text">类型判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof"><span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceof"><span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-prototype-toString-call"><span class="toc-text">Object.prototype.toString.call()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array"><span class="toc-text">Array</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C1%E2%80%9D-%E2%80%9D2%E2%80%9D-%E2%80%9D3%E2%80%9D-map-parseInt-%E7%9A%84%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-text">[“1”,”2”,”3”].map(parseInt)的输出结果是多少?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E8%BF%94%E5%9B%9E-1-2-3-%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%BD%A0%E8%83%BD%E6%83%B3%E5%88%B0%E7%9A%84%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%A1%88-%E8%A6%81%E6%B1%82%E4%BD%BF%E7%94%A8-map"><span class="toc-text">如何让上述代码返回[1,2,3]，使用你能想到的最简单的方案(要求使用[].map())</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#splice%E5%92%8Cslice%E4%BD%A0%E8%83%BD%E8%AF%B4%E8%AF%B4%E6%9C%89%E5%95%A5%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB%E5%90%97"><span class="toc-text">splice和slice你能说说有啥用和区别吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84"><span class="toc-text">怎么判断数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Number"><span class="toc-text">Number</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-1-0-2-0-3"><span class="toc-text">0.1 + 0.2 !&#x3D;&#x3D; 0.3?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#number%E8%83%BD%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%95%B4%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E8%8C%83%E5%9B%B4"><span class="toc-text">number能表示的整数的最大范围</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined%E4%B8%8Enull%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">undefined与null的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%9C%89%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">查询某个对象是否有某个属性的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8in%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">使用in关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84hasOwnProperty-%E6%96%B9%E6%B3%95"><span class="toc-text">使用对象的hasOwnProperty()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8undefined%E5%88%A4%E6%96%AD"><span class="toc-text">使用undefined判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E4%B8%AD%E5%88%A4%E6%96%AD"><span class="toc-text">在条件语句中判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#propertyIsEnumerable-NaN"><span class="toc-text">propertyIsEnumerable()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%E2%AD%90"><span class="toc-text">作用域与闭包⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85"><span class="toc-text">1）什么是闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E9%97%AD%E5%8C%85%E5%8E%9F%E7%90%86"><span class="toc-text">2）闭包原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E4%BC%98%E7%82%B9"><span class="toc-text">3）优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E7%BC%BA%E7%82%B9"><span class="toc-text">4）缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">4）应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E2%AD%90"><span class="toc-text">引用和操作符优先级⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E2%AD%90"><span class="toc-text">原型与原型链⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF%E2%AD%90"><span class="toc-text">原型和继承⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"><span class="toc-text">全局对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proto"><span class="toc-text">__proto__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new"><span class="toc-text">new</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E4%B8%80%E4%B8%8B"><span class="toc-text">检测一下</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93%E2%AD%90"><span class="toc-text">DOM事件总结⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BA%A7%E5%88%AB"><span class="toc-text">DOM事件的级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E3%80%81DOM%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-text">DOM事件模型、DOM事件流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-text">DOM事件模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-text">DOM事件流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0DOM%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-text">描述DOM事件捕获的具体流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">捕获的流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">冒泡的流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81-api-%E6%96%B9%E6%B3%95"><span class="toc-text">Event对象的常见 api 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1"><span class="toc-text">方法二：阻止冒泡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E8%AE%BE%E7%BD%AE%E4%BA%8B%E4%BB%B6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">方法三：设置事件优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A74%E3%80%81%E5%B1%9E%E6%80%A75%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E4%B8%AD%E7%94%A8%E5%88%B0%EF%BC%89"><span class="toc-text">属性4、属性5（事件委托中用到）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-text">自定义事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-text">事件委托</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E5%90%91%E2%AD%90"><span class="toc-text">this指向⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A"><span class="toc-text">默认绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-text">严格模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-text">非严格模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="toc-text">隐式绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="toc-text">显式绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87new%E7%BB%91%E5%AE%9A"><span class="toc-text">通过new绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="toc-text">ES6箭头函数绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">规则优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E8%83%BD%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%90%97%EF%BC%9F%E2%AD%90"><span class="toc-text">你能讲一下事件循环机制吗？⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85%E2%AD%90"><span class="toc-text">new 操作符做了哪些事情⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call%E3%80%81apply%E3%80%81bind%E5%8C%BA%E5%88%AB"><span class="toc-text">call、apply、bind区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let-const-var-%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="toc-text">let const var 区别⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#var"><span class="toc-text">var</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#let"><span class="toc-text">let</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-text">const</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E2%AD%90"><span class="toc-text">变量提升和函数提升⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB%E2%AD%90"><span class="toc-text">箭头函数与普通函数区别⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-%E2%80%A6-of-%E9%81%8D%E5%8E%86%E8%A7%84%E5%88%99"><span class="toc-text">for … of 遍历规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map%E4%B8%8Eset%E2%AD%90"><span class="toc-text">map与set⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-text">map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E4%B8%8Eobject%E5%8C%BA%E5%88%AB"><span class="toc-text">map与object区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AE%E5%80%BC"><span class="toc-text">键值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E4%B8%8E%E8%BF%AD%E4%BB%A3"><span class="toc-text">顺序与迭代</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E4%B8%8EweakMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">map与weakMap的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-%E4%B8%8E-weakSet-%E5%8C%BA%E5%88%AB"><span class="toc-text">set 与 weakSet 区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-text">函数的柯里化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">计算机网络和浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%92%8CUDP"><span class="toc-text">TCP和UDP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URI-%E5%92%8C-URL"><span class="toc-text">URI 和 URL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E5%92%8C-HTTPS"><span class="toc-text">HTTP 和 HTTPS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E2%AD%90"><span class="toc-text">HTTP协议⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-text">HTTP协议的主要特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">HTTP报文的组成部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%8C%85%E6%8B%AC%EF%BC%9A"><span class="toc-text">请求报文包括：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E5%8C%85%E6%8B%AC%EF%BC%9A"><span class="toc-text">响应报文包括：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E6%96%B9%E6%B3%95"><span class="toc-text">HTTP方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">http状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E9%93%BE%E6%8E%A5-http%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="toc-text">持久链接&#x2F;http长连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84%E7%AE%A1%E7%BA%BF%E5%8C%96"><span class="toc-text">长连接中的管线化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E2%AD%90"><span class="toc-text">跨域通信⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%85%B7%E4%BD%93%E9%99%90%E5%88%B6"><span class="toc-text">同源策略的概念和具体限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1"><span class="toc-text">前后端如何通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAAjax"><span class="toc-text">如何创建Ajax</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81-Ajax-%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BA%94%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="toc-text">发送 Ajax 请求的五个步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81-get-%E8%AF%B7%E6%B1%82%E5%92%8C-post-%E8%AF%B7%E6%B1%82"><span class="toc-text">发送 get 请求和 post 请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#onreadystatechange-%E4%BA%8B%E4%BB%B6"><span class="toc-text">onreadystatechange 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-text">事件的触发条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%A7%A6%E5%8F%91%E9%A1%BA%E5%BA%8F"><span class="toc-text">事件的触发顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">跨域通信的几种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSONP"><span class="toc-text">JSONP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocket"><span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS"><span class="toc-text">CORS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash"><span class="toc-text">Hash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#postMessage-%E6%96%B9%E6%B3%95"><span class="toc-text">postMessage()方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%E2%AD%90"><span class="toc-text">从URL输入到页面展现到底发生什么？⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URL-%E5%88%B0%E5%BA%95%E6%98%AF%E5%95%A5"><span class="toc-text">URL 到底是啥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%EF%BC%88DNS%EF%BC%89"><span class="toc-text">域名解析（DNS）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IP-%E5%9C%B0%E5%9D%80"><span class="toc-text">IP 地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90"><span class="toc-text">什么是域名解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%9F%9F%E5%90%8D%E5%8E%BB%E6%9F%A5%E8%AF%A2-URL-%E5%AF%B9%E5%BA%94%E7%9A%84-IP-%E5%91%A2"><span class="toc-text">浏览器如何通过域名去查询 URL 对应的 IP 呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">TCP 三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">TCP 三次握手的过程如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E5%95%A5%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">为啥需要三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-2-%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BC%A0%E5%9B%9E%E4%BA%86-ACK%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BC%A0%E5%9B%9E-SYN%EF%BC%9F"><span class="toc-text">第 2 次握手传回了 ACK，为什么还要传回 SYN？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81-HTTP-%E8%AF%B7%E6%B1%82"><span class="toc-text">发送 HTTP 请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%B9%B6%E8%BF%94%E5%9B%9E-HTTP-%E6%8A%A5%E6%96%87"><span class="toc-text">服务器处理请求并返回 HTTP 报文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVC-%E5%90%8E%E5%8F%B0%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5"><span class="toc-text">MVC 后台处理阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-text">http 响应报文</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2"><span class="toc-text">浏览器解析渲染页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">断开连接 四次挥手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie%E3%80%81sessionStorage%E3%80%81localStorage-%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E2%AD%90"><span class="toc-text">cookie、sessionStorage、localStorage 详解及应用场景⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie"><span class="toc-text">cookie</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3cookie"><span class="toc-text">了解cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">cookie的应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie%E7%BC%BA%E7%82%B9"><span class="toc-text">cookie缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%82%A8%E5%AD%98"><span class="toc-text">本地储存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#localStorage-amp-amp-sessionStorage"><span class="toc-text">localStorage &amp;&amp; sessionStorage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#localStorage%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">localStorage应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sessionStorage%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">sessionStorage应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E2%AD%90"><span class="toc-text">线程与进程⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88js%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84"><span class="toc-text">为什么js是单线程的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">进程和线程的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81%EF%BC%88Repaint%E3%80%81Reflow%EF%BC%89"><span class="toc-text">浏览器的重绘与回流（Repaint、Reflow）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6"><span class="toc-text">浏览器渲染机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BB%98"><span class="toc-text">重绘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%B5%81"><span class="toc-text">回流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%98%E5%8C%96"><span class="toc-text">浏览器优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81"><span class="toc-text">减少重绘与回流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript"><span class="toc-text">TypeScript</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EAndroid%E7%9A%84%E7%94%B5%E5%AD%90%E8%AF%8D%E5%85%B8%E8%AE%BE%E8%AE%A1"><span class="toc-text">基于Android的电子词典设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%9F%E5%8A%A9Python%E7%9A%84Requests%E5%BA%93%E5%92%8Clxml%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%8D%95%E8%AF%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E7%88%AC%E5%8F%96%E3%80%82"><span class="toc-text">借助Python的Requests库和lxml库进行单词数据的爬取。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Requests"><span class="toc-text">Requests</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XPath"><span class="toc-text">XPath</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-text">多进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQLite"><span class="toc-text">SQLite</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EAndroid%E6%8F%90%E4%BE%9B%E7%9A%84%E6%8E%A7%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%B1%89%E5%BC%8F%E5%AF%BC%E8%88%AA%E5%92%8C%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%E3%80%82"><span class="toc-text">基于Android提供的控件实现抽屉式导航和界面设计。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8API%E6%88%96SDK%E5%AE%9E%E7%8E%B0%E8%AF%AD%E9%9F%B3%E8%BE%93%E5%85%A5%E3%80%81%E5%8F%A5%E5%AD%90%E7%BF%BB%E8%AF%91%E5%92%8C%E5%8F%A5%E5%AD%90%E5%88%86%E6%9E%90%E5%8A%9F%E8%83%BD%E3%80%82"><span class="toc-text">调用API或SDK实现语音输入、句子翻译和句子分析功能。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8MVVM%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%A7%86%E5%9B%BE%E5%B1%82%E4%B8%8E%E6%A8%A1%E5%9E%8B%E5%B1%82%E7%9A%84%E8%A7%A3%E8%80%A6%E3%80%82"><span class="toc-text">使用MVVM架构模式实现视图层与模型层的解耦。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">React商城后台管理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF-%E4%BB%85%E4%BD%BF%E7%94%A8"><span class="toc-text">后端(仅使用)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF"><span class="toc-text">前端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2"><span class="toc-text">界面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A9%E6%B0%94API"><span class="toc-text">天气API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8C%E9%A3%8E%E5%A4%A9%E6%B0%94%EF%BC%88%E4%B8%8D%E9%9C%80%E8%A6%81%E8%B7%A8%E5%9F%9F%E5%A4%84%E7%90%86%EF%BC%89"><span class="toc-text">和风天气（不需要跨域处理）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E5%8F%B0%E4%BA%A4%E4%BA%92"><span class="toc-text">前后台交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async%E5%92%8Cawait"><span class="toc-text">async和await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%BC%8F%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="toc-text">类式组件与函数式组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1"><span class="toc-text">路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SPA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">SPA的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BrowserRouter%E4%B8%8EHashRouter%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">BrowserRouter与HashRouter的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-Router-v6-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">React-Router v6 新特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E9%80%9A%E4%BF%A1"><span class="toc-text">父子通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#props"><span class="toc-text">props</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-text">跨域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">登录数据持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-text">数据可视化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96"><span class="toc-text">进一步优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook"><span class="toc-text">Hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redux"><span class="toc-text">Redux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83ajax%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-text">解决生产环境ajax跨域问题</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/ebeefcc9.html" title="异步编程和事件循环"><img src="https://s4.ax1x.com/2022/03/01/bQ1k60.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif'" alt="异步编程和事件循环"/></a><div class="content"><a class="title" href="/posts/ebeefcc9.html" title="异步编程和事件循环">异步编程和事件循环</a><time datetime="2022-02-27T05:12:12.000Z" title="发表于 2022-02-27 13:12:12">2022-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/24025dd2.html" title="原型和继承"><img src="https://s4.ax1x.com/2022/02/12/H0Bq2R.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif'" alt="原型和继承"/></a><div class="content"><a class="title" href="/posts/24025dd2.html" title="原型和继承">原型和继承</a><time datetime="2022-02-20T11:12:22.000Z" title="发表于 2022-02-20 19:12:22">2022-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/aa436af0.html" title="Class 的基本语法"><img src="https://s4.ax1x.com/2022/02/12/H0B4bT.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif'" alt="Class 的基本语法"/></a><div class="content"><a class="title" href="/posts/aa436af0.html" title="Class 的基本语法">Class 的基本语法</a><time datetime="2022-02-18T13:01:02.000Z" title="发表于 2022-02-18 21:01:02">2022-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7108a574.html" title="严格模式"><img src="https://s4.ax1x.com/2022/02/12/H0BIVU.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif'" alt="严格模式"/></a><div class="content"><a class="title" href="/posts/7108a574.html" title="严格模式">严格模式</a><time datetime="2022-02-18T13:01:02.000Z" title="发表于 2022-02-18 21:01:02">2022-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8942b6ab.html" title="纯HTML/CSS项目——“宇智波•鸣人”"><img src="https://s4.ax1x.com/2022/02/12/H0BbG9.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif'" alt="纯HTML/CSS项目——“宇智波•鸣人”"/></a><div class="content"><a class="title" href="/posts/8942b6ab.html" title="纯HTML/CSS项目——“宇智波•鸣人”">纯HTML/CSS项目——“宇智波•鸣人”</a><time datetime="2022-02-16T02:12:32.000Z" title="发表于 2022-02-16 10:12:32">2022-02-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Leslie Waong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="6995412795" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="auto" data-autoplay="true" muted></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":0,"vOffset":0},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body></html>