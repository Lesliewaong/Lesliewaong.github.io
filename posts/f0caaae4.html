<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>TS中那些奇怪的符号 | Leslie Waong</title><meta name="keywords" content="TypeScript"><meta name="author" content="Leslie Waong"><meta name="copyright" content="Leslie Waong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TS中那些奇怪的符号! 非空断言操作符在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 ! 可以用于断言操作对象是非 null 和非 undefined 类型。 具体而言，x! 将从 x 值域中排除 null 和 undefined 。 那么非空断言操作符到底有什么用呢？下面我们先来看一下非空断言操作符的一些使用场景。 忽略 undefined 和 null 类型123456func"><meta property="og:type" content="article"><meta property="og:title" content="TS中那些奇怪的符号"><meta property="og:url" content="https://lesliewaong.top/posts/f0caaae4.html"><meta property="og:site_name" content="Leslie Waong"><meta property="og:description" content="TS中那些奇怪的符号! 非空断言操作符在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 ! 可以用于断言操作对象是非 null 和非 undefined 类型。 具体而言，x! 将从 x 值域中排除 null 和 undefined 。 那么非空断言操作符到底有什么用呢？下面我们先来看一下非空断言操作符的一些使用场景。 忽略 undefined 和 null 类型123456func"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/14.jpg"><meta property="article:published_time" content="2022-07-10T03:12:48.000Z"><meta property="article:modified_time" content="2022-07-17T08:40:25.763Z"><meta property="article:author" content="Leslie Waong"><meta property="article:tag" content="TypeScript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/14.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg"><link rel="canonical" href="https://lesliewaong.top/posts/f0caaae4"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"一年之内的产物",messageNext:"技术可能存在过期"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Leslie Waong",link:"链接: ",source:"来源: Leslie Waong",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"TS中那些奇怪的符号",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-07-17 16:40:25"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px");const a=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};a(),document.addEventListener("pjax:complete",a)})(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Leslie Waong" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">119</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li><li><a class="site-page child" href="/item/test/"><i class="fa-fw fa fa-star"></i><span> test</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/14.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leslie Waong</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li><li><a class="site-page child" href="/item/test/"><i class="fa-fw fa fa-star"></i><span> test</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">TS中那些奇怪的符号</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-10T03:12:48.000Z" title="发表于 2022-07-10 11:12:48">2022-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-17T08:40:25.763Z" title="更新于 2022-07-17 16:40:25">2022-07-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/TypeScript/">TypeScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="TS中那些奇怪的符号"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="TS中那些奇怪的符号"><a href="#TS中那些奇怪的符号" class="headerlink" title="TS中那些奇怪的符号"></a><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023943952">TS中那些奇怪的符号</a></h1><h2 id="非空断言操作符"><a href="#非空断言操作符" class="headerlink" title="! 非空断言操作符"></a>! 非空断言操作符</h2><p>在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 <code>!</code> 可以用于断言操作对象是非 null 和非 undefined 类型。</p><p><strong>具体而言，x! 将从 x 值域中排除 null 和 undefined 。</strong></p><p>那么非空断言操作符到底有什么用呢？下面我们先来看一下非空断言操作符的一些使用场景。</p><h4 id="忽略-undefined-和-null-类型"><a href="#忽略-undefined-和-null-类型" class="headerlink" title="忽略 undefined 和 null 类型"></a>忽略 undefined 和 null 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">maybeString: <span class="built_in">string</span> | <span class="literal">undefined</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Type &#x27;string | null | undefined&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br><span class="line">  <span class="comment">// Type &#x27;undefined&#x27; is not assignable to type &#x27;string&#x27;. </span></span><br><span class="line">  <span class="keyword">const</span> onlyString: <span class="built_in">string</span> = maybeString; <span class="comment">// Error</span></span><br><span class="line">  <span class="keyword">const</span> ignoreUndefinedAndNull: <span class="built_in">string</span> = maybeString!; <span class="comment">// Ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用函数时忽略-undefined-类型"><a href="#调用函数时忽略-undefined-类型" class="headerlink" title="调用函数时忽略 undefined 类型"></a>调用函数时忽略 undefined 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumGenerator = <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">numGenerator: NumGenerator | <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Object is possibly &#x27;undefined&#x27;.(2532)</span></span><br><span class="line">  <span class="comment">// Cannot invoke an object which is possibly &#x27;undefined&#x27;.(2722)</span></span><br><span class="line">  <span class="keyword">const</span> num1 = numGenerator(); <span class="comment">// Error</span></span><br><span class="line">  <span class="keyword">const</span> num2 = numGenerator!(); <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>!</code> 非空断言操作符会从编译生成的 JavaScript 代码中移除，所以在实际使用的过程中，要特别注意。比如下面这个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="built_in">number</span> | <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> b: <span class="built_in">number</span> = a!;</span><br><span class="line"><span class="built_in">console</span>.log(b); </span><br></pre></td></tr></table></figure><p>以上 TS 代码会编译生成以下 ES5 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure><p>虽然在 TS 代码中，我们使用了非空断言，使得 <code>const b: number = a!;</code> 语句可以通过 TypeScript 类型检查器的检查。但在生成的 ES5 代码中，<code>!</code> 非空断言操作符被移除了，所以在浏览器中执行以上代码，在控制台会输出 <code>undefined</code>。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="?. 运算符"></a>?. 运算符</h2><p>TypeScript 3.7 实现了呼声最高的 ECMAScript 功能之一：可选链（Optional Chaining）。</p><p>有了可选链后，我们编写代码时如果遇到 <code>null</code> 或 <code>undefined</code> 就可以立即停止某些表达式的运行。</p><p>可选链的核心是新的 <code>?.</code> 运算符，它支持以下语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj?.prop</span><br><span class="line">obj?.[expr]</span><br><span class="line">arr?.[index]</span><br><span class="line">func?.(args)</span><br></pre></td></tr></table></figure><h3 id="可选的属性访问"><a href="#可选的属性访问" class="headerlink" title="可选的属性访问"></a>可选的属性访问</h3><p>这里我们来举一个可选的属性访问的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> val = a?.b;</span><br></pre></td></tr></table></figure><p>为了更好的理解可选链，我们来看一下该 <code>const val = a?.b</code> 语句编译生成的 ES5 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> val = a === <span class="literal">null</span> || a === <span class="keyword">void</span> <span class="number">0</span> ? <span class="keyword">void</span> <span class="number">0</span> : a.b;</span><br></pre></td></tr></table></figure><p>上述的代码会自动检查对象 a 是否为 <code>null</code> 或 <code>undefined</code>，如果是的话就立即返回 <code>undefined</code>，这样就可以立即停止某些表达式的运行。你可能已经想到可以使用 <code>?.</code> 来替代很多使用 <code>&amp;&amp;</code> 执行空检查的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &amp;&amp; a.b) &#123; &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a?.b)&#123; &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* if(a?.b)&#123; &#125; 编译后的ES5代码</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* if(</span></span><br><span class="line"><span class="comment">*  a === null || a === void 0 </span></span><br><span class="line"><span class="comment">*  ? void 0 : a.b) &#123;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>但需要注意的是，<code>?.</code> 与 <code>&amp;&amp;</code> 运算符行为略有不同，<code>&amp;&amp;</code> 专门用于检测 <code>falsy</code> 值，比如<strong>空字符串</strong>、<strong>0</strong>、<strong>NaN</strong>、<strong>null</strong> 和 <strong>false</strong> 等。</p><p>而 <code>?.</code> 只会验证对象是否为 <code>null</code> 或 <code>undefined</code>，对于 0 或空字符串来说，并不会出现 “短路”。</p><h3 id="可选元素访问"><a href="#可选元素访问" class="headerlink" title="可选元素访问"></a>可选元素访问</h3><p>可选链除了支持<strong>可选属性</strong>的访问之外，它还支持<strong>可选元素</strong>的访问，它的行为类似于可选属性的访问，只是可选元素的访问允许我们访问非标识符的属性，比如任意字符串、数字索引和 Symbol：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryGetArrayElement</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr?: T[], index: <span class="built_in">number</span> = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr?.[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码经过编译后会生成以下 ES5 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryGetArrayElement</span>(<span class="params">arr, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="keyword">void</span> <span class="number">0</span>) &#123; index = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> arr === <span class="literal">null</span> || arr === <span class="keyword">void</span> <span class="number">0</span> ? <span class="keyword">void</span> <span class="number">0</span> : arr[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过观察生成的 ES5 代码，很明显在 <code>tryGetArrayElement</code> 方法中会自动检测输入参数 arr 的值是否为 <code>null</code> 或 <code>undefined</code>，从而保证了我们代码的健壮性。</p><h3 id="可选链与函数调用"><a href="#可选链与函数调用" class="headerlink" title="可选链与函数调用"></a>可选链与函数调用</h3><p>当尝试调用一个<strong>可能不存在的方法</strong>时也可以使用可选链。</p><p>在实际开发过程中，这是很有用的。</p><p>系统中某个方法不可用，有可能是由于版本不一致或者用户设备兼容性问题导致的。</p><p>函数调用时如果被调用的方法不存在，使用可选链可以使表达式自动返回 <code>undefined</code> 而不是抛出一个异常。</p><p>可选调用使用起来也很简单，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = obj.customMethod?.();</span><br></pre></td></tr></table></figure><p>该 TypeScript 代码编译生成的 ES5 代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = (_a = obj.customMethod) === <span class="literal">null</span></span><br><span class="line">  || _a === <span class="keyword">void</span> <span class="number">0</span> ? <span class="keyword">void</span> <span class="number">0</span> : _a.call(obj);</span><br></pre></td></tr></table></figure><p>另外在使用可选调用的时候，我们要注意以下两个注意事项：</p><ul><li>如果存在一个属性名且该属性名对应的值不是函数类型，使用 <code>?.</code> 仍然会产生一个 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=u0bsgrVkCmczcGx3T4bh1A==.yINHMmTv3WVHRLR4ocsWjGeAbX863orCRS8djpDxybL5MA3KoTIJqpHbEx74GInKLzhV3jLjEopgU03jPeNv1lhQXgAOC/5ZlbyYXiZDQNi2JprpBYCc06g/bN3+ugCG"><code>TypeError</code></a> 异常。</li><li>可选链的运算行为被局限在属性的访问、调用以及元素的访问 —— 它不会沿伸到后续的表达式中，也就是说可选调用不会阻止 <code>a?.b / someMethod()</code> 表达式中的除法运算或 <code>someMethod</code> 的方法调用。</li></ul><h2 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="?? 空值合并运算符"></a>?? 空值合并运算符</h2><p>在 TypeScript 3.7 版本中除了引入了前面介绍的可选链 <code>?.</code> 之外，也引入了一个新的逻辑运算符 —— 空值合并运算符 <code>??</code>。</p><p><strong>当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数</strong>。</p><p>与逻辑或 <code>||</code> 运算符不同，逻辑或会在左操作数为 <strong>falsy</strong> 值时返回右侧操作数。</p><p>也就是说，如果你使用 <code>||</code> 来为某些变量设置默认的值时，你可能会遇到意料之外的行为。比如为 falsy 值（<code>&#39;&#39;</code>、<code>NaN</code> 或 <code>0</code>）时。</p><p>这里来看一个具体的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="literal">null</span> ?? <span class="string">&#x27;default string&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出：&quot;default string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="number">0</span> ?? <span class="number">42</span>;</span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// 输出：0</span></span><br></pre></td></tr></table></figure><p>以上 TS 代码经过编译后，会生成以下 ES5 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> _a, _b;</span><br><span class="line"><span class="keyword">var</span> foo = (_a = <span class="literal">null</span>) !== <span class="literal">null</span> &amp;&amp; _a !== <span class="keyword">void</span> <span class="number">0</span> ? _a : <span class="string">&#x27;default string&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出：&quot;default string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = (_b = <span class="number">0</span>) !== <span class="literal">null</span> &amp;&amp; _b !== <span class="keyword">void</span> <span class="number">0</span> ? _b : <span class="number">42</span>;</span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// 输出：0</span></span><br></pre></td></tr></table></figure><p>通过观察以上代码，我们更加直观的了解到，空值合并运算符是如何解决前面 <code>||</code> 运算符存在的潜在问题。下面我们来介绍空值合并运算符的特性和使用时的一些注意事项。</p><h3 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h3><p>当空值合并运算符的左表达式不为 <code>null</code> 或 <code>undefined</code> 时，不会对右表达式进行求值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;A was called&#x27;</span>); <span class="keyword">return</span> <span class="literal">undefined</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;B was called&#x27;</span>); <span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;C was called&#x27;</span>); <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(A() ?? C());</span><br><span class="line"><span class="built_in">console</span>.log(B() ?? C());</span><br></pre></td></tr></table></figure><p>上述代码运行后，控制台会输出以下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A was called </span><br><span class="line">C was called </span><br><span class="line">foo </span><br><span class="line">B was called </span><br><span class="line">false </span><br></pre></td></tr></table></figure><h3 id="不能与-amp-amp-或-操作符共用"><a href="#不能与-amp-amp-或-操作符共用" class="headerlink" title="不能与 &amp;&amp; 或 || 操作符共用"></a>不能与 &amp;&amp; 或 || 操作符共用</h3><p>若空值合并运算符 <code>??</code> 直接与 <code>AND（&amp;&amp;）</code>和 <code>OR（||）</code>操作符组合使用 是不行的。这种情况下会抛出 SyntaxError。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#x27;||&#x27; and &#x27;??&#x27; operations cannot be mixed without parentheses.(5076)</span></span><br><span class="line"><span class="literal">null</span> || <span class="literal">undefined</span> ?? <span class="string">&quot;foo&quot;</span>; <span class="comment">// raises a SyntaxError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#x27;&amp;&amp;&#x27; and &#x27;??&#x27; operations cannot be mixed without parentheses.(5076)</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">undefined</span> ?? <span class="string">&quot;foo&quot;</span>; <span class="comment">// raises a SyntaxError</span></span><br></pre></td></tr></table></figure><p>但当使用括号来显式表明优先级时是可行的，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="literal">null</span> || <span class="literal">undefined</span> ) ?? <span class="string">&quot;foo&quot;</span>; <span class="comment">// 返回 &quot;foo&quot;</span></span><br></pre></td></tr></table></figure><h3 id="与可选链操作符-的关系"><a href="#与可选链操作符-的关系" class="headerlink" title="与可选链操作符 ?. 的关系"></a>与可选链操作符 ?. 的关系</h3><p>空值合并运算符针对 <code>undefined</code> 与 <code>null</code> 这两个值，可选链式操作符 <code>?.</code> 也是如此。</p><p>可选链式操作符，对于访问属性可能为 <code>undefined</code> 与 <code>null</code> 的对象时非常有用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Customer &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  city?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> customer: Customer = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Semlinker&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> customerCity = customer?.city ?? <span class="string">&quot;Unknown city&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(customerCity); <span class="comment">// 输出：Unknown city</span></span><br></pre></td></tr></table></figure><p>前面我们已经介绍了空值合并运算符的应用场景和使用时的一些注意事项，该运算符不仅可以在 TypeScript 3.7 以上版本中使用。</p><p>当然你也可以在 JavaScript 的环境中使用它，但你需要借助 Babel，在 Babel 7.8.0 版本也开始支持空值合并运算符。</p><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="? 可选属性"></a>? 可选属性</h2><p>在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。</p><p><strong>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述</strong>。</p><p>在 TypeScript 中使用 <code>interface</code> 关键字就可以声明一个接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> semlinker: Person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;semlinker&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">33</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们声明了 <code>Person</code> 接口，它包含了两个必填的属性 <code>name</code> 和 <code>age</code>。在初始化 Person 类型变量时，如果缺少某个属性，TypeScript 编译器就会提示相应的错误信息，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Property &#x27;age&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27; but required in type &#x27;Person&#x27;.(2741)</span></span><br><span class="line"><span class="keyword">let</span> lolo: Person  = &#123; <span class="comment">// Error</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lolo&quot;</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决上述的问题，我们可以把某个属性声明为可选的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lolo: Person  = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lolo&quot;</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工具类型"><a href="#工具类型" class="headerlink" title="工具类型"></a>工具类型</h3><h4 id="Partial-lt-T-gt"><a href="#Partial-lt-T-gt" class="headerlink" title="Partial&lt;T&gt;"></a><code>Partial&lt;T&gt;</code></h4><p>在实际项目开发过程中，为了提高代码复用率，我们可以利用 TypeScript 内置的工具类型 <code>Partial&lt;T&gt;</code> 来快速<strong>把某个接口类型中定义的属性变成可选的</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PullDownRefreshConfig &#123;</span><br><span class="line">  <span class="attr">threshold</span>: <span class="built_in">number</span>;</span><br><span class="line">  stop: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * type PullDownRefreshOptions = &#123;</span></span><br><span class="line"><span class="comment"> *   threshold?: number | undefined;</span></span><br><span class="line"><span class="comment"> *   stop?: number | undefined;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">type</span> PullDownRefreshOptions = Partial&lt;PullDownRefreshConfig&gt;</span><br></pre></td></tr></table></figure><p>是不是觉得 <code>Partial&lt;T&gt;</code> 很方便，下面让我们来看一下它是如何实现的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make all properties in T optional</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Required-lt-T-gt"><a href="#Required-lt-T-gt" class="headerlink" title="Required&lt;T&gt;"></a><code>Required&lt;T&gt;</code></h4><p>既然可以快速地把某个接口中定义的属性全部声明为可选，那能不能把所有的可选的属性变成必选的呢？答案是可以的，针对这个需求，我们可以使用 <code>Required&lt;T&gt;</code> 工具类型，具体的使用方式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PullDownRefreshConfig &#123;</span><br><span class="line">  <span class="attr">threshold</span>: <span class="built_in">number</span>;</span><br><span class="line">  stop: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PullDownRefreshOptions = Partial&lt;PullDownRefreshConfig&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * type PullDownRefresh = &#123;</span></span><br><span class="line"><span class="comment"> *   threshold: number;</span></span><br><span class="line"><span class="comment"> *   stop: number;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> PullDownRefresh = Required&lt;Partial&lt;PullDownRefreshConfig&gt;&gt;</span><br></pre></td></tr></table></figure><p>同样，我们来看一下 <code>Required&lt;T&gt;</code> 工具类型是如何实现的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make all properties in T required</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原来在 <code>Required&lt;T&gt;</code> 工具类型内部，通过 <code>-?</code> 移除了可选属性中的 <code>?</code>，使得属性从可选变为必选的。</p><h2 id="amp-运算符"><a href="#amp-运算符" class="headerlink" title="&amp; 运算符"></a>&amp; 运算符</h2><p>在 TypeScript 中交叉类型是将多个类型合并为一个类型。通过 <code>&amp;</code> 运算符可以将现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PartialPointX = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">type</span> Point = PartialPointX &amp; &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point: Point = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中我们先定义了 <code>PartialPointX</code> 类型，接着使用 <code>&amp;</code> 运算符创建一个新的 <code>Point</code> 类型，表示一个含有 x 和 y 坐标的点，然后定义了一个 <code>Point</code> 类型的变量并初始化。</p><h3 id="同名基础类型属性的合并"><a href="#同名基础类型属性的合并" class="headerlink" title="同名基础类型属性的合并"></a>同名基础类型属性的合并</h3><p>那么现在问题来了，假设在合并多个类型的过程中，刚好出现某些类型存在相同的成员，但对应的类型又不一致，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> X &#123;</span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">string</span>;</span><br><span class="line">  d: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Y &#123;</span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">number</span>;</span><br><span class="line">  e: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> XY = X &amp; Y;</span><br><span class="line"><span class="keyword">type</span> YX = Y &amp; X;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: XY;</span><br><span class="line"><span class="keyword">let</span> q: YX;</span><br></pre></td></tr></table></figure><p>在上面的代码中，接口 X 和接口 Y 都含有一个相同的成员 c，但它们的类型不一致。对于这种情况，此时 XY 类型或 YX 类型中成员 c 的类型是不是可以是 <code>string</code> 或 <code>number</code> 类型呢？比如下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = &#123; <span class="attr">c</span>: <span class="number">6</span>, <span class="attr">d</span>: <span class="string">&quot;d&quot;</span>, <span class="attr">e</span>: <span class="string">&quot;e&quot;</span> &#125;; <span class="comment">// Type &#x27;number&#x27; is not assignable to type &#x27;never&#x27;. (2322)</span></span><br><span class="line">q = &#123; <span class="attr">c</span>: <span class="string">&quot;c&quot;</span>, <span class="attr">d</span>: <span class="string">&quot;d&quot;</span>, <span class="attr">e</span>: <span class="string">&quot;e&quot;</span> &#125;; <span class="comment">// Type &#x27;string&#x27; is not assignable to type &#x27;never&#x27;. (2322)</span></span><br></pre></td></tr></table></figure><p>为什么接口 X 和接口 Y 混入后，成员 c 的类型会变成 <code>never</code> 呢？这是因为混入后成员 c 的类型为 <code>string &amp; number</code>，即成员 c 的类型既可以是 <code>string</code> 类型又可以是 <code>number</code> 类型。很明显这种类型是不存在的，所以混入后成员 c 的类型为 <code>never</code>。</p><h3 id="同名非基础类型属性的合并"><a href="#同名非基础类型属性的合并" class="headerlink" title="同名非基础类型属性的合并"></a>同名非基础类型属性的合并</h3><p>在上面示例中，刚好接口 X 和接口 Y 中内部成员 c 的类型都是基本数据类型，那么如果是非基本数据类型的话，又会是什么情形。我们来看个具体的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> D &#123; d: <span class="built_in">boolean</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> E &#123; e: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> F &#123; f: <span class="built_in">number</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123; x: D; &#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123; x: E; &#125;</span><br><span class="line"><span class="keyword">interface</span> C &#123; x: F; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ABC = A &amp; B &amp; C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> abc: ABC = &#123;</span><br><span class="line">  <span class="attr">x</span>: &#123;</span><br><span class="line">    <span class="attr">d</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">e</span>: <span class="string">&#x27;semlinker&#x27;</span>,</span><br><span class="line">    <span class="attr">f</span>: <span class="number">666</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abc:&#x27;</span>, abc);</span><br></pre></td></tr></table></figure><p>在混入多个类型时，若存在相同的成员，且成员类型为非基本数据类型，那么是可以成功合并。</p><h2 id="分隔符"><a href="#分隔符" class="headerlink" title="| 分隔符"></a>| 分隔符</h2><p>在 TypeScript 中联合类型（Union Types）表示取值可以为多种类型中的一种，联合类型使用 <code>|</code> 分隔每个类型。</p><p>联合类型通常与 <code>null</code> 或 <code>undefined</code> 一起使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHello = <span class="function">(<span class="params">name: <span class="built_in">string</span> | <span class="literal">undefined</span></span>) =&gt;</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>以上示例中 <code>name</code> 的类型是 <code>string | undefined</code> 意味着可以将 <code>string</code> 或 <code>undefined</code> 的值传递给 <code>sayHello</code> 函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sayHello(<span class="string">&quot;semlinker&quot;</span>);</span><br><span class="line">sayHello(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure><p>此外，对于联合类型来说，你可能会遇到以下的用法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="number">1</span> | <span class="number">2</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">type</span> EventNames = <span class="string">&#x27;click&#x27;</span> | <span class="string">&#x27;scroll&#x27;</span> | <span class="string">&#x27;mousemove&#x27;</span>;</span><br></pre></td></tr></table></figure><p>示例中的 <code>1</code>、<code>2</code> 或 <code>&#39;click&#39;</code> 被称为<strong>字面量类型</strong>，用来约束取值只能是某几个值中的一个。</p><h3 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h3><p>当使用联合类型时，我们必须尽量把当前值的类型收窄为当前值的实际类型，而<strong>类型保护就是实现类型收窄的一种手段</strong>。</p><p>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。</p><p>换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数字。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。</p><p>目前主要有四种的方式来实现类型保护：</p><h4 id="in-关键字"><a href="#in-关键字" class="headerlink" title="in 关键字"></a>in 关键字</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Admin &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  privileges: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Employee &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  startDate: <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UnknownEmployee = Employee | Admin;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printEmployeeInformation</span>(<span class="params">emp: UnknownEmployee</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Name: &quot;</span> + emp.name);</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;privileges&quot;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Privileges: &quot;</span> + emp.privileges);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;startDate&quot;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Start Date: &quot;</span> + emp.startDate);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="typeof-关键字"><a href="#typeof-关键字" class="headerlink" title="typeof 关键字"></a>typeof 关键字</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>) + value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> padding + value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;padding&#125;</span>&#x27;.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typeof</code> 类型保护只支持两种形式：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== typename</code>，<code>&quot;typename&quot;</code> 必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>， <code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。</p><p>但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。</p><h4 id="instanceof-关键字"><a href="#instanceof-关键字" class="headerlink" title="instanceof 关键字"></a>instanceof 关键字</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Padder &#123;</span><br><span class="line">  getPaddingString(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceRepeatingPadder</span> <span class="title">implements</span> <span class="title">Padder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> numSpaces: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">getPaddingString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>(<span class="built_in">this</span>.numSpaces + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringPadder</span> <span class="title">implements</span> <span class="title">Padder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> value: <span class="built_in">string</span></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">getPaddingString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> padder: Padder = <span class="keyword">new</span> SpaceRepeatingPadder(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> SpaceRepeatingPadder) &#123;</span><br><span class="line">  <span class="comment">// padder的类型收窄为 &#x27;SpaceRepeatingPadder&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义类型保护的类型谓词（type-predicate）"><a href="#自定义类型保护的类型谓词（type-predicate）" class="headerlink" title="自定义类型保护的类型谓词（type predicate）"></a>自定义类型保护的类型谓词（type predicate）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&quot;number&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&quot;string&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数字分隔符"><a href="#数字分隔符" class="headerlink" title="_ 数字分隔符"></a>_ 数字分隔符</h2><p>TypeScript 2.7 带来了对数字分隔符的支持，正如数值分隔符 ECMAScript 提案中所概述的那样。</p><p>对于一个数字字面量，你现在可以通过把一个下划线作为它们之间的分隔符来分组数字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inhabitantsOfMunich = <span class="number">1_464_301</span>;</span><br><span class="line"><span class="keyword">const</span> distanceEarthSunInKm = <span class="number">149_600_000</span>;</span><br><span class="line"><span class="keyword">const</span> fileSystemPermission = <span class="number">0b111_111_000</span>;</span><br><span class="line"><span class="keyword">const</span> bytes = <span class="number">0b1111_10101011_11110000_00001101</span>;</span><br></pre></td></tr></table></figure><p>分隔符不会改变数值字面量的值，但逻辑分组使人们更容易一眼就能读懂数字。以上 TS 代码经过编译后，会生成以下 ES5 代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> inhabitantsOfMunich = <span class="number">1464301</span>;</span><br><span class="line"><span class="keyword">var</span> distanceEarthSunInKm = <span class="number">149600000</span>;</span><br><span class="line"><span class="keyword">var</span> fileSystemPermission = <span class="number">504</span>;</span><br><span class="line"><span class="keyword">var</span> bytes = <span class="number">262926349</span>;</span><br></pre></td></tr></table></figure><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><p>虽然数字分隔符看起来很简单，但在使用时还是有一些限制。比如你只能在两个数字之间添加 <code>_</code> 分隔符。以下的使用方式是非法的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Numeric separators are not allowed here.(6188)</span></span><br><span class="line">3_<span class="number">.141592</span> <span class="comment">// Error</span></span><br><span class="line"><span class="number">3.</span>_141592 <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Numeric separators are not allowed here.(6188)</span></span><br><span class="line">1_e10 <span class="comment">// Error</span></span><br><span class="line">1e_10 <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cannot find name &#x27;_126301&#x27;.(2304)</span></span><br><span class="line">_126301  <span class="comment">// Error</span></span><br><span class="line"><span class="comment">// Numeric separators are not allowed here.(6188)</span></span><br><span class="line">126301_ <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cannot find name &#x27;b111111000&#x27;.(2304)</span></span><br><span class="line"><span class="comment">// An identifier or keyword cannot immediately follow a numeric literal.(1351)</span></span><br><span class="line">0_b111111000 <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Numeric separators are not allowed here.(6188)</span></span><br><span class="line">0b_111111000 <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>当然你也不能连续使用多个 <code>_</code> 分隔符，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Multiple consecutive numeric separators are not permitted.(6189)</span></span><br><span class="line">123__456 <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><h3 id="解析分隔符"><a href="#解析分隔符" class="headerlink" title="解析分隔符"></a>解析分隔符</h3><p>此外，需要注意的是以下用于解析数字的函数是不支持分隔符：</p><ul><li><code>Number()</code></li><li><code>parseInt()</code></li><li><code>parseFloat()</code></li></ul><p>这里我们来看一下实际的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;123_456&#x27;</span>)</span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;123_456&#x27;</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;123_456&#x27;</span>)</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>很明显对于以上的结果不是我们所期望的，所以在处理分隔符时要特别注意。当然要解决上述问题，也很简单只需要非数字的字符删掉即可。这里我们来定义一个 <code>removeNonDigits</code> 的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_NON_DIGIT = <span class="regexp">/[^0-9]/gu</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeNonDigits</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(RE_NON_DIGIT, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Number</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数通过调用字符串的 <code>replace</code> 方法来移除非数字的字符，具体的使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">removeNonDigits(<span class="string">&#x27;123_456&#x27;</span>)</span><br><span class="line"><span class="number">123456</span></span><br><span class="line">removeNonDigits(<span class="string">&#x27;149,600,000&#x27;</span>)</span><br><span class="line"><span class="number">149600000</span></span><br><span class="line">removeNonDigits(<span class="string">&#x27;1,407,836&#x27;</span>)</span><br><span class="line"><span class="number">1407836</span></span><br></pre></td></tr></table></figure><h2 id="lt-Type-gt-语法"><a href="#lt-Type-gt-语法" class="headerlink" title="&lt;Type&gt; 语法"></a><code>&lt;Type&gt;</code> 语法</h2><h3 id="TypeScript-断言"><a href="#TypeScript-断言" class="headerlink" title="TypeScript 断言"></a>TypeScript 断言</h3><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。</p><p>类型断言有两种形式：</p><h4 id="“尖括号”-语法"><a href="#“尖括号”-语法" class="headerlink" title="“尖括号” 语法"></a>“尖括号” 语法</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure><h4 id="as-语法"><a href="#as-语法" class="headerlink" title="as 语法"></a>as 语法</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure><h3 id="TypeScript-泛型"><a href="#TypeScript-泛型" class="headerlink" title="TypeScript 泛型"></a>TypeScript 泛型</h3><p>对于刚接触 TypeScript 泛型的读者来说，首次看到 <code>&lt;T&gt;</code> 语法会感到陌生。其实它没有什么特别，就像传递参数一样，我们传递了我们想要用于特定函数调用的类型。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jICi6O"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/17/jICi6O.jpg" alt="jICi6O.jpg"></a></p><p>参考上面的图片，当我们调用 <code>identity&lt;Number&gt;(1)</code> ，<code>Number</code> 类型就像参数 <code>1</code> 一样，它将在出现 <code>T</code> 的任何位置填充该类型。图中 <code>&lt;T&gt;</code> 内部的 <code>T</code> 被称为类型变量，它是我们希望传递给 identity 函数的类型占位符，同时它被分配给 <code>value</code> 参数用来代替它的类型：此时 <code>T</code> 充当的是类型，而不是特定的 Number 类型。</p><p>其中 <code>T</code> 代表 <strong>Type</strong>，在定义泛型时通常用作第一个类型变量名称。</p><p>但实际上 <code>T</code> 可以用任何有效名称代替。除了 <code>T</code> 之外，以下是常见泛型变量代表的意思：</p><ul><li><code>K（Key）</code>：表示对象中的键类型；</li><li><code>V（Value）</code>：表示对象中的值类型；</li><li><code>E（Element）</code>：表示元素类型。</li></ul><p>其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 <code>U</code>，用于扩展我们定义的 <code>identity</code> 函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span> &lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">value: T, message: U</span>) : <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(identity&lt;<span class="built_in">Number</span>, <span class="built_in">string</span>&gt;(<span class="number">68</span>, <span class="string">&quot;Semlinker&quot;</span>));</span><br></pre></td></tr></table></figure><p>除了为类型变量显式设定值之外，一种更常见的做法是使编译器自动选择这些类型，从而使代码更简洁。我们可以完全省略尖括号，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span> &lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">value: T, message: U</span>) : <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(identity(<span class="number">68</span>, <span class="string">&quot;Semlinker&quot;</span>));</span><br></pre></td></tr></table></figure><p>对于上述代码，编译器足够聪明，能够知道我们的参数类型，并将它们赋值给 T 和 U，而不需要开发人员显式指定它们。</p><h2 id="XXX-装饰器"><a href="#XXX-装饰器" class="headerlink" title="@XXX 装饰器"></a>@XXX 装饰器</h2><h3 id="装饰器语法"><a href="#装饰器语法" class="headerlink" title="装饰器语法"></a>装饰器语法</h3><p>对于一些刚接触 TypeScript 的小伙伴来说，在第一次看到 <code>@Plugin(&#123;...&#125;)</code> 这种语法可能会觉得很惊讶。</p><p>其实这是装饰器的语法，装饰器的本质是一个函数，通过装饰器我们可以方便地定义与对象相关的元数据。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Plugin</span>(&#123;</span><br><span class="line">  <span class="attr">pluginName</span>: <span class="string">&#x27;Device&#x27;</span>,</span><br><span class="line">  <span class="attr">plugin</span>: <span class="string">&#x27;cordova-plugin-device&#x27;</span>,</span><br><span class="line">  <span class="attr">pluginRef</span>: <span class="string">&#x27;device&#x27;</span>,</span><br><span class="line">  <span class="attr">repo</span>: <span class="string">&#x27;https://github.com/apache/cordova-plugin-device&#x27;</span>,</span><br><span class="line">  <span class="attr">platforms</span>: [<span class="string">&#x27;Android&#x27;</span>, <span class="string">&#x27;Browser&#x27;</span>, <span class="string">&#x27;iOS&#x27;</span>, <span class="string">&#x27;macOS&#x27;</span>, <span class="string">&#x27;Windows&#x27;</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Device</span> <span class="keyword">extends</span> <span class="title">IonicNativePlugin</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们通过装饰器来保存 ionic-native 插件的相关元信息，而 <code>@Plugin(&#123;...&#125;)</code> 中的 <code>@</code> 符号只是语法糖，为什么说是语法糖呢？这里我们来看一下编译生成的 ES5 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __decorate = (<span class="built_in">this</span> &amp;&amp; <span class="built_in">this</span>.__decorate) || <span class="function"><span class="keyword">function</span> (<span class="params">decorators, target, key, desc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="built_in">arguments</span>.length, r = c &lt; <span class="number">3</span> ? target : desc === <span class="literal">null</span> ? desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key) : desc, d;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Reflect</span> === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Reflect</span>.decorate === <span class="string">&quot;function&quot;</span>) r = <span class="built_in">Reflect</span>.decorate(decorators, target, key, desc);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">var</span> i = decorators.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (d = decorators[i]) r = (c &lt; <span class="number">3</span> ? d(r) : c &gt; <span class="number">3</span> ? d(target, key, r) : d(target, key)) || r;</span><br><span class="line">    <span class="keyword">return</span> c &gt; <span class="number">3</span> &amp;&amp; r &amp;&amp; <span class="built_in">Object</span>.defineProperty(target, key, r), r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Device = <span class="comment">/** <span class="doctag">@class </span>*/</span> (<span class="function"><span class="keyword">function</span> (<span class="params">_super</span>) </span>&#123;</span><br><span class="line">    __extends(Device, _super);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Device</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _super !== <span class="literal">null</span> &amp;&amp; _super.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>) || <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Device = __decorate([</span><br><span class="line">        Plugin(&#123;</span><br><span class="line">            <span class="attr">pluginName</span>: <span class="string">&#x27;Device&#x27;</span>,</span><br><span class="line">            <span class="attr">plugin</span>: <span class="string">&#x27;cordova-plugin-device&#x27;</span>,</span><br><span class="line">            <span class="attr">pluginRef</span>: <span class="string">&#x27;device&#x27;</span>,</span><br><span class="line">            <span class="attr">repo</span>: <span class="string">&#x27;https://github.com/apache/cordova-plugin-device&#x27;</span>,</span><br><span class="line">            <span class="attr">platforms</span>: [<span class="string">&#x27;Android&#x27;</span>, <span class="string">&#x27;Browser&#x27;</span>, <span class="string">&#x27;iOS&#x27;</span>, <span class="string">&#x27;macOS&#x27;</span>, <span class="string">&#x27;Windows&#x27;</span>],</span><br><span class="line">        &#125;),</span><br><span class="line">        Injectable()</span><br><span class="line">    ], Device);</span><br><span class="line">    <span class="keyword">return</span> Device;</span><br><span class="line">&#125;(IonicNativePlugin));</span><br></pre></td></tr></table></figure><p>通过生成的代码可知，<code>@Plugin(&#123;...&#125;)</code> 和 <code>@Injectable()</code> 最终会被转换成普通的方法调用，它们的调用结果最终会以数组的形式作为参数传递给 <code>__decorate</code> 函数，而在 <code>__decorate</code> 函数内部会以 <code>Device</code> 类作为参数调用各自的类型装饰器，从而扩展对应的功能。</p><h3 id="装饰器的分类"><a href="#装饰器的分类" class="headerlink" title="装饰器的分类"></a>装饰器的分类</h3><p>在 TypeScript 中装饰器分为类装饰器、属性装饰器、方法装饰器和参数装饰器四大类。</p><h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h4><p>类装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> ClassDecorator = <span class="xml"><span class="tag">&lt;<span class="name">TFunction</span> <span class="attr">extends</span> <span class="attr">Function</span>&gt;</span>(</span></span><br><span class="line"><span class="xml">  target: TFunction</span></span><br><span class="line"><span class="xml">) =&gt; TFunction | void;</span></span><br></pre></td></tr></table></figure><p>类装饰器顾名思义，就是用来装饰类的。它接收一个参数：</p><ul><li>target: TFunction - 被装饰的类</li></ul><p>看完第一眼后，是不是感觉都不好了。没事，我们马上来个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">target: <span class="built_in">Function</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  target.prototype.greet = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello Semlinker!&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Greeter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 内部实现</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGreeting = <span class="keyword">new</span> Greeting();</span><br><span class="line">myGreeting.greet(); <span class="comment">// console output: &#x27;Hello Semlinker!&#x27;;</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我们定义了 <code>Greeter</code> 类装饰器，同时我们使用了 <code>@Greeter</code> 语法糖，来使用装饰器。</p><blockquote><p>友情提示：读者可以直接复制上面的代码，在 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=dhotVKLs98Gh7cTrCd+/HQ==.AzMIMGaIK4xuV43ZArYSEZujBWurZSjDPmID+PWmBxHpfcREwvRtvBMWAQo8niRz">TypeScript Playground</a> 中运行查看结果。</p></blockquote><h4 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h4><p>属性装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> PropertyDecorator = <span class="function">(<span class="params">target:<span class="built_in">Object</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">  propertyKey: <span class="built_in">string</span> | symbol </span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>属性装饰器顾名思义，用来装饰类的属性。它接收两个参数：</p><ul><li>target: Object - 被装饰的类</li><li>propertyKey: string | symbol - 被装饰类的属性名</li></ul><p>趁热打铁，马上来个例子热热身：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProperty</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">delete</span> target[key];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> backingField = <span class="string">&quot;_&quot;</span> + key;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, backingField, &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// property getter</span></span><br><span class="line">  <span class="keyword">const</span> getter = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">this</span>: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currVal = <span class="built_in">this</span>[backingField];</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Get: <span class="subst">$&#123;key&#125;</span> =&gt; <span class="subst">$&#123;currVal&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> currVal;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// property setter</span></span><br><span class="line">  <span class="keyword">const</span> setter = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">this</span>: <span class="built_in">any</span>, newVal: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Set: <span class="subst">$&#123;key&#125;</span> =&gt; <span class="subst">$&#123;newVal&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">this</span>[backingField] = newVal;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create new property with getter and setter</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: getter,</span><br><span class="line">    <span class="attr">set</span>: setter,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">  <span class="meta">@logProperty</span></span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name : <span class="built_in">string</span></span>)</span> &#123; </span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;semlinker&quot;</span>);</span><br><span class="line">p1.name = <span class="string">&quot;kakuqo&quot;</span>;</span><br></pre></td></tr></table></figure><p>以上代码我们定义了一个 <code>logProperty</code> 函数，来跟踪用户对属性的操作，当代码成功运行后，在控制台会输出以下结果：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set: <span class="function"><span class="params">name</span> =&gt;</span> semlinker</span><br><span class="line">Set: <span class="function"><span class="params">name</span> =&gt;</span> kakuqo</span><br></pre></td></tr></table></figure><h4 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h4><p>方法装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> MethodDecorator = &lt;T&gt;<span class="function">(<span class="params">target:<span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span> | symbol,          </span></span></span><br><span class="line"><span class="params"><span class="function">  descriptor: TypePropertyDescript&lt;T&gt;</span>) =&gt;</span> TypedPropertyDescriptor&lt;T&gt; | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>方法装饰器顾名思义，用来装饰类的方法。它接收三个参数：</p><ul><li>target: Object - 被装饰的类</li><li>propertyKey: string | symbol - 方法名</li><li>descriptor: TypePropertyDescript - 属性描述符</li></ul><p>废话不多说，直接上例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LogOutput</span>(<span class="params">tarage: <span class="built_in">Function</span>, key: <span class="built_in">string</span>, descriptor: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> originalMethod = descriptor.value;</span><br><span class="line">  <span class="keyword">let</span> newMethod = <span class="function"><span class="keyword">function</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: <span class="built_in">any</span> = originalMethod.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.loggedOutput) &#123;</span><br><span class="line">      <span class="built_in">this</span>.loggedOutput = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.loggedOutput.push(&#123;</span><br><span class="line">      <span class="attr">method</span>: key,</span><br><span class="line">      <span class="attr">parameters</span>: args,</span><br><span class="line">      <span class="attr">output</span>: result,</span><br><span class="line">      <span class="attr">timestamp</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">  descriptor.value = newMethod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">  <span class="meta">@LogOutput</span></span><br><span class="line">  double (num: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> calc = <span class="keyword">new</span> Calculator();</span><br><span class="line">calc.double(<span class="number">11</span>);</span><br><span class="line"><span class="comment">// console ouput: [&#123;method: &quot;double&quot;, output: 22, ...&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(calc.loggedOutput); </span><br></pre></td></tr></table></figure><h4 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h4><p>参数装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> ParameterDecorator = <span class="function">(<span class="params">target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span> | symbol, </span></span></span><br><span class="line"><span class="params"><span class="function">  parameterIndex: <span class="built_in">number</span> </span>) =&gt;</span> <span class="built_in">void</span></span><br></pre></td></tr></table></figure><p>参数装饰器顾名思义，是用来装饰函数参数，它接收三个参数：</p><ul><li>target: Object - 被装饰的类</li><li>propertyKey: string | symbol - 方法名</li><li>parameterIndex: number - 方法中参数的索引值</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Log</span>(<span class="params">target: <span class="built_in">Function</span>, key: <span class="built_in">string</span>, parameterIndex: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> functionLogged = key || target.prototype.constructor.name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`The parameter in position <span class="subst">$&#123;parameterIndex&#125;</span> at <span class="subst">$&#123;functionLogged&#125;</span> has</span></span><br><span class="line"><span class="string">    been decorated`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="meta">@Log</span> phrase: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.greeting = phrase; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console output: The parameter in position 0 </span></span><br><span class="line"><span class="comment">// at Greeter has been decorated</span></span><br></pre></td></tr></table></figure><h2 id="XXX-私有字段"><a href="#XXX-私有字段" class="headerlink" title="#XXX 私有字段"></a>#XXX 私有字段</h2><p>在 TypeScript 3.8 版本就开始支持 <strong>ECMAScript 私有字段</strong>，使用方式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  #name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.#name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="built_in">this</span>.#name&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> semlinker = <span class="keyword">new</span> Person(<span class="string">&quot;Semlinker&quot;</span>);</span><br><span class="line"></span><br><span class="line">semlinker.#name;</span><br><span class="line"><span class="comment">//     ~~~~~</span></span><br><span class="line"><span class="comment">// Property &#x27;#name&#x27; is not accessible outside class &#x27;Person&#x27;</span></span><br><span class="line"><span class="comment">// because it has a private identifier.</span></span><br></pre></td></tr></table></figure><p>与常规属性（甚至使用 <code>private</code> 修饰符声明的属性）不同，私有字段要牢记以下规则：</p><ul><li>私有字段以 <code>#</code> 字符开头，有时我们称之为私有名称；</li><li>每个私有字段名称都唯一地限定于其包含的类；</li><li>不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；</li><li>私有字段不能在包含的类之外访问，甚至不能被检测到。</li></ul><h3 id="私有字段与-private-的区别"><a href="#私有字段与-private-的区别" class="headerlink" title="私有字段与 private 的区别"></a>私有字段与 private 的区别</h3><p>说到这里使用 <code>#</code> 定义的私有字段与 <code>private</code> 修饰符定义字段有什么区别呢？现在我们先来看一个 <code>private</code> 的示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;Semlinker&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br></pre></td></tr></table></figure><p>在上面代码中，我们创建了一个 Person 类，该类中使用 <code>private</code> 修饰符定义了一个私有属性 <code>name</code>，接着使用该类创建一个 <code>person</code> 对象，然后通过 <code>person.name</code> 来访问 <code>person</code> 对象的私有属性，这时 TypeScript 编译器会提示以下异常：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Property</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">is</span> <span class="keyword">private</span> <span class="keyword">and</span> only accessible within <span class="keyword">class</span> <span class="string">&#x27;Person&#x27;</span>.(<span class="number">2341</span>)</span><br></pre></td></tr></table></figure><p>那如何解决这个异常呢？当然你可以使用类型断言把 person 转为 any 类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((person <span class="keyword">as</span> any).name);</span><br></pre></td></tr></table></figure><p>通过这种方式虽然解决了 TypeScript 编译器的异常提示，但是在运行时我们还是可以访问到 <code>Person</code> 类内部的私有属性，为什么会这样呢？我们来看一下编译生成的 ES5 代码，也许你就知道答案了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="comment">/** <span class="doctag">@class </span>*/</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Person;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;Semlinker&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br></pre></td></tr></table></figure><p>这时相信有些小伙伴会好奇，在 TypeScript 3.8 以上版本通过 <code>#</code> 号定义的私有字段编译后会生成什么代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  #name: string;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.#name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="built_in">this</span>.#name&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码目标设置为 ES2015，会编译生成以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> __classPrivateFieldSet = (<span class="built_in">this</span> &amp;&amp; <span class="built_in">this</span>.__classPrivateFieldSet) </span><br><span class="line">  || <span class="function"><span class="keyword">function</span> (<span class="params">receiver, privateMap, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!privateMap.has(receiver)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;attempted to set private field on non-instance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    privateMap.set(receiver, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> __classPrivateFieldGet = (<span class="built_in">this</span> &amp;&amp; <span class="built_in">this</span>.__classPrivateFieldGet) </span><br><span class="line">  || <span class="function"><span class="keyword">function</span> (<span class="params">receiver, privateMap</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!privateMap.has(receiver)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;attempted to get private field on non-instance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> privateMap.get(receiver);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _name;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">      _name.set(<span class="built_in">this</span>, <span class="keyword">void</span> <span class="number">0</span>);</span><br><span class="line">      __classPrivateFieldSet(<span class="built_in">this</span>, _name, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Hello, my name is <span class="subst">$&#123;__classPrivateFieldGet(<span class="built_in">this</span>, _name)&#125;</span>!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">_name = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br></pre></td></tr></table></figure><p>通过观察上述代码，使用 <code>#</code> 号定义的 ECMAScript 私有字段，会通过 <code>WeakMap</code> 对象来存储，同时编译器会生成 <code>__classPrivateFieldSet</code> 和 <code>__classPrivateFieldGet</code> 这两个方法用于设置值和获取值。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leslie Waong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesliewaong.top/posts/f0caaae4.html">https://lesliewaong.top/posts/f0caaae4.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lesliewaong.top" target="_blank">Leslie Waong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/TypeScript/">TypeScript</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/14.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/6155a9d6.html"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/13.webp" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Axios</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/a2c0335.html" title="Axios+TS"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-03</div><div class="title">Axios+TS</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Leslie Waong</div><div class="author-info__description">BUPT</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">119</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lesliewaong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lesliewaong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1138964397&amp;website=www.qtxml.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">红雨漂泊泛起了回忆怎么潜</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TS%E4%B8%AD%E9%82%A3%E4%BA%9B%E5%A5%87%E6%80%AA%E7%9A%84%E7%AC%A6%E5%8F%B7"><span class="toc-text">TS中那些奇怪的符号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E7%A9%BA%E6%96%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">! 非空断言操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5-undefined-%E5%92%8C-null-%E7%B1%BB%E5%9E%8B"><span class="toc-text">忽略 undefined 和 null 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E6%97%B6%E5%BF%BD%E7%95%A5-undefined-%E7%B1%BB%E5%9E%8B"><span class="toc-text">调用函数时忽略 undefined 类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">?. 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E7%9A%84%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE"><span class="toc-text">可选的属性访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="toc-text">可选元素访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E9%93%BE%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-text">可选链与函数调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">?? 空值合并运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E8%B7%AF"><span class="toc-text">短路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E4%B8%8E-amp-amp-%E6%88%96-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B1%E7%94%A8"><span class="toc-text">不能与 &amp;&amp; 或 || 操作符共用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%8F%AF%E9%80%89%E9%93%BE%E6%93%8D%E4%BD%9C%E7%AC%A6-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">与可选链操作符 ?. 的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-text">? 可选属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B"><span class="toc-text">工具类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Partial-lt-T-gt"><span class="toc-text">Partial&lt;T&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Required-lt-T-gt"><span class="toc-text">Required&lt;T&gt;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#amp-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">&amp; 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E5%90%8D%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-text">同名基础类型属性的合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E5%90%8D%E9%9D%9E%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-text">同名非基础类型属性的合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%9A%94%E7%AC%A6"><span class="toc-text">| 分隔符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4"><span class="toc-text">类型保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#in-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">in 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">typeof 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceof-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">instanceof 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%B0%93%E8%AF%8D%EF%BC%88type-predicate%EF%BC%89"><span class="toc-text">自定义类型保护的类型谓词（type predicate）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%88%86%E9%9A%94%E7%AC%A6"><span class="toc-text">_ 数字分隔符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6"><span class="toc-text">使用限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%88%86%E9%9A%94%E7%AC%A6"><span class="toc-text">解析分隔符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lt-Type-gt-%E8%AF%AD%E6%B3%95"><span class="toc-text">&lt;Type&gt; 语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeScript-%E6%96%AD%E8%A8%80"><span class="toc-text">TypeScript 断言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C%E5%B0%96%E6%8B%AC%E5%8F%B7%E2%80%9D-%E8%AF%AD%E6%B3%95"><span class="toc-text">“尖括号” 语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#as-%E8%AF%AD%E6%B3%95"><span class="toc-text">as 语法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeScript-%E6%B3%9B%E5%9E%8B"><span class="toc-text">TypeScript 泛型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XXX-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">@XXX 装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%AD%E6%B3%95"><span class="toc-text">装饰器语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">装饰器的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">类装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">属性装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">方法装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">参数装饰器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XXX-%E7%A7%81%E6%9C%89%E5%AD%97%E6%AE%B5"><span class="toc-text">#XXX 私有字段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E5%AD%97%E6%AE%B5%E4%B8%8E-private-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">私有字段与 private 的区别</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/f0caaae4.html" title="TS中那些奇怪的符号"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/14.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="TS中那些奇怪的符号"></a><div class="content"><a class="title" href="/posts/f0caaae4.html" title="TS中那些奇怪的符号">TS中那些奇怪的符号</a><time datetime="2022-07-10T03:12:48.000Z" title="发表于 2022-07-10 11:12:48">2022-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6155a9d6.html" title="Axios"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/13.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="Axios"></a><div class="content"><a class="title" href="/posts/6155a9d6.html" title="Axios">Axios</a><time datetime="2022-07-05T08:42:42.000Z" title="发表于 2022-07-05 16:42:42">2022-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a2c0335.html" title="Axios+TS"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/1.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="Axios+TS"></a><div class="content"><a class="title" href="/posts/a2c0335.html" title="Axios+TS">Axios+TS</a><time datetime="2022-07-03T08:46:47.000Z" title="发表于 2022-07-03 16:46:47">2022-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e8bebe4.html" title="树的相关操作"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/2.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="树的相关操作"></a><div class="content"><a class="title" href="/posts/e8bebe4.html" title="树的相关操作">树的相关操作</a><time datetime="2022-07-03T08:15:52.000Z" title="发表于 2022-07-03 16:15:52">2022-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/92959c23.html" title="文件下载"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/10.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="文件下载"></a><div class="content"><a class="title" href="/posts/92959c23.html" title="文件下载">文件下载</a><time datetime="2022-07-03T03:46:42.000Z" title="发表于 2022-07-03 11:46:42">2022-07-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Leslie Waong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:""},null))},e=()=>{twikoo.getCommentsCount({envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))},n=(n=!1)=>{"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})};btf.loadComment(document.getElementById("twikoo-wrap"),n)})()</script></div><div class="aplayer no-destroy" data-id="6995412795" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="auto" data-autoplay="true" muted></div><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":0,"vOffset":0},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body></html>