<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>异步编程和事件循环 | Leslie Waong</title><meta name="keywords" content="Promise,async,await,setTimeout,回调函数"><meta name="author" content="Leslie Waong"><meta name="copyright" content="Leslie Waong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="异步通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕. 这是令人沮丧的体验，没有充分利用计算机的计算能力 — 尤其是在计算机普遍都有多核CPU的时代，坐在那里等待毫无意义，你完全可以在另一个处理器内核上干其他的工作，同时计算机完成耗时任务的时候通知你。这样你可以同时完成其他工作，这就是"><meta property="og:type" content="article"><meta property="og:title" content="异步编程和事件循环"><meta property="og:url" content="https://lesliewaong.top/posts/ebeefcc9.html"><meta property="og:site_name" content="Leslie Waong"><meta property="og:description" content="异步通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕. 这是令人沮丧的体验，没有充分利用计算机的计算能力 — 尤其是在计算机普遍都有多核CPU的时代，坐在那里等待毫无意义，你完全可以在另一个处理器内核上干其他的工作，同时计算机完成耗时任务的时候通知你。这样你可以同时完成其他工作，这就是"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/5.jpg"><meta property="article:published_time" content="2022-02-27T05:12:12.000Z"><meta property="article:modified_time" content="2022-03-25T14:08:26.424Z"><meta property="article:author" content="Leslie Waong"><meta property="article:tag" content="Promise"><meta property="article:tag" content="async"><meta property="article:tag" content="await"><meta property="article:tag" content="setTimeout"><meta property="article:tag" content="回调函数"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/5.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg"><link rel="canonical" href="https://lesliewaong.top/posts/ebeefcc9"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"一年之内的产物",messageNext:"技术可能存在过期"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Leslie Waong",link:"链接: ",source:"来源: Leslie Waong",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"异步编程和事件循环",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-03-25 22:08:26"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px");const a=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};a(),document.addEventListener("pjax:complete",a)})(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Leslie Waong" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">109</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/5.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leslie Waong</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">异步编程和事件循环</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-27T05:12:12.000Z" title="发表于 2022-02-27 13:12:12">2022-02-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-25T14:08:26.424Z" title="更新于 2022-03-25 22:08:26">2022-03-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JS/">JS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>95分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="异步编程和事件循环"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><p>通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕.</p><p>这是令人沮丧的体验，没有充分利用计算机的计算能力 — 尤其是在计算机普遍都有多核CPU的时代，坐在那里等待毫无意义，你完全可以在另一个处理器内核上干其他的工作，同时计算机完成耗时任务的时候通知你。这样你可以同时完成其他工作，这就是<strong>异步编程</strong>的出发点。你正在使用的编程环境（就web开发而言，编程环境就是web浏览器）负责为你提供异步运行此类任务的API。</p><h2 id="产生阻塞的代码"><a href="#产生阻塞的代码" class="headerlink" title="产生阻塞的代码"></a>产生阻塞的代码</h2><p>异步技术非常有用，特别是在web编程。当浏览器里面的一个web应用进行密集运算还没有把控制权返回给浏览器的时候，整个浏览器就像冻僵了一样，这叫做<strong>阻塞；</strong>这时候浏览器无法继续处理用户的输入并执行其他任务，直到web应用交回处理器的控制。</p><p>为什么是这样? 答案是：JavaScript一般来说是单线程的（<strong>single threaded</strong>）<strong>。</strong>接着我们来介绍<strong>线程</strong>的概念。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>一个<strong>线程</strong>是一个基本的处理过程，程序用它来完成任务。每个线程一次只能执行一个任务:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task A --&gt; Task B --&gt; Task C</span><br></pre></td></tr></table></figure><p>每个任务顺序执行，只有前面的结束了，后面的才能开始。</p><p>正如我们之前所说，现在的计算机大都有多个内核（core），因此可以同时执行多个任务。支持多线程的编程语言可以使用计算机的多个内核，同时完成多个任务:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span>: Task A --&gt; Task B</span><br><span class="line">Thread <span class="number">2</span>: Task C --&gt; Task D</span><br></pre></td></tr></table></figure><h3 id="JavaScript-是单线程的"><a href="#JavaScript-是单线程的" class="headerlink" title="JavaScript 是单线程的"></a>JavaScript 是单线程的</h3><p>JavaScript 传统上是单线程的。即使有多个内核，也只能在单一线程上运行多个任务，此线程称为主线程（<strong>main thread</strong>）。</p><p>经过一段时间，JavaScript获得了一些工具来帮助解决这种问题。通过 <code>Web workers</code>可以把一些任务交给一个名为<code>worker</code>的单独的线程，这样就可以同时运行多个JavaScript代码块。一般来说，用一个worker来运行一个耗时的任务，主线程就可以处理用户的交互（避免了阻塞）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main thread: Task A --&gt; Task C</span><br><span class="line">Worker thread: Expensive task B</span><br></pre></td></tr></table></figure><h2 id="异步代码"><a href="#异步代码" class="headerlink" title="异步代码"></a>异步代码</h2><p>web workers相当有用，但是他们确实也有局限。主要的一个问题是他们<strong>不能访问 DOM— 不能让一个worker直接更新UI</strong>。</p><p>我们不能在worker里面渲染1百万个蓝色圆圈，它基本上只能做算数的苦活。</p><p>其次，虽然在worker里面运行的代码不会产生阻塞，但是<strong>基本上还是同步的</strong>。</p><p>当一个函数依赖于几个在它之前运行的过程的结果，这就会成为问题。考虑下面的情况:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Main thread: Task A --&gt; Task B</span><br></pre></td></tr></table></figure><p>在这种情况下，比如说Task A 正在从服务器上获取一个图片之类的资源，Task B 准备在图片上加一个滤镜。</p><p>如果开始运行Task A 后立即尝试运行Task B，你将会得到一个错误，因为图像还没有获取到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main thread: Task A --&gt; Task B --&gt; |Task D|</span><br><span class="line">Worker thread: Task C -----------&gt; |      |</span><br></pre></td></tr></table></figure><p>在这种情况下，假设Task D 要同时使用 Task B 和Task C的结果，如果我们能保证这两个结果同时提供，程序可能正常运行，但是这不太可能。如果Task D 尝试在其中一个结果尚未可用的情况下就运行，程序就会抛出一个错误。</p><p>为了解决这些问题，浏览器允许我们异步运行某些操作。</p><p>像<code>Promises</code>这样的功能就允许让一些操作运行 (比如：从服务器上获取图片)，然后等待直到结果返回，再运行其他的操作:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main thread: Task A                   Task B</span><br><span class="line">    <span class="attr">Promise</span>:      |__async operation__|</span><br></pre></td></tr></table></figure><p><strong>由于操作发生在其他地方，因此在处理异步操作的时候，主线程不会被阻塞。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>围绕异步编程领域，现代软件设计正在加速旋转，就为了让程序在一个时间内做更多的事情。当你使用更新更强大的API时，你会发现在更多的情况下，使用异步编程是唯一的途径。以前写异步代码很困难，现在也需要你来适应，但是已经变容易了很多。在余下的部分，我们将进一步探讨异步代码的重要性，以及如何设计代码来防止前面已经提到过的问题。</p><h2 id="同步JavaScript"><a href="#同步JavaScript" class="headerlink" title="同步JavaScript"></a>同步JavaScript</h2><p>要理解什么是<strong>异步</strong> JavaScript ，我们应该从确切理解<strong>同步</strong> JavaScript 开始。</p><p>前面学的很多知识基本上都是同步的 — 运行代码，然后浏览器尽快返回结果。先看一个简单的例子 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  alert(<span class="string">&#x27;You clicked me!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pElem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">  pElem.textContent = <span class="string">&#x27;This is a newly-added paragraph.&#x27;</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(pElem);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码, 一行一行的顺序执行：</p><ol><li>先取得一个在DOM里面的 <code>&lt;button&gt;</code>引用。</li><li>点击按钮的时候，添加一个<code>click</code>事件监听器:<ol><li><code>alert()</code> 消息出现。</li><li>一旦alert 结束，创建一个<code>&lt;p&gt;</code>元素。</li><li>给它的文本内容赋值。</li><li>最后，把这个段落放进网页。</li></ol></li></ol><p>每一个操作在执行的时候，其他任何事情都没有发生 — 网页的渲染暂停。</p><p>任何时候只能做一件事情, 只有一个主线程，其他的事情都阻塞了，直到前面的操作完成。</p><p>所以上面的例子，点击了按钮以后，段落不会创建，直到在alert消息框中点击ok，段落才会出现。</p><p><strong>Note</strong>: 这很重要请记住，<code>alert()</code>在演示阻塞效果的时候非常有用，但是在正式代码里面，它就是一个噩梦。</p><h2 id="异步JavaScript"><a href="#异步JavaScript" class="headerlink" title="异步JavaScript"></a>异步JavaScript</h2><p>就前面提到的种种原因（比如，和阻塞相关）很多网页API特性使用异步代码，特别是从外部的设备上获取资源，譬如，从网络获取文件，访问数据库，从网络摄像头获得视频流，或者向VR头罩广播图像。</p><p>为什么使用异步代码这么难？看一个例子，当你从服务器获取一个图像，通常你不可能立马就得到，这需要时间，虽然现在的网络很快。这意味着下面的伪代码可能不能正常工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> response = fetch(<span class="string">&#x27;myImage.png&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> blob = response.blob();</span><br><span class="line"><span class="comment">// display your image blob in the UI somehow</span></span><br></pre></td></tr></table></figure><p>因为你不知道下载图片会多久，所以第二行代码执行的时候可能报错（可能间歇的，也可能每次）因为图像还没有就绪。取代的方法就是，代码必须等到 <code>response</code> 返回才能继续往下执行。</p><p>在JavaScript代码中，你经常会遇到两种异步编程风格：老派callbacks，新派promise。下面就来分别介绍。</p><h2 id="异步callbacks"><a href="#异步callbacks" class="headerlink" title="异步callbacks"></a>异步callbacks</h2><p>异步callbacks 其实就是<strong>函数</strong>，只不过是作为<strong>参数</strong>传递给那些在后台执行的其他函数。 当那些后台运行的代码结束，就调用callbacks函数，通知你工作已经完成，或者其他有趣的事情发生了。使用callbacks 有一点老套，在一些老派但经常使用的API里面，你会经常看到这种风格。</p><p>举个例子，异步callback 就是<code>addEventListener()</code>第二个参数（前面的例子）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  alert(<span class="string">&#x27;You clicked me!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pElem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">  pElem.textContent = <span class="string">&#x27;This is a newly-added paragraph.&#x27;</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(pElem);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第一个参数是侦听的事件类型，第二个就是事件发生时调用的回调函数。.</p><p>当我们把<strong>回调函数作为一个参数传递给另一个函数时，仅仅是把回调函数定义作为参数传递过去</strong> — <strong>回调函数并没有立刻执行，回调函数会在包含它的函数的某个地方异步执行，包含函数负责在合适的时候执行回调函数</strong>。</p><p>你可以自己写一个容易的，包含回调函数的函数。来看另外一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadAsset</span>(<span class="params">url, type, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">  xhr.responseType = type;</span><br><span class="line"></span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(xhr.response);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayImage</span>(<span class="params">blob</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(blob);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadAsset(<span class="string">&#x27;coffee.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>, displayImage);</span><br></pre></td></tr></table></figure><p>创建 <code>displayImage()</code> 函数，简单的把blob传递给它，生成objectURL，然后再生成一个image元素，把objectURL作为image的源地址，最后显示这张图片。 然后，我们创建 <code>loadAsset()</code> 函数，把URL，type，和回调函数同时都作为参数。函数用 <code>XMLHttpRequest</code> (通常缩写 “XHR”) 获取给定URL的资源，在获得资源响应后再把响应作为参数传递给回调函数去处理。 (使用 <code>onload</code> 事件处理) ，有点烧脑，是不是？！</p><p>回调函数用途广泛 — 他们不仅仅可以用来控制函数的执行顺序和函数之间的数据传递，还可以根据环境的不同，将数据传递给不同的函数，所以对下载好的资源，你可以采用不同的操作来处理，譬如 <code>processJSON()</code>, <code>displayText()</code>, 等等。</p><p>请注意，不是所有的回调函数都是异步的 — <strong>有一些是同步的</strong>。一个例子就是使用 <code>Array.prototype.forEach()</code>来遍历数组:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gods = [<span class="string">&#x27;Apollo&#x27;</span>, <span class="string">&#x27;Artemis&#x27;</span>, <span class="string">&#x27;Ares&#x27;</span>, <span class="string">&#x27;Zeus&#x27;</span>];</span><br><span class="line"></span><br><span class="line">gods.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">eachName, index</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index + <span class="string">&#x27;. &#x27;</span> + eachName);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这个例子中，我们遍历一个希腊神的数组，并在控制台中打印索引和值。<code>forEach()</code> 需要的参数是一个回调函数，回调函数本身带有两个参数，数组元素和索引值。它无需等待任何事情，立即运行。</p><h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><p>Promises 是新派的异步代码，现代的web APIs经常用到。 <code>fetch()</code> API就是一个很好的例子, 它基本上就是一个现代版的，更高效的 <code>XMLHttpRequest</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;products.json&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  products = json;</span><br><span class="line">  initialize();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Fetch problem: &#x27;</span> + err.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里<code>fetch()</code> 只需要一个参数— 资源的网络 URL — 返回一个promise。promise 是表示异步操作完成或失败的对象。可以说，它代表了一种中间状态。 本质上，这是浏览器说“我保证尽快给您答复”的方式，因此得名“promise”。</p><p>这个概念需要练习来适应;它感觉有点像运行中的薛定谔猫。这两种可能的结果都还没有发生，因此fetch操作目前正在等待浏览器试图在将来某个时候完成该操作的结果。然后我们有三个代码块链接到fetch()的末尾：</p><ul><li>两个 <code>then()</code> 块。两者都包含一个回调函数，如果前一个操作成功，该函数将运行，并且每个回调都接收前一个成功操作的结果作为输入，因此您可以继续对它执行其他操作。每个 <code>.then()</code>块返回另一个promise，这意味着可以将多个<code>.then()</code>块链接到另一个块上，这样就可以依次执行多个异步操作。</li><li>如果其中任何一个<code>then()</code>块失败，则在末尾运行<code>catch()</code>块——与同步<code>try...catch</code>类似，<code>catch()</code>提供了一个错误对象，可用来报告发生的错误类型。但是请注意，同步<code>try...catch</code>不能与promise一起工作，尽管它可以与<code>async/await</code>一起工作，稍后您将了解到这一点。</li></ul><h3 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h3><p>像promise这样的异步操作被放入事件队列中，事件队列在主线程完成处理后运行，这样它们就不会阻止后续JavaScript代码的运行。排队操作将尽快完成，然后将结果返回到JavaScript环境。</p><h3 id="Promises-对比-callbacks"><a href="#Promises-对比-callbacks" class="headerlink" title="Promises 对比 callbacks"></a>Promises 对比 callbacks</h3><p>promises与旧式callbacks有一些相似之处。它们本质上是一个返回的对象，您可以将回调函数附加到该对象上，而不必将回调作为参数传递给另一个函数。</p><p>然而，<code>Promise</code>是专门为异步操作而设计的，与旧式回调相比具有许多优点:</p><ul><li>您可以<strong>使用多个then()操作将多个异步操作链接在一起，并将其中一个操作的结果作为输入传递给下一个操作</strong>。这种链接方式对回调来说要难得多，会使回调以混乱的“末日金字塔”告终。 (也称为<strong>回调地狱</strong>)。</li><li><code>Promise</code>总是严格按照它们放置在事件队列中的<strong>顺序调用</strong>。</li><li>错误处理要好得多——所有的错误都由块末尾的一个<code>.catch()</code>块处理，而不是在“金字塔”的每一层单独处理。</li></ul><h2 id="异步代码的本质"><a href="#异步代码的本质" class="headerlink" title="异步代码的本质"></a>异步代码的本质</h2><p>让我们研究一个示例，它进一步说明了异步代码的本质，展示了当我们不完全了解代码执行顺序以及将异步代码视为同步代码时可能发生的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log (<span class="string">&#x27;Starting&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> image;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;It worked :)&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> response.blob();</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">myBlob</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;There has been a problem with your fetch operation: &#x27;</span> + error.message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log (<span class="string">&#x27;All done!&#x27;</span>);</span><br></pre></td></tr></table></figure><p>浏览器将会执行代码，看见第一个<code>console.log()</code> 输出(<code>Starting</code>) ，然后创建<code>image</code> 变量。</p><p>然后，它将移动到下一行并开始执行<code>fetch()</code>块，但是，因为<code>fetch()</code>是异步执行的，没有阻塞，所以在<code>promise</code>相关代码之后程序继续执行，从而到达最后的<code>console.log()</code>语句(<code>All done</code>!)并将其输出到控制台。</p><p>只有当<code>fetch()</code> 块完成运行返回结果给<code>.then()</code> ，我们才最后看到第二个<code>console.log()</code> 消息 (<code>It worked ;)</code>) . 所以 这些消息可能以和你预期不同的顺序出现：</p><ul><li><code>Starting</code></li><li><code>All done!</code></li><li><code>It worked :)</code></li></ul><p>如果你感到疑惑，考虑下面这个小例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;registering click handler&quot;</span>);</span><br><span class="line"></span><br><span class="line">button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;get click&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;all done&quot;</span>);</span><br></pre></td></tr></table></figure><p>这在行为上非常相似——第一个和第三个<code>console.log()</code>消息将立即显示，但是第二个消息将被阻塞，直到有人单击鼠标按钮。前面的示例以相同的方式工作，只是在这种情况下，第二个消息在<code>promise</code>链上被阻塞，直到获取资源后再显示在屏幕上，而不是单击。</p><p>将第三个<code>console.log()</code>调用更改为以下命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log (<span class="string">&#x27;All done! &#x27;</span> + image.src + <span class="string">&#x27;displayed.&#x27;</span>);</span><br></pre></td></tr></table></figure><p>此时控制台将会报错，而不会显示第三个 <code>console.log</code> 的信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TypeError</span>: image is <span class="literal">undefined</span>; can<span class="string">&#x27;t access its &quot;src&quot; property</span></span><br></pre></td></tr></table></figure><p>这是因为：浏览器运行第三个<code>console.log()</code>的时候，<code>fetch()</code> 语句块还没有完成，因此<code>image</code>还没有赋值。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在最基本的形式中，<strong>JavaScript是一种同步的、阻塞的、单线程的语言</strong>，在这种语言中，一次只能执行一个操作。但web浏览器定义了函数和API，允许我们当某些事件发生时不是按照同步方式，而是<strong>异步地调用函数</strong>(比如，时间的推移，用户通过鼠标的交互，或者获取网络数据)。这意味着您的代码可以同时做几件事情，而不需要停止或阻塞主线程。</p><p>异步还是同步执行代码，取决于我们要做什么。</p><p>有些时候，我们希望事情能够立即加载并发生。例如，当将一些用户定义的样式应用到一个页面时，您希望这些样式能够尽快被应用。</p><p>但是，如果我们正在运行一个需要时间的操作，比如查询数据库并使用结果填充模板，那么最好将该操作从主线程中移开使用异步完成任务。随着时间的推移，您将了解何时选择异步技术比选择同步技术更有意义。</p><h1 id="setTimeout-amp-setInterval"><a href="#setTimeout-amp-setInterval" class="headerlink" title="setTimeout() &amp; setInterval()"></a>setTimeout() &amp; setInterval()</h1><p>很长一段时间以来，web平台为JavaScript程序员提供了许多函数，这些函数允许您在一段时间间隔过后异步执行代码，或者重复异步执行代码块，直到您告诉它停止为止。这些都是:</p><ul><li><p><code>setTimeout()</code></p><p>在指定的时间后执行一段代码.</p></li><li><p><code>setInterval()</code></p><p>以固定的时间间隔，重复运行一段代码.</p></li><li><p><code>requestAnimationFrame()</code></p><p>setInterval()的现代版本;在浏览器下一次重新绘制显示之前执行指定的代码块，从而允许动画在适当的帧率下运行，而不管它在什么环境中运行.</p></li></ul><p>这些函数设置的异步代码实际上在<strong>主线程</strong>上运行（在其指定的计时器过去之后）。</p><p>在 <code>setTimeout()</code> 调用执行之前或 <code>setInterval()</code> 迭代之间可以（并且经常会）运行其他代码。根据这些操作的处理器密集程度，它们可以进一步延迟异步代码，<strong>因为任何异步代码仅在主线程可用后才执行（换句话说，当调用栈为空时）</strong>。</p><p>无论如何，这些函数用于在web站点或应用程序上运行不间断的动画和其他后台处理。</p><h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h2><p>正如前述， <code>setTimeout()</code> 在指定的时间后执行一段特定代码. 它需要如下参数:</p><ul><li>要运行的函数，或者函数引用。</li><li>表示在执行代码之前等待的时间间隔(以<strong>毫秒</strong>为单位，所以1000等于1秒)的数字。如果指定值为0(或完全省略该值)，函数将<strong>尽快</strong>运行。</li><li>更多的参数：在指定函数运行时，希望传递给函数的值。</li></ul><p><strong>Note:</strong> <strong>指定的时间（或延迟）不能保证在指定的确切时间之后执行，而是最短的延迟执行时间</strong>。<strong>在主线程上的堆栈为空之前，传递给这些函数的回调将无法运行。</strong></p><p>结果，像 <code>setTimeout(fn, 0)</code> 这样的代码将在堆栈为空时立即执行，而不是立即执行。如果执行类似 <code>setTimeout(fn, 0)</code> 之类的代码，之后立即运行从 1 到 100亿 的循环之后，回调将在几秒后执行。</p><p>在下面的示例中，浏览器将在执行匿名函数之前等待两秒钟，然后显示alert消息:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myGreeting = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;Hello, Mr. Universe!&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>我们指定的函数不必是匿名的。我们可以给函数一个名称，甚至可以在其他地方定义它，并将函数引用传递给 <code>setTimeout()</code> 。以下两个版本的代码片段相当于第一个版本:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With a named function</span></span><br><span class="line"><span class="keyword">let</span> myGreeting = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;Hello, Mr. Universe!&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// With a function defined separately</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;Hello Mr. Universe!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGreeting = <span class="built_in">setTimeout</span>(sayHi, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>例如，如果我们有一个函数既需要从超时调用，也需要响应某个事件，那么这将非常有用。此外它也可以帮助保持代码整洁，特别是当超时回调超过几行代码时。</p><p><code>setTimeout()</code> 返回一个标志符变量用来引用这个间隔，可以稍后用来取消这个超时任务。</p><h3 id="传递参数给setTimeout"><a href="#传递参数给setTimeout" class="headerlink" title="传递参数给setTimeout()"></a>传递参数给setTimeout()</h3><p>我们希望传递给<code>setTimeout()</code>中运行的函数的任何参数，都必须作为列表末尾的附加参数传递给它。</p><p>例如，我们可以重构之前的函数，这样无论传递给它的人的名字是什么，它都会向它打招呼：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;Hello &#x27;</span> + who + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>人名可以通过第三个参数传进 <code>setTimeout()</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let myGreeting = setTimeout(sayHi, 2000, &#x27;Mr. Universe&#x27;);</span><br></pre></td></tr></table></figure><h3 id="清除超时"><a href="#清除超时" class="headerlink" title="清除超时"></a>清除超时</h3><p>最后，如果创建了 timeout，您可以通过调用<code>clearTimeout()</code>，将<code>setTimeout()</code>调用的标识符作为参数传递给它，从而在超时运行之前取消。要取消上面的超时，你需要这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clearTimeout</span>(myGreeting);</span><br></pre></td></tr></table></figure><h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h2><p>当我们需要在一段时间之后运行一次代码时，<code>setTimeout()</code>可以很好地工作。但是当我们需要反复运行代码时会发生什么，例如在动画的情况下?</p><p>这就是<code>setInterval()</code>的作用所在。这与<code>setTimeout()</code>的工作方式非常相似，只是作为第一个参数传递给它的函数，<strong>重复</strong>执行的时间不少于第二个参数给出的毫秒数，<strong>而不是一次执行</strong>。您还可以将正在执行的函数所需的任何参数作为 <code>setInterval()</code> 调用的后续参数传递。</p><p>让我们看一个例子。下面的函数创建一个新的<code>Date()</code>对象，使用<code>toLocaleTimeString()</code>从中提取一个时间字符串，然后在UI中显示它。然后，我们使用<code>setInterval()</code>每秒运行该函数一次，创建一个每秒更新一次的数字时钟的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">   <span class="keyword">let</span> time = date.toLocaleTimeString();</span><br><span class="line">   <span class="built_in">document</span>.getElementById(<span class="string">&#x27;demo&#x27;</span>).textContent = time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createClock = <span class="built_in">setInterval</span>(displayTime, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>像<code>setTimeout()</code>一样, <code>setInterval()</code> 返回一个确定的值，稍后你可以用它来<strong>取消间隔任务</strong>。</p><h3 id="清除intervals"><a href="#清除intervals" class="headerlink" title="清除intervals"></a>清除intervals</h3><p><code>setInterval()</code>永远保持运行任务,除非我们做点什么——我们可能会想阻止这样的任务,否则当浏览器无法完成任何进一步的任务时我们可能得到错误, 或者动画处理已经完成了。我们可以用与停止超时相同的方法来实现这一点——通过将<code>setInterval()</code>调用返回的标识符传递给<code>clearInterval()</code>函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myInterval = <span class="built_in">setInterval</span>(myFunction, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">clearInterval</span>(myInterval);</span><br></pre></td></tr></table></figure><h2 id="关于-setTimeout-和-setInterval-需要注意的几点"><a href="#关于-setTimeout-和-setInterval-需要注意的几点" class="headerlink" title="关于 setTimeout() 和 setInterval() 需要注意的几点"></a>关于 setTimeout() 和 setInterval() 需要注意的几点</h2><p>当使用 <code>setTimeout()</code> 和 <code>setInterval()</code>的时候，有几点需要额外注意。 现在让我们回顾一下：</p><h3 id="递归的timeouts"><a href="#递归的timeouts" class="headerlink" title="递归的timeouts"></a>递归的timeouts</h3><p>还有另一种方法可以使用<code>setTimeout()</code>：我们可以递归调用它来重复运行相同的代码，而不是使用<code>setInterval()</code>。</p><p>下面的示例使用递归<code>setTimeout()</code>每100毫秒运行传递来的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">setTimeout</span>(run, <span class="number">100</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>将上面的示例与下面的示例进行比较 ––这使用 <code>setInterval()</code> 来实现相同的效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h4 id="递归setTimeout-和setInterval-有何不同？"><a href="#递归setTimeout-和setInterval-有何不同？" class="headerlink" title="递归setTimeout()和setInterval()有何不同？"></a>递归setTimeout()和setInterval()有何不同？</h4><p>上述代码的两个版本之间的差异是微妙的。</p><ul><li>递归 <code>setTimeout()</code> 保证执行之间的延迟相同，例如在上述情况下为100ms。 代码将运行，然后在它再次运行之前等待100ms，因此无论代码运行多长时间，间隔都是相同的。</li><li>使用 <code>setInterval()</code> 的示例有些不同。 <strong>我们选择的间隔包括执行我们想要运行的代码所花费的时间</strong>。假设代码需要40毫秒才能运行 - 然后间隔最终只有60毫秒。</li><li>当递归使用 <code>setTimeout()</code> 时，每次迭代都可以在运行下一次迭代之前计算不同的延迟。 换句话说，第二个参数的值可以指定在再次运行代码之前等待的不同时间（以毫秒为单位）。</li></ul><p>当你的代码有可能比你分配的时间间隔，花费更长时间运行时，最好使用递归的 <code>setTimeout()</code> - 这将使执行之间的时间间隔保持不变，无论代码执行多长时间，你不会得到错误。</p><h3 id="立即超时"><a href="#立即超时" class="headerlink" title="立即超时"></a>立即超时</h3><p>使用0用作setTimeout()的回调函数会立刻执行，但是在主线程代码运行之后执行。</p><p>举个例子，下面的代码输出一个包含警报的”Hello”，然后在您点击第一个警报的OK之后立即弹出“world”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;World&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&#x27;Hello&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果您希望设置一个代码块以便在所有主线程完成运行后立即运行，这将很有用。将其放在异步事件循环中，这样它将随后直接运行。</p><h3 id="使用-clearTimeout-or-clearInterval-清除"><a href="#使用-clearTimeout-or-clearInterval-清除" class="headerlink" title="使用 clearTimeout() or clearInterval()清除"></a>使用 clearTimeout() or clearInterval()清除</h3><p><code>clearTimeout()</code>和<code>clearInterval()</code>都使用相同的条目列表进行清除。有趣的是，这意味着你可以使用任一一种方法来清除<code>setTimeout()</code>和<code>setInterval()</code>。</p><p>但为了保持一致性，你应该使用 <code>clearTimeout()</code> 来清除 <code>setTimeout()</code> 条目，使用 <code>clearInterval()</code> 来清除 <code>setInterval()</code> 条目。 这样有助于避免混乱。</p><h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame()"></a>requestAnimationFrame()</h2><p><code>requestAnimationFrame()</code> 是一个专门的循环函数，旨在浏览器中高效运行动画。它基本上是现代版本的<code>setInterval()</code> —— 它在浏览器重新加载显示内容之前执行指定的代码块，从而允许动画以适当的帧速率运行，不管其运行的环境如何。</p><p>它是针对<code>setInterval()</code> 遇到的问题创建的，比如 <code>setInterval()</code>并不是针对设备优化的帧率运行，有时会丢帧。还有即使该选项卡不是活动的选项卡或动画滚出页面等问题 。</p><p>该方法将重新加载页面之前要调用的回调函数作为参数。这是您将看到的常见表达：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// Drawing code goes here</span></span><br><span class="line">   requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><p>这个想法是要定义一个函数，在其中更新动画 (例如，移动精灵，更新乐谱，刷新数据等)，然后调用它来开始这个过程。在函数的末尾，以 <code>requestAnimationFrame()</code> 传递的函数作为参数进行调用，这指示浏览器在下一次显示重新绘制时再次调用该函数。然后这个操作连续运行， 因为<code>requestAnimationFrame()</code> 是递归调用的。</p><p><strong>注意</strong>: 如果要执行某种简单的常规DOM动画, <strong>CSS 动画</strong>可能更快，因为它们是由浏览器的内部代码计算而不是JavaScript直接计算的。但是，如果您正在做一些<strong>更复杂</strong>的事情，并且<strong>涉及到在DOM中不能直接访问的对象</strong>, <code>requestAnimationFrame()</code> 在大多数情况下是更好的选择。</p><h3 id="你的动画跑得有多快？"><a href="#你的动画跑得有多快？" class="headerlink" title="你的动画跑得有多快？"></a>你的动画跑得有多快？</h3><p>动画的平滑度直接取决于动画的帧速率，并以每秒帧数（fps）为单位进行测量。这个数字越高，动画看起来就越平滑。</p><p>由于大多数屏幕的刷新率为60Hz，因此在使用web浏览器时，可以达到的最快帧速率是每秒60帧（FPS）。然而，更多的帧意味着更多的处理，这通常会导致卡顿和跳跃-也称为丢帧或跳帧。</p><p>如果您有一个刷新率为60Hz的显示器，并且希望达到60fps，则大约有16.7毫秒（1000/60）来执行动画代码来渲染每个帧。这提醒我们，我们需要注意每次通过动画循环时要运行的代码量。</p><p><code>requestAnimationFrame()</code> 总是试图尽可能接近60帧/秒的值，当然有时这是不可能的如果你有一个非常复杂的动画，你是在一个缓慢的计算机上运行它，你的帧速率将更少。<code>requestAnimationFrame()</code> 会尽其所能利用现有资源提升帧速率。</p><h3 id="requestAnimationFrame-与-setInterval-和-setTimeout-有什么不同"><a href="#requestAnimationFrame-与-setInterval-和-setTimeout-有什么不同" class="headerlink" title="requestAnimationFrame() 与 setInterval() 和 setTimeout()有什么不同?"></a>requestAnimationFrame() 与 setInterval() 和 setTimeout()有什么不同?</h3><p>让我们进一步讨论一下 <code>requestAnimationFrame()</code> 方法与前面介绍的其他方法的区别. 下面让我们看一下代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// Drawing code goes here</span></span><br><span class="line">   requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><p>现在让我们看看如何使用<code>setInterval()</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// Drawing code goes here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(draw, <span class="number">17</span>);</span><br></pre></td></tr></table></figure><p>如前所述，我们没有为<code>requestAnimationFrame()</code>;指定<strong>时间间隔</strong>；它只是在当前条件下尽可能快速平稳地运行它。如果动画由于某些原因而处于屏幕外浏览器也不会浪费时间运行它。</p><p>另一方面<code>setInterval()</code>需要指定间隔。我们通过公式1000毫秒/60Hz得出17的最终值，然后将其四舍五入。四舍五入是一个好主意，浏览器可能会尝试运行动画的速度超过60fps，它不会对动画的平滑度有任何影响。如前所述，60Hz是标准刷新率。</p><h3 id="包括时间戳"><a href="#包括时间戳" class="headerlink" title="包括时间戳"></a>包括时间戳</h3><p>传递给 <code>requestAnimationFrame()</code> 函数的实际回调也可以被赋予一个参数（一个时间戳值），表示自 <code>requestAnimationFrame()</code> 开始运行以来的时间。这是很有用的，因为它允许您在特定的时间以恒定的速度运行，而不管您的设备有多快或多慢。您将使用的一般模式如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> startTime = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!startTime) &#123;</span><br><span class="line">      startTime = timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   currentTime = timestamp - startTime;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do something based on current time</span></span><br><span class="line"></span><br><span class="line">   requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>与<code>setInterval()</code>或<code>setTimeout()</code> 相比最近的浏览器支持<code>requestAnimationFrame()</code></p><p>— <code>requestAnimationFrame()</code>.在Internet Explorer 10及更高版本中可用。因此，除非您的代码需要支持旧版本的IE，否则没有什么理由不使用<code>requestAnimationFrame()</code> 。</p><h3 id="撤销requestAnimationFrame"><a href="#撤销requestAnimationFrame" class="headerlink" title="撤销requestAnimationFrame()"></a>撤销requestAnimationFrame()</h3><p><code>requestAnimationFrame()</code>可用与之对应的<code>cancelAnimationFrame()</code>方法“撤销”。</p><p>该方法以<code>requestAnimationFrame()</code>的返回值为参数，此处我们将该返回值存在变量 <code>rAF</code> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cancelAnimationFrame(rAF);</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>上述这些方法在许多情况下都很有用，但请注意不要过度使用它们！因为它们仍然在<strong>主线程</strong>上运行，所以<strong>繁重的回调（尤其是那些操纵DOM的回调）</strong>会在不注意的情况下降低页面的速度。</p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>本质上，Promise 是一个对象，代表操作的中间状态 —— 正如它的单词含义 ‘承诺’ ，它保证在未来可能返回某种结果。虽然 Promise 并不保证操作在何时完成并返回结果，但是它保证当结果可用时，你的代码能正确处理结果，当结果不可用时，你的代码同样会被执行，来优雅的处理错误。</p><p>通常你不会对一个异步操作从开始执行到返回结果所用的时间感兴趣（除非它耗时过长），你会更想在任何时候都能响应操作结果，当然它不会阻塞其余代码的执行就更好了。</p><p><strong>如果某个业务，依赖于上层业务的数据，上层业务又依赖于更上一层的数据，我们还采用回调的方式来处理异步的话，就会出现回调地狱</strong>。</p><p>在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“<strong>回调地狱</strong>”，而<strong>Promise将回调嵌套改为链式调用，增加可读性和可维护性</strong>。</p><h2 id="回调函数的麻烦"><a href="#回调函数的麻烦" class="headerlink" title="回调函数的麻烦"></a>回调函数的麻烦</h2><p>要完全理解为什么 promise 是一件好事，应该回想之前的回调函数，理解它们造成的困难。</p><p>我们来谈谈订购披萨作为类比。为了使你的订单成功，你必须按顺序执行，<strong>不按顺序执行或上一步没完成就执行下一步是不会成功的</strong>：</p><ol><li>选择配料。如果你是优柔寡断，这可能需要一段时间，如果你无法下定决心或者决定换咖喱，可能会失败。</li><li>下订单。返回比萨饼可能需要一段时间，如果餐厅没有烹饪所需的配料，可能会失败。</li><li>然后你收集你的披萨吃。如果你忘记了自己的钱包，那么这可能会失败，所以无法支付比萨饼的费用！</li></ol><p>对于旧式callbacks，上述功能的伪代码表示可能如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chooseToppings(<span class="function"><span class="keyword">function</span>(<span class="params">toppings</span>) </span>&#123;</span><br><span class="line">  placeOrder(toppings, <span class="function"><span class="keyword">function</span>(<span class="params">order</span>) </span>&#123;</span><br><span class="line">    collectOrder(order, <span class="function"><span class="keyword">function</span>(<span class="params">pizza</span>) </span>&#123;</span><br><span class="line">      eatPizza(pizza);</span><br><span class="line">    &#125;, failureCallback);</span><br><span class="line">  &#125;, failureCallback);</span><br><span class="line">&#125;, failureCallback);</span><br></pre></td></tr></table></figure><p>这很麻烦且难以阅读（通常称为“回调地狱”），需要多次调用<code>failureCallback()</code>（每个嵌套函数一次），还有其他问题。</p><h3 id="使用promise改良"><a href="#使用promise改良" class="headerlink" title="使用promise改良"></a>使用promise改良</h3><p>Promises使得上面的情况更容易编写，解析和运行。如果我们使用异步promises代表上面的伪代码，我们最终会得到这样的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chooseToppings()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">toppings</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> placeOrder(toppings);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">order</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> collectOrder(order);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">pizza</span>) </span>&#123;</span><br><span class="line">  eatPizza(pizza);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(failureCallback);</span><br></pre></td></tr></table></figure><p>这要好得多 - 更容易看到发生了什么，我们只需要一个<code>.catch()</code>块来处理所有错误，它不会阻塞主线程（所以我们可以在等待时继续玩视频游戏为了准备好收集披萨），并保证每个操作在运行之前等待先前的操作完成。我们能够以这种方式一个接一个地链接多个异步操作，因为每个<code>.then()</code>块返回一个新的promise，当<code>.then()</code>块运行完毕时它会解析。聪明，对吗？</p><p>使用箭头函数，你可以进一步简化代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chooseToppings()</span><br><span class="line">.then(<span class="function"><span class="params">toppings</span> =&gt;</span></span><br><span class="line">  placeOrder(toppings)</span><br><span class="line">)</span><br><span class="line">.then(<span class="function"><span class="params">order</span> =&gt;</span></span><br><span class="line">  collectOrder(order)</span><br><span class="line">)</span><br><span class="line">.then(<span class="function"><span class="params">pizza</span> =&gt;</span></span><br><span class="line">  eatPizza(pizza)</span><br><span class="line">)</span><br><span class="line">.catch(failureCallback);</span><br></pre></td></tr></table></figure><p>甚至这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chooseToppings()</span><br><span class="line">.then(<span class="function"><span class="params">toppings</span> =&gt;</span> placeOrder(toppings))</span><br><span class="line">.then(<span class="function"><span class="params">order</span> =&gt;</span> collectOrder(order))</span><br><span class="line">.then(<span class="function"><span class="params">pizza</span> =&gt;</span> eatPizza(pizza))</span><br><span class="line">.catch(failureCallback);</span><br></pre></td></tr></table></figure><p>这是有效的，因为使用箭头函数 <code>() =&gt; x</code> 是 <code>()=&gt; &#123;return x;&#125;</code> 的有效简写; 。</p><p>你甚至可以这样做，<strong>因为函数只是直接传递它们的参数，所以不需要额外的函数层：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chooseToppings().then(placeOrder).then(collectOrder).then(eatPizza).catch(failureCallback);</span><br></pre></td></tr></table></figure><p>但是，<strong>这并不容易阅读，如果你的块比我们在此处显示的更复杂，则此语法可能无法使用。</strong></p><p><strong>注意</strong>: 你可以使用 <code>async/await</code> 语法进行进一步的改进。</p><p>最基本的，promise与事件监听器类似，但有一些差异：</p><ul><li>一个promise<strong>只能成功或失败一次</strong>。它不能成功或失败两次，并且一旦操作完成，它就无法从成功切换到失败，反之亦然。</li><li>如果promise成功或失败并且你稍后添加成功/失败回调，则将调用正确的回调，即使事件发生在较早的时间。</li></ul><h2 id="promise的基本流程"><a href="#promise的基本流程" class="headerlink" title="promise的基本流程"></a>promise的基本流程</h2><p>创建promise时，它既不是成功也不是失败状态。这个状态叫作<strong>pending</strong>（待定）。</p><p>当promise返回时，称为 <strong>resolved</strong>（已解决）。</p><ul><li>一个成功<strong>resolved</strong>的promise称为<strong>fullfilled</strong>（<strong>实现</strong>）。它返回一个值，可以通过将<code>.then()</code>块链接到promise链的末尾来访问该值。<code>.then()</code>块中的执行程序函数将包含promise的返回值。</li><li>一个不成功<strong>resolved</strong>的promise被称为<strong>rejected</strong>（<strong>拒绝</strong>）了。它返回一个原因（<strong>reason</strong>），一条错误消息，说明为什么拒绝promise。可以通过将<code>.catch()</code>块链接到promise链的末尾来访问此原因。</li></ul><p>如果一个 promise 已经被兑现（fulfilled）或被拒绝（rejected），那么我们也可以说它处于<em>已敲定（settled）</em>状态。您还会听到一个经常跟 promise 一起使用的术语：<em>已决议（resolved）</em>，它表示 promise 已经处于已敲定(settled)状态，或者为了匹配另一个 promise 的状态被”锁定”了。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/btof54"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btof54.png" alt="btof54.png"></a></p><h2 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise A+规范"></a>Promise A+规范</h2><p>其实 Promise 有多种规范，除了 Promise A、promise A+ 还有 Promise/B，Promise/D。<strong>目前我们使用的 Promise 是基于 Promise A+ 规范实现的</strong>。</p><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p>很多手写版本都是使用<code>setTimeout</code>去做异步处理，但是 <code>setTimeout</code> 属于<strong>宏任务</strong>，这与Promise 是个<strong>微任务</strong>相矛盾，所以选择一种创建微任务的方式去实现我们的手写代码。</p><p>这里有几种选择，一种就是 Promise A+ 规范中也提到的，<code>process.nextTick</code>（ Node 端 ）与<code>MutationObserver</code>（ 浏览器端 ），考虑到利用这两种方式需要做环境判断，所以在这里我们就推荐另外一种创建微任务的方式 <code>queueMicrotask</code>。</p><h2 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h2><h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><h4 id="原生Promise"><a href="#原生Promise" class="headerlink" title="原生Promise"></a>原生Promise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">   resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">   reject(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;reject&#x27;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 resolve success</span></span><br></pre></td></tr></table></figure><p>Promise 是一个<strong>类</strong>，在执行这个类的时候会传入一个<strong>执行器</strong>，这个执行器会<strong>立即执行</strong></p><p>Promise 会有三种状态</p><ul><li><strong>Pending 等待</strong></li><li><strong>Fulfilled 完成</strong></li><li><strong>Rejected 失败</strong></li></ul><p>状态只能由 <code>Pending --&gt; Fulfilled</code> 或者 <code>Pending --&gt; Rejected</code>，且<strong>一旦发生改变不可二次修改</strong>；</p><p>Promise 中使用 <code>resolve</code> 和 <code>reject</code> 两个函数来更改状态；</p><p><code>then</code> 方法内部做的事情就是<strong>状态判断</strong></p><ul><li>如果状态是成功，调用<strong>成功回调函数</strong></li><li>如果状态是失败，调用<strong>失败回调函数</strong></li></ul><h4 id="新建MyPromise类，传入执行器executor"><a href="#新建MyPromise类，传入执行器executor" class="headerlink" title="新建MyPromise类，传入执行器executor"></a>新建MyPromise类，传入执行器executor</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建 MyPromise.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建 MyPromise 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// executor 是一个执行器，进入会立即执行</span></span><br><span class="line">        executor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="executor-传入-resolve-和-reject-方法"><a href="#executor-传入-resolve-和-reject-方法" class="headerlink" title="executor 传入 resolve 和 reject 方法"></a>executor 传入 resolve 和 reject 方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建 MyPromise.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建 MyPromise 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// resolve和reject为什么要用箭头函数？</span></span><br><span class="line">        <span class="comment">// 如果直接调用的话，普通函数resolve和reject内部this指向的是undefined</span></span><br><span class="line">        <span class="comment">// 用箭头函数就可以让this指向当前实例对象</span></span><br><span class="line">        <span class="comment">// 更改成功后的状态</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更改失败后的状态</span></span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// executor 是一个执行器，进入会立即执行</span></span><br><span class="line">        <span class="comment">// 并传入resolve和reject方法</span></span><br><span class="line">        executor(<span class="built_in">this</span>.resolve,<span class="built_in">this</span>.reject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="状态与结果的管理"><a href="#状态与结果的管理" class="headerlink" title="状态与结果的管理"></a>状态与结果的管理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建 MyPromise.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义三个常量表示状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING=<span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED=<span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED=<span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"><span class="comment">// 新建 MyPromise 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span></span>&#123;</span><br><span class="line">    <span class="comment">// 公共字段存储状态和结果变量</span></span><br><span class="line">    <span class="comment">// 储存状态的变量，初始值是pending</span></span><br><span class="line">    status=PENDING;</span><br><span class="line">    <span class="comment">// 成功之后的值</span></span><br><span class="line">    value=<span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 失败之后的原因</span></span><br><span class="line">    reason=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// resolve和reject为什么要用箭头函数？</span></span><br><span class="line">        <span class="comment">// 如果直接调用的话，普通函数resolve和reject内部this指向的是undefined</span></span><br><span class="line">        <span class="comment">// 用箭头函数就可以让this指向当前实例对象</span></span><br><span class="line">        <span class="comment">// 更改成功后的状态</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.status===PENDING)&#123;</span><br><span class="line">                <span class="built_in">this</span>.status=FULFILLED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">                <span class="built_in">this</span>.value=value;<span class="comment">// 保存成功之后的值</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更改失败后的状态</span></span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.status===PENDING)&#123;</span><br><span class="line">                <span class="built_in">this</span>.status=REJECTED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">                <span class="built_in">this</span>.reason=reason;<span class="comment">// 保存失败后的原因</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// executor 是一个执行器，进入会立即执行</span></span><br><span class="line">        <span class="comment">// 并传入resolve和reject方法</span></span><br><span class="line">        executor(<span class="built_in">this</span>.resolve,<span class="built_in">this</span>.reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="then-的简单实现"><a href="#then-的简单实现" class="headerlink" title="then 的简单实现"></a>then 的简单实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled,onRejected</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断状态</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status===FULFILLED)&#123;</span><br><span class="line">        <span class="comment">// 调用成功回调，并且把值返回</span></span><br><span class="line">        onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.status===REJECTED)&#123;</span><br><span class="line">        <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">        onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用export-对外暴露-MyPromise-类"><a href="#使用export-对外暴露-MyPromise-类" class="headerlink" title="使用export 对外暴露 MyPromise 类"></a>使用export 对外暴露 MyPromise 类</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyPromise.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> MyPromise <span class="keyword">from</span> <span class="string">&quot;./MyPromise.js&quot;</span></span><br><span class="line"><span class="comment">// index.html</span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;./src/index.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="promise类中加入异步逻辑"><a href="#promise类中加入异步逻辑" class="headerlink" title="promise类中加入异步逻辑"></a>promise类中加入异步逻辑</h3><p>上面还没有经过异步处理，如果有异步逻辑加如来会带来一些问题，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MyPromise <span class="keyword">from</span> <span class="string">&quot;./MyPromise.js&quot;</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>); </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;reject&#x27;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有打印信息！！！</span></span><br></pre></td></tr></table></figure><p><strong>分析原因</strong>：</p><blockquote><p>主线程代码立即执行，setTimeout 是异步代码，then 会马上执行，这个时候判断 Promise 状态，状态是 Pending，然而之前并没有判断等待这个状态</p></blockquote><p>这里就需要我们处理一下 Pending 状态，我们改造一下之前的代码</p><h4 id="缓存成功与失败回调"><a href="#缓存成功与失败回调" class="headerlink" title="缓存成功与失败回调"></a>缓存成功与失败回调</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储成功回调函数</span></span><br><span class="line">onFulfilledCallback = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 存储失败回调函数</span></span><br><span class="line">onRejectedCallback = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="then-方法中的-Pending-的处理"><a href="#then-方法中的-Pending-的处理" class="headerlink" title="then 方法中的 Pending 的处理"></a>then 方法中的 Pending 的处理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled,onRejected</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断状态</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status===FULFILLED)&#123;</span><br><span class="line">        <span class="comment">// 调用成功回调，并且把值返回</span></span><br><span class="line">        onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.status===REJECTED)&#123;</span><br><span class="line">        <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">        onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.status===PENDING)&#123;</span><br><span class="line">        <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">        <span class="comment">// 等到执行成功失败函数的时候再传递</span></span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallback=onFulfilled;</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallback=onFulfilled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="resolve-与-reject-中调用回调函数"><a href="#resolve-与-reject-中调用回调函数" class="headerlink" title="resolve 与 reject 中调用回调函数"></a>resolve 与 reject 中调用回调函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更改成功后的状态</span></span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = FULFILLED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">        <span class="built_in">this</span>.value = value;<span class="comment">// 保存成功之后的值</span></span><br><span class="line">        <span class="comment">// 判断成功回调是否存在，如果存在就调用</span></span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallback &amp;&amp; <span class="built_in">this</span>.onFulfilledCallback(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更改失败后的状态</span></span><br><span class="line"><span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = REJECTED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">        <span class="built_in">this</span>.reason = reason;<span class="comment">// 保存失败后的原因</span></span><br><span class="line">        <span class="comment">// 判断失败回调是否存在，如果存在就调用</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallback &amp;&amp; <span class="built_in">this</span>.onRejectedCallback(reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前已经可以简单处理异步问题了</p><h3 id="实现-then-方法多次调用添加多个处理函数"><a href="#实现-then-方法多次调用添加多个处理函数" class="headerlink" title="实现 then 方法多次调用添加多个处理函数"></a>实现 then 方法多次调用添加多个处理函数</h3><blockquote><p>Promise 的 then 方法是可以被多次调用的。这里如果有三个 then 的调用，如果是同步回调，那么直接返回当前的值就行；如果是异步回调，那么保存的成功失败的回调，需要用不同的值保存，因为都互不相同。之前的代码需要改进。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MyPromise <span class="keyword">from</span> <span class="string">&quot;./MyPromise.js&quot;</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>); </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>目前的代码只能输出：<code>3 resolve success</code></p><h4 id="MyPromise-类中新增两个数组"><a href="#MyPromise-类中新增两个数组" class="headerlink" title="MyPromise 类中新增两个数组"></a>MyPromise 类中新增两个数组</h4><p>这里实际是用数组模拟了两个队列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储成功回调函数</span></span><br><span class="line"><span class="comment">// onFulfilledCallback = null;</span></span><br><span class="line">onFulfilledCallbacks = [];</span><br><span class="line"><span class="comment">// 存储失败回调函数</span></span><br><span class="line"><span class="comment">// onRejectedCallback = null;</span></span><br><span class="line">onRejectedCallbacks = [];</span><br></pre></td></tr></table></figure><h4 id="回调函数存入数组中"><a href="#回调函数存入数组中" class="headerlink" title="回调函数存入数组中"></a>回调函数存入数组中</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">        <span class="comment">// 调用成功回调，并且把值返回</span></span><br><span class="line">        onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">        <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">        onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">        <span class="comment">// 等到执行成功失败函数的时候再传递</span></span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallback.push(onFulfilled);</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallback.push(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环调用成功和失败回调"><a href="#循环调用成功和失败回调" class="headerlink" title="循环调用成功和失败回调"></a>循环调用成功和失败回调</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更改成功后的状态</span></span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = FULFILLED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">        <span class="built_in">this</span>.value = value;<span class="comment">// 保存成功之后的值</span></span><br><span class="line">        <span class="comment">// resolve里面将所有成功的回调拿出来执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.onFulfilledCallbacks.length) &#123;</span><br><span class="line">            <span class="comment">// Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空</span></span><br><span class="line">            <span class="built_in">this</span>.onFulfilledCallbacks.shift()(value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更改失败后的状态</span></span><br><span class="line"><span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = REJECTED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">        <span class="built_in">this</span>.reason = reason;<span class="comment">// 保存失败后的原因</span></span><br><span class="line">        <span class="comment">// reject里面将所有失败的回调拿出来执行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">this</span>.onRejectedCallback.length)&#123;</span><br><span class="line">            <span class="built_in">this</span>.onRejectedCallback.shift()(reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来运行一下，看看结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">resolve success</span><br><span class="line"><span class="number">2</span></span><br><span class="line">resolve success</span><br><span class="line"><span class="number">3</span></span><br><span class="line">resolve success</span><br></pre></td></tr></table></figure><h3 id="实现-then-方法的链式调用"><a href="#实现-then-方法的链式调用" class="headerlink" title="实现 then 方法的链式调用"></a>实现 then 方法的链式调用</h3><blockquote><p>then 方法要链式调用那么就需要返回一个 Promise 对象。<br>then 方法里面 return 一个返回值作为下一个 then 方法的参数，如果是 return 一个 Promise 对象，那么就需要判断它的状态。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MyPromise <span class="keyword">from</span> <span class="string">&quot;./MyPromise.js&quot;</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 目前这里只处理同步的问题</span></span><br><span class="line">  resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">other</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;other&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">  <span class="keyword">return</span> other()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之前的手写代码运行的时候会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 为了链式调用这里直接创建一个MyPromise，并在后面return出去</span></span><br><span class="line">    <span class="comment">// promise有暂时性死区，初始化之后才能使用</span></span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的内容在执行器中，会立即执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取成功回调函数的执行结果</span></span><br><span class="line">            <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">            <span class="comment">// 传入 resolvePromise 集中处理</span></span><br><span class="line">            resolvePromise(result, resolve, reject);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">            <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">            onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">            <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">            <span class="comment">// 等到执行成功失败函数的时候再传递</span></span><br><span class="line">            <span class="built_in">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">            <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装一个函数统一处理回调函数的执行结果 </span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">result, resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断result是不是 MyPromise 实例对象</span></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                <span class="comment">// 执行 result，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span></span><br><span class="line">                <span class="comment">// result.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span></span><br><span class="line">                <span class="comment">// 简化之后</span></span><br><span class="line">                result.then(resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 普通值</span></span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下，结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">resolve success</span><br><span class="line"><span class="number">2</span></span><br><span class="line">resolve other</span><br></pre></td></tr></table></figure><h3 id="then-方法链式调用识别-Promise-是否返回自己"><a href="#then-方法链式调用识别-Promise-是否返回自己" class="headerlink" title="then 方法链式调用识别 Promise 是否返回自己"></a>then 方法链式调用识别 Promise 是否返回自己</h3><blockquote><p>如果 then 方法返回的是自己的 Promise 对象，则会发生循环调用，这个时候程序会报错</p></blockquote><p>例如下面这种情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p1 = promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">  <span class="keyword">return</span> p1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用原生 Promise 执行这个代码，会报类型错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line">Uncaught (<span class="keyword">in</span> promise) <span class="built_in">TypeError</span>: Chaining cycle detected <span class="keyword">for</span> promise #&lt;<span class="built_in">Promise</span>&gt;</span><br></pre></td></tr></table></figure><p>修改代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 为了链式调用这里直接创建一个MyPromise，并在后面return出去</span></span><br><span class="line">    <span class="comment">// promise有暂时性死区，初始化之后才能使用</span></span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的内容在执行器中，会立即执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">            <span class="comment">// 创建一个微任务等待 promise 完成初始化</span></span><br><span class="line">            queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 获取成功回调函数的执行结果</span></span><br><span class="line">                <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                <span class="comment">// 传入 resolvePromise 集中处理</span></span><br><span class="line">                resolvePromise(promise, result, resolve, reject);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">            <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">            onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">            <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">            <span class="comment">// 等到执行成功失败函数的时候再传递</span></span><br><span class="line">            <span class="built_in">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">            <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装一个函数统一处理回调函数的执行结果 </span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, result, resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果相等了，说明return的是自己，抛出类型错误并返回</span></span><br><span class="line">            <span class="keyword">if</span> (promise === result) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断result是不是 MyPromise 实例对象</span></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                <span class="comment">// 执行 result，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span></span><br><span class="line">                <span class="comment">// result.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span></span><br><span class="line">                <span class="comment">// 简化之后</span></span><br><span class="line">                result.then(resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 普通值</span></span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这个时候将promise定义一个p1，然后返回的时候返回p1这个promise</span></span><br><span class="line"><span class="keyword">const</span> p1 = promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">   <span class="keyword">return</span> p1</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 运行的时候会走reject</span></span><br><span class="line">p1.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(reason.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里得到我们的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">resolve success</span><br><span class="line"><span class="number">3</span></span><br><span class="line">Chaining cycle detected <span class="keyword">for</span> promise #&lt;<span class="built_in">Promise</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="捕获错误及-then-链式调用其他状态代码补充"><a href="#捕获错误及-then-链式调用其他状态代码补充" class="headerlink" title="捕获错误及 then 链式调用其他状态代码补充"></a>捕获错误及 then 链式调用其他状态代码补充</h3><h4 id="捕获执行器错误"><a href="#捕获执行器错误" class="headerlink" title="捕获执行器错误"></a>捕获执行器错误</h4><blockquote><p>捕获执行器中的代码，如果执行器中有代码错误，那么 Promise 的状态要变为失败</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// executor 是一个执行器，进入会立即执行</span></span><br><span class="line">    <span class="comment">// 并传入resolve和reject方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executor(<span class="built_in">this</span>.resolve, <span class="built_in">this</span>.reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="comment">// 如果有错误，就直接执行reject</span></span><br><span class="line">        <span class="built_in">this</span>.reject(error)</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve(&#x27;success&#x27;)</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;执行器错误&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(reason.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">执行器错误</span><br></pre></td></tr></table></figure><h4 id="then-执行的时错误捕获"><a href="#then-执行的时错误捕获" class="headerlink" title="then 执行的时错误捕获"></a>then 执行的时错误捕获</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 为了链式调用这里直接创建一个MyPromise，并在后面return出去</span></span><br><span class="line">    <span class="comment">// promise有暂时性死区，初始化之后才能使用</span></span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的内容在执行器中，会立即执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">            <span class="comment">// 创建一个微任务等待 promise 完成初始化</span></span><br><span class="line">            queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取成功回调函数的执行结果</span></span><br><span class="line">                    <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                    <span class="comment">// 传入 resolvePromise 集中处理</span></span><br><span class="line">                    resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">            <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">            onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">            <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">            <span class="comment">// 等到执行成功失败函数的时候再传递</span></span><br><span class="line">            <span class="built_in">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">            <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装一个函数统一处理回调函数的执行结果 </span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, result, resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果相等了，说明return的是自己，抛出类型错误并返回</span></span><br><span class="line">            <span class="keyword">if</span> (promise === result) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断result是不是 MyPromise 实例对象</span></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                <span class="comment">// 执行 result，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span></span><br><span class="line">                <span class="comment">// result.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span></span><br><span class="line">                <span class="comment">// 简化之后</span></span><br><span class="line">                result.then(resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 普通值</span></span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">    <span class="comment">// throw new Error(&#x27;执行器错误&#x27;)</span></span><br><span class="line"> &#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第一个then方法中的错误要在第二个then方法中捕获到</span></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;then error&#x27;</span>)</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(reason.message)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(reason.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">resolve success</span><br><span class="line"><span class="number">4</span></span><br><span class="line">then error</span><br></pre></td></tr></table></figure><p>这里成功打印了1中抛出的错误 <code>then error</code></p><h3 id="参考-fulfilled-状态下的处理方式，对-rejected-和-pending-状态进行改造"><a href="#参考-fulfilled-状态下的处理方式，对-rejected-和-pending-状态进行改造" class="headerlink" title="参考 fulfilled 状态下的处理方式，对 rejected 和 pending 状态进行改造"></a>参考 fulfilled 状态下的处理方式，对 rejected 和 pending 状态进行改造</h3><p><strong>改造内容包括：</strong></p><blockquote><ol><li>增加异步状态下的链式调用</li><li>增加回调函数执行结果的判断</li><li>增加识别 Promise 是否返回自己</li><li>增加错误捕获</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 为了链式调用这里直接创建一个MyPromise，并在后面return出去</span></span><br><span class="line">    <span class="comment">// promise有暂时性死区，初始化之后才能使用</span></span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的内容在执行器中，会立即执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">            <span class="comment">// 创建一个微任务等待 promise 完成初始化</span></span><br><span class="line">            queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取成功回调函数的执行结果</span></span><br><span class="line">                    <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                    <span class="comment">// 传入 resolvePromise 集中处理</span></span><br><span class="line">                    resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">            <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">            queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                    resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">            <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">            <span class="comment">// 等到执行成功失败函数的时候再传递</span></span><br><span class="line">            <span class="built_in">this</span>.onFulfilledCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                        resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                        resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装一个函数统一处理回调函数的执行结果 </span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, result, resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果相等了，说明return的是自己，抛出类型错误并返回</span></span><br><span class="line">            <span class="keyword">if</span> (promise === result) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断result是不是 MyPromise 实例对象</span></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                <span class="comment">// 执行 result，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span></span><br><span class="line">                <span class="comment">// result.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span></span><br><span class="line">                <span class="comment">// 简化之后</span></span><br><span class="line">                result.then(resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 普通值</span></span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="then-中的参数变为可选"><a href="#then-中的参数变为可选" class="headerlink" title="then 中的参数变为可选"></a>then 中的参数变为可选</h3><p>上面我们处理 then 方法的时候都是默认传入 onFulfilled、onRejected 两个回调函数，但是实际上原生 Promise 是可以选择参数的单传或者不传，都不会影响执行。</p><p>例如下面这种</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then()</span><br><span class="line">  .then()</span><br><span class="line">  .then()</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure><p>所以我们需要对 then 方法做一点小小的调整</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 如果不传，就使用默认函数</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改造完自然是需要验证一下的</p><p><strong>先看情况一</strong>：resolve 之后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;succ&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">promise.then().then().then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 succ</span></span><br></pre></td></tr></table></figure><p><strong>先看情况一</strong>：reject 之后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">promise.then().then().then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value), <span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(reason))</span><br><span class="line"><span class="comment">// 打印 err</span></span><br></pre></td></tr></table></figure><h3 id="Promise-resolve-amp-Promise-reject"><a href="#Promise-resolve-amp-Promise-reject" class="headerlink" title="Promise.resolve() &amp; Promise.reject()"></a>Promise.resolve() &amp; Promise.reject()</h3><p>就像开头挂的那道面试题使用 <code>return Promise.resolve</code> 来返回一个 Promise 对象，我们用现在的手写代码尝试一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> MyPromise.resolve(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果它报错了 😥</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          ^</span><br><span class="line"></span><br><span class="line"><span class="built_in">TypeError</span>: MyPromise.resolve is not a <span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure><p>除了 Promise.resolve 还有 Promise.reject 的用法，我们都要去支持，接下来我们来实现一下</p><p><code>Promise.resolve(value)</code>方法返回一个以给定值解析后的<code>Promise</code>]对象。</p><ul><li>如果这个值是一个 promise ，那么将返回这个 promise ；</li><li>如果这个值是thenable（即带有<code>&quot;then&quot;</code>方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；(<strong>尚未实现</strong>)</li><li>否则返回的promise将以此值<strong>完成</strong>。</li></ul><p>此函数将类promise对象的多层嵌套展平。</p><p><code>Promise.reject()</code>方法返回一个带有拒绝原因的<code>Promise</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MyPromise &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// resolve 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果这个值是一个 promise ，那么将返回这个 promise </span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则返回的promise将以此值完成。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(value);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reject 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> reject (reason) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><blockquote><p><code>catch()方法</code>返回一个Promise，并且处理拒绝的情况。它的行为与调用Promise.prototype.then(undefined, onRejected) 相同。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line"><span class="keyword">catch</span>(onRejected)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>,onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p><code>Promise.all()</code> 方法接收一个promise的<code>iterable</code>类型（注：<code>Array</code>，<code>Map</code>，<code>Set</code>都属于ES6的iterable类型）的输入，并且<strong>只返回一个Promise实例</strong>， 那个输入的所有promise的resolve回调的结果是一个<strong>数组</strong>。</p><p>这个Promise的resolve回调执行是在<strong>所有输入的promise的resolve回调都结束，或者输入的iterable里没有promise了</strong>的时候。</p><p>它的reject回调执行是，<strong>只要任何一个输入的promise的reject回调执行或者输入不合法的promise就会立即抛出错误，并且reject的是第一个抛出的错误信息</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//all 静态方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;<span class="comment">//记录resolve次数</span></span><br><span class="line">    <span class="keyword">let</span> result = [];<span class="comment">// 输入的所有promise的resolve回调的结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">            MyPromise.resolve(p).then(</span><br><span class="line">                <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                    result[i] = val;</span><br><span class="line">                    <span class="comment">//所有then执行后, resolve结果,结果为一个数组</span></span><br><span class="line">                    <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">                        resolve(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">//有一个Promise被reject时，MyPromise的状态变为reject</span></span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = MyPromise.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MyPromise.all([promise1, promise2, promise3]).then(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// output: Array [3, 42, &quot;foo&quot;]</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">2000</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>, <span class="string">&#x27;three&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">4000</span>, <span class="string">&#x27;four&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p5 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;reject&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MyPromise.all([p1, p2, p3, p4, p5]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//&quot;reject&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p><strong><code>Promise.race(iterable)</code></strong> 方法返回一个 promise，<strong>一旦迭代器中的某个promise解决或拒绝，返回的promise就会解决或拒绝。</strong></p><p>状态只能由 <code>Pending --&gt; Fulfilled</code> 或者 <code>Pending --&gt; Rejected</code>，且<strong>一旦发生改变不可二次修改</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">            <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">            MyPromise.resolve(p).then(resolve,reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([promise1, promise2]).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="comment">// Both resolve, but promise2 is faster</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// expected output: &quot;two&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p><code>finally()</code> 方法返回一个<code>Promise</code>。在promise<strong>结束</strong>时，无论结果是fulfilled或者是rejected，都会执行指定的<strong>回调函数</strong>。</p><p>这为在<code>Promise</code>是否成功完成后都需要执行的代码提供了一种方式。</p><p>这避免了同样的语句需要在<code>then()</code>和<code>catch()</code>中各写一次的情况。</p><p>如果你想在 promise 执行完毕后无论其结果怎样都做一些处理或清理时，<code>finally()</code> 方法可能是有用的。</p><p><code>finally()</code> 虽然与 <code>.then(onFinally, onFinally)</code> 类似，它们不同的是：</p><ul><li>调用内联函数时，不需要多次声明该函数或为该函数创建一个变量保存它。</li><li>由于无法知道<code>promise</code>的最终状态，所以<code>finally</code>的回调函数中不接收任何参数，它仅用于无论最终结果如何都要执行的情况。</li><li>与<code>Promise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)</code> （resolved的结果为<code>undefined</code>）不同，<code>Promise.resolve(2).finally(() =&gt; &#123;&#125;)</code> resolved的结果为 <code>2</code>。</li><li>同样，<code>Promise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)</code> (rejected的结果为<code>undefined</code>), <code>Promise.reject(3).finally(() =&gt; &#123;&#125;)</code> rejected 的结果为 <code>3</code>。</li></ul><p><strong>备注：</strong> 在<code>finally</code>回调中 <code>throw</code>（或返回被拒绝的promise）将以 <code>throw()</code> 指定的原因拒绝新的promise.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//finally方法</span></span><br><span class="line"><span class="function"><span class="title">finally</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">        <span class="comment">// MyPromise.resolve执行回调,并在then中return结果传递给后面的Promise</span></span><br><span class="line">        <span class="function"><span class="params">value</span> =&gt;</span> MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> value),    </span><br><span class="line">        <span class="comment">// reject同理         </span></span><br><span class="line">        <span class="function"><span class="params">reason</span> =&gt;</span> MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)  </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h3><p>该<code>Promise.allSettled()</code>方法返回一个在所有给定的promise都已经<code>fulfilled</code>或<code>rejected</code>后的promise，并带有一个对象数组，每个对象表示对应的promise结果。</p><p>当您有多个<strong>彼此不依赖</strong>的异步任务成功完成时，或者您总是想知道<strong>每个</strong><code>promise</code>的结果时，通常使用它。</p><p>相比之下，<code>Promise.all()</code> 更适合<strong>彼此相互依赖</strong>或者在其中任何一个<code>reject</code>时<strong>立即结束</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//allSettled方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">allSettled</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) <span class="keyword">return</span> MyPromise.resolve([])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = []; <span class="comment">//输入的所有promise的resolve回调的结果</span></span><br><span class="line">        <span class="keyword">let</span> count = promises.length;</span><br><span class="line"></span><br><span class="line">        promises.forEach(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">            MyPromise.resolve(promise).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                result[index] = &#123;</span><br><span class="line">                    <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">                    value</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="comment">// resolve after all are settled</span></span><br><span class="line">                <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                result[index] = &#123;</span><br><span class="line">                    <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">                    reason</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="comment">// resolve after all are settled</span></span><br><span class="line">                <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">100</span>, <span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> promises = [promise1, promise2];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled(promises).</span><br><span class="line">  then(<span class="function">(<span class="params">results</span>) =&gt;</span> results.forEach(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result.status)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// expected output:</span></span><br><span class="line"><span class="comment">// &quot;fulfilled&quot;</span></span><br><span class="line"><span class="comment">// &quot;rejected&quot;</span></span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建 MyPromise.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义三个常量表示状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"><span class="comment">// 新建 MyPromise 类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共字段存储状态和结果变量</span></span><br><span class="line">    <span class="comment">// 储存状态的变量，初始值是pending</span></span><br><span class="line">    status = PENDING;</span><br><span class="line">    <span class="comment">// 成功之后的值</span></span><br><span class="line">    value = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 失败之后的原因</span></span><br><span class="line">    reason = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 存储成功回调函数</span></span><br><span class="line">    onFulfilledCallbacks = [];</span><br><span class="line">    <span class="comment">// 存储失败回调函数</span></span><br><span class="line">    onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// resolve和reject为什么要用箭头函数？</span></span><br><span class="line">        <span class="comment">// 如果直接调用的话，普通函数resolve和reject内部this指向的是undefined</span></span><br><span class="line">        <span class="comment">// 用箭头函数就可以让this指向当前实例对象</span></span><br><span class="line">        <span class="comment">// 更改成功后的状态</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = FULFILLED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">                <span class="built_in">this</span>.value = value;<span class="comment">// 保存成功之后的值</span></span><br><span class="line">                <span class="comment">// resolve里面将所有成功的回调拿出来执行</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">this</span>.onFulfilledCallbacks.length) &#123;</span><br><span class="line">                    <span class="comment">// Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空</span></span><br><span class="line">                    <span class="built_in">this</span>.onFulfilledCallbacks.shift()(value)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更改失败后的状态</span></span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = REJECTED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">                <span class="built_in">this</span>.reason = reason;<span class="comment">// 保存失败后的原因</span></span><br><span class="line">                <span class="comment">// reject里面将所有失败的回调拿出来执行</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">this</span>.onRejectedCallbacks.length) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.onRejectedCallbacks.shift()(reason);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// executor 是一个执行器，进入会立即执行</span></span><br><span class="line">        <span class="comment">// 并传入resolve和reject方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// 如果有错误，就直接执行reject</span></span><br><span class="line">            reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不传，就使用默认函数</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了链式调用这里直接创建一个MyPromise，并在后面return出去</span></span><br><span class="line">        <span class="comment">// promise有暂时性死区，初始化之后才能使用</span></span><br><span class="line">        <span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 这里的内容在执行器中，会立即执行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">                <span class="comment">// 创建一个微任务等待 promise 完成初始化</span></span><br><span class="line">                queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取成功回调函数的执行结果</span></span><br><span class="line">                        <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                        <span class="comment">// 传入 resolvePromise 集中处理</span></span><br><span class="line">                        resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">                <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">                queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                        resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">                <span class="comment">// 等到执行成功失败函数的时候再传递</span></span><br><span class="line">                <span class="built_in">this</span>.onFulfilledCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                            resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                            reject(error);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                            resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                            reject(error);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 封装一个函数统一处理回调函数的执行结果 </span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, result, resolve, reject</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 如果相等了，说明return的是自己，抛出类型错误并返回</span></span><br><span class="line">                <span class="keyword">if</span> (promise === result) &#123;</span><br><span class="line">                    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断result是不是 MyPromise 实例对象</span></span><br><span class="line">                <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                    <span class="comment">// 执行 result，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span></span><br><span class="line">                    <span class="comment">// result.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span></span><br><span class="line">                    <span class="comment">// 简化之后</span></span><br><span class="line">                    result.then(resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 普通值</span></span><br><span class="line">                    resolve(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line">    <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// resolve 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果这个值是一个 promise ，那么将返回这个 promise </span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则返回的promise将以此值完成。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(value);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reject 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//all 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;<span class="comment">//记录resolve次数</span></span><br><span class="line">        <span class="keyword">let</span> result = [];<span class="comment">// 输入的所有promise的resolve回调的结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">                MyPromise.resolve(p).then(</span><br><span class="line">                    <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                        index++;</span><br><span class="line">                        result[i] = val;</span><br><span class="line">                        <span class="comment">//所有then执行后, resolve结果,结果为一个数组</span></span><br><span class="line">                        <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">                            resolve(result);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="comment">//有一个Promise被reject时，MyPromise的状态变为reject</span></span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">                <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">                MyPromise.resolve(p).then(resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//finally方法</span></span><br><span class="line">    <span class="function"><span class="title">finally</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">            <span class="comment">// MyPromise.resolve执行回调,并在then中return结果传递给后面的Promise</span></span><br><span class="line">            <span class="function"><span class="params">value</span> =&gt;</span> MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> value),    </span><br><span class="line">            <span class="comment">// reject同理         </span></span><br><span class="line">            <span class="function"><span class="params">reason</span> =&gt;</span> MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)  </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//allSettled方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">allSettled</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (promises.length === <span class="number">0</span>) <span class="keyword">return</span> MyPromise.resolve([])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = []; <span class="comment">//输入的所有promise的resolve回调的结果</span></span><br><span class="line">            <span class="keyword">let</span> count = promises.length;</span><br><span class="line"></span><br><span class="line">            promises.forEach(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">                MyPromise.resolve(promise).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                    result[index] = &#123;</span><br><span class="line">                        <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">                        value</span><br><span class="line">                    &#125;</span><br><span class="line">                    count--;</span><br><span class="line">                    <span class="comment">// resolve after all are settled</span></span><br><span class="line">                    <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                    result[index] = &#123;</span><br><span class="line">                        <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">                        reason</span><br><span class="line">                    &#125;</span><br><span class="line">                    count--;</span><br><span class="line">                    <span class="comment">// resolve after all are settled</span></span><br><span class="line">                    <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一道面试题"><a href="#一道面试题" class="headerlink" title="一道面试题"></a>一道面试题</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印结果：<strong>0、1、2、3、4、5、6</strong></p><p>这里4怎么跑到3后面去了，不讲武德？ Why……</p><p><strong>Js引擎为了让microtask尽快的输出，做了一些优化，连续的多个then(3个)如果没有reject或者resolve会交替执行then而不至于让一个堵太久完成用户无响应，不单单v8这样其他引擎也是这样，因为其实promuse内部状态已经结束了。这块在v8源码里有完整的体现。</strong></p><h1 id="async-await"><a href="#async-await" class="headerlink" title="async + await"></a>async + await</h1><p><code>async functions</code> 和 <code>await</code> 关键字是最近添加到JavaScript语言里面的。它们是ECMAScript 2017 JavaScript版的一部分。简单来说，它们是基于promises的语法糖，使异步代码更易于编写和阅读。通过使用它们，异步代码看起来更像是老式同步代码，因此它们非常值得学习。</p><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>首先，我们使用 <code>async</code> 关键字，把它放在函数声明之前，使其成为 <code>async function</code>。<strong>异步函数</strong>是一个知道怎样使用 <code>await</code> 关键字调用异步代码的函数。</p><p>尝试在浏览器的JS控制台中键入以下行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure><p>该函数返回“Hello” —— 没什么特别的，对吧？</p><p>如果我们将其变成异步函数呢？请尝试以下方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure><p>哈。现在调用该函数会返回一个 <code>promise</code>。这是异步函数的特征之一 —— <strong>它保证函数的返回值为 promise</strong>。</p><p>你也可以创建一个异步函数表达式，如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure><p>你可以使用箭头函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="keyword">async</span> () =&gt; &#123; <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>这些都基本上是一样的。</p><p>要实际使用promise完成时返回的值，我们可以使用<code>.then()</code>块，因为它返回的是 promise：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello().then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value))</span><br></pre></td></tr></table></figure><p>甚至只是简写如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello().then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure><p>这就像我们在上一篇文章中看到的那样。</p><p>将 <code>async</code> 关键字加到函数申明中，可以告诉它们返回的是 <code>promise</code>，而不是直接返回值。此外，它<strong>避免了同步函数为支持使用 await 带来的任何潜在开销</strong>。在函数声明为 <code>async</code> 时，JavaScript引擎会添加必要的处理，以优化你的程序。爽！</p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>当 <code>await</code>关键字与异步函数一起使用时，它的真正优势就变得明显了 —— 事实上， <strong>await 只在异步函数里面才起作用</strong>。</p><p><strong>它可以放在任何异步的，基于 promise 的函数之前。它会暂停代码在该行上，直到 promise 完成，然后返回结果值</strong>。</p><p><strong>在暂停的同时，其他正在等待执行的代码就有机会执行了。</strong></p><p>您可以在调用任何返回Promise的函数时使用 <strong>await</strong>，包括Web API函数。</p><p>这是一个简单的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> greeting = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">hello().then(alert);</span><br></pre></td></tr></table></figure><h2 id="使用-async-await-重写-promise-代码"><a href="#使用-async-await-重写-promise-代码" class="headerlink" title="使用 async/await 重写 promise 代码"></a>使用 async/await 重写 promise 代码</h2><p>让我们回顾一下我们在上一篇文章中简单的 fetch 示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> response.blob())</span><br><span class="line">.then(<span class="function"><span class="params">myBlob</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;There has been a problem with your fetch operation: &#x27;</span> + e.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>到现在为止，你应该对 promises 及其工作方式有一个较好的理解。让我们将其转换为使用async / await看看它使事情变得简单了多少：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> myBlob = <span class="keyword">await</span> response.blob();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch()</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;There has been a problem with your fetch operation: &#x27;</span> + e.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>它使代码简单多了，更容易理解 —— 去除了到处都是 <code>.then()</code> 代码块！</p><p>由于 <code>async</code> 关键字将函数转换为 promise，您可以重构以上代码 —— 使用 promise 和 await 的混合方式，将函数的后半部分抽取到新代码块中。这样做可以更灵活：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> response.blob();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch().then(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(blob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="它到底是如何工作的？"><a href="#它到底是如何工作的？" class="headerlink" title="它到底是如何工作的？"></a>它到底是如何工作的？</h3><p>您会注意到我们已经将代码封装在函数中，并且我们在 <code>function</code> 关键字之前包含了 <code>async</code> 关键字。这是必要的 –– 您必须创建一个异步函数来定义一个代码块，在其中运行异步代码; await 只能在异步函数内部工作。</p><p>在<code>myFetch()</code>函数定义中，您可以看到代码与先前的 promise 版本非常相似，但存在一些差异。不需要附加 <code>.then()</code> 代码块到每个promise-based方法的结尾，你只需要在方法调用前添加 await 关键字，然后把结果赋给变量。<strong>await 关键字使JavaScript运行时暂停于此行，允许其他代码在此期间执行，直到异步函数调用返回其结果。</strong>一旦完成，您的代码将继续从下一行开始执行。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure><p>解析器会在此行上暂停，直到当服务器返回的响应变得可用时。此时 <code>fetch()</code> 返回的 promise 将会完成（fullfilled），返回的 response 会被赋值给 <code>response</code> 变量。一旦服务器返回的响应可用，解析器就会移动到下一行，从而创建一个<code>Blob</code>。Blob这行也调用基于异步promise的方法，因此我们也在此处使用<code>await</code>。当操作结果返回时，我们将它从<code>myFetch()</code>函数中返回。</p><p>这意味着当我们调用<code>myFetch()</code>函数时，它会返回一个promise，因此我们可以将<code>.then()</code>链接到它的末尾，在其中我们处理显示在屏幕上的<code>blob</code>。</p><p>你可能已经觉得“这真的很酷！”，你是对的 —— 用更少的.<code>then()</code>块来封装代码，同时它看起来很像同步代码，所以它非常直观。</p><h3 id="添加错误处理"><a href="#添加错误处理" class="headerlink" title="添加错误处理"></a>添加错误处理</h3><p>如果你想添加错误处理，你有几个选择。</p><p>您可以将同步的 <code>try...catch</code> 结构和 <code>async/await</code> 一起使用 。此示例扩展了我们上面展示的第一个版本代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> myBlob = <span class="keyword">await</span> response.blob();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">    <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    image.src = objectURL;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch();</span><br></pre></td></tr></table></figure><p><code>catch() &#123;&#125;</code> 代码块会接收一个错误对象 <code>e</code> ; 我们现在可以将其记录到控制台，它将向我们提供详细的错误消息，显示错误被抛出的代码中的位置。</p><p>如果你想使用我们上面展示的第二个（重构）代码版本，你最好继续混合方式并将 <code>.catch()</code> 块链接到 <code>.then()</code> 调用的末尾，就像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> response.blob();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch().then(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(blob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">e</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这是因为 <code>.catch()</code> 块将捕获来自异步函数调用和promise链中的错误。如果您在此处使用了<code>try/catch</code> 代码块，则在调用 <code>myFetch()</code> 函数时，您仍可能会收到未处理的错误。</p><h2 id="等待Promise-all"><a href="#等待Promise-all" class="headerlink" title="等待Promise.all()"></a>等待Promise.all()</h2><p><code>async / await</code> 建立在 promises之上，因此它与promises提供的所有功能兼容。这包括<code>Promise.all()</code> –– 你完全可以通过调用 <code>await</code> <code>Promise.all()</code> 将所有结果返回到变量中，就像同步代码一样。</p><p>将其转换为 async / await，现在看起来像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchAndDecode</span>(<span class="params">url, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> content;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(type === <span class="string">&#x27;blob&#x27;</span>) &#123;</span><br><span class="line">    content = <span class="keyword">await</span> response.blob();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;text&#x27;</span>) &#123;</span><br><span class="line">    content = <span class="keyword">await</span> response.text();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">displayContent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> coffee = fetchAndDecode(<span class="string">&#x27;coffee.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> tea = fetchAndDecode(<span class="string">&#x27;tea.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> description = fetchAndDecode(<span class="string">&#x27;description.txt&#x27;</span>, <span class="string">&#x27;text&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> values = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([coffee, tea, description]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> objectURL1 = URL.createObjectURL(values[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">let</span> objectURL2 = URL.createObjectURL(values[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> descText = values[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> image1 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> image2 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image1.src = objectURL1;</span><br><span class="line">  image2.src = objectURL2;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image1);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> para = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">  para.textContent = descText;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(para);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">displayContent()</span><br><span class="line">.catch(<span class="function">(<span class="params">e</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>可以看到 <code>fetchAndDecode()</code> 函数只进行了一丁点的修改就转换成了异步函数。请看<code>Promise.all()</code> 行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([coffee, tea, description]);</span><br></pre></td></tr></table></figure><p>在这里，通过使用<code>await</code>，我们能够在三个promise的结果都可用的时候，放入<code>values</code>数组中。这看起来非常像同步代码。我们需要将所有代码封装在一个新的异步函数<code>displayContent()</code> 中，尽管没有减少很多代码，但能够将大部分代码从 <code>.then()</code> 代码块移出，使代码得到了简化，更易读。</p><p>为了错误处理，我们在 <code>displayContent()</code> 调用中包含了一个 <code>.catch()</code> 代码块;这将处理两个函数中出现的错误。</p><h2 id="async-await的缺陷"><a href="#async-await的缺陷" class="headerlink" title="async/await的缺陷"></a>async/await的缺陷</h2><p>了解<code>Async/await</code>是非常有用的，但还有一些缺点需要考虑。</p><p><code>Async/await</code> 让你的代码看起来是同步的，在某种程度上，也使得它的行为更加地同步。 <code>await</code> 关键字<strong>会阻塞其后的代码</strong>，直到promise完成，就像执行同步操作一样。<strong>它确实可以允许其他任务在此期间继续运行，但您自己的代码被阻塞。</strong></p><p>这意味着您的代码可能会因为大量<code>await</code>的promises相继发生而变慢。每个<code>await</code>都会等待前一个完成，而你实际想要的是所有的这些promises同时开始处理（就像我们没有使用<code>async/await</code>时那样）。</p><p>有一种模式可以缓解这个问题——通过将 <code>Promise</code> 对象存储在变量中来同时开始它们，然后等待它们全部执行完毕。让我们看一些证明这个概念的例子。</p><p>我们有两个可用的例子 —— <a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/asynchronous/async-await/slow-async-await.html">slow-async-await.html</a>和<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/asynchronous/async-await/fast-async-await.html">fast-async-await.html</a>。它们都以自定义promise函数开始，该函数使用<code>setTimeout()</code> 调用伪造异步进程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">    &#125;, interval);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后每个包含一个 <code>timeTest()</code> 异步函数，等待三个 <code>timeoutPromise()</code> 调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个都以记录开始时间结束，查看 <code>timeTest()</code> promise 需要多长时间才能完成，然后记录结束时间并报告操作总共需要多长时间：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line">timeTest().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> finishTime = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">let</span> timeTaken = finishTime - startTime;</span><br><span class="line">  alert(<span class="string">&quot;Time taken in milliseconds: &quot;</span> + timeTaken);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>timeTest()</code> 函数在每种情况下都不同。</p><p>在<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/asynchronous/async-await/slow-async-await.html">slow-async-await.html</a>示例中，<code>timeTest()</code> 如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeoutPromise(<span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">await</span> timeoutPromise(<span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">await</span> timeoutPromise(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们直接等待所有三个timeoutPromise（）调用，使每个调用3秒钟。后续的每一个都被迫等到最后一个完成 - 如果你运行第一个例子，你会看到弹出框报告的总运行时间大约为9秒。</p><p>在<a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/javascript/asynchronous/async-await/fast-async-await.html">fast-async-await.html</a>示例中，<code>timeTest()</code> 如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> timeoutPromise1 = timeoutPromise(<span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">const</span> timeoutPromise2 = timeoutPromise(<span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">const</span> timeoutPromise3 = timeoutPromise(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> timeoutPromise1;</span><br><span class="line">  <span class="keyword">await</span> timeoutPromise2;</span><br><span class="line">  <span class="keyword">await</span> timeoutPromise3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<strong>我们将三个Promise对象存储在变量中，这样可以同时启动它们关联的进程。</strong></p><p>接下来，我们等待他们的结果 - 因为promise都在基本上同时开始处理，promise将同时完成;当您运行第二个示例时，您将看到弹出框报告总运行时间仅超过3秒！</p><p>您必须仔细测试您的代码，并在性能开始受损时牢记这一点。</p><p>另一个小小的不便是你必须将等待执行的promise封装在异步函数中。</p><h2 id="Async-await-的类方法"><a href="#Async-await-的类方法" class="headerlink" title="Async/await 的类方法"></a>Async/await 的类方法</h2><p>最后值得一提的是，我们可以在类/对象方法前面添加<code>async</code>，以使它们返回promises，并<code>await</code>它们内部的promises。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">first, last, age, gender, interests</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = &#123;</span><br><span class="line">      first,</span><br><span class="line">      last</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    <span class="built_in">this</span>.interests = interests;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">greeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">`Hi! I&#x27;m <span class="subst">$&#123;<span class="built_in">this</span>.name.first&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">farewell</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name.first&#125;</span> has left the building. Bye for now!`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> han = <span class="keyword">new</span> Person(<span class="string">&#x27;Han&#x27;</span>, <span class="string">&#x27;Solo&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;male&#x27;</span>, [<span class="string">&#x27;Smuggling&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>第一个实例方法可以使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">han.greeting().then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><h1 id="选择正确的方法"><a href="#选择正确的方法" class="headerlink" title="选择正确的方法"></a>选择正确的方法</h1><h2 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h2><p>通常在旧式API中找到，涉及将函数作为参数传递给另一个函数，然后在异步操作完成时调用该函数，以便回调可以依次对结果执行某些操作。这是promise的前身;它不那么高效或灵活。仅在必要时使用。</p><p>通过<code>XMLHttpRequest</code> API加载资源的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadAsset</span>(<span class="params">url, type, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">  xhr.responseType = type;</span><br><span class="line"></span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(xhr.response);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayImage</span>(<span class="params">blob</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(blob);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadAsset(<span class="string">&#x27;coffee.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>, displayImage);</span><br></pre></td></tr></table></figure><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>嵌套回调可能很麻烦且难以阅读（即“<strong>回调地狱</strong>”）</li><li>每层嵌套都需要故障回调，而使用promises，您只需使用一个<code>.catch（）</code>代码块来处理整个链的错误。</li><li>异步回调<strong>不是很优雅</strong>。</li><li>Promise回调总是按照它们<strong>放在事件队列中的严格顺序调用</strong>;<strong>异步回调不是</strong>。</li><li>当传入到一个<strong>第三方库</strong>时，异步回调对函数如何执行<strong>失去完全控制</strong>。</li></ul><h2 id="setTimeout-1"><a href="#setTimeout-1" class="headerlink" title="setTimeout()"></a>setTimeout()</h2><p><code>setTimeout()</code> 是一种允许您在经过任意时间后运行函数的方法</p><p>这里浏览器将在执行匿名函数之前等待两秒钟，然后将显示警报消息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myGreeting = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;Hello, Mr. Universe!&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><h3 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h3><p>您可以使用递归的<code>setTimeout（）</code>调用以类似于<code>setInterval（）</code>的方式重复运行函数，使用如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(run, <span class="number">100</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>递归<code>setTimeout（）</code>和<code>setInterval（）</code>之间存在差异：</p><ul><li>递归<code>setTimeout（）</code>保证两次执行间经过指定的时间量（在本例中为100ms）;代码将运行，然后等待100毫秒再次运行。无论代码运行多长时间，间隔都是相同的。</li><li>使用<code>setInterval（）</code>，我们选择的时间间隔包含了运行代码所花费的时间。（还是100ms为例）假设代码需要40毫秒才能运行 –– 间隔最终只会有60毫秒。</li></ul><p>当你的代码有可能比你分配的时间间隔更长时间运行时，最好使用递归的<code>setTimeout（）</code> ––这将使执行之间的时间间隔保持不变，无论代码执行多长时间，你不会得到错误。</p><h2 id="setInterval-1"><a href="#setInterval-1" class="headerlink" title="setInterval()"></a>setInterval()</h2><p><code>setInterval()</code>函数允许重复执行一个函数，并设置时间间隔。不如<code>requestAnimationFrame()</code>有效率，但允许您选择运行速率/帧速率。</p><p>以下函数创建一个新的<code>Date()</code>对象，使用<code>toLocaleTimeString()</code>从中提取时间字符串，然后在UI中显示它。然后我们使用<code>setInterval（）</code>每秒运行一次，创建每秒更新一次的数字时钟的效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">   <span class="keyword">let</span> time = date.toLocaleTimeString();</span><br><span class="line">   <span class="built_in">document</span>.getElementById(<span class="string">&#x27;demo&#x27;</span>).textContent = time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createClock = <span class="built_in">setInterval</span>(displayTime, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h3 id="缺陷-2"><a href="#缺陷-2" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>帧速率未针对运行动画的系统进行优化，并且可能效率低下。除非您需要选择特定（较慢）的帧速率，否则通常最好使用<code>requestAnimationFrame()</code>.</li></ul><h2 id="requestAnimationFrame-1"><a href="#requestAnimationFrame-1" class="headerlink" title="requestAnimationFrame()"></a>requestAnimationFrame()</h2><p><code>requestAnimationFrame()</code>是一种<strong>允许您以给定当前浏览器/系统的最佳帧速率重复且高效地运行函数</strong>的方法。除非您需要特定的速率帧，否则您应该尽可能使用它而不要去使用<code>setInterval()/recursive setTimeout()</code>。</p><p>一个简单的动画旋转器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spinner = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> rotateCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> startTime = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> rAF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!startTime) &#123;</span><br><span class="line">    startTime = timestamp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> rotateCount = (timestamp - startTime) / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  spinner.style.transform = <span class="string">&#x27;rotate(&#x27;</span> + rotateCount + <span class="string">&#x27;deg)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(rotateCount &gt; <span class="number">359</span>) &#123;</span><br><span class="line">    rotateCount = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rAF = requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><h3 id="缺陷-3"><a href="#缺陷-3" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>您无法使用<code>requestAnimationFrame（）</code>选择特定的帧速率。如果需要以较慢的帧速率运行动画，则需要使用<code>setInterval（）</code>或递归的<code>setTimeout（）</code>。</li></ul><h2 id="Promises-1"><a href="#Promises-1" class="headerlink" title="Promises"></a>Promises</h2><p>Promises是一种<strong>JavaScript功能</strong>，允许您<strong>运行异步操作并等到它完全完成后再根据其结果运行另一个操作</strong>。</p><p>Promise是<strong>现代异步JavaScript的支柱</strong>。</p><p>以下代码从服务器获取图像并将其显示在<code>&lt;img&gt;</code>元素中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> response.blob())</span><br><span class="line">.then(<span class="function"><span class="params">myBlob</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;There has been a problem with your fetch operation: &#x27;</span> + e.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="缺陷-4"><a href="#缺陷-4" class="headerlink" title="缺陷"></a>缺陷</h3><p><strong>Promise链可能很复杂，难以解析。</strong>如果你嵌套了许多promises，你最终可能会遇到类似的麻烦来回调地狱。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">remotedb.allDocs(&#123;</span><br><span class="line">  <span class="attr">include_docs</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">attachments</span>: <span class="literal">true</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> docs = result.rows;</span><br><span class="line">  docs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    localdb.put(element.doc).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      alert(<span class="string">&quot;Pulled doc with id &quot;</span> + element.doc._id + <span class="string">&quot; and added to local db.&quot;</span>);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err.name == <span class="string">&#x27;conflict&#x27;</span>) &#123;</span><br><span class="line">        localdb.get(element.doc._id).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line">          localdb.remove(resp._id, resp._rev).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line"><span class="comment">// et cetera...</span></span><br></pre></td></tr></table></figure><p>最好使用promises的链功能，这样使用更平顺，更易于解析的结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">remotedb.allDocs(...).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfAllDocs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfPut</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.get(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfGet</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>乃至：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">remotedb.allDocs(...)</span><br><span class="line">.then(<span class="function"><span class="params">resultOfAllDocs</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">resultOfPut</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.get(...);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">resultOfGet</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure><h2 id="Promise-all-1"><a href="#Promise-all-1" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>一种JavaScript功能，允许您<strong>等待多个promises完成，然后根据所有其他promises的结果运行进一步的操作。</strong></p><p>以下示例从服务器获取多个资源，并使用<code>Promise.all（）</code>等待所有资源可用，然后显示所有这些资源：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchAndDecode</span>(<span class="params">url, type</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Returning the top level promise, so the result of the entire chain is returned out of the function</span></span><br><span class="line">  <span class="keyword">return</span> fetch(url).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Depending on what type of file is being fetched, use the relevant function to decode its contents</span></span><br><span class="line">    <span class="keyword">if</span>(type === <span class="string">&#x27;blob&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> response.blob();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;text&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> response.text();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`There has been a problem with your fetch operation for resource &quot;<span class="subst">$&#123;url&#125;</span>&quot;: `</span> + e.message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the fetchAndDecode() method to fetch the images and the text, and store their promises in variables</span></span><br><span class="line"><span class="keyword">let</span> coffee = fetchAndDecode(<span class="string">&#x27;coffee.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> tea = fetchAndDecode(<span class="string">&#x27;tea.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> description = fetchAndDecode(<span class="string">&#x27;description.txt&#x27;</span>, <span class="string">&#x27;text&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use Promise.all() to run code only when all three function calls have resolved</span></span><br><span class="line"><span class="built_in">Promise</span>.all([coffee, tea, description]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">  <span class="comment">// Store each value returned from the promises in separate variables; create object URLs from the blobs</span></span><br><span class="line">  <span class="keyword">let</span> objectURL1 = URL.createObjectURL(values[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">let</span> objectURL2 = URL.createObjectURL(values[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> descText = values[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Display the images in &lt;img&gt; elements</span></span><br><span class="line">  <span class="keyword">let</span> image1 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> image2 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image1.src = objectURL1;</span><br><span class="line">  image2.src = objectURL2;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image1);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Display the text in a paragraph</span></span><br><span class="line">  <span class="keyword">let</span> para = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">  para.textContent = descText;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(para);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="缺陷-5"><a href="#缺陷-5" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>如果<code>Promise.all（）</code>拒绝，那么你在其数组参数中输入的一个或多个promise(s)就会被拒绝，或者可能根本不返回promises。你需要检查每一个，看看他们返回了什么。</li></ul><h2 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h2><p><strong>构造在promises之上的语法糖，允许您使用更像编写同步回调代码的语法来运行异步操作。</strong></p><p>以下示例是我们之前看到的简单承诺示例的重构，该示例获取并显示图像，使用async / await编写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> myBlob = <span class="keyword">await</span> response.blob();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch();</span><br></pre></td></tr></table></figure><h3 id="缺陷-6"><a href="#缺陷-6" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>您不能在非<code>async</code>函数内或代码的顶级上下文环境中使用<code>await</code>运算符。这有时会导致需要创建额外的函数封包，这在某些情况下会略微令人沮丧。但大部分时间都值得。</li><li>浏览器对async / await的支持不如promises那样好。如果你想使用async / await但是担心旧的浏览器支持，你可以考虑使用BabelJS库 - 这允许你使用最新的JavaScript编写应用程序，让Babel找出用户浏览器需要的更改。</li></ul><h1 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h1><p>我们都知道 Js 是单线程的，但是一些高耗时操作就带来了进程阻塞问题。</p><p>为了解决这个问题，Js 有两种任务的执行模式：<strong>同步模式（Synchronous）和异步模式（Asynchronous）</strong>。</p><h2 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h2><p>在异步模式下，创建<strong>异步任务主要分为宏任务与微任务两种</strong>。</p><p>ES6 规范中，宏任务（Macrotask） 称为 Task， 微任务（Microtask） 称为 Jobs。</p><p>宏任务是由宿主（浏览器、Node）发起的，而微任务由 JS 自身发起。</p><p><strong>宏任务与微任务的几种创建方式</strong></p><table><thead><tr><th>宏任务（Macrotask）</th><th>微任务（Microtask）</th></tr></thead><tbody><tr><td>setTimeout</td><td>requestAnimationFrame（有争议）</td></tr><tr><td>setInterval</td><td>MutationObserver（浏览器环境）</td></tr><tr><td>MessageChannel</td><td>Promise.[ then/catch/finally ]</td></tr><tr><td>I/O，事件队列</td><td>process.nextTick（Node环境）</td></tr><tr><td>setImmediate（Node环境）</td><td>queueMicrotask</td></tr><tr><td>script（整体代码块）</td><td></td></tr></tbody></table><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bt7ZTO"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/bt7ZTO.png" alt="bt7ZTO.png"></a></p><ol><li>判断宏任务队列是否为空<ul><li>不空 –&gt; 执行最早进入队列的任务 –&gt; 执行下一步</li><li>空 –&gt; 执行下一步</li></ul></li><li>判断微任务队列是否为空<ul><li>不空 –&gt; 执行最早进入队列的任务 –&gt; <strong>继续检查微任务队列空不空</strong></li><li>空 –&gt; 执行下一步</li></ul></li></ol><p><strong>如何理解 script（整体代码块）是个宏任务呢</strong></p><p>实际上如果同时存在两个 script 代码块，会首先在执行<strong>第一个 script 代码块中的同步代码</strong>，如果这个过程中创建了微任务并进入了微任务队列，第一个 script 同步代码执行完之后，会首先去<strong>清空微任务队列</strong>，再去开启<strong>第二个 script 代码块</strong>的执行。所以这里应该就可以理解 script（整体代码块）为什么会是宏任务。</p><p>因为首次执行宏队列中会有 script（整体代码块）任务，所以实际上就是 Js 解析完成后，在异步任务中，会<strong>先执行完所有的微任务</strong>，这里也是很多面试题喜欢考察的。需要注意的是，新创建的微任务会立即进入微任务队列排队执行，不需要等待下一次轮回。</p><p>所谓任务，浅显来说就是<strong>代码块开始执行的入口</strong>(确切地说，是函数栈的入口，但是栈的概念较为复杂，不表)。而在 <code>JS</code> 里，除了“<code>script</code>整体代码块”之外，<strong>所有代码块的入口都是“*回调函数*”</strong>，回调函数被注册到事件后不会马上被执行，而是保存在一个神秘的的地方，保存起来待执行的才能算“任务”，然后才有宏/微任务之分。</p><p>“<code>script</code>整体代码块”的特殊之处，在于<strong>它的入口不是回调函数</strong>，但是我们可以想象它被装在一个隐形的函数里，作为回调函数被注册到某个事件里（大概是它解析完成之后会触发的一个事件），这时候这个隐形的函数就成为了一个任务。</p><p>总的来说就是，宏任务作为主导，它有支配微任务的能力，在一个宏任务任务消灭之前，它会让它创建的微任务任务都执行完，然后才进入下一个宏任务任务。</p><p>然后，入栈出栈，这个另一个概念，是每个任务执行它的代码的时候发生的，比如变量定义，函数调用，通过栈的入出，计算出结果。</p><blockquote><p>补充</p></blockquote><p><strong>计算机中的同步</strong>是连续性的动作，上一步未完成前，下一步会发生堵塞，直至上一步完成后，下一步才可以继续执行。</p><p><code>JavaScript</code>的确是一门单线程语言，但是浏览器<code>UI</code>是多线程的，异步任务借助浏览器的线程和<code>JavaScript</code>的执行机制实现。 例如，<code>setTimeout</code>就借助浏览器定时器触发线程的计时功能来实现。</p><h2 id="JavaScript-执行上下文"><a href="#JavaScript-执行上下文" class="headerlink" title="JavaScript 执行上下文"></a>JavaScript 执行上下文</h2><p>当一段 JavaScript 代码在运行的时候，它实际上是运行在<strong>执行上下文</strong>中。下面3种类型的代码会创建一个新的执行上下文：</p><ul><li><strong>全局上下文</strong>是为运行<strong>代码主体</strong>而创建的执行上下文，也就是说它是为那些<strong>存在于JavaScript 函数之外的任何代码而创建的</strong>。</li><li>每个<strong>函数</strong>会在执行的时候创建自己的执行上下文。这个上下文就是通常说的 “<strong>本地/局部上下文</strong>（local context）”。</li><li>使用 <code>eval()</code>函数也会创建一个新的执行上下文。</li></ul><p>每一个上下文在本质上都是一种<strong>作用域</strong>层级。每个代码段开始执行的时候都会创建一个新的上下文来运行它，并且在代码退出的时候销毁掉。看看下面这段 JavaScript 程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outputElem = <span class="built_in">document</span>.getElementById(<span class="string">&quot;output&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userLanguages = &#123;</span><br><span class="line">  <span class="string">&quot;Mike&quot;</span>: <span class="string">&quot;en&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Teresa&quot;</span>: <span class="string">&quot;es&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greetUser</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">localGreeting</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> greeting;</span><br><span class="line">    <span class="keyword">let</span> language = userLanguages[user];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(language) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;es&quot;</span>:</span><br><span class="line">        greeting = <span class="string">`¡Hola, <span class="subst">$&#123;user&#125;</span>!`</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;en&quot;</span>:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        greeting = <span class="string">`Hello, <span class="subst">$&#123;user&#125;</span>!`</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> greeting;</span><br><span class="line">  &#125;</span><br><span class="line">  outputElem.innerHTML += localGreeting(user) + <span class="string">&quot;&lt;br&gt;\r&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greetUser(<span class="string">&quot;Mike&quot;</span>);</span><br><span class="line">greetUser(<span class="string">&quot;Teresa&quot;</span>);</span><br><span class="line">greetUser(<span class="string">&quot;Veronica&quot;</span>);</span><br></pre></td></tr></table></figure><p>这段程序代码包含了三个执行上下文，其中有些会在程序运行的过程中多次创建和销毁。每个上下文创建的时候会被推入<strong>执行上下文栈</strong>。当退出的时候，它会从上下文栈中移除。</p><ul><li>程序开始运行时，<strong>全局上下文</strong>就会被创建好。<ul><li>当执行到 <code>greetUser(&quot;Mike&quot;)</code>的时候会为 <code>greetUser()</code>函数创建一个它的上下文。这个执行上下文会被推入执行上下文栈中。<ul><li>当 <code>greetUser()</code> 调用 <code>localGreeting()</code>的时候会为该方法创建一个新的上下文。并且在 <code>localGreeting()</code> 退出的时候它的上下文也会从执行栈中弹出并销毁。 程序会从栈中获取下一个上下文并恢复执行, 也就是从<code>greetUser()</code> 剩下的部分开始执行。</li><li><code>greetUser()</code> 执行完毕并退出，其上下文也从栈中弹出并销毁。</li></ul></li><li>当 <code>greetUser(&quot;Teresa&quot;)</code>开始执行时，程序又会为它创建一个上下文并推入栈顶。<ul><li>当 <code>greetUser()</code> 调用 <code>localGreeting()</code>的时候另一个上下文被创建并用于运行该函数。 当 <code>localGreeting()</code> 退出的时候它的上下文也从栈中弹出并销毁。 <code>greetUser()</code> 得到恢复并继续执行剩下的部分。</li><li><code>greetUser()</code> 执行完毕并退出，其上下文也从栈中弹出并销毁。</li></ul></li><li>然后执行到 <code>greetUser(&quot;Veronica&quot;)</code>又再为它创建一个上下文并推入栈顶。<ul><li>当 <code>greetUser()</code> 调用 <code>localGreeting()</code>的时候，另一个上下文被创建用于执行该函数。当 <code>localGreeting()</code>执行完毕，它的上下文也从栈中弹出并销毁。</li><li><code>greetUser()</code> 执行完毕退出，其上下文也从栈中弹出并销毁。</li></ul></li></ul></li><li>主程序退出，全局执行上下文从执行栈中弹出。此时栈中所有的上下文都已经弹出，程序执行完毕。</li></ul><p>以这种方式来使用执行上下文，使得<strong>每个程序和函数都能够拥有自己的变量和其他对象</strong>。</p><p>每个上下文还能够额外的跟踪程序中下一行需要执行的代码以及一些对上下文非常重要的信息。</p><p>以这种方式来使用上下文和上下文栈，使得我们可以对程序运行的一些基础部分进行管理，包括局部和全局变量、函数的调用与返回等。</p><p>关于递归函数——即多次调用自身的函数，需要特别注意：<strong>每次递归调用自身都会创建一个新的上下文</strong>。</p><p>这使得 JavaScript 运行时能够<strong>追踪递归的层级以及从递归中得到的返回值，但这也意味着每次递归都会消耗内存来创建新的上下文</strong>。</p><h2 id="JavaScript运行时"><a href="#JavaScript运行时" class="headerlink" title="JavaScript运行时"></a>JavaScript运行时</h2><p>在执行 JavaScript 代码的时候，JavaScript 运行时实际上维护了一组用于执行 JavaScript 代码的<strong>代理</strong>。</p><p>每个代理由<strong>一组执行上下文的集合、执行上下文栈、主线程、一组可能创建用于执行 worker 的额外的线程集合、一个任务队列以及一个微任务队列</strong>构成。</p><p>除了主线程（某些浏览器在多个代理之间共享的主线程）之外，其它组成部分对该代理都是唯一的。</p><h3 id="事件循环（Event-loops）"><a href="#事件循环（Event-loops）" class="headerlink" title="事件循环（Event loops）"></a>事件循环（Event loops）</h3><p>每个代理都是由<strong>事件循环</strong>驱动的，事件循环负责收集事件（包括用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。然后它执行所有处于等待中的 JavaScript 任务（宏任务），然后是微任务，然后在开始下一次循环之前执行一些必要的渲染和绘制操作。</p><p>网页或者 app 的代码和浏览器本身的用户界面程序运行在相同的<strong>线程</strong>中， 共享相同的 <strong>事件循环</strong>。 该线程就是<strong>主线程</strong>，它除了运行网页本身的代码之外，还负责收集和派发用户和其它事件，以及渲染和绘制网页内容等。</p><p>然后，事件循环会驱动发生在浏览器中与用户交互有关的一切，但在这里，对我们来说更重要的是需要了解它是如何负责调度和执行在其线程中执行的每段代码的。</p><p>有如下三种事件循环:</p><ul><li><p>Window 事件循环</p><p>window 事件循环驱动所有同源的窗口。</p></li><li><p>Worker 事件循环</p><p>worker 事件循环顾名思义就是驱动 worker 的事件循环。这包括了所有种类的 worker：最基本的 web worker以及 shared worker 和 service worker。 Worker 被放在一个或多个独立于 “主代码” 的代理中。浏览器可能会用单个或多个事件循环来处理给定类型的所有 worker。</p></li><li><p>Worklet 事件循环</p><p>worklet事件循环用于驱动运行 worklet 的代理。这包含了 <code>Worklet</code> 、<code>AudioWorklet</code> 以及 <code>PaintWorklet</code>。</p></li></ul><p>多个同源（译者注：此处同源的源应该不是指同源策略中的源，而是指由同一个窗口打开的多个子窗口或同一个窗口中的多个 iframe 等，意味着起源的意思，下一段内容就会对这里进行说明）窗口可能运行在相同的事件循环中，每个队列任务进入到事件循环中以便处理器能够轮流对它们进行处理。记住这里的网络术语 “window” 实际上指的用于运行网页内容的浏览器级容器，包括实际的 window，一个 tab 标签或者一个 frame。</p><p>在特定情况下，同源窗口之间共享事件循环，例如：</p><ul><li>如果一个窗口打开了另一个窗口，它们可能会共享一个事件循环。</li><li>如果窗口是包含在 <code>&lt;iframe&gt;</code>中，则它可能会和包含它的窗口共享一个事件循环。</li><li>在多进程浏览器中多个窗口碰巧共享了同一个进程。</li></ul><p>这种特定情况依赖于浏览器的具体实现，各个浏览器可能并不一样。</p><h4 id="任务-vs-微任务"><a href="#任务-vs-微任务" class="headerlink" title="任务 vs 微任务"></a>任务 vs 微任务</h4><p>一个<strong>任务</strong>就是指计划由标准机制来执行的任何 JavaScript，如程序的初始化、事件触发的回调等。 除了使用事件，你还可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout"><code>setTimeout()</code></a> 或者 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/setInterval"><code>setInterval()</code></a> 来添加任务。</p><p>任务队列和微任务队列的区别很简单，但却很重要：</p><ul><li>当执行来自任务队列中的任务时，在每一次新的事件循环开始迭代的时候运行时都会执行队列中的每个任务。在每次迭代开始之后加入到队列中的任务需要<strong>在下一次迭代开始之后才会被执行</strong>.</li><li><strong>每次当一个任务退出且执行上下文为空的时候，微任务队列中的每一个微任务会依次被执行。</strong>不同的是它会等到微任务队列为空才会停止执行——即使中途有微任务加入。换句话说，<strong>微任务可以添加新的微任务到队列中，并在下一个任务开始执行之前且当前事件循环结束之前执行完所有的微任务。</strong></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>由于你的代码和浏览器的用户界面运行在同一个线程中，共享同一个事件循环，假如你的代码阻塞了或者进入了无限循环，则浏览器将会卡死。无论是由于 bug 引起还是代码中进行复杂的运算导致的性能降低，都会降低用户的体验。</p><p>当来自多个程序的多个代码对象尝试同时运行的时候，一切都可能变得很慢甚至被阻塞，更不要说浏览器还需要时间来渲染和绘制网站和 UI、处理用户事件等。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用 <code>web workers</code>可以让主线程另起新的线程来运行脚本，这能够缓解上面的情况。一个设计良好的网站或应用会把一些复杂的或者耗时的操作交给 worker 去做，这样可以让主线程除了更新、布局和渲染网页之外，尽可能少的去做其他事情。</p><p>通过使用像 <code>promises</code>这样的<code>异步JavaScript技术</code>可以<strong>使得主线程在等待请求返回结果的同时继续往下执行，这能够更进一步减轻上面提到的情况。</strong>然而，一些更接近于基础功能的代码——比如一些框架代码，可能更需要将代码安排在主线程上一个安全的时间来运行，它与任何请求的结果或者任务无关。</p><p><strong>微任务</strong>是另一种解决该问题的方案，<strong>通过将代码安排在下一次事件循环开始之前运行而不是必须要等到下一次开始之后才执行，这样可以提供一个更好的访问级别。</strong></p><p>微任务队列已经存在有一段时间了，但之前它仅仅被内部使用来驱动诸如 promise 这些。<code>queueMicrotask()</code>的加入可以让开发者创建一个统一的微任务队列，<strong>它能够在任何时候即便是当 JavaScript 执行上下文栈中没有执行上下文剩余时也可以将代码安排在一个安全的时间运行。</strong> 在多个实例、所有浏览器以及运行时中，一个标准的微任务队列机制意味着这些微任务可以非常可靠的以相同的顺序执行，从而避免一些潜在的难以发现的错误。</p><h2 id="queueMicrotask"><a href="#queueMicrotask" class="headerlink" title="queueMicrotask"></a>queueMicrotask</h2><p>可以安全的引入微任务而避免使用额外的技巧。</p><p>通过引入 <code>queueMicrotask()</code>，由晦涩地使用 promise 去创建微任务而带来的风险就可以被避免了。举例来说，当使用 promise 创建微任务时，由回调抛出的异常被报告为 rejected promises 而不是标准异常。同时，创建和销毁 promise 带来了事件和内存方面的额外开销，这是正确入列微任务的函数应该避免的。</p><p>简单的传入一个 JavaScript <code>Function</code> ，以在 <code>queueMicrotask()</code> 方法中处理微任务时供其上下文调用即可；取决于当前执行上下文， <code>queueMicrotask()</code> 以定义的形式被暴露在 <code>Window</code>或 <code>Worker</code>接口上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 微任务中将运行的代码 */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>微任务函数本身没有参数，也不返回值。</p><h3 id="何时使用微任务"><a href="#何时使用微任务" class="headerlink" title="何时使用微任务"></a>何时使用微任务</h3><p>我们来看看微任务特别有用的场景。通常，这些场景关乎捕捉或检查结果、执行清理等；其时机晚于一段 JavaScript 执行上下文主体的退出，但早于任何事件处理函数、timeouts 或 intervals 及其他回调被执行。</p><p>何时是那种有用的时候？</p><p>使用微任务的最主要原因简单归纳为：<strong>确保任务顺序的一致性，即便当结果或数据是同步可用的，也要同时减少操作中用户可感知到的延迟而带来的风险。</strong></p><h4 id="保证条件性使用-promises-时的顺序"><a href="#保证条件性使用-promises-时的顺序" class="headerlink" title="保证条件性使用 promises 时的顺序"></a>保证条件性使用 promises 时的顺序</h4><p>微任务可被用来确保执行顺序总是一致的一种情形，是当 promise 被用在一个 <code>if...else</code> 语句（或其他条件性语句）中、但并不在其他子句中的时候。考虑如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">customElement.prototype.getData = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.cache[url]) &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = <span class="built_in">this</span>.cache[url];</span><br><span class="line">    <span class="built_in">this</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">&quot;load&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fetch(url).then(<span class="function"><span class="params">result</span> =&gt;</span> result.arrayBuffer()).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.cache[url] = data;</span><br><span class="line">      <span class="built_in">this</span>.data = data;</span><br><span class="line">      <span class="built_in">this</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">&quot;load&quot;</span>));</span><br><span class="line">    )&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码带来的问题是，通过在 <code>if...else</code> 语句的其中一个分支（此例中为缓存中的图片地址可用时）中使用一个任务而 promise 包含在 <code>else</code> 子句中，我们面临了操作顺序可能不同的局势；比方说，像下面看起来的这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Loaded data&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Fetching data...&quot;</span>);</span><br><span class="line">element.getData();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Data fetched&quot;</span>);</span><br></pre></td></tr></table></figure><p>连续执行两次这段代码会形成下表中的结果：</p><table><thead><tr><th align="left">数据未缓存</th><th align="left">数据已缓存</th></tr></thead><tbody><tr><td align="left"><code>Fetching data Data fetched Loaded data</code></td><td align="left"><code>Fetching data Loaded data Data fetched</code></td></tr></tbody></table><p>甚至更糟的是，有时元素的 <code>data</code>属性会被设置，还有时当这段代码结束运行时却不会被设置。</p><p>我们可以通过在 <code>if</code> 子句里使用一个微任务来确保操作顺序的一致性，以达到平衡两个子句的目的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">customElement.prototype.getData = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.cache[url]) &#123;</span><br><span class="line">    queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.data = <span class="built_in">this</span>.cache[url];</span><br><span class="line">      <span class="built_in">this</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">&quot;load&quot;</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fetch(url).then(<span class="function"><span class="params">result</span> =&gt;</span> result.arrayBuffer()).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.cache[url] = data;</span><br><span class="line">      <span class="built_in">this</span>.data = data;</span><br><span class="line">      <span class="built_in">this</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">&quot;load&quot;</span>));</span><br><span class="line">    )&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过在两种情况下各自都通过一个微任务（<code>if</code> 中用的是 <code>queueMicrotask()</code> 而 <code>else</code> 子句中通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch"><code>fetch()</code></a> 使用了 promise）处理了设置 <code>data</code> 和触发 <code>load</code> 事件，平衡了两个子句。</p><h4 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h4><p>也可以使用微任务从不同来源将多个请求收集到单一的批处理中，从而避免对处理同类工作的多次调用可能造成的开销。</p><p>下面的代码片段创建了一个函数，将多个消息放入一个数组中批处理，通过一个微任务在上下文退出时将这些消息作为单一的对象发送出去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> messageQueue = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sendMessage = <span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">  messageQueue.push(message);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (messageQueue.length === <span class="number">1</span>) &#123;</span><br><span class="line">    queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> json = <span class="built_in">JSON</span>.stringify(messageQueue);</span><br><span class="line">      messageQueue.length = <span class="number">0</span>;</span><br><span class="line">      fetch(<span class="string">&quot;url-of-receiver&quot;</span>, json);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当 <code>sendMessage()</code>被调用时，指定的消息首先被推入消息队列数组。接着事情就变得有趣了。</p><p>如果我们刚加入数组的消息是第一条，就入列一个将会发送一个批处理的微任务。照旧，当 JavaScript 执行路径到达顶层，恰在运行回调之前，那个微任务将会执行。这意味着之后的间歇期内造成的对 <code>sendMessage()</code> 的任何调用都会将其各自的消息推入消息队列，但囿于入列微任务逻辑之前的数组长度检查，不会有新的微任务入列。</p><p>当微任务运行之时，等待它处理的可能是一个有若干条消息的数组。微任务函数先是通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify()</code></a> 方法将消息数组编码为 JSON。其后，数组中的内容就不再需要了，所以清空 <code>messageQueue</code> 数组。最后，使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch"><code>fetch()</code></a> 方法将编码后的 JSON 发往服务器。</p><p>这使得同一次事件循环迭代期间发生的每次 <code>sendMessage()</code> 调用将其消息添加到同一个 <code>fetch()</code> 操作中，而不会让诸如 timeouts 等其他可能的定时任务推迟传递。</p><p>服务器将接到 JSON 字符串，然后大概会将其解码并处理其从结果数组中找到的消息。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leslie Waong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesliewaong.top/posts/ebeefcc9.html">https://lesliewaong.top/posts/ebeefcc9.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lesliewaong.top" target="_blank">Leslie Waong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Promise/">Promise</a><a class="post-meta__tags" href="/tags/async/">async</a><a class="post-meta__tags" href="/tags/await/">await</a><a class="post-meta__tags" href="/tags/setTimeout/">setTimeout</a><a class="post-meta__tags" href="/tags/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/">回调函数</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/f578340e.html"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/16.webp" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Cookie、sessionStorage、localStorage 详解及应用场景</div></div></a></div><div class="next-post pull-right"><a href="/posts/e807d0a7.html"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/4.webp" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ES6模块化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/54b11a0c.html" title="Promise"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-25</div><div class="title">Promise</div></div></a></div><div><a href="/posts/8fbd8643.html" title="手写源码系列"><img class="cover" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/16.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-10</div><div class="title">手写源码系列</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Leslie Waong</div><div class="author-info__description">BUPT</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">109</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lesliewaong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lesliewaong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1138964397&amp;website=www.qtxml.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">红雨漂泊泛起了回忆怎么潜</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-text">异步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E9%98%BB%E5%A1%9E%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">产生阻塞的代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84"><span class="toc-text">JavaScript 是单线程的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81"><span class="toc-text">异步代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5JavaScript"><span class="toc-text">同步JavaScript</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5JavaScript"><span class="toc-text">异步JavaScript</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5callbacks"><span class="toc-text">异步callbacks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promises"><span class="toc-text">Promises</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97"><span class="toc-text">事件队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promises-%E5%AF%B9%E6%AF%94-callbacks"><span class="toc-text">Promises 对比 callbacks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">异步代码的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#setTimeout-amp-setInterval"><span class="toc-text">setTimeout() &amp; setInterval()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#setTimeout"><span class="toc-text">setTimeout()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E7%BB%99setTimeout"><span class="toc-text">传递参数给setTimeout()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E8%B6%85%E6%97%B6"><span class="toc-text">清除超时</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setInterval"><span class="toc-text">setInterval()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4intervals"><span class="toc-text">清除intervals</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-setTimeout-%E5%92%8C-setInterval-%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%87%A0%E7%82%B9"><span class="toc-text">关于 setTimeout() 和 setInterval() 需要注意的几点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%9A%84timeouts"><span class="toc-text">递归的timeouts</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92setTimeout-%E5%92%8CsetInterval-%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">递归setTimeout()和setInterval()有何不同？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E8%B6%85%E6%97%B6"><span class="toc-text">立即超时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-clearTimeout-or-clearInterval-%E6%B8%85%E9%99%A4"><span class="toc-text">使用 clearTimeout() or clearInterval()清除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#requestAnimationFrame"><span class="toc-text">requestAnimationFrame()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E7%9A%84%E5%8A%A8%E7%94%BB%E8%B7%91%E5%BE%97%E6%9C%89%E5%A4%9A%E5%BF%AB%EF%BC%9F"><span class="toc-text">你的动画跑得有多快？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#requestAnimationFrame-%E4%B8%8E-setInterval-%E5%92%8C-setTimeout-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-text">requestAnimationFrame() 与 setInterval() 和 setTimeout()有什么不同?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E6%8B%AC%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text">包括时间戳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%AF%E6%8C%81"><span class="toc-text">浏览器支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%A4%E9%94%80requestAnimationFrame"><span class="toc-text">撤销requestAnimationFrame()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise"><span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E9%BA%BB%E7%83%A6"><span class="toc-text">回调函数的麻烦</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8promise%E6%94%B9%E8%89%AF"><span class="toc-text">使用promise改良</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-text">promise的基本流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-A-%E8%A7%84%E8%8C%83"><span class="toc-text">Promise A+规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="toc-text">异步处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0"><span class="toc-text">手写实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="toc-text">核心逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%94%9FPromise"><span class="toc-text">原生Promise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BB%BAMyPromise%E7%B1%BB%EF%BC%8C%E4%BC%A0%E5%85%A5%E6%89%A7%E8%A1%8C%E5%99%A8executor"><span class="toc-text">新建MyPromise类，传入执行器executor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#executor-%E4%BC%A0%E5%85%A5-resolve-%E5%92%8C-reject-%E6%96%B9%E6%B3%95"><span class="toc-text">executor 传入 resolve 和 reject 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E4%B8%8E%E7%BB%93%E6%9E%9C%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-text">状态与结果的管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#then-%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">then 的简单实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8export-%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2-MyPromise-%E7%B1%BB"><span class="toc-text">使用export 对外暴露 MyPromise 类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise%E7%B1%BB%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%BC%82%E6%AD%A5%E9%80%BB%E8%BE%91"><span class="toc-text">promise类中加入异步逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%88%90%E5%8A%9F%E4%B8%8E%E5%A4%B1%E8%B4%A5%E5%9B%9E%E8%B0%83"><span class="toc-text">缓存成功与失败回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#then-%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84-Pending-%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">then 方法中的 Pending 的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resolve-%E4%B8%8E-reject-%E4%B8%AD%E8%B0%83%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">resolve 与 reject 中调用回调函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-then-%E6%96%B9%E6%B3%95%E5%A4%9A%E6%AC%A1%E8%B0%83%E7%94%A8%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-text">实现 then 方法多次调用添加多个处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MyPromise-%E7%B1%BB%E4%B8%AD%E6%96%B0%E5%A2%9E%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="toc-text">MyPromise 类中新增两个数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%AD%98%E5%85%A5%E6%95%B0%E7%BB%84%E4%B8%AD"><span class="toc-text">回调函数存入数组中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%B0%83%E7%94%A8%E6%88%90%E5%8A%9F%E5%92%8C%E5%A4%B1%E8%B4%A5%E5%9B%9E%E8%B0%83"><span class="toc-text">循环调用成功和失败回调</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-then-%E6%96%B9%E6%B3%95%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-text">实现 then 方法的链式调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#then-%E6%96%B9%E6%B3%95%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E8%AF%86%E5%88%AB-Promise-%E6%98%AF%E5%90%A6%E8%BF%94%E5%9B%9E%E8%87%AA%E5%B7%B1"><span class="toc-text">then 方法链式调用识别 Promise 是否返回自己</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF%E5%8F%8A-then-%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E7%8A%B6%E6%80%81%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%85"><span class="toc-text">捕获错误及 then 链式调用其他状态代码补充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E6%89%A7%E8%A1%8C%E5%99%A8%E9%94%99%E8%AF%AF"><span class="toc-text">捕获执行器错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#then-%E6%89%A7%E8%A1%8C%E7%9A%84%E6%97%B6%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7"><span class="toc-text">then 执行的时错误捕获</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83-fulfilled-%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AF%B9-rejected-%E5%92%8C-pending-%E7%8A%B6%E6%80%81%E8%BF%9B%E8%A1%8C%E6%94%B9%E9%80%A0"><span class="toc-text">参考 fulfilled 状态下的处理方式，对 rejected 和 pending 状态进行改造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#then-%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E5%8F%98%E4%B8%BA%E5%8F%AF%E9%80%89"><span class="toc-text">then 中的参数变为可选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-resolve-amp-Promise-reject"><span class="toc-text">Promise.resolve() &amp; Promise.reject()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-prototype-catch"><span class="toc-text">Promise.prototype.catch()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-all"><span class="toc-text">Promise.all()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-race"><span class="toc-text">Promise.race()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-prototype-finally"><span class="toc-text">Promise.prototype.finally()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-allSettled"><span class="toc-text">Promise.allSettled()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">一道面试题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#async-await"><span class="toc-text">async + await</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#async"><span class="toc-text">async</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#await"><span class="toc-text">await</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-async-await-%E9%87%8D%E5%86%99-promise-%E4%BB%A3%E7%A0%81"><span class="toc-text">使用 async&#x2F;await 重写 promise 代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-text">它到底是如何工作的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">添加错误处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%89%E5%BE%85Promise-all"><span class="toc-text">等待Promise.all()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-await%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-text">async&#x2F;await的缺陷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Async-await-%E7%9A%84%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">Async&#x2F;await 的类方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">选择正确的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83"><span class="toc-text">异步回调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7"><span class="toc-text">缺陷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setTimeout-1"><span class="toc-text">setTimeout()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7-1"><span class="toc-text">缺陷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setInterval-1"><span class="toc-text">setInterval()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7-2"><span class="toc-text">缺陷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#requestAnimationFrame-1"><span class="toc-text">requestAnimationFrame()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7-3"><span class="toc-text">缺陷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promises-1"><span class="toc-text">Promises</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7-4"><span class="toc-text">缺陷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-all-1"><span class="toc-text">Promise.all()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7-5"><span class="toc-text">缺陷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Async-await"><span class="toc-text">Async&#x2F;await</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7-6"><span class="toc-text">缺陷</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6"><span class="toc-text">事件循环机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-text">宏任务与微任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventLoop"><span class="toc-text">EventLoop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">JavaScript 执行上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="toc-text">JavaScript运行时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-loops%EF%BC%89"><span class="toc-text">事件循环（Event loops）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1-vs-%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-text">任务 vs 微任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#queueMicrotask"><span class="toc-text">queueMicrotask</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-text">何时使用微任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%9D%A1%E4%BB%B6%E6%80%A7%E4%BD%BF%E7%94%A8-promises-%E6%97%B6%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-text">保证条件性使用 promises 时的顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="toc-text">批量操作</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/f0ca7a3c.html" title="基于类 vs 基于原型的语言"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/9.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="基于类 vs 基于原型的语言"></a><div class="content"><a class="title" href="/posts/f0ca7a3c.html" title="基于类 vs 基于原型的语言">基于类 vs 基于原型的语言</a><time datetime="2022-03-22T03:32:47.000Z" title="发表于 2022-03-22 11:32:47">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d7c881ac.html" title="Express"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/14.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="Express"></a><div class="content"><a class="title" href="/posts/d7c881ac.html" title="Express">Express</a><time datetime="2022-03-15T08:11:03.000Z" title="发表于 2022-03-15 16:11:03">2022-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/783ce8a9.html" title="移动端适配"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/16.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="移动端适配"></a><div class="content"><a class="title" href="/posts/783ce8a9.html" title="移动端适配">移动端适配</a><time datetime="2022-03-12T07:04:52.000Z" title="发表于 2022-03-12 15:04:52">2022-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/50cb7bb5.html" title="Cookie、Session、Token、JWT"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/1.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="Cookie、Session、Token、JWT"></a><div class="content"><a class="title" href="/posts/50cb7bb5.html" title="Cookie、Session、Token、JWT">Cookie、Session、Token、JWT</a><time datetime="2022-03-11T03:11:11.000Z" title="发表于 2022-03-11 11:11:11">2022-03-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5c76f87e.html" title="XSS和CSRF"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/cover.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="XSS和CSRF"></a><div class="content"><a class="title" href="/posts/5c76f87e.html" title="XSS和CSRF">XSS和CSRF</a><time datetime="2022-03-10T04:01:23.000Z" title="发表于 2022-03-10 12:01:23">2022-03-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Leslie Waong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:""},null))},e=()=>{twikoo.getCommentsCount({envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))},n=(n=!1)=>{"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})};btf.loadComment(document.getElementById("twikoo-wrap"),n)})()</script></div><div class="aplayer no-destroy" data-id="6995412795" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="auto" data-autoplay="true" muted></div><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":0,"vOffset":0},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body></html>