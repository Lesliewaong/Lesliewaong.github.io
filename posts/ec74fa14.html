<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MQ2 | Leslie Waong</title><meta name="keywords" content="前端 Java 空间光通信"><meta name="author" content="Leslie Waong"><meta name="copyright" content="Leslie Waong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="自我介绍前端 面试官好，我叫王吉晨，现在就读于北京邮电大学，是一名研三的学生，预计明年六月份毕业。今天我想应聘的是软件开发的岗位。 下面我来介绍下我的学习、项目和实习经历。 最早是本科做了一个Android电子词典APP，其中词典的离线数据通过Python爬取并保存在SQLite数据库中，使用java进行安卓app的开发，实现了像离线或在线的单词查询、句子翻译、语音输入、生词本和注册登录等功能，通"><meta property="og:type" content="article"><meta property="og:title" content="MQ2"><meta property="og:url" content="https://lesliewaong.top/posts/ec74fa14.html"><meta property="og:site_name" content="Leslie Waong"><meta property="og:description" content="自我介绍前端 面试官好，我叫王吉晨，现在就读于北京邮电大学，是一名研三的学生，预计明年六月份毕业。今天我想应聘的是软件开发的岗位。 下面我来介绍下我的学习、项目和实习经历。 最早是本科做了一个Android电子词典APP，其中词典的离线数据通过Python爬取并保存在SQLite数据库中，使用java进行安卓app的开发，实现了像离线或在线的单词查询、句子翻译、语音输入、生词本和注册登录等功能，通"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/9.jpg"><meta property="article:published_time" content="2022-01-01T08:46:41.000Z"><meta property="article:modified_time" content="2022-09-29T03:38:32.312Z"><meta property="article:author" content="Leslie Waong"><meta property="article:tag" content="前端 Java 空间光通信"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/9.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg"><link rel="canonical" href="https://lesliewaong.top/posts/ec74fa14"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"一年之内的产物",messageNext:"技术可能存在过期"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Leslie Waong",link:"链接: ",source:"来源: Leslie Waong",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"MQ2",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-09-29 11:38:32"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px");const a=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};a(),document.addEventListener("pjax:complete",a)})(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Leslie Waong" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">122</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li><li><a class="site-page child" href="/item/test/"><i class="fa-fw fa fa-star"></i><span> test</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/9.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leslie Waong</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/item/Naruto/"><i class="fa-fw fa fa-star"></i><span> 火影</span></a></li><li><a class="site-page child" href="/react-admin-client"><i class="fa-fw fa fa-star"></i><span> One Piece</span></a></li><li><a class="site-page child" href="/item/test/"><i class="fa-fw fa fa-star"></i><span> test</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-desktop"></i><span> BiliBili</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MQ2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-01T08:46:41.000Z" title="发表于 2022-01-01 16:46:41">2022-01-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-29T03:38:32.312Z" title="更新于 2022-09-29 11:38:32">2022-09-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%9E%E6%8A%80%E6%9C%AF%E9%9D%A2/">非技术面</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">72.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>226分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="MQ2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p><strong>前端</strong></p><p>面试官好，我叫王吉晨，现在就读于北京邮电大学，是一名研三的学生，预计明年六月份毕业。今天我想应聘的是软件开发的岗位。</p><p>下面我来介绍下我的学习、项目和实习经历。</p><p>最早是本科做了一个Android电子词典APP，其中词典的离线数据通过Python爬取并保存在SQLite数据库中，使用java进行安卓app的开发，实现了像离线或在线的单词查询、句子翻译、语音输入、生词本和注册登录等功能，通过这个项目主要对前后端的开发语言都有了一定的了解，积累了开发经验。</p><p>后来研究生阶段利用空闲时间开始学习前端，先是系统学习了HTML，CSS和JS前端三件套，并通过Hexo搭建了个人博客网站记录一些学习内容。后面进一步学习了像ES6+、Ajax等前端知识。前端框架主要是学习了React，自己做了一个后台管理系统，主要基于react和antd等技术实现前端界面的搭建，通过这个项目熟悉了前后端分离的开发模式，以及模块化、组件化、工程化的开发理念，主要使用react hooks结合react router v6完成相应的功能。</p><p>实习的话，暑期在美团实习，基于组内微前端的研发平台，实现MBR报表的线上化，技术栈为React+TypeScript+MTD，通过这个项目熟悉了整个开发流程，从需求分析、方案设计、代码开发，再到联调测试，主要工作是实现MBR产品的前台页面和管理后台的展示与交互功能。</p><p>实验室这边，我的研究方向为自由空间光通信系统空间分集接收方案研究与设计，通过Matlab和Optilux工具包实现FSO空间分集接收仿真平台的搭建，并进行了离线实验验证，并在该方向下成功发表一篇二区SCI。</p><p>我认为我的优势一是技术视野开阔，喜欢钻研，具有良好的学习能力；二是注重团队合作，有着强烈的责任心和高度执行力；另外我也具备一定抗压能力，应对实验室或公司中时间紧任务重的情况，能够从容进行任务的分级与梳理，积极协调沟通，同时调整生活和工作上的平衡，争取手中任务都能保质按时地交付。</p><p>我的自我介绍就是这些，谢谢面试官！</p><p><strong>国企</strong></p><p>面试官好，我叫王吉晨，现在就读于北京邮电大学，是一名研三的学生，预计明年六月份毕业。下面我就介绍一下我的项目和实习经历。</p><p>本科时，我基于Android平台实现了一个电子词典APP，其中词典的离线数据使用Python爬取并保存在SQLite数据库中，并基于Android Studio完成界面设计和功能实现，主要开发语言是Java，通过这个项目学习了MVVM开发模式，体会到了逻辑、视图以及模型分离的开发理念，积累了开发经验。</p><p>后来研究生阶段利用空闲时间系统学习了前端的相关知识，框架主要是学习了React，像国家电投招聘网站前端界面就是React+Antd实现的。自己做了一个后台管理系统的项目，通过这个项目熟悉了前后端分离的开发模式，以及模块化、组件化、工程化的开发理念。</p><p>暑期时在美团实习，基于组内的微前端研发平台，实现MBR报表的线上化，通过这个项目熟悉了整个开发流程，从需求分析、方案设计、代码开发，再到联调测试，主要工作是实现MBR产品的前台页面和管理后台的展示与交互功能。</p><p>实验室的研究方向为自由空间光通信系统空间分集接收方案研究与设计，通过Matlab和Optilux实现40Gbps PM-CO-16QAM FSO空间分集接收仿真平台搭建，并进行了离线实验验证，在该方向下成功发表一篇二区SCI。</p><p>我认为我的优势一是技术视野开阔，喜欢钻研，具有良好的学习能力；注重团队合作，有着强烈的责任心和高度执行力，力争每次都能按时保质地交付手中的任务；另外具备一定抗压能力，应对实验室或公司中时间紧任务重的情况，能够从容进行任务的分级与梳理，积极沟通协调，同时调整生活和工作上的平衡。</p><p>综上所述，我想应聘的是软件开发的岗位。希望有机会能够加入贵公司!谢谢！</p><h1 id="实验室"><a href="#实验室" class="headerlink" title="实验室"></a>实验室</h1><p>我的研究方向是自由空间光通信分集接收技术的研究与设计。</p><p><strong>背景</strong></p><p>近年来，自由空间光通信系统因其免频谱许可证、高带宽、低功耗、易部署、高安全性和高指向性等优点被认为是高速宽带连接的下一个前沿领域。由于传统的无线微波通信技术已经不能满足目前卫星通信的需要，加上FSO链路的数据传输速率有了很大的提高，FSO技术在卫星通信系统特别是近地轨道(LEO)卫星对地通信中得到了广泛的关注和应用。然而，它们的性能仍然很大程度上取决于大气通道的连接条件;特别是大气湍流引起的光强闪烁和相位波动会降低接收信号的完整性，导致错误概率增加，限制链路性能，严重时可能导致链路中断。基于强度调制直接探测(IM/DD)的无中继星地激光通信系统由于探测方式的原因，接收机灵敏度较低，当信息速率高达40 Gbps甚至100 Gbps时，接收机灵敏度随着速率和带宽的增加而下降。相干光通信系统由于信号光和本振(LO)光的混合，通常比IM/DD光通信系统具有超过20 dB的额外灵敏度，这是实现LEO卫星对地高速通信的有效手段。然而，由于无中继空间信道的严重损耗，特别是在中等和强湍流下，相干接收系统的功率预算保证非常具有挑战性。因此，以经济有效的方式减少大气湍流效应和提高相干光通信系统的接收机灵敏度是低轨道卫星对地通信的关键目标之一。</p><p>孔径平均可以通过增大接收机孔径大小，自适应光学，信道编码。空间分集利用多个发射/接收分支增加空间自由度，显著降低了深度衰落概率，有效提高了系统性能;然而，这里的主要缺点是系统复杂性的增加。</p><p><strong>创新点</strong></p><p>分集可以有效抑制大气湍流，但会增加系统复杂性，同时相位不同步引起的相对相位差会降低分集系统的性能。 因此，本文提出了基于最优分支块相位校正的空间分集接收，并通过仿真和实验验证，以提高分集增益，有效降低分集系统的复杂度和中断概率。 该方案有望应用于高速近地轨道星地通信。</p><p>大气通道中的湍流以相位波动和振幅畸变(即闪烁)的形式在传播场中引起时变畸变。因此，合并前的一个关键步骤是不同分支之间的相位校正。传统的方案是对每个接收支路进行DSP处理，然后进行合并，对各支路的频率偏移和相位噪声进行补偿，并消除合并前支路之间的rpd。但DSP算法复杂度普遍较高，如果每个分支都需要采用DSP，分集系统的整体复杂度会非常高。假设DSP只考虑频率偏移和相位噪声的估计和补偿。在频偏估计和补偿方面，该方案与传统方案相比没有明显改进。而在传统方案中，相位估计和补偿需要进行M次，其中M为分支数。该方案只需要在obo - bpc后进行一次相位估计和补偿。由于仿真中调制格式为16QAM，因此采用传统的QPSK分割作为相位估计算法进行对比分析，其复杂度在[25]中有提及。对于OB-BPC算法，因为我们只对相位感兴趣，所以在实际操作中，Eq.(14)中的平均值可以用求和来代替，所以每次对相对相位差的估计都需要4B实乘法和4B−2实加法。B为OB-BPC或QPSK分区算法中的块长度。每个arctan(·)可以被认为是一个只读内存(ROM)访问。如表1所示，比较了两种方案相位估计的硬件复杂度。</p><p><strong>仿真</strong></p><p>40 Gbps PM-CO-16QAM FSO空间分集接收仿真平台如图3所示。optilux工具包。</p><p>首先，利用MATLAB软件生成16QAM信号。然后，利用偏振分束器(PBS)将线宽为50 kHz的外腔激光器(ECL)分成两个正交偏振光信号;然后用两个双平行马赫-曾德调制器对两个正交偏振光信号进行调制，生成的四个离散数据信号分别对应X和Y偏振态的实部和虚部。利用偏振光束组合器将两种偏振态的光信号合成为单个信号光束，并集成到计算机模拟的自由空间湍流通道中。</p><p>在模拟中，采用基于傅里叶变换的相位屏模型模拟大气湍流。</p><p>在接收端，光信号被多个接收望远镜接收并耦合到单模光纤中，然后被提供给每个相干接收分支，每个接收望远镜的孔径设置为0.45 m。在相干接收机中，接收到的光场与LO激光混合，利用平衡光电二极管(bpd)完成光电转换过程。LO激光器的输出功率为14 dBm。LO激光器的线宽设置为50 kHz，频率偏移设置为100 MHz。但是，不同支路相干接收机的频率偏移和线宽引入的相位噪声是不一样的。由于频率偏移是一个随时间变化的累积值，线宽引入的相位噪声也随时间变化。在仿真过程中，对不同时刻携带相同信号的不同支路加上由频率偏移和线宽引入的相位噪声，可以生成支路之间的rpd。光电二极管的响应率为0.8 A/W。这里还考虑了炮丸噪声和热噪声。最后，利用ADC对信号进行数字化处理，并在脱机DSP模块中进行处理，包括定时同步、频偏预补偿、obb - bpc、MRC、极化解复用、相位噪声估计、DD-LMS、QAM解映射和误码率计数。</p><p><strong>实验</strong></p><p>为了进一步研究所提出的OB-BPC方案的性能，在不同湍流信道下进行了16QAM时分集接收的离线实验，如图7所示;本文采用PLUTO-2空间光调制器(SLM)模拟湍流通道。由于目前市面上的SLMs对偏振非常敏感，在实验中很难实现偏振复用。此外，大气湍流造成的极化损伤非常小，一般可以通过信道均衡来补偿，这样分集增益与极化无关。首先，使用仿真中使用的相同DSP程序生成16QAM符号，并将实部和虚部对应的I和Q信号发送到最大采样率为12 GSa/s的安捷伦任意波形发生器(WG) M8190A产生基带电信号。这些信号用于驱动光IQ调制器，其中线宽小于100 kHz的激光与光调制器集成在一起;激光载流子中心频率设置为193.400太赫兹。随后，调制器的输出信号光通过望远镜发射到自由空间。</p><p>空间光调制器常被用于模拟大气湍流[31,32]，在原理上，当使用足够数量的平板时，可以准确模拟真实的湍流场景。PLUTO-2 SLM将灰度转换为相位级数据，这些数据反映在光的波前相位中，从而模拟大气湍流效应。</p><p>由于空间分集的实验系统不易建立，提出的方案在时间分集上进行了验证。注意，这里的时间分集是空间分集的等效实现，即M个接收器，只有一个信号传输可以等价于一个接收器，M个重复信号传输，只确保M个分支经历独立衰落。在实验中，每次更新大气湍流灰度图时，接收机接收到一个独立的衰落信号。接收望远镜接收并将信号光耦合到标准单模光纤(SSMF)中，然后使用可变光衰减器(VOA)来调整接收到的光功率。LO激光器工作在193.400太赫兹，线宽小于100 kHz。实验采用富士通FIM24706相干接收机进行相干接收，采用40GSa/s实时采样示波器对光电检测后的信号进行数字化处理，用于离线DSP算法应用。同时同步A WG和示波器的时钟源。</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/XzxS6f"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/21/XzxS6f.png" alt="XzxS6f.png"></a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>版本库👉.git<ul><li>当我们使用git管理文件时，比如<strong>git init</strong>时，这个时候，会多一个**.git**文件，我们把这个文件称之为版本库。</li><li><strong>.git</strong>文件另外一个作用就是它在创建的时候，会自动创建<strong>master</strong>分支，并且将<strong>HEAD</strong>指针指向<strong>master</strong>分支。</li></ul></li><li>工作区<ul><li>本地项目存放文件的位置。</li><li>可以理解成图上的workspace。</li></ul></li><li>暂存区 (<code>Index/Stage</code>)<ul><li>顾名思义就是暂时存放文件的地方，通过是通过<strong>add</strong>命令将工作区的文件添加到缓冲区。</li></ul></li><li>本地仓库（<code>Repository</code>）<ul><li>通常情况下，我们使用<strong>commit</strong>命令可以将暂存区的文件添加到本地仓库。</li><li>通常而言，<strong>HEAD</strong>指针指向的就是<strong>master</strong>分支。</li></ul></li><li>远程仓库（<code>Remote</code>）<ul><li>举个例子，当我们使用<strong>GitHub</strong>托管我们项目时，它就是一个远程仓库。</li><li>通常我们使用<strong>clone</strong>命令将远程仓库代码拷贝下来，本地代码更新后，通过<strong>push</strong>托送给远程仓库。</li></ul></li></ul><h2 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVX50s"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVX50s.png" alt="jVX50s.png"></a></p><p><strong>master分支</strong></p><ul><li><strong>主分支</strong>，用于<strong>部署生产环境</strong>的分支，确保稳定性。</li><li>master分支一般由develop以及hotfix分支合并，任何情况下都不能直接修改代码。</li></ul><p><strong>develop 分支</strong></p><ul><li>develop为<strong>开发分支</strong>，通常情况下，保存最新完成以及bug修复后的代码。</li><li>开发新功能时，feature分支都是基于develop分支下创建的。</li></ul><p><strong>feature分支</strong></p><ul><li><strong>开发新功能</strong>，基本上以develop为基础创建feature分支。</li><li>分支命名：<strong>feature/ 开头</strong>的为特性分支， 命名规则: feature/user_module、 feature/cart_module。</li></ul><p><strong>release分支</strong></p><ul><li>release 为<strong>预上线分支</strong>，发布提测阶段，会release分支代码为基准提测。</li></ul><p><strong>hotfix分支</strong></p><ul><li><strong>hotfix/</strong> 开头的为<strong>修复分支</strong>，它的命名规则与 feature 分支类似。</li><li>线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支。</li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>有了上述的基本了解后，那么我们就来看看整体的一个流程吧。</p><ul><li><p>创建本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init  </span><br></pre></td></tr></table></figure></li><li><p>链接本地仓库与远端仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add  origin url</span><br><span class="line">origin默认是远端仓库别名  url 可以是可以使用https或者ssh的方式新建</span><br></pre></td></tr></table></figure></li><li><p>检查配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email  &quot;your_email&quot;</span><br></pre></td></tr></table></figure></li><li><p>生成SSH密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;这里换上你的邮箱&quot;</span><br><span class="line">cd ~/.ssh 里面有一个文件名为id_rsa.pub,把里面的内容复制到git库的我的SSHKEYs中</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></li><li><p>常看远端仓库信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li><li><p>远端仓库重新命名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename old new</span><br></pre></td></tr></table></figure></li><li><p>提交到缓存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add . 全部上传到缓存区</span><br><span class="line">git add 指定文件</span><br></pre></td></tr></table></figure></li><li><p>提交到本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;some message&#x27;</span><br></pre></td></tr></table></figure></li><li><p>提交远程仓库/从远程拉取合并</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">git pull origin dev //从远程dev 分支拉取到本地dev 分支  pull=fetch+merge</span><br></pre></td></tr></table></figure></li><li><p>查看分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li><p>创建新分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>切换分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建分支并切换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>删除分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>克隆仓库后切换分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone url //将远程仓库克隆下载到本地</span><br><span class="line">git checkout -b dev origin/dev // 克隆仓库后切换到dev 分支</span><br></pre></td></tr></table></figure></li><li><p>忽略文件 .gitignore</p><p>这个文件的作用，会去忽略一些不需要纳入Git管理这种，我们也不希望出现在未跟踪文件列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此行为注释 会被Git忽略 </span></span><br><span class="line"><span class="comment"># 忽略 node_modules/ 目录下所有的文件 </span></span><br><span class="line">node_modules </span><br><span class="line"><span class="comment"># 忽略所有.vscode结尾的文件 </span></span><br><span class="line">.vscode </span><br><span class="line"><span class="comment"># 忽略所有.md结尾的文件 </span></span><br><span class="line">.md </span><br><span class="line"><span class="comment"># 但README.md 除外 </span></span><br><span class="line">!README.md </span><br><span class="line"><span class="comment"># 会忽略 doc/something.txt 但不会忽略doc/images/arch.txt </span></span><br><span class="line">doc/.txt </span><br><span class="line"><span class="comment"># 忽略 doc/ 目录下所有扩展名为txt文件 </span></span><br><span class="line">doc/**/*.txt</span><br></pre></td></tr></table></figure></li><li><p>文件状态</p><p>通常我们需要查看一个文件的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status </span><br></pre></td></tr></table></figure><ul><li><p><strong>Changes not staged for commit</strong></p><p>大概就是工作区有该内容，但是缓存区没有，需要我们<strong>git add</strong></p></li></ul></li></ul><ul><li><p><strong>Changes to be committed</strong></p><p>这个时候，文件放在缓存区了，我们需要<strong>git commit</strong></p></li></ul><ul><li><p><strong>nothing to commit, working tree clean</strong></p><p>这个时候，我们将本地的代码推送到远端即可</p></li></ul><ul><li><p>查看历史操作记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></li><li><p>查看日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></li><li><p>差异比较</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure></li></ul><h2 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h2><p>GitLens</p><h2 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h2><p>假设我们刚刚完成软件的一个新特性，也许之前一直在特性分支中工作，因此下一步将是将其合并到主线分支(<code>master</code>分支或<code>main</code>分支)。</p><p>在某些情况下，比方说你是项目中唯一的开发人员，或者有足够的经验并确定团队成员不会提出异议，那么直接合并一点问题都没有。</p><p>不过如果代码变更稍微复杂一点，并且希望其他人能够检查这部分工作，该怎么办呢？这就是pull request的目的。有了pull request，可以邀请其他人来评论所作的工作并给出反馈。</p><p>一旦创建了pull request，就可以和其他开发人员讨论相关代码。</p><p>大多数Git托管平台允许其他用户在此过程中添加评论以及提出建议，当评审人员批准后，就可以将其合并到另一个分支中。</p><h2 id="约定式提交-1-0-0"><a href="#约定式提交-1-0-0" class="headerlink" title="约定式提交 1.0.0"></a><a target="_blank" rel="noopener" href="https://www.conventionalcommits.org/zh-hans/v1.0.0/">约定式提交 1.0.0</a></h2><p>提交说明包含了下面的结构化元素，以向类库使用者表明其意图：</p><ol><li><strong>fix:</strong> <em>类型</em> 为 <code>fix</code> 的提交表示在代码库中修复了一个 bug（这和语义化版本中的 <a target="_blank" rel="noopener" href="https://semver.org/lang/zh-CN/#%E6%91%98%E8%A6%81"><code>PATCH</code></a> 相对应）。</li><li><strong>feat:</strong> <em>类型</em> 为 <code>feat</code> 的提交表示在代码库中新增了一个功能（这和语义化版本中的 <a target="_blank" rel="noopener" href="https://semver.org/lang/zh-CN/#%E6%91%98%E8%A6%81"><code>MINOR</code></a> 相对应）。</li><li><strong>BREAKING CHANGE:</strong> 在脚注中包含 <code>BREAKING CHANGE:</code> 或 <code>&lt;类型&gt;(范围)</code> 后面有一个 <code>!</code> 的提交，表示引入了破坏性 API 变更（这和语义化版本中的 <a target="_blank" rel="noopener" href="https://semver.org/lang/zh-CN/#%E6%91%98%E8%A6%81"><code>MAJOR</code></a> 相对应）。 破坏性变更可以是任意 <em>类型</em> 提交的一部分。</li><li>除 <code>fix:</code> 和 <code>feat:</code> 之外，也可以使用其它提交 <em>类型</em> ，例如 <a target="_blank" rel="noopener" href="https://github.com/conventional-changelog/commitlint/tree/master/%40commitlint/config-conventional">@commitlint/config-conventional</a>（基于 <a target="_blank" rel="noopener" href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines">Angular 约定</a>）中推荐的 <code>build:</code>、<code>chore:</code>、 <code>ci:</code>、<code>docs:</code>、<code>style:</code>、<code>refactor:</code>、<code>perf:</code>、<code>test:</code>，等等。</li><li>脚注中除了 <code>BREAKING CHANGE: &lt;description&gt;</code> ，其它条目应该采用类似 <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-interpret-trailers">git trailer format</a> 这样的惯例。</li></ol><p>其它提交类型在约定式提交规范中并没有强制限制，并且在语义化版本中没有隐式影响（除非它们包含 BREAKING CHANGE）。 可以为提交类型添加一个围在圆括号内的范围，以为其提供额外的上下文信息。例如 <code>feat(parser): adds ability to parse arrays.</code>。</p><h2 id="Git-中的撤销"><a href="#Git-中的撤销" class="headerlink" title="Git 中的撤销"></a>Git 中的撤销</h2><p>撤销可能是使用过程中最需要的操作，你可能在任何时候都需要撤销。根据情况不同，撤销的命令也是不同的。</p><h3 id="撤销最近几次-commit"><a href="#撤销最近几次-commit" class="headerlink" title="撤销最近几次 commit"></a>撤销最近几次 commit</h3><p>要撤销最近几次的提交，可以使用 <code>git reset</code>，下面介绍它的三种模式：<code>soft</code>、<code>mixed</code> 和 <code>hard</code>。</p><p>假设目前分支情况如下，我们需要撤销到 <code>98c27</code> commit 上去。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVxvng"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVxvng.png" alt="jVxvng.png"></a></p><p><strong>1）soft 模式</strong></p><p>执行 <code>git reset --soft 98c27</code>，git 会首先修改 HEAD 的指向，它会连带修改 HEAD 所在分支的指向：</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVxXjS"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVxXjS.png" alt="jVxXjS.png"></a></p><p>如上图所示，现在的暂存区和 HEAD 是不同的，这个操作本质上撤销了 <code>2c9be</code> 这个 commit，如同回到了上次准备 commit 的时候。（git 中的时光机！）</p><p>此时你可以进行后悔操作，继续修改文件再 add，然后重新 commit，这时会提交一个新的 commit。</p><p><strong>2）mixed 模式</strong></p><p>回到一开始的时候，假如我们执行的是 <code>git reset --mixed 98c27</code>，它也会首先修改 HEAD 的指向，使得 HEAD 上的 commit 为 <code>98c27</code>。</p><p>但还不够，git 还会接着更新你的暂存区，如同回到了你准备 add 的时候。（时光机再向前！）</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVxL1f"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVxL1f.png" alt="jVxL1f.png"></a></p><p>对你来说可能更方便了，继续改就行，然后重新 add、commit。这实际上是 reset 的默认模式，等同于 <code>git reset 98c27</code>。</p><p><strong>3）hard 模式</strong></p><p>不用我多说你可能已经意识到 hard 是干什么用的了。这一次 git 摧枯拉朽，把你的 HEAD、暂存区、工作区全给干掉了：</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVxI7d"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVxI7d.png" alt="jVxI7d.png"></a></p><p>一下子回到了你开始写需求的时候。所以这个命令是 <strong>危险</strong> 的，除非你真的打算不要这些修改了，否则最好不要用。</p><p>不过即使你真的用了又后悔，那也是有办法的，在 git 里面，既然能回到过去，也能在过去穿越到未来。</p><p>使用 <code>git reflog</code> 可以查看你最近的修改，找到最前面的 commit id，可以继续使用 reset 穿回去。</p><h3 id="合并-commit"><a href="#合并-commit" class="headerlink" title="合并 commit"></a>合并 commit</h3><p>有时候你可能发现自己刚才提交的好几个 commit 其实都是中间状态，还不如把它们合并成一个。</p><p>根据上面的 reset，实际上就能完成这件事情。</p><p>比如下面的场景，我们多提交了一个 File V1.1 的中间版本，希望将其从 commit 历史中去掉：</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVxTAA"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVxTAA.png" alt="jVxTAA.png"></a></p><p>那其实可以直接 reset 到 v1 版本：</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVx4ne"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVx4ne.png" alt="jVx4ne.png"></a></p><p>然后重新进行 commit，这样就会将 v1 之后的修改都提交到了新的版本，如同移除了中间的版本。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVx7tI"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVx7tI.png" alt="jVx7tI.png"></a></p><p>当然，这个场景也能用 rebase 解决，之后会提到。</p><h3 id="挪动-commit"><a href="#挪动-commit" class="headerlink" title="挪动 commit"></a>挪动 commit</h3><p>在多个分支上切换开发的时候，有时候会忘记切换分支就开始开发。</p><p>当发现自己提交的 commit 放错分支怎么办呢？在 git 中，这也不算个事，通过 <code>git cherry-pick</code> 就能解决。</p><p>cherry-pick 可以将指定的 commit “摘到”当前的分支上面，git 会为你重新生成一个 commit，但内容与 pick 的 commit 一致。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jVx50H"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVx50H.png" alt="jVx50H.png"></a></p><p>如果你要 pick 好几个 commit，它们之间有依赖关系，那需要根据先后顺序依次进行 cherry pick。</p><p>当发生冲突时，此时需要修改文件解决冲突，可以使用 <code>git cherry-pick --abort</code> 放弃此次 pick，或者解决完 add 进暂存区，然后使用 <code>git cherry-pick --continue</code>。注意这里并不是使用 <code>git commit</code>，如果你需要改变 commit 的信息，可以使用 commit，否则 git 会默认使用 pick 的 commit 的信息。</p><h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>单人基本不会冲突，主要是多人协作，而且对其他人代码或公共代码修改时才会冲突。</p><ul><li><strong>如果不是基于远程库的最新版所做的修改，不能推送，必须先拉取。</strong></li><li>拉取下来后如果进入冲突状态，根据产生冲突的地方检查并修改。</li><li>package-lock.json冲突<ul><li>统一node版本和npm版本(至少统一一个大的版本)，且在需要重新安装依赖的时候，使用npm ci的命令去安装。（强烈推荐,npm ci指的是根据package-lock.json去安装对应的版本，不对这个文件做改动）</li><li>使用git忽略package-lock.json（不推荐，这样子会导致不能根据安装依赖路径去安装包了）</li></ul></li></ul><h1 id="计算机网络和浏览器"><a href="#计算机网络和浏览器" class="headerlink" title="计算机网络和浏览器"></a>计算机网络和浏览器</h1><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><strong>TCP/IP</strong>体系结构相当于将<strong>OSI</strong>体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p><p>教学时经常把TCP/IP体系结构的<strong>网络接口层</strong>分成了<strong>物理层</strong>和<strong>数据链路层</strong>。</p><ul><li><strong>应用层，负责向用户提供一组应用程序，比如 HTTP、DNS、FTP 等</strong>;</li><li><strong>传输层，负责端到端的通信，比如 TCP、UDP 等</strong>；</li><li><strong>网络层，负责网络包的封装、分片、路由、转发，比如 IP、ICMP 等</strong>；</li><li><strong>网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等</strong>；</li></ul><h3 id="为什么网络要分层？"><a href="#为什么网络要分层？" class="headerlink" title="为什么网络要分层？"></a>为什么网络要分层？</h3><ul><li><strong>各层之间相互独立</strong></li><li><strong>提高了整体灵活性</strong> 高内聚，低耦合</li><li><strong>大问题化小</strong></li></ul><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><ul><li>两台电脑可以通过一根<strong>网线</strong>直接连接，进行通信。</li><li>机器一多，可以把网线都接到<strong>集线器</strong>（<strong>物理层</strong>）上，但是集线器会不管三七二十一进行<strong>广播</strong>。</li><li>不想广播，可以用（二层）<strong>交换机</strong>（<strong>数据链路层</strong>），又叫多端口网桥，它比较聪明，会自我学习生产<strong>MAC地址表</strong>，知道消息发到哪，那就<strong>不需要广播</strong>啦。</li><li><strong>互联网</strong>电脑这么多，交换机MAC地址表总不能全放下吧。改用<strong>路由器</strong>（<strong>网络层</strong>），也叫<strong>三层交换机</strong>，通过网段的方式定位要把消息转发到哪，就不需要像交换机那样苦哈哈一条条记录MAC地址啦（具有<strong>MAC地址</strong>和<strong>IP地址</strong>）。</li><li>路由器和光猫之间是好搭档，<strong>光猫</strong>负责把光纤里的光信号转换成电信号给路由器。</li><li>现在一般情况下，家里已经不用集线器和交换机了，<strong>大部分路由器也支持交换机的功能</strong>。所以可以看到，家里的台式机电脑一般就连到一个路由器，再连个光猫就够能快乐上网了。</li></ul><h2 id="URL输入到页面展现"><a href="#URL输入到页面展现" class="headerlink" title="URL输入到页面展现"></a>URL输入到页面展现</h2><p>总体来说分为以下几个过程:</p><ul><li><strong>解析URL并生成HTTP请求报文</strong></li><li><strong>DNS 解析</strong>：将<strong>域名</strong>解析成<strong>IP地址</strong></li><li><strong>TCP 三次握手</strong>建立连接、<strong>TLS三次握手</strong> =》在<strong>HTTPS</strong>上建立安全连接</li><li>将HTTP报文添加TCP头部（源、目标端口、序号、窗口大小和状态位）生成<strong>TCP报文</strong></li><li>添加<strong>IP包头</strong>（源、目标IP）和<strong>MAC包头</strong>（收发MAC地址）将数据封装成<strong>网络包</strong></li><li><strong>网卡驱动</strong>从IP模块获取到包之后，再次封装。</li><li><strong>网卡</strong>会将包转为<strong>电信号</strong>（光纤传输的话可能还有电光转换）。</li><li>网络包经过<strong>交换机</strong>和<strong>路由器</strong>转发到达<strong>服务器</strong></li><li>服务器将<strong>MAC、IP、TCP、HTTP头部一层层解析处理</strong>，<strong>将网页放入HTTP响应报文中</strong>，<strong>穿上TCP、IP、MAC头部返回</strong></li><li>浏览器拿到HTTP响应报文后，将<strong>HTML和CSS解析出DOM 树和 CSS 规则树</strong>（<strong>CSSOM</strong>），两者生成<strong>渲染树</strong>进行<strong>页面绘制</strong></li><li>断开TCP连接 ：<strong>TCP四次挥手</strong></li></ul><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>统一资源定位符，URI是统一资源标志符</p><p><strong>URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</strong></p><p>URL遵守以下的语法规则：<code>scheme://host.domain:port/path/filename</code></p><ul><li><strong>scheme</strong> - 定义因特网服务的类型。常见的协议有 <strong>http、https、ftp、file</strong>，其中最常见的类型是 http，而 <strong>https 则是进行加密的网络传输</strong>。</li><li><strong>host</strong> - 定义域主机（http 的默认主机是 <strong>www</strong>）</li><li><strong>domain</strong> - 定义因特网<strong>域名</strong>，比如 <code>w3school.com.cn</code></li><li><strong>port</strong> - 定义主机上的<strong>端口号</strong>（http 的默认端口号是 80）</li><li><strong>path</strong> - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</li><li><strong>filename</strong> - 定义文档/资源的名称</li></ul><p>当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是<code>/index.html</code>或者<code>/default.html</code>这些文件，这样就不会发生混乱了。</p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>委托操作系统将消息发送给Web服务器，<strong>需要查询服务器域名对应的IP地址。</strong></p><p>DNS服务器就<strong>专门保存了Web服务器域名与IP的对应关系</strong>。</p><p><strong>查询过程</strong></p><ul><li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li><li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器<strong>缓存</strong>中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li><li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li><li>本地DNS服务器向<strong>顶级域名服务器（.com）</strong>发送请求，返回相关的下一级的权威域名服务器的地址</li><li>本地DNS服务器向**权威域名服务器(.baidu.com)**发送请求，域名服务器返回对应的结果(<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>)</li><li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li><li>本地DNS服务器将返回结果返回给浏览器</li></ul><p>DNS解析是一个包含<strong>迭代</strong>查询和<strong>递归</strong>查询的过程。</p><ul><li>一般<strong>我们向本地 DNS 服务器</strong>发送请求的方式就是<strong>递归查询</strong>，因为我们只需要发出<strong>一次请求</strong>，然后<strong>本地 DNS 服务器返回给我们最终的请求结果</strong>。</li><li>而<strong>本地 DNS 服务器向其他域名服务器</strong>请求的过程是<strong>迭代查询</strong>的过程，因为<strong>每一次域名服务器只返回单次查询的结果，下一级的查询由本地 DNS 服务器自己进行</strong>。</li></ul><p><strong>DNS负载均衡</strong></p><h3 id="TCP三次握手-★"><a href="#TCP三次握手-★" class="headerlink" title="TCP三次握手 ★"></a>TCP三次握手 ★</h3><p>TCP连接的建立，通常称为三次握手。</p><p>这个所谓的「连接」，只是双方计算机里<strong>维护一个状态机</strong>。</p><p><strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小，称为连接。</strong></p><ul><li><strong>Socket</strong>:由<strong>IP地址</strong>和<strong>端口号</strong>组成</li><li><strong>序列号</strong>:用来解决乱序问题等</li><li><strong>窗口大小</strong>:用来做流量控制</li></ul><p><strong>三次握手</strong></p><ul><li>一开始，客户端和服务端都处于关闭状态。先是服务端<strong>主动监听某个端口</strong>。</li><li>客户端把第一个发送报文（包含<strong>客户端序列号</strong>（client_isn ），<code>SYN</code> 标志位置为<code>1</code>）发送给服务端，表示向服务端发起连接，该报文不包含应用层数据。</li><li>服务端收到客户端的<code>SYN</code>报文后，发送应答报文（包含<strong>服务端序列号</strong>（server_isn）、<strong>确认序列</strong>（client_isn +1）、<code>SYN</code>和<code>ACK</code>置1）给客户端，该报文也不包含应用层数据。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文（<strong>确认序列</strong>（server_isn +1），<code>ACK</code>置1），这次报文<strong>可以携带客户到服务器的数据</strong>，之后客户端处于建立连接状态。</li><li>服务器收到客户端的应答报文后，也进入建立连接状态。</li></ul><p><strong>为什么三次？</strong></p><p><strong>因为三次握手才能保证双方具有接收和发送的能力</strong>。</p><p><strong>序列号能够保证数据包不重复、不丢弃和按序传输。</strong></p><p><strong>通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。</strong></p><p>不使用<strong>两次握手</strong>和<strong>四次握手</strong>的原因:</p><ul><li>两次握手︰<strong>无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号</strong>;</li><li>四次握手︰三次握手就已经<strong>理论上最少可靠连接建立</strong>，所以不需要使用更多的通信次数。</li></ul><h3 id="TCP四次挥手-★"><a href="#TCP四次挥手-★" class="headerlink" title="TCP四次挥手 ★"></a>TCP四次挥手 ★</h3><p><strong>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</strong></p><ul><li>客户端打算关闭连接，此时会发送<code>FIN</code>报文（<code>FIN</code>置1），之后客户端进入<code>FIN_WAIT_1</code>状态。</li><li>服务端收到该报文后，就向客户端发送<code>ACK</code>应答报文，接着服务端进入<code>CLOSED_WAIT</code>状态；客户端收到服务端的<code>ACK</code>应答报文后，之后进入<code>FIN_WAIT_2</code>状态。</li><li>等待<strong>服务端处理完数据后</strong>，也向客户端发送<code>FIN</code> 报文，之后服务端进入<code>LAST_ACK</code>状态。</li><li>客户端收到服务端的<code>FIN</code> 报文后，回一个<code>ACK</code>应答报文，之后进入<code>TIME_WAIT</code>状态。</li><li>服务器收到了<code>ACK</code>应答报文后，就完成连接的关闭。</li><li>客户端在经过<code>2MSL</code>一段时间后，自动进入关闭状态。</li></ul><p><strong>主动关闭连接的，才有TIME_WAIT状态</strong>。</p><p><strong>为什么挥手需要四次</strong>?</p><p>再来回顾下四次挥手双方发FIN 包的过程，就能理解为什么需要四次了。</p><ul><li>关闭连接时，客户端向服务端发送<code>FIN</code> 时，仅仅表示<strong>客户端不再发送数据了但是还能接收数据</strong>。</li><li>服务器收到客户端的<code>FIN</code>报文时，先回一个<code>ACK</code>应答报文，而服务端可能还有数据需要处理和发送，等<br>服务端不再发送数据时，才发送<code>FIN</code>报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，<strong>服务端通常需要等待完成数据的发送和处理</strong>，所以服务端的<code>ACK</code>和 <code>FIN</code>一般都会分开发送，从而比三次握手导致多了一次。</p><p><code>MSL</code>是<code>Maximum Segment Lifetime</code>，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><p>经过<code>2MSL</code>这个时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><p><code>TIME-WAIT</code>更重要的作用是<strong>等待足够的时间以确保最后的ACK能让被动关闭方接收，从而帮助其正常关闭</strong>。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP：<strong>超文本传输协议</strong>。</p><p><strong>HTTP是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><p><strong>请求报文包括：</strong></p><ul><li><strong>请求行</strong>：包括<strong>请求方法</strong>、<strong>请求的URL</strong>、<strong>HTTP协议及版本</strong>。</li><li><strong>请求头</strong>：一大堆的键值对。</li><li><strong>空行</strong>指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。</li><li><strong>请求体</strong>：数据部分。</li></ul><p>响应报文包括：</p><ul><li><strong>状态行</strong>：<strong>HTTP协议及版本</strong>、<strong>状态码</strong>及<strong>状态描述</strong>。</li><li><strong>响应头</strong></li><li><strong>空行</strong></li><li><strong>响应体</strong></li></ul><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p><strong>1xx</strong>类状态码属于<strong>提示信息</strong>，是协议处理中的一种<strong>中间状态</strong>，实际用到的比较少。</p><p><strong>2xx</strong>类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li><strong>200 OK</strong> 是最常见的成功状态码，表示一切正常。</li></ul><p><strong>3xx</strong>类状态码表示客户端请求的资源发送了变动，需要客户端用新的URL重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li><p><strong>301 Moved Permanently</strong> 表示<strong>永久重定向</strong>，说明请求的资源已经不存在了，需改用新的URL再次访问。</p></li><li><p><strong>302 Found</strong> 表示<strong>临时重定向</strong>，说明请求的资源还在，但暂时需要用另一个URL来访问。</p><ul><li><strong>301</strong>和<strong>302</strong>都会在响应头里使用字段<strong>Location</strong>，指明后续要跳转的URL，浏览器会自动重定向新的URL。</li></ul></li><li><p><strong>304 Not Modified</strong> 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称<strong>缓存重定向</strong>，用于缓存控制。</p></li></ul><p><strong>4xx</strong>类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是<strong>错误码</strong>的含义。</p><ul><li><strong>400 Bad Request</strong> 表示客户端请求的报文有错误，但只是个笼统的错误</li><li><strong>403 Forbidden</strong> 表示<strong>服务器禁止访问资源</strong>，并不是客户端的请求出错。</li><li><strong>404 Not Found</strong> 表<strong>示请求的资源在服务器上不存在或未找到</strong>，所以无法提供给客户端。</li></ul><p><strong>5xx</strong>类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于<strong>服务器端的错误码</strong>。</p><p>项目静态网页状态码 <code>404 &amp; 405</code></p><p><strong>405 Method Not Allowed</strong>表明服务器禁止了使用当前 HTTP 方法的请求。绝大多数web服务器，都不允许静态文件响应POST请求。</p><h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><p><strong>根据场景合理使用各个方法，可以起到优化性能、增加网络安全的效果。</strong></p><h4 id="GET-与-POST-★"><a href="#GET-与-POST-★" class="headerlink" title="GET 与 POST ★"></a>GET 与 POST ★</h4><p><code>GET</code>方法的含义是<strong>请求从服务器获取资源</strong>，这个资源可以是静态的文本、页面、图片视频等。</p><p>而<code>POST</code>方法则是相反操作，它向<code>URI</code>指定的资源提交数据，数据就放在报文的<code>body</code>里。</p><h5 id="参数传递方式"><a href="#参数传递方式" class="headerlink" title="参数传递方式"></a>参数传递方式</h5><ul><li>GET 的参数一般是通过 <code>?</code> 跟在 URL 后面的，多个参数通过 <code>&amp;</code> 连接</li><li>POST 的参数一般是包含在请求体中。</li></ul><h5 id="参数长度限制不同"><a href="#参数长度限制不同" class="headerlink" title="参数长度限制不同"></a>参数长度限制不同</h5><p>GET 和 POST 传递参数的长度不同：</p><ul><li>get传送的数据量较小，不能大于2KB。</li><li>post传送的数据量较大，一般被默认为不受限制。</li></ul><p>在这里我们要明确一点：<strong>HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。</strong></p><p>服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。</p><h5 id="安全和幂等"><a href="#安全和幂等" class="headerlink" title="安全和幂等"></a>安全和幂等</h5><ul><li>在HTTP 协议里，<strong>所谓的「安全」是指请求方法不会「破坏」服务器上的资源</strong>。</li><li><strong>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</strong></li></ul><p>那么很明显<strong>GET方法就是安全且幂等</strong>的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</p><p><strong>POST</strong>因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等的</strong>。</p><h5 id="安全性不同（传输的角度）"><a href="#安全性不同（传输的角度）" class="headerlink" title="安全性不同（传输的角度）"></a>安全性不同（传输的角度）</h5><p>因为参数传递方式的不同，所以 GET 和 POST 的安全性不同：GET 比 POST 更不安全，因为参数直接暴露在URL上，所以 GET 不能用来传递敏感信息。</p><blockquote><p>从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上抓包，就能完整地获取数据报文，要想安全传输，就只有加密，也就是 HTTPS。</p></blockquote><h5 id="缓存机制不同"><a href="#缓存机制不同" class="headerlink" title="缓存机制不同"></a>缓存机制不同</h5><p>这个需要从以下几点来说明：</p><ul><li>GET 请求会<strong>被浏览器主动cache</strong>，而 POST 不会，除非手动设置。</li><li>GET 请求参数<strong>会被完整保留在浏览器历史记录里</strong>，而 POST 中的参数不会被保留。</li><li>GET 在<strong>浏览器回退时是无害的</strong>，而 POST 会再次提交请求。</li></ul><h5 id="时间消耗不同"><a href="#时间消耗不同" class="headerlink" title="时间消耗不同"></a>时间消耗不同</h5><p>GET 和 POST 请求时间的不同主要是因为：</p><ul><li>GET 产生<strong>一个</strong> TCP 数据包；</li><li>POST 产生<strong>两个</strong> TCP 数据包。</li></ul><p>对于 GET 方式的请求，浏览器会把 <strong>header 和 data</strong> 一并发送出去，服务器响应 200（返回数据）；而对于 POST，浏览器先发送 <strong>header</strong>，服务器响应 <strong>100 continue</strong>，浏览器再发送 <strong>data</strong>，服务器响应 200 ok（返回数据）。</p><p>在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，<strong>两次包的TCP在验证数据包完整性上，有非常大的优点</strong>。</p><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将不传回资源的本文部分，只返回<strong>头部消息</strong>。</p><p>HEAD 方法的使用场景</p><ul><li>在不获取资源的情况下，了解资源的一些信息，比如资源类型；</li><li>通过查看响应中的状态码，可以确定资源是否存在；</li><li>通过查看首部，测试资源是否被修改。</li></ul><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>PUT 方法用于将数据发送到服务器来创建/更新资源。</p><p>PUT 与 POST 方法的区别在于，<strong>PUT 方法是幂等的</strong>：<strong>调用一次与连续调用多次是等价的（即没有副作用）</strong>。</p><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>DELETE 方法就是请求服务器删除指定 URL 所对应的资源。</p><h3 id="HTTP头部"><a href="#HTTP头部" class="headerlink" title="HTTP头部"></a>HTTP头部</h3><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p><strong><code>Accept</code></strong> 请求头用来告知（服务器）客户端可以处理的内容类型，这种内容类型用MIME 类型来表示。借助内容协商机制，服务器可以从诸多备选项中选择一项进行应用，并使用 <code>Content-Type</code>应答头通知客户端它的选择。浏览器会基于请求的上下文来为这个请求头设置合适的值，比如获取一个 CSS 层叠样式表时值与获取图片、视频或脚本文件时的值是不同的。</p><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p><strong>Connection</strong> 头（header） 决定当前的事务完成后，是否会关闭网络连接。如果该值是“keep-alive”，网络连接就是持久的，不会关闭，使得对同一个服务器的请求可以继续在该连接上完成。</p><p><strong>备注：</strong> 特定于连接的标头字段（例如 Connection）不得与 HTTP/2 一起使用。</p><p>以逗号分隔的 HTTP 头 [通常仅有 <code>keep-alive</code>]</p><p>表明客户端想要保持该网络连接打开，HTTP/1.1 的请求默认使用一个持久连接。这个请求头列表由头部名组成，这些头将被第一个非透明的代理或者代理间的缓存所移除：这些头定义了发出者和第一个实体之间的连接，而不是和目的地节点间的连接。</p><h4 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h4><p><strong><code>Keep-Alive</code></strong> 是一个通用消息头，允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数。</p><p><strong>备注：</strong> 需要将 <code>Connection</code>]首部的值设置为 “keep-alive” 这个首部才有意义。同时需要注意的是，在 HTTP/2 协议中， <code>Connection</code>和<code>Keep-Alive</code> 是被忽略的；在其中采用其他机制来进行连接管理。</p><p><em>parameters</em></p><p>一系列用逗号隔开的参数，每一个参数由一个标识符和一个值构成，并使用等号 (<code>&#39;=&#39;</code>) 隔开。下述标识符是可用的：</p><ul><li><code>timeout</code>：指定了一个空闲连接需要保持打开状态的最小时长（以秒为单位）。需要注意的是，如果没有在传输层设置 keep-alive TCP message 的话，大于 TCP 层面的超时设置会被忽略。</li><li><code>max</code>：在连接关闭之前，在此连接可以发送的请求的最大值。在非管道连接中，除了 0 以外，这个值是被忽略的，因为需要在紧跟着的响应中发送新一次的请求。HTTP 管道连接则可以用它来限制管道的使用。</li></ul><h3 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h3><p><strong>简单<code>header（key-value） + body</code>、灵活和易于扩展（应用层(OSI第七层)，下层可随意变化）、应用广泛和跨平台</strong>。</p><p><strong>无状态</strong></p><ul><li><strong>不需要额外的资源来记录状态信息</strong></li><li>完成<strong>有关联性的操作</strong>时会非常麻烦</li></ul><p><strong>明文传输</strong></p><ul><li><strong>调试</strong>工作带了极大的便利性</li><li>毫<strong>无隐私</strong>可言，很容易就能被<strong>窃取</strong></li></ul><p>HTTP比较严重的缺点就是<strong>不安全:</strong></p><ul><li>**通信使用明文（不加密)**，内容可能会被窃听。</li><li><strong>不验证通信方的身份</strong>，因此有可能遭遇伪装。</li><li><strong>无法证明报文的完整性</strong>，所以有可能已遭篡改。</li></ul><p>HTTP的安全问题，可以用<strong>HTTPS</strong>的方式解决，也就是通过引入<strong>SSL/TLS</strong>层，使得在安全上达到了极致。</p><h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><ul><li>HTTP是<strong>超文本传输协议</strong>，信息是<strong>明文传输</strong>，存在安全风险的问题。HTTPS则解决HTTP不安全的缺陷，<strong>在TCP和HTTP之间加入了SSL/TLS安全协议</strong>，使得报文能够<strong>加密</strong>传输。</li><li>HTTP 连接建立相对简单，<strong>TCP三次握手</strong>之后便可进行HTTP的报文传输。而 HTTPS在<strong>TCP三次握手</strong>之后，还需进行<strong>SSL/TLS的握手</strong>过程，才可进入加密报文传输。</li><li>HTTP的端口号是<strong>80</strong>，HTTPS的端口号是<strong>443</strong>。</li><li>HTTPS 协议需要<strong>向CA(证书权威机构）申请数字证书</strong>，来保证服务器的身份是可信的。</li></ul><blockquote><p>SSL和TLS？</p></blockquote><p>这两实际上是一个东西。很多相关的文章都把这两者并列称呼(SSL/TLS)，因为这两者可以视作<strong>同一个东西的不同阶段</strong>。</p><h4 id="HTTPS优点"><a href="#HTTPS优点" class="headerlink" title="HTTPS优点"></a>HTTPS优点</h4><h5 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h5><p>HTTPS采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的<strong>混合加密</strong>方式，保证信息的<strong>机密性</strong>，解决了窃听的风险:</p><ul><li>在<strong>通信建立前</strong>采用<strong>非对称加密</strong>的方式<strong>交换</strong>「会话秘钥」，后续就不再使用非对称加密。</li><li>在<strong>通信过程中</strong>全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul><p>采用「混合加密」的方式的原因:</p><blockquote><p>对称加密：加密和解密使用的是同一个密钥。</p><p>RSA（非对称加密算法）：双方必须协商一对密钥，一个私钥一个公钥。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。</p></blockquote><p>对称加密运算速度快，但最开始仍可能被拦截，发送信息依然不安全，非对称加密足够安全，但运算速度慢。</p><p><strong>使用非对称加密的方法将加密算法的对称密钥发送过去</strong>，之后就可以使用使用这个密钥，利用<strong>对称密钥</strong>来通信了。</p><h5 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h5><p><strong>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</strong></p><p><strong>如何保证公钥不被篡改和信任度?</strong></p><p>所以这里就需要借助第三方权威机构<code>CA</code>(数字证书认证机构)﹐将<strong>服务器公钥放在数字证书</strong>（由数字证书认证机构颁发)中，只要证书是可信的，公钥就是可信的。</p><h5 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h5><p><strong>摘要算法</strong>用来实现<strong>完整性</strong>，能够为数据生成独一无二的<strong>指纹</strong>﹐用于校验数据的完整性，解决了<strong>篡改</strong>的风险。</p><p>客户端在发送明文之前会通过<strong>摘要算法</strong>算出明文的<strong>指纹</strong>，发送的时候把<strong>指纹＋明文</strong>一同加密成密文后，发送给服务器，服务器解密后，用<strong>相同的摘要算法</strong>算出发送过来的明文，通过比较客户端携带的<strong>指纹</strong>和当前算出的<strong>指纹</strong>做比较，若<strong>指纹</strong>相同，说明数据是完整的。</p><h4 id="HTTPS连接"><a href="#HTTPS连接" class="headerlink" title="HTTPS连接"></a>HTTPS连接</h4><p>SSL/TLS协议基本流程∶</p><ul><li><strong>客户端向服务器索要并验证服务器的公钥</strong>。</li><li>双方协商生产<strong>会话秘钥</strong>。</li><li>双方采用<strong>会话秘钥</strong>进行加密通信。</li></ul><p>前两步也就是SSL/TLS的建立过程，也就是握手阶段。</p><p>整个SSL/TLS的握手阶段全部结束后，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用<strong>会话秘钥加密内容。</strong></p><p>SSL/TLS 1.2需要4次握手，SSL/TLS 1.3优化了过程，<strong>只需要3次握手</strong>。</p><h3 id="HTTP-1-1、HTTP-2、HTTP-3演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3演变" class="headerlink" title="HTTP/1.1、HTTP/2、HTTP/3演变"></a>HTTP/1.1、HTTP/2、HTTP/3演变</h3><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><p>HTTP/1.1相比HTTP/1.0性能上的改进︰</p><ul><li>使用TCP<strong>长连接</strong>的方式改善了<strong>HTTP/1.0短连接</strong>造成的性能开销。<ul><li><strong>减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载</strong>。</li><li><strong>只要任意一端没有明确提出断开连接，则保持TCP连接状态。</strong></li></ul></li><li>支持<strong>管道（pipeline)网络传输</strong>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li><li>缓存<code>Etag</code></li></ul><p>但HTTP/1.1还是有性能瓶颈︰</p><ul><li><strong>请求/响应头部(Header)未经压缩就发送</strong>，首部信息越多延迟越大。只能压缩<code>Body</code>的部分;</li><li><strong>服务器是按请求的顺序响应的</strong>，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>;</li><li><strong>没有请求优先级控制</strong>;</li><li>请求只能从客户端开始，<strong>服务器只能被动响应</strong>。</li></ul><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p><strong>HTTP/2协议是大多基于HTTPS的，所以HTTP/2的安全性也是有保障的。</strong></p><p>那HTTP/2相比HTTP/1.1 性能上的改进︰</p><ul><li><strong>头部压缩</strong>（HPACK算法）</li><li><strong>二进制格式</strong> 增加了数据传输的效率</li><li><strong>数据流</strong><ul><li>HTTP/2的数据包<strong>不是按顺序发送的</strong>，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</li><li>每个请求或回应的所有数据包，称为一个数据流（<strong>Stream</strong> )。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。</li><li>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</li></ul></li><li><strong>多路复用</strong><ul><li>HTTP/2是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。</li><li>移除了HTTP/1.1中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。</li></ul></li><li><strong>服务器推送</strong><ul><li>HTTP/2还在一定程度上改善了传统的「请求-应答」工作模式，服务不再是被动地响应，<strong>也可以主动向客户端发送消息</strong>。</li><li>举例来说，在浏览器刚请求HTML的时候，就提前把可能会用到的JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送(<strong>Server Push</strong>，也叫<strong>Cache Push</strong>)。</li></ul></li></ul><h4 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h4><p>HTTP/2主要的问题在于，<strong>多个HTTP请求在复用一个TCP连接</strong>，下层的TCP协议是不知道有多少个HTTP请求的。</p><p>所以<strong>一旦发生了丢包现象，就会触发TCP的重传机制</strong>，这样在一个TCP连接中的<strong>所有的HTTP请求都必须等待这个丢了的包被重传回来</strong>。</p><ul><li>HTTP/1.1中的管道（pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了。</li><li>HTTP/2多个请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的HTTP请求。</li></ul><p>这都是<strong>基于TCP传输层</strong>的问题，所以<strong>HTTP/3把HTTP下层的TCP协议改成了UDP</strong>!</p><p>UDP是<strong>不管顺序，也不管丢包的</strong>，所以<strong>不会出现HTTP/1.1的队头阻塞和HTTP/2的一个丢包全部重传问题</strong>。</p><p>大家都知道UDP是不可靠传输的，但<strong>基于UDP的QUIC协议可以实现类似TCP的可靠性传输</strong>。</p><ul><li>QUIC有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，<strong>其他流不会受到影响</strong>。</li><li>TLS3升级成了最新的<strong>1.3</strong>版本，头部压缩算法也升级成了<strong>QPack</strong> 。</li><li>HTTPS要建立一个连接，要花费6次交互，先是建立三次握手，然后是TLS/1.3的三次握手。QUIC直接把以往的TCP和 TLS/1.3的6次交互<strong>合并成了3次，减少了交互次数</strong>。</li></ul><p>所以，QUIC是一个在UDP之上的<strong>伪</strong>TCP+ TLS+ HTTP/2的多路复用的协议。</p><p>QUIC是新协议，对于很多网络设备，根本不知道什么是QUIC，只会当做UDP，这样会出现新的问题。所以HTTP/3现在普及的进度非常的缓慢，不知道未来UDP是否能够逆袭TCP。</p><p>QUIC 全称：Quick UDP Internet Connections，是一种基于 UDP 的传输层协议。由 Google 自研，2012 年部署上线，2013 年提交 IETF，2021 年 5 月，IETF 推出标准版 RFC9000。</p><p>从协议栈可以看出：QUIC = HTTP/2 + TLS + UDP</p><h2 id="为什么端口号最大为65535？"><a href="#为什么端口号最大为65535？" class="headerlink" title="为什么端口号最大为65535？"></a>为什么端口号最大为65535？</h2><p>端口是 TCP/IP 协议中，IP 层的一个概念。</p><p>在 IP 层（也就是网络层），远程通信的两个节点，通过端口找到对应的处理程序。</p><p>而 IP 协议中端口是一个 2字节的 unsighed char 的长度，其最大值是 2^16 -1 = 65535</p><p>此时端口的字段用二进制表示为16个1： 1111,1111,1111,1111</p><p>TCP/IP协议中的服务端口，端口号由16位构成，可分配的端口号范围是0~65535。这些端口号分为知名端口号以及动态端口号。其中，知名端口号（Well-Known Ports）默认是不可使用，范围从0到1023，这些端口号一般固定分配给一些系统服务。动态端口号（Dynamic Ports），范围从1024到65535可以随机分配给某些网络或系统服务。</p><p>端口0：一般是用来表示所有端口，即1–65535。</p><p>另外其他答主也提到1–1024是知名端口号，但那是很久以前数据，是该更新了。举几个大于1024的知名端口号：</p><blockquote><p>1614/1615：思科ISE用于AAA的端口号<br>1812/1813：Radius服务器使用的端口号<br>3306：数据库mysql使用的端口号<br>3389：微软Windows远程桌面使用的端口号<br>8080：一般的应用服务器使用的端口号，例如tomcat</p></blockquote><p>因此，还觉得知名端口号，范围是1–1024吗？在实际使用中，</p><blockquote><p>对于tcp，客户端使用的临时端口号，一般都是大于10000的。<br>对于udp，客户端使用的临时端口号，可以从大于10000中选，也可以使用跟服务器一样的端口号。</p></blockquote><h2 id="跨域通信"><a href="#跨域通信" class="headerlink" title="跨域通信"></a>跨域通信</h2><blockquote><p>考察公司：完美世界、字节、美团、百度、腾讯</p></blockquote><h3 id="同源-跨域"><a href="#同源-跨域" class="headerlink" title="同源/跨域"></a>同源/跨域</h3><p><strong>同源策略</strong>：用于隔离潜在恶意文件的安全机制。</p><p>同源是指”<strong>协议</strong>+<strong>域名</strong>+<strong>端口</strong>“三者相同，<strong>即便两个不同的域名指向同一个ip地址，也非同源</strong>。</p><p><strong>同源策略限制内容有：</strong></p><ul><li><code>Cookie</code>、<code>LocalStorage</code>、<code>IndexedDB</code> 等存储性内容</li><li><code>DOM</code> 节点</li><li><code>AJAX</code> 请求</li></ul><p>但是有的标签是允许跨域加载资源：</p><ul><li><code>&lt;img src=XXX&gt;</code></li><li><code>&lt;link href=XXX&gt;</code></li><li><code>&lt;script src=XXX&gt;</code></li></ul><p>当协议、域名、端口号中任意一个不相同时，都算作不同域。</p><p><strong>不同域之间相互请求资源，就算作“跨域”</strong>。</p><p>跨域并<strong>不是请求发不出去</strong>，请求能发出去，服务端能收到请求并正常返回结果，只是结果<strong>被浏览器拦截</strong>了。</p><h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h3><h4 id="JSONP（JSON-with-Padding）"><a href="#JSONP（JSON-with-Padding）" class="headerlink" title="JSONP（JSON with Padding）"></a>JSONP（JSON with Padding）</h4><p>JS函数包裹JSON数据。</p><p>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。</p><p>JSONP请求一定需要对方的服务器做支持才可以。</p><p><code>&lt;script&gt;</code> 标签中type的默认属性是<code>text/javascript</code>,<strong>会把收到的文本内容当成JS代码进行执行</strong>。</p><p>优点：简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。</p><p>缺点：仅支持<code>get</code>方法；不安全，可能会遭受<code>XSS</code>攻击。</p><p><strong>JSONP的实现流程</strong></p><ul><li>声明一个回调函数，将函数名(如<code>handle</code>)当做参数值传递给跨域请求数据的服务器，函数形参为要获取的目标数据(服务器返回的<code>data</code>)。</li><li>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给<code>&lt;script&gt;</code>的<code>src</code>，还要在这个地址中向服务器传递该函数名（可以通过问号传参:<code>?callback=handle</code>）。</li><li>服务器接收到请求后，需要进行特殊的处理：把<strong>传递进来的函数名</strong>和它需要给你的<strong>数据</strong>拼接成一个<strong>字符串</strong>（模板字符串）。</li><li>最后服务器把该字符串返回给客户端，客户端接收到后相当于执行之前声明的回调函数（<code>handle</code>），对返回的数据进行操作。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Live Sever  本地服务器</span></span><br><span class="line"><span class="comment">//获取 input和p元素</span></span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="comment">//声明回调函数 接收后台返回数据</span></span><br><span class="line"><span class="comment">//注意  jsonp返回的数据是json对象可以直接使用</span></span><br><span class="line"><span class="comment">// 例如服务器的json字符串为 &#x27;&#123;&quot;msg&quot;:&quot;用户名设置成功&quot;&#125;&#x27;</span></span><br><span class="line"><span class="comment">// 实际返回的字符串 &#x27;handle(&#123;&quot;msg&quot;:&quot;用户名设置成功&quot;&#125;)&#x27;</span></span><br><span class="line"><span class="comment">// 浏览器接收后，执行handle(&#123;&quot;msg&quot;:&quot;用户名设置成功&quot;&#125;)</span></span><br><span class="line"><span class="comment">// 此时的参数就是一个json对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//修改 p 标签的提示文本</span></span><br><span class="line">    p.innerHTML = data.msg;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取用户的输入值</span></span><br><span class="line">    <span class="keyword">let</span> username = input.value;</span><br><span class="line">    <span class="built_in">console</span>.log(username)</span><br><span class="line">    <span class="comment">//向服务器端发送请求 检测用户名是否存在</span></span><br><span class="line">    <span class="comment">//1. 创建 script 标签</span></span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    <span class="comment">//2. 设置标签的 src 属性</span></span><br><span class="line">    script.src = <span class="string">`http://127.0.0.1:8000/jsonp-server?name=<span class="subst">$&#123;username&#125;</span>&amp;callback=handle`</span>;</span><br><span class="line">    <span class="comment">//3. 将 script 插入到文档中</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 服务器</span></span><br><span class="line"><span class="comment">//1. 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">//2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="comment">//3. 创建路由规则</span></span><br><span class="line"><span class="comment">// request 是对请求报文的封装</span></span><br><span class="line"><span class="comment">// response 是对响应报文的封装</span></span><br><span class="line"><span class="comment">//jsonp服务</span></span><br><span class="line"><span class="keyword">const</span> username=[];</span><br><span class="line">app.all(<span class="string">&#x27;/jsonp-server&#x27;</span>,<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;name,callback&#125; = request.query;</span><br><span class="line">    <span class="keyword">const</span> data = &#123;<span class="attr">msg</span>:<span class="string">&quot;用户名设置成功&quot;</span>&#125;;      </span><br><span class="line">    username.includes(name) ? data.msg=<span class="string">&quot;用户名已存在&quot;</span> : username.push(name);</span><br><span class="line">    <span class="built_in">console</span>.log(username)</span><br><span class="line">    <span class="comment">//将数据转化为字符串</span></span><br><span class="line">    <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    response.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 监听端口启动服务</span></span><br><span class="line">app.listen(<span class="number">8000</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务已经启动, 8000 端口监听中....&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS（Cross-Origin Resource Sharing），跨域资源共享。</p><p>CORS是官方的跨域解决方案，需要浏览器和后端同时支持。</p><p>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 CORS。</p><p>该属性表示哪些域名可以访问资源，如果设置通配符<code>*</code>则表示所有网站都可以访问资源。</p><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><ul><li>请求方法是 <code>HEAD</code>、<code>GET</code>、<code>POST</code> 三种之一；</li><li>HTTP 头信息不超过右边着几个字段：<ul><li><code>Accept</code>、</li><li><code>Accept-Language</code>、</li><li><code>Content-Language</code>、</li><li><code>Last-Event-ID</code></li><li><code>Content-Type</code> 只限于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>；</li></ul></li></ul><p>需要这些条件是为了<strong>兼容表单</strong>，因为历史上表单一直可以跨域。</p><p>浏览器直接发出<strong>CORS请求</strong>，具体来说就是在头信息中增加<code>Origin</code>字段，表示请求来源来自哪个域(协议+域名+端口)，服务器根据这个值决定是否同意请求。如果同意，返回的响应会多出以下响应头信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//juejin.com // 和 Orign 一致  这个字段是必须的</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span> <span class="comment">// 表示是否允许发送 Cookie  这个字段是可选的</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar <span class="comment">// 指定返回其他字段的值   这个字段是可选的</span></span><br></pre></td></tr></table></figure><p>在简单请求中服务器至少需要设置：<code>Access-Control-Allow-Origin</code> 字段。</p><h5 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h5><ul><li><p>不符合以上条件的请求，比如请求方法是 <code>PUT</code> 或 <code>DELETE</code>，或 <code>Content-Type</code> 值为 <code>application/json</code>。</p></li><li><p>浏览器会在正式通信之前，发送一次 <strong>HTTP 预检</strong> <code>OPTIONS</code> 请求，先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 请求方法和头信息字段（服务器返回的响应头会包含允许的域名、方法等）。只有得到肯定答复，浏览器才会发出正式的 <code>XHR</code> 请求，否则报错。</p></li><li><p>预检请求的方法是<code>OPTIONS</code>，它的头信息中有几个字段</p><ul><li><code>Origin</code>: 表示请求来自哪个域，这个字段是必须的</li><li><code>Access-Control-Request-Method</code>：列出CORS请求会用到哪些HTTP方法，这个字段是必须的</li><li><code>Access-Control-Request-Headers</code>： 指定CORS请求会额外发送的头信息字段，用逗号隔开</li></ul></li><li><p>OPTIONS请求次数过多也会损耗性能，所以要尽量减少OPTIONS请求，可以让服务器在请求返回头部添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Max-Age: <span class="built_in">Number</span> <span class="comment">// 数字 单位是秒</span></span><br></pre></td></tr></table></figure><p>表示<strong>预检请求的返回结果可以被缓存多久</strong>，在这个时间范围内再请求就不需要预检了。不过这个缓存只对完全一样的URL才会生效。</p></li></ul><h5 id="关于CORS的-cookie-问题"><a href="#关于CORS的-cookie-问题" class="headerlink" title="关于CORS的 cookie 问题"></a>关于CORS的 cookie 问题</h5><p>想要传递 <code>cookie</code> 需要满足 3 个条件</p><ul><li>web 请求设置<code>withCredentials</code></li></ul><p>这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 <code>withCredentials</code> 来进行传递 <code>cookie</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 xml 的设置方式</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// axios 设置方式</span></span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li><code>Access-Control-Allow-Credentials</code> 为 <code>true</code></li><li><code>Access-Control-Allow-Origin</code>为<strong>非</strong> <code>*</code></li></ul><h5 id="CORS完整复杂请求的例子"><a href="#CORS完整复杂请求的例子" class="headerlink" title="CORS完整复杂请求的例子"></a>CORS完整复杂请求的例子</h5><p>客户端 <code>http://127.0.0.1:5500</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="built_in">document</span>.cookie=<span class="string">&quot;name=leslie&quot;</span>;<span class="comment">// cookie不能跨域</span></span><br><span class="line">    xhr.withCredentials=<span class="literal">true</span>;<span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">    xhr.open(<span class="string">&#x27;PUT&#x27;</span>,<span class="string">&#x27;http://127.0.0.1:8000/cors&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">    xhr.setRequestHeader(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;leslie&#x27;</span>);</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((xhr.status&gt;=<span class="number">200</span> &amp;&amp; xhr.status&lt;<span class="number">300</span>) || xhr.status === <span class="number">304</span>)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(xhr.response);</span><br><span class="line">                <span class="comment">//得到响应头，后台需设置Access-Control-Expose-Headers</span></span><br><span class="line">                <span class="built_in">console</span>.log(xhr.getResponseHeader(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>服务器 <code>http://127.0.0.1:8000</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">//2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="comment">// 把server.js文件所在的目录设置为静态文件目录</span></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line"><span class="comment">//3. 创建路由规则</span></span><br><span class="line"><span class="comment">// request 是对请求报文的封装</span></span><br><span class="line"><span class="comment">// response 是对响应报文的封装</span></span><br><span class="line"><span class="comment">//CORS</span></span><br><span class="line"><span class="keyword">let</span> whitList = [<span class="string">&#x27;http://127.0.0.1:5500&#x27;</span>] <span class="comment">//设置白名单</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> origin = req.headers.origin</span><br><span class="line">    <span class="keyword">if</span> (whitList.includes(origin)) &#123;</span><br><span class="line">        <span class="comment">// 设置哪个源可以访问我</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, origin)</span><br><span class="line">        <span class="comment">// 允许携带哪个头访问我</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        <span class="comment">// 允许哪个方法访问我</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>)</span><br><span class="line">        <span class="comment">// 允许携带cookie</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">        <span class="comment">// 预检的存活时间</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Max-Age&#x27;</span>, <span class="number">6</span>)</span><br><span class="line">        <span class="comment">// 允许返回的头</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (req.method === <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">            res.end() <span class="comment">// OPTIONS请求不做任何处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.put(<span class="string">&#x27;/cors&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.headers)</span><br><span class="line">    res.setHeader(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;lw&#x27;</span>) <span class="comment">//返回一个响应头，后台需设置</span></span><br><span class="line">    res.end(<span class="string">&#x27;我不爱你&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//4. 监听端口启动服务</span></span><br><span class="line">app.listen(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务已经启动, 8000 端口监听中....&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第三方中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>);</span><br><span class="line"><span class="comment">//2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="comment">//CORS</span></span><br><span class="line">app.use(</span><br><span class="line">  cors(&#123;</span><br><span class="line">    <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;http://127.0.0.1:5500&quot;</span>,</span><br><span class="line">    <span class="string">&quot;methods&quot;</span>: <span class="string">&quot;GET,HEAD,PUT,PATCH,POST,DELETE&quot;</span>,</span><br><span class="line">    <span class="string">&quot;allowedHeaders&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">    <span class="string">&quot;exposedHeaders&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">    <span class="string">&quot;credentials&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;maxAge&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="comment">// &quot;preflightContinue&quot;: true,</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>简单的说，一般给<strong>客户端</strong>做代理的都是正向代理，给<strong>服务器</strong>做代理的就是反向代理。</p><h5 id="Node中间件代理"><a href="#Node中间件代理" class="headerlink" title="Node中间件代理"></a>Node中间件代理</h5><p>同源策略是<strong>浏览器</strong>需要遵循的标准，而如果是<strong>服务器向服务器</strong>请求就无需遵循同源策略。</p><p>代理的思路为，<strong>利用服务端请求不会跨域的特性，让接口和当前站点同域</strong>。</p><h5 id="React中配置代理"><a href="#React中配置代理" class="headerlink" title="React中配置代理"></a>React中配置代理</h5><p>在<code>package.json</code>中追加如下配置 :<code>&quot;proxy&quot;:http://localhost:5000</code></p><p>setupProxy.js <code>http-proxy-middleware</code> 配置多个代理，可以灵活的控制请求是否走代理。</p><h5 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h5><p>配置一个代理服务器向服务器请求，再将数据返回给客户端，实质和CORS跨域原理一样，也需要配置请求响应头Access-Control-Allow-Origin等字段，只不过是在代理服务器配置。</p><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p><code>WebSocket</code>是<code>HTML5</code>的一个持久化的协议，它实现了<strong>浏览器与服务器的全双工通信</strong>，同时也是跨域的一种解决方案。</p><p><code>WebSocket</code>和<code>HTTP</code>都是<strong>应用层协议</strong>，都基于 <code>TCP</code> 协议。</p><p>但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。</p><p>同时，<code>WebSocket</code> 在建立连接时需要借助 <code>HTTP</code> 协议，连接建立好了之后 <code>client</code> 与 <code>server</code> 之间的双向通信就与 <code>HTTP</code> 无关了。</p><h5 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h5><p>客户端 <code>http://127.0.0.1:5500</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:4000&#x27;</span>);</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    socket.send(<span class="string">&#x27;我爱你&#x27;</span>);<span class="comment">//向服务器发送数据</span></span><br><span class="line">&#125;</span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data);<span class="comment">//接收服务器返回的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器 <code>http://localhost:4000</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);<span class="comment">//记得安装ws</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123;<span class="attr">port</span>:<span class="number">4000</span>&#125;);</span><br><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  ws.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    ws.send(<span class="string">`<span class="subst">$&#123;data&#125;</span>我不爱你`</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h4><p><code>postMessage</code>是<code>HTML5 XMLHttpRequest Level 2</code>中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li><strong>页面和其打开的新窗口</strong>的数据传递</li><li><strong>多窗口</strong>之间消息传递</li><li><strong>页面与嵌套的iframe</strong>消息传递</li></ul><p>上面三个场景的跨域数据传递。</p><p>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin, [transfer]);</span><br></pre></td></tr></table></figure><ul><li><code>message</code>: 将要发送到其他window的数据。</li><li><code>targetOrigin</code>:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”<code>*</code>“（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配<code>targetOrigin</code>提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li><li><code>transfer</code>(可选)：是一串和<code>message</code> 同时传递的 <code>Transferable</code> 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><h4 id="简单例子-1"><a href="#简单例子-1" class="headerlink" title="简单例子"></a>简单例子</h4><p>客户端 <code>http://127.0.0.1:5500</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 等它加载完触发一个事件 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内嵌在http://localhost:5500/index.html --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:8000&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">id</span>=<span class="string">&quot;frame&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;load()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;frame&#x27;</span>)</span></span><br><span class="line"><span class="javascript">            frame.contentWindow.postMessage(<span class="string">&#x27;我爱你&#x27;</span>, <span class="string">&#x27;http://localhost:4000&#x27;</span>) <span class="comment">//发送数据</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; <span class="comment">//接受返回数据</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(e.data) <span class="comment">//我不爱你</span></span></span><br><span class="line"><span class="javascript">                p.innerHTML =<span class="string">&#x27;客户端：&#x27;</span>+ e.data;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务器 <code>http://127.0.0.1:8000</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(e.data) <span class="comment">//我爱你</span></span></span><br><span class="line"><span class="javascript">            p.innerHTML = <span class="string">&#x27;服务器：&#x27;</span> + e.data;</span></span><br><span class="line"><span class="javascript">            e.source.postMessage(<span class="string">&#x27;我不爱你&#x27;</span>, e.origin)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>window.name + iframe、location.hash + iframe</p><h2 id="Cookie、sessionStorage、localStorage"><a href="#Cookie、sessionStorage、localStorage" class="headerlink" title="Cookie、sessionStorage、localStorage"></a>Cookie、sessionStorage、localStorage</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是<strong>服务器发送到用户浏览器</strong>并<strong>保存在本地的一小块数据</strong>，它会在<strong>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</strong>。</p><p>通常，它用于告知服务端两个请求是否来自同一浏览器，如<strong>保持用户的登录状态</strong>。Cookie 使基于<strong>无状态</strong>的HTTP协议记录稳定的状态信息成为了可能。<strong>HTTP本质是无状态的，使用Cookies可以创建有状态的会话。</strong></p><h3 id="localStorage-amp-amp-sessionStorage"><a href="#localStorage-amp-amp-sessionStorage" class="headerlink" title="localStorage &amp;&amp; sessionStorage"></a>localStorage &amp;&amp; sessionStorage</h3><blockquote><p>Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在，而Web Storage仅仅是为了在本地“存储”数据而生。</p><p>即<code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p></blockquote><h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><p>IndexedDB 是一种底层 API，用于在客户端<strong>存储大量的结构化数据</strong>（也包括文件/二进制大型对象（blobs））。该 API 使用索引实现对数据的高性能搜索。虽然Web Storage在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th align="center">特性</th><th align="center">cookie</th><th align="center">localStorage</th><th align="center">sessionStorage</th><th align="center">indexDB</th></tr></thead><tbody><tr><td align="center">数据生命周期</td><td align="center">一般由服务器生成，会话期 Cookie/持久性 Cookie可以设置过期时间</td><td align="center">除非被清理，否则一直存在</td><td align="center">页面关闭就清理</td><td align="center">除非被清理，否则一直存在</td></tr><tr><td align="center">数据存储大小</td><td align="center">4K(数量20+，取决于浏览器)</td><td align="center">5M</td><td align="center">5M</td><td align="center">无限</td></tr><tr><td align="center">与服务端通信</td><td align="center">每次都会携带在header中，对于请求性能影响</td><td align="center">不参与</td><td align="center">不参与</td><td align="center">不参与</td></tr></tbody></table><p>Cookie <strong>曾一度用于客户端数据的存储</strong>，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。</p><h2 id="Cookie、Session、Token、JWT"><a href="#Cookie、Session、Token、JWT" class="headerlink" title="Cookie、Session、Token、JWT"></a>Cookie、Session、Token、JWT</h2><p>Cookie是<strong>服务器发送到用户浏览器</strong>并<strong>保存在本地的一小块数据</strong>，它会在<strong>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</strong>。</p><p>通常，它用于告知服务端两个请求是否来自同一浏览器，如<strong>保持用户的登录状态</strong>。Cookie 使基于<strong>无状态</strong>的HTTP协议记录稳定的状态信息成为了可能。</p><p>Cookie 主要用于以下三个方面：</p><ul><li><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li><strong>个性化设置</strong>（如用户自定义设置、主题等）</li><li><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</li></ul><p><strong>Session 是另一种记录服务器和客户端会话状态的机制</strong>，<strong>使服务端有状态化，可以记录会话信息</strong>。</p><p><strong>Session</strong> 是基于<code>cookie</code> 实现的<strong>，session 存储在服务器端</strong>，<code>sessionId</code> 会被<strong>存储到客户端的cookie 中</strong>。</p><p>第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个<code>Session ID</code>，以后每次请求把这个<code>Session ID</code>发送到服务器，服务器就知道你是谁了。</p><p>Token 是<strong>令牌</strong>，<strong>访问资源接口（API）时所需要的资源凭证</strong>。Token <strong>使服务端无状态化，不会存储会话信息。</strong></p><p><strong>JWT</strong> （JSON Web Token）</p><p>结构：<code>头部（Header）</code>、<code>载荷（Payload）</code>、<code>签名（Signature）</code>，并以<code>.</code>进行拼接。</p><p>其中头部和载荷都是以<code>JSON</code>格式存放数据，只是进行了编码。</p><p>签名是对头部和载荷内容进行签名，加密后存储于客户端，服务端只需要使用密钥解密进行校验即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</p><h2 id="XSS和CSRF"><a href="#XSS和CSRF" class="headerlink" title="XSS和CSRF"></a>XSS和CSRF</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p><code>Cross-Site Scripting</code>（跨站脚本攻击）简称 XSS，是一种<strong>代码注入攻击</strong>。</p><p>攻击者通过在<strong>目标网站</strong>上注入<strong>恶意脚本</strong>，使之在用户的<strong>浏览器</strong>上运行。</p><p>利用这些恶意脚本，攻击者可获取用户的敏感信息如<code>Cookie</code>、<code>SessionID</code> 等，进而危害数据安全。</p><p>简单来说,任何可以输入的地方都有可能引起,包括<strong>URL</strong>!</p><p>根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。</p><h3 id="常用防范方法"><a href="#常用防范方法" class="headerlink" title="常用防范方法"></a>常用防范方法</h3><ul><li><strong>httpOnly:</strong> 在 <code>cookie</code> 中设置 <code>HttpOnly</code> 属性后，js脚本将无法读取到 cookie 信息。</li><li><strong>输入过滤:</strong> 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。不仅仅是<strong>前端</strong>负责，<strong>后端</strong>也要做相同的过滤检查。因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。</li><li><strong>转义 HTML:</strong> 如果拼接 HTML 是必要的，就需要对于<strong>引号</strong>，<strong>尖括号</strong>，斜杠进行转义,但这还不是很完善。</li><li><strong>白名单:</strong> 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</li></ul><ul><li><strong>预防 DOM 型 XSS 攻击</strong><ul><li>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript代码本身不够严谨，把不可信的数据当作代码执行了。</li><li>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>（<strong>文本不会被解析为HTML</strong>）、<code>.setAttribute()</code> 等。</li><li>如果用 Vue/React 技术栈，尽量不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患。</li><li>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能<strong>把字符串作为代码运行</strong>。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</li></ul></li></ul><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>跨站请求伪造（Cross-site request forgery），通常缩写为 CSRF 或者 XSRF， 是一种<strong>挟制用户在当前已登录的 Web 应用程序上执行非本意的操作</strong>的攻击方法。</p><h4 id="CSRF与-XSS-区别"><a href="#CSRF与-XSS-区别" class="headerlink" title="CSRF与 XSS 区别"></a>CSRF与 XSS 区别</h4><ul><li><strong>通常来说 CSRF 是由 XSS 实现的。</strong></li><li>本质上讲，XSS 是代码注入问题，<strong>CSRF 是 HTTP 问题。</strong> XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。<strong>CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(Token验证可以避免)。</strong></li></ul><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><ul><li><strong>验证码</strong>；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 CSRF，但是用户体验比较差。</li><li><strong>token 验证的 CSRF 防御机制是公认最合适的方案。</strong>若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。</li></ul><h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP UDP"></a>TCP UDP</h2><blockquote><p>考察公司：美团、腾讯、完美世界</p></blockquote><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li>在传送数据之前<strong>不需要先建立连接</strong>，远地主机在收到 UDP 报文后，<strong>不需要给出任何确认</strong>。</li><li>一般用于<strong>即时通信</strong>，比如： QQ 语音、 QQ 视频 、直播等等</li><li>基于<strong>UDP的QUIC</strong>协议可以实现类似TCP的可靠性传输</li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul><li>提供<strong>面向连接</strong>的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li>TCP 在传递数据之前，会有<strong>三次握手</strong>来建立连接，而且在数据传递时，有<strong>确认</strong>、<strong>窗口</strong>、<strong>重传</strong>、<strong>拥塞控制</strong>机制，在数据传完后，还会<strong>断开连接</strong>用来节约系统资源</li><li>由于 TCP 要提供可靠的，面向连接的传输服务，这难以避免增加了许多开销。</li><li>TCP 一般用于<strong>文件传输、发送和接收邮件、远程登录</strong>等场景。</li></ul><h3 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h3><ul><li>三次握手建立可靠连接。</li><li><strong>流量控制：</strong>TCP 连接的每一方都有固定大小的缓冲空间，TCP 的<strong>接收端只允许发送端发送接收端缓冲区能接纳的数据</strong>。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。<strong>TCP 利用滑动窗口实现流量控制</strong>。</li><li><strong>拥塞控制：</strong> <strong>当网络拥塞时，减少数据的发送</strong>。<ul><li>第一个响应包是<strong>14kb</strong>大小。这是<strong>慢开始</strong>的一部分，慢开始是一种均衡网络连接速度的算法。慢开始逐渐增加发送数据的数量直到达到网络的最大带宽。</li><li>拥塞控制算法使用<strong>发送包</strong>和<strong>确认帧流</strong>（客户端返回）来确定发送速率。</li></ul></li><li><strong>ARQ 协议：</strong> <strong>每发完一个分组就停止发送，等待对方确认</strong>。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ul><h2 id="浏览器允许的并发请求资源数"><a href="#浏览器允许的并发请求资源数" class="headerlink" title="浏览器允许的并发请求资源数"></a>浏览器允许的并发请求资源数</h2><p>首先，是基于端口数量和线程切换开销的考虑，浏览器不可能无限量的并发请求，因此衍生出来了并发限制和HTTP/1.1的Keep alive。</p><p>而随着技术的发展，负载均衡和各类NoSQL的大量应用，基本已经足以应对C10K的问题。</p><p>但却并不是每个网站都懂得利用domain hash也就是多域名来加速访问。</p><p>因此，新的浏览器加大了并发数的限制，但却仍<strong>控制在8以内</strong>。</p><p>浏览器即使放弃保护自己，将所有请求一起发给服务器，也很可能会引发服务器的并发阈值控制而被BAN，而另外一个控制在8以内的原因也是keep alive技术的存在使得浏览器复用现有连接和服务器通信比创建新连接的性能要更好一些。</p><p>所以，浏览器的并发数其实并不仅仅只是良知的要求，而是双方都需要保护自己的默契，并在可靠的情况下提供更好的性能。</p><ul><li><p>按照普通设计，当网站cookie信息有1 KB、网站首页共150个资源时，用户在请求过程中需要发送150 KB的cookie信息，在512 Kbps的常见上行带宽下，需要长达3秒左右才能全部发送完毕。 尽管这个过程可以和页面下载不同资源的时间并发，但毕竟对速度造成了影响。 而且这些信息在js/css/images/flash等静态资源上，几乎是没有任何必要的。 解决方案是<strong>启用和主站不同的域名来放置静态资源，也就是cookie free</strong>。跨域默认不带cookie</p></li><li><p>将css放置在页面最上方应该是很自然的习惯，但第一个css内引入的图片下载是有可能堵塞后续的其他js的下载的。而在目前普遍过百的整页请求数的前提下，浏览器提供的仅仅数个并发，对于进行了良好优化甚至是前面有CDN的系统而言，是极大的性能瓶颈。 这也就衍生了<strong>domain hash</strong>技术来使用多个域名加大并发量（因为浏览器是基于domain的并发控制，而不是page），不过过多的散布会导致DNS解析上付出额外的代价，所以一般也是控制在2-4之间。 这里常见的一个性能小坑是没有机制去确保URL的哈希一致性（即同一个静态资源应该被哈希到同一个域名下），而导致资源被多次下载。</p></li><li><p>再怎么提速，页面上过百的总资源数也仍然是很可观的，如果能将其中一些很多页面都用到的元素如常用元素如按钮、导航、Tab等的背景图，指示图标等等合并为一张大图，并利用css background的定位来使多个样式引用同一张图片，那也就可以大大的减少总请求数了，这就是<code>css sprites</code>雪碧图的由来。</p></li><li><p>全站的js/css原本并不多，其合并技术的产生却是有着和图片不同的考虑。 由于css/js通常可能对dom布局甚至是内容造成影响，在浏览器解析上，不连贯的载入是会造成多次重新渲染的。因此，在网站变大需要保持模块化来提高可维护性的前提下，<code>js/css combine</code>也就自然衍生了，同时也是<code>minify、compress</code>等对内容进行多余空格、空行、注释的整理和压缩的技术出现的原因。</p></li><li><p>随着cookie free和domain hash的引入，网站整体的打开速度将会大大的上一个台阶。 这时我们通常看到的问题是大量的请求由于全站公有header/footer/nav等关系，其对应文件早已在本地缓存里存在了，但为了确保这个内容没有发生修改，浏览器还是需要请求一次服务器，拿到一个304 Not Modified才能放心。 一些比较大型的网站在建立了比较规范的发布制度后，会将大部分静态资源的有效期设置为最长，也就是Cache-Control max-age为10年。 这样设置后，浏览器就再也不会在有缓存的前提下去确认文件是否有修改了。 超长的有效期可以让用户在访问曾访问过的网站或网页时，获得最佳的体验。 带来的复杂性则体现在每次对静态资源进行更新时，必须发布为不同的URL来确保用户重新加载变动的资源。</p></li><li><p>即使是这样做完，仍然还存在着一个很大的优化空间，那就是很多页面浏览量很大，但其实用户直接很大比例直接就跳走了，第一屏以下的内容用户根本就不感兴趣。 对于超大流量的网站如淘宝、新浪等，这个问题尤其重要。 这个时候一般是通过将图片的src标签设置为一个loading或空白的样式，在用户翻页将图片放入可见区或即将放入可见区时再去载入。 不过这个优化其实和并发资源数的关系就比较小了，只是对一些散布不合理，或第一页底部的资源会有一定的帮助。 主要意图还是降低带宽费用。</p></li></ul><p>总的来说，各类技术都是为了<strong>能让用户更快的看到页面进行下一步操作，但却不必将宝贵的资源浪费在没有必要的重复请求、不看的内容上</strong>。</p><p><strong>浏览器的并发请求数目限制是针对同一域名的</strong>。</p><p>意即，同一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。</p><h2 id="后端定期向前端推送数据"><a href="#后端定期向前端推送数据" class="headerlink" title="后端定期向前端推送数据"></a>后端定期向前端推送数据</h2><p>sse是后端向前端发信息的单向通道，客户端发送一个请求，服务端保持足够连接直到有新消息发送回客户端，仍然保持着连接，这样连接就可以消息再次发送，由服务器单向发送给客户端。</p><p><a target="_blank" rel="noopener" href="https://imgse.com/i/vxXAyV"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/09/15/vxXAyV.png" alt="vxXAyV.png"></a></p><h2 id="浏览器多个标签之间通信"><a href="#浏览器多个标签之间通信" class="headerlink" title="浏览器多个标签之间通信"></a>浏览器多个标签之间通信</h2><table><thead><tr><th align="left">实现方式</th><th align="left">优缺点</th></tr></thead><tbody><tr><td align="left">localStorage</td><td align="left"><strong>优点：</strong> 操作简单，易于理解。<strong>缺点：</strong> 存储大小限制只能监听非己页面跨域不共享 （<strong>总体来说较为推荐</strong>）</td></tr><tr><td align="left">websocket</td><td align="left"><strong>优点：</strong> 理论上可是实现任何数据共享跨域共享 <strong>缺点：</strong> 需要服务端配合增加服务器压力上手不易 （<strong>总体不推荐</strong>）</td></tr><tr><td align="left">sharedWorker</td><td align="left"><strong>优点：</strong> 理论上可以实现任何数据共享性能较好 <strong>缺点：</strong> 跨域不共享调试不方便兼容性不好 （<strong>总体推荐一般</strong>）</td></tr><tr><td align="left">cookie</td><td align="left"><strong>优点：</strong> 兼容性好易于上手和理解 <strong>缺点：</strong> 有存储大小限制轮询消耗性能发请求会携带cookie （<strong>总体不推荐</strong>）</td></tr></tbody></table><h3 id="localStorage实现通信"><a href="#localStorage实现通信" class="headerlink" title="localStorage实现通信"></a>localStorage实现通信</h3><p>借助localStorage实现标签页之间通信在实际项目中使用的很多，因为它操作简单，易于理解。</p><p><strong>localStorage的特点：</strong></p><ul><li>同域共享存储空间</li><li>持久化数据存储</li><li>提供事件监听localStorage变化</li></ul><p>这里我们需要重点关注同域共享，如果多个标签页跨域了，那么数据将无法共享。</p><p>我们新建两个页面pageA和pageB，利用localStorage实现两个页面之间的通信。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// pageA.html</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>pageA<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.addEventListener(<span class="string">&quot;storage&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.info(<span class="string">&quot;localStorage发生变化：&quot;</span>, e)</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// pageB.html</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>pageB<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btnB&quot;</span>&gt;</span>添加数据到localStorage<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> btnB = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btnB&quot;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> num = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">  btnB.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;num&quot;</span>, num++)</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ul><li>pageA和pageB同源，即域名、端口、协议等都是相同的。</li><li>使用storage事件监听localStorage变化</li></ul><p>当然，如果你只是需要两个页面之间数据共享，那么可以不使用storage监听方法，直接通过localStorage.getItem()获取即可。</p><h3 id="使用websocket"><a href="#使用websocket" class="headerlink" title="使用websocket"></a>使用websocket</h3><p>websocket是一种网络通讯协议。我们都知道在使用HTTP协议的时候，我们与服务端都是通过发请求的方式进行通讯的，而且这种通讯只能由客户端发起。websocket协议就弥补了这一缺点，它是一个全双工通信的协议，意味着客户端和服务端可以互相通信，享受平等关系。</p><p>最简单列子就是聊天室，我们在聊天室里面可以收消息，也可以发消息，只要我们与服务端通过websocket建立好了连接。</p><p><strong>websocket特点：</strong></p><ul><li>保持连接状态，HTTP协议是无状态连接，即请求完毕后就会关闭连接。</li><li>全双工通信，客户端和服务端平等对待，可以互相通信。</li><li>建立在TCP协议之上</li><li>没有同源共享策略，即可实现跨域共享</li></ul><p>通过以上websocket的特点，我们再来思考如何利用websocket实现多标签页通信？</p><p>其实实现原理页比较简单，假如我们pageA和pageB都与服务器建立了websocket连接，那么连个页面都可以实时接收服务端发来的消息，也可以实时向服务端发送消息。如果pageA更改了数据，那么向服务端发送一条消息或数据，服务端在将这条消息或数据发送给pageB即可，这样就简单实现了两个标签页之间的通信。</p><p>原理有点类似于”中介“，我们可以通过中介来进行沟通。</p><p>总体来说，原理很简单，只是需要了解websocket。通常情况下，我们不建议使用websocket来进行多标签页通信，因为这回增加服务器的负担。</p><h3 id="SharedWorker"><a href="#SharedWorker" class="headerlink" title="SharedWorker"></a>SharedWorker</h3><p>我们都知道JavaScript是单线程的，单线程有好处也有坏处。为了弥补JS单线程的坏处，webWorker随之被提出，它可以为JS创造多线程环境。</p><p>sharedWorker就是webWorker中的一种，它可以由所有同源页面共享，利用这个特性，我们就可以使用它来进行多标签页之前的通信。</p><p><strong>sharedWorker特点：</strong></p><ul><li>跨域不共享，即多个标签页不能跨域</li><li>使用port发送和接收消息</li><li>如果url相同，且是同一个js，那么只会创建一个sharedWorker，多个页面共享这个sharedWorker</li></ul><p>其实它和我们的webSocket实现多页面通讯的原理很类似，都是发送数据和接收数据这样的步骤，shardWorker就好比我们的webSocket服务器。</p><p><strong>总结：</strong></p><p>sharedWorker的原理和websocket有点类似，都是广播和接收的原理，但是它也有一些缺点，比如调试不太方便、兼容性不太好。所以使用的时候一定要结合实际情况使用。</p><h3 id="使用cookie-setInterval"><a href="#使用cookie-setInterval" class="headerlink" title="使用cookie + setInterval"></a>使用cookie + setInterval</h3><p>我们都知道cookie可以用来存储数据，而且它是同源共享的，借助它的这些特点，我们就可以利用cookie实现多页面的通讯。</p><p><strong>cookie特点：</strong></p><ul><li>跨域不共享</li><li>具有存储空间限制</li><li>请求会自动携带cookie</li></ul><p>这种方式实现的原理非常简单，就是在需要接收消息的页面不断轮询去查询cookie，然后发送消息的页面将数据存储在cookie中，这样就实现了简单的数据共享。</p><h2 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h2><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><p>它的作用主要为：</p><p>（1）用来检测网络的连通情况和分析网络速度；</p><p>（2）根据域名得到服务器IP；</p><p>（3）根据ping返回的TTL值来判断对方所使用的操作系统及数据包经过路由器数量。</p><p>我们通常会用它来直接ping IP地址，来测试网络的连通情况。</p><p>bytes值：数据包大小，也就是字节。</p><p>time值：响应时间，这个时间越小，说明你连接这个地址速度越快。</p><p>TTL值：Time To Live,表示DNS记录在DNS服务器上存在的时间，它是IP协议包的一个值，告诉路由器该数据包何时需要被丢弃。可以通过Ping返回的TTL值大小，粗略地判断目标系统类型是Windows系列还是UNIX/Linux系列。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>因为页面自身还是在 GitHub Pages 托管，有时候首个请求还是会挺久才返回。</p><h3 id="性能检测"><a href="#性能检测" class="headerlink" title="性能检测"></a>性能检测</h3><ul><li><p><code>Network</code>面板是一个常被用到的工具，通过它可以<strong>获取到网站所有资源的请求情况</strong>，包括<strong>加载时间</strong>，<strong>资源大小</strong>，优先级设置、<strong>瀑布图</strong>以及<code>HTTP</code>缓存等信息。可以帮助开发者发现可能由于未进行有效压缩而导致资源尺寸过大的问题，未配置缓存策略导致二次请求加载时间过长的问题。</p></li><li><p><code>Lighthouse</code>是谷歌开发并开源的<code>web</code>性能测试工具，用于改进网络应用的质量，可以将其作为一个<code>Chrome</code>扩展程序运行，或从命令行运行。在浏览器的调试工具中默认就存在<code>lighthouse</code>选项，只需要切换至<code>lighthouse</code>，在右侧的选项区选中需要的选项。点击生成报告。</p></li><li><p>使用<code>Performance</code>面板主要对网站应用的运行时性能表现进行检测和分析，包括页面的每秒帧数，<code>CPU</code>的消耗和各种请求花费的时间。</p></li></ul><h3 id="如何保证资源更快的加载速度？"><a href="#如何保证资源更快的加载速度？" class="headerlink" title="如何保证资源更快的加载速度？"></a>如何保证资源更快的加载速度？</h3><h4 id="使用-dns-prefetch-减少-DNS-的查询时间"><a href="#使用-dns-prefetch-减少-DNS-的查询时间" class="headerlink" title="使用 dns-prefetch 减少 DNS 的查询时间"></a>使用 <code>dns-prefetch</code> 减少 DNS 的查询时间</h4><p><code>dns-prefetch</code> 能够 <strong>提前解析</strong> 后续可能会用到的 <strong>不同域的域名</strong>，使解析结果 <strong>缓存到系统缓存</strong> 中，缩短 <code>DNS</code> 解析时间以提高网站的访问速度。</p><h4 id="使用-preconnect-提前建立连接"><a href="#使用-preconnect-提前建立连接" class="headerlink" title="使用 preconnect 提前建立连接"></a>使用 <code>preconnect</code> 提前建立连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preconnect` 的作用是提前和第三方资源建立连接，设置了它浏览器就会做好早期的连接工作，但这个连接通常只会维持 `10 s</span><br></pre></td></tr></table></figure><h4 id="压缩资源体积"><a href="#压缩资源体积" class="headerlink" title="压缩资源体积"></a>压缩资源体积</h4><h5 id="HTTP-压缩"><a href="#HTTP-压缩" class="headerlink" title="HTTP 压缩"></a>HTTP 压缩</h5><p>HTTP 压缩中一个典型代表就是 <code>gzip</code>，它是一种优秀的压缩算法，可对 <code>http</code> 请求中的一些文件资源进行压缩处理，一般来讲是要在服务端处理的，可通过在响应头中设置 <code>Content-encoding: gzip</code> 表示当前资源使用的压缩方式（如：<code>gzip、deflate、br</code> 等），便于客户端使用正确的方式解压。</p><h5 id="Webpack-压缩"><a href="#Webpack-压缩" class="headerlink" title="Webpack 压缩"></a>Webpack 压缩</h5><p><strong>有 <code>HTTP</code> 压缩 不就够了吗？为什么还需要 <code>Webpack</code> 压缩？</strong></p><p>首先必须要明确的是压缩的过程本身就是会消耗时间的，如果所有资源都等到被访问的时候再由服务端进行压缩，在压缩完成之前客户端还是得处于等待状态，即仍 <strong>不能保证资源以最快的速度到达客户端</strong>。</p><p>那么优化方案就是将压缩资源的时间放到打包构建中，毕竟只有真正需要发布线上生产环境时才需要执行一系列的打包优化的操作，而这相比于 <strong><code>http</code></strong> 的 <strong>请求/响应</strong> 速度，稍微延长产物打包时间没有什么大问题。</p><p>下面会列举一些 <strong>Webpack</strong> 插件，但并不会去讲其中的具体用法，因为这些只是达到目的的不同方案而已，每个方案要是细讲都可以独占一篇文章，在这是没有必要的，具体用法可自行查阅。</p><blockquote><p><strong>使用 <code>CompressionPlugin</code> 压缩文件</strong></p></blockquote><p><strong><code>webpack</code> 文档</strong>提供插件合集中就包含了该插件，它的作用就是：**<code>Prepare compressed versions of assets to serve them with Content-Encoding.</code>**</p><blockquote><p><strong>使用 <code>HtmlWebpackPlugin</code> 压缩 <code>HTML</code> 文件</strong></p></blockquote><p>通常我们需要 <a href="https://link.juejin.cn/?target=https://github.com/jantimon/html-webpack-plugin"><strong><code>HtmlWebpackPlugin</code></strong></a> 插件来生成对应 <code>HTML</code> 或 对已有的 <code>HTML</code> 模板自动注入 <code>webpack bundles</code> 资源，除此之外，它还可配置 <code>minify</code> 选项实现压缩模板的目的。</p><blockquote><p><strong>使用 <code>SplitChunksPlugin</code> 自定义分包策略</strong></p></blockquote><p><code>Webpack</code> 默认会将尽可能多的模块代码打包在一起，这种默认规则的带来的优点和缺点都很明显:</p><ul><li>优点：<strong>能减少最终页面的 <code>HTTP</code> 请求数</strong></li><li>缺点：<ul><li><strong>页面初始代码包过大，影响首屏渲染性能</strong></li><li><strong>无法有效应用浏览器缓存</strong></li></ul></li></ul><p>**<code>SplitChunksPlugin</code>**是 <code>Webpack 4</code> 之后内置实现的最新分包方案，与 <code>Webpack 3</code> 中的 <code>CommonsChunkPlugin</code> 相比，它能够基于一些更灵活、合理的启发式规则将 <code>Module</code> 编排进不同的 <code>Chunk</code>，最终构建出 <strong>性能更佳、缓存更友好</strong> 的应用产物。</p><blockquote><p><strong>使用 <code>MiniCssExtractPlugin</code> 抽离和压缩 <code>CSS</code></strong></p></blockquote><p>**<code>MiniCssExtractPlugin</code>**会将 <code>CSS</code> 提取到单独的文件中，为每个包含 <code>CSS</code> 的 <code>JS</code> 文件创建一个 <code>CSS</code> 文件，并且支持 <code>CSS</code> 和 <code>SourceMaps</code> 的 <strong>按需加载</strong> 。</p><blockquote><p><strong>使用 <code>ImageMinimizerWebpackPlugin</code> 压缩图片资源</strong></p></blockquote><p>图片仍是一个 <code>Web</code> 应用中的必不可少的资源，而图片资源的体积也是首屏页面加载的瓶颈之一，因此，压缩图片也是性能优化需要考虑的内容。</p><p><strong><code>ImageMinimizerWebpackPlugin</code></strong> 可用于使用 <strong>优化/压缩</strong> 所有图像，它可以支持 <strong>无损（不损失质量）</strong>、<strong>有损（质量下降）</strong> 两种模式的压缩方式。</p><blockquote><p><strong>通过 <code>Tree Shaking</code> 移除无用代码</strong></p></blockquote><p><a href="https://link.juejin.cn/?target=https://webpack.docschina.org/guides/tree-shaking/%23root"><strong><code>Tree Shaking</code></strong></a> 依赖于 <code>ES6</code> 模块语法的 <strong>静态结构</strong> 特性（如： <code>import</code>和 <code>export</code>），当 <code>webpack</code> 的模式 <code>mode</code> 为 <code>&quot;production&quot;</code> 时，就可以启用 <strong>更多优化项</strong>，包括 <strong>压缩代码</strong> 与 <strong>Tree Shaking</strong>。</p><p>但同时我们就必须保证：</p><ul><li>尽量使用 <code>ES6</code> 模块语法，即 <code>import</code> 和 <code>export</code></li><li>保证没有 <strong>编译器</strong>（如：<code>babel</code>）将对应的 <code>ES6</code> 模块语法转换为 <code>CommonJS</code> 的语法（如：<code>@babel/preset-env</code> 的默认行为）</li><li>可在项目的 <code>package.json</code> 文件中添加 <code>&quot;sideEffects&quot;</code> 属性，标识当前内容是否存在副作用操作</li><li>可在通过 <code>/*#__PURE__*/</code> 注释，将函数调用标记为无副作用</li></ul><h4 id="减少-http-请求数量"><a href="#减少-http-请求数量" class="headerlink" title="减少 http 请求数量"></a>减少 http 请求数量</h4><p><strong>不同协议</strong> 下 <strong>请求数量</strong> 仍然可能成为 <strong>请求/响应</strong> 慢的原因：</p><ul><li>合并公共资源，如 雪碧图 等</li><li>内置模块资源，如 生成 <code>base64</code> 图片、通过 <code>symbol</code> 引用 <code>svg</code> 等</li><li>合并代码块，如构建工具分包策略配合公共组件封装、组件复用逻辑抽离 等</li><li>按需加载资源，如 路由懒加载、图片懒加载、上拉加载、分页加载 等</li></ul><h5 id="webpack对图片资源进行优化"><a href="#webpack对图片资源进行优化" class="headerlink" title="webpack对图片资源进行优化"></a>webpack对图片资源进行优化</h5><p>将小于某个大小的图片转化成 data URI 形式（Base64 格式）</p><ul><li>优点：<strong>减少请求数量</strong></li><li>缺点：<strong>体积变得更大</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载器  </span></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span> <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h4 id="减少不必要的-cookie"><a href="#减少不必要的-cookie" class="headerlink" title="减少不必要的 cookie"></a>减少不必要的 cookie</h4><p>不必要的 <code>cookie</code> 来回传输会造成带宽浪费：</p><ul><li>减少 <code>cookie</code> 存储的内容</li><li>对于静态资源采用 <code>CDN</code> 托管（即非同域），不同域名默认不携带 <code>cookie</code></li></ul><h4 id="CDN-托管静态资源-HTTP-缓存"><a href="#CDN-托管静态资源-HTTP-缓存" class="headerlink" title="CDN 托管静态资源 + HTTP 缓存"></a>CDN 托管静态资源 + HTTP 缓存</h4><p>性能优化的第一定律就是：优先考虑使用缓存。</p><p>缓存的主要手段有：浏览器缓存、CDN。</p><p><strong><code>CDN</code> 加速的本质是缓存加速</strong>，将服务器上存储的静资源容缓存在 <code>CDN</code> 节点上，当后续访问这些静态内容时，无需访问服务器源站，选择就近访问 <code>CDN</code> 节点即可，从而达到加速的效果，同时减轻服务器源站的压力。</p><p>主要用在博客的图片上面。但图片存在了Github仓库，所以性能还是有影响。</p><p>CDN是“去中心化的”。</p><p>静态资源是指在<strong>不同请求中访问到的数据都相同的静态文件</strong>。例如：<strong>图片、视频、网站中的文件（html、css、js）</strong>、软件安装包、apk文件、压缩包文件等。</p><p>动态资源是指在<strong>不同请求中访问到的数据不相同的动态内容</strong>。例如：网站中的文件（asp、jsp、php、perl、cgi）、<strong>API接口、数据库交互请求</strong>等。</p><p><strong>CDN的作用</strong></p><ul><li>加速网站的访问</li><li>CDN的负载均衡和分布式存储技术，可以加强网站的可靠性。</li><li>使用CDN加速可以实现网站的全国铺设，你不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，也不用为了管理维护技术人员而烦恼，节省了人力、精力和财力。</li></ul><p><strong>CDN工作原理</strong></p><ul><li>当用户点击网站页面上的内容URL，经过<strong>本地DNS系统</strong>解析，DNS系统会最终将域名的解析权交给CNAME指向的<strong>CDN专用DNS服务器</strong>。</li><li>CDN的DNS服务器将CDN的<strong>全局负载均衡设备IP地址</strong>返回用户。</li><li>用户向CDN的全局负载均衡设备发起内容URL访问请求。</li><li>CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的<strong>区域负载均衡设备</strong>。</li><li>区域负载均衡设备会为用户选择一台合适的<strong>缓存服务器</strong>提供服务（地址、内容、负载），区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。</li><li>全局负载均衡设备把该IP地址返回给用户。</li><li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，那么这台服务器就要向它的上一级缓存服务器请求内容，<strong>直至追溯到网站的源服务器将内容拉到本地</strong>。</li><li>DNS服务器根据用户IP地址，<strong>将域名解析成相应节点的缓存服务器IP地址</strong>，实现用户<strong>就近访问</strong>。</li></ul><h4 id="协议升级为-Http2-0"><a href="#协议升级为-Http2-0" class="headerlink" title="协议升级为 Http2.0"></a>协议升级为 Http2.0</h4><blockquote><p><strong><code>http1.x</code> 存在的问题：</strong> <code>HTTP</code> 的底层协议是 <code>TCP</code>，而 <code>TCP</code> 是面向连接即需要 <strong>三次握手</strong> 才能建立连接，其中：</p></blockquote><ul><li><code>http1.0</code> 中使用的是 <strong>短连接</strong>，即 <strong>一次请求/响应</strong> 结束后就会断开连接，这个过程比较耗时</li><li><code>http1.1</code>中使用的是长连接，在请求/响应头中设置<code>Connection: keep-alive</code>即可开启，优点是长连接允许多个请求共用一个TCP连接，缺点是带来了队头阻塞：<ul><li>每个 <code>TCP</code> 连接中的多个请求，需要进行排队，只有队头的请求被响应，才能继续处理下一个请求</li><li>其中一个缓解方案就是如果当前 <code>TCP</code> 连接中发生 <strong>队头阻塞</strong>，那就将部分请求放到其他 <code>TCP</code> 连接中</li><li>浏览器一般会限制同一个域名建立 <code>6-8</code> 个 <code>TCP</code> 链接，这也就是为什么需要为应用划分子域名、静态资源托管 <code>CDN</code> 的原因之一。</li></ul></li><li><code>http1.x</code> 中 <code>header</code> 部分的内容可能会很大，而且每一个请求可能都需要携带大量 <strong>重复</strong> <code>header</code> 的 <strong>文本内容</strong>，而这些也是导致 <strong>请求/响应</strong> 慢的原因之一。</li></ul><blockquote><p><strong>以上问题 <code>http2.0</code> 都能够解决：</strong></p></blockquote><ul><li><p>针对 <strong>TCP 连接数</strong> 被限制的问题，<code>http2.0</code> 采用 <strong>多路复用</strong> 一个域名只对应一个 <code>TCP</code> 连接。</p></li><li><p>针对 <strong>http 队头阻塞</strong> 问题，<code>http2.0</code> 中通过二进制分帧层为每个 <strong>请求/响应</strong> 添加 <code>stream id</code> 保证 <strong>请求/响应</strong> 一一对应，即不必等待前面的请求处理完成，并且还可以为每个请求添加 <strong>优先级</strong>。</p></li><li><p>针对<code>header</code>数据大的问题，http2.0中传输的header帧经过处理后会用二进制的方式表示，替换了原本的文本格式，并使用HPACK算法进行压缩</p><ul><li><strong>接收/发送</strong> 两端会维护一个 <strong>索引表</strong>，通过下标来标识 <code>header</code>，针对后续重复的 <code>header</code> 信息就可以用对应的索引来代替。</li></ul></li><li><p>针对传统的 <strong>请求 —&gt; 响应</strong> 模式，<code>http2.0</code> 中提供了 <strong>服务端推送</strong> 的能力，让服务端能够主动向客户端推送关键资源，加快资源加载。</p></li></ul><h4 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h4><p>使用<code>link</code>的<code>preload</code>属性预加载一个资源。webpack也可配置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>as属性可以指定预加载的类型，除了style还支持很多类型，常用的一般是<code>style</code>和<code>script</code>，<code>css</code>和<code>js</code>。</p><blockquote><p>【<strong>注意</strong>】<code>as</code> 属性一定要设置，除了设置优先级外，还涉及到浏览识别的问题：如果没有设置 <code>as</code> 属性，后续遇到该请求就会被作为一个 <code>XHR</code> 请求，把意味着资源预加载的功能可能会失效，因为可能会每次都发起新的请求获取</p></blockquote><p><code>preload</code> 是对资源的预加载，它虽提前加载但只在需要执行时执行，即这个资源一定是当前页面所需要的资源，如果是需要为下一个页面提前加载资源，那么应该使用 <code>prefetch</code>，它会在 <strong>浏览器空闲时</strong> 下载资源。。webpack也可配置。</p><h3 id="如何保证视图更快的渲染和交互？"><a href="#如何保证视图更快的渲染和交互？" class="headerlink" title="如何保证视图更快的渲染和交互？"></a>如何保证视图更快的渲染和交互？</h3><h4 id="渲染层面"><a href="#渲染层面" class="headerlink" title="渲染层面"></a>渲染层面</h4><h5 id="减少阻塞渲染的因素"><a href="#减少阻塞渲染的因素" class="headerlink" title="减少阻塞渲染的因素"></a>减少阻塞渲染的因素</h5><p>真正渲染视图之前，必然要生成 <strong><code>DOM Tree</code></strong> 和 **<code>CSSOM</code>**，因此必须保证 <strong>HTML 解释器</strong> 和 <strong>CSS 解释器</strong> 都尽早处理完成，同时 <strong><code>JavaScript</code></strong> 的加载和执行可能会阻塞这个过程：</p><ul><li><code>HTML</code> 文档中首次渲染的节点数量要尽量少，避免深层次的嵌套结构，避免大量使用慢标签（如：<code>iframe</code>）等。</li><li><code>CSS</code> 资源放文档头部，降低 <code>CSS</code> 复杂度，比如 合理使用 <code>CSS</code> 选择器。</li><li><code>JavaScript</code> 资源放文档底部，合理使用 <code>defer、async</code> 的加载方式。</li></ul><h5 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h5><p>懒加载主要是针对数量大、资源加载慢的情况，比如图片资源、大量列表数据展示等：</p><ul><li><strong>图片资源</strong>：优先加载在可视区范围内的图片，可视区外的图片 **<code>延后加载</code>**，或者说当移入的可视区时再加载。</li><li><strong>列表数据</strong>：列表数据通常数据里量大，不可能一次渲染完所有数据，一般通过 <strong><code>分页加载、上拉加载</code></strong> 等方式分批次渲染。</li></ul><p>在HTML中，图片是由 <code>&lt;img&gt;</code> 标签引入的，是由其中的<code>src</code>属性去请求的。所以实现懒加载的关键就是，在图片没有进入可视区的时候，不给<code>src</code>属性赋值，等图片进入到了可视区，再给<code>src</code>属性赋值，去请求图片。</p><p><code>img</code>的<code>loading</code>属性。</p><p><code>&lt;img src=&quot;./example.jpg&quot; loading=&quot;lazy&quot;&gt;</code></p><p><strong>js实现原理</strong></p><p>我们通过js监听页面的滚动也能实现。</p><p>使用js实现的原理主要是判断当前图片是否到了可视区域：</p><ul><li>拿到所有的图片 dom 。</li><li>遍历每个图片判断当前图片是否到了可视区范围内。</li><li>如果到了就设置图片的 src 属性。</li><li>绑定 window 的 scroll 事件，对其进行事件监听。</li></ul><p>在页面初始化的时候，<code>&lt;img&gt;</code>图片的src实际上是放在data-src属性上的，当元素处于可视范围内的时候，就把data-src赋值给src属性，完成图片加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> viewHeight = <span class="built_in">document</span>.body.clientHeight <span class="comment">//获取可视区高度</span></span><br><span class="line">  <span class="keyword">let</span> imgs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;img[data-src]&#x27;</span>)</span><br><span class="line">  imgs.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.dataset.src === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置</span></span><br><span class="line">    <span class="keyword">let</span> rect = item.getBoundingClientRect()</span><br><span class="line">    <span class="keyword">if</span> (rect.bottom &gt;= <span class="number">0</span> &amp;&amp; rect.top &lt; viewHeight) &#123;</span><br><span class="line">      item.src = item.dataset.src</span><br><span class="line">      item.removeAttribute(<span class="string">&#x27;data-src&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, lazyload)</span><br></pre></td></tr></table></figure><p>但是这样存在较大的性能问题，因为 scroll 事件会在很短的时间内触发很多次，严重影响页面性能，为了提高网页性能，我们需要一个节流函数来控制函数的多次触发，在一段时间内（如 200ms）只执行一次回调。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttle(lazyload, <span class="number">200</span>))</span><br></pre></td></tr></table></figure><h5 id="白屏优化"><a href="#白屏优化" class="headerlink" title="白屏优化"></a>白屏优化</h5><p>白屏是由于 <code>SPA</code> 应用需要等待 <code>JavaScript</code> 加载并执行完成后才会生成具体的页面结构内容导致的，即初始化模板中没有任何有意义需要被渲染的 <code>HTML</code> 结构：</p><ul><li>添加 **白屏 <code>loading</code>**，可在模板中添加默认的 <code>loading</code> 效果，等到真正页面内容被渲染就可以替换 <code>loading</code> 内容。</li><li>添加 <strong>骨架屏</strong>，和上述方案一致，在真正页面内容展示出来之前，先展示默认的视图内容，避免白屏。</li></ul><h5 id="服务端渲染（server-side-rendering）"><a href="#服务端渲染（server-side-rendering）" class="headerlink" title="服务端渲染（server-side rendering）"></a>服务端渲染（server-side rendering）</h5><p>现代框架默认是属于客户端应用框架，即组件的代码会在浏览器中运行，然后向页面输出 <strong>DOM</strong> 元素，也叫 <strong>客户端渲染（client-side rendering，CSR）</strong>：</p><ul><li>优点<ul><li>**<code>用户体验更好</code>**，基于 <strong>前端路由</strong> 的方式并不会真正进行 <strong>页面跳转</strong>，即不会使页面重新刷新、加载，带来更高的流畅度。</li><li><strong><code>占用服务端资源少</code><strong>，</strong>CSR 渲染</strong> 是交由客户端进行处理，服务端不需要关心渲染计算的过程，减轻了服务端的压力。</li></ul></li><li>缺点<ul><li>**<code>&quot;白屏&quot; 时间较长</code>**，主要是因为 <strong>CSR</strong> 渲染需要 <code>*.js</code> 的支持，而 <code>*.js</code> 又必须保证 <code>*.html</code> 被接收和解析， <code>*.html</code> 又强依赖于当前的 <strong>网络环境</strong>，因此，在差网环境下回导致 <strong>白屏时间过长</strong>，特别是在移动网络环境下。</li><li>**<code>对 SEO 的支持不友好</code>**，因为 <strong>白屏时间较长</strong> 导致在一段时间内没有重要的内容能够交由 <strong>搜索引擎</strong> 进行分析、分类、打标签等，并且 <strong>搜索引擎</strong> 并不会等待页面渲染完成，因此对 <strong>SEO</strong> 优化并不友好。</li></ul></li></ul><p><strong>服务端渲染（server-side rendering，SSR）</strong> 可将相同组件在服务渲染成相应的 <code>HTML</code> 字符串，并发送给浏览器进行渲染，即客户端不需要等待所有的 <strong>JavaScript</strong> 都被下载并执行之后才显示，所以用户可以更快看到完整的渲染好的内容。</p><h5 id="预渲染（prerender）"><a href="#预渲染（prerender）" class="headerlink" title="预渲染（prerender）"></a>预渲染（prerender）</h5><p>上述 <strong>服务端渲染（server-side rendering，SSR）</strong> 虽然能够解决一些客户端存在的问题，但它也带来了别的问题：</p><ul><li>**<code>需要保证开发一致性</code>**，比如 <strong>服务端</strong> 和 <strong>客户端</strong> 能够执行的组件生命周期钩子不同，一些外部库在 <strong>服务端渲染</strong> 应用中可能需要经过特殊处理。</li><li>**<code>需要更多的构建设定和部署要求</code>**，一个完全静态的 <strong>SPA</strong> 可以部署在任意的静态文件服务器，但服务端渲染应用需要一个能够运行 <strong>Node.js</strong> 服务器的环境。</li><li>**<code>更多的服务端负载</code>**，在 <strong>Node.js</strong> 中渲染一个完整的应用，会比仅供应静态文件产生更密集的 <strong>CPU</strong> 运算，并且需要考虑访问流量过大的情况等。</li></ul><p>因此，并不是所有应用都合适 <strong>服务端渲染</strong>，如果只是希望通过 <strong>SSR</strong> 来改善一些 <strong>推广页面</strong> (如 <code>/</code>、<code>/about</code>、<code>/contact</code> 等) 的 <strong>SEO</strong>，那么应该优先考虑 <strong>预渲染</strong> 的方式：</p><ul><li><strong>预渲染</strong> 是在打包构建过程中（离屏状态），针对对应的 <code>routes</code> 路由预先生成对应的页面内容。</li><li><strong>预渲染</strong> 需要和 <strong>打包构建工具（webpack、rollup 等）</strong> 进行配合，如 **<code>webpack</code>**，就可通过 <strong><code>prerender-spa-plugin</code></strong> 来支持 <strong>预渲染</strong>。</li></ul><h4 id="交互层面"><a href="#交互层面" class="headerlink" title="交互层面"></a>交互层面</h4><h5 id="减少回流-重绘"><a href="#减少回流-重绘" class="headerlink" title="减少回流/重绘"></a>减少回流/重绘</h5><p><strong>重绘</strong>：页面中元素样式的改变并不影响它在文档流中的位置时（如：<code>color、background-color、visibility</code> 等），浏览器会将新样式赋予给元素并 <strong>重新绘制</strong>.</p><p><strong>回流</strong>：当 <code>Render Tree</code> 中部分或全部元素的 <strong>尺寸、结构、某些属性</strong> 发生改变时，浏览器 <strong>重新渲染</strong> 部分或全部文档。</p><ul><li>减少对 <code>DOM</code> 进行频繁操作。</li><li>使经常变动的元素脱离文档流，如具有持续性的动画效果，会一直触发回流和重绘。</li><li>避免访问或减少访问会导致浏览器强制刷新队列的属性，如：<code>offsetTop、offsetLeft、offsetWidth</code>等<ul><li>【<strong>扩展</strong>】浏览器的渲染队列机制会通过 <strong>队列</strong> 将会触发 <strong>回流或重绘</strong> 的操作进行存储，等到一定的时间或一定的数量时再执行这些操作。</li></ul></li><li>避免对 <code>css</code> 进行单个修改，如在 <code>JavaScript</code> 修改多个样式时，尽量使用 <code>css</code> 选择器实现样式的集中变更。</li><li>使用 <code>will-change</code> 开启 <code>GPU</code> 加速，<code>will-change</code> 指定的属性使得浏览器可在元素属性真正发生变化之前提前做好对应的优化。</li><li>预先设定图片尺寸，避免图片资源加载完成后引发回流。</li></ul><h5 id="防抖-节流"><a href="#防抖-节流" class="headerlink" title="防抖/节流"></a>防抖/节流</h5><p><strong>防抖</strong>：多次频繁触发执行操作，以 <strong>最后一次</strong> 为准，忽略中间过程。</p><p><strong>节流</strong>：在指定的时间间隔内，<strong>只允许</strong> 执行一次对应的操作。</p><p>合理使用 <strong><code>防抖/节流</code></strong> 优化应用中的操作，比如 <strong><code>节流</code></strong> 可用于优化滚动事件、模糊搜索等，**<code>防抖</code>** 可用于优化一些按钮点击操作等。</p><h5 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h5><p><code>JavaScript</code> 是单线程的，如果存在需要大量计算的场景（如视频解码），<code>UI</code> 线程就会被阻塞，甚至浏览器直接卡死。</p><p><code>Web Worker</code> 可以使脚本运行在新的线程中，它们独立于主线程，可以进行大量的计算活动，而不会影响主线程的 <code>UI</code> 渲染，但不能滥用 <code>Web Worker</code> 。</p><h5 id="虚拟列表"><a href="#虚拟列表" class="headerlink" title="虚拟列表"></a>虚拟列表</h5><p>最常用的还是 <strong>分页加载</strong> 的方式：</p><ul><li>基于 <code>table</code> 表格的渲染，只会渲染固定数量的 <code>DOM</code></li><li>基于 <code>上拉加载</code> 列表的渲染，随着加载数据的增多，对应的 <code>DOM</code> 节点也会增多，达到某个限制页面一定会发生卡顿</li></ul><p><strong>虚拟列表</strong> 核心就是固定渲染的 <strong><code>DOM</code></strong> 数，通过动态切换数据内容实现视图的更新，并保证文档中真实 <strong><code>DOM</code></strong> 的数量不随着数据量增大而增大（其实和 <code>table</code> 分页很像，但它支持滚动）。</p><p>想了解其核心实现的，可查看 <a target="_blank" rel="noopener" href="https://juejin.cn/post/7129919300994859015"><strong>虚拟滚动是怎么做性能优化的?</strong></a></p><h5 id="大文件分片上传"><a href="#大文件分片上传" class="headerlink" title="大文件分片上传"></a>大文件分片上传</h5><p>大部分的项目总少不了文件上传功能，但对大文件的上传还是有必要进行优化，所谓的 <strong>断点续传</strong>、<strong>秒传</strong> 都要基于 <strong>分片上传</strong> 这个核心功能。</p><p>想了解其核心实现的，可查看 <a target="_blank" rel="noopener" href="https://juejin.cn/post/7074534222748188685"><strong>请问：怎么实现大文件快速上传？</strong></a></p><h5 id="Excel-导入-导出"><a href="#Excel-导入-导出" class="headerlink" title="Excel 导入/导出"></a>Excel 导入/导出</h5><p>针对 <strong>Excel 导入/导出</strong> 的功能相信很多人第一印象是后端的活，但大多数情况下，后端接口的处理速度会受各种影响，导致速度方面不是很理想，有时候也是需要前端来进行优化处理的，比如导入时前端不发送文件只发送解析后的 <code>JSON</code> 数据，导出时不需要单独发送额外接口，直接使用当前展示数据实现导出等。</p><p>想了解其核心实现的，可查看 <a target="_blank" rel="noopener" href="https://juejin.cn/post/7135945969425711111"><strong>给我实现一个前端的 Excel 导入和导出功能</strong></a></p><h3 id="React项目的优化-★"><a href="#React项目的优化-★" class="headerlink" title="React项目的优化 ★"></a>React项目的优化 ★</h3><h4 id="尽量避免重新render"><a href="#尽量避免重新render" class="headerlink" title="尽量避免重新render"></a>尽量避免重新render</h4><h5 id="使用PureComponent"><a href="#使用PureComponent" class="headerlink" title="使用PureComponent"></a>使用PureComponent</h5><p>React.PureComponent中<strong>浅层对比</strong>了<code>props</code>和<code>state</code>来避免重新渲染，但是假如props和state的属性值是对象的情况下，并不能阻止不必要的渲染，因为只是比较了地址，所以在使用PureComponent的时候要确保数据类型是值的类型，如果是引用类型，最好不要有深层次的变化。</p><h5 id="使用ShouldComponentUpdate"><a href="#使用ShouldComponentUpdate" class="headerlink" title="使用ShouldComponentUpdate"></a>使用ShouldComponentUpdate</h5><p>这个函数可以决定是否要重新渲染组件，也属于一个生命周期函数，如果props更改或者调用setState这个函数会返回一个布尔值，true表示会重新渲染，如果为false则不会重新渲染。</p><h5 id="使用React-memo"><a href="#使用React-memo" class="headerlink" title="使用React.memo"></a>使用React.memo</h5><p>如果组件在相同的props的情况下渲染结果相同时，可以通过将其包装在React.memo中，React将跳过渲染组件并直接复用最近一次渲染的结果。</p><p>React.memo对比的是<code>props</code>的变化，如果一个组件被这个钩子函数包裹，但是其内部有useState或者useReducer之类的，仍会进行重新渲染，这个也是进行的浅层比较，如果想要控制对比的过程，可以将自定义的函数通过第二个参数进行传递。</p><h5 id="使用useMemo缓存计算结果"><a href="#使用useMemo缓存计算结果" class="headerlink" title="使用useMemo缓存计算结果"></a>使用useMemo缓存计算结果</h5><p>如果一个组件中有一个计算量比较大的函数，重新渲染每次都调用比较消耗性能，所以我们可以使用useMemo来缓存这个函数的计算结果，这样只有传入的参数发生变化才会重新进行计算。</p><h5 id="使用useCallback来缓存函数"><a href="#使用useCallback来缓存函数" class="headerlink" title="使用useCallback来缓存函数"></a>使用useCallback来缓存函数</h5><p>假如一个组件中有一个函数，只要状态发生变化，这个函数就会被重新定义，使用useCallback可以进行缓存。</p><h5 id="使用发布订阅模式来避免中间组件不必要的渲染"><a href="#使用发布订阅模式来避免中间组件不必要的渲染" class="headerlink" title="使用发布订阅模式来避免中间组件不必要的渲染"></a>使用发布订阅模式来避免中间组件不必要的渲染</h5><p>如果组件的嵌套层级比较深，可能造成中间组件不必要的渲染，可能中间组件只是传递了props，这种情况我们可以通过发布订阅模式，让只关心某个状态的组件去更新，可以借助一些类似的第三方库：redux。</p><h5 id="尽量将状态放到子组件中（状态下方）"><a href="#尽量将状态放到子组件中（状态下方）" class="headerlink" title="尽量将状态放到子组件中（状态下方）"></a>尽量将状态放到子组件中（状态下方）</h5><p>如果一个状态只是某部分子组件在使用，可以将其提取为一个组件，然后状态定义到这个组件中，避免中间组件不必要的渲染。</p><h5 id="列表的每个item加上key属性"><a href="#列表的每个item加上key属性" class="headerlink" title="列表的每个item加上key属性"></a>列表的每个item加上key属性</h5><p>通过添加key属性可以更好的辅助Diff算法进行虚拟DOM计算，避免不必要的渲染。</p><h4 id="尽量减少要渲染的节点"><a href="#尽量减少要渲染的节点" class="headerlink" title="尽量减少要渲染的节点"></a>尽量减少要渲染的节点</h4><h5 id="组件懒加载"><a href="#组件懒加载" class="headerlink" title="组件懒加载"></a>组件懒加载</h5><p>组件懒加载实现的效果是让真正需要真是这个组件的时候才渲染，主要是通过<code>React.lazy</code>和<code>React.Suspense</code>这两个组件来进行组件懒加载。</p><p>主要是使用<code>React.lazy</code>来定义一个动态加载的组件，<code>React.Suspense</code>主要是用来包裹要懒加载的组件的。</p><h5 id="使用虚拟列表"><a href="#使用虚拟列表" class="headerlink" title="使用虚拟列表"></a>使用虚拟列表</h5><p>虚拟列表可以根据滚动容器的元素的高度来渲染长列表的数据，尤其是在一些没有直接分页的场景，主要是使用第三方库：r<code>eact-window</code>、<code>react-virtualized</code>。</p><h4 id="避免添加额外的DOM"><a href="#避免添加额外的DOM" class="headerlink" title="避免添加额外的DOM"></a>避免添加额外的DOM</h4><h6 id="使用React-fragment来避免不必要的div"><a href="#使用React-fragment来避免不必要的div" class="headerlink" title="使用React.fragment来避免不必要的div"></a>使用React.fragment来避免不必要的div</h6><p>因为React规定一个组件只能有一个父元素，我们可以通过<code>React.Fragment</code>或<code>&lt;&gt;&lt;/&gt;</code>来代替不必要的div。</p><h2 id="HTTP-浏览器缓存"><a href="#HTTP-浏览器缓存" class="headerlink" title="HTTP/浏览器缓存"></a>HTTP/浏览器缓存</h2><p>浏览器缓存(Brower Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力。</p><h3 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h3><ul><li><code>200 form memory cache</code> :不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。<strong>浏览器关闭后，数据将不存在（资源被释放掉了）</strong>，再次打开相同的页面时，不会出现from memory cache。</li><li><code>200 from disk cache</code>：不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，<strong>关闭浏览器后，数据依然存在</strong>，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。</li><li>优先访问<code>memory cache</code>,其次是<code>disk cache</code>，最后是<strong>请求网络资源</strong></li></ul><p>http缓存机制主要在<strong>http响应头</strong>中设定，响应头中相关字段为<code>Expires</code>、<code>Cache-Control</code>、<code>Last-Modified</code>、<code>Etag</code>。</p><h3 id="强缓存、协商缓存"><a href="#强缓存、协商缓存" class="headerlink" title="强缓存、协商缓存"></a>强缓存、协商缓存</h3><p>在第一次请求时，没有缓存，直接向服务器发送请求，服务器可能会将一些关于缓存的字段放入响应头。</p><p>第二次浏览器请求某一资源时：</p><ul><li>强缓存 <code>Cache-Control</code>（max-age,优先级高）、<code>Expires</code>(GMT）=&gt; 判断<strong>是否过期</strong><ul><li>没过期则直接从缓存中获取资源信息，<strong>不会与服务器进行通信</strong>。</li><li>如果两者同时存在，以 <code>Cache-Control</code> 为准。</li><li><code>Cache-Control:max-age=3600</code>，代表着资源的有效期是3600秒。除了该字段外，还有下面几个比较常用的设置值：<ul><li><code>no-cache</code>：<strong>不使用本地缓存</strong>。需要使用<strong>协商缓存</strong>。</li><li><code>no-store</code>：直接<strong>禁止游览器缓存数据</strong>，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</li><li><code>public</code>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</li><li><code>private</code>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</li><li><code>max-age</code> 为 0 可以近似理解为与 <code>no-cache</code> 等效。</li></ul></li></ul></li></ul><ul><li><p>协商缓存 <strong>由服务器来确定缓存资源是否可用</strong></p><ul><li><p><code>Last-Modified + If-Modified-Since http1.0</code></p><ul><li><p>Last-Modified：浏览器向服务器发送资源最后的修改时间。</p></li><li><p>If-Modified-Since：</p><p>当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有<code>Last-Modified</code>声明，则再次向服务器请求时带上头<code>If-Modified-Since</code>，表示请求时间。服务器收到请求后发现有<code>If-Modified-Since</code>则与被请求资源的最后修改时间进行对比（<code>Last-Modified</code>）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，<code>HTTP 200 OK</code>;若最后修改时间较旧（小），说明资源无新修改，响应<code>HTTP 304</code> 走缓存。</p></li></ul></li><li><p><code>Etag+ If-None-Match HTTP 1.1</code></p><ul><li><p>Etag是属于HTTP 1.1属性，它是由服务器（Apache或者其他工具）生成返回给前端，用来帮助服务器控制Web端的缓存验证。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</p></li><li><p>If-None-Match：当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头If-None-Match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304。</p></li><li><p>如果同时设了 <code>ETag</code> 和 <code>Last-Modified</code>，那么必须<strong>同时满足条件才会 304</strong>，不存在谁更优先就使用谁一说。</p><p>但一般分布式环境下（比如 CDN）很少使用 <code>ETag</code>，因为 <code>ETag</code> 依赖 Web Server 的哈希算法，不同 Web Server、不同版本、不同的配置，都会导致同样的文件 <code>ETag</code> 可能是不相等的。当然了，如果你能限制上述信息都一样，也可以使用 <code>ETag</code>，并不绝对。</p></li></ul></li></ul></li></ul><h3 id="缓存发展"><a href="#缓存发展" class="headerlink" title="缓存发展"></a>缓存发展</h3><p>强缓存有缺点，比如说，设置了<code>expires</code>，<code>GMT</code>格式，但是可能客户端与服务器时间不一致，或者网络延迟导致时间不准确，因此就通过<code>cache-control</code>返回一个<strong>相对时间</strong>来。</p><p>但是假如说<strong>资源并没有更新</strong>，但是强缓存时间过期了，那就需要重新拉去资源，因此就有了<code>Last-Modified</code>。</p><p>但是<code>last-modified</code>的时间单位是<code>s</code>，当1s内有资源修改，那浏览器返回的最后修改时间和上次的修改时间相同，那就不会重新拉取资源，还有可能**内容并不改变(仅仅改变的修改时间)**。</p><p>因此推出了<code>Etag</code>，通过<strong>比对资源内容</strong>来判断是否修改。</p><h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><ul><li><p><strong>浏览器地址栏中写入URL，回车 / 普通刷新F5</strong></p><p>不同浏览器和不同类型资源缓存方式不同，个人理解：</p><ul><li>返回200，并显示从缓存中获取，则为强缓存（虽然没有发出真实的 http 请求）。</li><li>返回304，说明是协商缓存命中走<strong>缓存</strong>。</li></ul></li><li><p><strong>强制刷新Ctrl+F5</strong> 删除缓存，重新请求。</p></li></ul><h2 id="浏览器解析渲染"><a href="#浏览器解析渲染" class="headerlink" title="浏览器解析渲染"></a>浏览器解析渲染</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/LuRQC4"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/04/13/LuRQC4.jpg" alt="LuRQC4.jpg"></a></p><p>请求回来的文档数据先保存在网络进程。在提交文档阶段，浏览器进程将网络进程接收到的HTML数据提交给渲染进程。</p><ul><li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</li><li>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；</li><li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li></ul><p>浏览器解析渲染页面分为以下步骤：</p><ul><li>根据 HTML 解析出 DOM 树<ul><li><strong>图片/CSS不会影响解析</strong></li><li><code>&lt;script&gt;</code><strong>阻塞渲染并停止HTML的解析</strong>（因为它可能操作dom）</li><li><strong>预加载</strong>在后台检索资源，可以减少阻塞</li><li>display:none被隐藏的节点也会在dom树上</li></ul></li><li>根据 CSS 解析生成 CSS 规则树（<strong>CSSOM</strong>）</li><li>结合 DOM 树和 CSS 规则树，生成渲染树<ul><li><code>&lt;head&gt;</code>和它的<strong>子节点</strong>以及任何具有<code>display: none</code>样式的结点，不会出现在Render树上</li><li><code>visibility: hidden</code>的节点会出现在Render树上</li><li><code>display: none</code> 会引起页面的<strong>回流</strong>(重排)以及<strong>重绘</strong>，而<code>visibility: hidden</code>只会引起<strong>重绘</strong></li></ul></li><li>根据渲染树计算每一个节点的信息</li><li>根据计算好的信息绘制页面<ul><li>第一次确定节点的大小和位置称为布局。</li><li>随后对节点大小和位置的重新计算称为<strong>回流</strong>，不改变大小位置的样式改变为<strong>重绘</strong>。</li><li>对布局树进行分层，并生成分层树，为每个图层生成绘制列表，并将其提交到合成线程。</li><li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li><li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程，浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</li><li>可以将内容提升到GPU上的层（而不是CPU上的主线程）可以提高绘制和重新绘制性能。<ul><li>有一些特定的属性和元素可以<strong>实例化一个层</strong>，包括<code>&lt;video&gt;</code>和<code>&lt;canvas&gt;</code>，任何CSS属性为<code>opacity</code>、3D <code>transform</code>等</li><li>分层确实可以提高重绘速度，但是它以<strong>内存管理</strong>为代价。</li></ul></li></ul></li></ul><h2 id="script标签属性"><a href="#script标签属性" class="headerlink" title="script标签属性"></a>script标签属性</h2><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>async标记告诉浏览器在等待js下载期间可以去干其他事，当js下载完成后会<strong>立即(尽快)执行</strong>，<strong>多条js可以并行下载</strong>。</p><p>async的好处是让多条js不会互相等待，<strong>下载期间浏览器会去干其他事(继续解析HTML等)<strong>，</strong>异步下载，异步执行</strong>。</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>与async一样，defer标记告诉浏览器在等待js下载期间可以去干其他事，<strong>多条js可以并行下载</strong>，不过当js下载完成之后<strong>不会立即执行</strong>，而是会等待解析完整个HTML之后在开始执行，而且多条defer标记的js会<strong>按照顺序执行</strong>。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>如果两个script之间<strong>没有依赖关系</strong>并且<strong>无需等待页面解析</strong>的更加适合使用<code>async</code>，反之如果两个script之间<strong>有依赖关系</strong>，或者希望<strong>优先解析HTML</strong>，则<code>defer</code>更加适合。</p><p>defer脚本会在文档渲染完毕后，<code>DOMContentLoaded</code>事件调用前执行。</p><h2 id="重绘-回流"><a href="#重绘-回流" class="headerlink" title="重绘/回流"></a>重绘/回流</h2><h3 id="回流-重排reflow"><a href="#回流-重排reflow" class="headerlink" title="回流/重排reflow"></a>回流/重排reflow</h3><p><strong>对节点大小和位置的重新计算</strong></p><h3 id="重绘Repaint"><a href="#重绘Repaint" class="headerlink" title="重绘Repaint"></a>重绘Repaint</h3><p><strong>不改变大小位置的样式改变</strong>（color、background-color、visibility）。</p><p>元素的回流会导致所有子元素和祖先元素以及 DOM 中跟随它的任何元素的后续<strong>回流</strong>。</p><p>在很多情况下，它们相当于<strong>重新布局整个页面</strong>。</p><p>回流一定会导致重绘，重绘成本也很高，<strong>因为浏览器必须验证 DOM 树中所有其他节点的可见性</strong>。</p><p>相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</p><p>不幸的是，很多事情都会引发回流。其中一些在编写 CSS 时特别相关：</p><ul><li><strong>调整窗口大小</strong></li><li><strong>添加或删除样式表</strong></li><li><strong>内容更改</strong>，例如用户在输入框中键入文本</li><li><strong>激活 CSS 伪类</strong>，例如 :hover（在 IE 中激活兄弟的伪类）</li><li><strong>操作 DOM 的脚本</strong></li></ul><h3 id="避免回流-重绘"><a href="#避免回流-重绘" class="headerlink" title="避免回流/重绘"></a>避免回流/重绘</h3><ul><li><p><strong>浏览器队列优化机制</strong></p><p>现代浏览器不会对每次回流重绘都进行操作，而是把涉及回流重绘的操作放到一个队列里面，当一段时间后或者队列放满了后，浏览器会一次性将队列中所有的操作执行，这样就会大大的减少回流重绘的次数，提高性能，但是当代码执行过程中需要获取某些元素的位置信息(比如执行到一些js自带获取位置信息的api时)，该队列会被强制刷新，这些api有：offsetLeft，offsetTop, offsetWidth, offsetHeight, clientWidth, clientHeigth，clientLeft，clientTop，scrollWidth, scrollHeight, scrollLeft, scrollTop， getBoundingClientRect()…</p></li><li><p><strong>CSS</strong></p><ul><li>使用transform来代替top(css硬件加速，相同效果前者少一个layout延时) 常见的触发硬件加速的css属性：transform，opacity，filters，Will-change</li><li>避免使用table布局</li><li>尽量避免多层嵌套，结构尽量扁平化</li><li>对于有复杂动画效果的DOM元素应该将其独立处出来，脱离文档流。应用<code>fixed</code>或<code>absolute</code>定位。</li><li>使用visibility，opacity 代替 display: none (前者的展现只涉及重绘， 后者需要回流)</li></ul></li></ul><ul><li><strong>JS</strong><ul><li><strong>避免频繁操作DOM</strong></li><li>React的虚拟DOM的作用是将真实 DOM 的副本存储在内存中。当您修改 DOM 时，它首先将这些更改应用到内存中的 DOM。然后，使用它的差异算法，找出真正发生了什么变化。最后，它对更改进行批处理，并调用一次将它们应用到real-dom 上。因此，<strong>最大限度地减少了回流和重绘。</strong></li></ul></li></ul><h3 id="display：none和visibility：hidden的区别"><a href="#display：none和visibility：hidden的区别" class="headerlink" title="display：none和visibility：hidden的区别"></a>display：none和visibility：hidden的区别</h3><ul><li>display：none隐藏完元素所占据的空间也会消失 。visibility：hidden隐藏完元素还是占据空间。</li><li>display：none没有继承性，visibility：hidden有继承性。给父元素设置visibility：hidden，其子元素也会继承该属性，如果给子元素设置visibility：visible，则子元素会显示出来。</li><li>visibility：hidden不会影响计数器的运算，比如ol标签中的li标签，隐藏其中的第二个标签，后续标签的序号不变，而如果使用display：none后续标签的序号会衔接上去上一个。</li><li>CSS3的transition支持visibility属性，但是并不支持display</li><li>display:none会引起回流(重排)和重绘 visibility:hidden会引起重绘</li></ul><h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><p><code>React</code>、<code>Vue</code>、<code>Angular</code> 等基于客户端渲染的前端框架，这类框架所构建的单页应用（SPA）具有<strong>用户体验好、渲染性能好、可维护性高</strong>等优点。但也也有一些很大的缺陷，其中主要涉及到以下两点：</p><ol><li>首屏加载时间过长</li></ol><blockquote><p>与传统服务端渲染直接获取服务端渲染好的 <code>HTML</code> 不同，单页应用使用 <code>JavaScript</code> 在客户端生成 <code>HTML</code>来呈现内容，用户需要等待客户端 <code>JS</code> 解析执行完成才能看到页面，这就使得首屏加载时间变长，从而影响用户体验。</p></blockquote><p>2.不利于 SEO</p><blockquote><p>当搜索引擎爬取网站 <code>HTML</code> 文件时，单页应用的 <code>HTML</code> 没有内容，因为他它需要通过客户端 <code>JavaScript</code> 解析执行才能生成网页内容，而目前的主流的搜索引擎对于这一部分内容的抓取还不是很好。为了解决这两个缺陷，业界借鉴了传统的服务端直出 <code>HTML</code> 方案，提出在服务器端执行前端框架（<code>React/Vue/Angular</code>）代码生成网页内容，然后将渲染好的网页内容返回给客户端，客户端只需要负责展示就可以了；</p></blockquote><p>这里为了让大家更好的理解服务端渲染应用，我们要从以下这几个小点出发，一点点进行学习</p><ul><li>渲染是什么？本质是什么？</li><li>传统的服务端渲染优势在哪？，不足在哪里</li><li>客户端渲染</li><li>现代化的服务端渲染（同构渲染）</li></ul><h3 id="什么是渲染"><a href="#什么是渲染" class="headerlink" title="什么是渲染"></a>什么是渲染</h3><blockquote><ol><li>浏览器会解析三个东西：</li></ol><ul><li>一个是HTML/SVG/XHTML，事实上，Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree。</li><li>CSS，解析CSS会产生CSS规则树。</li><li>Javascript，脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree.</li></ul><ol><li>解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。注意：<strong>Rendering Tree 渲染树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了。</strong> CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element。也就是DOM结点。也就是所谓的Frame。然后，计算每个Frame（也就是每个Element）的位置，这又叫layout和reflow过程。</li><li>最后通过调用操作系统Native GUI的API绘制。</li></ol></blockquote><p>例如对于我们前端开发者来说最常见的一种场景就是：<em>请求后端接口数据，然后将数据通过模板绑定语法绑定到页面中，最终呈现给用户。这个过程就是我们这里所指的渲染</em>。</p><p>渲染本质其实就是字符串的解析替换，实现方式有很多种</p><h3 id="传统的服务端渲染"><a href="#传统的服务端渲染" class="headerlink" title="传统的服务端渲染"></a>传统的服务端渲染</h3><p>服务端运行过程中将所需的数据结合页面模板渲染为<code>HTML</code>，响应给客户端浏览器。</p><h4 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h4><ol><li>客户端发送请求给服务器</li><li>服务器查询数据库，使用视图、模板引擎等拼接成html字符串，返回给客户端</li><li>客户端渲染html</li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>缺点<ul><li>应用的前后端部分完全耦合在一起，前端写完页面样式和结构后，再将页面交给后端套数据，最后再一起联调。</li><li>前端的发布过于依赖于后端的同学；</li><li>前端没有足够的发挥空间，无法充分利用现在前端生态下的一些更优秀的方案；（能不能让前端又可以摸鱼事情还不用做就更好了）</li><li>由于内容都是在服务端动态生成的，所以服务端的压力较大；</li><li>相比目前流行的 SPA 应用来说，用户体验一般；</li></ul></li></ul><p>优点 - 页面渲染速度快 - 同时 SEO 效果好。</p><p><em>但是不得不说，在网页应用并不复杂的情况下，这种方式也是可取的。</em></p><h3 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h3><p>传统的服务端渲染有很多问题，但是这些问题随着客户端 <code>Ajax</code> 技术的普及得到了有效的解决，<code>Ajax</code> 技术可以使得客户端动态获取数据变为可能，<strong>也就是说原本服务端渲染这件事儿也可以拿到客户端做了</strong>。</p><p>我们就可以把【<strong>数据处理</strong>】和【<strong>页码渲染</strong>】这两件事儿分开了，也就是【<strong>后端</strong>】负责数据处理，【<strong>前端</strong>】负责页面渲染，这种分离模式极大的提高了开发效率和可维护性。</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ul><li>节省服务端资源,js动态生成页面,部署简单</li><li>局部刷新,无需每次都请求完整的页面,体验更好</li><li>前后端分离</li></ul></li><li>缺点<ul><li>首屏渲染慢,渲染前需要下载css和js资源</li><li>无法进行SEO</li></ul></li></ul><p>当然主要还是前后端分离了，让前端工作性质上了一个档次！</p><p>感谢客户端渲染！</p><blockquote><p><strong>对于客户端渲染的 SPA 应用的问题有没有解决方案呢？</strong></p><ul><li>服务端渲染，严格来说是现代化的服务端渲染，也叫同构渲染</li></ul></blockquote><h3 id="现代化的服务端渲染"><a href="#现代化的服务端渲染" class="headerlink" title="现代化的服务端渲染"></a>现代化的服务端渲染</h3><p>我们在上一小节了解到 SPA 应用有两个非常明显的问题：</p><ul><li>首屏渲染慢</li><li>不利于 SEO</li></ul><p>但是我们在复习过了服务端渲染之后，就会想到将客户端渲染的工作放到服务端渲染，这个问题不就解决了吗？</p><p>那当然不是用老版本的服务端渲染了啦，这就引出了<strong>同构渲染</strong>，也就是【<strong>服务端渲染</strong>】 + 【<strong>客户端渲染</strong>】。</p><h4 id="分析优缺点："><a href="#分析优缺点：" class="headerlink" title="分析优缺点："></a>分析优缺点：</h4><ul><li><strong>优点</strong>：<ul><li>首屏渲染速度快</li><li>有利于 SEO</li></ul></li><li><strong>缺点</strong>：<ul><li>开发成本高。</li><li>涉及构建设置和部署的更多要求。</li><li>server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)</li></ul></li></ul><h3 id="相关技术："><a href="#相关技术：" class="headerlink" title="相关技术："></a>相关技术：</h3><ul><li><p>React 生态中的 Next.js</p></li><li><p>Vue 生态中的 Nuxt.js</p></li><li><p>Angular 生态中的 Angular Universal</p></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在对你的应用程序使用服务器端渲染 (<strong>SSR</strong>) 之前，你应该问的第一个问题是： <strong>是否真的需要它</strong>。</p><blockquote><ul><li>例如，如果你<strong>正在构建一个内部仪表盘</strong>，<strong>初始加载时的额外几百毫秒并不重要</strong>，这种情况下去<strong>使用服务器端渲染 (SSR) 将是一个小题大作之举</strong></li><li>如果内容到达时间要求是<strong>绝对关键的指标</strong>，在这种情况下，<strong>服务器端渲染(SSR) 可以帮助你实现最佳的初始加载性能</strong>。</li></ul></blockquote><p>事实上，很多网站是出于效益的考虑才启用服务端渲染，性能倒是在其次。</p><blockquote><ul><li>假设 A 网站页面中有一个关键字叫“前端性能优化”，这个关键字是 JS 代码跑过一遍后添加到 HTML 页面中的。</li></ul></blockquote><blockquote><ul><li>那么客户端渲染模式下，我们在搜索引擎搜索这个关键字，是找不到 A 网站的——搜索引擎只会查找现成的内容，不会帮你跑 JS 代码。</li><li>A网站的运营方见此情形，感到很头大：搜索引擎搜不出来，用户找不到我们，谁还会用我的网站呢？</li></ul></blockquote><p><strong>为了把“现成的内容”拿给搜索引擎看，A 网站不得不启用服务端渲染</strong>。</p><p>说白了，一切实用性为主，业务为辅，一切为炫技而做的事情说白了，都是要贴近团队、产品的！</p><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>HTML用于控制网页的结构，CSS用于控制网页的外观，JavaScript控制的是网页的行为。</p><h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><h3 id="其他语言对比"><a href="#其他语言对比" class="headerlink" title="其他语言对比"></a>其他语言对比</h3><p><strong>解释代码 vs 编译代码</strong></p><ul><li><p>在<strong>解释型</strong>语言中，代码<strong>自上而下</strong>运行，且<strong>实时返回运行结果</strong>。代码将直接以<strong>文本格式（text form）</strong>被接收和处理。解释型语言代表有：JS、MATLAB、Python和Java。</p></li><li><p>相对的，<strong>编译型</strong>语言需要先将代码<strong>转化（编译）</strong>成另一种形式才能运行。比如 C/C++ 先被<strong>编译成汇编语言</strong>，然后才能由计算机运行。程序将以<strong>二进制</strong>的格式运行，这些二进制内容是由程序源代码产生的。</p></li><li><p>编译性语言不如解释性语言跨平台性好，也就是说不同平台的兼容性有区别，所以才有了两种语言。用c语言开发了程序后，需要通过编译器把程序编译成机器语言（即计算机识别的二进制文件，因为不同的操作系统计算机识别的二进制文件是不同的），所以c语言程序进行移植后，要重新编译。（如windows编译成ext文件，linux编译成erp文件）。java程序首先通过编译器编译成class文件，如果在windows平台上运行，则通过windows平台上的java虚拟机（VM）进行解释。如果运行在linux平台上，则通过linux平台上的java虚拟机进行解释执行。所以说能跨平台，前提是平台上必须要有相匹配的java虚拟机。如果没有java虚拟机，则不能进行跨平台。</p></li><li><p><strong>JavaScript 是轻量级解释型语言</strong>。</p><ul><li>浏览器接受到JavaScript代码，并以代码自身的文本格式运行它。</li><li>技术上，几乎所有 JavaScript 转换器都运用了一种叫做<strong>即时编译（just-in-time compiling）</strong>的技术；</li><li>当 JavaScript 源代码被执行时，它会被编译成<strong>二进制</strong>的格式，使代码<strong>运行速度更快</strong>。</li><li>尽管如此，JavaScript 仍然是一门解释型语言，因为<strong>编译过程发生在代码运行中，而非之前</strong>。</li></ul></li><li><p><strong>编译型与解释型的共同点</strong></p><p>他们都要弄成二进制代码才能执行，两类编程语言的源代码都是英文，但是我们的计算机并不认识英文，所以都要转化成二进制才能执行。区别就在于“转化的方式”不一样。</p></li><li><p><strong>编译型与解释型的不同点</strong></p><ul><li><p>从运行效果上来看。编译型语言要等全部写完后通过编译器去生成一个类似<code>*.exe</code>的二进制文件，然后双击这个文件才可以看到效果。而解释型语言并没生成<code>*.exe</code>文件，而是直接生成效果。</p></li><li><p>运行的时候是否需要编译器的伴随。编译型语言运行的是最终生成的二进制代码，所以不需要编译器伴随。而解释型语言则一边解释一边运行，所以运行的时候很可能还有部分代码没有解释好，所以需要编译器伴随（解释型语言把该工具叫做解释器）。</p><p>举个例子，网页的解释器就在浏览器中，所以要看HTML的效果必须用浏览器或者有编译工具在内的其他工具打开，比如：模拟浏览器的工具。</p></li><li><p>执行的速度对比。编译型语言运行的已经是完全的二进制内容，运行起来十分干净利落，所以速度很快。而解释型语言运行的不一定是完全的二进制内容，因为它是一边解释成二进制一边运行。</p></li><li><p>可移植性对比。编译型语言是运行二进制内容，所以一旦CPU指令系统改变，那么之前的二进制文件可能运行不了。比如，如果到其他硬件平台上运行，就可能出现错误，就需要根据该平台重新编译出新的二进制文件。所以可移植性、平台兼容性比价差。而解释型语言则没有弄成什么二进制内容，而是在需要的时候才开始编译、运行。所以它自然具有可移植性，即在任何平台都可以马上运行起来。</p><p>要注意的是它的解释工具如：浏览器，本身就是编译型语言解释出来的二进制代码，所以浏览器本身不具备可移植性，是需要针对不同的平台弄出对应的浏览器最终二进制文件的，这里可别混淆。</p></li><li><p>升级上对比。编译型语言弄出来的二进制文件若要升级，自然要重新下载一个新的二进制文件。所以重新下载、安装、覆盖是最大的特点。而解释型的语言只要重新写好源代码即可，用户想要最新的效果，只要刷新一下即可，所以体验性好。比如：某网站平台升级了，用户只要重新刷新一下。</p></li><li><p>应用领域，编译型语言应用领域通常是那些安装软件，例如桌面上的安装软件。解释型的语言的应用领域通常是互联网、网站等那种刷新了一下就可以看到最新效果的领域。</p></li></ul></li></ul><p><strong>服务器端代码 vs 客户端代码</strong></p><ul><li><p>客户端代码是在用户的电脑上运行的代码，在浏览一个网页时，它的客户端代码就会被下载，然后由浏览器来运行并展示。</p></li><li><p>而服务器端代码在服务器上运行，运行结果由浏览器下载并展示出来。</p><ul><li>流行的服务器端 web 语言包括：PHP、Python、Ruby、ASP.NET 以及…… JavaScript！</li><li><strong>JavaScript 也可用作服务器端语言</strong>，比如现在流行的 Node.js 环境。</li></ul></li></ul><p><strong>强类型 Vs. 弱类型</strong></p><ul><li>强和弱是一个相对的概念，强是指倾向于将<strong>未定义的行为</strong>视作错误（Java、Python），弱是指倾向于进行<strong>隐式的转换</strong>、忽略类型相关的错误（JavaScript）。<strong>如果语言经常隐式地转换变量的类型</strong>，那这个语言就是弱类型语言，如果很少会这样做，那就是强类型语言。</li><li>很多设计得不够严谨的语言，虽然大多数情况下（或者我们通常鼓励大家这么做）是强类型的，但也有弱类型的部分（PHP）</li><li>还有的语言因为提供的抽象能力很弱，我们不得不去用弱类型的部分（C）</li><li>鸭子类型（duck typing）是强弱类型的一个折中（常见于动态类型中，例如 Python），兼顾了灵活性和严谨性。</li><li>我们认为弱类型是为了方便，而强类型是为了尽早发现错误。</li></ul><p><strong>动态类型 Vs. 静态类型</strong></p><ul><li>静态类型的变量的类型是在编译时确定的（C++、Java）；动态类型的类型是在运行时确定的（JavaScript、Python），例如你可以在一个 if 的两个分支里给一个变量赋值不同的类型。</li><li>有的动态类型语言也会添加编译期的类型检查（TypeScript、Python），但因为语言本身的动态性，这些检查仅能覆盖一部分情况。</li><li>在动态类型的语言中因为类型不那么重要，所以很多时候甚至没有提供指定类型的语法（隐含了运行时的自动推导）；而在静态类型语言里通常需要为变量指定类型，所以才有了编译期自动类型推导来提供便利，而动态类型语言则做不到这一点（因为不能在编译期确定类型，更无从推导）。</li><li>我们认为静态类型有助于在编译时发现有关类型的错误，确定的类型也给了编译期更多的优化空间；而动态类型给了开发者更高的灵活度。</li></ul><p><strong>虚拟机 VS. 本地代码</strong></p><ul><li>虚拟机是指在语言和 CPU 之间还有一个用于进行翻译的层次（JavaScript、Java）；无虚拟机是指编译器直接生成本地代码给 CPU 执行（C/C++、Golang）。</li><li>虚拟机也提供了更为复杂的运行时的动态特性，但这些特性有的时候也可以在没有虚拟机的情况下实现（例如 C++ 的运行时类型识别、Go 的 GC）。</li><li>虚拟机可以以解释的方式执行（Python，将代码视作一种数据指令来执行），也可以即时编译（JIT）的方式来执行（V8，先将代码编译到本地代码然后执行），有时也会混合这两种方式（为了更快的启动速度）。</li><li>我们认为无虚拟机的语言可以在更低的层次和其他程序交互，同时也天然地有着更好的性能；而有虚拟机的语言则可以轻松地跨平台，针对特定的架构在运行时即时编译出更高性能的代码。</li></ul><h3 id="基于类-vs-基于原型的语言"><a href="#基于类-vs-基于原型的语言" class="headerlink" title="基于类 vs 基于原型的语言"></a>基于类 vs 基于原型的语言</h3><p><strong>基于类的面向对象语言</strong>，比如 Java 和 C++，是构建在两个不同实体之上的：类和实例。</p><ul><li>一个<strong>类(class)<strong>定义了</strong>某一对象集合所具有的特征性属性</strong>（可以将 Java 中的方法和域以及 C++ 中的成员都视作属性）。<strong>类是抽象的，而不是其所描述的对象集合中的任何特定的个体。</strong></li><li>另一方面，<strong>一个实例(instance)是一个类的实例化</strong>。<strong>实例具有和其父类完全一致的属性</strong>。</li></ul><p><strong>基于原型的语言（如 JavaScript）</strong>并不存在这种区别：它<strong>只有对象</strong>。</p><p>基于原型的语言具有所谓**原型对象(prototypical object)**的概念。</p><p><strong>原型对象可以作为一个模板，新对象可以从中获得原始的属性。</strong></p><p>任何对象都可以指定其自身的属性，既可以是创建时也可以在运行时创建。</p><p><strong>任何对象都可以作为另一个对象的原型(prototype)，从而允许后者共享前者的属性</strong>。</p><table><thead><tr><th align="left">基于类的（Java）</th><th align="left">基于原型的（JavaScript）</th></tr></thead><tbody><tr><td align="left">类和实例是不同的事物。</td><td align="left">所有对象均为实例。</td></tr><tr><td align="left">通过类定义来定义类；通过构造器方法来实例化类。</td><td align="left">通过构造器函数来定义和创建一组对象。</td></tr><tr><td align="left">通过 <code>new</code> 操作符创建单个对象。</td><td align="left">相同。</td></tr><tr><td align="left">通过类定义来定义现存类的子类，从而构建对象的层级结构。</td><td align="left">指定一个对象作为原型并且与构造函数一起构建对象的层级结构</td></tr><tr><td align="left">遵循类链继承属性。</td><td align="left">遵循原型链继承属性。</td></tr><tr><td align="left">类定义指定类的所有实例的<strong>所有</strong>属性。无法在运行时动态添加属性。</td><td align="left">构造器函数或原型指定实例的<strong>初始</strong>属性集。允许动态地向单个的对象或者整个对象集中添加或移除属性。</td></tr></tbody></table><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向对象是把构成问题事务分解成各个对象，<strong>建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</strong></p><p>万事万物皆对象。面向对象的思想主要是以对象为主，将一个问题抽象出具体的对象，并且将抽象出来的对象和对象的属性和方法封装成一个类。</p><ul><li><strong>面向过程</strong>的特点在于<strong>逻辑性强</strong>，符合思维方式和解决问题的流程。</li><li><strong>面向对象</strong>的特点就是<strong>可扩展性更强</strong>一些，解决了<strong>代码重用性</strong>的问题。</li></ul><p>js中对象，对象下的方法和属性，都是储存在<strong>内存</strong>中的，调用的时候，是可以随时拿到这些属性和方法的。</p><p>在编程中使用OOP就是为了<strong>提高代码的复用性</strong>，而提高代码复用性的根本原因是为了<strong>降低内存的使用率</strong>。</p><p>面向对象程序设计的<strong>目的</strong>是在编程中促进更好的<strong>灵活性和可维护性</strong>，在大型软件工程中广为流行。即代码各部分相对独立，耦合性低，且功能明确，遇到bug或者更改需求，都可以直接针对特定的对象进行修改，便于维护。另外，面向对象凭借其对<strong>模块化</strong>的重视，面向对象的代码开发更简单，更容易理解，相比非模块化编程方法 , 它能更直接地分析, 编码和理解复杂的情况和过程。</p><p><strong>面向对象有三大特性，封装、继承和多态</strong></p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>封装主要实现的功能就是将数据隐藏，只暴露出有限的接口。</strong></p><p>在js中万物皆对象，字符串、数值、数组、函数都属于Object。因此js基本的创建对象的方法有两种：</p><ul><li><p><strong>对象字面量法</strong></p></li><li><p><strong>new对象</strong></p></li></ul><p><strong>但这两种方法都会产生大量重复代码，基于面向对象思想，我们使用新的方式创建对象。</strong></p><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式如同它的名字一般，将对象从原料加工、制作、最后出厂，可实现大批量的功能相似产品对象！</p><p><strong>工厂模式的优缺点</strong>：虽然解决了创建相似对象的问题，但是却没有解决对象识别问题（即怎样知道一个对象的类型）。</p><h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><p>构造函数其实就是普通的函数，只不过有以下的特点：</p><ul><li><strong>首字母大写</strong>（建议构造函数首字母大写，即使用大驼峰命名，非构造函数首字母小写）</li><li>内部使用this</li><li>使用 new生成实例</li></ul><p><strong>构造函数模式的优缺点</strong>：</p><ul><li>优点：创建自定义函数意味着将来可以将它的实例标识为一种特定的类型，这是构造函数胜过工厂模式的地方.</li><li>缺点：每个方法都要在每个实例上重新创建一遍.</li></ul><h4 id="原型-类-模式"><a href="#原型-类-模式" class="headerlink" title="原型(类)模式"></a>原型(类)模式</h4><p><strong>原型模式的优缺点：</strong></p><ul><li>优点：可以让所有的对象实例共享它所包含的属性和方法</li><li>缺点：原型中是所有属性都是<strong>共享</strong>的，但是实例一般都是要有自己的单独属性的。所以一般很少单独使用原型模式。</li></ul><h4 id="混合模式（常用作封装类）"><a href="#混合模式（常用作封装类）" class="headerlink" title="混合模式（常用作封装类）"></a>混合模式（常用作封装类）</h4><p>通过构造函数模式定义实例（私有）属性，而原型模式用于定义方法和共享的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name,age</span>)</span>&#123;<span class="comment">//定义私有属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayname = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;<span class="comment">//定义公有属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;chen&quot;</span>,<span class="number">22</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;qian&quot;</span>,<span class="number">21</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.age);<span class="comment">//22</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.age);<span class="comment">//21</span></span><br><span class="line">person1.sayname()<span class="comment">//chen</span></span><br><span class="line">person2.sayname()<span class="comment">//qian</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayname===person2.sayname);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//改变person1的属性和方法</span></span><br><span class="line">person1.age = <span class="number">26</span>;</span><br><span class="line">person1.sayname = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&quot;change&quot;</span>)&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person1.age);<span class="comment">//26     </span></span><br><span class="line"><span class="built_in">console</span>.log(person2.age);<span class="comment">//21  person2不受影响</span></span><br><span class="line">person1.sayname()<span class="comment">//change</span></span><br><span class="line">person2.sayname()<span class="comment">//qian  person2访问原型的方法，不受影响</span></span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>引入继承性的好处</p><ul><li>减少了代码的冗余，提高了代码的复用性</li><li>便于功能的扩展</li><li>为之后多态性的使用，提供了前提</li></ul><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>通过将<strong>子类的原型对象指向父类的实例</strong>，实现继承访问父类属性方法等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line">SubType.prototype.constructor = SubType; <span class="comment">// 修复constructor使符合原型链规定</span></span><br></pre></td></tr></table></figure><p>原型链方案存在的缺点：</p><ul><li>由于所有SubType实例原型都指向同一个SuperType实例, 因此<strong>对某个SubType实例的来自父类的引用类型变量修改会影响所有的SubType实例</strong>。</li><li>在创建子类实例时无法向父类构造传参, 即没有实现super()的功能。</li></ul><h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><p>构造函数继承，即在<strong>子类的构造函数中执行父类的构造函数，并为其绑定子类的this</strong>，让父类的构造函数把成员属性和方法都挂到子类的this上去，这样既<strong>能避免实例之间共享一个原型实例，又能向父类构造方法传参</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承自SuperType</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用<code>SuperType</code>构造函数，于是<code>SubType</code>的每个实例都会将<code>SuperType</code>中的属性复制一份。</p><p>缺点：</p><ul><li>只能继承父类的<strong>实例</strong>属性和方法，不能继承<strong>原型</strong>属性/方法</li><li>无法实现复用，每个子类实际上是调用父类来生成的实例</li></ul><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>组合上述两种方法就是组合继承。用原型链实现对<strong>原型</strong>属性和方法的继承，用借用构造函数技术来实现<strong>实例</strong>属性的继承。</p><p>缺点：</p><ul><li>第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性<code>name</code>，<code>color</code>。</li><li>第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性<code>name</code>，<code>color</code>。</li></ul><p>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象<code>SubType.prototype</code>的两个同名属性。所以，组合模式的缺点就是在<strong>使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</strong></p><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p><strong>解决构造函数被执行两次</strong>的问题, 我们将<strong>指向父类实例改为指向父类原型</strong>, 减去一次构造函数的执行。</p><p>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code> 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code> 和<code>isPrototypeOf()</code></p><p><strong>这是最成熟的方法，也是现在库实现的方法</strong>。</p><h4 id="ES6类继承extends"><a href="#ES6类继承extends" class="headerlink" title="ES6类继承extends"></a>ES6类继承extends</h4><p><code>extends</code>关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中<code>constructor</code>表示构造函数，一个类中只能有一个构造函数，有多个会报出<code>SyntaxError</code>错误,如果没有显式指定构造方法，则会添加默认的 <code>constructor</code>方法，使用例子如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(length, length);   </span><br><span class="line">    <span class="comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Square&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>多态</strong>（Polymorphism）按字面的意思就是“多种状态”,在面向对象语言中，接口的多种不同的实现方式即为多态。</p><p><strong>可以解释为：</strong>同样的操作作用于不同对象上面，可以产生不同的解释和不同的运行结果。换句话说，给不同对象发送统一消息的时候，这些对象会根据这个信息分别给出不同的反馈。</p><p>JavaScript的多态的思想实际上就是把“做什么”和“谁去做”分离开来，要实现这一点，归根结底就是解耦。</p><p><strong>区分方法的重写和重载？</strong></p><ul><li><p>二者的概念：</p><ul><li><p>方法的重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.</p></li><li><p>方法的重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p></li></ul></li><li><p>重载：不表现为多态性。 重写：表现为多态性。</p></li></ul><h2 id="Js中的堆栈"><a href="#Js中的堆栈" class="headerlink" title="Js中的堆栈"></a>Js中的堆栈</h2><p>堆<code>heap</code>是<strong>动态分配</strong>的内存，<strong>大小不定</strong>也<strong>不会自动释放</strong>，栈<code>stack</code>为<strong>自动分配</strong>的内存空间，在代码执行过程中<strong>自动释放</strong>。</p><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>在栈内存中提供一个供<code>Js</code>代码执行的环境，关于<strong>作用域</strong>以及<strong>函数的调用</strong>都是栈内存中执行的。</p><p><code>Js</code>中基本数据类型<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Null</code>、<code>Undefined</code>、<code>Symbol</code>、<code>BigInt</code>，</p><ul><li><strong>占用空间小且大小固定</strong>，<strong>值直接保存在栈内存中，是按值访问</strong>，</li><li>对于<code>Object</code>引用类型，其<strong>指针放置于栈内存中</strong>，<strong>指向堆内存的实际地址</strong>，是通过<strong>引用</strong>访问。</li></ul><p>关于调用栈，每调用一个函数，解释器就会把该函数添加进调用栈并开始执行；</p><p>正在调用栈中执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行；</p><p>当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码；</p><p>当分配的调用栈空间被占满时，会引发<strong>堆栈溢出</strong>错误。</p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>引用类型<code>Object</code>的变量<strong>占据空间大且大小不固定</strong>，堆内存中存储<strong>实际对象</strong>，在栈内存中存储对象的指针。</p><p>对于对象的访问是按引用访问的，在堆区的内存不会随着程序的运行而自动释放，这就需要实现<strong>垃圾回收机制</strong><code>GC</code>。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存。</p><p>并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存。</p><p>对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>需要注意的是在<code>Js</code>中没有类似于<code>C</code>中的<code>free()</code>函数去手动释放内存，对于堆区内存回收全部需要通过<code>Js</code>的垃圾回收机制去实现。<br>在<strong>栈</strong>区中执行的变量等是通过值访问，当其<strong>作用域销毁后变量也就随之销毁</strong>，</p><p>而使用引用访问的堆区变量，在一个作用域消失后还可能在外层作用域或者其他作用域仍然<strong>存在引用</strong>，不能直接销毁，</p><p>此时就需要通过算法计算该堆区变量是否属于不再需要的变量，从而决定是否需要进行内存回收，</p><p>在<code>Js</code>中主要有<strong>引用计数</strong>与<strong>标记清除</strong>两种垃圾回收算法。</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>对于引用计数垃圾回收算法，把对象是否不再需要简化定义为<strong>该对象有没有其他变量或对象引用到它</strong>，如果没有引用指向该对象，该对象将被垃圾回收机制回收。</p><p>在这里，对象的概念不仅特指<code>JavaScript</code>对象，还包括函数作用域或者全局词法作用域。</p><p>引用计数垃圾回收算法使用比较少，主要是在<code>IE6</code>与<code>IE7</code>等低版本<code>IE</code>浏览器中使用。</p><p>但是对于引用计数垃圾回收算法有个限制，当对象<strong>循环引用</strong>时，就会造成<strong>内存泄漏</strong>，也就是引用计数垃圾回收算法无法处理循环引用的对象。</p><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>对于标记清除垃圾回收算法，把对象是否不再需要简化定义为<strong>该对象是否可以获得</strong>。</p><p>该算法设置一个叫做根<code>root</code>的对象，在<code>Javascript</code>里根是全局对象，垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象，以此不断向下查找。</p><p><strong>从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象</strong>，这样便解决了循环引用的问题。</p><p>所有现代浏览器都使用了标记清除垃圾回收算法，所有对<code>JavaScript</code>垃圾回收算法的改进都是基于标记清除算法的改进。</p><ul><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都<strong>加上标记</strong>。</li><li>然后，它会<strong>去掉</strong>运行环境中的变量以及被环境中变量所引用的变量的标记。</li><li>此后，<strong>依然有标记</strong>的变量就被视为准备删除的变量，原因是<strong>在运行环境中已经无法访问到这些变量了</strong>。</li><li>最后，垃圾收集器完成内存清除工作，<strong>销毁那些带标记的值并回收它们所占用的内存空间</strong>。</li></ul><h3 id="常见内存泄露情况及解决方法"><a href="#常见内存泄露情况及解决方法" class="headerlink" title="常见内存泄露情况及解决方法"></a>常见内存泄露情况及解决方法</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    bar = <span class="string">&quot;this is a hidden global variable&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种意外的全局变量可能由 <code>this</code> 创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.variable = <span class="string">&quot;potential accidental global&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 调用自己，this 指向了全局对象（window）</span></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上述使用<strong>严格模式</strong>，可以避免意外的全局变量。</p><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>定时器也常会造成内存泄露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = getData();</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;Node&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        <span class="comment">// 处理 node 和 someResource</span></span><br><span class="line">        node.innerHTML = <span class="built_in">JSON</span>.stringify(someResource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>如果<code>id</code>为Node的元素从<code>DOM</code>中移除，该定时器仍会存在，同时，因为回调函数中包含对<code>someResource</code>的引用，定时器外面的<code>someResource</code>也不会被释放。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>包括我们之前所说的闭包，维持函数内局部变量，使其得不到释放。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">document</span>.createElement(<span class="string">&#x27;XXX&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj, <span class="string">&#x27;闭包内引用obj obj不会被释放&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  obj = <span class="literal">null</span>; <span class="comment">// 解决方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dom"><a href="#dom" class="headerlink" title="dom"></a>dom</h4><p>没有清理对<code>DOM</code>元素的引用同样造成内存泄露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refA = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;refA&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.removeChild(refA); <span class="comment">// dom删除了</span></span><br><span class="line"><span class="built_in">console</span>.log(refA, <span class="string">&#x27;refA&#x27;</span>); <span class="comment">// 但是还存在引用能console出整个div 没有被回收</span></span><br><span class="line">refA = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(refA, <span class="string">&#x27;refA&#x27;</span>); <span class="comment">// 解除引用</span></span><br></pre></td></tr></table></figure><h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>包括使用事件监听<code>addEventListener</code>监听的时候，在不监听的情况下使用<code>removeEventListener</code>取消对事件监听。</p><h4 id="解决内存泄漏的数据结构"><a href="#解决内存泄漏的数据结构" class="headerlink" title="解决内存泄漏的数据结构"></a>解决内存泄漏的数据结构</h4><p>WeakSet WeakMap</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote><p>JavaScript 是一种<strong>弱类型</strong>、<strong>动态</strong>语言。</p><p><strong>不用提前声明变量的类型</strong>，在程序<strong>运行</strong>过程中，<strong>类型会被自动确定</strong>。</p><p>可以使用<strong>同一个变量保存不同类型的数据</strong>。</p></blockquote><h3 id="7-1"><a href="#7-1" class="headerlink" title="7+1"></a>7+1</h3><ul><li>原始类型(值不可变，栈)：<code>Undefined</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>BigInt</code>、<code>Symbol</code>、<code>Null</code></li><li>引用数据类型（堆，地址：栈）：<code>Object</code>（几乎所有通过 <code>new</code> 创建的东西：Array、Set、Date）</li></ul><h2 id="模块化、组件化、工程化"><a href="#模块化、组件化、工程化" class="headerlink" title="模块化、组件化、工程化"></a>模块化、组件化、工程化</h2><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>后端：<strong>CommonJS</strong> :<code>module.exports</code>、<code>require</code>方法用于加载模块。</p><p>前端：<strong>ES6</strong> 模块化语法：export 和 import；</p><h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><p><code>webpack</code>最热门的前端资源模块化管理和打包工具、</p><p><code>create-react-app</code> 脚手架初始化react 项目开发、</p><p><code>ESLint</code> 插件化的 JavaScript 代码检测工具</p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>其中以React的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。</p><p>理解:<strong>用来实现局部功能效果的代码和资源的集合(html/css/js/img等等)</strong></p><p>为什么要用组件:一个界面的功能复杂</p><p>作用:<strong>复用编码,简化项目编码,提高运行效率</strong></p><p>当应用是以多组件的方式实现,这个应用就是组件化的应用。</p><h2 id="框架好处"><a href="#框架好处" class="headerlink" title="框架好处"></a>框架好处</h2><ol><li><strong>组件化</strong>: 其中以 React 的组件化最为彻底,甚至可以到<strong>函数级</strong>别的原子组件,高度的组件化可以是我们的工程<strong>易于维护、易于组合拓展</strong>。</li><li><strong>天然分层</strong>: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。</li><li><strong>生态</strong>: 现在主流前端框架都<strong>自带生态</strong>,不管是<strong>数据流管理架构</strong>还是 <strong>UI 库</strong>都有成熟的解决方案。</li><li><strong>开发效率</strong>: 现代前端框架都默认<strong>自动更新DOM</strong>,而非我们手动操作,解放了开发者的手动DOM成本,提高开发效率,从根本上解决了UI 与状态同步问题。</li></ol><p>常见框架：<strong>Angular React Vue Svelte</strong></p><h1 id="Android词典"><a href="#Android词典" class="headerlink" title="Android词典"></a>Android词典</h1><p>本文使用Java编程实现一款基于Android平台的电子词典，词典数据借助Python的Requests库和XPath进行内容的获取。</p><p>该电子词典主要实现五大功能：注册登录、单词功能、句子功能、学习功能和娱乐功能。单词功能实现主要借助SQLite数据库进行单词释义等内容的查询；句子功能主要通过调用API或SDK实现；学习功能主要指生词本和内嵌网页，生词本功能使用了MVVM的架构模式；娱乐功能则是影视金句的轮播图。制作一款电子词典APP不但具有重要的实用价值，而且对提高自己的编程能力、分析和解决问题的能力具有重要作用。</p><p>基于Android的电子词典设计</p><p>离线情况和有网络的情况。</p><h2 id="单词数据的爬取"><a href="#单词数据的爬取" class="headerlink" title="单词数据的爬取"></a>单词数据的爬取</h2><blockquote><p>借助Python的Requests库和lxml库</p></blockquote><ul><li><p>Requests构建HTTP的请求头<strong>伪装成浏览器与词典网站进行通信</strong>，<strong>发起请求</strong>和<strong>获取响应内容</strong>，对应的方法为<strong>get</strong>方法。主要是获得相应url对应的html。</p></li><li><p>XPath，全称 XML Path Language，即<strong>XML路径语言</strong>,以<strong>XML树结构</strong>为基础，能够在数据的结构树中查找各类节点，比如属性节点、文本节点和元素节点等等。在检查元素中右键即可复制它的XPath路径，分析规律并且结合XPath的表达式语法，就可获取相关文本内容。</p></li><li><p>本项目使用<code>Multiprocessing</code>的<code>Pool</code>方法设置一定进程数量的进程池，将所有需要爬虫的单词异步执行，也就是非阻塞的方式。</p></li><li><p>当时遇到的问题<strong>多进程爬取的数据无法同时向SQLite数据库中保存</strong>，因此先爬取内容到<code>TXT</code>，再保存到数据库中。</p></li></ul><h2 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h2><p>使用<strong>布局编辑器</strong>构建界面。</p><ul><li><p>根布局就是<code>DrawerLayout</code>，在根布局之后又主要分为两大部分，第一部分就是我们主界面的内容，第二部分是左边滑出的布局，这里用NavitationView来代替。</p></li><li><p>线性布局（<code>LinearLayout</code>）和相对布局（<code>RelativeLayout</code>）实现。</p><ul><li>线性布局是将界面中的全部控件按照<strong>水平</strong>或<strong>竖直</strong>方向进行排列，同时它也是最基本的布局方式。</li><li>相对布局则是通过控件之间的<strong>相对位置</strong>关系实现控件的摆放，有利于适配不同屏幕大小的手机，因此使用更为普遍。</li></ul></li><li><p>一般布局都是用<code>dp</code>，字体用<code>sp</code>（手机字体调大了，APP的字体会随之变大）来布局的，用来<strong>适配移动端分辨率</strong>。</p></li></ul><h2 id="API或SDK"><a href="#API或SDK" class="headerlink" title="API或SDK"></a>API或SDK</h2><p>调用百度API实现句子翻译的功能。调用讯飞开放平台的SDK实现语音输入的功能。</p><ul><li><p>API 全称 Application Programming Interface，即<strong>「应用程序接口」</strong>。一般是指一些预先定义的<strong>函数</strong>，目的是供应用程序与开发人员基于某软件或硬件得以访问一组程序的能力，而又无需访问源码，或理解内部工作机制的细节。</p></li><li><p>SDK 全称 Software Development Kit，<strong>软件开发工具包</strong>。通俗来讲就是<strong>第三方服务商提供的实现产品软件某项功能的工具包</strong>。例如 JDK 就是一种 SDK。</p></li><li><p><strong>API 在更多场合下更像是 SDK 的一个子集</strong>，他们的区别如下：</p><ul><li><p>API 通常是一个<strong>函数</strong>，有特定的功能；而 SDK 是一个很多功能函数的<strong>集合体</strong>，更像是一个<strong>工具包</strong>。</p></li><li><p>API 通常扮演<strong>数据接口</strong>的形象，SDK 相当于一个<strong>工具环境</strong>，通常是需要在 SDK 的环境下调用 APl。</p></li><li><p><strong>SDK 相较于 API 封装层次更高</strong>。</p></li></ul></li></ul><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过<strong>分离关注点</strong>的方式来组织代码结构，优化我们的开发效率。</p><h3 id="Android-MVC"><a href="#Android-MVC" class="headerlink" title="Android MVC"></a>Android MVC</h3><ul><li><p><strong>View：</strong>XML布局文件。</p></li><li><p><strong>Model：</strong>实体模型（数据的获取、存储、数据状态变化）。</p></li><li><p><strong>Controller：</strong>对应于Activity，处理数据、业务和UI。</p></li></ul><p>从上面这个结构来看，Android本身的设计还是符合MVC架构的，但是<strong>Android中纯粹作为View的XML视图功能太弱，我们大量处理View的逻辑只能写在Activity中，这样Activity就充当了View和Controller两个角色</strong>，直接导致Activity中的代码大爆炸。相信大多数Android开发者都遇到过一个Acitivty数以千行的代码情况吧！所以，更贴切的说法是，这个MVC结构最终其实只是一个<strong>Model-View（Activity:View&amp;Controller）</strong>的结构。</p><h3 id="Android-MVVM"><a href="#Android-MVVM" class="headerlink" title="Android MVVM"></a>Android MVVM</h3><p>**View: **对应于Activity和XML，负责View的绘制以及与用户交互。</p><p>**Model: **实体模型。</p><p><strong>ViewModel: <strong>负责完成View与Model间的交互，负责</strong>业务逻辑</strong>。</p><p>Android为此提供了一套<strong>架构组件</strong>，主要有LiveData、ViewModel 和Room。</p><ul><li>LiveData是用来构建数据对象，当基础数据库改变时会通知视图；</li><li>ViewModel是用来<strong>存储和管理与界面相关的数据</strong>，这些数据在应用跳转时不会被销毁；</li><li>Room是一个SQLite对象映射库，它可以轻松地将SQLite表数据转换为Java对象，主要负责底层数据库的处理，本文调用其中的Dao接口来执行数据库增删改查等操作，利用 Database创建和管理数据库。同时，Room可以为SQLite语句提供编译时检查，并能够返回RxJava、Flowable和LiveData可观察对象。</li><li>Repository是一个仓库类，介于视图层与数据映射层（数据访问层）之间。它的作用是让视图层感觉不到数据访问层的存在，提供了一个类似集合的接口给视图层进行访问。</li></ul><p>采用MVVM模式最大的优点就是编写代码是思路明确，<strong>视图层与模型层完全解耦</strong>，方便后期的管理与维护，数据库相关的操作非常方便。</p><p>MVVM 模式中的VM，通过双向的数据绑定，<strong>将 View 和 Model 的同步更新给自动化了</strong>。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如vue是通过使用数据劫持和发布订阅者模式来实现的这一功能。</p><h1 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h1><h2 id="项目介绍、难点、收获"><a href="#项目介绍、难点、收获" class="headerlink" title="项目介绍、难点、收获"></a>项目介绍、难点、收获</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>MBR系统开发，支撑MBR平台一期需求页面搭建</strong></p><p>产品定位：面向B-Team以及管理层，实现餐饮SaaS MBR报表线上化，实现商分提效。</p><p>短期目标：MBR平台一期前后台页面开发上线，实现MBR核心指标线上化。</p><p>工作成果：</p><ul><li>参与MBR三端评审，针对MBR平台一期需求完成方案调研与设计，主要对富文本编辑器和树形控件进行调研与选型，并对PRD中的各项需求进行分析设计。</li><li>完成MBR前后台页面需求开发，基于steamer平台将MBR前台和管理后台分别创建一个业务模块进行开发。前台页面主要完成页面整体布局、目录树导航（翻页、面包屑关联等）开发、页面动态渲染、页面部分组件（负责人卡片、富文本组件、无权限页面、文件下载页面等）开发；后台页面主要完成页面整体布局、目录树维护（增删改节点、节点关联页面、不同类型节点的功能区分等）、路由拦截等。</li><li>将请求发送、UI组件库这类公共服务（组件）发布为服务模块供业务模块使用，并在Shepherd网关编写mock接口进行本地测试。</li><li>前后台业务模块与服务模块的联调、构建与发布，并协助指导外包同学进行开发。</li><li>页面埋点、前后端联调、泳道环境和ST环境的部署与发布。</li></ul><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p><strong>业务方面：</strong></p><ul><li><strong>第一次从零开始做团队项目，不知道如何下手以及估算排期。</strong></li></ul><p>解决：在mentor引导下，针对需求进行方案调研与设计，确定好可以实现需求的合适的组件库。对于开发流程，首先对整个开发过程进行拆分例如这个项目，前台展示页面更重要优先级最高，再针对页面UI进行组件层级的拆分，每一个组件下又可以根据不同的功能点确定拆分成更小组件还是组件内通过写一个函数来实现等等，整个开发还是以先实现静态页面，再通过state等实现数据展示交互功能，这样从整体到部分再到细节，就能梳理出大致的开发流程以及估算合适排期。</p><ul><li><strong>产品对需求进行变更或提出了新需求，导致延期风险。</strong></li></ul><p>解决：与产品、后端及组内同事积极沟通，协调需求变更。首先对所提需求进行分类，对于必须实现的需求，如管理后台目录树的编辑与页面关联的需求必须实现，但前期PRD对这方面描述不完善且设计不合理，经过积极与后端、产品讨论对齐尽快提出可行的方案并加以实现；对于非必须实现且不合理的需求，与产品说明需求的不合理性及实现成本，尽可能取消这类需求或进行更改。</p><p><strong>技术方面：</strong></p><ul><li><p><strong>功能性问题</strong>：开发经验、博客论坛、谷歌搜索等</p><ul><li>目录树维护（增删改节点、节点关联页面、不同类型节点的功能区分等）：UI库的树组件一般不支持可编辑，因此需要二次开发，另外项目要求对不同层级的节点编辑要求有区别，比如有子节点父节点不能删除、父节点不能挂页面等，除此之外，编辑完后怎么像后端发请求保存。我的做法是封装一个递归遍历所有节点的函数，根据传参实现对节点不同的操作，弹出框和编辑按钮也可以根据不同的类型进行一部分的复用，向后端传参这里有两种方式，一种每进行一次操作发请求保存，但由于设计到拖拽节点等操作，我需要时刻拿到对应节点的位置，后端也需要对拿到数据进行处理，另外，每更改一次前台页面的数据就相当于变化一次；另一种方案，不管增删改还是关联页面，只要不点击保存就不向后端请求，点击保存，将整棵树的数据传给后端，点击取消则重新获取上一次的数据，为了防止不保存就离开或关闭页面，还要进行路由拦截。</li><li>无刷新修改url：需求是点击某个节点或翻页，内容区局部刷新，路由地址也要变化，最早想到是用路由的param参数，但内容区组件其实是固定的，只是根据请求的数据进行渲染，用路由意义不大；因为内容区可以根据react的重新渲染机制，只要state或props变更就进行对比和重渲染，路由地址可以直接用History.pushState()/replaceState()来更改。但这里面要注意react的浅比较和key的使用。</li><li>请求封装、下载</li><li>展示 滚动条、图片、grid</li></ul></li><li><p>平台基建/团队技术栈问题</p><ul><li><p>echarts等引起的ST环境导航切换白屏（removeChild） 错误边界 部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，不会渲染那些发生崩溃的子组件树，捕获错误，由于我们的bug是在路由跳转才会产生，因此错误边界组件捕获到错误可能立刻被卸载，因此并没有输出错误原因，而是直接让这个错误消失了。</p></li><li><p>组内的开发平台不熟悉，导致开发中经常遇到瓶颈，如样式不生效、构建发布失败和服务模块没有成功引入等。</p><p>解决：一方面，学习组内的wiki文档或者去学城搜索，很多问题别人已经遇到并解决过，同时可以结合之前别人的代码进行比对，排查原因并解决；另一方面，多向mentor和组内同事请教，他们的开发经验可以帮助快速定位问题并找到解决方案，甚至有些问题别人一两句话就能搞定，靠自己则会浪费过多时间。因此需要权衡问题的紧急程度，争取在不耽误项目排期的情况下快速定位问题并解决。</p></li><li><p>新技术栈如TypeScript不熟悉。</p><p>解决：首先集中时间对TypeScript的基础进行整体学习，同时结合组内之前的代码学习TypeScript在React的使用方式，在后续开发中不断完善编码规范，遇到报错可以去StackOverflow等网站查询他人的解决方法。</p></li></ul></li></ul><h3 id="收获与不足"><a href="#收获与不足" class="headerlink" title="收获与不足"></a>收获与不足</h3><p>通过上述项目与工作的锻炼，以及与mentor及组内同事的交流和学习，我得到了以下收获：</p><p><strong>业务方面：</strong></p><ul><li>对于业务理解有了提升，逐渐开始理解新需求的背景和目标，并能针对业务需求进行任务拆分。</li><li>第一次参与较大型且周期较⻓的业务项目开发，熟悉了整个开发流程，从需求分析、方案设计、代码开发，再到现在的联调测试，同时能够独立地进行方案设计与开发实现。</li></ul><p><strong>技术方面：</strong></p><ul><li><p>对Git常用命令、分支和冲突等方面有了进一步的学习和认识。</p></li><li><p>学习了新的技术栈TypeScript，同时对React、React Hook和React Router等有了进一步学习和更深的理解。</p></li><li><p>学习了新的UI组件库的使用，也尝试在项目中使用一些实用性轮子，同时对富文本编辑器、下载导出Excel等进行了调研学习与开发。</p></li><li><p>对公司和组内的各项基建更加熟悉，例如Shepherd、Ocean、steamer等，对steamer平台的使用有了一定了解，如业务模块和服务模块的构建与发布。</p></li><li><p>代码能力得到了成长，能够独立完成需求的开发以及BUG的定位与修复。同时，代码编程风格得到优化，代码格式逐渐统一与规范。</p></li></ul><p><strong>软实力：</strong></p><ul><li><p>沟通能力得到了提高，从最开始不好意思开口问，到现在可以有不懂的地方及时发问，并能快速对齐需求，与产品、后端及组内同事保持良好沟通，共同完成项目的开发。</p></li><li><p>合作意识提高，由于第一次参与团队项目，从最开始只顾自己开发，到现在能够及时沟通进度与存在问题，并互相帮助并提供解决方案。</p></li><li><p>抗压能力得到提升。</p></li></ul><p>反思不足：</p><p><strong>业务方面：</strong></p><ul><li>业务理解还停留于表层，经常被动接受并消化产品传递来的信息而无法很好的反馈。</li><li>对业务的远瞻性和敏感度不足，相对模糊的需求没有尽早明确，导致对开发耗时及排期估算不准确。</li><li>方案设计不够完善，例如组件库的选择只考虑是否能够完成相应需求以及当前是否在维护，没有与组内通用的组件库保持一致，导致后续重构的风险。</li></ul><p><strong>技术方面：</strong></p><ul><li>技术涉猎单一且固定，代码编写水平依然需要进一步提高，同时对React等技术栈底层原理还不够深入。</li><li>技术设计水平还有待提高，在开发过程中出现过设计不够合理的情况，导致代码需要重构。</li><li>对组内平台的底层原理不够了解，遇到样式或功能bug不能及时定位。</li></ul><p><strong>软实力：</strong></p><ul><li>当多任务并行时，心态会比较急躁，时间安排不合理，导致某段时间过于疲劳。</li><li>沟通表达能力还是有所欠缺。</li><li>写文档的能力有待提高，同时由于时间安排不合理，有时做了很多事情，来不及总结与整理。</li></ul><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>可以大体从三方面讲：</p><p><strong>业务方面：</strong></p><ul><li>尽快熟悉业务脉络和逻辑，加深组内平台和常用工具的理解与使用，快速融入工作氛围并适应工作节奏。</li><li>多关注业务的发展，弄清楚为何这么做，如何做的更好。视野不只停留在业务的开发上，更要对业务的落地、性能、效益进行思考。</li><li>对于接到手中的需求，提高方案调研与设计的能力，另外，对于产品需求不要总是被动地接收和消化，要多质疑、常思考、敢提问，争取在需求评审中能经常给出自己的意见。</li></ul><p><strong>技术方面：</strong></p><ul><li>对React、TypeScript、Webpack等源码及底层原理进行深入学习，提高自身在行业内的技术竞争力。</li><li>能力不只停留在已有的技术上，更要对新知识保持热情与追求，不断拓展技术的广度并持续钻研技术的深度，提升自己的行业竞争力。希望以后自己能成为行业大牛。</li><li>提升编写代码的鲁棒性和可靠性，当出现BUG时，能快速定位问题，主动担责，并尽快修复。</li></ul><p><strong>软实力：</strong></p><ul><li>协调好生活与工作的平衡，合理安排时间，确保工作有序无误地开展，培养自己的耐心并提高自己的抗压能力。</li><li>提升多方协作能力，能够对项目需求合理拆解，协调多人保质按时交付任务。</li><li>不要总是埋头做事，沟通表达能力要多加练习，平时注意反思总结，每天/周抽出时间进行个人的沉淀与记录。</li></ul><h2 id="遇到的困难"><a href="#遇到的困难" class="headerlink" title="遇到的困难"></a>遇到的困难</h2><p>STAR原则，什么情景，发生了什么事情，你怎么处理的，最终的结果是什么</p><p>本科时参加了一个电子设计大赛，当时要做的是设计一个电路特性测试仪模块。但由于这个题目本身就比较复杂，比赛时间又比较短，也没有提前购买一些器材，因此比赛进行到一半时，一起参赛的队友已经想放弃了。但我觉得放弃太可惜了，一方面给队友打气鼓劲，一方面要做的事情进行规划和任务分级，因为这个比赛是有基础部分和发挥部分，首先不一定按照先基础再发挥去实现，而应该具体去分析里面最容易实现、耗时最短的先实现，同时针对一些问题提出自己的一些解决方案，比如单片机ad采集太小太大都不行，所以我当时提出使用负反馈的方法接入运算放大器，在这种接法中，放大倍数与运放外接的反馈电阻大小有关：倍数为反馈电阻和信号输入端电阻之比。在保证放大后的电压正常采集的情况下，对输入电压经过放大再采集。这样就能同时记录输入前后的电压。就这样，大家坚持到了最后一天，最后也是取得了省二等奖的成绩。最大感悟就是不轻言放弃，理论联系实际，敢于动手尝试。当时间紧、任务多时，一定要做好任务分级、 学会取舍，同时团队分工要明确合理，并要关注团队成员的心态。另外，凡事预则立，不预则废。如果提前尽可能做准备，可能就不会陷入这种境地。</p><p>研究生</p><h2 id="课程-成绩-获奖情况-竞赛"><a href="#课程-成绩-获奖情况-竞赛" class="headerlink" title="课程/成绩/获奖情况/竞赛"></a>课程/成绩/获奖情况/竞赛</h2><p>研究生 通信网理论基础 86 光网络技术 88 研究生课程很多不进行考试 主要重点在实验室项目或课题</p><p>本科 高等数学 98 复变函数与积分变换 100 计算机程序设计（C语言） 93 信号与系统 96 电路 99</p><p>计算机二级、三级 GET4、6 普通话二级乙等</p><p>北邮 山科校一等奖学金 三好学生 优秀共青团员 优秀学生标兵等</p><p>第八届山东省大学生数学竞赛（非数学类）——省一等奖<br>山东省大学生物理竞赛——省三等奖<br>2019年全国大学生电子设计竞赛——省二等奖<br>2017年第十届“认证杯”数学建模网络挑战赛——省二等奖<br>2017年APMCM亚太地区大学生数学建模竞赛——省三等奖</p><p>2020-09～至今，研究自由空间光通信中的分集接收方案，并通过Matlab和Optilux实现40Gbps PM-CO-16QAM FSO空间分集接收仿真平台搭建，并进行了离线实验验证。成功发表一篇二区（Optics Express）SCI（导师一作、本人二作）：Performance analysis of a spatial diversity coherent free-space optical communication system based on optimal branch block phase correction.</p><h2 id="你经历的最大挫折是什么？"><a href="#你经历的最大挫折是什么？" class="headerlink" title="你经历的最大挫折是什么？"></a>你经历的最大挫折是什么？</h2><p>高考对我来说就是挺大的挫折吧，高中时期其实我成绩还算不错，当时正常发挥考上211应该不成问题，但最后因为考试心态等问题，考的相比平时差了不少，本科专业因为调剂也不想学，但后来也是慢慢调整自己，在本科期间换了专业，参加各类比赛等等，最终考研来到了北邮，现在看来高考失利也只是人生路上的一个小插曲，未来路还很长，还是要一直充满希望的。</p><h2 id="优缺点-竞争力"><a href="#优缺点-竞争力" class="headerlink" title="优缺点 竞争力"></a>优缺点 竞争力</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>乐观开朗，乐于助人，适应能力强，不管学校还是公司，都能够与身边的人愉快相处。</p><p>技术视野开阔，喜欢钻研，具有良好的学习能力，热爱编程，对业界新技术敏感，开拓创新意识强，能保持不断进取的精神。像平时经常会在B站看一些学习或者技术类的视频，也会经常浏览知乎、掘金、包括一些个人的博客论坛网站，丰富自己的视野，如果是比较新的技术，可能直接去看一些国外的网站或文章会收获更多。</p><p>注重团队合作，有着强烈的责任心和高度执行力。</p><p>抗压能力还算可以，应对实验室或公司中时间紧任务重的情况，能够从容进行任务的分级与梳理，积极沟通协调，同时调整生活<br>和工作上的平衡，力争每次都能按时保质地交付手中的任务。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>沟通能力还是需要进一步提高，在之前实习过程中，从最开始不好意思开口问，到后来有不懂的地方及时发问，并能与产品、后端及组内同事保持良好沟通，共同完成项目的开发。但沟通交流本身就是一门学问，需要不断磨练与提高，自己在这方面还是有很长的路要走。</p><p>提升多方协作能力，能够对项目需求合理拆解，协调多人保质按时交付任务。尽量提高自己的一个管理或者领导能力，树立大局观，不要总是埋头做事，平时注意反思总结，每天/周抽出时间进行个人的沉淀与记录，这样之后才能走得更远。</p><h2 id="你平时是怎么学习的？"><a href="#你平时是怎么学习的？" class="headerlink" title="你平时是怎么学习的？"></a>你平时是怎么学习的？</h2><p>基础学习：</p><p>B站、MDN（建议英文，中译有误）和官网（React、React Router）</p><p>知识拓展：</p><p>掘金/知乎/segmentfault思否/CSDN、阮一峰博客</p><p>bug：</p><p>Stack overflow</p><h2 id="你什么时候接触前端的-为啥学前端"><a href="#你什么时候接触前端的-为啥学前端" class="headerlink" title="你什么时候接触前端的/为啥学前端"></a>你什么时候接触前端的/为啥学前端</h2><p>本科时候做词典APP，里面离线数据是通过爬虫获取的，所以对html有了一些了解，包括安卓开发的XML布局，其实也跟前端比较类似。在我看来，学习前端是一件很有意思的一件事，随着我学习进度的增加，慢慢的，我发现了前端所做的都是用户可以最直观感受和体验的，也是最能让开发者感受到成就感的。</p><p>当然最早学前端，也因为它入门更容易，但随着学习深入就会发现现在的前端已经不是原先的切图仔，如果把前端狭义的理解为做页面，那天花板当然低了，但对应的，后端也可以被理解为 CRUD，天花板也很低。这时候如果把数据库 AI 这些扯进后端范畴，那么广义的前端也应该包含一切和交互相关的内容，比如网络资源优化、自动化部署、交互体验研究、设计和开发协作、跨平台渲染引擎、字符排版、甚至浏览器本身就是前端范畴。</p><p>当然，前端也不是归宿，后端语言像nodejs或其他也要学习，语言永远只是工具，重要的是开发的思想。另一方面，技术是需要给业务赋能，所以想走的更远，只学技术也不够。</p><p>前端的工程体系难就难在庞杂，链路长，环节多，而且和许多其他领域有交叉（比如网络、运维、编译器、图形学、人机交互理论、PL/DSL 设计），吃透一个环节的难度确实不难，但作为大厂的前端负责人需要规划整合这些东西，我是觉得天花板一点也不低。</p><h2 id="有无意向offer"><a href="#有无意向offer" class="headerlink" title="有无意向offer"></a>有无意向offer</h2><p>可能我秋招投的不是很早吧，现在有一些公司进展到二面、三面环节了，比如华为等。</p><p>美团因为实习的原因，估计会有转正，但那边主要做的是ToB的项目或低代码，而且工作强度还是有一些的，所以就想看看其他公司的业务或技术的发展方向，其次包括团队氛围、工作压力或稳定、还有技术提升都会考虑。</p><p>当初投B站也是因为很早就开始玩B站，平时看视频B站相对更多一些，也有一个六级号，所以本身对B站这个公司还是很感兴趣的，而且B站不论是用户还是工作人员，基本还是比较年轻的，所以工作氛围可能相对更好一些。</p><h2 id="情商跟职商"><a href="#情商跟职商" class="headerlink" title="情商跟职商"></a>情商跟职商</h2><p>举几个例子：</p><p>1.你和同事意见相左怎么办？</p><p>2.你和老板意见出现分歧，而你比较笃定你的想法是正确的。这时你会怎么做？</p><p>3.领导如果让你做假账，你做不做？</p><p>4.上司分配给你的任务，并不是你喜欢的，这个时候你应该怎么做？</p><p>5.如果你的leader和boss意见冲突，都要求你完成一个紧急任务，该怎么办？</p><p><strong>比如第一个问题，“你和同事意见相左怎么办？”我们不妨可以这样回答。</strong></p><p><strong>答：</strong>工作中遇到分歧的是在所难免的。</p><p>我会尽量站在对方的⻆度去理解这个问题，首先审视一下自己的认识有没有局限。</p><p>如果发现我的观点没有问题，那我会在坚持我最主要原则的前提下，多通过一些策略性的沟通方式，比如，多对对方的观点、付出的努力、观点的价值表示认可，然后阐述我自己考虑问题的出发点是什么，以此来争取对方的理解和支持。</p><p><strong>一句话总结：理解分歧，坚持底线，柔性解决。记住，体现态度！</strong></p><h2 id="城市"><a href="#城市" class="headerlink" title="城市"></a>城市</h2><p>像上海、北京这种大城市虽然生活成本偏高；但对个人来讲，发展和上升空间相较于小城市和县城还是高不少。另外，很多曾经包括现在的同学都留在了大城市，没事还能一起聚餐玩一玩，生活圈子可能会更广一些。</p><p>大城市就是工作机会多、发展好等等，小城市就是离家近、消费低等等。</p><p>北上深仍旧是薪资高地，杭州紧随其后，硕士平均薪资杭州甚至排第二。</p><p>值得注意的是，<strong>西安是北方城市里北京以外唯一上榜城市</strong>，虽然时不时被唱衰，但如果想留在北方，又觉得北京生活压力大，西安确实是个不错的选择。</p><p><strong>未来竞争力 ：</strong>根据仲量联行最新发布的《中国城市12强》报告，遴选出全国12座具有「未来竞争力」的城市。拥有未来竞争力的城市主要特点是<strong>聚集了众多新一代高新技术企业，能推动下一轮发展浪潮。</strong>这12座城市按照得分高低排列依次是<strong>上海、北京、深圳、广州、杭州、南京、苏州、武汉、天津、成都、重庆、西安。</strong></p><p><strong>处于第一梯队：厦门、深圳、上海、北京和广州。</strong></p><p>全国排名第一的是厦门，房价收入比超过30，也就是说以目前厦门的平均工资和房价，两夫妻购买一套120平的房子，得不吃不喝30年，又吃又喝得60年，又吃又喝带上一个娃估计90年。</p><p><strong>处于第二梯队「房价收入比＞20」是福州、天津、南京、杭州。</strong></p><p>大多数人，入驻北上广深杭是为了赚取高工资、获取剪刀差，本没指望在当地成家的。<strong>但厦门、福州、天津和南京可不一样，以目前的房价收入比，是很难支撑梦想的。</strong></p><p>全国主要城市中，房价收入比较为合理的是沈阳、长沙和西安（10左右）。</p><p><strong>西安：</strong>除了「三放四降」，同时给予大学毕业生住房租住支持。<br><strong>长沙：</strong>本科及以上学历青年人才落户并工作，政府提供两年生活补贴；<br><strong>沈阳：</strong>只要你来找工作，政府提供免费的住宿；<br><strong>海南：</strong>为愿意落户并创业的人才提供300万元的贷款；<br><strong>武汉：</strong>打出5年留下百万大学生，每个月都有政策出台；<br><strong>天津：</strong>本科生不超过40岁，硕士生不超过45岁，博士不受年龄限制，直接落户天津，不用缴纳社保，不用居住证。</p><h2 id="爱好"><a href="#爱好" class="headerlink" title="爱好"></a>爱好</h2><p>平时会和朋友们一起打篮球、打羽毛球，也喜欢动漫、影视、听音乐之类放松下自己，其实本科阶段我也做过B站的up主，上传过一些自己剪辑的视频，只不过后来因为时间有限就断更了。（国漫、日漫、影视的剪辑类视频，2000+粉丝）</p><h2 id="对公司的了解？为啥选"><a href="#对公司的了解？为啥选" class="headerlink" title="对公司的了解？为啥选"></a>对公司的了解？为啥选</h2><h3 id="B站"><a href="#B站" class="headerlink" title="B站"></a>B站</h3><p>六级用户 日漫/国漫、科技、学习、生活、鬼畜等 up主 做过视频 动漫影视剪辑类的</p><p><strong>没有广告</strong> 生态环境：高自由度的并且激励用户创作的运营方式，二次创作和自主创作较多</p><p>B站其实最有竞争力的是专业，硬核，不管游戏，鬼畜，还是财经。这一点其实还是在优质up主上，b站今后如果可以给优质up主创造一个良好的盈利和发展环境，还是未来可期的。</p><p>其实，现在在首页和排行榜的尽是良莠不齐、鱼龙混杂的内容，需要用户自己寻找其中的宝藏。长此以往，必将“劣币驱逐良币”，B站赖以生存的基石（优秀内容创造者）也会土崩瓦解。一方面可要让用户更轻松地看到更优质有趣的视频，另一方面激励这类视频up主的创造积极性。</p><p>还有很重要的一点，就是用户量的激增，用户质量肯定良莠不齐，弹幕评论环境也会有所恶化，这也十分需要关注。</p><p>当然，这些情况的改善需要更高管理层做出一些举措，作为开发人员，我们能做的可能就是用技术，帮助up主活的更好。</p><p>当初投B站也是因为很早就开始玩B站，平时看视频B站相对更多一些，也有一个六级号，所以本身对B站这个公司还是很感兴趣的，而且B站不论是用户还是工作人员，基本还是比较年轻的，所以工作氛围可能相对更好一些。</p><h3 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h3><p><strong>为什么选择华为，华为有哪些吸引你加入的地方</strong></p><ul><li>对于应届毕业生来说，第一份工作尤为重要，这将决定你的职业眼光，发展前景，还有你身边的人将极大的影响你的未来，需要谨慎选择。华为作为一个较大的平台。</li><li>该部门的方向也是与我比较匹配的。</li></ul><p><strong>如何看待华为文化</strong></p><p>华为的”<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%8B%BC%E6%80%A7%E6%96%87%E5%8C%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2259609598%22%7D">狼性文化</a>“可以用这样的几个词语来概括:<strong>学习，创新、获益、团结</strong>。用狼性文化来说，学习和创新代表敏锐的嗅觉，获益代表进攻精神，而团结就代表群体奋斗精神</p><p>不是出路，就是出局。适应公司或者是个人。</p><p><strong>对华为的了解</strong></p><p>华为当前的业务可分为四大领域：运营商业务、企业业务、消费者业务和云服务。四大业务领域相互协同、共同发展，拼接成华为生态战略布局版图。</p><p>对于我们很多普通人来说，对华为的了解也仅仅只限于手机。</p><p>特别是我爸妈这一代人，都比较喜欢用华为荣耀的手机。</p><p>她说，别人都说华为手机好，所以就买了。</p><p>我觉得这就很有代表性：知道华为手机好，但不知道华为手机为什么好，你再问问ta对华为还知道什么，他们也就说不清楚了。</p><p>其实华为手机并不是华为的全部，华为除了在手机行业，华为目前仍在开展的业务有很多，其中大部分业务都处于行业前列。</p><p>华为每年投入那么多钱搞研发，是实实在在的做出来了成果。</p><p>华为智能汽车解决方案BU作为<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%8D%8E%E4%B8%BA%E5%85%AC%E5%8F%B8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2271488088%22%7D">华为公司</a>面向汽车行业的研发和商业实体，聚焦以ICT技术为客户提供高价值、高可靠的智能驾驶、智能座舱、智能电动、智能车云产品和解决方案，帮助车企造好车，引领汽车进入数字智能新时代。</p><h3 id="国家电投"><a href="#国家电投" class="headerlink" title="国家电投"></a>国家电投</h3><p>月薪1w *16 1000餐补 房补 8000福利 总包20 户口</p><p>老师推荐</p><p>国家电投是我国五大发电集团之一，是全球最大的光伏发电企业</p><p>国家电投集团数字科技有限公司成立于2013年8月，是国家电力投资集团有限公司承担信息化建设实施和信息技术开发应用的专业化平台公司。公司现有资产总额4.29亿元，获得国家高新企业资质，具备咨询服务、应用开发、项目管理、运行维护、信息安全等IT全产业链业务能力和完备资质。</p><p>公司秉承“服务集团，让企业和能源更智慧”的使命，致力于成为集团公司管理数字化的坚强平台，产业数字化的技术领跑者、市场主力军，成为国内领先、国际知名的能源数字科技企业</p><h3 id="中兴"><a href="#中兴" class="headerlink" title="中兴"></a>中兴</h3><p>一方面实验室之前有跟中兴有过项目合作，虽然我并没有参与，但也有所耳闻，比如LDPC信道编码、FTN-WDM（超奈奎斯特波分复用）等等；另一方面，中兴的手机也是我们大家最早了解的，现像今年出了一款屏下摄像头的中兴 Axon 40 Ultra，另外还有努比亚和红魔两个品牌。红魔作为游戏手机，总体销量不错。</p><p>中兴通讯是全球领先的综合通信解决方案提供商，中国最大的通信设备上市公司。主要产品包括：2G/3G/4G/5G无线基站与核心网、IMS、固网接入与承载、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%89%E7%BD%91%E7%BB%9C/6219507?fromModule=lemma_inlink">光网络</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%8A%AF%E7%89%87/32249?fromModule=lemma_inlink">芯片</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%AB%98%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%99%A8/6620986?fromModule=lemma_inlink">高端路由器</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%99%BA%E8%83%BD%E4%BA%A4%E6%8D%A2%E6%9C%BA/742295?fromModule=lemma_inlink">智能交换机</a>、政企网、大数据、云计算、数据中心、手机及家庭终端、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82/9334841?fromModule=lemma_inlink">智慧城市</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ICT/32270?fromModule=lemma_inlink">ICT</a>业务，以及航空、铁路与城市轨道交通信号传输设备。</p><h2 id="期望薪资"><a href="#期望薪资" class="headerlink" title="期望薪资"></a>期望薪资</h2><p>总包 月薪 年终奖 其他补贴 当地消费水平</p><h3 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h3><p>普通 21-24k sp 25-26 ssp 27-29 *15.5</p><p>晚走 饭补车补</p><h3 id="华为-1"><a href="#华为-1" class="headerlink" title="华为"></a>华为</h3><p>普通14 (16-24) sp15 (25-29) ssp16 (30-38) *(14-16)</p><p>公积金5% 通信补贴 交通补贴</p><h3 id="b站"><a href="#b站" class="headerlink" title="b站"></a>b站</h3><p>普通 (20-23) sp (24-27) ssp (28-30) *(15-18)</p><p>上海 饭补 优秀的转正后1k补贴</p><h3 id="中兴-1"><a href="#中兴-1" class="headerlink" title="中兴"></a>中兴</h3><p>20 / 23*12</p><p>西安</p><h3 id="完美"><a href="#完美" class="headerlink" title="完美"></a>完美</h3><p>很多游戏 23k 25k</p><h2 id="家庭-单身"><a href="#家庭-单身" class="headerlink" title="家庭/单身"></a>家庭/单身</h2><p>家是在一个普通小县城，感觉相比大城市的工作机遇和发展前景还是差很多，因此想在大城市工作感受下；家里父母都是普通打工人，但家庭氛围很和睦，也很重视教育，父母也都支持我的决定。目前没有女朋友，但我觉得对找工作可能不是一件坏事，我可以只考虑自身情况去选择工作地点等等。</p><h2 id="期望的团队"><a href="#期望的团队" class="headerlink" title="期望的团队"></a>期望的团队</h2><p>和谐愉快地相处、平时工作上可以互相帮助，下班有时间也能一起玩耍。团队做的项目期望是一些核心或者能对个人有所提升的项目，当然也不是除此之外的项目就不做了。</p><h2 id="加班"><a href="#加班" class="headerlink" title="加班"></a>加班</h2><p>坦诚的讲，没有人喜欢加班。但总会有主观或客观因素造成了加班，主观因素，比如自己有段时间工作不积极，导致项目临近上线很多工作还没做，这种加班也是自己找的，就需要提高工作效率，反思自己问题。如果外界客观因素导致，偶尔加班也无妨，如果加班过多，可以尝试跟leader或相关人员协调沟通。</p><h2 id="如何看待-toB-与-toC"><a href="#如何看待-toB-与-toC" class="headerlink" title="如何看待 toB 与 toC"></a>如何看待 toB 与 toC</h2><p>从职业方向取舍的角度看，我认为纠结这两个点没必要，toB 的业务可能很简单，toC 的业务也可能很复杂，两个端的壁垒也没有那么大。</p><p>从传统观点上看：</p><p>toB：业务复杂，表单和定制化需求较多，需要给出一整套解决方案，但对体验和交互要求没有那么重要 。</p><p>toC：偏向用户体验的内容稍多，移动端的内容稍多。对性能的要求略高，每个产品的功能不复杂，业务开始只需要满足用户的一个痛点。</p><p>但随着前端能力的增加，很多工具类软件都可以由前端承载，代码的复杂度也随之上升，前端从传统的辅助地位逐渐走向了客户端工程师的地位，内容也逐渐变得更有挑战性。</p><p>但如果从公司的角度看，toB 的公司一般面向政府、企事业单位，以供应商的身份提供技术咨询、定制化开发、业务支持等服务，回款周期较长，如果外部环境不好，资金流不畅，很容易拖欠工资。 但是，节奏没有那么快，一切都有较长的排期，相对更规范一些。</p><p>toC 的公司，一般都自负盈亏，现金流相对会快一些。但是现在的互联网企业都搞什么敏捷开发，基本上一周或者两周就一个版本，面向市场需要小步快跑。</p><h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><h4 id="主管面反问"><a href="#主管面反问" class="headerlink" title="主管面反问"></a>主管面反问</h4><ul><li>对应届生的培养方式</li><li>我的base地</li><li>试用期的考核？</li><li>晋升体系</li><li>业务方向的发展？</li></ul><h4 id="技术面反问"><a href="#技术面反问" class="headerlink" title="技术面反问"></a>技术面反问</h4><p>您觉得，这份工作所需的能力，我还有哪些不具备？</p><p>部门/公司的主要研究方向？工作地点？</p><p>部门/公司的团队规模以及未来的主要规划？</p><p>入职是否有员工培训，具体内容是什么？</p><p>前端未来的发展如何？例如低代码、web3.0这种?</p><h3 id="HR"><a href="#HR" class="headerlink" title="HR"></a>HR</h3><p>待遇、部门业务、发展前景、加班情况、培训体系、签约年限、不要主动问三方违约金、试用期/见习期</p><p>年假、事假、病假等每年都有多少天？</p><p>工作的作息</p><p>试用期多久（试用期的工资）</p><p>公积金是多少？</p><p>面试结果什么时候出来？</p><p>面试官您好，我想知道您听完我的回答有什么比较好的建议么？</p><p>进去之后的晋升机制是怎样的？会经常有技术交流的活动么？</p><p>总包20W，但是这一年是哪一年，这是HR的一个模糊话说。通常人会认为这是从入职起的第一年，总包20W。但HR可能说的是转正之后的第一个完整年总包20万。这里的差异可是不小的，所以有必要拿到offer时问清楚。国企和银行的试用期的待遇都是较低的，一般是转正之后的八折，甚至有银行试用期的工资是转正之后的五折（如中国农业银行）。年终奖</p><h1 id="SaaS、IaaS、PaaS、iPaaS和aPaaS"><a href="#SaaS、IaaS、PaaS、iPaaS和aPaaS" class="headerlink" title="SaaS、IaaS、PaaS、iPaaS和aPaaS"></a>SaaS、IaaS、PaaS、iPaaS和aPaaS</h1><h2 id="SaaS、IaaS、PaaS"><a href="#SaaS、IaaS、PaaS" class="headerlink" title="SaaS、IaaS、PaaS"></a>SaaS、IaaS、PaaS</h2><p>我们传统开发一个软件，需要9个东西：</p><p><a target="_blank" rel="noopener" href="https://imgse.com/i/vXwRDs"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/09/12/vXwRDs.png" alt="vXwRDs.png"></a></p><p>作为使用软件的人，左边的【应用】和【数据】，是<strong>离我们最近的部分。</strong></p><blockquote><p>比如最常见的：我们在某软件里提交了报销申请，其实我们就是上传了自己的报销数据到应用中。</p></blockquote><p>最右边的【虚拟化】、【服务器】、【存储】、【网络】是制作一个软件的基础条件，除了虚拟化技术其他都是硬件，所以在云计算领域中，这块被称为基础设施。</p><blockquote><p>它们在机房都能看到。</p></blockquote><p>而中间的这些，就是<strong>利用最右边</strong>的基础设施搭建出的平台，从而<strong>承载最左边</strong>的【应用】和【数据】。</p><p>所以说，从右到左就是一个硬件逐渐软化（软件开发）的过程，IT技术在这个过程中扮演了必要角色：</p><p>但！</p><p><strong>不是所有企业都具有独立开发一个软件的资本</strong>（钱、人、力缺哪个都不行）。</p><p>所以，云服务产生了。</p><p>大大小小企业，财力不同、问题不同，因此对于软件的开发，总有形形色色的需求。</p><p><strong>经过演变，云服务逐渐分为三类：</strong></p><blockquote><p>第一种，云服务提供基础设施，我们可能听过某某说“租了哪里的服务器，准备自己搞个软件……”，其实就是Iaas。<br>第二种，云服务提供一个平台，企业自己设计应用，数据也由自己保管。这就是Paas。<br>第三种，云服务提供现成的软件，数据也全部上云。这就是SaaS。</p></blockquote><p>如图：</p><p><a target="_blank" rel="noopener" href="https://imgse.com/i/vXw55V"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/09/12/vXw55V.png" alt="vXw55V.png"></a></p><p>从Iaas到SaaS的过程，企业需要付出的成本越来越小，云化的程度也越来越高。</p><h2 id="iPaaS和aPaaS"><a href="#iPaaS和aPaaS" class="headerlink" title="iPaaS和aPaaS"></a>iPaaS和aPaaS</h2><p><strong>ipaas和apaas的产生，是因为企业在使用软件过程中，又遇到了难以解决的问题：</strong></p><p>1、<strong>对于很多企业来说，SaaS都是固定功能的软件，</strong>对于自己需要个性化的需求难以满足，虽然软件开发能灵活满足自己的需求，但是无论是自研还是托管，开发和运维费用都极其高昂</p><p>3、一个软件解决不了所有问题，那就多堆几个软件，<strong>导致一个企业可能用了五六个软件，但都互相独立，无论是功能还是数据，都不能连起来</strong></p><p>本来想通过信息化提高效率、解决数据难题的，却使得数据壁垒越来越厚、事情越做越多。</p><p><strong>这可不行。</strong></p><p><strong>所以ipaas和apaas产生了。</strong></p><p><strong>首先，是企业的个性化问题。</strong></p><p>堵死一大批企业的，其实就是软件开发的门槛过高。要找到懂开发又懂业务的IT太难了，业务人员为了开发去学编程也不是朝夕就能实现。</p><p>怎么才能提供一种框架，让业务人员不需要学代码就能自己设计出一个管理软件呢？这种模式就是apaas，从应用和数据层面入手，设计搭建工具与逻辑，实现零代码开发。</p><p>而apaas从<strong>应用和数据层面入手</strong>，就足以看出，它趋向于PaaS和SaaS之间。</p><p><strong>其次，就是打通企业内部的各个软件问题。</strong></p><p>由于企业堆叠的各种SaaS软件，用着不同的主机和数据库，怎么将这些软件集成起来？这就需要一种技术，也就是iPaaS。</p><p>它从<strong>虚拟主机和数据库层面</strong>入手，创建一个中心生态系统来查看、管理和修改所有数据、基础设施和操作。从而轻松打通各个系统的数据与功能。</p><p>可以看出，iPaaS则趋向于IaaS和PaaS之间。</p><h3 id="各自功能："><a href="#各自功能：" class="headerlink" title="各自功能："></a>各自功能：</h3><ul><li>解决企业里各个软件造成的壁垒问题，减轻IT任务量——ipaas</li><li>满足企业追求的灵活但要性价比高的软件开发，降低开发门槛——apaas</li></ul><h3 id="技术偏重点："><a href="#技术偏重点：" class="headerlink" title="技术偏重点："></a>技术偏重点：</h3><ul><li>ipaas偏向IaaS</li><li>apaas偏向SaaS</li></ul><h3 id="使用对象："><a href="#使用对象：" class="headerlink" title="使用对象："></a>使用对象：</h3><ul><li>ipaas：IT人员</li><li>apaas：所有人</li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>递归就是把规模较大的一个问题，分解成规模较小的多个子问题去解决，而每一个子问题又可以继续拆分成多个更小的子问题。</p><p>递归就是<strong>一个函数在它的函数体内调用它自身</strong>。</p><p>执行递归函数]将反复调用其自身，每调用一次就进入新的一层。递归函数必须有<strong>结束条件</strong>。</p><p>我一般处理递归的思路主要注意以下两点：</p><ul><li>先处理一小步（先处理最简情况）,然后自己调自己</li><li>找到退出条件</li></ul><p>迭代：迭代是重复反馈过程的活动。每一次对过程的重复称为一次“迭代”，每一次迭代得到的结果会作为下一次迭代的初始值。</p><p>递归中有迭代，但迭代中不一定有递归，大部分可以相互转换；</p><p>相比较而言，能用迭代就不要用递归，递归不断调用函数，浪费空间，也容易引起堆栈溢出。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>简洁</li><li>在树的前序，中序，后序遍历算法中，递归的实现明显要比循环简单得多。</li></ul><h3 id="问题（缺点）"><a href="#问题（缺点）" class="headerlink" title="问题（缺点）"></a>问题（缺点）</h3><ul><li><strong>性能</strong>：假设传入的参数值特别大，那么这个调用栈将会非常之大，最终可能超出调用栈的缓存大小而崩溃导致程序执行失败。每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。</li><li>效率：<ul><li>递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址以及临时变量，而往栈中压入数据和弹出数据都需要时间。</li><li>递归中很多计算都是重复的，由于其本质是把一个问题分解成两个或者多个小问题，多个小问题存在相互重叠的部分，则存在<strong>重复计算</strong>，如fibonacci斐波那契数列的递归实现。</li></ul></li></ul><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>尾递归是一种递归的写法，可以避免不断的将函数压栈最终导致堆栈溢出。</p><p>通过设置一个累加参数，并且每一次都将当前的值累加上去，然后递归调用。通过尾递归，我们可以<strong>把复杂度从O(n)降低到O(1)</strong></p><p>先说尾调用来理解尾递归</p><blockquote><p>尾调用是指一个函数里的最后一个动作是返回一个函数的调用结果的情形，即最后一步新调用的返回值直接被当前函数的返回结果</p></blockquote><p><strong>尾调用核心理解</strong></p><p>就是看一个函数在调用另一个函数得时候，<strong>本身是否可以被“释放”</strong></p><p><strong>尾调用好处</strong></p><p>如果将函数优化为尾调用，那么完全可以做到每次执行时，调用帧为一，这将大大节省内存，提高能效。</p><p><strong>尾递归 = 尾调用 + 递归</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.trace()</span></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用factorial(3)函数执行步骤如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="number">3</span>, <span class="number">1</span>) </span><br><span class="line">factorial(<span class="number">2</span>, <span class="number">3</span>) </span><br><span class="line">factorial(<span class="number">1</span>, <span class="number">6</span>) </span><br><span class="line">factorial(<span class="number">0</span>, <span class="number">6</span>) <span class="comment">// n = 0; return 6</span></span><br></pre></td></tr></table></figure><p>调用栈不再需要多次对factorial进行压栈处理，因为<strong>每一个递归调用都不在依赖于上一个递归调用的值</strong>。</p><p>因此，空间的复杂度为o(1)而不是0(n)。查看控制台，发现第三次打印的结果如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.trace</span><br><span class="line">factorial @ VM362:<span class="number">2</span></span><br><span class="line">factorial @ VM362:<span class="number">7</span></span><br><span class="line">factorial @ VM362:<span class="number">7</span></span><br><span class="line">factorial @ VM362:<span class="number">7</span></span><br><span class="line">(anonymous) @ VM362:<span class="number">9</span></span><br></pre></td></tr></table></figure><p>既然说了调用栈不再需要多次对factorial进行压栈处理，那为什么结果还是不会在每次调用的时候压栈，只有一个factorial呢?</p><p>正确的使用方式应该是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.trace()</span></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，虽然说这里启用了严格模式，但是经测试，在Chrome和Firefox下，还是会报栈溢出错误，并没有进行尾调用优化</span></span><br><span class="line"><span class="comment">// Safari浏览器进行了尾调用优化，factorial(500000, 1)结果为Infinity，因为结果超出了JS可表示的数字范围</span></span><br><span class="line"><span class="comment">// 如果在node v6版本下执行，需要加--harmony_tailcalls参数，node --harmony_tailcalls test.js</span></span><br><span class="line"><span class="comment">// 但是node最新版本已经移除了--harmony_tailcalls功能</span></span><br></pre></td></tr></table></figure><h3 id="Memoization"><a href="#Memoization" class="headerlink" title="Memoization"></a>Memoization</h3><blockquote><p>memoization最初是用来优化计算机程序使之计算的更快的技术，是通过存储调用函数的结果并且在同样参数传进来的时候返回结果。大部分应该是在递归函数中使用。memoization 是一种优化技术，避免一些不必要的重复计算，可以提高计算速度。</p></blockquote><p>同样以阶乘函数为例：</p><p><strong>不使用memoization</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用memoization</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = [] <span class="comment">// 定义一个空的存放缓存的数组</span></span><br><span class="line"><span class="keyword">const</span> factorial = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache[n - <span class="number">1</span>]) &#123; <span class="comment">// 先从cache数组里查询结果，如果没找到的话再计算</span></span><br><span class="line">    <span class="keyword">return</span> cache[n - <span class="number">1</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = factorial(n - <span class="number">1</span>) * n</span><br><span class="line">    cache[n - <span class="number">1</span>] = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>搭配闭包使用memoization</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorialMemo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = []</span><br><span class="line">  <span class="keyword">const</span> factorial = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache[n - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`get factorial(<span class="subst">$&#123;n&#125;</span>) from cache...`</span>)</span><br><span class="line">      <span class="keyword">return</span> cache[n - <span class="number">1</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> result = factorial(n - <span class="number">1</span>) * n</span><br><span class="line">      cache[n - <span class="number">1</span>] = result</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> factorial</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = factorialMemo()</span><br></pre></td></tr></table></figure><p>memorization 可以把函数每次的返回值存在一个数组或者对象中，在接下来的计算中可以直接读取已经计算过并且返回的数据，不用重复多次相同的计算。<strong>是一个空间换时间的方式</strong>，这种方法可用于部分递归中以提高递归的效率。</p><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><h3 id="JS自带排序"><a href="#JS自带排序" class="headerlink" title="JS自带排序"></a>JS自带排序</h3><p><code>sort()</code> 方法对数组的元素进行<strong>就地排序</strong>并返回排序后的数组。</p><p>默认排序顺序是<strong>升序</strong>，将元素转换为<strong>字符串</strong>，然后比较它们的 <strong>UTF-16</strong> 代码单元值序列（根据每个字符的 Unicode 代码点值进行排序）。</p><p>排序的时间和空间复杂度不能保证，因为它取决于实现。</p><p>ASCII是计算机中最常用的编码方式，用于<strong>将字母，数字，标点符号和控制字符转换为计算机可以理解的数字形式</strong>。</p><p>UTF-8 (UCS Transformation Format 8)是<strong>万维网上最常用的字符编码</strong>。</p><p><strong>前 128 个 UTF-8 字符与前 128 个 ASCII 字符(编号为 0-127) 精确匹配</strong>。</p><p>在JavaScript中，所有的string类型都是使用<code>UTF-16</code>编码的。</p><p><code>str.charCodeAt()</code> 方法返回 <code>0</code> 到 <code>65535</code> 之间的整数，表示给定索引处的<strong>UTF-16代码单元</strong>。</p><h4 id="仅数字"><a href="#仅数字" class="headerlink" title="仅数字"></a>仅数字</h4><table><thead><tr><th align="left"><code>compareFunction(a, b)</code> return value</th><th align="left">sort order</th></tr></thead><tbody><tr><td align="left">&gt; 0</td><td align="left">sort <code>b</code> before <code>a</code></td></tr><tr><td align="left">&lt; 0</td><td align="left">sort <code>a</code> before <code>b</code></td></tr><tr><td align="left">=== 0</td><td align="left">keep original order of <code>a</code> and <code>b</code></td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b);<span class="comment">// 升序排序</span></span><br><span class="line">    <span class="comment">// nums.sort((a,b) =&gt; b-a);// 降序排序</span></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>冒泡排序只会操作<strong>相邻的两个数据</strong>。</li><li>外层需要n-1次排序，第n次比较是多余的，每一次结束后，未排序部分的最大值冒泡到最后。（从后向前）</li><li>内层循环不断对<strong>未排序部分</strong>两两比较交换。</li><li>每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。</li><li>一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> hasChange,</span><br><span class="line">        n=nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=n-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        hasChange = <span class="literal">false</span>;<span class="comment">// 提前停止标志位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                [nums[j],nums[j+<span class="number">1</span>]] = [nums[j+<span class="number">1</span>],nums[j]];<span class="comment">// 两两比较交换</span></span><br><span class="line">                hasChange = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hasChange) <span class="keyword">break</span>;<span class="comment">// 本轮没有数据交换，说明已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>冒泡的过程只涉及相邻数据的交换操作，空间复杂度为 O(1)，是一个<code>原地</code>排序算法。</p><p>为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换， 所以冒泡排序是<code>稳定</code>的排序算法。</p><p>时间复杂度：最佳：<code>T(n) = O(n)</code>，正序。 最差：<code>T(n) = O(n^2)</code>，反序。 平均：<code>T(n) = O(n^2)</code>。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>我们通常说的插入排序是指直接插入排序。</p><p>插入排序的工作原理：<strong>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</strong>。</p><p><strong>步骤</strong></p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中<strong>从后向前</strong>扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤 2 ~ 5。</li></ul><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> preIndex,current,</span><br><span class="line">        n=nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        preIndex=i-<span class="number">1</span>;<span class="comment">// 待比较元素下标</span></span><br><span class="line">        current=nums[i];<span class="comment">// 保存当前元素</span></span><br><span class="line">        <span class="keyword">while</span>(preIndex&gt;=<span class="number">0</span> &amp;&amp; nums[preIndex]&gt;current)&#123;</span><br><span class="line">            <span class="comment">// 待比较元素比当前元素大，后移</span></span><br><span class="line">            nums[preIndex+<span class="number">1</span>]=nums[preIndex];</span><br><span class="line">            preIndex--;<span class="comment">//下标左移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束，preIndex + 1即为当前元素应该插入的位置，避免同一个元素赋值给自身</span></span><br><span class="line">        <span class="keyword">if</span> (preIndex + <span class="number">1</span> != i) nums[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>插入排序算法的运行不需要额外的存储空间，空间复杂度是 O(1)，是一个<code>原地</code>排序算法。</p><p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是<code>稳定</code>的排序算法。</p><p>时间：最佳：<code>T(n) = O(n)</code>，正序。 最差：<code>T(n) = O(n^2)</code>，反序。 平均：<code>T(n) = O(n^2)</code>。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序<strong>每次会从未排序区间中找到最大（小）的元素，将其放到已排序区间的末尾。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 选择</span></span><br><span class="line">    <span class="keyword">let</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        minIndex=i;</span><br><span class="line">        <span class="comment">// 寻找未排序中最小数的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j= i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;nums[minIndex])&#123;</span><br><span class="line">                minIndex=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将未排序中最小的数放到已排序好数组的最后</span></span><br><span class="line">        [nums[i],nums[minIndex]]=[nums[minIndex],nums[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>选择排序空间复杂度为 O(1)，是一种<code>原地</code>排序算法。</p><p>选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，破坏了稳定性。</p><p>无论是正序还是逆序，选择排序都会遍历 <code>T = （n-1)）+ （n -2）+（n - 3）.... + 1; ===&gt;&gt; T = [n*(n-1) ] / 2；</code> 次来排序，所以，最佳、最差和平均的复杂度是一样的。 <code>T(n) = O(n^2)</code>。</p><h3 id="快速排序-★"><a href="#快速排序-★" class="headerlink" title="快速排序 ★"></a>快速排序 ★</h3><ul><li>先找到一个基准点（一般指数组的中部<code>midIndex</code>或随机数），然后数组被该基准点分为两部分，依次与该基准点数据<code>mid</code>比较，如果比它小，放左边；反之，放右边。</li><li>左右分别用一个空数组去存储比较后的数据。</li><li>最后递归执行上述操作，直到数组长度 &lt;= 1;</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 快排</span></span><br><span class="line">    <span class="keyword">const</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">1</span>) <span class="keyword">return</span> nums;<span class="comment">// 同时是递归终止条件</span></span><br><span class="line">    <span class="comment">// 基准点</span></span><br><span class="line">    <span class="keyword">let</span> midIndex=<span class="built_in">Math</span>.floor(len/<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// splice会从原数组中删除基准点数据，并返回一个数组</span></span><br><span class="line">    <span class="keyword">let</span> midNum = nums.splice(midIndex,<span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 依次与该基准点数据mid比较，如果比它小，放左边；反之，放右边</span></span><br><span class="line">    <span class="keyword">let</span> left=[],right=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        num&lt;midNum ? left.push(num) : right.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归执行上述操作</span></span><br><span class="line">    <span class="keyword">return</span> [...sortArray(left),midNum,...sortArray(right)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>缺点：<strong>需要另外声明两个数组，浪费了内存空间资源</strong>。</p><p>优化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortArray = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">const</span> partition = <span class="function">(<span class="params">nums, l, r</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> pivot = nums[r]; <span class="comment">// 最右边的元素作为 pivot 元素</span></span><br><span class="line">        <span class="keyword">let</span> pIndex = l;</span><br><span class="line">        <span class="comment">// 循环结束时，pIndex左边都是比pivot小的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = l;i&lt;r; i++) &#123; </span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                [nums[i],nums[pIndex]]=[nums[pIndex],nums[i]]</span><br><span class="line">                pIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pIndex和r交换，更新pivot元素</span></span><br><span class="line">        [nums[r],nums[pIndex]]=[nums[pIndex],nums[r]] </span><br><span class="line">        <span class="keyword">return</span> pIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> quick = <span class="function">(<span class="params">nums,l, r</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((r - l) / <span class="number">2</span>) + l; <span class="comment">// 选取中间</span></span><br><span class="line">        <span class="comment">// 将它和位置r的元素交换，让 nums[r] 作为 pivot 元素</span></span><br><span class="line">        [nums[mid],nums[r]]=[nums[r],nums[mid]]</span><br><span class="line">        <span class="keyword">let</span> pIndex = partition(nums, l, r);</span><br><span class="line">        quick(nums,l, pIndex - <span class="number">1</span>);</span><br><span class="line">        quick(nums,pIndex + <span class="number">1</span>, r);</span><br><span class="line">    &#125;;</span><br><span class="line">    quick(nums,<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化的算法进行分区时，不需要很多额外的内存空间，所以快排是<code>原地排序</code>算法。</p><p>快速排序每次交换的元素都有可能不是相邻的，因此它有可能打破原来值为相同的元素之间的顺序。因此，快速排序并<code>不稳定</code>。</p><p>极端的例子：如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为基准点，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n / 2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n^2)。<strong>快排时间复杂度与基准点的选取有关，一般取中部或随机最优。</strong></p><p>时间：最佳：<code>T(n) = O(nlogn)</code>。 最差：<code>T(n) = O(n^2)</code>。 平均：<code>T(n) = O(nlogn)</code>。</p><p>为什么？解决？</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序采用的是<code>分治思想</code>。排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><p>分治，顾名思义，就是分而治之，将<strong>一个大问题分解成小的子问题来解决</strong>。小的子问题解决了，大问题也就解决了。</p><p>因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。所以<strong>不是原地排序算法</strong>。</p><p>归并排序是<strong>稳定</strong>的排序方法。</p><p>时间：最佳：<code>T(n) = O(nlogn)</code>。 最差：<code>T(n) = O(nlogn)</code>。 平均：<code>T(n) = O(nlogn)</code>。</p><p><strong>归并排序与快速排序：</strong></p><ul><li>归并排序的处理过程是<code>由下而上</code>的，先处理子问题，然后再合并。</li><li>而快排正好相反，它的处理过程是<code>由上而下</code>的，先分区，然后再处理子问题。</li><li>归并排序虽然是<strong>稳定的</strong>、时间复杂度为<code>O(nlogn)</code> 的排序算法，但是它是<strong>非原地</strong>排序算法。</li><li>快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，它是一种<strong>选择排序</strong>，最坏 、最好、平均时间复杂度均为 <code>O(nlogn)</code>，它是<strong>不稳定排序</strong>。</p><p>注意因为完全二叉树的性质，可以用数组表示对应的树结构（所以，堆排序过程中，你是看不到树这数据结构的，用数组进行映射了），这叫顺序存储。</p><p>堆是具有以下性质的完全二叉树：</p><ul><li><p>大顶堆：每个节点的值都<strong>大于或等于</strong>其左右孩子节点的值</p><p>注：<strong>没有要求左右值的大小关系</strong></p></li><li><p>小顶堆：每个节点的值都<strong>小于或等于</strong>其左右孩子节点的值</p></li></ul><p><strong>排序说明</strong></p><p>升序：一般采用大顶堆</p><p>降序：一般采用小顶堆</p><p><strong>基本思想</strong></p><ul><li><p>将待排序序列构造成一个<strong>大顶堆</strong></p><p>注意：这里使用的是<strong>数组</strong>，而不是一颗二叉树</p></li><li><p>此时：整个序列的最大值就是<strong>堆顶的根节点</strong></p></li><li><p>将其<strong>与末尾元素进行交换</strong>，此时末尾就是最大值</p></li><li><p>然后将剩余 n-1 个元素<strong>重新构造成一个堆</strong>。如此反复，便能的得到一个有序序列。</p></li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul><li>先将整个待排序的记录序列分割成为<strong>若干子序列</strong>。</li><li>分别进行<strong>直接插入排序</strong>。</li><li>待整个序列中的记录基本有序时，再对全体记录进行<strong>依次直接插入排序</strong>。</li></ul><p>希尔排序过程中，只涉及相邻数据的交换操作，空间复杂度为 O(1) 。所以是<strong>原地排序</strong>算法。</p><p>单次直接插入排序是稳定的，它不会改变相同元素之间的相对顺序，但在多次不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，可能导致相同元素相对顺序发生变化。 因此，希尔排序<strong>不稳定</strong>。</p><p>时间：最佳：<code>T(n) = O(nlogn)</code>。 最差：<code>T(n) = O(n(logn)^2)</code>。 平均：<code>T(n) = O(n(logn)^2)</code>。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈（stack）是一种运算受限的线性表。特点：<strong>先进后出</strong>。</p><blockquote><p>程序中的栈结构</p></blockquote><ul><li>函数调用栈：A(B(C(D())))：<br>即 A 函数中调用 B，B 调用 C，C 调用 D；在 A 执行的过程中会将 A 压入栈，随后 B 执行时 B 也被压入栈，函数 C 和 D 执行时也会被压入栈。所以当前栈的顺序为：A-&gt;B-&gt;C-&gt;D（栈顶）；函数 D 执行完之后，会弹出栈被释放，弹出栈的顺序为 D-&gt;C-&gt;B-&gt;A;</li><li>递归：<br>为什么没有停止条件的递归会造成栈溢出？比如函数 A 为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数 A 压入栈，最后造成栈溢出（Queue Overfloat）。</li></ul><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列（Queue）是一种运算受限的线性表，特点：先进先出。</p><p>事件循环中的宏任务和微任务队列。</p><p><strong>优先队列</strong></p><ul><li>每个元素不再只是一个数据，还包含优先级。</li><li>在添加元素过程中，根据优先级放入到正确位置。</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>常见的数组定义：<strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p><p><strong>JavaScript 数组的长度和元素类型都是非固定的。</strong></p><p>因为数组的<strong>长度可随时改变</strong>，并且其数据<strong>在内存中也可以不连续</strong>（存储相同类型元素内存连续）。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/j0lv5T"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/07/j0lv5T.png" alt="j0lv5T.png" style="zoom:33%"></a></p><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><blockquote><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p></blockquote><p>其实<strong>数组就是一张哈希表</strong>。哈希表中关键码就是数组的索引下表，然后通过下表直接访问数组中的元素。</p><p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><p>我们一般会选择如下三种数据结构：</p><ul><li><strong>数组</strong></li><li><strong>set（集合）</strong></li><li><strong>map（映射）</strong></li></ul><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是一种通过<strong>指针</strong>串联在一起的线性结构，每一个节点由两部分组成，一个是<strong>数据域</strong>一个是<strong>指针域</strong>（存放指向下一个节点的指针），<strong>最后一个节点的指针域指向null</strong>（空指针的意思）。链接的入口节点称为链表的头结点也就是<code>head</code>。</p><p><strong>单链表</strong>：单链表中的节点只能指向节点的下一个节点。</p><p><strong>双链表</strong>：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p><p><strong>双链表既可以向前查询也可以向后查询</strong>。</p><p><strong>循环链表</strong>，就是链表首尾相连。</p><p>链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><p>链表的增添和删除都是O(1)操作，也不会影响到其他节点。</p><p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p><p>链表的长度可以是不固定的，并且可以动态增删， <strong>适合数据量不固定，频繁增删，较少查询的场景</strong>。</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hZKNm8"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/08/25/hZKNm8.png" alt="hZKNm8.png"></a></p><p>常用术语：</p><ul><li>节点的度（Degree）：<strong>节点的子树个数</strong>，比如节点 B 的度为 2；</li><li>树的度：<strong>树的所有节点中最大的度数</strong>，如上图树的度为 2；</li><li>叶节点（Leaf）：<strong>度为 0 的节点（也称为叶子节点）</strong>，如上图的 H，I 等；</li><li>父节点（Parent）：<strong>度不为 0 的节点称为父节点</strong>，如上图节点 B 是节点 D 和 E 的父节点；</li><li>子节点（Child）：若 B 是 D 的父节点，那么 D 就是 B 的子节点；</li><li>兄弟节点（Sibling）：具有同一父节点的各节点彼此是兄弟节点，比如上图的 B 和 C，D 和 E 互为兄弟节点；</li><li>路径和路径长度：<strong>路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长</strong>度，比如 A-&gt;H 的路径长度为 3；</li><li>节点的层次（Level）：规定根节点在 1 层，其他任一节点的层数是其父节点的层数加 1。如 B 和 C 节点的层次为 2；</li><li>树的深度（Depth）：<strong>树种所有节点中的最大层次是这棵树的深度</strong>，如上图树的深度为 4；</li></ul><p>如果树中的每一个节点最多只能由两个子节点，这样的树就称为<strong>二叉树</strong></p><p><strong>二叉树的种类</strong></p><ul><li><p><strong>满二叉树</strong>：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p><p>也可以说深度为k，有2^k-1个节点的二叉树。</p></li><li><p><strong>完全二叉树</strong>：除了最<strong>底层节点可能没填满外</strong>，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层<strong>最左边的若干位置</strong>。若最底层为第 h 层，则该层包含 1~ 2^h -1 个节点。</p></li></ul><p><strong>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</strong></p><p>二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵<strong>空树</strong>或它的<strong>左右两个子树的高度差的绝对值不超过1</strong>，并且<strong>左右两个子树都是一棵平衡二叉树</strong>。</p><p><strong>二叉树的存储方式</strong></p><ul><li>链式存储 通过<strong>指针</strong>把分布在散落在各个地址的节点串联一起</li><li>顺序存储 数组 在内存是连续分布的</li></ul><p><strong>二叉树的遍历方式</strong></p><ul><li><strong>深度优先遍历</strong>：先往深走，遇到叶子节点再往回走。前中后，其实指的就是根节点的遍历顺序<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li><strong>广度优先遍历</strong>：一层一层的去遍历。<ul><li>层次遍历（迭代法，队列）</li></ul></li></ul><p><strong>前端应用</strong>：DOM树、CSS规则树、虚拟DOM、AST语法树</p><h2 id="各自优势"><a href="#各自优势" class="headerlink" title="各自优势"></a>各自优势</h2><h3 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h3><ul><li>优点：可以通过下标值访问，效率高；</li><li>缺点：查找数据时需要先对数据进行排序，生成有序数组，才能提高查找效率；并且在插入和删除元素时，需要大量的位移操作；</li></ul><h3 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h3><ul><li>优点：数据的插入和删除操作效率都很高；</li><li>缺点：查找效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。</li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul><li>优点：哈希表的插入/查询/删除效率都非常高；</li><li>缺点：空间利用率不高，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是无序的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中最大值或最小值这些特殊值。</li></ul><h3 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h3><ul><li>优点：树结构综合了上述三种结构的优点，同时也弥补了它们存在的缺点（虽然效率不一定都比它们高），比如树结构中数据都是有序的，查找效率高；空间利用率高；并且可以快速获取最大值和最小值等。</li></ul><p>总的来说：每种数据结构都有自己特定的应用场景。</p><h2 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h2><p>动态规划</p><p>英文：Dynamic Programming，简称<strong>DP</strong>，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的。</p><blockquote><p>动态规划问题五步曲</p></blockquote><ol><li>确定<strong>dp数组（dp table）</strong>以及<strong>下标</strong>的含义</li><li>确定<strong>递推公式</strong></li><li>dp数组如何<strong>初始化</strong></li><li>确定<strong>遍历顺序</strong></li><li><strong>举例</strong>推导dp数组</li></ol><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p><p><strong>刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心</strong>。</p><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p><p>回溯是递归的副产品，只要有递归就会有回溯。</p><p><strong>回溯函数也就是递归函数，指的都是一个函数</strong>。</p><blockquote><p>回溯法解决的问题</p></blockquote><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合。</li><li>切割问题：一个字符串按一定规则有几种切割方式。</li><li>子集问题：一个N个数的集合里有多少符合条件的子集。</li><li>排列问题：N个数按一定规则<strong>全排列</strong>，有几种排列方式。</li><li>棋盘问题：N皇后，解数独等等。</li></ul><p>组合无序，排列有序。</p><blockquote><p>如何理解回溯法</p></blockquote><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>！</p><p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度构成的树的深度</strong>。</p><blockquote><p>回溯法模板</p></blockquote><ul><li><p>回溯函数模板参数</p></li><li><p>回溯函数终止条件</p></li><li><p>回溯搜索的遍历过程</p></li></ul><p>在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Lp7IvF"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/04/08/Lp7IvF.png" alt="Lp7IvF.png"></a></p><p>注意图中，我特意举例集合大小和孩子的数量是相等的！</p><p>大家可以从图中看出<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p><p>分析完过程，回溯算法模板框架如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> backtracking= <span class="function">(<span class="params">参数</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双指针</p><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><p>二分法</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>操作系统（Operating System，缩写：OS）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石。</p><p>简单来讲，操作系统就是一种复杂的软件，相当于软件管家。</p><p>操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。</p><p><strong>操作系统的核心概念都是对具体物理硬件的抽象</strong>，主要有如下：</p><ul><li>进程（线程）：<strong>进程（线程）是操作系统对CPU的抽象</strong></li><li>虚拟内存（地址空间）：<strong>虚拟内存是操作系统对物理内存的抽象</strong></li><li>文件：<strong>文件是操作系统对物理磁盘的抽象</strong></li><li>多线程(multithreading)：是指从软件或者硬件上实现多个线程并发执行的技术</li><li>CPU 核心(core)：它是 CPU 的大脑，它接收指令，并执行计算或运算以满足这些指令。一个 CPU 可以有多个内核</li><li>图形处理器(Graphics Processing Unit)：又称显示核心、视觉处理器、显示芯片或绘图芯片</li><li>缓存命中(cache hit)：当应用程序或软件请求数据时，会首先发生缓存命中</li><li>RAM((Random Access Memory)：随机存取存储器，也叫主存，是与 CPU 直接交换数据的内部存储器</li><li>ROM (Read Only Memory)：只读存储器是一种半导体存储器，其特性是一旦存储数据就无法改变或删除</li><li>进程间通信(interprocess communication)： 指至少两个进程或线程间传送数据或信号的一些技术或方法</li></ul><h2 id="进程和线程★"><a href="#进程和线程★" class="headerlink" title="进程和线程★"></a>进程和线程★</h2><blockquote><p>考察公司：华为</p></blockquote><h3 id="进程、线程和协程"><a href="#进程、线程和协程" class="headerlink" title="进程、线程和协程"></a>进程、线程和协程</h3><ul><li>进程是<strong>系统进行资源分配和调度的一个独立单位</strong>。</li><li>线程是<strong>CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位</strong>。</li><li>协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的轻量级线程，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。</li></ul><p><strong>一个进程至少由一个线程组成</strong>。线程自己基本上<strong>不拥有系统资源</strong>，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程<strong>共享进程所拥有的全部资源</strong>。</p><p>进程与进程之间完全隔离，互不干扰，一个进程崩溃不会影响其他进程，避免一个进程出错影响整个程序 。</p><p>一个进程中可以并发多个线程，每个线程并行执行不同的任务 。</p><p>一个进程中的任意一个线程执行出错，会导致这个进程崩溃 。</p><p>同一进程下的线程之间可以直接通信和共享数据 。</p><p>当一个进程关闭之后，操作系统会回收该进程的内存空间。</p><h3 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h3><p>浏览器从关闭到启动，然后新开一个页面至少需要：1个浏览器进程，1个GPU进程，1个网络进程，和1个渲染进程，一共4个进程；</p><p>后续如果再打开新的标签页：浏览器进程，GPU进程，网络进程是共享的，不会重新启动，然后默认情况下会为每一个标签页配置一个渲染进程，但是也有例外，比如从A页面里面打开一个新的页面B页面，而A页面和B页面又属于同一站点的话，A和B就共用一个渲染进程，其他情况就为B创建一个新的渲染进程。</p><p>所以，最新的Chrome浏览器包括：1个浏览器主进程，1个GPU进程，1个网络进程，多个渲染进程，和多个插件进程。</p><ul><li><strong>浏览器进程</strong>：负责控制浏览器除标签页外的界面，包括地址栏、书签、前进后退按钮等，以及负责与其他进程的协调工作，同时提供存储功能。</li><li><strong>GPU进程</strong>：负责整个浏览器界面的渲染。Chrome刚开始发布的时候是没有GPU进程的，而使用GPU的初衷是为了实现3D CSS效果，只是后面网页、Chrome的UI界面都用GPU来绘制，这使GPU成为浏览器普遍的需求，最后Chrome在多进程架构上也引入了GPU进程 。</li><li><strong>网络进程</strong>：负责发起和接受网络请求，以前是作为模块运行在浏览器进程一时在面的，后面才独立出来，成为一个单独的进程。</li><li><strong>插件进程</strong>：主要是负责插件的运行，因为插件可能崩溃，所以需要通过插件进程来隔离，以保证插件崩溃也不会对浏览器和页面造成影响。</li><li><strong>渲染进程</strong>：负责控制显示tab标签页内的所有内容，核心任务是将HTML、CSS、JS转为用户可以与之交互的网页，排版引擎Blink和JS引擎V8都是运行在该进程中，默认情况下Chrome会为每个Tab标签页创建一个渲染进程。</li></ul><p><strong>渲染进程（浏览器内核）</strong></p><p>浏览器的渲染进程是<strong>多线程</strong>的，<strong>页面的渲染，JavaScript 的执行，事件的循环</strong>，都在这个进程内进行：</p><ul><li><strong>GUI 渲染线程</strong>：负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。</li><li><strong>JavaScript 引擎线程</strong>：也称为 JavaScript 内核，负责处理 Javascript 脚本程序、解析 Javascript 脚本、运行代码等。（例如 V8 引擎）</li><li><strong>事件触发线程</strong>：用来控制浏览器事件循环，注意这不归 JavaScript 引擎线程管，当事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。</li><li><strong>定时触发器线程</strong>：传说中的 setInterval 与 setTimeout 所在线程，注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms 。</li><li><strong>异步 http 请求线程</strong>：在 XMLHttpRequest 连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li></ul><p>注意，<strong>GUI 渲染线程与 JavaScript 引擎线程是互斥的</strong>，当 JavaScript 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JavaScript 引擎空闲时立即被执行。所以如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><p><strong>单线程的JavaScript</strong></p><p>所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><ol><li><strong>管道/匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li><li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li><li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li><li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。</strong></li><li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li><li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li><li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。</p><p><strong>产生死锁的四个必要条件是什么?</strong></p><p>如果系统中以下四个条件同时成立，那么就能引起死锁：</p><ul><li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li><li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li><li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li><li><strong>循环等待</strong>：有一组等待进程 <code>&#123;P0, P1,..., Pn&#125;</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li></ul><p>注意，只有四个条件同时成立时，死锁才会出现。</p><p><strong>解决死锁的方法</strong></p><p>解决死锁的方法可以从多个角度去分析，一般的情况下，有<strong>预防，避免，检测和解除四种</strong>。</p><ul><li><strong>预防</strong> 是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</li><li><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></li><li><strong>检测</strong>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</li><li><strong>解除</strong> 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</li></ul><h2 id="虚拟内存★"><a href="#虚拟内存★" class="headerlink" title="虚拟内存★"></a>虚拟内存★</h2><blockquote><p>考察公司：腾讯</p></blockquote><p>再问你一个常识性的问题！<strong>什么是虚拟内存(Virtual Memory)?</strong></p><p>这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。<strong>为什么可以这样呢？</strong> 正是因为 <strong>虚拟内存</strong> 的存在，通过 <strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。这样会更加有效地管理内存并减少出错。</p><p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。<strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 <strong>把内存扩展到硬盘空间</strong>。</p><h2 id="常见的锁★"><a href="#常见的锁★" class="headerlink" title="常见的锁★"></a>常见的锁★</h2><blockquote><p>考察公司：华为</p></blockquote><h3 id="互斥锁与自旋锁：谁更轻松自如？"><a href="#互斥锁与自旋锁：谁更轻松自如？" class="headerlink" title="互斥锁与自旋锁：谁更轻松自如？"></a>互斥锁与自旋锁：谁更轻松自如？</h3><p>最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。</p><p>加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。</p><p>当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：</p><ul><li><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li><li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li></ul><p>互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，<strong>既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞</strong>。</p><p><strong>对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的</strong>。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b4d5c8a73274715886c9bf672eca0d2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。</p><p>那这个开销成本是什么呢？会有<strong>两次线程上下文切换的成本</strong>：</p><ul><li>当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；</li><li>接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。</li></ul><p>线程的上下文切换的是什么？当两个线程是属于同一个进程，<strong>因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</strong></p><p>上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。</p><p>所以，<strong>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。</strong></p><p>自旋锁是通过 CPU 提供的 <code>CAS</code> 函数（<em>Compare And Swap</em>），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。</p><p>一般加锁的过程，包含两个步骤：</p><ul><li>第一步，查看锁的状态，如果锁是空闲的，则执行第二步；</li><li>第二步，将锁设置为当前线程持有；</li></ul><p>CAS 函数就把这两个步骤合并成一条硬件级指令，形成<strong>原子指令</strong>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</p><p>使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 <code>while</code> 循环等待实现，不过最好是使用 CPU 提供的 <code>PAUSE</code> 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。</p><p>自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。<strong>需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</strong></p><p>自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。</p><p>自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：<strong>当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对</strong>。</p><p>它俩是锁的最基本处理方式，更高级的锁都会选择其中一个来实现，比如读写锁既可以选择互斥锁实现，也可以基于自旋锁实现。</p><hr><h3 id="读写锁：读和写还有优先级区分？"><a href="#读写锁：读和写还有优先级区分？" class="headerlink" title="读写锁：读和写还有优先级区分？"></a>读写锁：读和写还有优先级区分？</h3><p>读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。</p><p>所以，<strong>读写锁适用于能明确区分读操作和写操作的场景</strong>。</p><p>读写锁的工作原理是：</p><ul><li>当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。</li><li>但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。</li></ul><p>所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。</p><p>知道了读写锁的工作原理后，我们可以发现，<strong>读写锁在读多写少的场景，能发挥出优势</strong>。</p><p>另外，根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。</p><p>读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取读锁。如下图：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24eeac7c225746cd8bff53ed2d8be52b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>而写优先锁是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取读锁。如下图：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f355161b38c94aa499292a6055b4c88f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。</p><p>写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。</p><p>既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。</p><p><strong>公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。</strong></p><p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p><hr><h3 id="乐观锁与悲观锁：做事的心态有何不同？"><a href="#乐观锁与悲观锁：做事的心态有何不同？" class="headerlink" title="乐观锁与悲观锁：做事的心态有何不同？"></a>乐观锁与悲观锁：做事的心态有何不同？</h3><p>前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。</p><p>悲观锁做事比较悲观，它认为<strong>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁</strong>。</p><p>那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。</p><p>乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：<strong>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作</strong>。</p><p>放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。</p><p>可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现<strong>乐观锁全程并没有加锁，所以它也叫无锁编程</strong>。</p><p>这里举一个场景例子：在线文档。</p><p>我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。</p><p>那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。</p><p>怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交改动，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。</p><p>服务端要怎么验证是否冲突了呢？通常方案如下：</p><ul><li>由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；</li><li>当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号一致则修改成功，否则提交失败。</li></ul><p>实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。</p><p>乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以<strong>只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。</strong></p><hr><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。</p><p>如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。</p><p>如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。</p><p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p><p>另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。</p><p>相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p><p>但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。</p><p>不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。</p><h1 id="前端发展"><a href="#前端发展" class="headerlink" title="前端发展"></a>前端发展</h1><h2 id="基础框架-工程化"><a href="#基础框架-工程化" class="headerlink" title="基础框架/工程化"></a>基础框架/工程化</h2><p>随着 jQuery.js 渐渐淡出人们的视野，前端开发框架成为了开发人员必不可少的工具，也成为大家最为关注的东西。</p><h3 id="mv-框架"><a href="#mv-框架" class="headerlink" title="mv* 框架"></a>mv* 框架</h3><ul><li>React（Next.js）</li><li>Vue（nuxt.js）</li><li>Svelte</li><li>Angular。</li></ul><p>React 即将发布18版本，vue3 成为vue默认版本，Svelte异军突起。</p><h3 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h3><ul><li><p>传统：Webpack, Rollup, Parcel, Esbuild</p></li><li><p>ESM相关：Snowpack, Vite；</p><p>ESM（ECMAScript modules）的实现：在开发环境编译时，使用 Server 动态编译 + 浏览器的 ESM，基本上实现了“开发环境 0 编译”的功能。而生产环境编译时，则会调用其他编译工具来完成（如 Vite 使用 Rollup）。</p></li></ul><h3 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h3><ul><li>Babel</li><li>Prettier</li><li>ESLint</li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul><li>Tailwind CSS（原子类）</li></ul><h3 id="web3D"><a href="#web3D" class="headerlink" title="web3D"></a>web3D</h3><ul><li>Three.js</li><li>Oasis Engine</li></ul><h3 id="跨端"><a href="#跨端" class="headerlink" title="跨端"></a>跨端</h3><ul><li>React Native</li><li>Flutter</li><li>Weex</li><li>uni-app</li><li>taro</li></ul><h3 id="桌面端"><a href="#桌面端" class="headerlink" title="桌面端"></a>桌面端</h3><ul><li>Tauri（Webview + Rust/.Net/Go）</li><li>electron（Chromium + Nodejs）</li></ul><h3 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h3><ul><li>qiankun</li><li>single-spa</li><li>micro-app</li></ul><h3 id="E2E-测试"><a href="#E2E-测试" class="headerlink" title="E2E 测试"></a>E2E 测试</h3><ul><li>cypress（node服务，与程序一起运行）</li><li>puppeteer（无头浏览器）</li></ul><h2 id="语言-1"><a href="#语言-1" class="headerlink" title="语言"></a>语言</h2><p>阿特伍德定律：任何可以用 JavaScript 来写的应用，最终都将用 JavaScript 来写。</p><p>随着前端应用大型化、复杂化，TypeScript 肯定会越来越普及。 未来，TypeScript 是否能得到浏览器和 Node.js 原生支持呢？我们一起期待吧。</p><p>前端的同学如果有想学习其他语言的，有如下推荐：</p><ul><li>Rust 是 JS 基础设施的未来 - Lee Robinson</li><li>全栈 —— Go</li><li>AI —— Python</li><li>Flutter —— Dart</li></ul><h2 id="行业趋势"><a href="#行业趋势" class="headerlink" title="行业趋势"></a>行业趋势</h2><h3 id="前端智能化"><a href="#前端智能化" class="headerlink" title="前端智能化"></a>前端智能化</h3><h4 id="低代码（LowCode）"><a href="#低代码（LowCode）" class="headerlink" title="低代码（LowCode）"></a>低代码（LowCode）</h4><p>其实就是早期的搭建系统、组件平台等（宜搭、微搭），这个概念2014年被著名的研究机构Forrester提出。低代码平台的门槛在逐步降低，从专业的技术人员向业务人员进行转变，中国低代码行业比较分散。 <img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dd2669683414107b15822ad63efaee1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="低代码.png"> <img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43da527e12f344adad57672e1d70d9ca~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="低代码1.png"> <img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec2a9071eb684a32b14acad58149fca5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="低代码四象限.jpg"></p><ul><li>其中，OutSystems、Mendix、微软Salesforce、ServiceNow 被评为行业领导者。</li><li>Appian、Oracle 和 Pega 被评为挑战者。</li><li>Creatio、Kintone、Newgen 和 Quickbase 被评为利基（niche）市场参与者。</li><li>今年没有厂商被评为远见者。</li></ul><p>Gartner 预测： “到 2023 年，超过 70% 的企业将采用低代码（LCAP）作为他们发展战略的关键目标之一”。到 2025 年，整体 LCAP（低代码开发平台）市场规模将达到 290 亿美元，年复合增长率超过 20%；其中，LCAP 的细分市场预计将在 2020——2025 年之间，从 44.5 亿美元增长至 143.8 亿美元，复合年增长率为 26.4%。</p><h4 id="代码自动生成"><a href="#代码自动生成" class="headerlink" title="代码自动生成"></a>代码自动生成</h4><p><code>Sketch2Code</code>，AI 将手绘稿子 转换为 html 代码。</p><p><code>imgcook</code>，将Sketch/PSD/图片 转换为 React、Vue、Flutter、小程序等代码。</p><h3 id="大前端（泛前端）"><a href="#大前端（泛前端）" class="headerlink" title="大前端（泛前端）"></a>大前端（泛前端）</h3><p>从切图仔、写 HTML 模板的“石器时代”，到前后端分离、大前端的“工业时代”，再到现在跨端技术、低代码的“电气时代”。前端研发的职责一直在改变，同时前端研发需要掌握的技术也在迭代更新。- 字节前端</p><h4 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h4><p>Serverless 是一种基于云计算的简化方式，基本可以理解为 FaaS（函数即服务）+ BaaS（后端即服务），在 BaaS 层进行存储与计算，在 FaaS 层提供云函数。</p><p>在 Serverless 的赋能之下，前端工程师能够将页面交互、业务逻辑、数据处理等全部掌控在自己的手中，实现了真正全栈的可能。</p><h4 id="全栈"><a href="#全栈" class="headerlink" title="全栈"></a>全栈</h4><p>“全栈开发者”是指“同时掌握前端、后端以及其他网站开发相关技能的开发者”。</p><p>一个“全栈开发者”可能会使用以下技能点：</p><p>前端：JavaScript、H5、CSS3、sass、less、React、Vue、webpack、jest。</p><p>后端：Nodejs/Deno、Go、Java、Spring、Gin、Kafka、Hadoop。</p><p>数据库：MySQL、mongoDB、redis、clickhouse。</p><p>运维：网络协议、CDN、Nginx、ZooKeeper、Docker、Kubernetes。</p><p>值得注意的是，一个优秀的工程师并不是以“栈”数取胜，而取决于你解决了什么层次的问题。</p><blockquote><p>“全栈”或者“专家”仅仅是实现目标的过程状态。吴军在《硅谷来信》中，将工程师划分成五个等级：<img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5426b5c30f5446ee8f10774f39d05266~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="工程师5个等级.png">从工程师能力模型来看，第一级需要集“天时地利人和”大成，是工程师的最高荣誉。普通人或许可以将目标聚焦在第二、三级。优秀的工程师并不是以“栈”数取胜，更重要的是拥有产品观、全局思维、沟通能力、学习能力、解决问题能力等。<a target="_blank" rel="noopener" href="https://juejin.cn/post/7062617190981173278">来源：《来自未来，2022 年的前端人都在做什么?》</a></p></blockquote><h4 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h4><p>DevOps（Development 和 Operations 的组合词）是一种重视“软件开发人员（Dev）”和“IT 运维技术人员（OPS）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。在开发、测试、部署、运维等多个领域进行了共建。</p><p>与 Kubernetes 相结合：Kubernetes 是一种开源容器编排系统，容器技术的日益普及是 DevOps 出现的因素之一。使用 Kubernetes DevOps，软件开发人员和运维团队可以快速实时地相互交换大量的应用程序，大大提高了生产力。 <img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/934be27077824dd2a88ba423479dc6ce~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="DevOps.png"></p><h4 id="微前端-1"><a href="#微前端-1" class="headerlink" title="微前端"></a>微前端</h4><p>微服务架构：微服务架构可以将一个应用分成若干个更小的服务，这让整个开发过程具有很高的敏捷性和可拓展性。</p><p>常用的微前端框架包括 qiankun、single-spa、micro-app</p><blockquote><p>微前端我觉得它其实没有太多的趋势。首先微前端就不是一个大家都要用的。微前端沾了微服务的光，但是微服务是所有后端基本上都要往架构上迁， 微前端很明显不是这样的。它更多的是单页应用并有多框架隔离的需求，然后做出微前端这样一个技术方案。我觉得说实话，微前端就不该这么热，包括很多学生都会问我微前端，我反问你有没有看过微前端解决什么样的问题？如果非要往这上边靠的话，就相当于没有困难创造困难也要上，举个例子，公司一共有四五个前端，就非要用微前端架构，四五个人都可以用不同框架，这其实是没必要的。- 程劭非（winter）</p></blockquote><p>我比较赞同老师说的，我认为一切技术都为了解决某个问题，关键在于我们有没有找准那个关键的问题，是否在解决这个问题。</p><h4 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h4><p>根据winter老师的看法，小程序只是一个前端的技术实现方案，并无大的难点和技术创新，更重要的是看商业模式上的考量。</p><p>解决小程序的跨平台开发问题可以采用框架转换：uni-app（Vue）、taro（React）。</p><h4 id="5G时代"><a href="#5G时代" class="headerlink" title="5G时代"></a>5G时代</h4><p>5G 时代到来，5G将与超高清视频、VR、AR、消费级云计算、智能家居、智慧城市、车联网、物联网、智能制造等产生深度融合，这些都将为前端技术的发展带来新的增长和机遇。WebGL、WebGPU等技术也将迎来一波发展的机会。</p><ul><li><p>Web 3D</p><p>3D 类的 H5 小游戏、在线看房、电子商务、在线教育等，对于技术而言这无疑是一片沃土。随着 5G 技术发展，视频加载速度会非常快，简单的实时渲染会被视频直接替代。复杂的可以通过服务器渲染，将画面传回网页中，只要传输够快，手机的性能就不再是问题。</p><p>相关的一些库：</p><p><code>Three.js</code>、<code>Oasis Engine</code>、<code>Babylon.js</code>、<code>PlayCanvas.js</code></p></li><li><p>WebRTC (Web Real-Time Communications)</p><p>传统的技术包括：XMLHttpRequest，WebSocket，未来：WebRTC 会在点对点私密传输、娱乐领域，元宇宙领域，低延迟领域大放异彩。</p></li></ul><h2 id="底层演进"><a href="#底层演进" class="headerlink" title="底层演进"></a>底层演进</h2><h3 id="前端历年大事件"><a href="#前端历年大事件" class="headerlink" title="前端历年大事件"></a><em>前端历年大事件</em></h3><p><em><code>2021 JavaScript大事件 ↓</code></em></p><p><strong>JavaScript</strong></p><p>8.24： TypeScript 新官网上线</p><p>12.4： JavaScript 26 岁了</p><p><strong>Node.js</strong></p><p>2.2： npm 7.0 正式可用</p><p>3.29： Deno 公司成立</p><p>4.21： Node.js 16 发布</p><p>7.20： Node-RED 2.0 发布，低代码编程工具</p><p>9.20： Node.js 发布 Corepack，用于管理npm、yarn、pnpm、cnpm</p><p>10.19： Node.js 17 发布</p><p><strong>Vue</strong></p><p>8.3： Vue.js 被选作维基百科的前端框架</p><p>8.5： Vue 3.2 发布</p><p>11.24： Pinia 正式成为 vuejs 的一员</p><p><strong>React</strong></p><p>5.28： React 18 alpha 发布</p><p>10.5： React 全新文档发布</p><p>11.27： Next.js 12 发布</p><p>12.14： Create React App 5.0 发布</p><p><strong>打包工具</strong></p><p>2021.1.6 Snowpack 3.0 发布</p><p>2021.2.17 Vite 2.0 发布</p><p>2021.10.13 Parcel v2 发布</p><p><strong>其他</strong></p><p>2021.3.6 jQuery 3.6.0 发布</p><p>2021.3.17 Chrome V8 9.0 发布</p><p>2021.10.7 jQuery Mobile 弃用</p><p>2021.11.4 Angular v13 发布</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>Chrome 一家独大，IE 浏览器将于 2022 年 6 月 15 日正式停用。</p><h3 id="HTML6-0"><a href="#HTML6-0" class="headerlink" title="HTML6.0"></a>HTML6.0</h3><p>支持原生模式、没有 JavaScript 的单页应用程序、自由调整图像大小、专用库、微格式、自定义菜单、增强身份验证、集成摄像头。</p><h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h3><p>WebAssembly 简称 Wasm，是一种可在 Web 中运行的全新语言格式，同时兼具体积小、性能高、可移植性强等特点，在底层上类似 Web 中的 JavaScript，同时也是 W3C 承认的 Web 中的第 4 门语言。</p><p>在前端的游戏、音乐、视频等领域大放异彩，目前很多桌面软件也纷纷通过编译成 Wasm 的形式搬进了浏览器中。</p><p>2022 年 Wasm 功能将会不断完善，同时也会有越来越多的传统 PC 软件推出 Web 版本。</p><h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><p>首次被列入十四五规划，2021年，中国企业积极构建开源平台。根据GitHub统计，中国开发者已成为全球最大规模的开发者群体。</p><h3 id="元宇宙"><a href="#元宇宙" class="headerlink" title="元宇宙"></a>元宇宙</h3><p>游戏、VR/AR、区块链数字资产等等概念的整合。</p><h3 id="web-3-0"><a href="#web-3-0" class="headerlink" title="web 3.0"></a>web 3.0</h3><p>web1.0: 单向信息，只读；web 2.0的标志：User Generated Content（用户生成内容，例如微博、Facebook）；web3.0: 人和网络以及网络与人的沟通。</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>在工业4.0的大背景下，随着人工智能、云计算、大数据、物联网、区块链等互联网潮流技术的不断推进，互联网行业走向工业化和智能化。全球疫情的常态化，越来越多的公司选择或者不得不居家办公（WFH），必然给前端行业带来更多的机会。</p><p>2023 年底全球软件开发人员达到 2770万，中国将占6％至8％，前端预计30万左右，而JavaScript 在全球目前约有 1400 万开发者。</p><p>2005左右才出现前端的岗位，变化非常快，目前还是处在发展期（好事儿），只有把握底层变化，不断思辨和学习，才能把焦虑控制在一定范围内。</p><blockquote><p>另外说到“卷”，还是上进心导致的，对吧？真想躺的话，能躺的办法还是挺多的。如果想要进前端的领域，从学习的角度来讲，我推荐 hard way。也就是说，我们看起来最难的那条路反而是最简单的，那些看起来简单的路，它有可能反而是更绕。你想往山顶上走，肯定选择最陡峭的，你想走下坡路，肯定选择最远的那条路。这个道理是是我想今天传达给大家的，原因还是在于看到太多的同学们想走捷径，或者说想走简单的路，结果反而越走越远，最后绕回来的话反而消耗更大。- 程劭非（winter）</p></blockquote><p>最后，小厂前端团队押宝押什么? 押技术落地，押Vue3.0、TS、Three.js，押年轻人！</p><h1 id="签约注意"><a href="#签约注意" class="headerlink" title="签约注意"></a>签约注意</h1><p><strong>签约分为两种：</strong>签offer和签三方协议(就业协议书)。其中前者对个人及企业的约束效力远不及后者。三方也具体指你、企业和学校三方。</p><p><strong>offer</strong>一般是单位提供给你的一个录用意向，以合同的形式提供给你，要求你在上面签字，表明你接受对方的录用意向，愿意到单位工作。所以，这实际上<strong>相当于个人和企业签署的一个录用意向书</strong>，然后等你正式工作后，再签署劳动合同。</p><p><strong>三方协议</strong>是<strong>应届毕业生与单位、学校签署的正式协议</strong>，对单位、学校、个人都有很强的约束力，也是正式的签约形式。三方协议一般一式四份，学生本人一份，学院一份，学校一份，单位一份。学生与单位签署三方协议并盖章后，须将其中两份三方协议交至学院学校处。<strong>三方协议会影响最终报到证与档案等的调动。</strong>有些学校还将有无签署三方作为衡量部分学生能否毕业和拿到毕业证的相关指标。所以，三方协议不能怠慢，必须引起重视。</p><p>如果有的同学之前已经跟其它单位签约，现在又想和新单位签约，那么又涉及到一个问题，就是<strong>违约</strong>。</p><p>如果签了offer以后，又不去这家单位了，就是违约，需要缴纳一定金额的违约金。尽管offer不是三方协议，但它实际上是你和公司之间签署的一个非正式的合同。所以，<strong>如果在offer中约定了违约金，那么，当你不去时，就算违约，仍然要交违约金。</strong></p><p>同时，违约金也会有相关规定。一般来讲，违约金特别高的，要慎重签约，因为很可能是单位不好，留不住人，才通过高额的违约金来栓住你。如果offer上没规定违约金事宜，那么一般情况下是不用交违约金的。但这时，你损害的是个人信誉。所以，在签offer时，还是要慎重。</p><p>毕业生原则上只能签约一个用人单位，特殊情况需要违约，则得向学校相关部门申请违约。</p><p>​ <strong>第一步：</strong>首先要与原单位取得联系，委婉地说明自己违约的原因，<strong>表达想违约的意愿</strong>。</p><p>　　<strong>注：</strong>一般同学会采取电联，<strong>在此建议可以采取邮件加电联的方式。因为邮件可以作为书面证据</strong>，你告知过原单位相关情况。为万一出现的纠纷留好证据。</p><p>　　<strong>第二步：****要求原签约单位出具的解约或违约书面退函。</strong></p><p>　　<strong>注：</strong>记得一定需<strong>加盖单位公章</strong>，因为这样才有效；此外，因为原三方上可能约定了违约金的，部分企业会要求你缴纳违约金才肯给你解约函。这时候，你可直接缴纳违约金，获取解约函，或者向原企业“哭穷”“装可怜”减少违约金甚至不交违约金。总之，在此环节内想尽办法拿到盖有单位公章的解约书才是王道！</p><p>　　<strong>第三步：****取得新单位的书面接收函。</strong></p><p>　　<strong>注：</strong>注意新单位的签约时间，及时和新单位HR联系，了解近况。<strong>有不少同学由于原公司拖着不给违约书，导致错过新单位的签约。</strong>新单位的书面接收函也需加盖单位公章，因为这样才有效。</p><p>　　<strong>第四步：</strong> 将原签约单位的解约函与新单位的签收函交至学校相关部门（一般都是招生就业处）<strong>换取新三方。</strong></p><p>　　<strong>第五步：</strong> 拿新三方与新的单位签约，再将签好盖好章的新三方交至学校与学院。</p><p>　　<strong>注：</strong>最好留个心和校方核对一下，<strong>千万不要出现将档案、报到证弄错成原单位的。</strong></p><p><strong>派遣证一式两份，一份是派遣证，另一部分是报到证。</strong>派遣证在你毕业后将放入你的档案，由国家直接打到你的单位（档案属国家机密，不允许个人持有。如果你的用人单位拥有档案保存资格那么你的档案就放在单位，如果没有，那单位会掏钱将你的档案放在人才市场类的档案保存处。如果你没工作，那你的档案就直接打回原籍）。而报到证则交由你手自行保管。在这里必须要重点说的是，很多人在毕业后没多久就把报到证丢了，而当若干年后单位希望将你提干要求出示报到证时，很多就没有了，而只能再跑回某地去重新开证明，这时的证明可就没那么好开了，所以还是保管好。</p><p>　　<strong>“报到证”的全称是《全国普通高等学校本专科毕业生就业报到证》</strong>，由国家教育部直接印刷，省级高校毕业生就业管理部门单独签发，列入国家就业计划的毕业生才能持有的有效报到证件。</p><p>　　用人单位以报到证为依据，接收安排毕业生工作，并接转毕业生的人事档案、户口迁移手续等；报到证代表了毕业生的干部关系。</p><p>　　报到证只能一人一份，由其它部门印制或签发的报到证无效。毕业生对报到证要妥善保管，不论什么原因，凡自行涂改、撕毁的报到证一律作废。</p><p>　　如报到证遗失，应由毕业生本人向学校就业办公室提出申请，由学校核实后，出具证明材料，毕业生本人持证明材料到省级高校毕业生就业指导中心办理报到证遗失证明。 <strong>报到证一式二份，一份进本人档案，一份交单位，是今后转正和干部身份的重要证明。</strong></p><p>　　报到证制度沿袭多年直至今日。现在人才市场中，一些个体企业、外资企业表示不需要毕业生的报到证，但是，只要是对学生负责的用人单位，都应该很重视报到证；对于作为中国普通高校正式应届毕业生来说，在现有体制下，报到证的作用必将影响你毕业之后的生活。如果签了offer的同学一定要向学校老师询问清楚各项手续应该什么时候办，应该走什么流程，才能顺利毕业呀！</p><p><strong>在和公司正式签三方时，要注意以下事项：</strong></p><p>1）如果你非常想去这家单位的话，就在个人意见栏填写“同意到xxx单位工作”。</p><p>2）如果对方向你承诺解决户口问题，一定要把这一条写到三方后面的备注栏里。例如“xx公司承诺为本人解决北京户口”，这是维护自己的正当权益。当然，公司也会在里面写上“违约金xxx”。</p><p>3）要看填写的用人单位名称是否与单位的有效印鉴名称一致，如不一致，协议无效；填写自己的专业名称时，要与学校教务处的专业名称一致，不能简写。</p><p>4）学生在签订协议时，要严格按照规定的步骤进行。等用人单位填写完毕、盖章后再到学校就业指导中心签证盖章。以防单位在填写时，工资待遇等与过去承诺的大相径庭。学生却因为自己和学校都已经签字盖章，而无法挽回。</p><p>5）三方协议书只是毕业生、用人单位、学校三方之间签订的就业意向，不是劳动关系的法律文件，对劳动关系没有约束力。签订了三方协议并没有进入就业的“保险箱”，还需要接受用人单位实习期、试用期的进一步考察。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leslie Waong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesliewaong.top/posts/ec74fa14.html">https://lesliewaong.top/posts/ec74fa14.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lesliewaong.top" target="_blank">Leslie Waong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/9.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/wx.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/zfb.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/avatar.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Leslie Waong</div><div class="author-info__description">BUPT</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">122</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lesliewaong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lesliewaong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1138964397&amp;website=www.qtxml.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">红雨漂泊泛起了回忆怎么潜</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%AE%A4"><span class="toc-text">实验室</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Git"><span class="toc-text">Git</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E5%91%BD%E5%90%8D"><span class="toc-text">分支命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VSCode"><span class="toc-text">VSCode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pull-Request"><span class="toc-text">Pull Request</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E5%AE%9A%E5%BC%8F%E6%8F%90%E4%BA%A4-1-0-0"><span class="toc-text">约定式提交 1.0.0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-%E4%B8%AD%E7%9A%84%E6%92%A4%E9%94%80"><span class="toc-text">Git 中的撤销</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E6%9C%80%E8%BF%91%E5%87%A0%E6%AC%A1-commit"><span class="toc-text">撤销最近几次 commit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6-commit"><span class="toc-text">合并 commit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%AA%E5%8A%A8-commit"><span class="toc-text">挪动 commit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3"><span class="toc-text">冲突解决</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">计算机网络和浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">计算机网络体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BD%91%E7%BB%9C%E8%A6%81%E5%88%86%E5%B1%82%EF%BC%9F"><span class="toc-text">为什么网络要分层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-text">网络通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0"><span class="toc-text">URL输入到页面展现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URL"><span class="toc-text">URL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E8%A7%A3%E6%9E%90"><span class="toc-text">DNS解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E2%98%85"><span class="toc-text">TCP三次握手 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E2%98%85"><span class="toc-text">TCP四次挥手 ★</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E6%96%B9%E6%B3%95"><span class="toc-text">HTTP方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GET-%E4%B8%8E-POST-%E2%98%85"><span class="toc-text">GET 与 POST ★</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F"><span class="toc-text">参数传递方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E4%B8%8D%E5%90%8C"><span class="toc-text">参数长度限制不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%92%8C%E5%B9%82%E7%AD%89"><span class="toc-text">安全和幂等</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8D%E5%90%8C%EF%BC%88%E4%BC%A0%E8%BE%93%E7%9A%84%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="toc-text">安全性不同（传输的角度）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%B8%8D%E5%90%8C"><span class="toc-text">缓存机制不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%B6%88%E8%80%97%E4%B8%8D%E5%90%8C"><span class="toc-text">时间消耗不同</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HEAD"><span class="toc-text">HEAD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUT"><span class="toc-text">PUT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DELETE"><span class="toc-text">DELETE</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%A4%B4%E9%83%A8"><span class="toc-text">HTTP头部</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Accept"><span class="toc-text">Accept</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Connection"><span class="toc-text">Connection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Keep-Alive"><span class="toc-text">Keep-Alive</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%89%B9%E6%80%A7"><span class="toc-text">HTTP特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS"><span class="toc-text">HTTP和HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E4%BC%98%E7%82%B9"><span class="toc-text">HTTPS优点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86"><span class="toc-text">混合加密</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-text">数字证书</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95"><span class="toc-text">摘要算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E8%BF%9E%E6%8E%A5"><span class="toc-text">HTTPS连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1%E3%80%81HTTP-2%E3%80%81HTTP-3%E6%BC%94%E5%8F%98"><span class="toc-text">HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3演变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-1"><span class="toc-text">HTTP&#x2F;1.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-2"><span class="toc-text">HTTP&#x2F;2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-3"><span class="toc-text">HTTP&#x2F;3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AB%AF%E5%8F%A3%E5%8F%B7%E6%9C%80%E5%A4%A7%E4%B8%BA65535%EF%BC%9F"><span class="toc-text">为什么端口号最大为65535？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1"><span class="toc-text">跨域通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90-%E8%B7%A8%E5%9F%9F"><span class="toc-text">同源&#x2F;跨域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">跨域解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSONP%EF%BC%88JSON-with-Padding%EF%BC%89"><span class="toc-text">JSONP（JSON with Padding）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS"><span class="toc-text">CORS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-text">简单请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82"><span class="toc-text">复杂请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ECORS%E7%9A%84-cookie-%E9%97%AE%E9%A2%98"><span class="toc-text">关于CORS的 cookie 问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CORS%E5%AE%8C%E6%95%B4%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">CORS完整复杂请求的例子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86"><span class="toc-text">代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Node%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-text">Node中间件代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#React%E4%B8%AD%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86"><span class="toc-text">React中配置代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">Nginx反向代理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocket"><span class="toc-text">WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90"><span class="toc-text">简单例子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#postMessage"><span class="toc-text">postMessage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90-1"><span class="toc-text">简单例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie%E3%80%81sessionStorage%E3%80%81localStorage"><span class="toc-text">Cookie、sessionStorage、localStorage</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie"><span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#localStorage-amp-amp-sessionStorage"><span class="toc-text">localStorage &amp;&amp; sessionStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IndexedDB"><span class="toc-text">IndexedDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT"><span class="toc-text">Cookie、Session、Token、JWT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XSS%E5%92%8CCSRF"><span class="toc-text">XSS和CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS"><span class="toc-text">XSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%98%B2%E8%8C%83%E6%96%B9%E6%B3%95"><span class="toc-text">常用防范方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF"><span class="toc-text">CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CSRF%E4%B8%8E-XSS-%E5%8C%BA%E5%88%AB"><span class="toc-text">CSRF与 XSS 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1"><span class="toc-text">防御</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-UDP"><span class="toc-text">TCP UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-text">TCP 协议如何保证可靠传输</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%81%E8%AE%B8%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E8%B5%84%E6%BA%90%E6%95%B0"><span class="toc-text">浏览器允许的并发请求资源数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E5%AE%9A%E6%9C%9F%E5%90%91%E5%89%8D%E7%AB%AF%E6%8E%A8%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-text">后端定期向前端推送数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">浏览器多个标签之间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#localStorage%E5%AE%9E%E7%8E%B0%E9%80%9A%E4%BF%A1"><span class="toc-text">localStorage实现通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8websocket"><span class="toc-text">使用websocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SharedWorker"><span class="toc-text">SharedWorker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8cookie-setInterval"><span class="toc-text">使用cookie + setInterval</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ping"><span class="toc-text">Ping</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B"><span class="toc-text">性能检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%B5%84%E6%BA%90%E6%9B%B4%E5%BF%AB%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%EF%BC%9F"><span class="toc-text">如何保证资源更快的加载速度？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-dns-prefetch-%E5%87%8F%E5%B0%91-DNS-%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%97%B6%E9%97%B4"><span class="toc-text">使用 dns-prefetch 减少 DNS 的查询时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-preconnect-%E6%8F%90%E5%89%8D%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-text">使用 preconnect 提前建立连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E8%B5%84%E6%BA%90%E4%BD%93%E7%A7%AF"><span class="toc-text">压缩资源体积</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP-%E5%8E%8B%E7%BC%A9"><span class="toc-text">HTTP 压缩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Webpack-%E5%8E%8B%E7%BC%A9"><span class="toc-text">Webpack 压缩</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%91-http-%E8%AF%B7%E6%B1%82%E6%95%B0%E9%87%8F"><span class="toc-text">减少 http 请求数量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#webpack%E5%AF%B9%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="toc-text">webpack对图片资源进行优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84-cookie"><span class="toc-text">减少不必要的 cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CDN-%E6%89%98%E7%AE%A1%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90-HTTP-%E7%BC%93%E5%AD%98"><span class="toc-text">CDN 托管静态资源 + HTTP 缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E5%8D%87%E7%BA%A7%E4%B8%BA-Http2-0"><span class="toc-text">协议升级为 Http2.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">预加载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%A7%86%E5%9B%BE%E6%9B%B4%E5%BF%AB%E7%9A%84%E6%B8%B2%E6%9F%93%E5%92%8C%E4%BA%A4%E4%BA%92%EF%BC%9F"><span class="toc-text">如何保证视图更快的渲染和交互？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%B1%82%E9%9D%A2"><span class="toc-text">渲染层面</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E9%98%BB%E5%A1%9E%E6%B8%B2%E6%9F%93%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-text">减少阻塞渲染的因素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">懒加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%99%BD%E5%B1%8F%E4%BC%98%E5%8C%96"><span class="toc-text">白屏优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%88server-side-rendering%EF%BC%89"><span class="toc-text">服务端渲染（server-side rendering）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E6%B8%B2%E6%9F%93%EF%BC%88prerender%EF%BC%89"><span class="toc-text">预渲染（prerender）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%B1%82%E9%9D%A2"><span class="toc-text">交互层面</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E5%9B%9E%E6%B5%81-%E9%87%8D%E7%BB%98"><span class="toc-text">减少回流&#x2F;重绘</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81"><span class="toc-text">防抖&#x2F;节流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Web-Worker"><span class="toc-text">Web Worker</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8"><span class="toc-text">虚拟列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0"><span class="toc-text">大文件分片上传</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Excel-%E5%AF%BC%E5%85%A5-%E5%AF%BC%E5%87%BA"><span class="toc-text">Excel 导入&#x2F;导出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BC%98%E5%8C%96-%E2%98%85"><span class="toc-text">React项目的优化 ★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E9%87%8D%E6%96%B0render"><span class="toc-text">尽量避免重新render</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8PureComponent"><span class="toc-text">使用PureComponent</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ShouldComponentUpdate"><span class="toc-text">使用ShouldComponentUpdate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8React-memo"><span class="toc-text">使用React.memo</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8useMemo%E7%BC%93%E5%AD%98%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C"><span class="toc-text">使用useMemo缓存计算结果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8useCallback%E6%9D%A5%E7%BC%93%E5%AD%98%E5%87%BD%E6%95%B0"><span class="toc-text">使用useCallback来缓存函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E6%9D%A5%E9%81%BF%E5%85%8D%E4%B8%AD%E9%97%B4%E7%BB%84%E4%BB%B6%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%B8%B2%E6%9F%93"><span class="toc-text">使用发布订阅模式来避免中间组件不必要的渲染</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E5%B0%86%E7%8A%B6%E6%80%81%E6%94%BE%E5%88%B0%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%EF%BC%88%E7%8A%B6%E6%80%81%E4%B8%8B%E6%96%B9%EF%BC%89"><span class="toc-text">尽量将状态放到子组件中（状态下方）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E7%9A%84%E6%AF%8F%E4%B8%AAitem%E5%8A%A0%E4%B8%8Akey%E5%B1%9E%E6%80%A7"><span class="toc-text">列表的每个item加上key属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E5%87%8F%E5%B0%91%E8%A6%81%E6%B8%B2%E6%9F%93%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">尽量减少要渲染的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">组件懒加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8"><span class="toc-text">使用虚拟列表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%B7%BB%E5%8A%A0%E9%A2%9D%E5%A4%96%E7%9A%84DOM"><span class="toc-text">避免添加额外的DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8React-fragment%E6%9D%A5%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84div"><span class="toc-text">使用React.fragment来避免不必要的div</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="toc-text">HTTP&#x2F;浏览器缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B"><span class="toc-text">缓存类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98%E3%80%81%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-text">强缓存、协商缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%8F%91%E5%B1%95"><span class="toc-text">缓存发展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E6%96%B0"><span class="toc-text">刷新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93"><span class="toc-text">浏览器解析渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#script%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7"><span class="toc-text">script标签属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#async"><span class="toc-text">async</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer"><span class="toc-text">defer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%BB%98-%E5%9B%9E%E6%B5%81"><span class="toc-text">重绘&#x2F;回流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%B5%81-%E9%87%8D%E6%8E%92reflow"><span class="toc-text">回流&#x2F;重排reflow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BB%98Repaint"><span class="toc-text">重绘Repaint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81-%E9%87%8D%E7%BB%98"><span class="toc-text">避免回流&#x2F;重绘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#display%EF%BC%9Anone%E5%92%8Cvisibility%EF%BC%9Ahidden%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">display：none和visibility：hidden的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-text">服务端渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B2%E6%9F%93"><span class="toc-text">什么是渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-text">传统的服务端渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">实现原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-text">客户端渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E5%8C%96%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-text">现代化的服务端渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">分析优缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%EF%BC%9A"><span class="toc-text">相关技术：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF"><span class="toc-text">前端</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80"><span class="toc-text">语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AF%94"><span class="toc-text">其他语言对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB-vs-%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-text">基于类 vs 基于原型的语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-text">构造函数模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B-%E7%B1%BB-%E6%A8%A1%E5%BC%8F"><span class="toc-text">原型(类)模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%B8%B8%E7%94%A8%E4%BD%9C%E5%B0%81%E8%A3%85%E7%B1%BB%EF%BC%89"><span class="toc-text">混合模式（常用作封装类）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-text">原型链继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">借用构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-text">寄生组合式继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES6%E7%B1%BB%E7%BB%A7%E6%89%BFextends"><span class="toc-text">ES6类继承extends</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Js%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88"><span class="toc-text">Js中的堆栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%8C%BA"><span class="toc-text">栈区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%8C%BA"><span class="toc-text">堆区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-text">引用计数算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">标记清除算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%83%85%E5%86%B5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">常见内存泄露情况及解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E5%A4%96%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">意外的全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dom"><span class="toc-text">dom</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-text">事件监听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">解决内存泄漏的数据结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1"><span class="toc-text">7+1</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">模块化、组件化、工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">工程化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="toc-text">组件化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E5%A5%BD%E5%A4%84"><span class="toc-text">框架好处</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android%E8%AF%8D%E5%85%B8"><span class="toc-text">Android词典</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E7%88%AC%E5%8F%96"><span class="toc-text">单词数据的爬取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1"><span class="toc-text">界面设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API%E6%88%96SDK"><span class="toc-text">API或SDK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM"><span class="toc-text">MVVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-MVC"><span class="toc-text">Android MVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-MVVM"><span class="toc-text">Android MVVM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HR%E9%9D%A2"><span class="toc-text">HR面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D%E3%80%81%E9%9A%BE%E7%82%B9%E3%80%81%E6%94%B6%E8%8E%B7"><span class="toc-text">项目介绍、难点、收获</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9"><span class="toc-text">难点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E8%8E%B7%E4%B8%8E%E4%B8%8D%E8%B6%B3"><span class="toc-text">收获与不足</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E5%88%92"><span class="toc-text">规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E7%9A%84%E5%9B%B0%E9%9A%BE"><span class="toc-text">遇到的困难</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B-%E6%88%90%E7%BB%A9-%E8%8E%B7%E5%A5%96%E6%83%85%E5%86%B5-%E7%AB%9E%E8%B5%9B"><span class="toc-text">课程&#x2F;成绩&#x2F;获奖情况&#x2F;竞赛</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E7%BB%8F%E5%8E%86%E7%9A%84%E6%9C%80%E5%A4%A7%E6%8C%AB%E6%8A%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">你经历的最大挫折是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-%E7%AB%9E%E4%BA%89%E5%8A%9B"><span class="toc-text">优缺点 竞争力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E5%B9%B3%E6%97%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%9A%84%EF%BC%9F"><span class="toc-text">你平时是怎么学习的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%8E%A5%E8%A7%A6%E5%89%8D%E7%AB%AF%E7%9A%84-%E4%B8%BA%E5%95%A5%E5%AD%A6%E5%89%8D%E7%AB%AF"><span class="toc-text">你什么时候接触前端的&#x2F;为啥学前端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%97%A0%E6%84%8F%E5%90%91offer"><span class="toc-text">有无意向offer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%83%85%E5%95%86%E8%B7%9F%E8%81%8C%E5%95%86"><span class="toc-text">情商跟职商</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%8E%E5%B8%82"><span class="toc-text">城市</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B1%E5%A5%BD"><span class="toc-text">爱好</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%85%AC%E5%8F%B8%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%9F%E4%B8%BA%E5%95%A5%E9%80%89"><span class="toc-text">对公司的了解？为啥选</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E7%AB%99"><span class="toc-text">B站</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8E%E4%B8%BA"><span class="toc-text">华为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BD%E5%AE%B6%E7%94%B5%E6%8A%95"><span class="toc-text">国家电投</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%85%B4"><span class="toc-text">中兴</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%9F%E6%9C%9B%E8%96%AA%E8%B5%84"><span class="toc-text">期望薪资</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BE%8E%E5%9B%A2"><span class="toc-text">美团</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8E%E4%B8%BA-1"><span class="toc-text">华为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b%E7%AB%99"><span class="toc-text">b站</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%85%B4-1"><span class="toc-text">中兴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E"><span class="toc-text">完美</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B6%E5%BA%AD-%E5%8D%95%E8%BA%AB"><span class="toc-text">家庭&#x2F;单身</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%9F%E6%9C%9B%E7%9A%84%E5%9B%A2%E9%98%9F"><span class="toc-text">期望的团队</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E7%8F%AD"><span class="toc-text">加班</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85-toB-%E4%B8%8E-toC"><span class="toc-text">如何看待 toB 与 toC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E9%97%AE"><span class="toc-text">反问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF"><span class="toc-text">技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E7%AE%A1%E9%9D%A2%E5%8F%8D%E9%97%AE"><span class="toc-text">主管面反问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E9%9D%A2%E5%8F%8D%E9%97%AE"><span class="toc-text">技术面反问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HR"><span class="toc-text">HR</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SaaS%E3%80%81IaaS%E3%80%81PaaS%E3%80%81iPaaS%E5%92%8CaPaaS"><span class="toc-text">SaaS、IaaS、PaaS、iPaaS和aPaaS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SaaS%E3%80%81IaaS%E3%80%81PaaS"><span class="toc-text">SaaS、IaaS、PaaS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iPaaS%E5%92%8CaPaaS"><span class="toc-text">iPaaS和aPaaS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E8%87%AA%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-text">各自功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%81%8F%E9%87%8D%E7%82%B9%EF%BC%9A"><span class="toc-text">技术偏重点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-text">使用对象：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%88%E7%BC%BA%E7%82%B9%EF%BC%89"><span class="toc-text">问题（缺点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BE%E9%80%92%E5%BD%92"><span class="toc-text">尾递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memoization"><span class="toc-text">Memoization</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-text">数组排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E8%87%AA%E5%B8%A6%E6%8E%92%E5%BA%8F"><span class="toc-text">JS自带排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%85%E6%95%B0%E5%AD%97"><span class="toc-text">仅数字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-%E2%98%85"><span class="toc-text">快速排序 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-text">希尔排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-text">队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-text">哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-text">树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E8%87%AA%E4%BC%98%E5%8A%BF"><span class="toc-text">各自优势</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-1"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8-1"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-text">树结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-text">常见算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E2%98%85"><span class="toc-text">进程和线程★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B"><span class="toc-text">进程、线程和协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84"><span class="toc-text">浏览器是多进程的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">进程间通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E2%98%85"><span class="toc-text">虚拟内存★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%81%E2%98%85"><span class="toc-text">常见的锁★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%9A%E8%B0%81%E6%9B%B4%E8%BD%BB%E6%9D%BE%E8%87%AA%E5%A6%82%EF%BC%9F"><span class="toc-text">互斥锁与自旋锁：谁更轻松自如？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%9A%E8%AF%BB%E5%92%8C%E5%86%99%E8%BF%98%E6%9C%89%E4%BC%98%E5%85%88%E7%BA%A7%E5%8C%BA%E5%88%86%EF%BC%9F"><span class="toc-text">读写锁：读和写还有优先级区分？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9A%E5%81%9A%E4%BA%8B%E7%9A%84%E5%BF%83%E6%80%81%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">乐观锁与悲观锁：做事的心态有何不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95"><span class="toc-text">前端发展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6-%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">基础框架&#x2F;工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mv-%E6%A1%86%E6%9E%B6"><span class="toc-text">mv* 框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7"><span class="toc-text">打包工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83"><span class="toc-text">语法规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS"><span class="toc-text">CSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web3D"><span class="toc-text">web3D</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E7%AB%AF"><span class="toc-text">跨端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%8C%E9%9D%A2%E7%AB%AF"><span class="toc-text">桌面端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF"><span class="toc-text">微前端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E2E-%E6%B5%8B%E8%AF%95"><span class="toc-text">E2E 测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80-1"><span class="toc-text">语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF"><span class="toc-text">行业趋势</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%99%BA%E8%83%BD%E5%8C%96"><span class="toc-text">前端智能化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8E%E4%BB%A3%E7%A0%81%EF%BC%88LowCode%EF%BC%89"><span class="toc-text">低代码（LowCode）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90"><span class="toc-text">代码自动生成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%89%8D%E7%AB%AF%EF%BC%88%E6%B3%9B%E5%89%8D%E7%AB%AF%EF%BC%89"><span class="toc-text">大前端（泛前端）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Serverless"><span class="toc-text">Serverless</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E6%A0%88"><span class="toc-text">全栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DevOps"><span class="toc-text">DevOps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF-1"><span class="toc-text">微前端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="toc-text">小程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5G%E6%97%B6%E4%BB%A3"><span class="toc-text">5G时代</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%BC%94%E8%BF%9B"><span class="toc-text">底层演进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%8E%86%E5%B9%B4%E5%A4%A7%E4%BA%8B%E4%BB%B6"><span class="toc-text">前端历年大事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">浏览器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML6-0"><span class="toc-text">HTML6.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebAssembly"><span class="toc-text">WebAssembly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%BA%90"><span class="toc-text">开源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E5%AE%87%E5%AE%99"><span class="toc-text">元宇宙</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web-3-0"><span class="toc-text">web 3.0</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AD%BE%E7%BA%A6%E6%B3%A8%E6%84%8F"><span class="toc-text">签约注意</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/66c016fb.html" title="JVM"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/11.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="JVM"></a><div class="content"><a class="title" href="/posts/66c016fb.html" title="JVM">JVM</a><time datetime="2022-10-07T06:46:20.000Z" title="发表于 2022-10-07 14:46:20">2022-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ff54bd4f.html" title="JS垃圾回收"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/11.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="JS垃圾回收"></a><div class="content"><a class="title" href="/posts/ff54bd4f.html" title="JS垃圾回收">JS垃圾回收</a><time datetime="2022-10-07T03:01:02.000Z" title="发表于 2022-10-07 11:01:02">2022-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f7ede91d.html" title="Java基础"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/7.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="Java基础"></a><div class="content"><a class="title" href="/posts/f7ede91d.html" title="Java基础">Java基础</a><time datetime="2022-10-01T08:46:40.000Z" title="发表于 2022-10-01 16:46:40">2022-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f0caaae4.html" title="TS中那些奇怪的符号"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/3.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="TS中那些奇怪的符号"></a><div class="content"><a class="title" href="/posts/f0caaae4.html" title="TS中那些奇怪的符号">TS中那些奇怪的符号</a><time datetime="2022-07-10T03:12:48.000Z" title="发表于 2022-07-10 11:12:48">2022-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6155a9d6.html" title="Axios"><img src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/14.webp" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Lesliewaong/Lesliewaong.github.io/img/friend_404.gif"' alt="Axios"></a><div class="content"><a class="title" href="/posts/6155a9d6.html" title="Axios">Axios</a><time datetime="2022-07-05T08:42:42.000Z" title="发表于 2022-07-05 16:42:42">2022-07-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Leslie Waong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:""},null))},e=()=>{twikoo.getCommentsCount({envId:"https://twikoo-k8ctnwg8j-1138964397-qqcom.vercel.app/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))},n=(n=!1)=>{"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})};btf.loadComment(document.getElementById("twikoo-wrap"),n)})()</script></div><div class="aplayer no-destroy" data-id="6995412795" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="auto" data-autoplay="true" muted></div><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":0,"vOffset":0},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body></html>