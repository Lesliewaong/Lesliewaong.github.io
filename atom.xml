<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leslie Waong</title>
  
  <subtitle>Lesliewaongの博客</subtitle>
  <link href="https://lesliewaong.top/atom.xml" rel="self"/>
  
  <link href="https://lesliewaong.top/"/>
  <updated>2022-10-05T09:39:07.432Z</updated>
  <id>https://lesliewaong.top/</id>
  
  <author>
    <name>Leslie Waong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础</title>
    <link href="https://lesliewaong.top/posts/f7ede91d.html"/>
    <id>https://lesliewaong.top/posts/f7ede91d.html</id>
    <published>2022-10-01T08:46:40.000Z</published>
    <updated>2022-10-05T09:39:07.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h2><h3 id="Java-语言特点"><a href="#Java-语言特点" class="headerlink" title="Java 语言特点"></a>Java 语言特点</h3><ul><li><p>面向对象（封装，继承，多态）；</p></li><li><p>平台无关性（ <strong>Java 虚拟机</strong>实现平台无关性）；</p></li><li><p>支持多线程（ C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用<code>std::thread</code>和<code>std::async</code>来创建线程。）；</p></li><li><p>可靠性；</p></li><li><p>安全性；</p></li><li><p>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</p></li><li><p><strong>编译与解释</strong>并存；</p></li></ul><p>🌈 拓展一下：</p><p>“Write Once, Run Anywhere（一次编写，随处运行）”这句宣传口号，真心经典，流传了好多年！以至于，直到今天，依然有很多人觉得跨平台是 Java 语言最大的优势。实际上，跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你通过 Docker 就很容易实现跨平台了。在我看来，<strong>Java 强大的生态</strong>才是！</p><h3 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>Java 虚拟机（JVM）是<strong>运行 Java 字节码的虚拟机</strong>。</p><p>JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p><p><strong>字节码和不同系统的 JVM</strong> 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p><p><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong></p><p>也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</p><p>除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。</p><h4 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h4><p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。</p><p>它拥有 <strong>JRE 所拥有的一切</strong>，还有<strong>编译器（javac）</strong>和工具（如 javadoc 和 jdb）。<strong>它能够创建和编译程序</strong>。</p><p>JRE 是 <strong>Java 运行时环境</strong>。它是运行已编译 Java 程序所需的所有内容的集合，包括 <strong>Java 虚拟机（JVM）</strong>，Java 类库，java 命令和其他的一些基础构件。但是，<strong>它不能用于创建新程序</strong>。</p><p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</p><p>Java 语言通过字节码的方式，<strong>在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点</strong>。</p><p>所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p><strong>Java 程序从源代码到运行的过程如下所示：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.java =&gt; javac编译 =&gt; .class =&gt; 解释器&amp;JIT =&gt; 机器可理解的代码</span><br></pre></td></tr></table></figure><p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。</p><p>在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。</p><p>而且，有些方法和代码块是经常需要被调用的(也就是所谓的<strong>热点代码</strong>)，所以后面引进了 <strong>JIT（just-in-time compilation）</strong> 编译器，而 JIT 属于运行时编译。</p><p>当 JIT 编译器完成第一次编译后，会将字节码对应的机器码保存下来，下次可以直接使用。</p><p>而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p><blockquote><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。</p></blockquote><h3 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h3><p>AOT 可以提前编译节省启动时间，那为什么不全部使用这种编译方式呢？</p><p>长话短说，这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p><h3 id="“编译与解释并存”"><a href="#“编译与解释并存”" class="headerlink" title="“编译与解释并存”"></a>“编译与解释并存”</h3><p>其实这个问题我们讲字节码的时候已经提到过，因为比较重要，所以我们这里再提一下。</p><p>我们可以将高级编程语言按照程序的执行方式分为两种：</p><ul><li><strong>编译型</strong> ：编译型语言会通过<strong>编译器</strong>将源代码<strong>一次性翻译成可被该平台执行的机器码</strong>。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li><li><strong>解释型</strong> ：解释型语言会通过<strong>解释器</strong>一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li></ul><p>根据维基百科介绍：</p><blockquote><p>为了改善编译语言的效率而发展出的即时编译技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成字节码open in new window。到执行期时，再将字节码直译，之后执行。Java与LLVM是这种技术的代表产物。</p></blockquote><p><strong>为什么说 Java 语言“编译与解释并存”？</strong></p><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p><h3 id="Oracle-JDK-vs-OpenJDK"><a href="#Oracle-JDK-vs-OpenJDK" class="headerlink" title="Oracle JDK vs OpenJDK"></a>Oracle JDK vs OpenJDK</h3><p>可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle JDK 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。</p><p>对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：</p><blockquote><p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？</p><p>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p></blockquote><p><strong>总结：</strong></p><ol><li>Oracle JDK 大概每 6 个月发一次主要版本（从 2014 年 3 月 JDK 8 LTS 发布到 2017 年 9 月 JDK 9 发布经历了长达 3 年多的时间，所以并不总是 6 个月），而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。</li><li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；（个人观点：众所周知，JDK 原来是 SUN 公司开发的，后来 SUN 公司又卖给了 Oracle 公司，Oracle 公司以 Oracle 数据库而著名，而 Oracle 数据库又是闭源的，这个时候 Oracle 公司就不想完全开源了，但是原来的 SUN 公司又把 JDK 给开源了，如果这个时候 Oracle 收购回来之后就把他给闭源，必然会引起很多 Java 开发者的不满，导致大家对 Java 失去信心，那 Oracle 公司收购回来不就把 Java 烂在手里了吗！然后，Oracle 公司就想了个骚操作，这样吧，我把一部分核心代码开源出来给你们玩，并且我要和你们自己搞的 JDK 区分下，你们叫 OpenJDK，我叫 Oracle JDK，我发布我的，你们继续玩你们的，要是你们搞出来什么好玩的东西，我后续发布 Oracle JDK 也会拿来用一下，一举两得！）</li><li>Oracle JDK 比 OpenJDK 更稳定（肯定啦，Oracle JDK 由 Oracle 内部团队进行单独研发的，而且发布时间比 OpenJDK 更长，质量更有保障）。OpenJDK 和 Oracle JDK 的代码几乎相同（OpenJDK 的代码是从 Oracle JDK 代码派生出来的，可以理解为在 Oracle JDK 分支上拉了一条新的分支叫 OpenJDK，所以大部分代码相同），但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li><li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li><li>Oracle JDK 不会为即将发布的版本提供长期支持（如果是 LTS 长期支持版本的话也会，比如 JDK 8，但并不是每个版本都是 LTS 版本），用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li><li>Oracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li></ol><blockquote><p>既然 Oracle JDK 这么好，那为什么还要有 OpenJDK？</p><p>答：</p><ol><li>OpenJDK 是开源的，开源意味着你可以对它根据你自己的需要进行修改、优化，比如 Alibaba 基于 OpenJDK 开发了 Dragonwell8</li><li>OpenJDK 是商业免费的（这也是为什么通过 yum 包管理器上默认安装的 JDK 是 OpenJDK 而不是 Oracle JDK）。虽然 Oracle JDK 也是商业免费（比如 JDK 8），但并不是所有版本都是免费的。</li><li>OpenJDK 更新频率更快。Oracle JDK 一般是每 6 个月发布一个新版本，而 OpenJDK 一般是每 3 个月发布一个新版本。（现在你知道为啥 Oracle JDK 更稳定了吧，先在 OpenJDK 试试水，把大部分问题都解决掉了才在 Oracle JDK 上发布）</li></ol><p>基于以上这些原因，OpenJDK 还是有存在的必要的！</p></blockquote><p>🌈 拓展一下：</p><ul><li>BCL 协议（Oracle Binary Code License Agreement）： 可以使用 JDK（支持商用），但是不能进行修改。</li><li>OTN 协议（Oracle Technology Network License Agreement）： 11 及之后新发布的 JDK 用的都是这个协议，可以自己私下用，但是商用需要付费。</li></ul><h3 id="Java-vs-C"><a href="#Java-vs-C" class="headerlink" title="Java vs C++"></a>Java vs C++</h3><p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来。</p><p>虽然，Java 和 C++ 都是<strong>面向对象的语言，都支持封装、继承和多态</strong>，但是，它们还是有挺多不相同的地方：</p><ul><li>Java <strong>不提供指针</strong>来直接访问内存，程序内存更加安全<ul><li>虽然没有指针，但每个变量，如果不是基本数据类型（int float 等），那么就是一个引用（reference）。引用类似指针，只是不能进行指针运算。实现基本的数据结构时指针唯一的作用就是指向，不涉及指针运算（pointer arithmetic）（这也不叫 const pointer），所以 Java / Python 的引用已经足够做到这一点了。</li></ul></li><li>Java 的<strong>类是单继承</strong>的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是<strong>接口可以多继承</strong>。<ul><li>类 单继承<ul><li>java只支持单继承，如果子类继承的多个父类里面有相同的方法或者属性，子类将不知道具体继承哪一个，会产生歧义。举例说明：如果类A同时继承了B,C，类B和C有相同的方法d，那么类A该继承哪个类的d方法呢，这是不明确的。</li><li>如果父类中的方法同名，子类中没有覆盖，同样会产生上面的错误。</li><li>类是单继承，多实现。通俗的讲，子类只能有一个亲身父亲，但是一个父类可以有多个孩子。</li><li>因此java中就没有设计类的多继承。</li></ul></li><li>接口 多继承<ul><li>接口里定义的都是静态常量，方法都是抽象方法，没有逻辑实现。具体的方法必须由实现接口的类覆盖实现，在调用时始终只会调用实现类（也就是子类覆盖的方法）的方法，不会出现歧义（上面多继承的第二个缺点）。</li><li>接口中的变量都是静态成员常量（public static final），会在编译期就感知到错误，即使存在一定的引用不明确冲突也会在编译时提示错误，因此也不会导致歧义。</li><li>如果子接口继承的多个父接口中有相同的属性a，那么类在实现接口时是不能调用接口里面的属性a的，与类不能多继承原因一致，造成引用不明确。如果是不同的属性，实现类是可以调用的。</li><li>总结一下，接口可以继承多个父接口的相同的方法，不同的属性，不能继承多个父接口中相同的属性。</li></ul></li></ul></li><li>Java 有**自动内存管理垃圾回收机制(GC)**，不需要程序员手动释放无用内存。</li><li>C ++同时支持<strong>方法重载和操作符重载</strong>，但是 Java 只支持<strong>方法重载</strong>（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ul><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Java 中的注释有三种：</p><ol><li><strong>单行注释</strong> ：通常用于解释方法内某单行代码的作用。<code>//</code></li><li><strong>多行注释</strong> ：通常用于解释一段代码的作用。<code>/* */</code> </li><li><strong>文档注释</strong> ：通常用于生成 Java 开发文档。<code>/** */</code></li></ol><p>用的比较多的还是单行注释和文档注释，多行注释在实际开发中使用的相对较少。</p><p>在我们编写代码的时候，如果代码量比较少，我们自己或者团队其他成员还可以很轻易地看懂代码，但是当项目结构一旦复杂起来，我们就需要用到注释了。注释并不会执行(编译器在编译代码之前会把代码中的所有注释抹掉,字节码中不保留注释)，是我们程序员写给自己看的，注释是你的代码说明书，能够帮助看代码的人快速地理清代码之间的逻辑关系。因此，在写程序的时候随手加上注释是一个非常好的习惯。</p><p>《Clean Code》这本书明确指出：</p><blockquote><p><strong>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong></p><p><strong>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</strong></p></blockquote><h3 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h3><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。</p><p>有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 <strong>关键字</strong> 。简单来说，<strong>关键字是被赋予特殊含义的标识</strong>符 。比如，在我们的日常生活中，如果我们想要开一家店，则要给这个店起一个名字，起的这个“名字”就叫标识符。但是我们店的名字不能叫“警察局”，因为“警察局”这个名字已经被赋予了特殊的含义，而“警察局”就是我们日常生活中的关键字。</p><p><em><strong>规则：(必须要遵守。否则，编译不通过)</strong></em></p><ul><li>由26个英文字母大小写，0-9, _或$组成。</li><li>数字不可以开头。</li><li>不可以使用关键字和保留字，但能包含关键字和保留字。</li><li>Java中严格区分大小写，长度无限制。</li><li>标识符不能包含空格。</li></ul><p><em><strong>规范：（可以不遵守，不影响编译和运行。但是要求大家遵守）</strong></em></p><ul><li>包名：多单词组成时所有字母都小写：<code>xxxyyyzzz</code></li><li>类名、接口名：多单词组成时，所有单词的首字母大写： <code>XxxYyyZzz</code>(大驼峰式)</li><li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写： <code>xxxYyyZzz</code>(小驼峰式)</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接： <code>XXX_YYY_ZZZ</code></li></ul><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><table><thead><tr><th align="left">分类</th><th>关键字</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td align="left">访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td align="left">类，方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td align="left"></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td>enum</td></tr><tr><td align="left">程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td align="left"></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td>assert</td><td></td></tr><tr><td align="left">错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td align="left">包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="left">基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td align="left"></td><td>short</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="left">变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td align="left">保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><blockquote><p>Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。</p><p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p><ul><li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li><li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li><li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li></ul></blockquote><p>⚠️ 注意 ：虽然 <code>true</code>, <code>false</code>, 和 <code>null</code> 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。</p><h3 id="自增自减"><a href="#自增自减" class="headerlink" title="自增自减"></a>自增自减</h3><p>在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（–）。</p><p>++ 和 – 运算符可以放在变量之前，也可以放在变量之后，</p><ul><li>当运算符放在变量之前时(前缀)，先自增/减，再赋值；当 <code>b = ++a</code> 时，先自增（自己增加 1），再赋值（赋值给 b）；</li><li>当运算符放在变量之后时(后缀)，先赋值，再自增/减。当 <code>b = a++</code> 时，先赋值(赋值给 b)，再自增（自己增加 1）。</li><li>也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。</li></ul><h3 id="continue、break-和-return"><a href="#continue、break-和-return" class="headerlink" title="continue、break 和 return"></a>continue、break 和 return</h3><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。</p><p>但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p><ol><li><code>continue</code> ：指<strong>跳出当前的这一次循环</strong>，继续下一次循环。</li><li><code>break</code> ：指<strong>跳出整个循环体</strong>，继续执行循环下面的语句。</li></ol><p><code>return</code> 用于<strong>跳出所在方法，结束该方法的运行</strong>。return 一般有两种用法：</p><ol><li><code>return;</code> ：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li><code>return value;</code> ：return 一个特定值，用于有返回值函数的方法</li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h4><p>按数据类型分<br><a href="https://imgse.com/i/xlcLOe"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/10/05/xlcLOe.png" alt="xlcLOe.png"></a></p><p>按照声明位置分类</p><p><a href="https://imgse.com/i/xlcqyD"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/10/05/xlcqyD.png" alt="xlcqyD.png"></a></p><h4 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h4><ul><li><p><strong>语法形式</strong> ：</p><ul><li>成员变量是属于<strong>类</strong>的，成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，</li><li>局部变量是在<strong>代码块或方法中</strong>定义的变量或是<strong>方法的参数</strong>；而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；</li><li>成员变量和局部变量都能被 <code>final</code> 所修饰。</li></ul></li><li><p><strong>存储方式</strong> ：</p><ul><li>如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于<strong>类</strong>的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于<strong>实例</strong>的。</li><li>而<strong>对象存在于堆内存</strong>，<strong>局部变量则存在于栈内存</strong>。</li></ul></li><li><p><strong>生存时间</strong> ：</p><ul><li>成员变量是对象的一部分，它随着对象的创建而存在，</li><li>而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li></ul></li><li><p><strong>默认值</strong> ：</p><ul><li>成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），</li><li>而局部变量则不会自动赋值。</li></ul></li></ul><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，它们都共享同一份静态变量。</p><p>通常情况下，静态变量会被 <code>final</code> 关键字修饰成为常量。</p><h4 id="字符型常量-vs-字符串常量"><a href="#字符型常量-vs-字符串常量" class="headerlink" title="字符型常量 vs 字符串常量"></a>字符型常量 vs 字符串常量</h4><ol><li><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</li><li><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</li><li><strong>占内存大小</strong> ： 字符常量只占 2 个字节; 字符串常量占若干个字节。</li></ol><p>(<strong>注意： <code>char</code> 在 Java 中占两个字节</strong>)</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="方法的返回值-方法类型？"><a href="#方法的返回值-方法类型？" class="headerlink" title="方法的返回值?方法类型？"></a>方法的返回值?方法类型？</h4><p><strong>方法的返回值</strong> 是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！</p><p>我们可以按照方法的返回值和参数类型将方法分为下面这几种：</p><p><strong>1.无参数无返回值的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面这个方法也没有返回值，虽然用到了 return</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        <span class="comment">// 表示结束方法的执行,下方的输出语句不会执行</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.有参数无返回值的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(Parameter <span class="number">1</span>, ..., Parameter n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.有返回值无参数的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.有返回值有参数的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态方法不能调用非静态成员"><a href="#静态方法不能调用非静态成员" class="headerlink" title="静态方法不能调用非静态成员?"></a>静态方法不能调用非静态成员?</h4><p>这个需要结合 JVM 的相关知识，主要原因如下：</p><ol><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ol><h4 id="静态方法-vs-实例方法"><a href="#静态方法-vs-实例方法" class="headerlink" title="静态方法 vs 实例方法"></a>静态方法 vs 实例方法</h4><p><strong>1、调用方式</strong></p><p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p><p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p><p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staicMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 调用实例方法</span></span><br><span class="line">        person.method();</span><br><span class="line">        <span class="comment">// 调用静态方法</span></span><br><span class="line">        Person.staicMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、访问类成员是否存在限制</strong></p><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p><h4 id="重载-vs-重写"><a href="#重载-vs-重写" class="headerlink" title="重载 vs 重写"></a>重载 vs 重写</h4><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote><p><strong>重载</strong></p><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>《Java 核心技术》这本书是这样介绍重载的：</p><blockquote><p>如果多个方法(比如 <code>StringBuilder</code> 的构造方法)有相同的名字、不同的参数， 便产生了重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;HelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure><p>编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。</p><p>Java 允许重载任何方法， 而不只是构造器方法。</p></blockquote><p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p><p><strong>重写</strong></p><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p><table><thead><tr><th align="left">区别点</th><th align="left">重载方法</th><th align="left">重写方法</th></tr></thead><tbody><tr><td align="left">发生范围</td><td align="left">同一个类</td><td align="left">子类</td></tr><tr><td align="left">参数列表</td><td align="left">必须修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">返回类型</td><td align="left">可修改</td><td align="left">子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td align="left">异常</td><td align="left">可修改</td><td align="left">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td></tr><tr><td align="left">访问修饰符</td><td align="left">可修改</td><td align="left">一定不能做更严格的限制（可以降低限制）</td></tr><tr><td align="left">发生阶段</td><td align="left">编译期</td><td align="left">运行期</td></tr></tbody></table><p><strong>方法的重写要遵循“两同两小一大”</strong>（：</p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><p>⭐️ 关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;超级英雄&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">extends</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;超人&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hero <span class="title">hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hero();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperSuperMan</span> <span class="keyword">extends</span> <span class="title">SuperMan</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;超级超级英雄&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SuperMan <span class="title">hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SuperMan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h4><p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 <code>printVariable</code> 方法就可以接受 0 个或者多个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(String arg1, String... args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p><p>答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p><p>我们通过下面这个例子来证明一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VariableLengthArgument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printVariable</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : args) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printVariable</span><span class="params">(String arg1, String arg2)</span> </span>&#123;</span><br><span class="line">        System.out.println(arg1 + arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printVariable(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        printVariable(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">ab</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure><p>另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 <code>class</code>文件就可以看出来了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VariableLengthArgument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printVariable</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        String[] var1 = args;</span><br><span class="line">        <span class="keyword">int</span> var2 = args.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            String s = var1[var3];</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="基本数据类型-1"><a href="#基本数据类型-1" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Java 中有 8 种基本数据类型，分别为：</p><ul><li>6 种数字类型：<ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code>。</li></ul><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><table><thead><tr><th align="left">基本类型</th><th align="left">位数</th><th align="left">字节</th><th align="left">默认值</th><th>取值范围</th></tr></thead><tbody><tr><td align="left"><code>byte</code></td><td align="left">8</td><td align="left">1</td><td align="left">0</td><td>-128 ~ 127</td></tr><tr><td align="left"><code>short</code></td><td align="left">16</td><td align="left">2</td><td align="left">0</td><td>-32768 ~ 32767</td></tr><tr><td align="left"><code>int</code></td><td align="left">32</td><td align="left">4</td><td align="left">0</td><td>-2147483648 ~ 2147483647</td></tr><tr><td align="left"><code>long</code></td><td align="left">64</td><td align="left">8</td><td align="left">0L</td><td>-9223372036854775808 ~ 9223372036854775807</td></tr><tr><td align="left"><code>char</code></td><td align="left">16</td><td align="left">2</td><td align="left">‘u0000’</td><td>0 ~ 65535</td></tr><tr><td align="left"><code>float</code></td><td align="left">32</td><td align="left">4</td><td align="left">0f</td><td>1.4E-45 ~ 3.4028235E38</td></tr><tr><td align="left"><code>double</code></td><td align="left">64</td><td align="left">8</td><td align="left">0d</td><td>4.9E-324 ~ 1.7976931348623157E308</td></tr><tr><td align="left"><code>boolean</code></td><td align="left">1</td><td align="left"></td><td align="left">false</td><td>true、false</td></tr></tbody></table><p>对于 <code>boolean</code>，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p><p>另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。</p><p>这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一。</p><p><strong>注意：</strong></p><ol><li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li><li><code>char a = &#39;h&#39;</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号。</li></ol><p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p><p><strong>比特(bit)和字节(byte)</strong>  </p><p>在讨论内存前，先清楚数据是如何存储在计算机中的。</p><ul><li>计算机就是一系列的电路开关。每个开关存在两种状态：关(off)和开(on)。如果电路是开的，它的值是1。如果电路是关的，它的值是0。</li><li><strong>一个0或者一个1存储为一个比特(bit)，是计算机中最小的存储单位</strong>。</li><li>计算机中<strong>最基本的存储单元</strong>是字节(byte) 。 <strong>每个字节由8个比特构成</strong>。</li><li>计算机的存储能力是以字节和多字节来衡量的。如下：<ul><li>千字节(kilobyte,KB) = 1024B</li><li>兆字节(megabyte,MB) = 1024KB</li><li>千兆字节(gigabyte,GB) = 1024MB</li><li>万亿字节(terabyte,TB) = 1024GB  </li></ul></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>自动类型转换(只涉及7种基本数据类型）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> 、<span class="keyword">char</span> 、<span class="keyword">short</span> --&gt; <span class="keyword">int</span> --&gt; <span class="keyword">long</span> --&gt; <span class="keyword">float</span> --&gt; <span class="keyword">double</span></span><br></pre></td></tr></table></figure><blockquote><p>结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。</p><p>特别的：当byte、char、short三种类型的变量做运算时，结果为int型</p><p>说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量</p></blockquote><p>强制类型转换(只涉及7种基本数据类型）：自动类型提升运算的逆运算。需要使用强转符：<code>()</code></p><blockquote><p>注意点：强制类型转换，可能导致精度损失。</p></blockquote><p> <code>String</code> 与8种基本数据类型间的运算</p><ul><li>String属于引用数据类型，翻译为：字符串</li><li>声明String类型变量时，使用一对 <code>&quot;&quot;</code></li><li>String可以和8种基本数据类型变量做运算，且运算只能是连接运算：<code>+</code></li><li>运算的结果仍然是String类型</li></ul><h3 id="基本类型-vs-包装类型"><a href="#基本类型-vs-包装类型" class="headerlink" title="基本类型 vs 包装类型"></a>基本类型 vs 包装类型</h3><ul><li>成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li>包装类型可用于泛型，而基本类型不可以。</li><li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li>相比于对象类型， 基本数据类型占用的空间非常小。</li></ul><p><strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><p>⚠️ 注意 ： <strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p><h3 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p><strong>Integer 缓存源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Character</code> 缓存源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">      <span class="keyword">return</span> CharacterCache.cache[(<span class="keyword">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Character(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CharacterCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> Character[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> Character((<span class="keyword">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Boolean</code> 缓存源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">33</span>;</span><br><span class="line">Integer i2 = <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line">Float i11 = <span class="number">333f</span>;</span><br><span class="line">Float i22 = <span class="number">333f</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line">Double i3 = <span class="number">1.2</span>;</span><br><span class="line">Double i4 = <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure><p>下面我们来看一下问题。下面的代码的输出结果是 <code>true</code> 还是 <code>false</code> 呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p><p>因此，答案是 <code>false</code> 。你答对了吗？</p><p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p><p>说明·对于Integer var=？在-128至127之间的赋值，lnteger对象是在IntegerCache.cache产生， 会复用已有对象，这个区间内的lnteger值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。</p><h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p><strong>什么是自动拆装箱？</strong></p><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><p>上面这两行代码对应的字节码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">8</span> L1</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> BIPUSH <span class="number">10</span></span><br><span class="line"></span><br><span class="line"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">9</span> L2</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line"> RETURN</span><br></pre></td></tr></table></figure><p>从字节码中，我们发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p><p>因此，</p><ul><li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li><li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li></ul><p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 应该使用 long 而不是 Long</span></span><br><span class="line">    Long sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浮点数运算精度丢失风险"><a href="#浮点数运算精度丢失风险" class="headerlink" title="浮点数运算精度丢失风险"></a>浮点数运算精度丢失风险</h3><p>浮点数运算精度丢失代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">2.0f</span> - <span class="number">1.9f</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">1.8f</span> - <span class="number">1.7f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>为什么会出现这个问题呢？</p><p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p><p>就比如说十进制下的 0.2 就没办法精确转换成二进制小数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span></span><br><span class="line"><span class="comment">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span>（发生循环）</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="如何解决精度丢失问题"><a href="#如何解决精度丢失问题" class="headerlink" title="如何解决精度丢失问题"></a>如何解决精度丢失问题</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line">BigDecimal x = a.subtract(b);</span><br><span class="line">BigDecimal y = b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure><h3 id="超过-long-整型的数据"><a href="#超过-long-整型的数据" class="headerlink" title="超过 long 整型的数据"></a>超过 long 整型的数据</h3><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p><p>在 Java 中，64 位 long 整型是最大的整数类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> l = Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p><p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组(Array)，是多个相同类型数据一定顺序排列的集合，并使用一个名字命名，并通过编号的 方式对这些数据进行统一管理。</p><h3 id="数组的特点"><a href="#数组的特点" class="headerlink" title="数组的特点"></a>数组的特点</h3><ol><li>数组是序排列的</li><li>数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型</li><li>创建数组对象会在内存中开辟<strong>一整块连续的空间</strong></li><li><strong>数组的长度一旦确定，就不能修改</strong>。</li></ol><h3 id="数组元素的默认初始化值"><a href="#数组元素的默认初始化值" class="headerlink" title="数组元素的默认初始化值"></a>数组元素的默认初始化值</h3><ul><li>数组元素是整型：<code>0</code></li><li>数组元素是浮点型：<code>0.0</code></li><li>数组元素是char型：<code>0</code>或<code>&#39;\u0000&#39;</code>，而非’0’</li><li>数组元素是boolean型：<code>false</code></li><li>数组元素是引用数据类型：<code>null</code></li></ul><h3 id="一维数组内存解析"><a href="#一维数组内存解析" class="headerlink" title="一维数组内存解析"></a>一维数组内存解析</h3><p><a href="https://imgse.com/i/xlcjwd"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/10/05/xlcjwd.png" alt="xlcjwd.png"></a></p><h3 id="二维数组内存解析"><a href="#二维数组内存解析" class="headerlink" title="二维数组内存解析"></a>二维数组内存解析</h3><p><a href="https://imgse.com/i/xlcvTA"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/10/05/xlcvTA.png" alt="xlcvTA.png"></a></p><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="面向对象-vs-面向过程"><a href="#面向对象-vs-面向过程" class="headerlink" title="面向对象 vs 面向过程"></a>面向对象 vs 面向过程</h3><p>两者的主要区别在于解决问题的方式不同：</p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p><p><strong>类</strong>：对一类事物的描述，是<strong>抽象的</strong>、<strong>概念上</strong>的定义</p><p><strong>对象</strong>：是实际存在的该类事物的每个个体，因而也称为<strong>实例(instance)</strong></p><p>面向对象程序设计的重点是<strong>类的设计</strong>，设计类就是设计类的成员。<strong>对象，是由类new出来的，派生出来的。</strong></p><p><strong>面向对象思想实现的规则</strong></p><ol><li>创建类，设计类的成员</li><li>创建类的对象</li><li>通过<code>对象.属性</code> 或 <code>对象.方法</code>调用对象的结构</li></ol><p>补充：几个概念的使用说明</p><ul><li><strong>属性</strong> = <strong>成员变量</strong> = <strong>field</strong> = <strong>域、字段</strong></li><li><strong>方法</strong> = <strong>成员方法</strong> = <strong>函数</strong> = <strong>method</strong></li><li><strong>创建类的对象</strong> = <strong>类的实例化</strong> = <strong>实例化类</strong></li></ul><h3 id="常用关键字"><a href="#常用关键字" class="headerlink" title="常用关键字"></a>常用关键字</h3><h4 id="this–本类的"><a href="#this–本类的" class="headerlink" title="this–本类的"></a>this–本类的</h4><p>this理解为：<strong>当前对象或当前正在创建的对象</strong>，可以调用的结构：<em><strong>属性、方法；构造器</strong></em></p><ul><li>在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是，通常情况下，我们都择省略”this.”。特殊情况下，如果<em><strong>方法的形参和类的属性同名时</strong></em>，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li><li>在类的构造器中，我们可以使用”this.属性”或”this.方法”的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都择省略”this.”。特殊情况下，如果<em><strong>构造器的形参和类的属性同名</strong></em>时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li></ul><ul><li>this调用构造器：<ul><li>我们在类的构造器中，可以显式的使用***”this(形参列表)”***方式，调用本类中指定的其他构造器</li><li>构造器中不能通过”this(形参列表)”方式调用自己</li><li>如果一个类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)”</li><li>规定：”this(形参列表)”<em><strong>必须声明在当前构造器的首行</strong></em></li><li>**构造器内部，最多只能声明一个”this(形参列表)”**，用来调用其他的构造器</li></ul></li></ul><h4 id="super–父类的"><a href="#super–父类的" class="headerlink" title="super–父类的"></a>super–父类的</h4><p>super 关键字可以理解为：父类的，可以用来调用的结构：<em><strong>属性、方法、构造器</strong></em></p><ul><li>尤其当子父类出现同名成员时，可以用supe表明调用的是父类中的成员</li><li>super的追溯不仅限于直接父类</li><li>super和this的用法相像，this代表本类对象的引用， super代表父类的内存空间的标识</li></ul><p><strong>通过使用”super.属性”或”super.方法”的方式，显式的调用父类中声明的属性或方法。</strong>但是，通常情况下，我们习惯省略”super.”</p><p><strong>特殊情况</strong></p><ul><li>当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。</li><li>当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。</li></ul><p><strong>super调用构造器：</strong></p><ul><li>我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</li><li>“super(形参列表)”的使用，必须声明在子类构造器的首行！</li><li>我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现</li><li>在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super()</li><li>在类的多个构造器中，至少一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</li></ul><p><strong>this与super的区别</strong></p><table><thead><tr><th>区别点</th><th>this</th><th>super</th></tr></thead><tbody><tr><td>访问属性</td><td>访问本类中的属性，如果本类没有此属性则从父类中继续查找</td><td>直接访问父类中的属性</td></tr><tr><td>调用方法</td><td>访问本类中的方法，如果本类没有此方法则从父类中继续查找</td><td>直接访问父类中的方法</td></tr><tr><td>调用构造器</td><td>调用本类构造器，必须放在构造器的首行</td><td>调用父类构造器，必须放在子类构造器的首行</td></tr></tbody></table><h4 id="package-import"><a href="#package-import" class="headerlink" title="package/import"></a>package/import</h4><h5 id="package关键字"><a href="#package关键字" class="headerlink" title="package关键字"></a>package关键字</h5><ol><li>为了更好的实现项目中类的管理，提供包的概念</li><li>使用package声明类或接口所属的包，声明在源文件的首行</li><li>包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”</li><li>每”.”一次，就代表一层文件目录。</li></ol><h5 id="import的使用"><a href="#import的使用" class="headerlink" title="import的使用"></a>import的使用</h5><ol><li>在源文件中显式的使用import结构<strong>导入</strong>指定包下的类、接口</li><li>声明在包的声明和类的声明之间</li><li>如果需要导入多个结构，则并列写出即可</li><li>可以使用”<code>xxx.*</code>“的方式，表示可以导入xxx包下的所结构</li><li>如果使用的类或接口是java.lang包下定义的，则可以省略import结构</li><li>如果使用的类或接口是本包下定义的，则可以省略import结构</li><li>如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。</li><li>使用”xxx.*”方式表明可以调用xxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入</li><li>import static:导入指定类或接口中的静态结构:属性或方法。</li></ol><h4 id="static–静态的"><a href="#static–静态的" class="headerlink" title="static–静态的"></a>static–静态的</h4><p>主要用来修饰类的内部结构，如：属性、方法、代码块、内部类</p><p><strong>static修饰属性：静态变量（或类变量）</strong></p><p>属性是否使用static修饰，可分为：静态属性 vs 非静态属性(实例变量)</p><ul><li>实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</li><li>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</li></ul><p><strong>static修饰属性的其他说明：</strong></p><ul><li>静态变量随着类的加载而加载。可以通过”类.静态变量”的方式进行调用</li><li>静态变量的加载要早于对象的创建。</li><li>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</li></ul><table><thead><tr><th></th><th>类变量</th><th>实例变量</th></tr></thead><tbody><tr><td>类</td><td>yes</td><td>no</td></tr><tr><td>对象</td><td>yes</td><td>yes</td></tr></tbody></table><p><strong>静态属性举例：System.out; Math.PI;</strong></p><p><strong>static修饰方法：静态方法、类方法</strong></p><ul><li>随着类的加载而加载，可以通过”类.静态方法”的方式进行调用</li><li>静态方法中，只能调用静态的方法或属性</li><li>非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</li></ul><table><thead><tr><th></th><th>静态方法</th><th>非静态方法</th></tr></thead><tbody><tr><td>类</td><td>yes</td><td>no</td></tr><tr><td>对象</td><td>yes</td><td>yes</td></tr></tbody></table><p><strong>使用的注意点：</strong></p><ul><li><strong>在静态的方法内，不能使用this关键字、super关键字</strong></li><li>关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。（静态结构–类，非静态结构–对象）</li></ul><p><strong>如何判定属性和方法应该使用static关键字：</strong></p><p><strong>关于属性：</strong></p><ul><li>属性是可以被多个对象所共享的，不会随着对象的不同而不同的。</li><li>类中的常量也常常声明为static</li></ul><p><strong>关于方法：</strong></p><ul><li>操作静态属性的方法，通常设置为static的</li><li>工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections</li></ul><h4 id="final–最终的"><a href="#final–最终的" class="headerlink" title="final–最终的"></a>final–最终的</h4><p><strong>可以用来修饰：类、方法、变量</strong></p><ol><li><p>final 用来修饰一个类:<strong>此类不能被其他类所继承。</strong></p><p>比如：String类、System类、StringBuffer类</p></li><li><p>final 用来修饰方法：<strong>表明此方法不可以被重写</strong></p><p>比如：Object类中getClass();</p></li><li><p>final 用来修饰变量：<strong>此时的”变量”就称为是一个常量</strong></p><ul><li>final修饰属性：可以考虑赋值的位置：<strong>显式初始化、代码块中初始化、构造器中初始化</strong></li><li>final修饰局部变量：<strong>尤其是使用final修饰形参时，表明此形参是一个常量</strong>。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</li></ul></li><li><p>static final 用来修饰属性：<strong>全局常量</strong></p></li></ol><h4 id="abstract–抽象的"><a href="#abstract–抽象的" class="headerlink" title="abstract–抽象的"></a>abstract–抽象的</h4><p>abstract: 抽象的，可以用来修饰：类、方法</p><p><strong>abstract修饰类：抽象类</strong></p><ul><li>此类<strong>不能实例化</strong></li><li>抽象类中<strong>一定有构造器</strong>，便于<strong>子类实例化时调用</strong>（涉及：子类对象实例化的全过程）</li><li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 —&gt;抽象的使用前提：继承性</li></ul><p><strong>abstract修饰方法：抽象方法</strong></p><ul><li>抽象方法只有方法的声明，<strong>没方法体</strong></li><li><strong>包含抽象方法的类，一定是一个抽象类</strong>。反之，抽象类中可以没有抽象方法的。</li><li>若子类重写了父类中的<strong>所有抽象方法</strong>后，此子类方可实例化</li><li>若子类没重写父类中的<strong>所有抽象方法</strong>，则此子类也是一个抽象类，需要使用abstract修饰</li></ul><p><strong>注意点：</strong></p><ul><li>abstract不能用来修饰：属性、构造器等结构</li><li>abstract不能用来修饰私有方法、静态方法（静态方法不能被重写，抽象方法不能调用）、final的方法、final的类</li></ul><h4 id="interface–接口"><a href="#interface–接口" class="headerlink" title="interface–接口"></a>interface–接口</h4><p>接口使用interface来定义；Java中，接口和类是并列的两个结构</p><h5 id="interface关键字使用"><a href="#interface关键字使用" class="headerlink" title="interface关键字使用"></a>interface关键字使用</h5><ol><li><p>如何定义接口：定义接口中的成员</p><ul><li>JDK7及以前：只能定义全局常量（public static final，书写时可以省略）和抽象方法（public abstract）</li><li>JDK8:除了定义全局常量和抽象方法，还可以定义静态方法、默认方法</li></ul></li><li><p><strong>接口中不能定义构造器</strong>的！意味着<strong>接口不可以实例化</strong></p></li><li><p>Java开发中，接口通过让类去实现(<strong>implements</strong>)的方式来使用.</p><ul><li>如果实现类覆盖了接口中的抽象方法，则此实现类就可以实例化</li><li>如果实现类没覆盖接口中的抽象方法，则此实现类仍为一个抽象类</li></ul></li><li><p>Java类可以<strong>实现多个接口</strong> —&gt;弥补了Java单继承性的局限性</p><p>格式：class AA extends BB implements CC,DD,EE</p></li><li><p>接口与接口之间可以继承，而且可以多继承</p></li><li><p>接口的具体使用，体现多态性</p></li><li><p><strong>接口，实际上可以看做是一种规范</strong></p></li></ol><p><strong>使用举例</strong>：不同的设备通过USB口接入电脑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        Flash flash = <span class="keyword">new</span> Flash();</span><br><span class="line">        computer.transferData(flash);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferData</span><span class="params">(USB usb)</span></span>&#123;<span class="comment">//USB usb = new Flash();</span></span><br><span class="line">usb.start();</span><br><span class="line">System.out.println(<span class="string">&quot;具体传输数据的细节&quot;</span>);</span><br><span class="line">usb.stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"><span class="comment">//常量：定义了长、宽、最大最小的传输速度等</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flash</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U盘开启工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U盘结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机开启工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用总结</strong></p><ol><li>接口使用上也满足多态性</li><li>接口，实际上就是定义了一种规范</li><li>开发中，体会面向接口编程！</li></ol><h5 id="Java8中关于接口的新规范"><a href="#Java8中关于接口的新规范" class="headerlink" title="Java8中关于接口的新规范"></a>Java8中关于接口的新规范</h5><ul><li><p>Java8中，可以为接口添加<strong>静态方法</strong>和<strong>默认方法</strong>。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。</p></li><li><p>静态方法：使用 <strong>static</strong>关键字修饰。</p><p><strong>可以通过接口直接调用静态方法</strong>，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像 Collection/Collections 或者 Path/Paths这样成对的接口和类。</p></li><li><p>默认方法：默认方法使用 <strong>default</strong>关键字修饰。</p></li><li><p>可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性比如：java8 API中对 Collection、List、 Comparator等接口提供了丰富的默认方法。</p></li></ul><p><strong>JDK 8后接口使用总结</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubClass s = <span class="keyword">new</span> SubClass();</span><br><span class="line"><span class="comment">//        s.method1();</span></span><br><span class="line"><span class="comment">//        1.接口中定义的静态方法，只能通过接口来调用。</span></span><br><span class="line">        CompareA.method1();</span><br><span class="line"><span class="comment">//        2.通过实现类的对象，可以调用接口中的默认方法。</span></span><br><span class="line"><span class="comment">//        如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</span></span><br><span class="line">        s.method2();</span><br><span class="line"><span class="comment">//        3.如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，</span></span><br><span class="line"><span class="comment">//        那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。--&gt;类优先原则</span></span><br><span class="line"><span class="comment">//        4.如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</span></span><br><span class="line"><span class="comment">//        那么在实现类没重写此方法的情况下，报错。--&gt;接口冲突。</span></span><br><span class="line"><span class="comment">//        这就需要我们必须在实现类中重写此方法</span></span><br><span class="line">        s.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span>  <span class="keyword">extends</span> <span class="title">SuperClass</span> <span class="keyword">implements</span> <span class="title">CompareA</span>,<span class="title">CompareB</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass:上海&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass:深圳&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    如何在子类(或实现类)的方法中调用父类、接口中被重写的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        method3();<span class="comment">//调用自己定义的重写的方法</span></span><br><span class="line">        <span class="keyword">super</span>.method3();<span class="comment">//调用的是父类中声明的</span></span><br><span class="line">        <span class="comment">//调用接口中的默认方法</span></span><br><span class="line">        CompareA.<span class="keyword">super</span>.method3();</span><br><span class="line">        CompareB.<span class="keyword">super</span>.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompareA</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CompareA:北京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CompareA:上海&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CompareA:上海&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompareB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CompareB:上海&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass:北京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h3><p><strong>共同点</strong> ：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong> ：</p><ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ul><h3 id="创建对象-对象实体-对象引用"><a href="#创建对象-对象实体-对象引用" class="headerlink" title="创建对象?对象实体/对象引用?"></a>创建对象?对象实体/对象引用?</h3><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p><p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;</p><p>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p><blockquote><p>对象的相等 vs 引用相等</p></blockquote><ul><li>对象的相等一般比较的是内存中存放的内容是否相等。</li><li>引用相等一般比较的是他们指向的内存地址是否相等。</li></ul><h3 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h3><p>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</p><blockquote><p>如果一个类没有声明构造方法，该程序能正确执行吗?</p></blockquote><p>如果一个类没有声明构造方法，也可以执行！</p><p>因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><p>如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。</p><p>如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p><blockquote><p>构造方法有哪些特点？是否可被 override?</p></blockquote><p>构造方法特点如下：</p><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><p>构造方法<strong>不能被 override（重写）,但是可以 overload（重载）</strong>,所以你可以看到一个类中有多个构造函数的情况。</p><h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。</p><p>但是可以提供一些可以被外界访问的方法来操作属性。</p><p>就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。</p><p>如果属性不想被外界访问，我们大可不必提供方法给外界访问。</p><p>但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><p>就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//id属性私有化</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//name属性私有化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取id的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置id的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取name的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置name的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对不同的方法属性设置不同的权限修饰符来达到对类进行封装的目的。</p><ul><li>权限从小到大顺序为：private &lt; 缺省 &lt; protected &lt; public</li><li>具体的修饰范围：</li></ul><table><thead><tr><th>修饰符</th><th>类内部</th><th>同一个包</th><th>不同包的子类</th><th>同一个工程</th></tr></thead><tbody><tr><td>private</td><td>Yes</td><td></td><td></td><td></td></tr><tr><td>（缺省）</td><td>Yes</td><td>Yes</td><td></td><td></td></tr><tr><td>protected</td><td>Yes</td><td>Yes</td><td>Yes</td><td></td></tr><tr><td>public</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr></tbody></table><p><strong>权限修饰符可用来修饰的结构说明</strong>：</p><ul><li>4种权限都可以用来修饰<strong>类的内部结构</strong>：属性、方法、构造器、内部类</li><li><strong>修饰类</strong>，只能使用：缺省、public</li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。</p><p>例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。</p><p>同时，每一个对象还定义了额外的特性使得他们与众不同。</p><p>例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。</p><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</p><p>通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ol><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p>编译时和运行时类型不一致，产生了多态</p><p><strong>代码举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Man();</span><br><span class="line">Object obj = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure><ul><li>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</li><li>总结：编译，看左边；运行，看右边。</li><li>对象的多态：在Java中，子类的对象可以替代父类的对象使用<ul><li>一个变量只能有一种确定的数据类型</li><li>一个引用类型变量可能指向（引用）多种不同类型的对象</li></ul></li></ul><p><strong>多态性的使用前提：</strong></p><p>① 类的继承关系 ② 方法的重写</p><p><strong>多态的特点:</strong></p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><h3 id="深拷贝、浅拷贝、引用拷贝"><a href="#深拷贝、浅拷贝、引用拷贝" class="headerlink" title="深拷贝、浅拷贝、引用拷贝"></a>深拷贝、浅拷贝、引用拷贝</h3><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p><ul><li><strong>浅拷贝</strong>：<strong>浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点）</strong>，不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong> ：<strong>深拷贝会完全复制整个对象，包括这个对象所包含的内部对象</strong>。</li></ul><p>上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！</p><p><strong>浅拷贝</strong></p><p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p><p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Address <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Person person = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = <span class="keyword">new</span> Person(<span class="keyword">new</span> Address(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line">Person person1Copy = person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure><p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p><p><strong>深拷贝</strong></p><p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Person person = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = <span class="keyword">new</span> Person(<span class="keyword">new</span> Address(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line">Person person1Copy = person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure><p>从输出结构就可以看出，虽然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p><p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p><p>我专门画了一张图来描述浅拷贝、深拷贝、引用拷贝：</p><p><a href="https://imgse.com/i/xlA1ln"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/10/04/xlA1ln.png" alt="xlA1ln.png"></a></p><h2 id="Java-常见类"><a href="#Java-常见类" class="headerlink" title="Java 常见类"></a>Java 常见类</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="Object-类的常见方法"><a href="#Object-类的常见方法" class="headerlink" title="Object 类的常见方法"></a>Object 类的常见方法</h4><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 实例被垃圾回收器回收的时候触发的操作</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="和-equals"><a href="#和-equals" class="headerlink" title="== 和 equals()"></a>== 和 equals()</h4><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li></ul><blockquote><p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></blockquote><p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p><p><code>Object</code> 类 <code>equals()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li><strong>类没有重写 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><p>举个例子（这里只是为了举例。实际上，你按照下面这种写法的话，像 IDEA 这种比较智能的 IDE 都会提示你将 <code>==</code> 换成 <code>equals()</code> ）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">System.out.println(aa == bb);<span class="comment">// true</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="number">42</span> == <span class="number">42.0</span>);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p><p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p><p><code>String</code>类<code>equals()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h4><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p><code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p><h5 id="为什么要有-hashCode？"><a href="#为什么要有-hashCode？" class="headerlink" title="为什么要有 hashCode？"></a>为什么要有 hashCode？</h5><p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 <code>hashCode</code>？</p><p>下面这段内容摘自我的 Java 启蒙书《Head First Java》:</p><blockquote><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p></blockquote><p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p><p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p><p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p><p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></p><p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p><p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p><p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><p>总结下来就是 ：</p><ul><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象<strong>不一定相等（哈希碰撞）</strong>。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li></ul><p>相信大家看了我前面对 <code>hashCode()</code> 和 <code>equals()</code> 的介绍之后，下面这个问题已经难不倒你们了。</p><h5 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h5><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p><strong>思考</strong> ：重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</p><p><strong>总结</strong> ：</p><ul><li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li><li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h4><p><strong>可变性</strong></p><p><code>String</code> 是不可变的。</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程安全性</strong></p><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，<strong>线程安全</strong>。</p><p><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。</p><p><code>StringBuffer</code> 对方法加了<strong>同步锁或者对调用的方法加了同步锁</strong>，所以是<strong>线程安全</strong>的。</p><p><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是<strong>非线程安全</strong>的。</p><p><strong>性能</strong></p><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。</p><p><code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。</p><p>相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ol><li>操作<strong>少量</strong>的数据: 适用 <code>String</code></li><li><strong>单线程</strong>操作字符串缓冲区下操作<strong>大量</strong>数据: 适用 <code>StringBuilder</code></li><li><strong>多线程</strong>操作字符串缓冲区下操作<strong>大量</strong>数据: 适用 <code>StringBuffer</code></li></ol><h4 id="String-为什么不可变"><a href="#String-为什么不可变" class="headerlink" title="String 为什么不可变"></a>String 为什么不可变</h4><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。</p><p>因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p><p><code>String</code> 真正不可变有下面几点原因：</p><ol><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li></ol><p>在 Java 9 之后，<code>String</code> 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 <code>byte</code> 数组存储字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,<span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 9 为何要将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> ?</strong></p><p>新版的 String 其实支持两个编码方案： Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p><p>JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。</p><p>如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，<code>byte</code> 和 <code>char</code> 所占用的空间是一样的。</p><h4 id="字符串拼接-“-”-vs-StringBuilder"><a href="#字符串拼接-“-”-vs-StringBuilder" class="headerlink" title="字符串拼接 “+” vs StringBuilder"></a>字符串拼接 “+” vs StringBuilder</h4><p>Java 语言本身并不支持运算符重载，<strong>“+”和“+=”是专门为 String 类重载过的运算符</strong>，也是 Java 中仅有的两个重载过的运算符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;he&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;llo&quot;</span>;</span><br><span class="line">String str3 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">String str4 = str1 + str2 + str3;</span><br></pre></td></tr></table></figure><p>字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    s += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><p><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 <code>StringBuilder</code> 对象。</p><p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (String value : arr) &#123;</span><br><span class="line">    s.append(value);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><p>如果你使用 IDEA 的话，IDEA 自带的代码检查机制也会提示你修改代码。</p><h4 id="String-equals-vs-Object-equals"><a href="#String-equals-vs-Object-equals" class="headerlink" title="String equals() vs Object equals()"></a>String equals() vs Object equals()</h4><p><code>String</code> 中的 <code>equals</code> 方法是被<strong>重写</strong>过的，比较的是 <strong>String 字符串的值是否相等</strong>。 </p><p><code>Object</code> 的 <code>equals</code> 方法是比较的<strong>对象的内存地址</strong>。</p><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line">String aa = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line">String bb = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 = new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 = new String(“abc”);这句话创建了几个字符串对象？</h4><p>会创建 1 或 2 个字符串对象。</p><p>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 2 个字符串对象“abc”。</p><p>示例代码（JDK 1.8）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><p>对应的字节码：<br><a href="https://imgse.com/i/xlgCSf"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/10/05/xlgCSf.png" alt="xlgCSf.png"></a></p><p><code>ldc</code> 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。</p><p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p><p>示例代码（JDK 1.8）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串常量池中已存在字符串对象“abc”的引用</span></span><br><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">// 下面这段代码只会在堆中创建 1 个字符串对象“abc”</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><p>对应的字节码：</p><p><a href="https://imgse.com/i/xlgpfP"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/10/05/xlgpfP.png" alt="xlgpfP.png"></a></p><p>这里就不对上面的字节码进行详细注释了，7 这个位置的 <code>ldc</code> 命令不会在堆中创建新的字符串对象“abc”，这是因为 0 这个位置已经执行了一次 <code>ldc</code> 命令，已经在堆中创建过一次字符串对象“abc”了。7 这个位置执行 <code>ldc</code> 命令会直接返回字符串常量池中字符串对象“abc”对应的引用。</p><h4 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern 方法"></a>intern 方法</h4><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p><ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li></ul><p>示例代码（JDK 1.8） :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”Java“</span></span><br><span class="line"><span class="comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span></span><br><span class="line">String s1 = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line">String s2 = s1.intern();</span><br><span class="line"><span class="comment">// 会在堆中在单独创建一个字符串对象</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line">String s4 = s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 和 s4 指向的是堆中不同的对象</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="String-类型的变量和常量做“-”运算时发生了什么？"><a href="#String-类型的变量和常量做“-”运算时发生了什么？" class="headerlink" title="String 类型的变量和常量做“+”运算时发生了什么？"></a>String 类型的变量和常量做“+”运算时发生了什么？</h4><p>先来看字符串不加 <code>final</code> 关键字拼接的情况（JDK1.8）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">String str3 = <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">String str4 = str1 + str2;</span><br><span class="line">String str5 = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> ：比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 <code>String</code> 中的 <code>equals</code> 方法是被重写过的。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是字符串的值是否相等。如果你使用 <code>==</code> 比较两个字符串是否相等的话，IDEA 还是提示你使用 <code>equals()</code> 方法替换。</p></blockquote><p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p><p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。</p><p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p><p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p><p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p><ul><li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li><li><code>final</code> 修饰的基本数据类型和字符串变量</li><li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li></ul><p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p><p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str4 = <span class="keyword">new</span> StringBuilder().append(str1).append(str2).toString();</span><br></pre></td></tr></table></figure><p>我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p><p>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String str1 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String str2 = <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line">String c = <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line">String d = str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p><p>如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。</p><p>示例代码（<code>str2</code> 在运行时才能确定其值）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String str1 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String str2 = getStr();</span><br><span class="line">String c = <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line">String d = str1 + str2; <span class="comment">// 在堆上创建的新的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>Java 异常类层次结构图概览</strong> ：</p><p><a href="https://imgse.com/i/xlgi6S"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/10/05/xlgi6S.png" alt="xlgi6S.png"></a></p><h3 id="Exception-vs-Error"><a href="#Exception-vs-Error" class="headerlink" title="Exception vs Error"></a>Exception vs Error</h3><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h3 id="Checked-Exception-vs-Unchecked-Exception"><a href="#Checked-Exception-vs-Unchecked-Exception" class="headerlink" title="Checked Exception vs Unchecked Exception"></a>Checked Exception vs Unchecked Exception</h3><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…。</p><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li><li>……</li></ul><h3 id="Throwable-类常用方法"><a href="#Throwable-类常用方法" class="headerlink" title="Throwable 类常用方法"></a>Throwable 类常用方法</h3><ul><li><code>String getMessage()</code>: 返回异常发生时的简要描述</li><li><code>String toString()</code>: 返回异常发生时的详细信息</li><li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li><li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><ul><li><code>try</code>块 ： 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><code>catch</code>块 ： 用于处理 try 捕获到的异常。</li><li><code>finally</code> 块 ： 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将<strong>在方法返回之前被执行</strong>。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Try to do something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br><span class="line">Finally</span><br></pre></td></tr></table></figure><p><strong>注意：不要在 finally 语句块中使用 return!</strong> </p><p>当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p><h3 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a>finally 中的代码一定会执行吗？</h3><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p><p>就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 终止当前正在运行的Java虚拟机</span></span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Try to do something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br></pre></td></tr></table></figure><p>另外，在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p><ol><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><ol><li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li><li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li></ol><p>《Effective Java》中明确指出：</p><blockquote><p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p></blockquote><p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code> 、<code>Scanner</code> 、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line">Scanner scanner = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p><p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedInputStream bin = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">     BufferedOutputStream bout = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bout.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常使用需要注意的地方？"><a href="#异常使用需要注意的地方？" class="headerlink" title="异常使用需要注意的地方？"></a>异常使用需要注意的地方？</h3><ul><li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li><li>抛出的异常信息一定要有意义。</li><li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li><li>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。</li><li>……</li></ul><h3 id="throw-和-throws区别"><a href="#throw-和-throws区别" class="headerlink" title="throw 和 throws区别"></a><code>throw</code> 和 <code>throws</code>区别</h3><p><code>throw</code> 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。 <code>throws</code> 属于异常处理的一种方式，声明在方法的声明处。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="什么是泛型？有什么作用？"><a href="#什么是泛型？有什么作用？" class="headerlink" title="什么是泛型？有什么作用？"></a>什么是泛型？有什么作用？</h3><p><strong>Java 泛型（Generics）</strong> 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</p><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。</p><p>使用泛型的主要优点在于<strong>能够在编译时而不是在运行时检测错误</strong>。</p><p>比如 <code>ArrayList&lt;Persion&gt; persons = new ArrayList&lt;Persion&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Persion</code> 对象，如果传入其他类型的对象就会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br></pre></td></tr></table></figure><p>并且，原生 <code>List</code> 返回类型是 <code>Object</code> ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p><h3 id="泛型的使用方式有哪几种？"><a href="#泛型的使用方式有哪几种？" class="headerlink" title="泛型的使用方式有哪几种？"></a>泛型的使用方式有哪几种？</h3><p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p><p><strong>1.泛型类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实例化泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure><p><strong>2.泛型接口</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，不指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.泛型方法</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">( E[] inputArray )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">        System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure><blockquote><p>注意: <code>public static &lt; E &gt; void printArray( E[] inputArray )</code> 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code></p></blockquote><h3 id="项目中哪里用到了泛型？"><a href="#项目中哪里用到了泛型？" class="headerlink" title="项目中哪里用到了泛型？"></a>项目中哪里用到了泛型？</h3><ul><li>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</li><li>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 <code>Excel</code> 导出的数据类型</li><li>构建集合工具类（参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法）。</li><li>……</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="何谓反射？"><a href="#何谓反射？" class="headerlink" title="何谓反射？"></a>何谓反射？</h3><p>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。反射之所以被称为框架的灵魂，主要是因为它赋予了我们<strong>在运行时分析类以及执行类中方法的能力</strong>。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p><h3 id="反射的优缺点？"><a href="#反射的优缺点？" class="headerlink" title="反射的优缺点？"></a>反射的优缺点？</h3><p>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p><p>不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p><h3 id="反射的应用场景？"><a href="#反射的应用场景？" class="headerlink" title="反射的应用场景？"></a>反射的应用场景？</h3><p>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是！这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。<strong>像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制</strong>。</p><p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p><p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DebugInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p><p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p><p>这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="何谓注解？"><a href="#何谓注解？" class="headerlink" title="何谓注解？"></a>何谓注解？</h3><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p><p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Override</span> <span class="keyword">extends</span> <span class="title">Annotation</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p><h3 id="注解的解析方法有哪几种？"><a href="#注解的解析方法有哪几种？" class="headerlink" title="注解的解析方法有哪几种？"></a>注解的解析方法有哪几种？</h3><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li></ul><h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><h3 id="何谓-SPI"><a href="#何谓-SPI" class="headerlink" title="何谓 SPI?"></a>何谓 SPI?</h3><p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：<strong>专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口</strong>。</p><p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p><p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p><h3 id="SPI-和-API-有什么区别？"><a href="#SPI-和-API-有什么区别？" class="headerlink" title="SPI 和 API 有什么区别？"></a>SPI 和 API 有什么区别？</h3><p><strong>那 SPI 和 API 有啥区别？</strong></p><p>说到 SPI 就不得不说一下 API 了，从广义上来说它们都属于接口，而且很容易混淆。</p><p>一般模块之间都是通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p><p>当<strong>实现方提供了接口和实现</strong>，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。</p><p>当<strong>接口存在于调用方这边时</strong>，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根绝这个规则对这个接口进行实现，从而提供服务。</p><p>举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。</p><h3 id="SPI-的优缺点？"><a href="#SPI-的优缺点？" class="headerlink" title="SPI 的优缺点？"></a>SPI 的优缺点？</h3><p>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：</p><ul><li>需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。</li><li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时，会有并发问题。</li></ul><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="序列化-反序列化"><a href="#序列化-反序列化" class="headerlink" title="序列化/反序列化"></a>序列化/反序列化</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><p>简单来说：</p><ul><li><strong>序列化</strong>： 将<strong>数据结构或对象转换成二进制字节流</strong>的过程</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p><p>维基百科是如是介绍序列化的：</p><blockquote><p><strong>序列化</strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p></blockquote><p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><p><a href="https://imgse.com/i/xlomtg"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/10/05/xlomtg.png" alt="xlomtg.png"></a></p><h3 id="如果有些字段不想进行序列化怎么办？"><a href="#如果有些字段不想进行序列化怎么办？" class="headerlink" title="如果有些字段不想进行序列化怎么办？"></a>如果有些字段不想进行序列化怎么办？</h3><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h3 id="Java-IO-流了解吗？"><a href="#Java-IO-流了解吗？" class="headerlink" title="Java IO 流了解吗？"></a>Java IO 流了解吗？</h3><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是<strong>字节</strong>输入流，后者是<strong>字符</strong>输入流。</li><li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><h3 id="I-O-流为什么要分为字节流和字符流呢"><a href="#I-O-流为什么要分为字节流和字符流呢" class="headerlink" title="I/O 流为什么要分为字节流和字符流呢?"></a>I/O 流为什么要分为字节流和字符流呢?</h3><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>个人认为主要有两点原因：</p><ul><li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时；</li><li>如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。</li></ul><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><h3 id="什么是语法糖？"><a href="#什么是语法糖？" class="headerlink" title="什么是语法糖？"></a>什么是语法糖？</h3><p><strong>语法糖（Syntactic sugar）</strong> 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p><p>举个例子，Java 中的 <code>for-each</code> 就是一个常用的语法糖，其原理其实就是基于普通的 for 循环和迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] strs = &#123;<span class="string">&quot;JavaGuide&quot;</span>, <span class="string">&quot;公众号：JavaGuide&quot;</span>, <span class="string">&quot;博客：https://javaguide.cn/&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成 JVM 认识的基本语法。这也侧面说明，<strong>Java 中真正支持语法糖的是 Java 编译器而不是 JVM</strong>。</p><p>如果你去看<code>com.sun.tools.javac.main.JavaCompiler</code>的源码，你会发现在<code>compile()</code>中有一个步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现的。</p><h3 id="Java-中有哪些常见的语法糖？"><a href="#Java-中有哪些常见的语法糖？" class="headerlink" title="Java 中有哪些常见的语法糖？"></a>Java 中有哪些常见的语法糖？</h3><p>Java 中最常用的语法糖主要有泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础&quot;&gt;&lt;a href=&quot;#Java基础&quot; class=&quot;headerlink&quot; title=&quot;Java基础&quot;&gt;&lt;/a&gt;Java基础&lt;/h1&gt;&lt;h2 id=&quot;基础概念与常识&quot;&gt;&lt;a href=&quot;#基础概念与常识&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="Java" scheme="https://lesliewaong.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>TS中那些奇怪的符号</title>
    <link href="https://lesliewaong.top/posts/f0caaae4.html"/>
    <id>https://lesliewaong.top/posts/f0caaae4.html</id>
    <published>2022-07-10T03:12:48.000Z</published>
    <updated>2022-07-17T08:40:25.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TS中那些奇怪的符号"><a href="#TS中那些奇怪的符号" class="headerlink" title="TS中那些奇怪的符号"></a><a href="https://segmentfault.com/a/1190000023943952">TS中那些奇怪的符号</a></h1><h2 id="非空断言操作符"><a href="#非空断言操作符" class="headerlink" title="! 非空断言操作符"></a>! 非空断言操作符</h2><p>在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 <code>!</code> 可以用于断言操作对象是非 null 和非 undefined 类型。</p><p><strong>具体而言，x! 将从 x 值域中排除 null 和 undefined 。</strong></p><p>那么非空断言操作符到底有什么用呢？下面我们先来看一下非空断言操作符的一些使用场景。</p><h4 id="忽略-undefined-和-null-类型"><a href="#忽略-undefined-和-null-类型" class="headerlink" title="忽略 undefined 和 null 类型"></a>忽略 undefined 和 null 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">maybeString: <span class="built_in">string</span> | <span class="literal">undefined</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Type &#x27;string | null | undefined&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br><span class="line">  <span class="comment">// Type &#x27;undefined&#x27; is not assignable to type &#x27;string&#x27;. </span></span><br><span class="line">  <span class="keyword">const</span> onlyString: <span class="built_in">string</span> = maybeString; <span class="comment">// Error</span></span><br><span class="line">  <span class="keyword">const</span> ignoreUndefinedAndNull: <span class="built_in">string</span> = maybeString!; <span class="comment">// Ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用函数时忽略-undefined-类型"><a href="#调用函数时忽略-undefined-类型" class="headerlink" title="调用函数时忽略 undefined 类型"></a>调用函数时忽略 undefined 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumGenerator = <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">numGenerator: NumGenerator | <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Object is possibly &#x27;undefined&#x27;.(2532)</span></span><br><span class="line">  <span class="comment">// Cannot invoke an object which is possibly &#x27;undefined&#x27;.(2722)</span></span><br><span class="line">  <span class="keyword">const</span> num1 = numGenerator(); <span class="comment">// Error</span></span><br><span class="line">  <span class="keyword">const</span> num2 = numGenerator!(); <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>!</code> 非空断言操作符会从编译生成的 JavaScript 代码中移除，所以在实际使用的过程中，要特别注意。比如下面这个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="built_in">number</span> | <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> b: <span class="built_in">number</span> = a!;</span><br><span class="line"><span class="built_in">console</span>.log(b); </span><br></pre></td></tr></table></figure><p>以上 TS 代码会编译生成以下 ES5 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure><p>虽然在 TS 代码中，我们使用了非空断言，使得 <code>const b: number = a!;</code> 语句可以通过 TypeScript 类型检查器的检查。但在生成的 ES5 代码中，<code>!</code> 非空断言操作符被移除了，所以在浏览器中执行以上代码，在控制台会输出 <code>undefined</code>。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="?. 运算符"></a>?. 运算符</h2><p>TypeScript 3.7 实现了呼声最高的 ECMAScript 功能之一：可选链（Optional Chaining）。</p><p>有了可选链后，我们编写代码时如果遇到 <code>null</code> 或 <code>undefined</code> 就可以立即停止某些表达式的运行。</p><p>可选链的核心是新的 <code>?.</code> 运算符，它支持以下语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj?.prop</span><br><span class="line">obj?.[expr]</span><br><span class="line">arr?.[index]</span><br><span class="line">func?.(args)</span><br></pre></td></tr></table></figure><h3 id="可选的属性访问"><a href="#可选的属性访问" class="headerlink" title="可选的属性访问"></a>可选的属性访问</h3><p>这里我们来举一个可选的属性访问的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> val = a?.b;</span><br></pre></td></tr></table></figure><p>为了更好的理解可选链，我们来看一下该 <code>const val = a?.b</code> 语句编译生成的 ES5 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> val = a === <span class="literal">null</span> || a === <span class="keyword">void</span> <span class="number">0</span> ? <span class="keyword">void</span> <span class="number">0</span> : a.b;</span><br></pre></td></tr></table></figure><p>上述的代码会自动检查对象 a 是否为 <code>null</code> 或 <code>undefined</code>，如果是的话就立即返回 <code>undefined</code>，这样就可以立即停止某些表达式的运行。你可能已经想到可以使用 <code>?.</code> 来替代很多使用 <code>&amp;&amp;</code> 执行空检查的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &amp;&amp; a.b) &#123; &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a?.b)&#123; &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* if(a?.b)&#123; &#125; 编译后的ES5代码</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* if(</span></span><br><span class="line"><span class="comment">*  a === null || a === void 0 </span></span><br><span class="line"><span class="comment">*  ? void 0 : a.b) &#123;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>但需要注意的是，<code>?.</code> 与 <code>&amp;&amp;</code> 运算符行为略有不同，<code>&amp;&amp;</code> 专门用于检测 <code>falsy</code> 值，比如<strong>空字符串</strong>、<strong>0</strong>、<strong>NaN</strong>、<strong>null</strong> 和 <strong>false</strong> 等。</p><p>而 <code>?.</code> 只会验证对象是否为 <code>null</code> 或 <code>undefined</code>，对于 0 或空字符串来说，并不会出现 “短路”。</p><h3 id="可选元素访问"><a href="#可选元素访问" class="headerlink" title="可选元素访问"></a>可选元素访问</h3><p>可选链除了支持<strong>可选属性</strong>的访问之外，它还支持<strong>可选元素</strong>的访问，它的行为类似于可选属性的访问，只是可选元素的访问允许我们访问非标识符的属性，比如任意字符串、数字索引和 Symbol：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryGetArrayElement</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr?: T[], index: <span class="built_in">number</span> = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr?.[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码经过编译后会生成以下 ES5 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryGetArrayElement</span>(<span class="params">arr, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="keyword">void</span> <span class="number">0</span>) &#123; index = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> arr === <span class="literal">null</span> || arr === <span class="keyword">void</span> <span class="number">0</span> ? <span class="keyword">void</span> <span class="number">0</span> : arr[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过观察生成的 ES5 代码，很明显在 <code>tryGetArrayElement</code> 方法中会自动检测输入参数 arr 的值是否为 <code>null</code> 或 <code>undefined</code>，从而保证了我们代码的健壮性。</p><h3 id="可选链与函数调用"><a href="#可选链与函数调用" class="headerlink" title="可选链与函数调用"></a>可选链与函数调用</h3><p>当尝试调用一个<strong>可能不存在的方法</strong>时也可以使用可选链。</p><p>在实际开发过程中，这是很有用的。</p><p>系统中某个方法不可用，有可能是由于版本不一致或者用户设备兼容性问题导致的。</p><p>函数调用时如果被调用的方法不存在，使用可选链可以使表达式自动返回 <code>undefined</code> 而不是抛出一个异常。</p><p>可选调用使用起来也很简单，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = obj.customMethod?.();</span><br></pre></td></tr></table></figure><p>该 TypeScript 代码编译生成的 ES5 代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = (_a = obj.customMethod) === <span class="literal">null</span></span><br><span class="line">  || _a === <span class="keyword">void</span> <span class="number">0</span> ? <span class="keyword">void</span> <span class="number">0</span> : _a.call(obj);</span><br></pre></td></tr></table></figure><p>另外在使用可选调用的时候，我们要注意以下两个注意事项：</p><ul><li>如果存在一个属性名且该属性名对应的值不是函数类型，使用 <code>?.</code> 仍然会产生一个 <a href="https://link.segmentfault.com/?enc=u0bsgrVkCmczcGx3T4bh1A==.yINHMmTv3WVHRLR4ocsWjGeAbX863orCRS8djpDxybL5MA3KoTIJqpHbEx74GInKLzhV3jLjEopgU03jPeNv1lhQXgAOC/5ZlbyYXiZDQNi2JprpBYCc06g/bN3+ugCG"><code>TypeError</code></a> 异常。</li><li>可选链的运算行为被局限在属性的访问、调用以及元素的访问 —— 它不会沿伸到后续的表达式中，也就是说可选调用不会阻止 <code>a?.b / someMethod()</code> 表达式中的除法运算或 <code>someMethod</code> 的方法调用。</li></ul><h2 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="?? 空值合并运算符"></a>?? 空值合并运算符</h2><p>在 TypeScript 3.7 版本中除了引入了前面介绍的可选链 <code>?.</code> 之外，也引入了一个新的逻辑运算符 —— 空值合并运算符 <code>??</code>。</p><p><strong>当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数</strong>。</p><p>与逻辑或 <code>||</code> 运算符不同，逻辑或会在左操作数为 <strong>falsy</strong> 值时返回右侧操作数。</p><p>也就是说，如果你使用 <code>||</code> 来为某些变量设置默认的值时，你可能会遇到意料之外的行为。比如为 falsy 值（<code>&#39;&#39;</code>、<code>NaN</code> 或 <code>0</code>）时。</p><p>这里来看一个具体的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="literal">null</span> ?? <span class="string">&#x27;default string&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出：&quot;default string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="number">0</span> ?? <span class="number">42</span>;</span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// 输出：0</span></span><br></pre></td></tr></table></figure><p>以上 TS 代码经过编译后，会生成以下 ES5 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> _a, _b;</span><br><span class="line"><span class="keyword">var</span> foo = (_a = <span class="literal">null</span>) !== <span class="literal">null</span> &amp;&amp; _a !== <span class="keyword">void</span> <span class="number">0</span> ? _a : <span class="string">&#x27;default string&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出：&quot;default string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = (_b = <span class="number">0</span>) !== <span class="literal">null</span> &amp;&amp; _b !== <span class="keyword">void</span> <span class="number">0</span> ? _b : <span class="number">42</span>;</span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// 输出：0</span></span><br></pre></td></tr></table></figure><p>通过观察以上代码，我们更加直观的了解到，空值合并运算符是如何解决前面 <code>||</code> 运算符存在的潜在问题。下面我们来介绍空值合并运算符的特性和使用时的一些注意事项。</p><h3 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h3><p>当空值合并运算符的左表达式不为 <code>null</code> 或 <code>undefined</code> 时，不会对右表达式进行求值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;A was called&#x27;</span>); <span class="keyword">return</span> <span class="literal">undefined</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;B was called&#x27;</span>); <span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;C was called&#x27;</span>); <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(A() ?? C());</span><br><span class="line"><span class="built_in">console</span>.log(B() ?? C());</span><br></pre></td></tr></table></figure><p>上述代码运行后，控制台会输出以下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A was called </span><br><span class="line">C was called </span><br><span class="line">foo </span><br><span class="line">B was called </span><br><span class="line">false </span><br></pre></td></tr></table></figure><h3 id="不能与-amp-amp-或-操作符共用"><a href="#不能与-amp-amp-或-操作符共用" class="headerlink" title="不能与 &amp;&amp; 或 || 操作符共用"></a>不能与 &amp;&amp; 或 || 操作符共用</h3><p>若空值合并运算符 <code>??</code> 直接与 <code>AND（&amp;&amp;）</code>和 <code>OR（||）</code>操作符组合使用 是不行的。这种情况下会抛出 SyntaxError。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#x27;||&#x27; and &#x27;??&#x27; operations cannot be mixed without parentheses.(5076)</span></span><br><span class="line"><span class="literal">null</span> || <span class="literal">undefined</span> ?? <span class="string">&quot;foo&quot;</span>; <span class="comment">// raises a SyntaxError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#x27;&amp;&amp;&#x27; and &#x27;??&#x27; operations cannot be mixed without parentheses.(5076)</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">undefined</span> ?? <span class="string">&quot;foo&quot;</span>; <span class="comment">// raises a SyntaxError</span></span><br></pre></td></tr></table></figure><p>但当使用括号来显式表明优先级时是可行的，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="literal">null</span> || <span class="literal">undefined</span> ) ?? <span class="string">&quot;foo&quot;</span>; <span class="comment">// 返回 &quot;foo&quot;</span></span><br></pre></td></tr></table></figure><h3 id="与可选链操作符-的关系"><a href="#与可选链操作符-的关系" class="headerlink" title="与可选链操作符 ?. 的关系"></a>与可选链操作符 ?. 的关系</h3><p>空值合并运算符针对 <code>undefined</code> 与 <code>null</code> 这两个值，可选链式操作符 <code>?.</code> 也是如此。</p><p>可选链式操作符，对于访问属性可能为 <code>undefined</code> 与 <code>null</code> 的对象时非常有用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Customer &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  city?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> customer: Customer = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Semlinker&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> customerCity = customer?.city ?? <span class="string">&quot;Unknown city&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(customerCity); <span class="comment">// 输出：Unknown city</span></span><br></pre></td></tr></table></figure><p>前面我们已经介绍了空值合并运算符的应用场景和使用时的一些注意事项，该运算符不仅可以在 TypeScript 3.7 以上版本中使用。</p><p>当然你也可以在 JavaScript 的环境中使用它，但你需要借助 Babel，在 Babel 7.8.0 版本也开始支持空值合并运算符。</p><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="? 可选属性"></a>? 可选属性</h2><p>在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。</p><p><strong>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述</strong>。</p><p>在 TypeScript 中使用 <code>interface</code> 关键字就可以声明一个接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> semlinker: Person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;semlinker&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">33</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们声明了 <code>Person</code> 接口，它包含了两个必填的属性 <code>name</code> 和 <code>age</code>。在初始化 Person 类型变量时，如果缺少某个属性，TypeScript 编译器就会提示相应的错误信息，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Property &#x27;age&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27; but required in type &#x27;Person&#x27;.(2741)</span></span><br><span class="line"><span class="keyword">let</span> lolo: Person  = &#123; <span class="comment">// Error</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lolo&quot;</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决上述的问题，我们可以把某个属性声明为可选的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lolo: Person  = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lolo&quot;</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工具类型"><a href="#工具类型" class="headerlink" title="工具类型"></a>工具类型</h3><h4 id="Partial-lt-T-gt"><a href="#Partial-lt-T-gt" class="headerlink" title="Partial&lt;T&gt;"></a><code>Partial&lt;T&gt;</code></h4><p>在实际项目开发过程中，为了提高代码复用率，我们可以利用 TypeScript 内置的工具类型 <code>Partial&lt;T&gt;</code> 来快速<strong>把某个接口类型中定义的属性变成可选的</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PullDownRefreshConfig &#123;</span><br><span class="line">  <span class="attr">threshold</span>: <span class="built_in">number</span>;</span><br><span class="line">  stop: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * type PullDownRefreshOptions = &#123;</span></span><br><span class="line"><span class="comment"> *   threshold?: number | undefined;</span></span><br><span class="line"><span class="comment"> *   stop?: number | undefined;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">type</span> PullDownRefreshOptions = Partial&lt;PullDownRefreshConfig&gt;</span><br></pre></td></tr></table></figure><p>是不是觉得 <code>Partial&lt;T&gt;</code> 很方便，下面让我们来看一下它是如何实现的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make all properties in T optional</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Required-lt-T-gt"><a href="#Required-lt-T-gt" class="headerlink" title="Required&lt;T&gt;"></a><code>Required&lt;T&gt;</code></h4><p>既然可以快速地把某个接口中定义的属性全部声明为可选，那能不能把所有的可选的属性变成必选的呢？答案是可以的，针对这个需求，我们可以使用 <code>Required&lt;T&gt;</code> 工具类型，具体的使用方式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PullDownRefreshConfig &#123;</span><br><span class="line">  <span class="attr">threshold</span>: <span class="built_in">number</span>;</span><br><span class="line">  stop: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PullDownRefreshOptions = Partial&lt;PullDownRefreshConfig&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * type PullDownRefresh = &#123;</span></span><br><span class="line"><span class="comment"> *   threshold: number;</span></span><br><span class="line"><span class="comment"> *   stop: number;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> PullDownRefresh = Required&lt;Partial&lt;PullDownRefreshConfig&gt;&gt;</span><br></pre></td></tr></table></figure><p>同样，我们来看一下 <code>Required&lt;T&gt;</code> 工具类型是如何实现的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make all properties in T required</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原来在 <code>Required&lt;T&gt;</code> 工具类型内部，通过 <code>-?</code> 移除了可选属性中的 <code>?</code>，使得属性从可选变为必选的。</p><h2 id="amp-运算符"><a href="#amp-运算符" class="headerlink" title="&amp; 运算符"></a>&amp; 运算符</h2><p>在 TypeScript 中交叉类型是将多个类型合并为一个类型。通过 <code>&amp;</code> 运算符可以将现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PartialPointX = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">type</span> Point = PartialPointX &amp; &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point: Point = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中我们先定义了 <code>PartialPointX</code> 类型，接着使用 <code>&amp;</code> 运算符创建一个新的 <code>Point</code> 类型，表示一个含有 x 和 y 坐标的点，然后定义了一个 <code>Point</code> 类型的变量并初始化。</p><h3 id="同名基础类型属性的合并"><a href="#同名基础类型属性的合并" class="headerlink" title="同名基础类型属性的合并"></a>同名基础类型属性的合并</h3><p>那么现在问题来了，假设在合并多个类型的过程中，刚好出现某些类型存在相同的成员，但对应的类型又不一致，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> X &#123;</span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">string</span>;</span><br><span class="line">  d: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Y &#123;</span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">number</span>;</span><br><span class="line">  e: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> XY = X &amp; Y;</span><br><span class="line"><span class="keyword">type</span> YX = Y &amp; X;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: XY;</span><br><span class="line"><span class="keyword">let</span> q: YX;</span><br></pre></td></tr></table></figure><p>在上面的代码中，接口 X 和接口 Y 都含有一个相同的成员 c，但它们的类型不一致。对于这种情况，此时 XY 类型或 YX 类型中成员 c 的类型是不是可以是 <code>string</code> 或 <code>number</code> 类型呢？比如下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = &#123; <span class="attr">c</span>: <span class="number">6</span>, <span class="attr">d</span>: <span class="string">&quot;d&quot;</span>, <span class="attr">e</span>: <span class="string">&quot;e&quot;</span> &#125;; <span class="comment">// Type &#x27;number&#x27; is not assignable to type &#x27;never&#x27;. (2322)</span></span><br><span class="line">q = &#123; <span class="attr">c</span>: <span class="string">&quot;c&quot;</span>, <span class="attr">d</span>: <span class="string">&quot;d&quot;</span>, <span class="attr">e</span>: <span class="string">&quot;e&quot;</span> &#125;; <span class="comment">// Type &#x27;string&#x27; is not assignable to type &#x27;never&#x27;. (2322)</span></span><br></pre></td></tr></table></figure><p>为什么接口 X 和接口 Y 混入后，成员 c 的类型会变成 <code>never</code> 呢？这是因为混入后成员 c 的类型为 <code>string &amp; number</code>，即成员 c 的类型既可以是 <code>string</code> 类型又可以是 <code>number</code> 类型。很明显这种类型是不存在的，所以混入后成员 c 的类型为 <code>never</code>。</p><h3 id="同名非基础类型属性的合并"><a href="#同名非基础类型属性的合并" class="headerlink" title="同名非基础类型属性的合并"></a>同名非基础类型属性的合并</h3><p>在上面示例中，刚好接口 X 和接口 Y 中内部成员 c 的类型都是基本数据类型，那么如果是非基本数据类型的话，又会是什么情形。我们来看个具体的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> D &#123; d: <span class="built_in">boolean</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> E &#123; e: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> F &#123; f: <span class="built_in">number</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123; x: D; &#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123; x: E; &#125;</span><br><span class="line"><span class="keyword">interface</span> C &#123; x: F; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ABC = A &amp; B &amp; C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> abc: ABC = &#123;</span><br><span class="line">  <span class="attr">x</span>: &#123;</span><br><span class="line">    <span class="attr">d</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">e</span>: <span class="string">&#x27;semlinker&#x27;</span>,</span><br><span class="line">    <span class="attr">f</span>: <span class="number">666</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abc:&#x27;</span>, abc);</span><br></pre></td></tr></table></figure><p>在混入多个类型时，若存在相同的成员，且成员类型为非基本数据类型，那么是可以成功合并。</p><h2 id="分隔符"><a href="#分隔符" class="headerlink" title="| 分隔符"></a>| 分隔符</h2><p>在 TypeScript 中联合类型（Union Types）表示取值可以为多种类型中的一种，联合类型使用 <code>|</code> 分隔每个类型。</p><p>联合类型通常与 <code>null</code> 或 <code>undefined</code> 一起使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHello = <span class="function">(<span class="params">name: <span class="built_in">string</span> | <span class="literal">undefined</span></span>) =&gt;</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>以上示例中 <code>name</code> 的类型是 <code>string | undefined</code> 意味着可以将 <code>string</code> 或 <code>undefined</code> 的值传递给 <code>sayHello</code> 函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sayHello(<span class="string">&quot;semlinker&quot;</span>);</span><br><span class="line">sayHello(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure><p>此外，对于联合类型来说，你可能会遇到以下的用法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="number">1</span> | <span class="number">2</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">type</span> EventNames = <span class="string">&#x27;click&#x27;</span> | <span class="string">&#x27;scroll&#x27;</span> | <span class="string">&#x27;mousemove&#x27;</span>;</span><br></pre></td></tr></table></figure><p>示例中的 <code>1</code>、<code>2</code> 或 <code>&#39;click&#39;</code> 被称为<strong>字面量类型</strong>，用来约束取值只能是某几个值中的一个。</p><h3 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h3><p>当使用联合类型时，我们必须尽量把当前值的类型收窄为当前值的实际类型，而<strong>类型保护就是实现类型收窄的一种手段</strong>。</p><p>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。</p><p>换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数字。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。</p><p>目前主要有四种的方式来实现类型保护：</p><h4 id="in-关键字"><a href="#in-关键字" class="headerlink" title="in 关键字"></a>in 关键字</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Admin &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  privileges: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Employee &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  startDate: <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UnknownEmployee = Employee | Admin;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printEmployeeInformation</span>(<span class="params">emp: UnknownEmployee</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Name: &quot;</span> + emp.name);</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;privileges&quot;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Privileges: &quot;</span> + emp.privileges);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;startDate&quot;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Start Date: &quot;</span> + emp.startDate);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="typeof-关键字"><a href="#typeof-关键字" class="headerlink" title="typeof 关键字"></a>typeof 关键字</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>) + value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> padding + value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;padding&#125;</span>&#x27;.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typeof</code> 类型保护只支持两种形式：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== typename</code>，<code>&quot;typename&quot;</code> 必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>， <code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 </p><p>但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。</p><h4 id="instanceof-关键字"><a href="#instanceof-关键字" class="headerlink" title="instanceof 关键字"></a>instanceof 关键字</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Padder &#123;</span><br><span class="line">  getPaddingString(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceRepeatingPadder</span> <span class="title">implements</span> <span class="title">Padder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> numSpaces: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">getPaddingString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>(<span class="built_in">this</span>.numSpaces + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringPadder</span> <span class="title">implements</span> <span class="title">Padder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> value: <span class="built_in">string</span></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">getPaddingString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> padder: Padder = <span class="keyword">new</span> SpaceRepeatingPadder(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> SpaceRepeatingPadder) &#123;</span><br><span class="line">  <span class="comment">// padder的类型收窄为 &#x27;SpaceRepeatingPadder&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义类型保护的类型谓词（type-predicate）"><a href="#自定义类型保护的类型谓词（type-predicate）" class="headerlink" title="自定义类型保护的类型谓词（type predicate）"></a>自定义类型保护的类型谓词（type predicate）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&quot;number&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&quot;string&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数字分隔符"><a href="#数字分隔符" class="headerlink" title="_ 数字分隔符"></a>_ 数字分隔符</h2><p>TypeScript 2.7 带来了对数字分隔符的支持，正如数值分隔符 ECMAScript 提案中所概述的那样。</p><p>对于一个数字字面量，你现在可以通过把一个下划线作为它们之间的分隔符来分组数字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inhabitantsOfMunich = <span class="number">1_464_301</span>;</span><br><span class="line"><span class="keyword">const</span> distanceEarthSunInKm = <span class="number">149_600_000</span>;</span><br><span class="line"><span class="keyword">const</span> fileSystemPermission = <span class="number">0b111_111_000</span>;</span><br><span class="line"><span class="keyword">const</span> bytes = <span class="number">0b1111_10101011_11110000_00001101</span>;</span><br></pre></td></tr></table></figure><p>分隔符不会改变数值字面量的值，但逻辑分组使人们更容易一眼就能读懂数字。以上 TS 代码经过编译后，会生成以下 ES5 代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> inhabitantsOfMunich = <span class="number">1464301</span>;</span><br><span class="line"><span class="keyword">var</span> distanceEarthSunInKm = <span class="number">149600000</span>;</span><br><span class="line"><span class="keyword">var</span> fileSystemPermission = <span class="number">504</span>;</span><br><span class="line"><span class="keyword">var</span> bytes = <span class="number">262926349</span>;</span><br></pre></td></tr></table></figure><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><p>虽然数字分隔符看起来很简单，但在使用时还是有一些限制。比如你只能在两个数字之间添加 <code>_</code> 分隔符。以下的使用方式是非法的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Numeric separators are not allowed here.(6188)</span></span><br><span class="line">3_<span class="number">.141592</span> <span class="comment">// Error</span></span><br><span class="line"><span class="number">3.</span>_141592 <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Numeric separators are not allowed here.(6188)</span></span><br><span class="line">1_e10 <span class="comment">// Error</span></span><br><span class="line">1e_10 <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cannot find name &#x27;_126301&#x27;.(2304)</span></span><br><span class="line">_126301  <span class="comment">// Error</span></span><br><span class="line"><span class="comment">// Numeric separators are not allowed here.(6188)</span></span><br><span class="line">126301_ <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cannot find name &#x27;b111111000&#x27;.(2304)</span></span><br><span class="line"><span class="comment">// An identifier or keyword cannot immediately follow a numeric literal.(1351)</span></span><br><span class="line">0_b111111000 <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Numeric separators are not allowed here.(6188)</span></span><br><span class="line">0b_111111000 <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>当然你也不能连续使用多个 <code>_</code> 分隔符，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Multiple consecutive numeric separators are not permitted.(6189)</span></span><br><span class="line">123__456 <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><h3 id="解析分隔符"><a href="#解析分隔符" class="headerlink" title="解析分隔符"></a>解析分隔符</h3><p>此外，需要注意的是以下用于解析数字的函数是不支持分隔符：</p><ul><li><code>Number()</code></li><li><code>parseInt()</code></li><li><code>parseFloat()</code></li></ul><p>这里我们来看一下实际的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;123_456&#x27;</span>)</span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;123_456&#x27;</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;123_456&#x27;</span>)</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>很明显对于以上的结果不是我们所期望的，所以在处理分隔符时要特别注意。当然要解决上述问题，也很简单只需要非数字的字符删掉即可。这里我们来定义一个 <code>removeNonDigits</code> 的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_NON_DIGIT = <span class="regexp">/[^0-9]/gu</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeNonDigits</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(RE_NON_DIGIT, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Number</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数通过调用字符串的 <code>replace</code> 方法来移除非数字的字符，具体的使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">removeNonDigits(<span class="string">&#x27;123_456&#x27;</span>)</span><br><span class="line"><span class="number">123456</span></span><br><span class="line">removeNonDigits(<span class="string">&#x27;149,600,000&#x27;</span>)</span><br><span class="line"><span class="number">149600000</span></span><br><span class="line">removeNonDigits(<span class="string">&#x27;1,407,836&#x27;</span>)</span><br><span class="line"><span class="number">1407836</span></span><br></pre></td></tr></table></figure><h2 id="lt-Type-gt-语法"><a href="#lt-Type-gt-语法" class="headerlink" title="&lt;Type&gt; 语法"></a><code>&lt;Type&gt;</code> 语法</h2><h3 id="TypeScript-断言"><a href="#TypeScript-断言" class="headerlink" title="TypeScript 断言"></a>TypeScript 断言</h3><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。</p><p>类型断言有两种形式：</p><h4 id="“尖括号”-语法"><a href="#“尖括号”-语法" class="headerlink" title="“尖括号” 语法"></a>“尖括号” 语法</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure><h4 id="as-语法"><a href="#as-语法" class="headerlink" title="as 语法"></a>as 语法</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure><h3 id="TypeScript-泛型"><a href="#TypeScript-泛型" class="headerlink" title="TypeScript 泛型"></a>TypeScript 泛型</h3><p>对于刚接触 TypeScript 泛型的读者来说，首次看到 <code>&lt;T&gt;</code> 语法会感到陌生。其实它没有什么特别，就像传递参数一样，我们传递了我们想要用于特定函数调用的类型。</p><p><a href="https://imgtu.com/i/jICi6O"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/17/jICi6O.jpg" alt="jICi6O.jpg"></a></p><p>参考上面的图片，当我们调用 <code>identity&lt;Number&gt;(1)</code> ，<code>Number</code> 类型就像参数 <code>1</code> 一样，它将在出现 <code>T</code> 的任何位置填充该类型。图中 <code>&lt;T&gt;</code> 内部的 <code>T</code> 被称为类型变量，它是我们希望传递给 identity 函数的类型占位符，同时它被分配给 <code>value</code> 参数用来代替它的类型：此时 <code>T</code> 充当的是类型，而不是特定的 Number 类型。</p><p>其中 <code>T</code> 代表 <strong>Type</strong>，在定义泛型时通常用作第一个类型变量名称。</p><p>但实际上 <code>T</code> 可以用任何有效名称代替。除了 <code>T</code> 之外，以下是常见泛型变量代表的意思：</p><ul><li><code>K（Key）</code>：表示对象中的键类型；</li><li><code>V（Value）</code>：表示对象中的值类型；</li><li><code>E（Element）</code>：表示元素类型。</li></ul><p>其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 <code>U</code>，用于扩展我们定义的 <code>identity</code> 函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span> &lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">value: T, message: U</span>) : <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(identity&lt;<span class="built_in">Number</span>, <span class="built_in">string</span>&gt;(<span class="number">68</span>, <span class="string">&quot;Semlinker&quot;</span>));</span><br></pre></td></tr></table></figure><p>除了为类型变量显式设定值之外，一种更常见的做法是使编译器自动选择这些类型，从而使代码更简洁。我们可以完全省略尖括号，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span> &lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">value: T, message: U</span>) : <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(identity(<span class="number">68</span>, <span class="string">&quot;Semlinker&quot;</span>));</span><br></pre></td></tr></table></figure><p>对于上述代码，编译器足够聪明，能够知道我们的参数类型，并将它们赋值给 T 和 U，而不需要开发人员显式指定它们。</p><h2 id="XXX-装饰器"><a href="#XXX-装饰器" class="headerlink" title="@XXX 装饰器"></a>@XXX 装饰器</h2><h3 id="装饰器语法"><a href="#装饰器语法" class="headerlink" title="装饰器语法"></a>装饰器语法</h3><p>对于一些刚接触 TypeScript 的小伙伴来说，在第一次看到 <code>@Plugin(&#123;...&#125;)</code> 这种语法可能会觉得很惊讶。</p><p>其实这是装饰器的语法，装饰器的本质是一个函数，通过装饰器我们可以方便地定义与对象相关的元数据。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Plugin</span>(&#123;</span><br><span class="line">  <span class="attr">pluginName</span>: <span class="string">&#x27;Device&#x27;</span>,</span><br><span class="line">  <span class="attr">plugin</span>: <span class="string">&#x27;cordova-plugin-device&#x27;</span>,</span><br><span class="line">  <span class="attr">pluginRef</span>: <span class="string">&#x27;device&#x27;</span>,</span><br><span class="line">  <span class="attr">repo</span>: <span class="string">&#x27;https://github.com/apache/cordova-plugin-device&#x27;</span>,</span><br><span class="line">  <span class="attr">platforms</span>: [<span class="string">&#x27;Android&#x27;</span>, <span class="string">&#x27;Browser&#x27;</span>, <span class="string">&#x27;iOS&#x27;</span>, <span class="string">&#x27;macOS&#x27;</span>, <span class="string">&#x27;Windows&#x27;</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Device</span> <span class="keyword">extends</span> <span class="title">IonicNativePlugin</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们通过装饰器来保存 ionic-native 插件的相关元信息，而 <code>@Plugin(&#123;...&#125;)</code> 中的 <code>@</code> 符号只是语法糖，为什么说是语法糖呢？这里我们来看一下编译生成的 ES5 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __decorate = (<span class="built_in">this</span> &amp;&amp; <span class="built_in">this</span>.__decorate) || <span class="function"><span class="keyword">function</span> (<span class="params">decorators, target, key, desc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="built_in">arguments</span>.length, r = c &lt; <span class="number">3</span> ? target : desc === <span class="literal">null</span> ? desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key) : desc, d;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Reflect</span> === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Reflect</span>.decorate === <span class="string">&quot;function&quot;</span>) r = <span class="built_in">Reflect</span>.decorate(decorators, target, key, desc);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">var</span> i = decorators.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (d = decorators[i]) r = (c &lt; <span class="number">3</span> ? d(r) : c &gt; <span class="number">3</span> ? d(target, key, r) : d(target, key)) || r;</span><br><span class="line">    <span class="keyword">return</span> c &gt; <span class="number">3</span> &amp;&amp; r &amp;&amp; <span class="built_in">Object</span>.defineProperty(target, key, r), r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Device = <span class="comment">/** <span class="doctag">@class </span>*/</span> (<span class="function"><span class="keyword">function</span> (<span class="params">_super</span>) </span>&#123;</span><br><span class="line">    __extends(Device, _super);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Device</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _super !== <span class="literal">null</span> &amp;&amp; _super.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>) || <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Device = __decorate([</span><br><span class="line">        Plugin(&#123;</span><br><span class="line">            <span class="attr">pluginName</span>: <span class="string">&#x27;Device&#x27;</span>,</span><br><span class="line">            <span class="attr">plugin</span>: <span class="string">&#x27;cordova-plugin-device&#x27;</span>,</span><br><span class="line">            <span class="attr">pluginRef</span>: <span class="string">&#x27;device&#x27;</span>,</span><br><span class="line">            <span class="attr">repo</span>: <span class="string">&#x27;https://github.com/apache/cordova-plugin-device&#x27;</span>,</span><br><span class="line">            <span class="attr">platforms</span>: [<span class="string">&#x27;Android&#x27;</span>, <span class="string">&#x27;Browser&#x27;</span>, <span class="string">&#x27;iOS&#x27;</span>, <span class="string">&#x27;macOS&#x27;</span>, <span class="string">&#x27;Windows&#x27;</span>],</span><br><span class="line">        &#125;),</span><br><span class="line">        Injectable()</span><br><span class="line">    ], Device);</span><br><span class="line">    <span class="keyword">return</span> Device;</span><br><span class="line">&#125;(IonicNativePlugin));</span><br></pre></td></tr></table></figure><p>通过生成的代码可知，<code>@Plugin(&#123;...&#125;)</code> 和 <code>@Injectable()</code> 最终会被转换成普通的方法调用，它们的调用结果最终会以数组的形式作为参数传递给 <code>__decorate</code> 函数，而在 <code>__decorate</code> 函数内部会以 <code>Device</code> 类作为参数调用各自的类型装饰器，从而扩展对应的功能。</p><h3 id="装饰器的分类"><a href="#装饰器的分类" class="headerlink" title="装饰器的分类"></a>装饰器的分类</h3><p>在 TypeScript 中装饰器分为类装饰器、属性装饰器、方法装饰器和参数装饰器四大类。</p><h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h4><p>类装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> ClassDecorator = <span class="xml"><span class="tag">&lt;<span class="name">TFunction</span> <span class="attr">extends</span> <span class="attr">Function</span>&gt;</span>(</span></span><br><span class="line"><span class="xml">  target: TFunction</span></span><br><span class="line"><span class="xml">) =&gt; TFunction | void;</span></span><br></pre></td></tr></table></figure><p>类装饰器顾名思义，就是用来装饰类的。它接收一个参数：</p><ul><li>target: TFunction - 被装饰的类</li></ul><p>看完第一眼后，是不是感觉都不好了。没事，我们马上来个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">target: <span class="built_in">Function</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  target.prototype.greet = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello Semlinker!&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Greeter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 内部实现</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGreeting = <span class="keyword">new</span> Greeting();</span><br><span class="line">myGreeting.greet(); <span class="comment">// console output: &#x27;Hello Semlinker!&#x27;;</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我们定义了 <code>Greeter</code> 类装饰器，同时我们使用了 <code>@Greeter</code> 语法糖，来使用装饰器。</p><blockquote><p>友情提示：读者可以直接复制上面的代码，在 <a href="https://link.segmentfault.com/?enc=dhotVKLs98Gh7cTrCd+/HQ==.AzMIMGaIK4xuV43ZArYSEZujBWurZSjDPmID+PWmBxHpfcREwvRtvBMWAQo8niRz">TypeScript Playground</a> 中运行查看结果。</p></blockquote><h4 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h4><p>属性装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> PropertyDecorator = <span class="function">(<span class="params">target:<span class="built_in">Object</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">  propertyKey: <span class="built_in">string</span> | symbol </span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>属性装饰器顾名思义，用来装饰类的属性。它接收两个参数：</p><ul><li>target: Object - 被装饰的类</li><li>propertyKey: string | symbol - 被装饰类的属性名</li></ul><p>趁热打铁，马上来个例子热热身：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProperty</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">delete</span> target[key];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> backingField = <span class="string">&quot;_&quot;</span> + key;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, backingField, &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// property getter</span></span><br><span class="line">  <span class="keyword">const</span> getter = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">this</span>: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currVal = <span class="built_in">this</span>[backingField];</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Get: <span class="subst">$&#123;key&#125;</span> =&gt; <span class="subst">$&#123;currVal&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> currVal;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// property setter</span></span><br><span class="line">  <span class="keyword">const</span> setter = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">this</span>: <span class="built_in">any</span>, newVal: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Set: <span class="subst">$&#123;key&#125;</span> =&gt; <span class="subst">$&#123;newVal&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">this</span>[backingField] = newVal;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create new property with getter and setter</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: getter,</span><br><span class="line">    <span class="attr">set</span>: setter,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">  <span class="meta">@logProperty</span></span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name : <span class="built_in">string</span></span>)</span> &#123; </span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;semlinker&quot;</span>);</span><br><span class="line">p1.name = <span class="string">&quot;kakuqo&quot;</span>;</span><br></pre></td></tr></table></figure><p>以上代码我们定义了一个 <code>logProperty</code> 函数，来跟踪用户对属性的操作，当代码成功运行后，在控制台会输出以下结果：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set: <span class="function"><span class="params">name</span> =&gt;</span> semlinker</span><br><span class="line">Set: <span class="function"><span class="params">name</span> =&gt;</span> kakuqo</span><br></pre></td></tr></table></figure><h4 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h4><p>方法装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> MethodDecorator = &lt;T&gt;<span class="function">(<span class="params">target:<span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span> | symbol,          </span></span></span><br><span class="line"><span class="params"><span class="function">  descriptor: TypePropertyDescript&lt;T&gt;</span>) =&gt;</span> TypedPropertyDescriptor&lt;T&gt; | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>方法装饰器顾名思义，用来装饰类的方法。它接收三个参数：</p><ul><li>target: Object - 被装饰的类</li><li>propertyKey: string | symbol - 方法名</li><li>descriptor: TypePropertyDescript - 属性描述符</li></ul><p>废话不多说，直接上例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LogOutput</span>(<span class="params">tarage: <span class="built_in">Function</span>, key: <span class="built_in">string</span>, descriptor: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> originalMethod = descriptor.value;</span><br><span class="line">  <span class="keyword">let</span> newMethod = <span class="function"><span class="keyword">function</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: <span class="built_in">any</span> = originalMethod.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.loggedOutput) &#123;</span><br><span class="line">      <span class="built_in">this</span>.loggedOutput = <span class="keyword">new</span> <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.loggedOutput.push(&#123;</span><br><span class="line">      <span class="attr">method</span>: key,</span><br><span class="line">      <span class="attr">parameters</span>: args,</span><br><span class="line">      <span class="attr">output</span>: result,</span><br><span class="line">      <span class="attr">timestamp</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">  descriptor.value = newMethod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">  <span class="meta">@LogOutput</span></span><br><span class="line">  double (num: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> calc = <span class="keyword">new</span> Calculator();</span><br><span class="line">calc.double(<span class="number">11</span>);</span><br><span class="line"><span class="comment">// console ouput: [&#123;method: &quot;double&quot;, output: 22, ...&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(calc.loggedOutput); </span><br></pre></td></tr></table></figure><h4 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h4><p>参数装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> ParameterDecorator = <span class="function">(<span class="params">target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span> | symbol, </span></span></span><br><span class="line"><span class="params"><span class="function">  parameterIndex: <span class="built_in">number</span> </span>) =&gt;</span> <span class="built_in">void</span></span><br></pre></td></tr></table></figure><p>参数装饰器顾名思义，是用来装饰函数参数，它接收三个参数：</p><ul><li>target: Object - 被装饰的类</li><li>propertyKey: string | symbol - 方法名</li><li>parameterIndex: number - 方法中参数的索引值</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Log</span>(<span class="params">target: <span class="built_in">Function</span>, key: <span class="built_in">string</span>, parameterIndex: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> functionLogged = key || target.prototype.constructor.name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`The parameter in position <span class="subst">$&#123;parameterIndex&#125;</span> at <span class="subst">$&#123;functionLogged&#125;</span> has</span></span><br><span class="line"><span class="string">    been decorated`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="meta">@Log</span> phrase: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.greeting = phrase; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console output: The parameter in position 0 </span></span><br><span class="line"><span class="comment">// at Greeter has been decorated</span></span><br></pre></td></tr></table></figure><h2 id="XXX-私有字段"><a href="#XXX-私有字段" class="headerlink" title="#XXX 私有字段"></a>#XXX 私有字段</h2><p>在 TypeScript 3.8 版本就开始支持 <strong>ECMAScript 私有字段</strong>，使用方式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  #name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.#name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="built_in">this</span>.#name&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> semlinker = <span class="keyword">new</span> Person(<span class="string">&quot;Semlinker&quot;</span>);</span><br><span class="line"></span><br><span class="line">semlinker.#name;</span><br><span class="line"><span class="comment">//     ~~~~~</span></span><br><span class="line"><span class="comment">// Property &#x27;#name&#x27; is not accessible outside class &#x27;Person&#x27;</span></span><br><span class="line"><span class="comment">// because it has a private identifier.</span></span><br></pre></td></tr></table></figure><p>与常规属性（甚至使用 <code>private</code> 修饰符声明的属性）不同，私有字段要牢记以下规则：</p><ul><li>私有字段以 <code>#</code> 字符开头，有时我们称之为私有名称；</li><li>每个私有字段名称都唯一地限定于其包含的类；</li><li>不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；</li><li>私有字段不能在包含的类之外访问，甚至不能被检测到。</li></ul><h3 id="私有字段与-private-的区别"><a href="#私有字段与-private-的区别" class="headerlink" title="私有字段与 private 的区别"></a>私有字段与 private 的区别</h3><p>说到这里使用 <code>#</code> 定义的私有字段与 <code>private</code> 修饰符定义字段有什么区别呢？现在我们先来看一个 <code>private</code> 的示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;Semlinker&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br></pre></td></tr></table></figure><p>在上面代码中，我们创建了一个 Person 类，该类中使用 <code>private</code> 修饰符定义了一个私有属性 <code>name</code>，接着使用该类创建一个 <code>person</code> 对象，然后通过 <code>person.name</code> 来访问 <code>person</code> 对象的私有属性，这时 TypeScript 编译器会提示以下异常：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Property</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">is</span> <span class="keyword">private</span> <span class="keyword">and</span> only accessible within <span class="keyword">class</span> <span class="string">&#x27;Person&#x27;</span>.(<span class="number">2341</span>)</span><br></pre></td></tr></table></figure><p>那如何解决这个异常呢？当然你可以使用类型断言把 person 转为 any 类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((person <span class="keyword">as</span> any).name);</span><br></pre></td></tr></table></figure><p>通过这种方式虽然解决了 TypeScript 编译器的异常提示，但是在运行时我们还是可以访问到 <code>Person</code> 类内部的私有属性，为什么会这样呢？我们来看一下编译生成的 ES5 代码，也许你就知道答案了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="comment">/** <span class="doctag">@class </span>*/</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Person;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;Semlinker&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br></pre></td></tr></table></figure><p>这时相信有些小伙伴会好奇，在 TypeScript 3.8 以上版本通过 <code>#</code> 号定义的私有字段编译后会生成什么代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  #name: string;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.#name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="built_in">this</span>.#name&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码目标设置为 ES2015，会编译生成以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> __classPrivateFieldSet = (<span class="built_in">this</span> &amp;&amp; <span class="built_in">this</span>.__classPrivateFieldSet) </span><br><span class="line">  || <span class="function"><span class="keyword">function</span> (<span class="params">receiver, privateMap, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!privateMap.has(receiver)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;attempted to set private field on non-instance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    privateMap.set(receiver, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> __classPrivateFieldGet = (<span class="built_in">this</span> &amp;&amp; <span class="built_in">this</span>.__classPrivateFieldGet) </span><br><span class="line">  || <span class="function"><span class="keyword">function</span> (<span class="params">receiver, privateMap</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!privateMap.has(receiver)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;attempted to get private field on non-instance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> privateMap.get(receiver);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _name;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">      _name.set(<span class="built_in">this</span>, <span class="keyword">void</span> <span class="number">0</span>);</span><br><span class="line">      __classPrivateFieldSet(<span class="built_in">this</span>, _name, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Hello, my name is <span class="subst">$&#123;__classPrivateFieldGet(<span class="built_in">this</span>, _name)&#125;</span>!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">_name = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br></pre></td></tr></table></figure><p>通过观察上述代码，使用 <code>#</code> 号定义的 ECMAScript 私有字段，会通过 <code>WeakMap</code> 对象来存储，同时编译器会生成 <code>__classPrivateFieldSet</code> 和 <code>__classPrivateFieldGet</code> 这两个方法用于设置值和获取值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TS中那些奇怪的符号&quot;&gt;&lt;a href=&quot;#TS中那些奇怪的符号&quot; class=&quot;headerlink&quot; title=&quot;TS中那些奇怪的符号&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000023943952&quot;&gt;TS</summary>
      
    
    
    
    <category term="TypeScript" scheme="https://lesliewaong.top/categories/TypeScript/"/>
    
    
    <category term="TypeScript" scheme="https://lesliewaong.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Axios</title>
    <link href="https://lesliewaong.top/posts/6155a9d6.html"/>
    <id>https://lesliewaong.top/posts/6155a9d6.html</id>
    <published>2022-07-05T08:42:42.000Z</published>
    <updated>2022-07-17T08:40:25.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Axios的理解与使用"><a href="#Axios的理解与使用" class="headerlink" title="Axios的理解与使用"></a>Axios的理解与使用</h1><h2 id="axios-是什么"><a href="#axios-是什么" class="headerlink" title="axios 是什么?"></a>axios 是什么?</h2><ul><li>前端最流行的 ajax 请求库 </li><li>react/vue 官方都推荐使用 axios 发 ajax 请求 </li><li>文档: <a href="https://github.com/axios/axios">https://github.com/axios/axios</a></li></ul><h2 id="axios-特点"><a href="#axios-特点" class="headerlink" title="axios 特点"></a>axios 特点</h2><ul><li>基于 <code>xhr</code> + <code>promise</code> 的异步 <code>ajax</code> 请求库 </li><li><strong>浏览器端/node端</strong>都可以使用 </li><li>支持<strong>请求／响应拦截器</strong> </li><li>支持<strong>请求取消</strong> </li><li><strong>请求/响应数据转换</strong> </li><li><strong>批量发送多个请求</strong></li></ul><h2 id="axios-常用语法"><a href="#axios-常用语法" class="headerlink" title="axios 常用语法"></a>axios 常用语法</h2><ul><li><code>axios(config)</code>: <strong>通用/最本质</strong>的发任意类型请求的方式 </li><li><code>axios(url[, config])</code>: 可以只指定 url 发 <code>get</code> 请求 </li><li><code>axios.request(config)</code>: 等同于 <code>axios(config)</code> </li><li><code>axios.get(url[, config])</code>: 发 <code>get</code> 请求 </li><li><code>axios.delete(url[, config])</code>: 发 <code>delete</code> 请求 </li><li><code>axios.post(url[, data, config])</code>: 发 <code>post</code> 请求</li><li><code>axios.put(url[, data, config])</code>: 发 <code>put</code> 请求 </li><li><code>axios.defaults.xxx</code>: 请求的<strong>默认全局配置</strong> </li><li><code>axios.interceptors.request.use()</code>: 添加<strong>请求拦截器</strong> </li><li><code>axios.interceptors.response.use()</code>: 添加<strong>响应拦截器</strong> </li><li><code>axios.create([config])</code>: <strong>创建一个新的 axios</strong>(它没有下面的功能) </li><li><code>axios.Cancel()</code>: 用于创建取消请求的错误对象 </li><li><code>axios.CancelToken()</code>: 用于创建取消请求的 token 对象 </li><li><code>axios.isCancel()</code>: 是否是一个取消请求的错误 </li><li><code>axios.all(promises)</code>: 用于<strong>批量执行多个异步请求</strong> </li><li><code>axios.spread()</code>: 用来<strong>指定接收所有成功数据的回调函数的方法</strong></li></ul><h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><a href="https://imgtu.com/i/j2GiCQ"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/12/j2GiCQ.png" alt="j2GiCQ.png"></a></p><h2 id="难点语法的理解和使用"><a href="#难点语法的理解和使用" class="headerlink" title="难点语法的理解和使用"></a>难点语法的理解和使用</h2><h3 id="axios-create-config"><a href="#axios-create-config" class="headerlink" title="axios.create(config)"></a>axios.create(config)</h3><ol><li><p>根据指定配置创建一个新的 axios, 也就是<strong>每个新 axios 都有自己的配置</strong> </p></li><li><p>新 axios 只是<strong>没有取消请求和批量发请求的方法</strong>, 其它所有语法都是一致的 </p></li><li><p>为什么要设计这个语法?</p><ul><li>需求: 项目中<strong>有部分接口需要的配置与另一部分接口需要的配置不太一样</strong>, 如何处理 </li><li>解决: <strong>创建 2 个新 axios, 每个都有自己特有的配置,</strong> 分别应用到不同要求的接口请求中</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建实例对象  /getJoke</span></span><br><span class="line"><span class="keyword">const</span> duanzi = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;https://api.apiopen.top&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">2000</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> onather = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;https://b.com&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">2000</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//这里  duanzi 与 axios 对象的功能几近是一样的</span></span><br><span class="line"><span class="comment">// duanzi(&#123;</span></span><br><span class="line"><span class="comment">//     url: &#x27;/getJoke&#x27;,</span></span><br><span class="line"><span class="comment">// &#125;).then(response =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(response);</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line">duanzi.get(<span class="string">&#x27;/getJoke&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="拦截器函数-ajax-请求-请求的回调函数的调用顺序"><a href="#拦截器函数-ajax-请求-请求的回调函数的调用顺序" class="headerlink" title="拦截器函数/ajax 请求/请求的回调函数的调用顺序"></a>拦截器函数/ajax 请求/请求的回调函数的调用顺序</h3><ol><li>说明: 调用 axios()并不是立即发送 ajax 请求, 而是需要经历一个较长的流程 </li><li>流程: 请求拦截器2 =&gt; 请求拦截器1 =&gt; 发ajax请求 =&gt; 响应拦截器1 =&gt; 响应拦截器 2 =&gt; 请求的回调 </li><li>注意: 此流程是通过 promise 串连起来的, 请求拦截器传递的是 config, 响应 拦截器传递的是 response</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// 设置请求拦截器  config 配置对象</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 成功 - 1号&#x27;</span>);</span><br><span class="line">    <span class="comment">//修改 config 中的参数</span></span><br><span class="line">    config.params = &#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">100</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 失败 - 1号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 成功 - 2号&#x27;</span>);</span><br><span class="line">    <span class="comment">//修改 config 中的参数</span></span><br><span class="line">    config.timeout = <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 失败 - 2号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 成功 1号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> response.data;</span><br><span class="line">    <span class="comment">// return response;</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 失败 1号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 成功 2号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 失败 2号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;自定义回调处理成功的结果&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h3><p>基本流程 :</p><ol><li>配置 cancelToken 对象 </li><li>缓存用于取消请求的 cancel 函数 </li><li>在后面特定时机调用 cancel 函数取消请求 </li><li>在错误回调中判断如果 error 是 cancel, 做相应处理</li></ol><p>实现功能 点击按钮, 取消某个正在请求中的请求,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取按钮</span></span><br><span class="line"><span class="keyword">const</span> btns = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="comment">//2.声明全局变量</span></span><br><span class="line"><span class="keyword">let</span> cancel = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//检测上一次的请求是否已经完成</span></span><br><span class="line">    <span class="keyword">if</span> (cancel !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//取消上一次的请求</span></span><br><span class="line">        cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    axios(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span><br><span class="line">        <span class="comment">//1. 添加配置对象的属性</span></span><br><span class="line">        <span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//3. 将 c 的值赋值给 cancel</span></span><br><span class="line">            cancel = c;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response);</span><br><span class="line">        <span class="comment">//将 cancel 的值初始化</span></span><br><span class="line">        cancel = <span class="literal">null</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定第二个事件取消请求</span></span><br><span class="line">btns[<span class="number">1</span>].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;cancel(); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认配置</span></span><br><span class="line">axios.defaults.method = <span class="string">&#x27;GET&#x27;</span>;<span class="comment">//设置默认的请求类型为 GET</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://localhost:3000&#x27;</span>;<span class="comment">//设置基础 URL</span></span><br><span class="line">axios.defaults.params = &#123;<span class="attr">id</span>:<span class="number">100</span>&#125;;</span><br><span class="line">axios.defaults.timeout = <span class="number">3000</span>;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    axios(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/posts&#x27;</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Axios的难点问题"><a href="#Axios的难点问题" class="headerlink" title="Axios的难点问题"></a>Axios的难点问题</h1><h2 id="axios-与-Axios-的关系"><a href="#axios-与-Axios-的关系" class="headerlink" title="axios 与 Axios 的关系"></a>axios 与 Axios 的关系</h2><ol><li>从<code>语法</code>上来说: axios 不是 Axios 的实例</li><li>从<code>功能</code>上来说: axios 是 Axios 的实例</li><li>axios 是 <code>Axios.prototype.request</code> 函数 <code>bind()</code>返回的函数</li><li>axios 作为对象有 Axios 原型对象上的所有方法, 有 Axios 对象上所有属性</li></ol><h2 id="instance-与-axios-的区别"><a href="#instance-与-axios-的区别" class="headerlink" title="instance 与 axios 的区别?"></a>instance 与 axios 的区别?</h2><ol><li>相同:<br> (1) 都是一个能发任意请求的函数: request(config)<br> (2) 都有发特定请求的各种方法: get()/post()/put()/delete()<br> (3) 都有默认配置和拦截器的属性: defaults/interceptors</li><li>不同:<br> (1) 默认配置很可能不一样<br> (2) instance 没有 axios 后面添加的一些方法: create()/CancelToken()/all()</li></ol><h2 id="axios运行的整体流程"><a href="#axios运行的整体流程" class="headerlink" title="axios运行的整体流程"></a>axios运行的整体流程</h2><ol><li><p>整体流程:<br> request(config) ==&gt; dispatchRequest(config) ==&gt; xhrAdapter(config)</p></li><li><p>request(config):<br> 将请求拦截器 / dispatchRequest() / 响应拦截器 通过 promise 链串连起来,<br> 返回 promise</p></li><li><p>dispatchRequest(config):<br> 转换请求数据 ===&gt; 调用 xhrAdapter()发请求 ===&gt; 请求返回后转换响应数<br> 据. 返回 promise</p></li><li><p>xhrAdapter(config):<br> 创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据,<br> 返回 promise </p></li><li><p>流程图:</p><p> <a href="https://imgtu.com/i/j2JPZ6"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/12/j2JPZ6.png" alt="j2JPZ6.png"></a></p></li></ol><h2 id="axios-的请求-响应拦截器是什么"><a href="#axios-的请求-响应拦截器是什么" class="headerlink" title="axios 的请求/响应拦截器是什么?"></a>axios 的请求/响应拦截器是什么?</h2><ol><li>请求拦截器:<br> Ⅰ- <strong>在真正发送请求前执行的回调函数</strong><br> Ⅱ- 可以<strong>对请求进行检查或配置进行特定处理</strong><br> Ⅲ- 成功的回调函数, 传递的默认是 <code>config</code>(也必须是)<br> Ⅳ- 失败的回调函数, 传递的默认是 <code>error</code></li><li>响应拦截器<br> Ⅰ- <strong>在请求得到响应后执行的回调函数</strong><br> Ⅱ- <strong>可以对响应数据进行特定处理</strong><br> Ⅲ- 成功的回调函数, 传递的默认是 <code>response</code><br> Ⅳ- 失败的回调函数, 传递的默认是 <code>error</code></li></ol><h2 id="axios-的请求-响应数据转换器是什么"><a href="#axios-的请求-响应数据转换器是什么" class="headerlink" title="axios 的请求/响应数据转换器是什么?"></a>axios 的请求/响应数据转换器是什么?</h2><ol><li>请求转换器: 对请求头和请求体数据进行特定处理的函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (utils.isObject(data)) &#123;</span><br><span class="line"> setContentTypeIfUnset(headers, <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>响应转换器: 将响应体 json 字符串解析为 js 对象或数组的函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.data = <span class="built_in">JSON</span>.parse(response.data)</span><br></pre></td></tr></table></figure><h2 id="response与error-的整体结构"><a href="#response与error-的整体结构" class="headerlink" title="response与error 的整体结构"></a>response与error 的整体结构</h2><ol><li>response的整体结构</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    data, status,statusText,headers,config,request</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>error 的整体结构</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    message,response,request,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何取消未完成的请求"><a href="#如何取消未完成的请求" class="headerlink" title="如何取消未完成的请求?"></a>如何取消未完成的请求?</h2><ol><li>当配置了 cancelToken 对象时, 保存 cancel 函数</li><li>创建一个用于将来中断请求的 cancelPromise</li><li>并定义了一个用于取消请求的 cancel 函数</li><li>将 cancel 函数传递出来</li><li>调用 cancel()取消请求</li><li>执行 cacel 函数, 传入错误信息 message</li><li>内部会让 cancelPromise 变为成功, 且成功的值为一个 Cancel 对象</li><li>在 cancelPromise 的成功回调中中断请求, 并让发请求的 proimse 失败, </li><li>失败的 reason 为 Cancel 对象</li></ol><h1 id="完整过一遍axios"><a href="#完整过一遍axios" class="headerlink" title="完整过一遍axios"></a>完整过一遍axios</h1><h2 id="axios请求方法"><a href="#axios请求方法" class="headerlink" title="axios请求方法"></a>axios请求方法</h2><p>主要有get，post，put，patch，delete</p><ul><li><p>get</p><p>获取数据</p></li><li><p>post</p><p>提交数据（表单提交+文件上传）</p></li><li><p>put</p><p>更新数据（将所有数据均推放到服务端）</p></li><li><p>patch</p><p>更新数据（只将修改的数据推送到后端）</p></li><li><p>delete</p><p>删除数据</p></li></ul><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><h4 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h4><p>调用型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;/data.json&#x27;</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>axios()型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;/data.json&#x27;</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="params"><a href="#params" class="headerlink" title="params"></a>params</h4><p>调用型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;/data.json&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">        <span class="attr">id</span>:<span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>axios()方法型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;/data.json&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">        <span class="attr">id</span>:<span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="post方法"><a href="#post方法" class="headerlink" title="post方法"></a>post方法</h3><h4 id="写法-1"><a href="#写法-1" class="headerlink" title="写法"></a>写法</h4><p>调用型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">&#x27;/post&#x27;</span>,&#123;&#125;,config)</span><br></pre></td></tr></table></figure><p>post方法有三个参数，分别是url、数据、config。config参数暂时不讨论。</p><p>一般上传的数据分两种</p><ul><li><code>form-data</code> 表单提交（图片上传、文件上传）</li><li><code>application/json</code></li><li>以上两种数据，都可以在请求发起后，进入浏览器network查看请求头中的content-type进行查看</li></ul><p>假设我们现在要上传一个数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123; <span class="attr">id</span>:<span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure><p>那么我们可以直接将其传入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">&#x27;/post&#x27;</span>,data).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>axios()方法型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;/post&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:data</span><br><span class="line">&#125;).then(...)</span><br></pre></td></tr></table></figure><h4 id="两种数据的小细节"><a href="#两种数据的小细节" class="headerlink" title="两种数据的小细节"></a>两种数据的小细节</h4><p>当我们上传的是一个一般的<code>let data = &#123; id:12 &#125;</code>数据时，Network的请求头里会显示为：<code>application/json；charset=UTF-8</code></p><p>当我们上传的是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">id</span>:<span class="number">12</span>&#125;</span><br><span class="line"><span class="keyword">let</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line">    formData.append(key,data[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将data转格式了，格式变为formdata形式。</p><p>那么Network的请求头里会显示为：<code>multipart/form-data; boundary=----WebKitFormBoundarywWFnSlPye1ZF8CSw</code></p><h3 id="put方法和patch方法"><a href="#put方法和patch方法" class="headerlink" title="put方法和patch方法"></a>put方法和patch方法</h3><p>形式与post方法大体相同，Network显示仅<strong>Request Method</strong>不同。</p><h3 id="delete方法"><a href="#delete方法" class="headerlink" title="delete方法"></a>delete方法</h3><h4 id="写法-2"><a href="#写法-2" class="headerlink" title="写法"></a>写法</h4><p>url删除法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接从url里面删除</span></span><br><span class="line">axios.delete(<span class="string">&#x27;/data.json&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">        <span class="attr">id</span>:<span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>从url删除，Network请求头最后面会显示为：<code>Query String Parameters</code></p><p>请求体删除法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.delete(<span class="string">&#x27;/data.json&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">id</span>:<span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>从请求体里删除，Network请求头最后面会显示为：<code>Request Payload</code></p><p>两种方法的删除方式是不同的，具体使用需要和后端沟通。</p><h3 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>同时进行多个请求，并统一处理返回值。</p><p>案例：假设有一个聊天工具，同时有你的聊天记录和个人信息。此时需要调用两个接口去请求数据。此时需要统一处理他们的返回值。</p><h4 id="axios提供的方法：all、spread"><a href="#axios提供的方法：all、spread" class="headerlink" title="axios提供的方法：all、spread"></a>axios提供的方法：all、spread</h4><p>axios.all方法接受一个数组作为参数，数组中的每个元素都是一个请求，返回一个promise对象，<strong>当数组中所有请求均已完成时</strong>，执行then方法。 在then方法中执行了 axios.spread 方法。该方法是接收一个函数作为参数，返回一个新的函数。接收的参数函数的参数是axios.all方法中每个请求返回的响应。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> axios.get(<span class="string">&#x27;/user/12345&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermissions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> axios.get(<span class="string">&#x27;/user/12345/permissions&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">    .then(axios.spread(<span class="function">(<span class="params">acct, perms</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 两个请求都完成后,acct是getUserAccount的返回值，同理，perms是 getUserPermissions的返回值</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h2 id="axios实例简介"><a href="#axios实例简介" class="headerlink" title="axios实例简介"></a>axios实例简介</h2><h3 id="为什么要用实例？"><a href="#为什么要用实例？" class="headerlink" title="为什么要用实例？"></a>为什么要用实例？</h3><p>当我们需要用到不同的后端域名，直接调用<code>axios.get</code>并不太方便。我们可以用创建实例的方式去调用，不同的域名用不同的实例一一对应。</p><h3 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> instance = axios.create(&#123;</span><br><span class="line">        <span class="attr">baseURL</span>:<span class="string">&#x27;http://localhost:8080&#x27;</span>,<span class="comment">//基本请求路径</span></span><br><span class="line">        <span class="attr">timeout</span>:<span class="number">1000</span>,<span class="comment">//超时设定</span></span><br><span class="line">    &#125;)</span><br><span class="line">    instance.get(<span class="string">&#x27;/data.json&#x27;</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本配置方法"><a href="#基本配置方法" class="headerlink" title="基本配置方法"></a>基本配置方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">baseURL:<span class="string">&#x27;http://localhost:8080&#x27;</span>,<span class="comment">//请求的域名、基本地址</span></span><br><span class="line"><span class="attr">timeout</span>:<span class="number">1000</span>,<span class="comment">//请求超时时长（ms）</span></span><br><span class="line"><span class="attr">url</span>:<span class="string">&#x27;/data.json&#x27;</span>,<span class="comment">//请求路径</span></span><br><span class="line"><span class="attr">method</span>:<span class="string">&#x27;get，post，put，patch,delete&#x27;</span>,<span class="comment">//请求方法</span></span><br><span class="line"><span class="attr">headers</span>:&#123;</span><br><span class="line"><span class="attr">token</span>:<span class="string">&#x27;&#x27;</span><span class="comment">//代表当前登陆人的身份信息</span></span><br><span class="line">&#125;,<span class="comment">//设置请求头</span></span><br><span class="line"><span class="attr">params</span>:&#123;&#125;,<span class="comment">//将请求参数拼接在url上，是一个对象</span></span><br><span class="line"><span class="attr">data</span>:&#123;&#125;<span class="comment">//将请求参数放在请求体里，是一个对象</span></span><br></pre></td></tr></table></figure><p>其中，params和data表现形式为<strong>对象</strong>。</p><p>使用场景通常是发起请求时，顺带传送参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以get请求为例，get有两个配置，分别是相对路径和config</span></span><br><span class="line">axios.get(<span class="string">&#x27;/data.json&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">        <span class="comment">//参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="参数配置方法"><a href="#参数配置方法" class="headerlink" title="参数配置方法"></a>参数配置方法</h2><h3 id="1-全局配置"><a href="#1-全局配置" class="headerlink" title="1.全局配置"></a>1.全局配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.基本配置方法（baseurl等）</span><br><span class="line">如：</span><br><span class="line">axios.defaults.timeout = <span class="number">1000</span> <span class="comment">//全局配置请求时长1s</span></span><br></pre></td></tr></table></figure><h3 id="2-实例配置"><a href="#2-实例配置" class="headerlink" title="2.实例配置"></a>2.实例配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> instance = axios.create(</span><br><span class="line">    <span class="comment">//基本配置方法</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果设置了全局的配置方法，而实例配置中没有设置相应的方法，则延用全局的方法，否则，以实例中的方法为主。</p><h3 id="3-axios请求配置"><a href="#3-axios请求配置" class="headerlink" title="3.axios请求配置"></a>3.axios请求配置</h3><p>视具体情况而定，如调用某个路径的文件巨大，我们可以单独对其请求时长进行设置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance.get(<span class="string">&#x27;/data.json&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">timeout</span>:<span class="number">5000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优先级<strong>：请求配置 &gt; 实例配置 &gt; 全局配置</strong></p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>在发起请求前做一些处理，再发起请求后再做一些处理。</p><p>分为请求拦截器和响应拦截器</p><h3 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(</span><br><span class="line">    <span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//在发送请求前做些什么</span></span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 在请求错误的时候做些什么（此处错误，请求没有到后端）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)<span class="comment">//这里返回一个promise对象</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(</span><br><span class="line">    <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//请求成功对响应数据进行处理</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//响应错误做些什么（此处错误，到达后端后返回）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>两者都在响应错误后进行了promise对象的返回，具体的作用是什么呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.get().then().catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>这一段代码是我们平时发送get请求时的标准形态，then会执行请求成功后的操作，catch用来捕获错误。</p><p>我们前面拦截响应后，无论是请求还是响应的拦截器，他们的err返回的promise都会进入catch中。</p><h3 id="取消拦截器（了解即可）"><a href="#取消拦截器（了解即可）" class="headerlink" title="取消拦截器（了解即可）"></a>取消拦截器（了解即可）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> inerceptors = axios.interceptors.request.use</span><br><span class="line">(<span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">    config.header = &#123;</span><br><span class="line">        <span class="attr">auth</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line">axios.inerceptors.request.eject(interceptors) <span class="comment">//用axios全局去调用interceptors，这样就取消拦截了。。。</span></span><br></pre></td></tr></table></figure><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>通过拦截器控制登陆状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登陆状态,有token</span></span><br><span class="line"><span class="keyword">let</span> request = axios.create(&#123;&#125;)</span><br><span class="line">request.interceptors.request.use</span><br><span class="line">(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.headers.token = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 非登陆状态，无token </span></span><br><span class="line"><span class="keyword">let</span> request2 = axios.create(&#123;&#125;)</span><br></pre></td></tr></table></figure><p>有token的可以访问更多，get更多的数据，无token则不行。类似于评论需要登陆</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="表现形式-1"><a href="#表现形式-1" class="headerlink" title="表现形式"></a>表现形式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先设置拦截器</span></span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">    <span class="function"><span class="params">config</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">    &#125;,<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">    <span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;,<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的获取</span></span><br><span class="line">axios.get(<span class="string">&#x27;/data.json&#x27;</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">//所有错误处理都会进入此处</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>具体的实践过程中，我们需要创建一个统一的错误处理，将所有的错误类型都放在拦截其中，方便我们后面调用接口时使用。</p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个请求实例</span></span><br><span class="line"><span class="keyword">let</span> instance = axios.create(&#123;&#125;)</span><br><span class="line"><span class="comment">//为请求实例添加请求拦截器</span></span><br><span class="line">instance.interceptors.request.use(</span><br><span class="line">    <span class="function"><span class="params">config</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">    &#125;,<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//请求错误 一般http状态码以4开头，常见：401超时，404 not found 多为前端浏览器错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">instance.interceptors.response.use(</span><br><span class="line">    <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;,<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//响应错误,一般http状态码以5开头，500系统错误，502系统重启等，偏向于服务端返回的报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">instance.get(<span class="string">&#x27;data&#x27;</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Axios的理解与使用&quot;&gt;&lt;a href=&quot;#Axios的理解与使用&quot; class=&quot;headerlink&quot; title=&quot;Axios的理解与使用&quot;&gt;&lt;/a&gt;Axios的理解与使用&lt;/h1&gt;&lt;h2 id=&quot;axios-是什么&quot;&gt;&lt;a href=&quot;#axios-是什</summary>
      
    
    
    
    <category term="前端" scheme="https://lesliewaong.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Ajax" scheme="https://lesliewaong.top/tags/Ajax/"/>
    
    <category term="Axios" scheme="https://lesliewaong.top/tags/Axios/"/>
    
  </entry>
  
  <entry>
    <title>Axios+TS</title>
    <link href="https://lesliewaong.top/posts/a2c0335.html"/>
    <id>https://lesliewaong.top/posts/a2c0335.html</id>
    <published>2022-07-03T08:46:47.000Z</published>
    <updated>2022-07-17T08:40:25.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript实战之用TS封装Axios"><a href="#TypeScript实战之用TS封装Axios" class="headerlink" title="TypeScript实战之用TS封装Axios"></a>TypeScript实战之用TS封装Axios</h1><h2 id="Axios几个常用类型"><a href="#Axios几个常用类型" class="headerlink" title="Axios几个常用类型"></a>Axios几个常用类型</h2><p>在使用<code>TypeScript</code>封装<code>Axios</code>之前我们先来看看<code>Axios</code>几个重要的类型。</p><h3 id="AxiosRequestConfig"><a href="#AxiosRequestConfig" class="headerlink" title="AxiosRequestConfig"></a>AxiosRequestConfig</h3><p><code>AxiosRequestConfig</code>是我们使用<code>axios</code>发送请求传递参数的类型。当然它也是我们请求拦截器里面的参数类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios(config: AxiosRequestConfig)</span><br></pre></td></tr></table></figure><p>可以看到，这个<code>config</code>里面的参数还是挺多的。我们常用的有<code>url、method、params、data、headers、baseURL、timeout</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AxiosRequestConfig &#123;</span><br><span class="line">  url?: <span class="built_in">string</span>;</span><br><span class="line">  method?: Method;</span><br><span class="line">  baseURL?: <span class="built_in">string</span>;</span><br><span class="line">  transformRequest?: AxiosTransformer | AxiosTransformer[];</span><br><span class="line">  transformResponse?: AxiosTransformer | AxiosTransformer[];</span><br><span class="line">  headers?: <span class="built_in">any</span>;</span><br><span class="line">  params?: <span class="built_in">any</span>;</span><br><span class="line">  paramsSerializer?: <span class="function">(<span class="params">params: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">  data?: <span class="built_in">any</span>;</span><br><span class="line">  timeout?: <span class="built_in">number</span>;</span><br><span class="line">  timeoutErrorMessage?: <span class="built_in">string</span>;</span><br><span class="line">  withCredentials?: <span class="built_in">boolean</span>;</span><br><span class="line">  adapter?: AxiosAdapter;</span><br><span class="line">  auth?: AxiosBasicCredentials;</span><br><span class="line">  responseType?: ResponseType;</span><br><span class="line">  xsrfCookieName?: <span class="built_in">string</span>;</span><br><span class="line">  xsrfHeaderName?: <span class="built_in">string</span>;</span><br><span class="line">  onUploadProgress?: <span class="function">(<span class="params">progressEvent: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  onDownloadProgress?: <span class="function">(<span class="params">progressEvent: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  maxContentLength?: <span class="built_in">number</span>;</span><br><span class="line">  validateStatus?: (<span class="function">(<span class="params">status: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">boolean</span>) | <span class="literal">null</span>;</span><br><span class="line">  maxBodyLength?: <span class="built_in">number</span>;</span><br><span class="line">  maxRedirects?: <span class="built_in">number</span>;</span><br><span class="line">  socketPath?: <span class="built_in">string</span> | <span class="literal">null</span>;</span><br><span class="line">  httpAgent?: <span class="built_in">any</span>;</span><br><span class="line">  httpsAgent?: <span class="built_in">any</span>;</span><br><span class="line">  proxy?: AxiosProxyConfig | <span class="literal">false</span>;</span><br><span class="line">  cancelToken?: CancelToken;</span><br><span class="line">  decompress?: <span class="built_in">boolean</span>;</span><br><span class="line">  transitional?: TransitionalOptions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AxiosInstance"><a href="#AxiosInstance" class="headerlink" title="AxiosInstance"></a>AxiosInstance</h3><p><code>AxiosInstance</code>是我们使用<code>axios</code>实例对象类型。</p><p>我们使用<code>axios.create(config?: AxiosRequestConfig)</code>创建出来的对象都是<code>AxiosInstance</code>类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AxiosInstance &#123;</span><br><span class="line">  (config: AxiosRequestConfig): AxiosPromise;</span><br><span class="line">  (url: <span class="built_in">string</span>, config?: AxiosRequestConfig): AxiosPromise;</span><br><span class="line">  defaults: AxiosRequestConfig;</span><br><span class="line">  interceptors: &#123;</span><br><span class="line">    <span class="attr">request</span>: AxiosInterceptorManager&lt;AxiosRequestConfig&gt;;</span><br><span class="line">    response: AxiosInterceptorManager&lt;AxiosResponse&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">  getUri(config?: AxiosRequestConfig): <span class="built_in">string</span>;</span><br><span class="line">  request&lt;T = <span class="built_in">any</span>, R = AxiosResponse&lt;T&gt;&gt; (config: AxiosRequestConfig): <span class="built_in">Promise</span>&lt;R&gt;;</span><br><span class="line">  get&lt;T = <span class="built_in">any</span>, R = AxiosResponse&lt;T&gt;&gt;(url: <span class="built_in">string</span>, config?: AxiosRequestConfig): <span class="built_in">Promise</span>&lt;R&gt;;</span><br><span class="line">  <span class="keyword">delete</span>&lt;T = <span class="built_in">any</span>, R = AxiosResponse&lt;T&gt;&gt;(url: <span class="built_in">string</span>, config?: AxiosRequestConfig): <span class="built_in">Promise</span>&lt;R&gt;;</span><br><span class="line">  head&lt;T = <span class="built_in">any</span>, R = AxiosResponse&lt;T&gt;&gt;(url: <span class="built_in">string</span>, config?: AxiosRequestConfig): <span class="built_in">Promise</span>&lt;R&gt;;</span><br><span class="line">  options&lt;T = <span class="built_in">any</span>, R = AxiosResponse&lt;T&gt;&gt;(url: <span class="built_in">string</span>, config?: AxiosRequestConfig): <span class="built_in">Promise</span>&lt;R&gt;;</span><br><span class="line">  post&lt;T = <span class="built_in">any</span>, R = AxiosResponse&lt;T&gt;&gt;(url: <span class="built_in">string</span>, data?: <span class="built_in">any</span>, config?: AxiosRequestConfig): <span class="built_in">Promise</span>&lt;R&gt;;</span><br><span class="line">  put&lt;T = <span class="built_in">any</span>, R = AxiosResponse&lt;T&gt;&gt;(url: <span class="built_in">string</span>, data?: <span class="built_in">any</span>, config?: AxiosRequestConfig): <span class="built_in">Promise</span>&lt;R&gt;;</span><br><span class="line">  patch&lt;T = <span class="built_in">any</span>, R = AxiosResponse&lt;T&gt;&gt;(url: <span class="built_in">string</span>, data?: <span class="built_in">any</span>, config?: AxiosRequestConfig): <span class="built_in">Promise</span>&lt;R&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，我们可以使用<code>axios.create、axios.all、axios.spread</code>方法，但是<code>AxiosInstance</code> 上并没有<code>create、all、spread</code>等方法，那我们的<code>axios</code>到底是什么类型呢？</p><h3 id="AxiosStatic"><a href="#AxiosStatic" class="headerlink" title="AxiosStatic"></a>AxiosStatic</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AxiosStatic <span class="keyword">extends</span> AxiosInstance &#123;</span><br><span class="line">  create(config?: AxiosRequestConfig): AxiosInstance;</span><br><span class="line">  Cancel: CancelStatic;</span><br><span class="line">  CancelToken: CancelTokenStatic;</span><br><span class="line">  isCancel(value: <span class="built_in">any</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  all&lt;T&gt;(values: (T | <span class="built_in">Promise</span>&lt;T&gt;)[]): <span class="built_in">Promise</span>&lt;T[]&gt;;</span><br><span class="line">  spread&lt;T, R&gt;(callback: <span class="function">(<span class="params">...args: T[]</span>) =&gt;</span> R): <span class="function">(<span class="params">array: T[]</span>) =&gt;</span> R;</span><br><span class="line">  isAxiosError(payload: <span class="built_in">any</span>): payload is AxiosError;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> axios: AxiosStatic;</span><br></pre></td></tr></table></figure><p>可以发现，<code>axios</code>其实是<code>AxiosStatic</code>类型，并且继承了<code>AxiosInstance</code>类型。所以是两者的结合。</p><p>相较<code>axios.create(config?: AxiosRequestConfig)</code>创建出来的实例对象，<code>axios</code>功能是更强大的。</p><h3 id="AxiosResponse"><a href="#AxiosResponse" class="headerlink" title="AxiosResponse"></a>AxiosResponse</h3><p><code>AxiosResponse</code>是非常重要的，我们的<code>axios</code>请求返回值类型都是<code>AxiosResponse</code>类型。</p><p>并且我们可以发现<code>AxiosResponse</code>是一个接口泛型，这个泛型会应用到后端返回的<code>data</code>上。所以这块我们可以根据后端接口返回定义不同的类型传递进去。</p><p>后面笔者在封装常用方法的时候会细说。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AxiosResponse&lt;T = any&gt;  &#123;</span><br><span class="line">  <span class="attr">data</span>: T;</span><br><span class="line">  status: <span class="built_in">number</span>;</span><br><span class="line">  statusText: <span class="built_in">string</span>;</span><br><span class="line">  headers: <span class="built_in">any</span>;</span><br><span class="line">  config: AxiosRequestConfig;</span><br><span class="line">  request?: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AxiosError"><a href="#AxiosError" class="headerlink" title="AxiosError"></a>AxiosError</h3><p><code>AxiosError</code>这个类型也是我们必须要知道的。在我们响应拦截器里面的错误就是<code>AxiosError</code>类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AxiosError&lt;T = any&gt; <span class="keyword">extends</span> Error &#123;</span><br><span class="line">  <span class="attr">config</span>: AxiosRequestConfig;</span><br><span class="line">  code?: <span class="built_in">string</span>;</span><br><span class="line">  request?: <span class="built_in">any</span>;</span><br><span class="line">  response?: AxiosResponse&lt;T&gt;;</span><br><span class="line">  isAxiosError: <span class="built_in">boolean</span>;</span><br><span class="line">  toJSON: <span class="function">() =&gt;</span> <span class="built_in">object</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说完了<code>Axios</code>的几个常用类型，接下来我们正式开始使用<code>TS</code>来封装我们的<code>Axios</code>。</p><h2 id="基础封装"><a href="#基础封装" class="headerlink" title="基础封装"></a>基础封装</h2><p>首先我们实现一个最基本的版本，实例代码如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; AxiosInstance, AxiosRequestConfig, AxiosResponse &#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">  <span class="comment">// axios 实例</span></span><br><span class="line">  <span class="attr">instance</span>: AxiosInstance</span><br><span class="line">  <span class="comment">// 基础配置，url和超时时间</span></span><br><span class="line">  <span class="attr">baseConfig</span>: AxiosRequestConfig = &#123;<span class="attr">baseURL</span>: <span class="string">&quot;/api&quot;</span>, <span class="attr">timeout</span>: <span class="number">60000</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">config: AxiosRequestConfig</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用axios.create创建axios实例</span></span><br><span class="line">    <span class="built_in">this</span>.instance = axios.create(<span class="built_in">Object</span>.assign(<span class="built_in">this</span>.baseConfig, config))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 定义请求方法</span></span><br><span class="line">  <span class="keyword">public</span> request(config: AxiosRequestConfig): <span class="built_in">Promise</span>&lt;AxiosResponse&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.instance.request(config)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Request</span><br></pre></td></tr></table></figure><p>在实际项目中有了基本的请求方法还是远远不够的，我们还需要封装拦截器和一些常用方法。</p><h2 id="拦截器封装"><a href="#拦截器封装" class="headerlink" title="拦截器封装"></a>拦截器封装</h2><p>拦截器封装只需要在类中对<code>axios.create()</code>创建的实例调用<code>interceptors</code>下的两个拦截器即可，实例代码如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">config: AxiosRequestConfig</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.instance = axios.create(<span class="built_in">Object</span>.assign(<span class="built_in">this</span>.baseConfig, config))</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">this</span>.instance.interceptors.request.use(</span><br><span class="line">    <span class="function">(<span class="params">config: AxiosRequestConfig</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 一般会请求拦截里面加token</span></span><br><span class="line">      <span class="keyword">const</span> token = <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;token&quot;</span>) <span class="keyword">as</span> <span class="built_in">string</span></span><br><span class="line">      config.headers!.Authorization = token;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> config</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">err: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">    &#125;,</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">this</span>.instance.interceptors.response.use(</span><br><span class="line">    <span class="function">(<span class="params">res: AxiosResponse</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 直接返回res，当然你也可以只返回res.data</span></span><br><span class="line">      <span class="comment">// 系统如果有自定义code也可以在这里处理</span></span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">err: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 这里用来处理http常见错误，进行全局提示</span></span><br><span class="line">      <span class="keyword">let</span> message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">switch</span> (err.response.status) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">          message = <span class="string">&quot;请求错误(400)&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">          message = <span class="string">&quot;未授权，请重新登录(401)&quot;</span>;</span><br><span class="line">          <span class="comment">// 这里可以做清空storage并跳转到登录页的操作</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">          message = <span class="string">&quot;拒绝访问(403)&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">          message = <span class="string">&quot;请求出错(404)&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">408</span>:</span><br><span class="line">          message = <span class="string">&quot;请求超时(408)&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">          message = <span class="string">&quot;服务器错误(500)&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">501</span>:</span><br><span class="line">          message = <span class="string">&quot;服务未实现(501)&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">502</span>:</span><br><span class="line">          message = <span class="string">&quot;网络错误(502)&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">503</span>:</span><br><span class="line">          message = <span class="string">&quot;服务不可用(503)&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">504</span>:</span><br><span class="line">          message = <span class="string">&quot;网络超时(504)&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">505</span>:</span><br><span class="line">          message = <span class="string">&quot;HTTP版本不受支持(505)&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          message = <span class="string">`连接出错(<span class="subst">$&#123;err.response.status&#125;</span>)!`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这里错误消息可以使用全局弹框展示出来</span></span><br><span class="line">      <span class="comment">// 比如element plus 可以使用 ElMessage</span></span><br><span class="line">      <span class="comment">// ElMessage(&#123;</span></span><br><span class="line">      <span class="comment">//   showClose: true,</span></span><br><span class="line">      <span class="comment">//   message: `$&#123;message&#125;，请检查网络或联系管理员！`,</span></span><br><span class="line">      <span class="comment">//   type: &quot;error&quot;,</span></span><br><span class="line">      <span class="comment">// &#125;);</span></span><br><span class="line">      <span class="comment">// 这里是AxiosError类型，所以一般我们只reject我们需要的响应即可</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err.response)</span><br><span class="line">    &#125;,</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们分别对请求拦截器和响应拦截器做了处理。</p><p>在请求拦截器我们给请求头添加了<code>token</code>。</p><p>在响应拦截器，我们返回了整个<code>response</code>对象，当然你也可以只返回后端返回的<code>response.data</code>，这里可以根据个人喜好来处理。其次对<code>http</code>错误进行了全局处理。</p><h2 id="常用方法封装"><a href="#常用方法封装" class="headerlink" title="常用方法封装"></a>常用方法封装</h2><p>在基础封装的时候我们封装了一个<code>request</code>通用方法，其实我们还可以更具体的封装<code>get、post、put、delete</code>方法，让我们使用更方便。</p><p>并且，我们前面分析到，<code>AxiosResponse</code>其实是一个泛型接口，他可以接受一个泛型并应用到我们的<code>data</code>上。所以我们可以在这里再定义一个后端通用返回的数据类型。</p><p>比如假设我们某个项目后端接口不管请求成功与失败，返回的结构永远是<code>code、message、results</code>的话我们可以定义一个这样的数据类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Result&lt;T&gt; = &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">message</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">result</span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后传递个各个方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> get&lt;T = <span class="built_in">any</span>&gt;(</span><br><span class="line">  url: <span class="built_in">string</span>, </span><br><span class="line">  config?: AxiosRequestConfig</span><br><span class="line">): <span class="built_in">Promise</span>&lt;AxiosResponse&lt;Result&lt;T&gt;&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.instance.get(url, config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> post&lt;T = <span class="built_in">any</span>&gt;(</span><br><span class="line">  url: <span class="built_in">string</span>,</span><br><span class="line">  data?: <span class="built_in">any</span>,</span><br><span class="line">  config?: AxiosRequestConfig</span><br><span class="line">): <span class="built_in">Promise</span>&lt;AxiosResponse&lt;Result&lt;T&gt;&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.instance.post(url, data, config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> put&lt;T = <span class="built_in">any</span>&gt;(</span><br><span class="line">  url: <span class="built_in">string</span>,</span><br><span class="line">  data?: <span class="built_in">any</span>,</span><br><span class="line">  config?: AxiosRequestConfig</span><br><span class="line">): <span class="built_in">Promise</span>&lt;AxiosResponse&lt;Result&lt;T&gt;&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.instance.put(url, data, config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">delete</span>&lt;T = <span class="built_in">any</span>&gt;(</span><br><span class="line">  url: <span class="built_in">string</span>,</span><br><span class="line">  config?: AxiosRequestConfig</span><br><span class="line">): <span class="built_in">Promise</span>&lt;AxiosResponse&lt;Result&lt;T&gt;&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.instance.delete(url, config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当我们调用接口的时候就可以看到我们返回的<code>data</code>的类型啦。就是我们定义的<code>Result</code>类型。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91bc8bd77ee04d5894e32b520cc462fc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>所以我们可以直接得到自动提示</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b3c21a67fd24ad09215b361104ae89a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>上面调用接口的时候并没有传递接口数据类型，所以我们的<code>result</code>是<code>any</code>类型，要想要每个接口都有类型提示，我们还需要给方法传递泛型。</p><p>我们再改进下，我们再定义一个<code>login</code>接口返回值类型<code>loginType</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> loginType = &#123;</span><br><span class="line">  <span class="attr">token</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后再调用方法的地方传递进去，然后我们再看看返回值<code>data</code>的类型。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f680681572e4f8da5025179ff2a4a44~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>可以看到他是<code>Result&lt;loginType&gt;</code>类型，这个<code>loginType</code>就是<code>result</code>的类型。</p><p>所以我们的<code>result</code>还可以进一步的得到提示</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0c75682186f4549a583eca37029c5f7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>当然每个接口都定义返回值类型固然好，但是会大大加大前端的工作量。我们在写请求方法的时候也可以不传递接口返回值类型，这样<code>result</code>的类型就是<code>any</code>。这个可以根据自身项目需求来选择使用。</p><p>看到这小伙伴们是不是都弄懂了呢？如还有疑问欢迎留言。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说了这么多，有些小伙伴们可能有点晕了，下面笔者分享下整个<code>axios</code>的封装。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; AxiosInstance, AxiosRequestConfig, AxiosResponse &#125; <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result&lt;T&gt; = &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="built_in">number</span>;</span><br><span class="line">  message: <span class="built_in">string</span>;</span><br><span class="line">  result: T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">  <span class="comment">// axios 实例</span></span><br><span class="line">  <span class="attr">instance</span>: AxiosInstance;</span><br><span class="line">  <span class="comment">// 基础配置，url和超时时间</span></span><br><span class="line">  baseConfig: AxiosRequestConfig = &#123; <span class="attr">baseURL</span>: <span class="string">&quot;/api&quot;</span>, <span class="attr">timeout</span>: <span class="number">60000</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">config: AxiosRequestConfig</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用axios.create创建axios实例</span></span><br><span class="line">    <span class="built_in">this</span>.instance = axios.create(<span class="built_in">Object</span>.assign(<span class="built_in">this</span>.baseConfig, config));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.instance.interceptors.request.use(</span><br><span class="line">      <span class="function">(<span class="params">config: AxiosRequestConfig</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 一般会请求拦截里面加token</span></span><br><span class="line">        <span class="keyword">const</span> token = <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;token&quot;</span>) <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">        config.headers!.Authorization = token;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function">(<span class="params">err: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.instance.interceptors.response.use(</span><br><span class="line">      <span class="function">(<span class="params">res: AxiosResponse</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 直接返回res，当然你也可以只返回res.data</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function">(<span class="params">err: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里用来处理http常见错误，进行全局提示</span></span><br><span class="line">        <span class="keyword">let</span> message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (err.response.status) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">            message = <span class="string">&quot;请求错误(400)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">            message = <span class="string">&quot;未授权，请重新登录(401)&quot;</span>;</span><br><span class="line">            <span class="comment">// 这里可以做清空storage并跳转到登录页的操作</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">            message = <span class="string">&quot;拒绝访问(403)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">            message = <span class="string">&quot;请求出错(404)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">408</span>:</span><br><span class="line">            message = <span class="string">&quot;请求超时(408)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">            message = <span class="string">&quot;服务器错误(500)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">501</span>:</span><br><span class="line">            message = <span class="string">&quot;服务未实现(501)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">502</span>:</span><br><span class="line">            message = <span class="string">&quot;网络错误(502)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">503</span>:</span><br><span class="line">            message = <span class="string">&quot;服务不可用(503)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">504</span>:</span><br><span class="line">            message = <span class="string">&quot;网络超时(504)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">505</span>:</span><br><span class="line">            message = <span class="string">&quot;HTTP版本不受支持(505)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            message = <span class="string">`连接出错(<span class="subst">$&#123;err.response.status&#125;</span>)!`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里错误消息可以使用全局弹框展示出来</span></span><br><span class="line">        <span class="comment">// 比如element plus 可以使用 ElMessage</span></span><br><span class="line">        <span class="comment">// ElMessage(&#123;</span></span><br><span class="line">        <span class="comment">//   showClose: true,</span></span><br><span class="line">        <span class="comment">//   message: `$&#123;message&#125;，请检查网络或联系管理员！`,</span></span><br><span class="line">        <span class="comment">//   type: &quot;error&quot;,</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="comment">// 这里是AxiosError类型，所以一般我们只reject我们需要的响应即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err.response);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义请求方法</span></span><br><span class="line">  <span class="keyword">public</span> request(config: AxiosRequestConfig): <span class="built_in">Promise</span>&lt;AxiosResponse&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.instance.request(config);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> get&lt;T = <span class="built_in">any</span>&gt;(</span><br><span class="line">    url: <span class="built_in">string</span>,</span><br><span class="line">    config?: AxiosRequestConfig</span><br><span class="line">  ): <span class="built_in">Promise</span>&lt;AxiosResponse&lt;Result&lt;T&gt;&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.instance.get(url, config);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> post&lt;T = <span class="built_in">any</span>&gt;(</span><br><span class="line">    url: <span class="built_in">string</span>,</span><br><span class="line">    data?: <span class="built_in">any</span>,</span><br><span class="line">    config?: AxiosRequestConfig</span><br><span class="line">  ): <span class="built_in">Promise</span>&lt;AxiosResponse&lt;Result&lt;T&gt;&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.instance.post(url, data, config);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> put&lt;T = <span class="built_in">any</span>&gt;(</span><br><span class="line">    url: <span class="built_in">string</span>,</span><br><span class="line">    data?: <span class="built_in">any</span>,</span><br><span class="line">    config?: AxiosRequestConfig</span><br><span class="line">  ): <span class="built_in">Promise</span>&lt;AxiosResponse&lt;Result&lt;T&gt;&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.instance.put(url, data, config);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">delete</span>&lt;T = <span class="built_in">any</span>&gt;(</span><br><span class="line">    url: <span class="built_in">string</span>,</span><br><span class="line">    config?: AxiosRequestConfig</span><br><span class="line">  ): <span class="built_in">Promise</span>&lt;AxiosResponse&lt;Result&lt;T&gt;&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.instance.delete(url, config);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Request;</span><br></pre></td></tr></table></figure><h1 id="十分钟封装一个好用的axios"><a href="#十分钟封装一个好用的axios" class="headerlink" title="十分钟封装一个好用的axios"></a>十分钟封装一个好用的axios</h1><h2 id="通用能力"><a href="#通用能力" class="headerlink" title="通用能力"></a>通用能力</h2><p>列一下我想要这个通用请求能达到什么样的效果</p><ul><li><p>正常请求该有的（<strong>跨域携带cookie，token，超时设置</strong>）</p></li><li><p>请求响应拦截器</p><ul><li><p>请求成功，业务状态码200，解析result给我，我不想一层一层的去判断拿数据</p></li><li><p><strong>http请求200， 业务状态码非200，说明逻辑判断这是不成功的，那就全局message提示服务端的报错</strong></p></li><li><p><strong>http请求非200， 说明http请求都有问题，也全局message提示报错</strong></p></li><li><p>http请求或者业务状态码<code>401</code>都做<strong>注销</strong>操作</p></li></ul></li><li><p>全局的loading配置, 默认开启，可配置关闭（由于后端的问题，经常会让前端加防抖节流或者loading不让用户在界面上疯狂乱点，行吧行吧，你们的问题前端帮你们解决，你的规矩就是规矩是吧）</p></li><li><p>统一文件下载处理 （不要再去各写各的下载了，你写一个，他写一个，一个项目就是这样整的跟屎一样）</p></li></ul><h2 id="一步一步添加功能实现"><a href="#一步一步添加功能实现" class="headerlink" title="一步一步添加功能实现"></a>一步一步添加功能实现</h2><p>正常请求该有的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios, &#123; AxiosInstance, AxiosRequestConfig &#125; <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createAxiosByinterceptors = (</span><br><span class="line">    config?: AxiosRequestConfig</span><br><span class="line">): <span class="function"><span class="params">AxiosInstance</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">1000</span>,    <span class="comment">//超时配置</span></span><br><span class="line">    <span class="attr">withCredentials</span>: <span class="literal">true</span>,  <span class="comment">//跨域携带cookie</span></span><br><span class="line">    ...config,   <span class="comment">// 自定义配置覆盖基本配置</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>请求响应拦截器</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios, &#123; AxiosInstance, AxiosRequestConfig &#125; <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Message &#125; <span class="keyword">from</span> <span class="string">&quot;element-ui&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; jumpLogin &#125; <span class="keyword">from</span> <span class="string">&quot;@/utils&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createAxiosByinterceptors = (</span><br><span class="line">    config?: AxiosRequestConfig</span><br><span class="line">): <span class="function"><span class="params">AxiosInstance</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">1000</span>,    <span class="comment">//超时配置</span></span><br><span class="line">    <span class="attr">withCredentials</span>: <span class="literal">true</span>,  <span class="comment">//跨域携带cookie</span></span><br><span class="line">    ...config,   <span class="comment">// 自定义配置覆盖基本配置</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">instance.interceptors.request.use(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">config: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;config:&quot;</span>, config);</span><br><span class="line">        <span class="comment">// config.headers.Authorization = vm.$Cookies.get(&quot;vue_admin_token&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">instance.interceptors.response.use(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;response:&quot;</span>, response);</span><br><span class="line">        <span class="keyword">const</span> &#123; code, data, message &#125; = response.data;</span><br><span class="line">        <span class="keyword">if</span> (code === <span class="number">200</span>) <span class="keyword">return</span> data;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">401</span>) &#123;</span><br><span class="line">            jumpLogin();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message.error(message);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(response.data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;error-response:&quot;</span>, error.response);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;error-config:&quot;</span>, error.config);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;error-request:&quot;</span>, error.request);</span><br><span class="line">        <span class="keyword">if</span> (error.response) &#123;</span><br><span class="line">            <span class="keyword">if</span> (error.response.status === <span class="number">401</span>) &#123;</span><br><span class="line">                jumpLogin();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Message.error(error?.response?.data?.message || <span class="string">&quot;服务端异常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>全局的loading配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios, &#123; AxiosInstance, AxiosRequestConfig &#125; <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Message &#125; <span class="keyword">from</span> <span class="string">&quot;element-ui&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; jumpLogin &#125; <span class="keyword">from</span> <span class="string">&quot;@/utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Loading &#125; <span class="keyword">from</span> <span class="string">&quot;element-ui&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ElLoadingComponent &#125; <span class="keyword">from</span> <span class="string">&quot;element-ui/types/loading&quot;</span>;</span><br><span class="line"><span class="comment">// import vm from &quot;@/main&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loadingInstance: ElLoadingComponent | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> requestNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addLoading = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 增加loading 如果pending请求数量等于1，弹出loading, 防止重复弹出</span></span><br><span class="line">  requestNum++;</span><br><span class="line">  <span class="keyword">if</span> (requestNum == <span class="number">1</span>) &#123;</span><br><span class="line">    loadingInstance = Loading.service(&#123;</span><br><span class="line">      <span class="attr">text</span>: <span class="string">&quot;正在努力加载中....&quot;</span>,</span><br><span class="line">      <span class="attr">background</span>: <span class="string">&quot;rgba(0, 0, 0, 0)&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cancelLoading = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 取消loading 如果pending请求数量等于0，关闭loading</span></span><br><span class="line">  requestNum--;</span><br><span class="line">  <span class="keyword">if</span> (requestNum === <span class="number">0</span>) loadingInstance?.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createAxiosByinterceptors = (</span><br><span class="line">  config?: AxiosRequestConfig</span><br><span class="line">): <span class="function"><span class="params">AxiosInstance</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">1000</span>,    <span class="comment">//超时配置</span></span><br><span class="line">    <span class="attr">withCredentials</span>: <span class="literal">true</span>,  <span class="comment">//跨域携带cookie</span></span><br><span class="line">    ...config,   <span class="comment">// 自定义配置覆盖基本配置</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加请求拦截器</span></span><br><span class="line">  instance.interceptors.request.use(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">config: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">      <span class="keyword">const</span> &#123; loading = <span class="literal">true</span> &#125; = config;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;config:&quot;</span>, config);</span><br><span class="line">      <span class="comment">// config.headers.Authorization = vm.$Cookies.get(&quot;vue_admin_token&quot;);</span></span><br><span class="line">      <span class="keyword">if</span> (loading) addLoading();</span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加响应拦截器</span></span><br><span class="line">  instance.interceptors.response.use(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;response:&quot;</span>, response);</span><br><span class="line">      <span class="keyword">const</span> &#123; loading = <span class="literal">true</span> &#125; = response.config;</span><br><span class="line">      <span class="keyword">if</span> (loading) cancelLoading();</span><br><span class="line">      <span class="keyword">const</span> &#123; code, data, message &#125; = response.data;</span><br><span class="line">      <span class="keyword">if</span> (code === <span class="number">200</span>) <span class="keyword">return</span> data;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">401</span>) &#123;</span><br><span class="line">        jumpLogin();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         Message.error(message);</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(response.data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;error-response:&quot;</span>, error.response);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;error-config:&quot;</span>, error.config);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;error-request:&quot;</span>, error.request);</span><br><span class="line">      <span class="keyword">const</span> &#123; loading = <span class="literal">true</span> &#125; = error.config;</span><br><span class="line">      <span class="keyword">if</span> (loading) cancelLoading();</span><br><span class="line">      <span class="keyword">if</span> (error.response) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error.response.status === <span class="number">401</span>) &#123;</span><br><span class="line">          jumpLogin();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Message.error(error?.response?.data?.message || <span class="string">&quot;服务端异常&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>统一文件下载处理</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios, &#123; AxiosInstance, AxiosRequestConfig &#125; <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Message &#125; <span class="keyword">from</span> <span class="string">&quot;element-ui&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; jumpLogin, downloadFile &#125; <span class="keyword">from</span> <span class="string">&quot;@/utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Loading &#125; <span class="keyword">from</span> <span class="string">&quot;element-ui&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ElLoadingComponent &#125; <span class="keyword">from</span> <span class="string">&quot;element-ui/types/loading&quot;</span>;</span><br><span class="line"><span class="comment">// import vm from &quot;@/main&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loadingInstance: ElLoadingComponent | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> requestNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addLoading = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 增加loading 如果pending请求数量等于1，弹出loading, 防止重复弹出</span></span><br><span class="line">  requestNum++;</span><br><span class="line">  <span class="keyword">if</span> (requestNum == <span class="number">1</span>) &#123;</span><br><span class="line">    loadingInstance = Loading.service(&#123;</span><br><span class="line">      <span class="attr">text</span>: <span class="string">&quot;正在努力加载中....&quot;</span>,</span><br><span class="line">      <span class="attr">background</span>: <span class="string">&quot;rgba(0, 0, 0, 0)&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cancelLoading = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 取消loading 如果pending请求数量等于0，关闭loading</span></span><br><span class="line">  requestNum--;</span><br><span class="line">  <span class="keyword">if</span> (requestNum === <span class="number">0</span>) loadingInstance?.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createAxiosByinterceptors = (</span><br><span class="line">  config?: AxiosRequestConfig</span><br><span class="line">): <span class="function"><span class="params">AxiosInstance</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">1000</span>,    <span class="comment">//超时配置</span></span><br><span class="line">    <span class="attr">withCredentials</span>: <span class="literal">true</span>,  <span class="comment">//跨域携带cookie</span></span><br><span class="line">    ...config,   <span class="comment">// 自定义配置覆盖基本配置</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加请求拦截器</span></span><br><span class="line">  instance.interceptors.request.use(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">config: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">      <span class="keyword">const</span> &#123; loading = <span class="literal">true</span> &#125; = config;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;config:&quot;</span>, config);</span><br><span class="line">      <span class="comment">// config.headers.Authorization = vm.$Cookies.get(&quot;vue_admin_token&quot;);</span></span><br><span class="line">      <span class="keyword">if</span> (loading) addLoading();</span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加响应拦截器</span></span><br><span class="line">  instance.interceptors.response.use(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;response:&quot;</span>, response);</span><br><span class="line">      <span class="keyword">const</span> &#123; loading = <span class="literal">true</span> &#125; = response.config;</span><br><span class="line">      <span class="keyword">if</span> (loading) cancelLoading();</span><br><span class="line">      <span class="keyword">const</span> &#123; code, data, message &#125; = response.data;</span><br><span class="line">      <span class="comment">// config设置responseType为blob 处理文件下载</span></span><br><span class="line">      <span class="keyword">if</span> (response.data <span class="keyword">instanceof</span> Blob) &#123;</span><br><span class="line">        <span class="keyword">return</span> downloadFile(response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (code === <span class="number">200</span>) <span class="keyword">return</span> data;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">401</span>) &#123;</span><br><span class="line">          jumpLogin();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Message.error(message);</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(response.data);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;error-response:&quot;</span>, error.response);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;error-config:&quot;</span>, error.config);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;error-request:&quot;</span>, error.request);</span><br><span class="line">      <span class="keyword">const</span> &#123; loading = <span class="literal">true</span> &#125; = error.config;</span><br><span class="line">      <span class="keyword">if</span> (loading) cancelLoading();</span><br><span class="line">      <span class="keyword">if</span> (error.response) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error.response.status === <span class="number">401</span>) &#123;</span><br><span class="line">          jumpLogin();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Message.error(error?.response?.data?.message || <span class="string">&quot;服务端异常&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">src/utils/index.ts</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Message &#125; <span class="keyword">from</span> <span class="string">&quot;element-ui&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AxiosResponse &#125; <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> vm <span class="keyword">from</span> <span class="string">&quot;@/main&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   跳转登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> jumpLogin = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  vm.$Cookies.remove(<span class="string">&quot;vue_admin_token&quot;</span>);</span><br><span class="line">  vm.$router.push(<span class="string">`/login?redirect=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(vm.$route.fullPath)&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">response</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> downloadFile = <span class="function">(<span class="params">response: AxiosResponse</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;response.data.type:&quot;</span>, response.data.type);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fileReader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    fileReader.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;result:&quot;</span>, <span class="built_in">this</span>.result);</span><br><span class="line">        <span class="keyword">const</span> jsonData = <span class="built_in">JSON</span>.parse((<span class="built_in">this</span> <span class="keyword">as</span> <span class="built_in">any</span>).result); <span class="comment">// 成功 说明是普通对象数据</span></span><br><span class="line">        <span class="keyword">if</span> (jsonData?.code !== <span class="number">200</span>) &#123;</span><br><span class="line">          Message.error(jsonData?.message ?? <span class="string">&quot;请求失败&quot;</span>);</span><br><span class="line">          reject(jsonData);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 解析成对象失败，说明是正常的文件流</span></span><br><span class="line">        <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([response.data]);</span><br><span class="line">        <span class="comment">// 本地保存文件</span></span><br><span class="line">        <span class="keyword">const</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line">        <span class="keyword">const</span> link = <span class="built_in">document</span>.createElement(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        link.href = url;</span><br><span class="line">        <span class="keyword">const</span> filename = response?.headers?.[<span class="string">&quot;content-disposition&quot;</span>]</span><br><span class="line">          ?.split(<span class="string">&quot;filename*=&quot;</span>)?.[<span class="number">1</span>]</span><br><span class="line">          ?.substr(<span class="number">7</span>);</span><br><span class="line">        link.setAttribute(<span class="string">&quot;download&quot;</span>, <span class="built_in">decodeURI</span>(filename));</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(link);</span><br><span class="line">        link.click();</span><br><span class="line">        resolve(response.data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    fileReader.readAsText(response.data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createAxiosByinterceptors &#125; <span class="keyword">from</span> <span class="string">&quot;@/api/request&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = createAxiosByinterceptors(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: localhost:<span class="number">7007</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//lodaing配置</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> appList = (params: <span class="built_in">any</span>): <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt; =&gt; request.get(<span class="string">&quot;/app&quot;</span>, &#123; params, <span class="attr">loading</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">// 不需要默认的全局loading效果可配置loading为false关闭 loading默认为true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件下载</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> exportGoods = <span class="function">(<span class="params">data: <span class="built_in">any</span></span>) =&gt;</span>request.post(<span class="string">&quot;/export&quot;</span>, data, &#123;</span><br><span class="line">    <span class="attr">responseType</span>: <span class="string">&quot;blob&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TypeScript实战之用TS封装Axios&quot;&gt;&lt;a href=&quot;#TypeScript实战之用TS封装Axios&quot; class=&quot;headerlink&quot; title=&quot;TypeScript实战之用TS封装Axios&quot;&gt;&lt;/a&gt;TypeScript实战之用TS封</summary>
      
    
    
    
    <category term="TypeScript" scheme="https://lesliewaong.top/categories/TypeScript/"/>
    
    
    <category term="Ajax" scheme="https://lesliewaong.top/tags/Ajax/"/>
    
    <category term="Axios" scheme="https://lesliewaong.top/tags/Axios/"/>
    
    <category term="TypeScript" scheme="https://lesliewaong.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>树的相关操作</title>
    <link href="https://lesliewaong.top/posts/e8bebe4.html"/>
    <id>https://lesliewaong.top/posts/e8bebe4.html</id>
    <published>2022-07-03T08:15:52.000Z</published>
    <updated>2022-07-10T14:13:09.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树的相关操作"><a href="#树的相关操作" class="headerlink" title="树的相关操作"></a>树的相关操作</h1><h2 id="平铺数组-lt-gt-树形结构"><a href="#平铺数组-lt-gt-树形结构" class="headerlink" title="平铺数组&lt;=&gt;树形结构"></a>平铺数组&lt;=&gt;树形结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;001&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;节点1&quot;</span>, <span class="attr">pid</span>: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;0011&quot;</span>, <span class="attr">pid</span>: <span class="string">&quot;001&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;节点1-1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;00111&quot;</span>, <span class="attr">pid</span>: <span class="string">&quot;0011&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;节点1-1-1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;002&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;节点2&quot;</span>, <span class="attr">pid</span>: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generateTree = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    item.children = arr.filter(<span class="function">(<span class="params">childitem</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item.id === childitem.pid;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> !item.pid; <span class="comment">// undefined null 0 &#x27;&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">tree = generateTree(arr);</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeToArr</span>(<span class="params">treeData, result = [], &#123; childrenName = <span class="string">&quot;children&quot;</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  treeData.forEach(<span class="function">(<span class="params">treeItem</span>) =&gt;</span> &#123;</span><br><span class="line">    result.push(treeItem);</span><br><span class="line">    <span class="keyword">if</span> (treeItem[childrenName]) &#123;</span><br><span class="line">      TreeToArr(treeItem[childrenName], result);</span><br><span class="line">      <span class="keyword">delete</span> treeItem[childrenName];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(TreeToArr(tree));</span><br></pre></td></tr></table></figure><h2 id="树的遍历查看祖先节点"><a href="#树的遍历查看祖先节点" class="headerlink" title="树的遍历查看祖先节点"></a>树的遍历查看祖先节点</h2><p>树的全部展开操作，一般需要获取到所有的树的组件节点key</p><h3 id="树的数据结构"><a href="#树的数据结构" class="headerlink" title="树的数据结构"></a>树的数据结构</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> TNode &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  key: <span class="built_in">number</span>;</span><br><span class="line">  children: TNode[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看所有的父节点"><a href="#查看所有的父节点" class="headerlink" title="查看所有的父节点"></a>查看所有的父节点</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAllParentKeys</span>(<span class="params">list: TNode[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> keys: <span class="built_in">number</span>[] = [];</span><br><span class="line">  list.forEach(<span class="function">(<span class="params">&#123; key, children &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      keys.push(key, ...getAllParentKeys(children));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找某个指定节点的所有祖先节点"><a href="#查找某个指定节点的所有祖先节点" class="headerlink" title="查找某个指定节点的所有祖先节点"></a>查找某个指定节点的所有祖先节点</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到某个节点的所有祖先节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findParentKeys</span>(<span class="params">list: TNode[], childKey: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resultKey: <span class="built_in">number</span>[] = [];</span><br><span class="line">  canFindKey(list, childKey, resultKey);</span><br><span class="line">  <span class="keyword">return</span> resultKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canFindKey</span>(<span class="params">list: TNode[], childKey: <span class="built_in">number</span>, result: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canFind = <span class="literal">false</span>;</span><br><span class="line"> <span class="comment">// 这里的遍历需要注意！使用some return true可以跳出some循环</span></span><br><span class="line"><span class="comment">// 如果使用forEach return只能跳出当前循环，但是不能终止forEach，可以使用try catch终止</span></span><br><span class="line">  list.some(<span class="function">(<span class="params">&#123; key, children &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === childKey) &#123;</span><br><span class="line">      canFind = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      result.push(key);</span><br><span class="line">      canFind = canFindKey(children, childKey, result);</span><br><span class="line">      <span class="keyword">if</span> (canFind) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> canFind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;树的相关操作&quot;&gt;&lt;a href=&quot;#树的相关操作&quot; class=&quot;headerlink&quot; title=&quot;树的相关操作&quot;&gt;&lt;/a&gt;树的相关操作&lt;/h1&gt;&lt;h2 id=&quot;平铺数组-lt-gt-树形结构&quot;&gt;&lt;a href=&quot;#平铺数组-lt-gt-树形结构&quot; class</summary>
      
    
    
    
    <category term="JS" scheme="https://lesliewaong.top/categories/JS/"/>
    
    
    <category term="JS" scheme="https://lesliewaong.top/tags/JS/"/>
    
    <category term="树" scheme="https://lesliewaong.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>文件下载</title>
    <link href="https://lesliewaong.top/posts/92959c23.html"/>
    <id>https://lesliewaong.top/posts/92959c23.html</id>
    <published>2022-07-03T03:46:42.000Z</published>
    <updated>2022-07-19T15:36:25.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h1><h2 id="前端从后端下载或导出文件的方法"><a href="#前端从后端下载或导出文件的方法" class="headerlink" title="前端从后端下载或导出文件的方法"></a><a href="https://juejin.cn/post/6911964673331953671">前端从后端下载或导出文件的方法</a></h2><p>适用场景： 很多时候，前端存在需要从后端下载文件的情况，典型的就是导出excel表格。</p><p>一般存在两种方式：</p><ul><li>请求接口之后，后端返回文件路径，前端直接下载。</li><li>请求接口之后，后端以<strong>文件流</strong>的形式返回给前端，前端再下载到本地。</li></ul><h3 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h3><p>很简单，请求完接口之后，打开该文件的地址：</p><p><code>window.location.href = res.request.responseURL</code></p><p><code>responseURL</code>这个地址其实和接口地址是一样，直接打开它，就能默认下载到本地的下载路径了。</p><p>非常方便，但是存在不足，比如<strong>不能修改文件的名称</strong>。</p><p>而且，有些场景使用这种方式是行不通的，比如，很多管理系统，都是需要<strong>登录</strong>的，既然要登录，那就一般都会需要验证每个请求是否安全，往往需要在header里带上token，后端才会给你这个请求放行。</p><p>所以，这种方式，你请求接口之后，转到这个链接，其实就是再请求了一次，这个时候你是不好在请求里带上token的，自然也就拿不到你要的文件。</p><p>所以，这个时候就要用第二种方式，以文件流的方式来下载。</p><h3 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h3><p>第二种方式，就是正常的api请求，后端以文件流的形式发送给前端，前端获取到文件数据之后，在本地模拟一次点击按钮下载，不过这次下载不是再向后端请求一次api,而是把第一次请求api之后，后端返回的文件数据转换成合适的格式之后下载下来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">exportFile(<span class="built_in">this</span>.queryParam).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> xlsx = <span class="string">&#x27;application/vnd.ms-excel&#x27;</span></span><br><span class="line">        <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([res.data], &#123; <span class="attr">type</span>: xlsx &#125;)</span><br><span class="line">        <span class="comment">//转换数据类型</span></span><br><span class="line">        <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// 转换完成，创建一个a标签用于下载</span></span><br><span class="line">        <span class="comment">// const name = res.headers[&#x27;content-disposition&#x27;]</span></span><br><span class="line">        <span class="comment">// a.download = name.split(&#x27;=&#x27;)[1]</span></span><br><span class="line">        a.download = <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.$t(<span class="string">&#x27;自定义文件名&#x27;</span>)&#125;</span>.xlsx`</span></span><br><span class="line">        a.href = <span class="built_in">window</span>.URL.createObjectURL(blob)</span><br><span class="line">        a.click()</span><br><span class="line">        a.remove()</span><br><span class="line">        <span class="built_in">document</span>.body.removeChild(a) <span class="comment">//也可以这么移除</span></span><br><span class="line">        <span class="comment">// 直接打开下载文件的链接</span></span><br><span class="line">        <span class="comment">// window.location.href = res.request.responseURL</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li><p>不管是第一种方式还是第二种方式，尽量让后端指定好文件的类型。当然，使用第二种方式，前端可以再次指定好文件类型。</p></li><li><p>这里将获取到的文件内容转换成blob类型的数据，是最常见的下载文件数据的格式，当然还可以使用别的方式。</p></li><li><p>这里创建a标签取下载文件，还可以用别的方式，或者如果碰到浏览器兼容性的问题，可能需要个性化处理。</p></li><li><p>.download这里可以拿后端返回的文件名，也可以自己定义文件名，看你自己哪个方便一些。如果后端拿到的文件名是乱码，建议直接在前端定义文件名。</p></li><li><p>最关键的是，下载文件乱码的问题，很多人碰到，解决方法也很简单。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">exportFile</span> (<span class="params">parameter</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> axios(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">`<span class="subst">$&#123;api.file&#125;</span>/export`</span>,</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: parameter,</span><br><span class="line">        <span class="attr">header</span>: &#123;</span><br><span class="line">            <span class="attr">headers</span>: &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-download&#x27;</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">responseType</span>: <span class="string">&#x27;blob&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在请求接口的header里一定要指定<code>responseType</code>为<code>blob</code>，否则把返回的文件数据转换成blob对象，blob是不认识的，就会出现乱码。</p></li></ul><h2 id="前端下载文件的5种方法的对比"><a href="#前端下载文件的5种方法的对比" class="headerlink" title="前端下载文件的5种方法的对比"></a><a href="https://juejin.cn/post/6844904069958467592">前端下载文件的5种方法的对比</a></h2><h3 id="form表单提交"><a href="#form表单提交" class="headerlink" title="form表单提交"></a>form表单提交</h3><p>这是以前常使用的传统方式，毕竟那个年代，没那么多好用的新特性呀。</p><p>道理也很简单，为一个下载按钮添加<code>click</code>事件，点击时动态生成一个表单，利用表单提交的功能来实现文件的下载（实际上表单的提交就是发送一个请求）</p><p>来看下如何生成一个表单，生成怎么样的一个表单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">path</span></span> - 请求的地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">fileName</span></span> - 文件名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadFile</span> (<span class="params">downloadUrl, fileName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建表单</span></span><br><span class="line">    <span class="keyword">const</span> formObj = <span class="built_in">document</span>.createElement(<span class="string">&#x27;form&#x27;</span>);</span><br><span class="line">    formObj.action = downloadUrl;</span><br><span class="line">    formObj.method = <span class="string">&#x27;get&#x27;</span>;</span><br><span class="line">    formObj.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    <span class="comment">// 创建input，主要是起传参作用</span></span><br><span class="line">    <span class="keyword">const</span> formItem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">    formItem.value = fileName; <span class="comment">// 传参的值</span></span><br><span class="line">    formItem.name = <span class="string">&#x27;fileName&#x27;</span>; <span class="comment">// 传参的字段名</span></span><br><span class="line">    <span class="comment">// 插入到网页中</span></span><br><span class="line">    formObj.appendChild(formItem);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(formObj);</span><br><span class="line">    formObj.submit(); <span class="comment">// 发送请求</span></span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(formObj); <span class="comment">// 发送完清除掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>传统方式，兼容性好，不会出现URL长度限制问题</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法知道下载的进度</li><li>无法直接下载浏览器可直接预览的文件类型（如txt/png等）</li></ul><h3 id="open或location-href"><a href="#open或location-href" class="headerlink" title="open或location.href"></a>open或location.href</h3><p>最简单最直接的方式，实际上跟<code>a</code>标签访问下载链接一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">&#x27;downloadFile.zip&#x27;</span>);</span><br><span class="line">location.href = <span class="string">&#x27;downloadFile.zip&#x27;</span>;</span><br></pre></td></tr></table></figure><p>当然地址也可以是接口api的地址，而不单纯是个链接地址。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>简单方便直接</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>会出现<strong>URL长度限制</strong>问题</li><li>需要注意<strong>url编码</strong>问题</li><li><strong>浏览器可直接浏览的文件类型是不提供下载的</strong>，如txt、png、jpg、gif等</li><li><strong>不能添加header，也就不能进行鉴权</strong></li><li><strong>无法知道下载的进度</strong></li></ul><h3 id="a标签的download"><a href="#a标签的download" class="headerlink" title="a标签的download"></a>a标签的download</h3><p>我们知道，<code>a</code>标签可以访问下载文件的地址，浏览器帮助进行下载。但是对于浏览器支持直接浏览的txt、png、jpg、gif等文件，是不提供直接下载（可右击从菜单里另存为）的。</p><p>为了解决这个直接浏览不下载的问题，可以利用<code>download</code>属性。</p><p><code>download</code>属性是HTML5新增的属性，兼容性可以了解下 <a href="https://link.juejin.cn/?target=https://caniuse.com/#search=download">can i use download</a></p><p>总体兼容性算是很好了，基本可以区分为IE和其他浏览。但是需要注意一些信息：</p><ul><li>Edge 13在尝试下载data url链接时会崩溃。</li><li>Chrome 65及以上版本只支持同源下载链接。</li><li>Firefox只支持同源下载链接。</li></ul><p>基于上面描述，如果你尝试下载跨域链接，那么其实<code>download</code>的效果就会没了，跟不设置<code>download</code>表现一致。即浏览器能预览的还是会预览，而不是下载。</p><p>简单用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;example.jpg&quot;</span> download&gt;点击下载&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>可以带上属性值，指定下载的文件名，即重命名下载文件。不设置的话默认是文件原本名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;example.jpg&quot;</span> download=<span class="string">&quot;test&quot;</span>&gt;点击下载&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>如上，会下载了一个名叫<code>test</code>的图片。</p><p><strong>监测是否支持download</strong></p><p>要知道浏览器是否支持<code>download</code>属性，简单的一句代码即可区分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isSupport = <span class="string">&#x27;download&#x27;</span> <span class="keyword">in</span> <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>对于在跨域下不能下载可浏览的文件，其实可以跟后端协商好，在后端层做多一层转发，最终返回给前端的文件链接跟下载页同域就好了。</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>能解决不能直接下载浏览器可浏览的文件</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>得已知下载文件地址</li><li>不能下载跨域下的浏览器可浏览的文件</li><li>有兼容性问题，特别是IE</li><li>不能进行鉴权</li></ul><h3 id="利用Blob对象"><a href="#利用Blob对象" class="headerlink" title="利用Blob对象"></a>利用Blob对象</h3><p>该方法较上面的直接使用<code>a</code>标签<code>download</code>这种方法的优势在于，它除了能利用已知文件地址路径进行下载外，还能通过发送ajax请求api获取文件流进行下载。毕竟有些时候，后端不会直接提供一个下载地址给你直接访问，而是要调取api。</p><p>利用<code>Blob</code>对象可以将文件流转化成<code>Blob</code>二进制对象。该对象兼容性良好，需要注意的是</p><ul><li>IE10以下不支持。</li><li>在Safari浏览器上访问<code>Blob Url</code>或<code>Object URL</code>当前是有缺陷的，如下文中通过<code>URL.createObjectURL</code>生成的链接。<code>caniuse</code>官网有指出 Safari has a <a href="https://link.juejin.cn/?target=https://jsfiddle.net/24FhL/">serious issue</a> with blobs that are of the type application/octet-stream</li></ul><p>进行下载的思路很简单：发请求获取二进制数据，转化为<code>Blob</code>对象，利用<code>URL.createObjectUrl</code>生成url地址，赋值在<code>a</code>标签的<code>href</code>属性上，结合<code>download</code>进行下载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">path</span></span> - 下载地址/下载请求地址。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">name</span></span> - 下载文件的名字/重命名（考虑到兼容性问题，最好加上后缀名）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">downloadFile (path, name) &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">&#x27;get&#x27;</span>, path);</span><br><span class="line">    xhr.responseType = <span class="string">&#x27;blob&#x27;</span>;</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span> || <span class="built_in">this</span>.status === <span class="number">304</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是IE10及以上，不支持download属性，采用msSaveOrOpenBlob方法，但是IE10以下也不支持msSaveOrOpenBlob</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;msSaveOrOpenBlob&#x27;</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">                navigator.msSaveOrOpenBlob(<span class="built_in">this</span>.response, name);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// const blob = new Blob([this.response], &#123; type: xhr.getResponseHeader(&#x27;Content-Type&#x27;) &#125;);</span></span><br><span class="line">            <span class="comment">// const url = URL.createObjectURL(blob);</span></span><br><span class="line">            <span class="keyword">const</span> url = URL.createObjectURL(<span class="built_in">this</span>.response);</span><br><span class="line">            <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            a.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">            a.href = url;</span><br><span class="line">            a.download = name;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(a);</span><br><span class="line">            a.click();</span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(a);</span><br><span class="line">            URL.revokeObjectURL(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法不能缺少<code>a</code>标签的<code>download</code>属性的设置。</p><p>因为发请求时已设置返回数据类型为<code>Blob</code>类型（<code>xhr.responseType = &#39;blob&#39;</code>），所以<code>target.response</code>就是一个<code>Blob</code>对象，打印出来会看到两个属性<code>size</code>和<code>type</code>。</p><p>虽然<code>type</code>属性已指定了文件的类型，但是为了稳妥起见，还是在<code>download</code>属性值里指定后缀名，如Firefox不指定下载下来的文件就会不识别类型。</p><p>大家可能会注意到，上述代码有两处注释，其实除了上述的写法外，还有另一个写法，改动一丢丢。</p><p>如果发送请求时不设置<code>xhr.responseType = &#39;blob&#39;</code>，默认ajax请求会返回<code>DOMString</code>类型的数据，即字符串。</p><p>这时就需要两处注释的代码了，对返回的文本转化为<code>Blob</code>对象，然后创建blob url，此时需要注释掉原本的<code>const url = URL.createObjectURL(target.response)</code>。</p><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul><li>能解决不能直接下载浏览器可浏览的文件</li><li>可设置header，也就可添加鉴权信息</li></ul><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul><li>兼容性问题，IE10以下不可用；Safari浏览器可以留意下使用情况</li></ul><h3 id="利用base64"><a href="#利用base64" class="headerlink" title="利用base64"></a>利用base64</h3><p>这里的用法跟上面用<code>Blob</code>大同小异，基本上思路是一样的，唯一不同的是，上面是利用<code>Blob</code>对象生成<code>Blob URL</code>，而这里则是生成<code>Data URL</code>，所谓<code>Data URL</code>，就是<code>base64</code>编码后的url形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">path</span></span> - 下载地址/下载请求地址。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">name</span></span> - 下载文件的名字（考虑到兼容性问题，最好加上后缀名）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">downloadFile (path, name) &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">&#x27;get&#x27;</span>, path);</span><br><span class="line">    xhr.responseType = <span class="string">&#x27;blob&#x27;</span>;</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span> || <span class="built_in">this</span>.status === <span class="number">304</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> fileReader = <span class="keyword">new</span> FileReader();</span><br><span class="line">            fileReader.readAsDataURL(<span class="built_in">this</span>.response);</span><br><span class="line">            fileReader.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                a.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">                a.href = <span class="built_in">this</span>.result;</span><br><span class="line">                a.download = name;</span><br><span class="line">                <span class="built_in">document</span>.body.appendChild(a);</span><br><span class="line">                a.click();</span><br><span class="line">                <span class="built_in">document</span>.body.removeChild(a);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul><li>能解决不能直接下载浏览器可浏览的文件</li><li>可设置header，也就可添加鉴权信息</li></ul><h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><ul><li>兼容性问题，IE10以下不可用</li></ul><h3 id="关于文件名"><a href="#关于文件名" class="headerlink" title="关于文件名"></a>关于文件名</h3><p>有时候我们在发送下载请求之前，并不知道文件名，或者文件名是后端提供的，我们就要想办法获取。</p><h4 id="Content-Disposition"><a href="#Content-Disposition" class="headerlink" title="Content-Disposition"></a>Content-Disposition</h4><p>当返回文件流的时候，我们在浏览器上观察接口返回的信息，会看到有这么一个header：<code>Content-Disposition</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: attachment; filename=CMCoWork__________20200323151823_190342.xlsx; filename*=UTF<span class="number">-8</span>&#x27;&#x27;CMCoWork_%E4</span><br></pre></td></tr></table></figure><p>上面的值是例子。</p><p>其中包含了文件名，我们可以想办法获取其中的文件名。</p><p>我们看到，有<code>filename=</code>和<code>filename*=</code>，后者不一定有，在旧版浏览器中或个别浏览器中，会不支持这种形式，<code>filename*</code>采用了<code>RFC 5987</code>中规定的编码方式。</p><p>所以你要获取文件名，就变成，截取这段字符串中的这两个字段值了。</p><p>看上面的例子大家可能发现，怎么值怪怪的。是的，如果名字是英文，那好办， 如果是有中文或者其他特殊符号，是需要处理好编码的</p><ul><li><code>filename</code>，需要后端处理好编码形式，但是就算后端处理好了，也会应每个浏览器的不同，解析的情况也不同。是个比较难处理好的家伙，所以才有后面的<code>filename*</code></li><li><code>filename*</code>，是个现代浏览器支持的，为了解决<code>filename</code>的不足，一般是<code>UTF-8</code>，我们用<code>decodeURIComponent</code>就能解码了，能还原成原本的样子。当然，解码前你要把值中的<code>UTF-8&#39;&#39;</code>这种部分给去掉。</li></ul><p>所以，在我们实现之前，我们就要明白，取<code>Content-Disposition</code>的内容，并不是百分百能符合你预期的，除非你的文件名全是英文数字。</p><p>我们提取文件名值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xhr是XMLHttpRequest对象</span></span><br><span class="line"><span class="keyword">const</span> content = xhr.getResponseHeader(<span class="string">&#x27;content-disposition&#x27;</span>); <span class="comment">// 注意是全小写，自定义的header也是全小写</span></span><br><span class="line"><span class="keyword">if</span> (content) &#123;</span><br><span class="line">    <span class="keyword">let</span> name1 = content.match(<span class="regexp">/filename=(.*);/</span>)[<span class="number">1</span>]; <span class="comment">// 获取filename的值</span></span><br><span class="line">    <span class="keyword">let</span> name2 = content.match(<span class="regexp">/filename\*=(.*)/</span>)[<span class="number">1</span>]; <span class="comment">// 获取filename*的值</span></span><br><span class="line">    name1 = <span class="built_in">decodeURIComponent</span>(name1);</span><br><span class="line">    name2 = <span class="built_in">decodeURIComponent</span>(name2.substring(<span class="number">6</span>)); <span class="comment">// 这个下标6就是UTF-8&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们获得了两个文件名<code>name1,name2</code>，如果两个都存在，那么我们优先取<code>name2</code>的，因为这个更靠谱，<code>name1</code>如果包含中文或特殊符号，就有风险还原不了真正的文件名。</p><h4 id="自定义header"><a href="#自定义header" class="headerlink" title="自定义header"></a>自定义header</h4><p>本质上跟上述的<code>Content-Disposition</code>差不多，只是我们这里不使用默认的header，我们自己自定义一个<code>response header</code>，跟后端决定好编码方式返回，前端直接获取这个自定义header，然后使用对应的解码即可，如使用<code>decodeURIComponent</code>。</p><p>但是我们都要知道，在跨域的情况下，前端获取到的header只有默认的6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。</p><p>所以你想要获取到别的header，需要后端配合，设置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Expose-Headers: Content-Disposition, custom-header</span><br></pre></td></tr></table></figure><p>这样，前端就能获取到对应暴露的header字段，需要注意的是，<code>Content-Disposition</code>也是需要暴露的。</p><h4 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h4><p>这里额外提供个方法，该方法作用是，当你知道文件的全名（含后缀名），想要重命名，但是得后缀名一样，来获取后缀名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findType</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> index = name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> name.substring(index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下载大文件"><a href="#下载大文件" class="headerlink" title="下载大文件"></a>下载大文件</h2><p>注意: 如果下载特别大的文件，则上面的就不行了，可能会造成网页崩溃，这里就需要用到下载的库。 </p><p> <a href="https://github.com/eligrey/FileSaver.js">FileSaver</a>, 轻松实现下载文件500M</p><h3 id="1-安装npm依赖"><a href="#1-安装npm依赖" class="headerlink" title="1.安装npm依赖"></a>1.安装npm依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install file-saver --save</span><br></pre></td></tr></table></figure><h3 id="2-引入代码"><a href="#2-引入代码" class="headerlink" title="2.引入代码"></a>2.引入代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="keyword">import</span> &#123; saveAs &#125; <span class="keyword">from</span> <span class="string">&#x27;file-saver&#x27;</span>;</span><br><span class="line">...</span><br><span class="line">+      saveAs(blob, fileName );</span><br></pre></td></tr></table></figure><h3 id="3-完整例子"><a href="#3-完整例子" class="headerlink" title="3.完整例子"></a>3.完整例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="keyword">import</span> &#123; saveAs &#125; <span class="keyword">from</span> <span class="string">&#x27;file-saver&#x27;</span>;</span><br><span class="line">axios(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;api/file&#x27;</span>,</span><br><span class="line">    <span class="attr">responseType</span>: <span class="string">&#x27;blob&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.data)&#123;</span><br><span class="line">        fileName = <span class="built_in">this</span>.fileName;</span><br><span class="line">        <span class="comment">// 有文件名就用自定义的，没有就从header获取</span></span><br><span class="line">        <span class="keyword">if</span> (!fileName) &#123;</span><br><span class="line">            fileName = fileNameFromHeader(</span><br><span class="line">                res.headers[<span class="string">&quot;content-disposition&quot;</span>] || <span class="string">&quot;&quot;</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([res.data],&#123;</span><br><span class="line">            <span class="attr">type</span>:<span class="string">&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8&quot;</span>&#125;);</span><br><span class="line">        +      saveAs(blob, fileName );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileNameFromHeader</span>(<span class="params">disposition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">    disposition = disposition.split(<span class="string">&quot;;&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (disposition &amp;&amp; <span class="regexp">/filename=.*/gi</span>.test(disposition)) &#123;</span><br><span class="line">        result = disposition.match(<span class="regexp">/filename=.*/gi</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>((result[<span class="number">0</span>].split(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>]).replace(<span class="regexp">/\+/g</span>, <span class="string">&#x27;%20&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-其他问题"><a href="#4-其他问题" class="headerlink" title="4.其他问题"></a>4.其他问题</h3><p>下载大文件过程中遇到的其他问题</p><ul><li>axios请求超时，注意配置timeout</li><li>Nginx 响应超时报504 网关超时错误，注意配置Nginx</li><li>控制台报error response，浏览器请求长时间得不到响应，本地调试代理转发超时造成的，<a href="https://segmentfault.com/q/1010000017751671">参考</a></li><li><a href="https://github.com/eligrey/FileSaver.js/issues/163">文件超过2G的解决方案</a></li></ul><h2 id="前端对于文件流的下载"><a href="#前端对于文件流的下载" class="headerlink" title="前端对于文件流的下载"></a><a href="https://juejin.cn/post/6905999356227223559">前端对于文件流的下载</a></h2><h3 id="Stream概念"><a href="#Stream概念" class="headerlink" title="Stream概念"></a>Stream概念</h3><p>想象一下,你编写了一个文件,你可以将它保存在硬盘上,也可以将它保存到U盘上,这样简单的操作,其实就是数据的传输。</p><p>数据的传输,也就是数据的流动,既然出现了这个流动,那就会有出方向和入方向,就像大部分河流一样,在某个地方冒出了涓涓细流,到最后流入大海(这属于地理知识我们在这里不做过多讨论…),在很多时候，流（Stream）我们代指字节流（Byte Steram），也就是长长的一串字节，除了字节流，我们还可能有视频流、音频流、数据流等等……</p><p>流按照处理数据的单位，可以分为字节流和字符流。</p><p>字节流的处理单位是字节，通常用来处理二进制文件，例如音乐、图片文件等。而字符流的处理单位是字符，因为Java采用Unicode编码，Java字符流处理的即为Unicode字符，所以在操作汉字、国际化等方面，字符流具有优势。</p><h3 id="MIME概念"><a href="#MIME概念" class="headerlink" title="MIME概念"></a>MIME概念</h3><blockquote><p>媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。它在IETF RFC 6838中进行了定义和标准化。<br> 互联网号码分配机构（IANA）是负责跟踪所有官方MIME类型的官方机构，您可以在媒体类型页面中找到最新的完整列表。</p></blockquote><p><code>MIME</code>它的全名叫多用途互联网邮件扩展（Multipurpose Internet Mail Extensions），最初是为了将纯文本格式的电子邮件扩展到可以支持多种信息格式而定制的。后来被应用到多种协议里，包括我们常用的HTTP协议。</p><p> <code>MIME</code>的常见形式是一个主类型加一个子类型，用斜线分隔。比如<code>text/html</code>、<code>application/javascript</code>、<code>image/png</code>等。</p><h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><h4 id="概念-什么是Blob"><a href="#概念-什么是Blob" class="headerlink" title="概念-什么是Blob"></a>概念-什么是Blob</h4><blockquote><p>Blob（Binary Large Object）对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 ReadableStream 来用于数据操作。<br> Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p></blockquote><p>从<code>MDN</code>官方的定义来看,我们大概可以知道这个<code>Blob</code>是用来干啥的了,它是一个用来读取或操作二进制数据的玩意,这我们就可以来下载后端给我们的文件流了啊</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Blob = <span class="keyword">new</span> Blob( array, options )</span><br></pre></td></tr></table></figure><ul><li>array 是一个由ArrayBuffer（二进制数据缓冲区）、ArrayBufferView（二进制数据缓冲区的array-like视图）、Blob、DOMString等对象构成的Array，或者其他类似对象的混合体，它将会被放进Blob。DOMStrings会被编码为UTF-8。</li><li>options 是可选的，它可能会指定如下两个属性：</li><li>type，默认值为 “”，它代表了将会被放入到blob中的数组内容的MIME类型。</li><li><ul><li>endings，默认值为”transparent”，用于指定包含行结束符n的字符串如何被写入。 它是以下两个值中的一个：</li></ul></li><li><ul><li>“native”，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 “transparent”，代表会保持blob中保存的结束符不变。 🌰 :</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> say = &#123;<span class="attr">hello</span>: <span class="string">&quot;world&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">JSON</span>.stringify(say, <span class="literal">null</span>, <span class="number">2</span>)],&#123;<span class="attr">type</span> : <span class="string">&#x27;application/json&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="URl对象"><a href="#URl对象" class="headerlink" title="URl对象"></a>URl对象</h3><p>我们想要下载这个文件需要通过创建URL对象指定文件的下载链接</p><h4 id="创建构造函数"><a href="#创建构造函数" class="headerlink" title="创建构造函数"></a>创建构造函数</h4><p>创建新的URL表示指定的File对象或者Blob对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectURL = <span class="built_in">window</span>.URL.createObjectURL(blob)</span><br></pre></td></tr></table></figure><h4 id="释放对象"><a href="#释放对象" class="headerlink" title="释放对象"></a>释放对象</h4><p>这个方法不会像<code>JavaScript</code>的垃圾回收机制那样帮你处理一些事情,在每次调用<code>createObjectURL</code>方法时，都会创建一个新的 URL 对象，即使你已经用相同的对象作为参数创建过。当不再需要这些 URL 对象时，每个对象必须通过调用 <code>URL.revokeObjectURL</code>方法来释放。浏览器会在文档退出的时候自动释放它们，但是为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.URL.revokeObjectURL(objectURL)</span><br></pre></td></tr></table></figure><h3 id="使用a标签下载"><a href="#使用a标签下载" class="headerlink" title="使用a标签下载"></a>使用a标签下载</h3><h4 id="生成一个a标签"><a href="#生成一个a标签" class="headerlink" title="生成一个a标签"></a>生成一个a标签</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> link = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="指定下载链接"><a href="#指定下载链接" class="headerlink" title="指定下载链接"></a>指定下载链接</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link.href = <span class="built_in">window</span>.URL.createObjectURL(blob)</span><br></pre></td></tr></table></figure><h4 id="设置文件名"><a href="#设置文件名" class="headerlink" title="设置文件名"></a>设置文件名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link.download = fileName</span><br></pre></td></tr></table></figure><h4 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link.click()</span><br></pre></td></tr></table></figure><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">    <span class="attr">hello</span>: <span class="string">&quot;world&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">JSON</span>.stringify(foo)], &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;application/vnd.ms-excel;charset=utf-8&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> fileName = <span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().valueOf()&#125;</span>.xls`</span>;</span><br><span class="line"><span class="keyword">const</span> link = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">link.href = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line">link.download = fileName;</span><br><span class="line">link.click();</span><br><span class="line"><span class="built_in">window</span>.URL.revokeObjectURL(link.href);</span><br></pre></td></tr></table></figure><h3 id="兼容IE"><a href="#兼容IE" class="headerlink" title="兼容IE"></a>兼容IE</h3><p>在IE中要使用<code>window.navigator.msSaveOrOpenBlob</code>来处理Blob对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.navigator.msSaveOrOpenBlob(blob, fileName);</span><br></pre></td></tr></table></figure><h3 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*res是请求后返回的文件流,name是传入的文件名*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> downloadExcel = <span class="function">(<span class="params">res,name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([res],&#123;<span class="attr">type</span>: <span class="string">&#x27;application/vnd.ms-excel&#x27;</span>&#125;)</span><br><span class="line">  <span class="keyword">const</span> fileName = <span class="string">`<span class="subst">$&#123;name&#125;</span>.xlsx`</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;download&#x27;</span> <span class="keyword">in</span> <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> elink = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    elink.download = fileName</span><br><span class="line">    elink.style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">    elink.href = URL.createObjectURL(blob)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(elink)</span><br><span class="line">    elink.click()</span><br><span class="line">    URL.revokeObjectURL(elink.href)</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(elink)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    navigator.msSaveBlob(blob, fileName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下载进度"><a href="#下载进度" class="headerlink" title="下载进度"></a>下载进度</h2><p><strong><code>ProgressEvent</code></strong> 接口是测量如 HTTP 请求（一个<code>XMLHttpRequest</code>，或者一个 <code>&lt;img&gt;</code>，<code>&lt;audio&gt;</code>，<code>&lt;video&gt;</code>，<code>&lt;style&gt;</code> 或 <code>&lt;link&gt;</code>等底层资源的加载）等底层流程进度的事件。</p><ul><li><p><code>ProgressEvent.lengthComputable</code>只读</p><p>是一个 <code>Boolean</code>标志，表示底层流程将需要完成的总工作量和已经完成的工作量是否可以计算。换句话说，它告诉我们进度是否可以被测量。</p></li><li><p><code>ProgressEvent.loaded</code> 只读</p><p>是一个 <code>unsigned long long</code> 类型数据，表示<strong>底层流程已经执行的工作总量</strong>。可以用这个属性和 <code>ProgressEvent.total</code> 计算工作完成比例。当使用 HTTP 下载资源，它只表示内容本身的部分，不包括首部和其它开销。</p></li><li><p><code>ProgressEvent.total</code> 只读</p><p>是一个 <code>unsigned long long</code> 类型数据，表示<strong>正在执行的底层流程的工作总量</strong>。当使用 HTTP 下载资源，它只表示内容本身的部分，不包括首部和其它开销。</p></li></ul><p>下面的示例为一个新建的 <code>XMLHTTPRequest</code> 添加了一个 <code>ProgressEvent</code>，并使用它来显示请求状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> progressBar = <span class="built_in">document</span>.getElementById(<span class="string">&quot;p&quot;</span>),</span><br><span class="line">    client = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">client.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;magical-unicorns&quot;</span>)</span><br><span class="line">client.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">pe</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pe.lengthComputable) &#123;</span><br><span class="line">        progressBar.max = pe.total</span><br><span class="line">        progressBar.value = pe.loaded</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">client.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params">pe</span>) </span>&#123;</span><br><span class="line">    progressBar.value = pe.loaded</span><br><span class="line">&#125;</span><br><span class="line">client.send()</span><br></pre></td></tr></table></figure><p><strong>axios onUploadProgress（post） onDownloadProgres（get）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `onUploadProgress` 允许为上传处理进度事件</span></span><br><span class="line"><span class="attr">onUploadProgress</span>: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do whatever you want with the native progress event</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// `onDownloadProgress` 允许为下载处理进度事件</span></span><br><span class="line"><span class="attr">onDownloadProgress</span>: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对原生进度事件的处理</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(progressEvent.loaded  /  progressEvent.total  *  <span class="number">100</span>) +  <span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>axios的onDownloadProgress返回参数的total为0的问题。</p><ul><li><p>原因一、很简单，可能只是后端没有返回content-length，让后端工程师加上就行。</p></li><li><p>原因二、开启了gzip。开启gzip之后服务器默认就会开启文件分块编码【Transfer-Encoding: chunked】，分块编码把「报文」分割成若干个大小已知的块，块之间是紧挨着发送的。</p><p>采用这种传输方式进行响应时，没必要带上Content-Length这个首部信息。因为即使带上了也是不准确的，所以content-length会没有。</p><p>解决方式之一：</p><p>后端把文件大小存储到其他字段，比如：header[‘x-content-length’];</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件下载&quot;&gt;&lt;a href=&quot;#文件下载&quot; class=&quot;headerlink&quot; title=&quot;文件下载&quot;&gt;&lt;/a&gt;文件下载&lt;/h1&gt;&lt;h2 id=&quot;前端从后端下载或导出文件的方法&quot;&gt;&lt;a href=&quot;#前端从后端下载或导出文件的方法&quot; class=&quot;header</summary>
      
    
    
    
    <category term="常用功能" scheme="https://lesliewaong.top/categories/%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
    <category term="Ajax" scheme="https://lesliewaong.top/tags/Ajax/"/>
    
    <category term="Axios" scheme="https://lesliewaong.top/tags/Axios/"/>
    
    <category term="文件下载" scheme="https://lesliewaong.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Js中Date对象</title>
    <link href="https://lesliewaong.top/posts/c8a51e74.html"/>
    <id>https://lesliewaong.top/posts/c8a51e74.html</id>
    <published>2022-07-01T08:15:52.000Z</published>
    <updated>2022-07-10T14:13:09.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Js中Date对象"><a href="#Js中Date对象" class="headerlink" title="Js中Date对象"></a>Js中Date对象</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sun Oct 18 2020 10:46:54 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(value); <span class="comment">// new Date(1602989155183)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(dateString);<span class="comment">// new Date(&quot;2020-10-18 10:15:30&quot;)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);<span class="comment">// new Date(2020, 9, 18, 10, 15, 30)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">Date</span>())); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p><code>Date.now()</code></p><p>返回自<code>1970</code>年<code>1</code>月<code>1</code>日<code>00:00:00 (UTC)</code>到当前时间的毫秒数。</p><p><code>dateObj.getFullYear()</code></p><p>根据本地时间返回指定日期的年份。</p><p><code>dateObj.getMonth()</code></p><p>根据本地时间，返回一个指定的日期对象的月份，为基于<code>0</code>的值，<code>0</code>表示一年中的<strong>第一月</strong>。</p><p><code>dateObj.getDate()</code></p><p>根据本地时间，返回一个指定的日期对象为一个月中的哪一日，范围为从<code>1-31</code>。</p><p><code>dateObj.getDay()</code></p><p>根据本地时间，返回一个具体日期中一周的第几天，<code>0</code>表示星期天。</p><p><code>dateObj.getHours()</code></p><p>根据本地时间，返回一个指定的日期对象的小时。</p><p><code>dateObj.getMinutes()</code></p><p>根据本地时间，返回一个指定的日期对象的分钟数。</p><p><code>dateObj.getSeconds()</code></p><p>根据本地时间，返回一个指定的日期对象的秒数。</p><p><code>dateObj.toLocaleString([locales [, options]])</code></p><p>返回该日期对象的字符串，该字符串格式因不同语言而不同。</p><p>新增的参数<code>locales</code>和<code>options</code>使程序能够指定使用哪种语言格式化规则，允许定制该方法的表现<code>behavior</code>。</p><p>在旧版本浏览器中，<code>locales</code>和<code>options</code>参数被忽略，使用的语言环境和返回的字符串格式是各自独立实现的。</p><h2 id="每隔1s显示当前时间"><a href="#每隔1s显示当前时间" class="headerlink" title="每隔1s显示当前时间"></a>每隔1s显示当前时间</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formateCurrentDate= <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> date.getFullYear() + <span class="string">&#x27;-&#x27;</span></span><br><span class="line">        + (date.getMonth() + <span class="number">1</span>) + <span class="string">&#x27;-&#x27;</span></span><br><span class="line">        + date.getDate() + <span class="string">&#x27; &#x27;</span></span><br><span class="line">        + date.getHours() + <span class="string">&#x27;:&#x27;</span></span><br><span class="line">        + date.getMinutes() + <span class="string">&#x27;:&#x27;</span></span><br><span class="line">        + date.getSeconds();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// document.querySelectorAll(&#x27;span&#x27;)[0].textContent=formateCurrentDate();</span></span><br><span class="line">    <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;span&#x27;</span>)[<span class="number">0</span>].textContent=<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString();</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// react</span></span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        setTime(formateCurrentDate())</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure><h2 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span>: 日期格式化函数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>date 日期类型</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>format 日期格式  默认 yyyy-MM-dd HH:mm:ss格式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params">date, format = <span class="string">&#x27;yyyy-MM-dd HH:mm:ss 星期w&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!date) &#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> typeDate = date <span class="keyword">instanceof</span> <span class="built_in">Date</span> ? date.getTime() : date;</span><br><span class="line">    date = <span class="keyword">new</span> <span class="built_in">Date</span>(typeDate);</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">        <span class="attr">yyyy</span>: date.getFullYear(), <span class="comment">// 完整年份 例：2021 -&gt; 2021</span></span><br><span class="line">        <span class="attr">yy</span>: (<span class="string">&#x27;&#x27;</span> + date.getFullYear()).slice(-<span class="number">2</span>), <span class="comment">// 缩写年份 例：2021 -&gt; 21</span></span><br><span class="line">        <span class="attr">M</span>: date.getMonth() + <span class="number">1</span>, <span class="comment">// 月份 不足两位不补0</span></span><br><span class="line">        <span class="attr">MM</span>: (<span class="string">&#x27;0&#x27;</span> + (date.getMonth() + <span class="number">1</span>)).slice(-<span class="number">2</span>), <span class="comment">// 月份 不足两位补0</span></span><br><span class="line">        <span class="attr">d</span>: date.getDate(), <span class="comment">// 天 不足两位不补0</span></span><br><span class="line">        <span class="attr">dd</span>: (<span class="string">&#x27;0&#x27;</span> + date.getDate()).slice(-<span class="number">2</span>), <span class="comment">// 天 不足两位补0</span></span><br><span class="line">        <span class="attr">H</span>: date.getHours(), <span class="comment">// 24小时 不足两位不补0</span></span><br><span class="line">        <span class="attr">HH</span>: (<span class="string">&#x27;0&#x27;</span> + date.getHours()).slice(-<span class="number">2</span>), <span class="comment">// 24小时 不足两位补0</span></span><br><span class="line">        <span class="attr">h</span>: date.getHours() % <span class="number">12</span>, <span class="comment">// 12小时制 不足两位不补0</span></span><br><span class="line">        <span class="attr">hh</span>: (<span class="string">&#x27;0&#x27;</span> + (date.getHours() % <span class="number">12</span>)).slice(-<span class="number">2</span>), <span class="comment">// 12小时制 不足两位补0</span></span><br><span class="line">        <span class="attr">m</span>: date.getMinutes(),  <span class="comment">// 分钟 不足两位不补0</span></span><br><span class="line">        <span class="attr">mm</span>: (<span class="string">&#x27;0&#x27;</span> + date.getMinutes()).slice(-<span class="number">2</span>), <span class="comment">// 分钟 不足两位补0</span></span><br><span class="line">        <span class="attr">s</span>: date.getSeconds(),  <span class="comment">// 秒 不足两位不补0</span></span><br><span class="line">        <span class="attr">ss</span>: (<span class="string">&#x27;0&#x27;</span> + date.getSeconds()).slice(-<span class="number">2</span>),  <span class="comment">// 秒 不足两位补0</span></span><br><span class="line">        <span class="attr">w</span>: [<span class="string">&#x27;日&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;二&#x27;</span>, <span class="string">&#x27;三&#x27;</span>, <span class="string">&#x27;四&#x27;</span>, <span class="string">&#x27;五&#x27;</span>, <span class="string">&#x27;六&#x27;</span>][date.getDay()], <span class="comment">// 星期</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> format.replace(<span class="regexp">/([a-z]+)/gi</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj[key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(formatDate(<span class="string">&#x27;2021-07-03 19:00:00&#x27;</span>));</span><br><span class="line"><span class="comment">// 2021-07-03 19:00:00 星期六</span></span><br></pre></td></tr></table></figure><h2 id="dayjs"><a href="#dayjs" class="headerlink" title="dayjs"></a><a href="https://dayjs.fenxianglu.cn/">dayjs</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Js中Date对象&quot;&gt;&lt;a href=&quot;#Js中Date对象&quot; class=&quot;headerlink&quot; title=&quot;Js中Date对象&quot;&gt;&lt;/a&gt;Js中Date对象&lt;/h1&gt;&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="JS" scheme="https://lesliewaong.top/categories/JS/"/>
    
    
    <category term="Date" scheme="https://lesliewaong.top/tags/Date/"/>
    
    <category term="JS" scheme="https://lesliewaong.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>开发者工具</title>
    <link href="https://lesliewaong.top/posts/7a69cd3a.html"/>
    <id>https://lesliewaong.top/posts/7a69cd3a.html</id>
    <published>2022-06-21T04:01:12.000Z</published>
    <updated>2022-07-17T08:40:25.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h1><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p>命令行面板=&gt;screenshot</p><p><a href="https://imgtu.com/i/j4HQ0O"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/16/j4HQ0O.png" alt="j4HQ0O.png"></a></p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p><a href="https://imgtu.com/i/j4HMnK"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/16/j4HMnK.png" alt="j4HMnK.png"></a></p><h2 id="拾色器"><a href="#拾色器" class="headerlink" title="拾色器"></a>拾色器</h2><p><a href="https://imgtu.com/i/j4HuX6"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/16/j4HuX6.png" alt="j4HuX6.png"></a></p><h2 id="在线调伪类样式"><a href="#在线调伪类样式" class="headerlink" title="在线调伪类样式"></a>在线调伪类样式</h2><p><a href="https://imgtu.com/i/j4HVh9"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/16/j4HVh9.png" alt="j4HVh9.png"></a></p><h2 id="查看元素绑定事件"><a href="#查看元素绑定事件" class="headerlink" title="查看元素绑定事件"></a>查看元素绑定事件</h2><p><a href="https://imgtu.com/i/j4Hn6x"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/16/j4Hn6x.png" alt="j4Hn6x.png"></a></p><h2 id="全局搜索代码"><a href="#全局搜索代码" class="headerlink" title="全局搜索代码"></a>全局搜索代码</h2><p><a href="https://imgtu.com/i/j4HepR"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/16/j4HepR.png" alt="j4HepR.png"></a></p><h2 id="Rendering-实时检测网页变化"><a href="#Rendering-实时检测网页变化" class="headerlink" title="Rendering 实时检测网页变化"></a>Rendering 实时检测网页变化</h2><p>下面是比较实用的功能：</p><ol><li>Paint flashing，实时高亮重绘区域（绿色）。</li><li>Layout Shift Regions，实时高亮重排（重新布局）区域（蓝色）。</li><li>Layer borders，将合成层用边框标出来（橙色、橄榄色、青色）。</li></ol><p><a href="https://imgtu.com/i/j4Hm11"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/16/j4Hm11.png" alt="j4Hm11.png"></a></p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p><a href="https://imgtu.com/i/j4HEtJ"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/16/j4HEtJ.png" alt="j4HEtJ.png"></a></p><h2 id="NetWork"><a href="#NetWork" class="headerlink" title="NetWork"></a>NetWork</h2><p><a href="https://imgtu.com/i/qeLtoQ"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/20/qeLtoQ.png" alt="qeLtoQ.png"></a></p><p><strong>瀑布图</strong>是什么呢？</p><p>瀑布图就是上方图片后面的<strong>waterfall</strong>纵列</p><p>瀑布图是一个级联图, 展示了浏览器如何加载资源并渲染成网页. 图中的每一行都是一次单独的浏览器请求. 这个图越长, 说明加载网页过程中所发的请求越多. 每一行的宽度, 代表浏览器发出请求并下载该资源的过程中所耗费的时间。它的侧重点在于分析网路链路</p><p>瀑布图颜色说明：</p><ul><li><strong>DNS Lookup</strong> [深绿色] - 在浏览器和服务器进行通信之前, 必须经过DNS查询, 将域名转换成IP地址. 在这个阶段, 你可以处理的东西很少. 但幸运的是, 并非所有的请求都需要经过这一阶段。</li><li><strong>Initial Connection</strong> [橙色] - 在浏览器发送请求之前, 必须建立<strong>TCP</strong>连接. 这个过程仅仅发生在瀑布图中的开头几行, 否则这就是个性能问题(后边细说)。</li><li><strong>SSL/TLS Negotiation</strong> [紫色] - 如果你的页面是通过<strong>SSL/TLS</strong>这类安全协议加载资源, 这段时间就是浏览器建立安全连接的过程。目前Google将HTTPS作为其搜索排名因素 之一, SSL/TLS 协商的使用变得越来越普遍了。</li><li><strong>Time To First Byte (TTFB)</strong> [绿色] - <strong>TTFB 是浏览器请求发送到服务器的时间+服务器处理请求时间+响应报文的第一字节到达浏览器的时间</strong>。 我们用这个指标来判断你的web服务器是否性能不够, 或者说你是否需要使用CDN。</li><li><strong>Downloading (蓝色)</strong> - 这是浏览器用来下载资源所用的时间. 这段时间越长, 说明资源越大. 理想情况下, 你可以通过控制资源的大小来控制这段时间的长度。</li></ul><p>那么除了瀑布图的长度外，我们如何才能判断一个瀑布图的状态是<strong>健康</strong>的呢？</p><ul><li>首先, 减少所有资源的加载时间. 亦即减小瀑布图的宽度。 瀑布图越窄, 网站的访问速度越快。</li><li>其次, 减少请求数量，也就是降低瀑布图的高度。瀑布图越矮越好。</li><li>最后, 通过优化资源请求顺序来加快渲染时间。从图上看, 就是将绿色的”开始渲染”线向左移。这条线向左移动的越远越好。</li></ul><p>这样，我们就可以从network的角度去排查“慢”的问题。</p><p><strong>蓝线</strong>表示 DOMReady 事件。事件触发的条件是：浏览器已经把整个 HTML 文档的 DOM 结构解析完毕。一般前端开发者监听这个事件是为了可靠地在文档中查找元素。这个事件触发之前有可能只下载了半截 HTML，想要的元素还没出现。</p><p><strong>红线</strong>表示 load 事件，触发条件是：整个页面的 JS CSS 图片都下载完毕。用户看到的进度条/小菊花已经不再显示为 “忙” 的状态。是用户眼中的加载完毕。</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p><a href="https://imgtu.com/i/qeLYdg"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/03/20/qeLYdg.png" alt="qeLYdg.png"></a></p><h2 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h2><p><a href="https://imgtu.com/i/j4H5EF"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/16/j4H5EF.png" alt="j4H5EF.png"></a></p><h2 id="调整页面元素布局"><a href="#调整页面元素布局" class="headerlink" title="调整页面元素布局"></a>调整页面元素布局</h2><p>元素面板直接拖动即可</p><p>控制台输入：</p><ul><li><code>$0</code> 返回当前选中元素</li><li><code>$_</code> 返回上一次的结果</li><li><code>copy(想要复制的数据)</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开发者工具&quot;&gt;&lt;a href=&quot;#开发者工具&quot; class=&quot;headerlink&quot; title=&quot;开发者工具&quot;&gt;&lt;/a&gt;开发者工具&lt;/h1&gt;&lt;h2 id=&quot;截图&quot;&gt;&lt;a href=&quot;#截图&quot; class=&quot;headerlink&quot; title=&quot;截图&quot;&gt;&lt;/a&gt;截</summary>
      
    
    
    
    <category term="工具" scheme="https://lesliewaong.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="开发者工具" scheme="https://lesliewaong.top/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript+React</title>
    <link href="https://lesliewaong.top/posts/3e7be573.html"/>
    <id>https://lesliewaong.top/posts/3e7be573.html</id>
    <published>2022-06-17T05:12:48.000Z</published>
    <updated>2022-07-17T08:40:25.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-TypeScript-实践"><a href="#React-TypeScript-实践" class="headerlink" title="React+TypeScript 实践"></a><a href="https://mp.weixin.qq.com/s/PRs9IsNeqS7JYILuOEEXIw">React+TypeScript 实践</a></h1><h2 id="如何引入-React"><a href="#如何引入-React" class="headerlink" title="如何引入 React"></a>如何引入 React</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br></pre></td></tr></table></figure><p>这种引用方式<strong>被证明</strong>是最可靠的一种方式， <strong>推荐使用</strong>。</p><p>而另外一种引用方式:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br></pre></td></tr></table></figure><p>需要添加额外的配置：<code>&quot;allowSyntheticDefaultImports&quot;: true</code></p><h2 id="函数式组件的声明方式"><a href="#函数式组件的声明方式" class="headerlink" title="函数式组件的声明方式"></a>函数式组件的声明方式</h2><p>声明的几种方式</p><p>第一种：也是比较<strong>推荐</strong>的一种，使用 <strong>React.FunctionComponent</strong>，简写形式：<strong>React.FC:</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Great</span></span><br><span class="line">type AppProps = &#123;</span><br><span class="line">  <span class="attr">message</span>: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App: React.FC&lt;AppProps&gt; = <span class="function">(<span class="params">&#123; message, children &#125;</span>) =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;message&#125;</span></span><br><span class="line"><span class="xml">    &#123;children&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用<strong>用 React.FC 声明函数组件</strong>和<strong>普通声明</strong>以及 <strong>PropsWithChildren</strong> 的区别是：</p><ul><li><p>React.FC <strong>显式地定义了返回类型</strong>，其他方式是隐式推导的</p></li><li><p>React.FC 对静态属性：<strong>displayName、propTypes、defaultProps</strong> 提供了类型检查和自动补全</p></li><li><p>React.FC <strong>为 children 提供了隐式的类型</strong>（ReactElement | null），但是目前，提供的类型存在<strong>一些 issue</strong>（问题）</p></li></ul><p>比如以下用法 React.FC 会报类型错误:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App: React.FC = <span class="function"><span class="params">props</span> =&gt;</span> props.children</span><br><span class="line"><span class="keyword">const</span> App: React.FC = <span class="function">() =&gt;</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> App: React.FC = <span class="function">() =&gt;</span> <span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><p>解决方法:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App: React.FC&lt;&#123;&#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> props.children <span class="keyword">as</span> any</span><br><span class="line"><span class="keyword">const</span> App: React.FC&lt;&#123;&#125;&gt; = <span class="function">() =&gt;</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> any</span><br><span class="line"><span class="keyword">const</span> App: React.FC&lt;&#123;&#125;&gt; = <span class="function">() =&gt;</span> <span class="string">&#x27;hello&#x27;</span> <span class="keyword">as</span> any</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> App: React.FC&lt;&#123;&#125;&gt; = <span class="function"><span class="params">props</span> =&gt;</span> (props.children <span class="keyword">as</span> unknown) <span class="keyword">as</span> JSX.Element</span><br><span class="line"><span class="keyword">const</span> App: React.FC&lt;&#123;&#125;&gt; = <span class="function">() =&gt;</span> ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> unknown) <span class="keyword">as</span> JSX.Element</span><br><span class="line"><span class="keyword">const</span> App: React.FC&lt;&#123;&#125;&gt; = <span class="function">() =&gt;</span> (<span class="string">&#x27;hello&#x27;</span> <span class="keyword">as</span> unknown) <span class="keyword">as</span> JSX.Element</span><br></pre></td></tr></table></figure><p>在通常情况下，使用 <strong>React.FC</strong> 的方式声明最简单有效，推荐使用；如果出现类型不兼容问题，建议使用<strong>以下两种方式：</strong></p><p>第二种：使用 <strong>PropsWithChildren</strong>，这种方式可以为你省去频繁定义 children 的类型，自动设置 children 类型为 ReactNode:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type AppProps = React.PropsWithChildren&lt;&#123; <span class="attr">message</span>: string &#125;&gt;</span><br><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">&#123; message, children &#125;: AppProps</span>) =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;message&#125;</span></span><br><span class="line"><span class="xml">    &#123;children&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>第三种：直接声明:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type AppProps = &#123;</span><br><span class="line">  <span class="attr">message</span>: string</span><br><span class="line">  children?: React.ReactNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">&#123; message, children &#125;: AppProps</span>) =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;message&#125;</span></span><br><span class="line"><span class="xml">    &#123;children&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><h3 id="useState-lt-T-gt"><a href="#useState-lt-T-gt" class="headerlink" title="useState&lt;T&gt;"></a><code>useState&lt;T&gt;</code></h3><p>大部分情况下，TS 会自动为你推导 <strong>state</strong> 的类型:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `val`会推导为boolean类型， toggle接收boolean类型参数</span></span><br><span class="line"><span class="keyword">const</span> [val, toggle] = React.useState(<span class="literal">false</span>)</span><br><span class="line"><span class="comment">// obj会自动推导为类型: &#123;name: string&#125;</span></span><br><span class="line"><span class="keyword">const</span> [obj] = React.useState(&#123; <span class="attr">name</span>: <span class="string">&#x27;sj&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// arr会自动推导为类型: string[]</span></span><br><span class="line"><span class="keyword">const</span> [arr] = React.useState([<span class="string">&#x27;One&#x27;</span>, <span class="string">&#x27;Two&#x27;</span>])</span><br></pre></td></tr></table></figure><p>使用推导类型作为接口/类型:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// user会自动推导为类型: &#123;name: string&#125;</span></span><br><span class="line">    <span class="keyword">const</span> [user] = React.useState(&#123; <span class="attr">name</span>: <span class="string">&#x27;sj&#x27;</span>, <span class="attr">age</span>: <span class="number">32</span> &#125;)</span><br><span class="line">    <span class="keyword">const</span> showUser = React.useCallback(<span class="function">(<span class="params">obj: <span class="keyword">typeof</span> user</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`My name is <span class="subst">$&#123;obj.name&#125;</span>, My age is <span class="subst">$&#123;obj.age&#125;</span>`</span></span><br><span class="line">    &#125;, [])  </span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span>用户: &#123;showUser(user)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，一些状态初始值为空时（<strong>null</strong>），需要显示地声明类型：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type User = &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [user, setUser] = React.useState&lt;User | <span class="literal">null</span>&gt;(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><h3 id="useRef-lt-T-gt"><a href="#useRef-lt-T-gt" class="headerlink" title="useRef&lt;T&gt;"></a><code>useRef&lt;T&gt;</code></h3><p>当初始值为 <strong>null</strong> 时，有两种创建方式:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref1 = React.useRef&lt;HTMLInputElement&gt;(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> ref2 = React.useRef&lt;HTMLInputElement | <span class="literal">null</span>&gt;(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p><strong>这两种的区别在于</strong>：</p><ul><li>第一种方式的 ref1.current 是<strong>只读的（read-only）</strong>，并且<strong>可以传递给内置的 ref 属性，绑定 DOM 元素</strong> <strong>；</strong></li><li>第二种方式的 ref2.current 是<strong>可变的</strong>（类似于声明类的成员变量）</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = React.useRef(<span class="number">0</span>)</span><br><span class="line">React.useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ref.current += <span class="number">1</span></span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><p>这两种方式在使用时，都需要对类型进行检查:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onButtonClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ref1.current?.focus()</span><br><span class="line">  ref2.current?.focus()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在某种情况下，可以省去类型检查，通过添加 <strong>!</strong> <strong>断言</strong>，<strong>不推荐</strong>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref1 = React.useRef&lt;HTMLDivElement&gt;(<span class="literal">null</span>!)</span><br><span class="line">  React.useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//  不需要做类型检查，需要人为保证ref1.current.focus一定存在</span></span><br><span class="line">    doSomethingWith(ref1.current.focus())</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;ref1&#125;</span>&gt;</span> etc <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a><code>useEffect</code></h3><p><strong>useEffect</strong> 需要注意回调函数的返回值只能是函数或者 <strong>undefined</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// undefined作为回调函数的返回值</span></span><br><span class="line">  React.useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="comment">// 返回值是一个函数</span></span><br><span class="line">  React.useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useMemo-lt-T-gt-useCallback-lt-T-gt"><a href="#useMemo-lt-T-gt-useCallback-lt-T-gt" class="headerlink" title="useMemo&lt;T&gt; / useCallback&lt;T&gt;"></a><code>useMemo&lt;T&gt; / useCallback&lt;T&gt;</code></h3><p><strong>useMemo</strong> 和 <strong>useCallback</strong> 都可以直接从它们返回的值中推断出它们的类型</p><p><strong>useCallback</strong> 的参数必须制定类型，否则 ts 不会报错，默认指定为 <strong>any</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="number">10</span></span><br><span class="line"><span class="comment">// 自动推断返回值为 number</span></span><br><span class="line"><span class="keyword">const</span> result = React.useMemo(<span class="function">() =&gt;</span> value * <span class="number">2</span>, [value])</span><br><span class="line"><span class="comment">// 自动推断 (value: number) =&gt; number</span></span><br><span class="line"><span class="keyword">const</span> multiply = React.useCallback(<span class="function">(<span class="params">value: number</span>) =&gt;</span> value * multiplier, [</span><br><span class="line">  multiplier,</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>同时也支持传入泛型， <strong>useMemo</strong> 的泛型指定了返回值类型，<strong>useCallback</strong> 的泛型指定了参数类型</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以显式的指定返回值类型，返回值不一致会报错</span></span><br><span class="line"><span class="keyword">const</span> result = React.useMemo&lt;string&gt;(<span class="function">() =&gt;</span> <span class="number">2</span>, [])</span><br><span class="line"><span class="comment">// 类型“() =&gt; number”的参数不能赋给类型“() =&gt; string”的参数。</span></span><br><span class="line"><span class="keyword">const</span> handleChange = React.useCallback&lt;</span><br><span class="line">  React.ChangeEventHandler&lt;HTMLInputElement&gt;</span><br><span class="line">&gt;(<span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(evt.target.value)</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><h3 id="自定义-Hooks"><a href="#自定义-Hooks" class="headerlink" title="自定义 Hooks"></a>自定义 Hooks</h3><p>需要注意，自定义 Hook 的返回值如果是<strong>数组类型</strong>，TS 会自动推导为 <strong>Union</strong> 类型，而我们实际需要的是数组里里每一项的具体类型，需要手动添加 <strong>const</strong> <strong>断言</strong> 进行处理：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useLoading</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setState] = React.useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> load = <span class="function">(<span class="params">aPromise: <span class="built_in">Promise</span>&lt;any&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    setState(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> aPromise.then(<span class="function">() =&gt;</span> setState(<span class="literal">false</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实际需要: [boolean, typeof load] 类型</span></span><br><span class="line">  <span class="comment">// 而不是自动推导的：(boolean | typeof load)[]</span></span><br><span class="line">  <span class="keyword">return</span> [isLoading, load] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用 <strong>const</strong> 断言遇到<strong>问题</strong>，也可以直接定义返回类型:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useLoading</span>(<span class="params"></span>): [</span></span><br><span class="line"><span class="function">  <span class="title">boolean</span>,</span></span><br><span class="line"><span class="function">  (<span class="params">aPromise: <span class="built_in">Promise</span>&lt;any&gt;</span>) =&gt; <span class="title">Promise</span>&lt;<span class="title">any</span>&gt;</span></span><br><span class="line"><span class="function">] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setState] = React.useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> load = <span class="function">(<span class="params">aPromise: <span class="built_in">Promise</span>&lt;any&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    setState(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> aPromise.then(<span class="function">() =&gt;</span> setState(<span class="literal">false</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [isLoading, load]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有大量的自定义 Hook 需要处理，这里有一个方便的工具方法可以处理 tuple 返回值:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tuplify</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">any</span>[]&gt;(<span class="params">...elements: T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elements</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useLoading</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setState] = React.useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> load = <span class="function">(<span class="params">aPromise: <span class="built_in">Promise</span>&lt;any&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    setState(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> aPromise.then(<span class="function">() =&gt;</span> setState(<span class="literal">false</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (boolean | typeof load)[]</span></span><br><span class="line">  <span class="keyword">return</span> [isLoading, load]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTupleLoading</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setState] = React.useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> load = <span class="function">(<span class="params">aPromise: <span class="built_in">Promise</span>&lt;any&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    setState(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> aPromise.then(<span class="function">() =&gt;</span> setState(<span class="literal">false</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// [boolean, typeof load]</span></span><br><span class="line">  <span class="keyword">return</span> tuplify(isLoading, load)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认属性-defaultProps"><a href="#默认属性-defaultProps" class="headerlink" title="默认属性 defaultProps"></a>默认属性 defaultProps</h2><p>大部分文章都<strong>不推荐</strong>使用 defaultProps <strong>,</strong> 相关讨论可以点击<strong>参考链接</strong></p><p>推荐方式：使用<strong>默认参数值</strong>来代替<strong>默认属性：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type GreetProps = &#123; age?: number &#125;</span><br><span class="line"><span class="keyword">const</span> Greet = <span class="function">(<span class="params">&#123; age = <span class="number">21</span> &#125;: GreetProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="defaultProps-类型"><a href="#defaultProps-类型" class="headerlink" title="defaultProps 类型"></a>defaultProps 类型</h3><p><strong>TypeScript3.0+<strong>在默认属性 的类型推导上有了极大的改进，虽然尚且</strong>存在一些边界 case 仍然存在问题</strong>，<strong>不推荐使用</strong>，如果有需要使用的场景，可参照如下方式：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type IProps = &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> defaultProps = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line">type GreetProps = IProps &amp; <span class="keyword">typeof</span> defaultProps</span><br><span class="line"><span class="keyword">const</span> Greet = <span class="function">(<span class="params">props: GreetProps</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">Greet.defaultProps = defaultProps</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> TestComponent = <span class="function">(<span class="params">props: React.ComponentProps&lt;<span class="keyword">typeof</span> Greet&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> el = <span class="xml"><span class="tag">&lt;<span class="name">TestComponent</span> <span class="attr">name</span>=<span class="string">&quot;foo&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="Types-or-Interfaces"><a href="#Types-or-Interfaces" class="headerlink" title="Types or Interfaces"></a>Types or Interfaces</h2><p>在日常的 react 开发中 <strong>interface</strong> 和 <strong>type</strong> 的使用场景十分类似</p><p><strong>implements</strong> 与 <strong>extends</strong> 静态操作，不允许存在一种或另一种实现的情况，所以<strong>不支持使用联合类型：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="attr">x</span>: number = <span class="number">2</span></span><br><span class="line">  <span class="attr">y</span>: number = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">interface IShape &#123;</span><br><span class="line">  area(): number</span><br><span class="line">&#125;</span><br><span class="line">type Perimeter = &#123;</span><br><span class="line">  perimeter(): number</span><br><span class="line">&#125;</span><br><span class="line">type RectangleShape = (IShape | Perimeter) &amp; Point</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="title">implements</span> <span class="title">RectangleShape</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 类只能实现具有静态已知成员的对象类型或对象类型的交集。</span></span><br><span class="line">  x = <span class="number">2</span></span><br><span class="line">  y = <span class="number">3</span></span><br><span class="line">  <span class="function"><span class="title">area</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.x + <span class="built_in">this</span>.y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface ShapeOrPerimeter <span class="keyword">extends</span> RectangleShape &#123;&#125;</span><br><span class="line"><span class="comment">// 接口只能扩展使用静态已知成员的对象类型或对象类型的交集</span></span><br></pre></td></tr></table></figure><h3 id="使用-Type-还是-Interface？"><a href="#使用-Type-还是-Interface？" class="headerlink" title="使用 Type 还是 Interface？"></a>使用 Type 还是 Interface？</h3><p>有几种常用规则：</p><ul><li><p>在定义公共 API 时(比如编辑一个库）使用 <strong>interface</strong>，这样可以方便使用者继承接口</p></li><li><p>在定义组件属性（Props）和状态（State）时，建议使用 <strong>type</strong>，因为 <strong>type</strong>的约束性更强</p></li></ul><p><strong>interface</strong> 和 <strong>type</strong> 在 ts 中是两个不同的概念，但在 React 大部分使用的 <strong>case</strong> 中，<strong>interface</strong> 和 <strong>type</strong> 可以达到相同的功能效果，<strong>type</strong> 和 <strong>interface 最大的区别</strong>是：</p><ul><li><strong>type</strong> 类型不能二次编辑，而 <strong>interface</strong> 可以随时扩展</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Animal &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以继续在原有属性基础上，添加新属性：color</span></span><br><span class="line">interface Animal &#123;</span><br><span class="line">  <span class="attr">color</span>: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************/</span></span><br><span class="line">type Animal = &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type类型不支持属性扩展</span></span><br><span class="line"><span class="comment">// Error: Duplicate identifier &#x27;Animal&#x27;</span></span><br><span class="line">type Animal = &#123;</span><br><span class="line">  <span class="attr">color</span>: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取未导出的-Type"><a href="#获取未导出的-Type" class="headerlink" title="获取未导出的 Type"></a>获取未导出的 Type</h3><p>某些场景下我们在引入第三方的库时会发现想要使用的组件并没有导出我们需要的组件参数类型或者返回值类型，这时候我们可以通过 ComponentProps/ ReturnType 来获取到想要的类型。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取参数类型</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">&#x27;library&#x27;</span> <span class="comment">// 但是未导出props type</span></span><br><span class="line">type ButtonProps = React.ComponentProps&lt;<span class="keyword">typeof</span> Button&gt; <span class="comment">// 获取props</span></span><br><span class="line">type AlertButtonProps = Omit&lt;ButtonProps, <span class="string">&#x27;onClick&#x27;</span>&gt; <span class="comment">// 去除onClick</span></span><br><span class="line"><span class="keyword">const</span> AlertButton: React.FC&lt;AlertButtonProps&gt; = <span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> alert(&#x27;hello&#x27;)&#125; &#123;...props&#125; /&gt;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 获取返回值类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">baz</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">type FooReturn = ReturnType&lt;<span class="keyword">typeof</span> foo&gt; <span class="comment">// &#123; baz: number &#125;</span></span><br></pre></td></tr></table></figure><h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><p>通常我们使用 <strong>type</strong> 来定义 <strong>Props</strong>，为了提高可维护性和代码可读性，在日常的开发过程中我们希望可以添加清晰的注释。</p><p>现在有这样一个 <strong>type</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type OtherProps = &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">color</span>: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用的过程中，hover 对应类型会有如下展示</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type OtherProps = &#123;</span></span><br><span class="line"><span class="comment">//   name: string;</span></span><br><span class="line"><span class="comment">//   color: string;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">const</span> OtherHeading: React.FC&lt;OtherProps&gt; = <span class="function">(<span class="params">&#123; name, color &#125;</span>) =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My Website Heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>增加相对详细的注释，使用时会更清晰，需要注意，<strong>注释需要使用</strong> <strong>/**/</strong> <strong>，</strong> <strong>//</strong> <strong>无法被 vscode 识别</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Great</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>color color</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>children children</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>onClick onClick</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">type Props = &#123;</span><br><span class="line">  <span class="comment">/** color */</span></span><br><span class="line">  color?: string</span><br><span class="line">  <span class="comment">/** children */</span></span><br><span class="line">  <span class="attr">children</span>: React.ReactNode</span><br><span class="line">  <span class="comment">/** onClick */</span></span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type Props</span></span><br><span class="line"><span class="comment">// @param color — color</span></span><br><span class="line"><span class="comment">// @param children — children</span></span><br><span class="line"><span class="comment">// @param onClick — onClick</span></span><br><span class="line"><span class="keyword">const</span> Button: React.FC&lt;Props&gt; = <span class="function">(<span class="params">&#123; children, color = <span class="string">&#x27;tomato&#x27;</span>, onClick &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">backgroundColor:</span> <span class="attr">color</span> &#125;&#125; <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;children&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用-Props-ts-类型"><a href="#常用-Props-ts-类型" class="headerlink" title="常用 Props ts 类型"></a>常用 Props ts 类型</h2><h3 id="基础属性类型"><a href="#基础属性类型" class="headerlink" title="基础属性类型"></a>基础属性类型</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">type AppProps = &#123;</span><br><span class="line">  <span class="attr">message</span>: string</span><br><span class="line">  <span class="attr">count</span>: number</span><br><span class="line">  <span class="attr">disabled</span>: boolean</span><br><span class="line">  <span class="comment">/** array of a type! */</span></span><br><span class="line">  <span class="attr">names</span>: string[]</span><br><span class="line">  <span class="comment">/** string literals to specify exact string values, with a union type to join them together */</span></span><br><span class="line">  <span class="attr">status</span>: <span class="string">&#x27;waiting&#x27;</span> | <span class="string">&#x27;success&#x27;</span></span><br><span class="line">  <span class="comment">/** 任意需要使用其属性的对象（不推荐使用，但是作为占位很有用） */</span></span><br><span class="line">  <span class="attr">obj</span>: object</span><br><span class="line">  <span class="comment">/** 作用和`object`几乎一样，和 `Object`完全一样 */</span></span><br><span class="line">  <span class="attr">obj2</span>: &#123;&#125;</span><br><span class="line">  <span class="comment">/** 列出对象全部数量的属性 （推荐使用） */</span></span><br><span class="line">  <span class="attr">obj3</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: string</span><br><span class="line">    <span class="attr">title</span>: string</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** array of objects! (common) */</span></span><br><span class="line">  <span class="attr">objArr</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: string</span><br><span class="line">    <span class="attr">title</span>: string</span><br><span class="line">  &#125;[]</span><br><span class="line">  <span class="comment">/** 任意数量属性的字典，具有相同类型*/</span></span><br><span class="line">  <span class="attr">dict1</span>: &#123;</span><br><span class="line">    [key: string]: MyTypeHere</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 作用和dict1完全相同 */</span></span><br><span class="line">  <span class="attr">dict2</span>: Record&lt;string, MyTypeHere&gt;</span><br><span class="line">  <span class="comment">/** 任意完全不会调用的函数 */</span></span><br><span class="line">  onSomething: <span class="built_in">Function</span></span><br><span class="line">  <span class="comment">/** 没有参数&amp;返回值的函数 */</span></span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">  <span class="comment">/** 携带参数的函数 */</span></span><br><span class="line">  <span class="attr">onChange</span>: <span class="function">(<span class="params">id: number</span>) =&gt;</span> <span class="keyword">void</span></span><br><span class="line">  <span class="comment">/** 携带点击事件的函数 */</span></span><br><span class="line">  onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): <span class="keyword">void</span></span><br><span class="line">  <span class="comment">/** 可选的属性 */</span></span><br><span class="line">  optional?: OptionalType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用-React-属性类型"><a href="#常用-React-属性类型" class="headerlink" title="常用 React 属性类型"></a>常用 React 属性类型</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> declare interface AppBetterProps &#123;</span><br><span class="line">  <span class="attr">children</span>: React.ReactNode <span class="comment">// 一般情况下推荐使用，支持所有类型 Great</span></span><br><span class="line">  <span class="attr">functionChildren</span>: <span class="function">(<span class="params">name: string</span>) =&gt;</span> React.ReactNode</span><br><span class="line">  style?: React.CSSProperties <span class="comment">// 传递style对象</span></span><br><span class="line">  onChange?: React.FormEventHandler&lt;HTMLInputElement&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> declare interface AppProps &#123;</span><br><span class="line">  <span class="attr">children1</span>: JSX.Element <span class="comment">// 差, 不支持数组</span></span><br><span class="line">  <span class="attr">children2</span>: JSX.Element | JSX.Element[] <span class="comment">// 一般, 不支持字符串</span></span><br><span class="line">  <span class="attr">children3</span>: React.ReactChildren <span class="comment">// 忽略命名，不是一个合适的类型，工具类类型</span></span><br><span class="line">  <span class="attr">children4</span>: React.ReactChild[] <span class="comment">// 很好</span></span><br><span class="line">  <span class="attr">children</span>: React.ReactNode <span class="comment">// 最佳，支持所有类型 推荐使用</span></span><br><span class="line">  <span class="attr">functionChildren</span>: <span class="function">(<span class="params">name: string</span>) =&gt;</span> React.ReactNode <span class="comment">// recommended function as a child render prop type</span></span><br><span class="line">  style?: React.CSSProperties <span class="comment">// 传递style对象</span></span><br><span class="line">  onChange?: React.FormEventHandler&lt;HTMLInputElement&gt; <span class="comment">// 表单事件, 泛型参数是event.target的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Forms-and-Events"><a href="#Forms-and-Events" class="headerlink" title="Forms and Events"></a>Forms and Events</h2><h3 id="onChange"><a href="#onChange" class="headerlink" title="onChange"></a>onChange</h3><p><strong>change</strong> 事件，有两个定义参数类型的方法。</p><p>第一种方法使用推断的方法签名（例如：<code>React.FormEvent &lt;HTMLInputElement&gt; ：void</code>）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line">type changeFn = <span class="function">(<span class="params">e: React.FormEvent&lt;HTMLInputElement&gt;</span>) =&gt;</span> <span class="keyword">void</span></span><br><span class="line"><span class="keyword">const</span> App: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = React.useState(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> onChange: changeFn = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    setState(e.currentTarget.value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;state&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法强制使用 <strong>@types / react</strong> 提供的委托类型，两种方法均可。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span><span class="keyword">const</span> App: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = React.useState(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> onChange: React.ChangeEventHandler&lt;HTMLInputElement&gt; = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    setState(e.currentTarget.value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;state&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="onSubmit"><a href="#onSubmit" class="headerlink" title="onSubmit"></a>onSubmit</h3><p>如果不太关心事件的类型，可以直接使用 <strong>React.SyntheticEvent</strong>，如果目标表单有想要访问的自定义命名输入，可以使用类型扩展</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> onSubmit = <span class="function">(<span class="params">e: React.SyntheticEvent</span>) =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">    <span class="keyword">const</span> target = e.target <span class="keyword">as</span> <span class="keyword">typeof</span> e.target &amp; &#123;</span><br><span class="line">      <span class="attr">password</span>: &#123; <span class="attr">value</span>: string &#125;</span><br><span class="line">    &#125; <span class="comment">// 类型扩展</span></span><br><span class="line">    <span class="keyword">const</span> password = target.password.value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;onSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">          Password:</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Log in&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><p>常用的操作符，常用于类型判断</p><ul><li><p><code>typeof and instanceof</code>: 用于类型区分</p></li><li><p><code>keyof</code>: 获取 object 的 key</p></li><li><p><code>O[K]:</code> 属性查找</p></li><li><p><code>[K in O]</code>：映射类型</p></li><li><p><code>+ or - or readonly or ?</code>: 加法、减法、只读和可选修饰符</p></li><li><p><code>x ? Y : Z</code>: 用于泛型类型、类型别名、函数参数类型的条件类型</p></li><li><p><code>!</code>: 可空类型的空断言</p></li><li><p><code>as</code>: 类型断言</p></li><li><p><code>is</code>: 函数返回类型的类型保护</p></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="使用查找类型访问组件属性类型"><a href="#使用查找类型访问组件属性类型" class="headerlink" title="使用查找类型访问组件属性类型"></a>使用查找类型访问组件属性类型</h3><p>通过查找类型减少 <strong>type</strong> 的非必要导出，如果需要提供复杂的 <strong>type</strong>，应当提取到作为公共 API 导出的文件中。</p><p>现在我们有一个 Counter 组件，需要 name 这个必传参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// counter.tsx</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">export</span> type Props = &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Counter: React.FC&lt;Props&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span><span class="tag">&lt;/&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter</span><br></pre></td></tr></table></figure><p>在其他引用它的组件中我们有两种方式获取到 Counter 的参数类型</p><p>第一种是通过 <strong>typeof</strong> 操作符（<strong>推荐</strong>）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Great</span></span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">&#x27;./d-tips1&#x27;</span></span><br><span class="line">type PropsNew = React.ComponentProps&lt;<span class="keyword">typeof</span> Counter&gt; &amp; &#123;</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> App: React.FC&lt;PropsNew&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Counter</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><p>第二种是通过在原组件进行导出</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Counter, &#123; Props &#125; <span class="keyword">from</span> <span class="string">&#x27;./d-tips1&#x27;</span></span><br><span class="line">type PropsNew = Props &amp; &#123;</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> App: React.FC&lt;PropsNew&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Counter</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><h3 id="不要在-type-或-interface-中使用函数声明"><a href="#不要在-type-或-interface-中使用函数声明" class="headerlink" title="不要在 type 或 interface 中使用函数声明"></a>不要在 type 或 interface 中使用函数声明</h3><p>保持一致性，类型/接口的所有成员都通过相同的语法定义。</p><p><strong>–strictFunctionTypes</strong> 在比较函数类型时强制执行更严格的类型检查，但第一种声明方式下严格检查不生效。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">✅</span><br><span class="line"></span><br><span class="line">interface ICounter &#123;</span><br><span class="line">  <span class="attr">start</span>: <span class="function">(<span class="params">value: number</span>) =&gt;</span> string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">❌</span><br><span class="line"></span><br><span class="line">interface ICounter1 &#123;</span><br><span class="line">  start(value: number): string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">🌰</span><br><span class="line"></span><br><span class="line">interface Animal &#123;&#125;</span><br><span class="line">interface Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="attr">wow</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line">interface Comparer&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">compare</span>: <span class="function">(<span class="params">a: T, b: T</span>) =&gt;</span> number</span><br><span class="line">&#125;</span><br><span class="line">declare <span class="keyword">let</span> animalComparer: Comparer&lt;Animal&gt;</span><br><span class="line">declare <span class="keyword">let</span> dogComparer: Comparer&lt;Dog&gt;</span><br><span class="line">animalComparer = dogComparer <span class="comment">// Error</span></span><br><span class="line">dogComparer = animalComparer <span class="comment">// Ok</span></span><br><span class="line">interface Comparer1&lt;T&gt; &#123;</span><br><span class="line">  compare(a: T, <span class="attr">b</span>: T): number</span><br><span class="line">&#125;</span><br><span class="line">declare <span class="keyword">let</span> animalComparer1: Comparer1&lt;Animal&gt;</span><br><span class="line">declare <span class="keyword">let</span> dogComparer1: Comparer1&lt;Dog&gt;</span><br><span class="line">animalComparer1 = dogComparer <span class="comment">// Ok</span></span><br><span class="line">dogComparer1 = animalComparer <span class="comment">// Ok</span></span><br></pre></td></tr></table></figure><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>我们在进行事件注册时经常会在事件处理函数中使用 <strong>event</strong> 事件对象，例如当使用鼠标事件时我们通过 <strong>clientX</strong>、<strong>clientY</strong> 去获取指针的坐标。</p><p>大家可能会想到直接把 <strong>event</strong> 设置为 <strong>any</strong> 类型，但是这样就失去了我们对代码进行静态检查的意义。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">event: any</span>) </span>&#123;、</span><br><span class="line">  <span class="built_in">console</span>.log(event.clientY)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试想下当我们注册一个 <strong>Touch</strong> 事件，然后错误的通过事件处理函数中的 <strong>event</strong> 对象去获取其 <strong>clientY</strong> 属性的值，在这里我们已经将 <strong>event</strong> 设置为 <strong>any</strong> 类型，导致 <strong>TypeScript</strong> 在编译时并不会提示我们错误， 当我们通过 <strong>event.clientY</strong> 访问时就有问题了，因为 <strong>Touch</strong> 事件的 <strong>event</strong> 对象并没有 <strong>clientY</strong> 这个属性。</p><p>通过 <strong>interface</strong> 对 <strong>event</strong> 对象进行类型声明编写的话又十分浪费时间，幸运的是 <strong>React</strong> 的声明文件提供了 Event 对象的类型声明。</p><h4 id="Event-事件对象类型"><a href="#Event-事件对象类型" class="headerlink" title="Event 事件对象类型"></a>Event 事件对象类型</h4><ul><li><p>ClipboardEvent&lt;T = Element&gt; 剪切板事件对象</p></li><li><p>DragEvent&lt;T =Element&gt; 拖拽事件对象</p></li><li><p>ChangeEvent&lt;T = Element&gt; Change 事件对象</p></li><li><p>KeyboardEvent&lt;T = Element&gt; 键盘事件对象</p></li><li><p>MouseEvent&lt;T = Element&gt; 鼠标事件对象</p></li><li><p>TouchEvent&lt;T = Element&gt; 触摸事件对象</p></li><li><p>WheelEvent&lt;T = Element&gt; 滚轮时间对象</p></li><li><p>AnimationEvent&lt;T = Element&gt; 动画事件对象</p></li><li><p>TransitionEvent&lt;T = Element&gt; 过渡事件对象</p></li></ul><h4 id="事件处理函数类型"><a href="#事件处理函数类型" class="headerlink" title="事件处理函数类型"></a>事件处理函数类型</h4><p>当我们定义事件处理函数时有没有更方便定义其函数类型的方式呢？答案是使用 <strong>React</strong> 声明文件所提供的 <strong>EventHandler</strong> 类型别名，通过不同事件的 <strong>EventHandler</strong> 的类型别名来定义事件处理函数的类型</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type EventHandler&lt;E <span class="keyword">extends</span> React.SyntheticEvent&lt;any&gt;&gt; = &#123;</span><br><span class="line">  bivarianceHack(event: E): <span class="keyword">void</span></span><br><span class="line">&#125;[<span class="string">&#x27;bivarianceHack&#x27;</span>]</span><br><span class="line">type ReactEventHandler&lt;T = Element&gt; = EventHandler&lt;React.SyntheticEvent&lt;T&gt;&gt;</span><br><span class="line">type ClipboardEventHandler&lt;T = Element&gt; = EventHandler&lt;React.ClipboardEvent&lt;T&gt;&gt;</span><br><span class="line">type DragEventHandler&lt;T = Element&gt; = EventHandler&lt;React.DragEvent&lt;T&gt;&gt;</span><br><span class="line">type FocusEventHandler&lt;T = Element&gt; = EventHandler&lt;React.FocusEvent&lt;T&gt;&gt;</span><br><span class="line">type FormEventHandler&lt;T = Element&gt; = EventHandler&lt;React.FormEvent&lt;T&gt;&gt;</span><br><span class="line">type ChangeEventHandler&lt;T = Element&gt; = EventHandler&lt;React.ChangeEvent&lt;T&gt;&gt;</span><br><span class="line">type KeyboardEventHandler&lt;T = Element&gt; = EventHandler&lt;React.KeyboardEvent&lt;T&gt;&gt;</span><br><span class="line">type MouseEventHandler&lt;T = Element&gt; = EventHandler&lt;React.MouseEvent&lt;T&gt;&gt;</span><br><span class="line">type TouchEventHandler&lt;T = Element&gt; = EventHandler&lt;React.TouchEvent&lt;T&gt;&gt;</span><br><span class="line">type PointerEventHandler&lt;T = Element&gt; = EventHandler&lt;React.PointerEvent&lt;T&gt;&gt;</span><br><span class="line">type UIEventHandler&lt;T = Element&gt; = EventHandler&lt;React.UIEvent&lt;T&gt;&gt;</span><br><span class="line">type WheelEventHandler&lt;T = Element&gt; = EventHandler&lt;React.WheelEvent&lt;T&gt;&gt;</span><br><span class="line">type AnimationEventHandler&lt;T = Element&gt; = EventHandler&lt;React.AnimationEvent&lt;T&gt;&gt;</span><br><span class="line">type TransitionEventHandler&lt;T = Element&gt; = EventHandler&lt;</span><br><span class="line">  React.TransitionEvent&lt;T&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p><strong>bivarianceHack</strong> 为事件处理函数的类型定义，函数接收一个 <strong>event</strong> 对象，并且其类型为接收到的泛型变量 <strong>E</strong> 的类型, 返回值为 <strong>void</strong></p><blockquote><p>关于为何是用 bivarianceHack 而不是(event: E): void，这与 strictfunctionTypes 选项下的功能兼容性有关。(event: E): void，如果该参数是派生类型，则不能将其传递给参数是基类的函数。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  private x: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  private d: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line">type EventHandler&lt;E <span class="keyword">extends</span> Animal&gt; = <span class="function">(<span class="params">event: E</span>) =&gt;</span> <span class="keyword">void</span></span><br><span class="line"><span class="keyword">let</span> z: EventHandler&lt;Animal&gt; = <span class="function">(<span class="params">o: Dog</span>) =&gt;</span> &#123;&#125; <span class="comment">// fails under strictFunctionTyes</span></span><br><span class="line">type BivariantEventHandler&lt;E <span class="keyword">extends</span> Animal&gt; = &#123;</span><br><span class="line">  bivarianceHack(event: E): <span class="keyword">void</span></span><br><span class="line">&#125;[<span class="string">&#x27;bivarianceHack&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> y: BivariantEventHandler&lt;Animal&gt; = <span class="function">(<span class="params">o: Dog</span>) =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-类型"><a href="#Promise-类型" class="headerlink" title="Promise 类型"></a>Promise 类型</h3><p>在做异步操作时我们经常使用 <strong>async</strong> 函数，函数调用时会 <strong>return</strong> 一个 <strong>Promise</strong> 对象，可以使用 <strong>then</strong> 方法添加回调函数。<strong>Promise<T></strong> 是一个泛型类型，<strong>T</strong> 泛型变量用于确定 <strong>then</strong> 方法时接收的第一个回调函数的参数类型。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type IResponse&lt;T&gt; = &#123;</span><br><span class="line">  <span class="attr">message</span>: string</span><br><span class="line">  <span class="attr">result</span>: T</span><br><span class="line">  <span class="attr">success</span>: boolean</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getResponse</span>(<span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">IResponse</span>&lt;<span class="title">number</span>[]&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;获取成功&#x27;</span>,</span><br><span class="line">    <span class="attr">result</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="attr">success</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getResponse().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>首先声明 <strong>IResponse</strong> 的泛型接口用于定义 <strong>response</strong> 的类型，通过 <strong>T</strong> 泛型变量来确定 <strong>result</strong> 的类型。然后声明了一个 异步函数 <strong>getResponse</strong> 并且将函数返回值的类型定义为 <strong>Promise&lt;IResponse&lt;number[]&gt;&gt;</strong> 。最后调用 <strong>getResponse</strong> 方法会返回一个 <strong>promise</strong> 类型，通过 <strong>then</strong> 调用，此时 <strong>then</strong> 方法接收的第一个回调函数的参数 <strong>response</strong> 的类型为，**{ message: string, result: number[], success: boolean}** 。</p><h3 id="泛型参数的组件"><a href="#泛型参数的组件" class="headerlink" title="泛型参数的组件"></a>泛型参数的组件</h3><p>下面这个组件的 name 属性都是指定了传参格式，如果想不指定，而是想通过传入参数的类型去推导实际类型，这就要用到泛型。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TestB = <span class="function">(<span class="params">&#123; name, name2 &#125;: &#123; name: string; name2?: string &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;test-b&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      TestB--&#123;name&#125;</span></span><br><span class="line"><span class="xml">      &#123;name2&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要外部传入参数类型，只需 -&gt;</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">type Props&lt;T&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: T</span><br><span class="line">  name2?: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> TestC: &lt;T&gt;<span class="function">(<span class="params">props: Props&lt;T&gt;</span>) =&gt;</span> React.ReactElement = <span class="function">(<span class="params">&#123; name, name2 &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;test-b&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      TestB--&#123;name&#125;</span></span><br><span class="line"><span class="xml">      &#123;name2&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TestD = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &lt;TestC<span class="tag">&lt;<span class="name">string</span>&gt;</span> name=&quot;123&quot; /&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  )</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="什么时候使用泛型"><a href="#什么时候使用泛型" class="headerlink" title="什么时候使用泛型"></a>什么时候使用泛型</h3><p>当你的函数，接口或者类：</p><ul><li>需要作用到很多类型的时候，举个 🌰</li></ul><p>当我们需要一个 id 函数，函数的参数可以是任何值，返回值就是将参数原样返回，并且其只能接受一个参数，在 js 时代我们会很轻易地甩出一行</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br></pre></td></tr></table></figure><p>由于其可以接受任意值，也就是说我们的函数的入参和返回值都应该可以是任意类型，如果不使用泛型，我们只能重复的进行定义</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type idBoolean = <span class="function">(<span class="params">arg: boolean</span>) =&gt;</span> boolean</span><br><span class="line">type idNumber = <span class="function">(<span class="params">arg: number</span>) =&gt;</span> number</span><br><span class="line">type idString = <span class="function">(<span class="params">arg: string</span>) =&gt;</span> string</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>如果使用泛型，我们只需要</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">const</span> id1: &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T = <span class="function"><span class="params">arg</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要被用到很多地方的时候，比如常用的工具泛型 <strong>Partial</strong>。</li></ul><p>功能是将类型的属性<strong>变成可选，</strong> 注意这是浅 <strong>Partial</strong>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Partial&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]?: T[P] &#125;</span><br></pre></td></tr></table></figure><p>如果需要深 Partial 我们可以通过泛型递归来实现</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type DeepPartial&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">Function</span></span><br><span class="line">  ? T</span><br><span class="line">  : T <span class="keyword">extends</span> object</span><br><span class="line">  ? &#123; [P <span class="keyword">in</span> keyof T]?: DeepPartial&lt;T[P]&gt; &#125;</span><br><span class="line">  : T</span><br><span class="line">type PartialedWindow = DeepPartial&lt;Window&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React-TypeScript-实践&quot;&gt;&lt;a href=&quot;#React-TypeScript-实践&quot; class=&quot;headerlink&quot; title=&quot;React+TypeScript 实践&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://mp.weixin.qq</summary>
      
    
    
    
    <category term="React" scheme="https://lesliewaong.top/categories/React/"/>
    
    
    <category term="React" scheme="https://lesliewaong.top/tags/React/"/>
    
    <category term="TS" scheme="https://lesliewaong.top/tags/TS/"/>
    
  </entry>
  
  <entry>
    <title>Webpack基础</title>
    <link href="https://lesliewaong.top/posts/3859b0d1.html"/>
    <id>https://lesliewaong.top/posts/3859b0d1.html</id>
    <published>2022-06-15T11:12:22.000Z</published>
    <updated>2022-06-22T15:19:54.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="为什么需要打包工具？"><a href="#为什么需要打包工具？" class="headerlink" title="为什么需要打包工具？"></a>为什么需要打包工具？</h2><p>开发时，我们会使用框架（React、Vue），ES6 模块化语法，Less/Sass 等 css 预处理器等语法进行开发。</p><p>这样的代码要想在浏览器运行必须经过编译成浏览器能识别的 JS、Css 等语法，才能运行。</p><p>所以我们需要打包工具帮我们做完这些事。</p><p>除此之外，打包工具还能压缩代码、做兼容性处理、提升代码性能等。</p><h2 id="有哪些打包工具？"><a href="#有哪些打包工具？" class="headerlink" title="有哪些打包工具？"></a>有哪些打包工具？</h2><ul><li>Grunt</li><li>Gulp</li><li>Parcel</li><li>Webpack</li><li>Rollup</li><li>Vite</li><li>…</li></ul><p>目前市面上最流量的是 Webpack，所以我们主要以 Webpack 来介绍使用打包工具</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p><strong><code>Webpack</code> 是一个静态资源打包工具。</strong></p><p>它会以一个或多个文件作为打包的入口，将我们整个项目所有文件编译组合成一个或多个文件输出出去。</p><p>输出的文件就是编译好的文件，就可以在浏览器段运行了。</p><p>我们将 <code>Webpack</code> 输出的文件叫做 <code>bundle</code>。</p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>Webpack 本身功能是有限的:</p><ul><li>开发模式：仅能编译 JS 中的 <code>ES Module</code> 语法</li><li>生产模式：能编译 JS 中的 <code>ES Module</code> 语法，还能压缩 JS 代码</li></ul><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="1-资源目录"><a href="#1-资源目录" class="headerlink" title="1. 资源目录"></a>1. 资源目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webpack_code <span class="comment"># 项目根目录（所有指令必须在这个目录运行）</span></span><br><span class="line">    └── src <span class="comment"># 项目源码目录</span></span><br><span class="line">        ├── js <span class="comment"># js文件目录</span></span><br><span class="line">        │   ├── count.js</span><br><span class="line">        │   └── sum.js</span><br><span class="line">        └── main.js <span class="comment"># 项目主文件</span></span><br></pre></td></tr></table></figure><h3 id="2-创建文件"><a href="#2-创建文件" class="headerlink" title="2. 创建文件"></a>2. 创建文件</h3><ul><li>count.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sum.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">p, c</span>) =&gt;</span> p + c, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>main.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> count <span class="keyword">from</span> <span class="string">&quot;./js/count&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">&quot;./js/sum&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><h3 id="3-下载依赖"><a href="#3-下载依赖" class="headerlink" title="3. 下载依赖"></a>3. 下载依赖</h3><p>打开终端，来到项目根目录。运行以下指令：</p><ul><li>初始化<code>package.json</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>此时会生成一个基础的 <code>package.json</code> 文件。</p><p><strong>需要注意的是 <code>package.json</code> 中 <code>name</code> 字段不能叫做 <code>webpack</code>, 否则下一步会报错</strong></p><ul><li>下载依赖</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli -D</span><br></pre></td></tr></table></figure><h3 id="4-启用-Webpack"><a href="#4-启用-Webpack" class="headerlink" title="4. 启用 Webpack"></a>4. 启用 Webpack</h3><ul><li>开发模式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack ./src/main.js --mode=development</span><br></pre></td></tr></table></figure><ul><li>生产模式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack ./src/main.js --mode=production</span><br></pre></td></tr></table></figure><p><code>npx webpack</code>: 是用来运行本地安装 <code>Webpack</code> 包的。</p><p><code>./src/main.js</code>: 指定 <code>Webpack</code> 从 <code>main.js</code> 文件开始打包，不但会打包 <code>main.js</code>，还会将其依赖也一起打包进来。</p><p><code>--mode=xxx</code>：指定模式（环境）。</p><h3 id="5-观察输出文件"><a href="#5-观察输出文件" class="headerlink" title="5. 观察输出文件"></a>5. 观察输出文件</h3><p>默认 <code>Webpack</code> 会将文件打包输出到 <code>dist</code> 目录下，我们查看 <code>dist</code> 目录下文件情况就好了</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Webpack</code> 本身功能比较少，只能处理 <code>js</code> 资源，一旦遇到 <code>css</code> 等其他资源就会报错。</p><p>所以我们学习 <code>Webpack</code>，就是主要学习如何处理其他资源。</p><h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><p>在开始使用 <code>Webpack</code> 之前，我们需要对 <code>Webpack</code> 的配置有一定的认识。</p><h2 id="5-大核心概念"><a href="#5-大核心概念" class="headerlink" title="5 大核心概念"></a>5 大核心概念</h2><ul><li><p><code>entry</code>（入口）</p><p>指示 Webpack 从哪个文件开始打包</p></li><li><p><code>output</code>（输出）</p><p>指示 Webpack 打包完的文件输出到哪里去，如何命名等</p></li><li><p><code>loader</code>（加载器）</p><p>webpack 本身只能处理 js、json 等资源，其他资源需要借助 loader，Webpack 才能解析</p></li><li><p><code>plugins</code>（插件）</p><p>扩展 Webpack 的功能</p></li><li><p><code>mode</code>（模式）</p><p>主要由两种模式：</p><ul><li><p>开发模式：development</p></li><li><p>生产模式：production</p></li></ul></li></ul><h2 id="准备-Webpack-配置文件"><a href="#准备-Webpack-配置文件" class="headerlink" title="准备 Webpack 配置文件"></a>准备 Webpack 配置文件</h2><p>在项目根目录下新建文件：<code>webpack.config.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  <span class="attr">output</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 加载器</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 插件</span></span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Webpack 是基于 Node.js 运行的，所以采用 <code>Common.js</code> 模块化规范</p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><ul><li>配置文件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node.js的核心模块，专门用来处理文件路径</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口</span></span><br><span class="line">  <span class="comment">// 相对路径和绝对路径都行</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// path: 文件输出目录，必须是绝对路径</span></span><br><span class="line">    <span class="comment">// path.resolve()方法返回一个绝对路径</span></span><br><span class="line">    <span class="comment">// __dirname 当前文件的文件夹绝对路径</span></span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="comment">// filename: 输出文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 加载器</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 插件</span></span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>运行指令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>此时功能和之前一样，也不能处理样式资源。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>Webpack 将来都通过 <code>webpack.config.js</code> 文件进行配置，来增强 Webpack 的功能</p><p>我们后面会以两个模式来分别搭建 Webpack 的配置，先进行开发模式，再完成生产模式</p><h1 id="开发模式介绍"><a href="#开发模式介绍" class="headerlink" title="开发模式介绍"></a>开发模式介绍</h1><p>开发模式顾名思义就是我们开发代码时使用的模式。</p><p>这个模式下我们主要做两件事：</p><ul><li><p><strong>编译代码，使浏览器能识别运行。</strong></p><p>开发时我们有样式资源、字体图标、图片资源、html 资源等，webpack 默认都不能处理这些资源，所以我们要加载配置来编译这些资源。</p></li><li><p><strong>代码质量检查，树立代码规范。</strong></p><p>提前检查代码的一些隐患，让代码运行时能更加健壮。</p><p>提前检查代码规范和格式，统一团队编码风格，让代码更优雅美观。</p></li></ul><h1 id="处理样式资源"><a href="#处理样式资源" class="headerlink" title="处理样式资源"></a>处理样式资源</h1><p>本章节我们学习使用 Webpack 如何处理 Css、Less、Sass、Scss、Styl 样式资源</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Webpack 本身是不能识别样式资源的，所以我们需要借助 Loader 来帮助 Webpack 解析样式资源</p><p>我们找 Loader 都应该去官方文档中找到对应的 Loader，然后使用</p><p>官方文档找不到的话，可以从社区 Github 中搜索查询</p><p><a href="https://webpack.docschina.org/loaders/">Webpack 官方 Loader 文档</a></p><h2 id="处理-Css-资源"><a href="#处理-Css-资源" class="headerlink" title="处理 Css 资源"></a>处理 Css 资源</h2><h3 id="1-下载包"><a href="#1-下载包" class="headerlink" title="1. 下载包"></a>1. 下载包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i css-loader style-loader -D</span><br></pre></td></tr></table></figure><p>注意：需要下载两个 loader</p><h3 id="2-功能介绍"><a href="#2-功能介绍" class="headerlink" title="2. 功能介绍"></a>2. 功能介绍</h3><ul><li><code>css-loader</code>：负责将 Css 文件编译成 Webpack 能识别的模块</li><li><code>style-loader</code>：会动态创建一个 Style 标签，里面放置 Webpack 中 Css 模块内容</li></ul><p>此时样式就会以 Style 标签的形式在页面上生效</p><h3 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-添加-Css-资源"><a href="#4-添加-Css-资源" class="headerlink" title="4. 添加 Css 资源"></a>4. 添加 Css 资源</h3><ul><li>src/css/index.css</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>src/main.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> count <span class="keyword">from</span> <span class="string">&quot;./js/count&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">&quot;./js/sum&quot;</span>;</span><br><span class="line"><span class="comment">// 引入 Css 资源，Webpack才会对其打包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./css/index.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><ul><li>public/index.html</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack5<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Webpack5<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 准备一个使用样式的 DOM 容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入打包后的js文件，才能看到效果 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../dist/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-运行指令"><a href="#5-运行指令" class="headerlink" title="5. 运行指令"></a>5. 运行指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>打开 index.html 页面查看效果</p><h2 id="处理-Less-资源"><a href="#处理-Less-资源" class="headerlink" title="处理 Less 资源"></a>处理 Less 资源</h2><h3 id="1-下载包-1"><a href="#1-下载包-1" class="headerlink" title="1. 下载包"></a>1. 下载包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i less-loader -D</span><br></pre></td></tr></table></figure><h3 id="2-功能介绍-1"><a href="#2-功能介绍-1" class="headerlink" title="2. 功能介绍"></a>2. 功能介绍</h3><ul><li><code>less-loader</code>：负责将 Less 文件编译成 Css 文件</li></ul><h3 id="3-配置-1"><a href="#3-配置-1" class="headerlink" title="3. 配置"></a>3. 配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-添加-Less-资源"><a href="#4-添加-Less-资源" class="headerlink" title="4. 添加 Less 资源"></a>4. 添加 Less 资源</h3><ul><li>src/less/index.less</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: deeppink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>src/main.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> count <span class="keyword">from</span> <span class="string">&quot;./js/count&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">&quot;./js/sum&quot;</span>;</span><br><span class="line"><span class="comment">// 引入资源，Webpack才会对其打包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./css/index.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./less/index.less&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><ul><li>public/index.html</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack5<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Webpack5<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../dist/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-运行指令-1"><a href="#5-运行指令-1" class="headerlink" title="5. 运行指令"></a>5. 运行指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>打开 index.html 页面查看效果</p><h2 id="处理-Sass-和-Scss-资源"><a href="#处理-Sass-和-Scss-资源" class="headerlink" title="处理 Sass 和 Scss 资源"></a>处理 Sass 和 Scss 资源</h2><h3 id="1-下载包-2"><a href="#1-下载包-2" class="headerlink" title="1. 下载包"></a>1. 下载包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i sass-loader sass -D</span><br></pre></td></tr></table></figure><p>注意：需要下载两个</p><h3 id="2-功能介绍-2"><a href="#2-功能介绍-2" class="headerlink" title="2. 功能介绍"></a>2. 功能介绍</h3><ul><li><code>sass-loader</code>：负责将 Sass 文件编译成 css 文件</li><li><code>sass</code>：<code>sass-loader</code> 依赖 <code>sass</code> 进行编译</li></ul><h3 id="3-配置-2"><a href="#3-配置-2" class="headerlink" title="3. 配置"></a>3. 配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-添加-Sass-资源"><a href="#4-添加-Sass-资源" class="headerlink" title="4. 添加 Sass 资源"></a>4. 添加 Sass 资源</h3><ul><li>src/sass/index.sass</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 可以省略大括号和分号 */</span></span><br><span class="line"><span class="selector-class">.box3</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span></span><br><span class="line">  height: <span class="number">100px</span></span><br><span class="line">  background-color: hotpink</span><br></pre></td></tr></table></figure><ul><li>src/sass/index.scss</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box4</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightpink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>src/main.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> count <span class="keyword">from</span> <span class="string">&quot;./js/count&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">&quot;./js/sum&quot;</span>;</span><br><span class="line"><span class="comment">// 引入资源，Webpack才会对其打包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./css/index.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./less/index.less&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./sass/index.sass&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./sass/index.scss&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><ul><li>public/index.html</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack5<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Webpack5<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../dist/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-运行指令-2"><a href="#5-运行指令-2" class="headerlink" title="5. 运行指令"></a>5. 运行指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>打开 index.html 页面查看效果</p><h2 id="处理-Styl-资源"><a href="#处理-Styl-资源" class="headerlink" title="处理 Styl 资源"></a>处理 Styl 资源</h2><h3 id="1-下载包-3"><a href="#1-下载包-3" class="headerlink" title="1. 下载包"></a>1. 下载包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i stylus-loader stylus -D</span><br></pre></td></tr></table></figure><h3 id="2-功能介绍-3"><a href="#2-功能介绍-3" class="headerlink" title="2. 功能介绍"></a>2. 功能介绍</h3><ul><li><code>stylus-loader</code>：负责将 Styl 文件编译成 Css 文件</li></ul><h3 id="3-配置-3"><a href="#3-配置-3" class="headerlink" title="3. 配置"></a>3. 配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-添加-Styl-资源"><a href="#4-添加-Styl-资源" class="headerlink" title="4. 添加 Styl 资源"></a>4. 添加 Styl 资源</h3><ul><li>src/styl/index.styl</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 可以省略大括号、分号、冒号 */</span></span><br><span class="line"><span class="selector-class">.box</span> </span><br><span class="line">  <span class="attribute">width</span> <span class="number">100px</span> </span><br><span class="line">  <span class="attribute">height</span> <span class="number">100px</span> </span><br><span class="line">  <span class="attribute">background-color</span> pink</span><br></pre></td></tr></table></figure><ul><li>src/main.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&quot;./math&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> count <span class="keyword">from</span> <span class="string">&quot;./js/count&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">&quot;./js/sum&quot;</span>;</span><br><span class="line"><span class="comment">// 引入资源，Webpack才会对其打包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./css/index.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./less/index.less&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./sass/index.sass&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./sass/index.scss&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styl/index.styl&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><ul><li>public/index.html</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack5<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Webpack5<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 准备一个使用样式的 DOM 容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../dist/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-运行指令-3"><a href="#5-运行指令-3" class="headerlink" title="5. 运行指令"></a>5. 运行指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>打开 index.html 页面查看效果</p><h1 id="处理图片资源"><a href="#处理图片资源" class="headerlink" title="处理图片资源"></a>处理图片资源</h1><p>过去在 Webpack4 时，我们处理图片资源通过 <code>file-loader</code> 和 <code>url-loader</code> 进行处理</p><p>现在 Webpack5 已经将两个 Loader 功能内置到 Webpack 里了，我们只需要简单配置即可处理图片资源</p><h2 id="1-配置"><a href="#1-配置" class="headerlink" title="1. 配置"></a>1. 配置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-添加图片资源"><a href="#2-添加图片资源" class="headerlink" title="2. 添加图片资源"></a>2. 添加图片资源</h2><ul><li>src/images/1.jpeg</li><li>src/images/2.png</li><li>src/images/3.gif</li></ul><h2 id="3-使用图片资源"><a href="#3-使用图片资源" class="headerlink" title="3. 使用图片资源"></a>3. 使用图片资源</h2><ul><li>src/less/index.less</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;../images/1.jpeg&quot;</span>);</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>src/sass/index.sass</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box3</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span></span><br><span class="line">  height: <span class="number">100px</span></span><br><span class="line">  background-image: <span class="built_in">url</span>(<span class="string">&quot;../images/2.png&quot;</span>)</span><br><span class="line">  background-size: cover</span><br></pre></td></tr></table></figure><ul><li>src/styl/index.styl</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box5</span></span><br><span class="line">  <span class="attribute">width</span> <span class="number">100px</span></span><br><span class="line">  <span class="attribute">height</span> <span class="number">100px</span></span><br><span class="line">  <span class="attribute">background-image</span> url(&quot;../images/<span class="number">3</span><span class="selector-class">.gif</span>&quot;)</span><br><span class="line">  <span class="attribute">background-size</span> cover</span><br></pre></td></tr></table></figure><h2 id="4-运行指令"><a href="#4-运行指令" class="headerlink" title="4. 运行指令"></a>4. 运行指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>打开 index.html 页面查看效果</p><h2 id="5-输出资源情况"><a href="#5-输出资源情况" class="headerlink" title="5. 输出资源情况"></a>5. 输出资源情况</h2><p>此时如果查看 dist 目录的话，会发现多了三张图片资源</p><p>因为 Webpack 会将所有打包好的资源输出到 dist 目录下</p><ul><li>为什么样式资源没有呢？</li></ul><p>因为经过 <code>style-loader</code> 的处理，样式资源打包到 main.js 里面去了，所以没有额外输出出来</p><h2 id="6-对图片资源进行优化"><a href="#6-对图片资源进行优化" class="headerlink" title="6. 对图片资源进行优化"></a>6. 对图片资源进行优化</h2><p><strong>将小于某个大小的图片转化成 data URI 形式（Base64 格式）</strong></p><ul><li>优点：<strong>减少请求数量</strong></li><li>缺点：<strong>体积变得更大</strong></li></ul><p>此时输出的图片文件就只有两张，有一张图片以 data URI 形式内置到 js 中了</p><p>（注意：需要将上次打包生成的文件清空，再重新打包才有效果）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span> <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="修改输出资源的名称和路径"><a href="#修改输出资源的名称和路径" class="headerlink" title="修改输出资源的名称和路径"></a>修改输出资源的名称和路径</h1><h2 id="1-配置-1"><a href="#1-配置-1" class="headerlink" title="1. 配置"></a>1. 配置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">          <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">          <span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line">          <span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line">          <span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-修改-index-html"><a href="#2-修改-index-html" class="headerlink" title="2. 修改 index.html"></a>2. 修改 index.html</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack5<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Webpack5<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 修改 js 资源路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../dist/static/js/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-运行指令"><a href="#3-运行指令" class="headerlink" title="3. 运行指令"></a>3. 运行指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><ul><li>此时输出文件目录：</li></ul><p>（注意：需要将上次打包生成的文件清空，再重新打包才有效果）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── dist</span><br><span class="line">    └── static</span><br><span class="line">         ├── imgs</span><br><span class="line">         │    └── 7003350e.png</span><br><span class="line">         └── js</span><br><span class="line">              └── main.js</span><br></pre></td></tr></table></figure><h1 id="自动清空上次打包资源"><a href="#自动清空上次打包资源" class="headerlink" title="自动清空上次打包资源"></a>自动清空上次打包资源</h1><h2 id="1-配置-2"><a href="#1-配置-2" class="headerlink" title="1. 配置"></a>1. 配置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>,</span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>, <span class="comment">// 自动将上次打包目录资源清空</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">40</span> * <span class="number">1024</span>, <span class="comment">// 小于40kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">          <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">          <span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line">          <span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line">          <span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-运行指令"><a href="#2-运行指令" class="headerlink" title="2. 运行指令"></a>2. 运行指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>观察 dist 目录资源情况</p><h1 id="处理字体图标资源"><a href="#处理字体图标资源" class="headerlink" title="处理字体图标资源"></a>处理字体图标资源</h1><h2 id="1-下载字体图标文件"><a href="#1-下载字体图标文件" class="headerlink" title="1. 下载字体图标文件"></a>1. 下载字体图标文件</h2><ol><li><p>打开<a href="https://www.iconfont.cn/">阿里巴巴矢量图标库</a></p></li><li><p>选择想要的图标添加到购物车，统一下载到本地</p></li></ol><h2 id="2-添加字体图标资源"><a href="#2-添加字体图标资源" class="headerlink" title="2. 添加字体图标资源"></a>2. 添加字体图标资源</h2><ul><li><p>src/fonts/iconfont.ttf</p></li><li><p>src/fonts/iconfont.woff</p></li><li><p>src/fonts/iconfont.woff2</p></li><li><p>src/css/iconfont.css</p><ul><li>注意字体文件路径需要修改</li></ul></li><li><p>src/main.js</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&quot;./math&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> count <span class="keyword">from</span> <span class="string">&quot;./js/count&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">&quot;./js/sum&quot;</span>;</span><br><span class="line"><span class="comment">// 引入资源，Webpack才会对其打包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./css/iconfont.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./css/index.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./less/index.less&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./sass/index.sass&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./sass/index.scss&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styl/index.styl&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><ul><li>public/index.html</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack5<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Webpack5<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用字体图标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-arrow-down&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-ashbin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-browse&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../dist/static/js/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-配置-4"><a href="#3-配置-4" class="headerlink" title="3. 配置"></a>3. 配置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>, <span class="comment">// 自动将上次打包目录资源清空</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">          <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">          <span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line">          <span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line">          <span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>type: &quot;asset/resource&quot;</code>和<code>type: &quot;asset&quot;</code>的区别：</p><ol><li><code>type: &quot;asset/resource&quot;</code> 相当于<code>file-loader</code>, 将文件转化成 Webpack 能识别的资源，其他不做处理</li><li><code>type: &quot;asset&quot;</code> 相当于<code>url-loader</code>, <strong>将文件转化成 Webpack 能识别的资源，同时小于某个大小的资源会处理成 data URI 形式</strong></li></ol><h2 id="4-运行指令-1"><a href="#4-运行指令-1" class="headerlink" title="4. 运行指令"></a>4. 运行指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>打开 index.html 页面查看效果</p><h1 id="处理其他资源"><a href="#处理其他资源" class="headerlink" title="处理其他资源"></a>处理其他资源</h1><p>开发中可能还存在一些其他资源，如音视频等，我们也一起处理了</p><h2 id="1-配置-3"><a href="#1-配置-3" class="headerlink" title="1. 配置"></a>1. 配置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>, <span class="comment">// 自动将上次打包目录资源清空</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">          <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">          <span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line">          <span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line">          <span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?|map4|map3|avi)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就是在处理字体图标资源基础上增加其他文件类型，统一处理即可</p><h2 id="2-运行指令-1"><a href="#2-运行指令-1" class="headerlink" title="2. 运行指令"></a>2. 运行指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>打开 index.html 页面查看效果</p><h1 id="处理-js-资源"><a href="#处理-js-资源" class="headerlink" title="处理 js 资源"></a>处理 js 资源</h1><p>有人可能会问，js 资源 Webpack 不能已经处理了吗，为什么我们还要处理呢？</p><p>原因是 Webpack 对 js 处理是有限的，只能编译 js 中 ES 模块化语法，不能编译其他语法，导致 js 不能在 IE 等浏览器运行，所以我们希望做一些兼容性处理。</p><p>其次开发中，团队对代码格式是有严格要求的，我们不能由肉眼去检测代码格式，需要使用专业的工具来检测。</p><ul><li>针对 <strong>js 兼容性处理</strong>，我们使用 <code>Babel</code> 来完成</li><li>针对<strong>代码格式</strong>，我们使用 <code>Eslint</code> 来完成</li></ul><p>我们先完成 Eslint，检测代码格式无误后，在由 Babel 做代码兼容性处理。</p><h2 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h2><p>可组装的<code>JavaScript</code> 和<code>JSX</code> 检查工具。</p><p>这句话意思就是：它是用来检测 js 和 jsx 语法的工具，可以配置各项功能。</p><p>我们使用 Eslint，关键是写 Eslint 配置文件，里面写上各种 rules 规则，将来运行 Eslint 时就会以写的规则对代码进行检查。</p><h3 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h3><p>配置文件由很多种写法：</p><ul><li><code>.eslintrc.*</code>：新建文件，位于项目根目录<ul><li><code>.eslintrc</code></li><li><code>.eslintrc.js</code></li><li><code>.eslintrc.json</code></li><li>区别在于配置格式不一样</li></ul></li><li><code>package.json</code> 中 <code>eslintConfig</code>：不需要创建文件，在原有文件基础上写</li></ul><p>ESLint 会查找和自动读取它们，所以以上配置文件只需要存在一个即可</p><h3 id="2-具体配置"><a href="#2-具体配置" class="headerlink" title="2. 具体配置"></a>2. 具体配置</h3><p>我们以 <code>.eslintrc.js</code> 配置文件为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 解析选项</span></span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 具体检查规则</span></span><br><span class="line">  <span class="attr">rules</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 继承其他规则</span></span><br><span class="line">  <span class="attr">extends</span>: [],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 其他规则详见：https://eslint.bootcss.com/docs/user-guide/configuring</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>parserOptions 解析选项</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parserOptions: &#123;</span><br><span class="line">  <span class="attr">ecmaVersion</span>: <span class="number">6</span>, <span class="comment">// ES 语法版本</span></span><br><span class="line">  <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span>, <span class="comment">// ES 模块化</span></span><br><span class="line">  <span class="attr">ecmaFeatures</span>: &#123; <span class="comment">// ES 其他特性</span></span><br><span class="line">    <span class="attr">jsx</span>: <span class="literal">true</span> <span class="comment">// 如果是 React 项目，就需要开启 jsx 语法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>rules 具体规则</li></ol><ul><li><code>&quot;off&quot;</code> 或 <code>0</code> - 关闭规则</li><li><code>&quot;warn&quot;</code> 或 <code>1</code> - 开启规则，使用警告级别的错误：<code>warn</code> (不会导致程序退出)</li><li><code>&quot;error&quot;</code> 或 <code>2</code> - 开启规则，使用错误级别的错误：<code>error</code> (当被触发的时候，程序会退出)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">  <span class="attr">semi</span>: <span class="string">&quot;error&quot;</span>, <span class="comment">// 禁止使用分号</span></span><br><span class="line">  <span class="string">&#x27;array-callback-return&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>, <span class="comment">// 强制数组方法的回调函数中有 return 语句，否则警告</span></span><br><span class="line">  <span class="string">&#x27;default-case&#x27;</span>: [</span><br><span class="line">    <span class="string">&#x27;warn&#x27;</span>, <span class="comment">// 要求 switch 语句中有 default 分支，否则警告</span></span><br><span class="line">    &#123; <span class="attr">commentPattern</span>: <span class="string">&#x27;^no default$&#x27;</span> &#125; <span class="comment">// 允许在最后注释 no default, 就不会有警告了</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">eqeqeq</span>: [</span><br><span class="line">    <span class="string">&#x27;warn&#x27;</span>, <span class="comment">// 强制使用 === 和 !==，否则警告</span></span><br><span class="line">    <span class="string">&#x27;smart&#x27;</span> <span class="comment">// https://eslint.bootcss.com/docs/rules/eqeqeq#smart 除了少数情况下不会有警告</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多规则详见：<a href="https://eslint.bootcss.com/docs/rules/">规则文档</a></p><ol start="3"><li>extends 继承</li></ol><p>开发中一点点写 rules 规则太费劲了，所以有更好的办法，继承现有的规则。</p><p>现有以下较为有名的规则：</p><ul><li><a href="https://eslint.bootcss.com/docs/rules/">Eslint 官方的规则</a>：<code>eslint:recommended</code></li><li><a href="https://github.com/vuejs/vue-cli/tree/dev/packages/@vue/cli-plugin-eslint">Vue Cli 官方的规则</a>：<code>plugin:vue/essential</code></li><li><a href="https://github.com/facebook/create-react-app/tree/main/packages/eslint-config-react-app">React Cli 官方的规则</a>：<code>react-app</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如在React项目中，我们可以这样写配置</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&quot;react-app&quot;</span>],</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="comment">// 我们的规则会覆盖掉react-app的规则</span></span><br><span class="line">    <span class="comment">// 所以想要修改规则直接改就是了</span></span><br><span class="line">    <span class="attr">eqeqeq</span>: [<span class="string">&quot;warn&quot;</span>, <span class="string">&quot;smart&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-在-Webpack-中使用"><a href="#3-在-Webpack-中使用" class="headerlink" title="3. 在 Webpack 中使用"></a>3. 在 Webpack 中使用</h3><ol><li>下载包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i eslint-webpack-plugin eslint -D</span><br></pre></td></tr></table></figure><ol start="2"><li>定义 Eslint 配置文件</li></ol><ul><li>.eslintrc.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 继承 Eslint 规则</span></span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&quot;eslint:recommended&quot;</span>],</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>, <span class="comment">// 启用node中全局变量</span></span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>, <span class="comment">// 启用浏览器中全局变量</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">ecmaVersion</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&quot;no-var&quot;</span>: <span class="number">2</span>, <span class="comment">// 不能使用 var 定义变量</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>修改 js 文件代码</li></ol><ul><li>main.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> count <span class="keyword">from</span> <span class="string">&quot;./js/count&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">&quot;./js/sum&quot;</span>;</span><br><span class="line"><span class="comment">// 引入资源，Webpack才会对其打包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./css/iconfont.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./css/index.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./less/index.less&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./sass/index.sass&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./sass/index.scss&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styl/index.styl&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = count(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result1);</span><br><span class="line"><span class="keyword">var</span> result2 = sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result2);</span><br></pre></td></tr></table></figure><ol><li>配置</li></ol><ul><li>webpack.config.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ESLintWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;eslint-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>, <span class="comment">// 自动将上次打包目录资源清空</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">          <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">          <span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line">          <span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line">          <span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> ESLintWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.resolve(__dirname, <span class="string">&quot;src&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="5"><li>运行指令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>在控制台查看 Eslint 检查效果</p><h3 id="4-VSCode-Eslint-插件"><a href="#4-VSCode-Eslint-插件" class="headerlink" title="4. VSCode Eslint 插件"></a>4. VSCode Eslint 插件</h3><p>打开 VSCode，下载 Eslint 插件，即可不用编译就能看到错误，可以提前解决</p><p>但是此时就会对项目所有文件默认进行 Eslint 检查了，我们 dist 目录下的打包后文件就会报错。但是我们只需要检查 src 下面的文件，不需要检查 dist 下面的文件。</p><p>所以可以使用 Eslint 忽略文件解决。在项目根目录新建下面文件:</p><ul><li><code>.eslintignore</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 忽略dist目录下所有文件</span><br><span class="line">dist</span><br></pre></td></tr></table></figure><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>JavaScript 编译器。</p><p>主要用于<strong>将 ES6 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中</strong></p><h3 id="1-配置文件-1"><a href="#1-配置文件-1" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h3><p>配置文件由很多种写法：</p><ul><li><code>babel.config.*</code>：新建文件，位于项目根目录<ul><li><code>babel.config.js</code></li><li><code>babel.config.json</code></li></ul></li><li><code>.babelrc.*</code>：新建文件，位于项目根目录<ul><li><code>.babelrc</code></li><li><code>.babelrc.js</code></li><li><code>.babelrc.json</code></li></ul></li><li><code>package.json</code> 中 <code>babel</code>：不需要创建文件，在原有文件基础上写</li></ul><p>Babel 会查找和自动读取它们，所以以上配置文件只需要存在一个即可</p><h3 id="2-具体配置-1"><a href="#2-具体配置-1" class="headerlink" title="2. 具体配置"></a>2. 具体配置</h3><p>我们以 <code>babel.config.js</code> 配置文件为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 预设</span></span><br><span class="line">  <span class="attr">presets</span>: [],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>presets 预设</li></ol><p>简单理解：就是一组 Babel 插件, 扩展 Babel 功能</p><ul><li><code>@babel/preset-env</code>: 一个智能预设，允许您使用最新的 JavaScript。</li><li><code>@babel/preset-react</code>：一个用来编译 React jsx 语法的预设</li><li><code>@babel/preset-typescript</code>：一个用来编译 TypeScript 语法的预设</li></ul><h3 id="3-在-Webpack-中使用-1"><a href="#3-在-Webpack-中使用-1" class="headerlink" title="3. 在 Webpack 中使用"></a>3. 在 Webpack 中使用</h3><ol><li>下载包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-loader @babel/core @babel/preset-env -D</span><br></pre></td></tr></table></figure><ol start="2"><li>定义 Babel 配置文件</li></ol><ul><li>babel.config.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>修改 js 文件代码</li></ol><ul><li>main.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> count <span class="keyword">from</span> <span class="string">&quot;./js/count&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">&quot;./js/sum&quot;</span>;</span><br><span class="line"><span class="comment">// 引入资源，Webpack才会对其打包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./css/iconfont.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./css/index.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./less/index.less&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./sass/index.sass&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./sass/index.scss&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styl/index.styl&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result1 = count(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result1);</span><br><span class="line"><span class="keyword">const</span> result2 = sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result2);</span><br></pre></td></tr></table></figure><ol start="4"><li>配置</li></ol><ul><li>webpack.config.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ESLintWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;eslint-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>, <span class="comment">// 自动将上次打包目录资源清空</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">          <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">          <span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line">          <span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line">          <span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>, <span class="comment">// 排除node_modules代码不编译</span></span><br><span class="line">        loader: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> ESLintWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.resolve(__dirname, <span class="string">&quot;src&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="5"><li>运行指令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>打开打包后的 <code>dist/static/js/main.js</code> 文件查看，会发现箭头函数等 ES6 语法已经转换了</p><h1 id="处理-Html-资源"><a href="#处理-Html-资源" class="headerlink" title="处理 Html 资源"></a>处理 Html 资源</h1><h2 id="1-下载包-4"><a href="#1-下载包-4" class="headerlink" title="1. 下载包"></a>1. 下载包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i html-webpack-plugin -D</span><br></pre></td></tr></table></figure><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><ul><li>webpack.config.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ESLintWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;eslint-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>, <span class="comment">// 自动将上次打包目录资源清空</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">          <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">          <span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line">          <span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line">          <span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>, <span class="comment">// 排除node_modules代码不编译</span></span><br><span class="line">        loader: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> ESLintWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.resolve(__dirname, <span class="string">&quot;src&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 以 public/index.html 为模板创建文件</span></span><br><span class="line">      <span class="comment">// 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源</span></span><br><span class="line">      <span class="attr">template</span>: path.resolve(__dirname, <span class="string">&quot;public/index.html&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-修改-index-html"><a href="#3-修改-index-html" class="headerlink" title="3. 修改 index.html"></a>3. 修改 index.html</h2><p>去掉引入的 js 文件，因为 HtmlWebpackPlugin 会自动引入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack5<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Webpack5<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-arrow-down&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-ashbin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-browse&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-运行指令-2"><a href="#4-运行指令-2" class="headerlink" title="4. 运行指令"></a>4. 运行指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>此时 dist 目录就会输出一个 index.html 文件</p><h1 id="开发服务器-amp-自动化"><a href="#开发服务器-amp-自动化" class="headerlink" title="开发服务器&amp;自动化"></a>开发服务器&amp;自动化</h1><p>每次写完代码都需要手动输入指令才能编译代码，太麻烦了，我们希望一切自动化</p><h2 id="1-下载包-5"><a href="#1-下载包-5" class="headerlink" title="1. 下载包"></a>1. 下载包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-dev-server -D</span><br></pre></td></tr></table></figure><h2 id="2-配置-1"><a href="#2-配置-1" class="headerlink" title="2. 配置"></a>2. 配置</h2><ul><li>webpack.config.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ESLintWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;eslint-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>, <span class="comment">// 自动将上次打包目录资源清空</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">          <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">          <span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line">          <span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line">          <span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>, <span class="comment">// 排除node_modules代码不编译</span></span><br><span class="line">        loader: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> ESLintWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.resolve(__dirname, <span class="string">&quot;src&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 以 public/index.html 为模板创建文件</span></span><br><span class="line">      <span class="comment">// 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源</span></span><br><span class="line">      <span class="attr">template</span>: path.resolve(__dirname, <span class="string">&quot;public/index.html&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 开发服务器</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>, <span class="comment">// 启动服务器域名</span></span><br><span class="line">    <span class="attr">port</span>: <span class="string">&quot;3000&quot;</span>, <span class="comment">// 启动服务器端口号</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 是否自动打开浏览器</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-运行指令-1"><a href="#3-运行指令-1" class="headerlink" title="3. 运行指令"></a>3. 运行指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack serve</span><br></pre></td></tr></table></figure><p><strong>注意运行指令发生了变化</strong></p><p>并且当你使用开发服务器时，所有代码都会在内存中编译打包，并不会输出到 dist 目录下。</p><p>开发时我们只关心代码能运行，有效果即可，至于代码被编译成什么样子，我们并不需要知道。</p><h1 id="生产模式介绍"><a href="#生产模式介绍" class="headerlink" title="生产模式介绍"></a>生产模式介绍</h1><p>生产模式是开发完成代码后，我们需要得到代码将来部署上线。</p><p>这个模式下我们主要对代码进行优化，让其运行性能更好。</p><p>优化主要从两个角度出发:</p><ol><li><strong>优化代码运行性能</strong></li><li><strong>优化代码打包速度</strong></li></ol><h2 id="生产模式准备"><a href="#生产模式准备" class="headerlink" title="生产模式准备"></a>生产模式准备</h2><p>我们分别准备两个配置文件来放不同的配置</p><h3 id="1-文件目录"><a href="#1-文件目录" class="headerlink" title="1. 文件目录"></a>1. 文件目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── webpack-test (项目根目录)</span><br><span class="line">    ├── config (Webpack配置文件目录)</span><br><span class="line">    │    ├── webpack.dev.js(开发模式配置文件)</span><br><span class="line">    │    └── webpack.prod.js(生产模式配置文件)</span><br><span class="line">    ├── node_modules (下载包存放目录)</span><br><span class="line">    ├── src (项目源码目录，除了html其他都在src里面)</span><br><span class="line">    │    └── 略</span><br><span class="line">    ├── public (项目html文件)</span><br><span class="line">    │    └── index.html</span><br><span class="line">    ├── .eslintrc.js(Eslint配置文件)</span><br><span class="line">    ├── babel.config.js(Babel配置文件)</span><br><span class="line">    └── package.json (包的依赖管理配置文件)</span><br></pre></td></tr></table></figure><h3 id="2-修改-webpack-dev-js"><a href="#2-修改-webpack-dev-js" class="headerlink" title="2. 修改 webpack.dev.js"></a>2. 修改 webpack.dev.js</h3><p>因为文件目录变了，所以所有<strong>绝对路径</strong>需要回退一层目录才能找到对应的文件。相对路径不需要处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ESLintWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;eslint-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="literal">undefined</span>, <span class="comment">// 开发模式没有输出，不需要指定输出目录</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line">    <span class="comment">// clean: true, // 开发模式没有输出，不需要清空输出结果</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">          <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">          <span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line">          <span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line">          <span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>, <span class="comment">// 排除node_modules代码不编译</span></span><br><span class="line">        loader: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> ESLintWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.resolve(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 以 public/index.html 为模板创建文件</span></span><br><span class="line">      <span class="comment">// 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源</span></span><br><span class="line">      <span class="attr">template</span>: path.resolve(__dirname, <span class="string">&quot;../public/index.html&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 其他省略</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>, <span class="comment">// 启动服务器域名</span></span><br><span class="line">    <span class="attr">port</span>: <span class="string">&quot;3000&quot;</span>, <span class="comment">// 启动服务器端口号</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 是否自动打开浏览器</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行开发模式的指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack serve --config ./config/webpack.dev.js</span><br></pre></td></tr></table></figure><h3 id="3-修改-webpack-prod-js"><a href="#3-修改-webpack-prod-js" class="headerlink" title="3. 修改 webpack.prod.js"></a>3. 修改 webpack.prod.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ESLintWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;eslint-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;../dist&quot;</span>), <span class="comment">// 生产模式需要输出</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">          <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">          <span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line">          <span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line">          <span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>, <span class="comment">// 排除node_modules代码不编译</span></span><br><span class="line">        loader: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> ESLintWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.resolve(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 以 public/index.html 为模板创建文件</span></span><br><span class="line">      <span class="comment">// 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源</span></span><br><span class="line">      <span class="attr">template</span>: path.resolve(__dirname, <span class="string">&quot;../public/index.html&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// devServer: &#123;</span></span><br><span class="line">  <span class="comment">//   host: &quot;localhost&quot;, // 启动服务器域名</span></span><br><span class="line">  <span class="comment">//   port: &quot;3000&quot;, // 启动服务器端口号</span></span><br><span class="line">  <span class="comment">//   open: true, // 是否自动打开浏览器</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行生产模式的指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack --config ./config/webpack.prod.js</span><br></pre></td></tr></table></figure><h3 id="4-配置运行指令"><a href="#4-配置运行指令" class="headerlink" title="4. 配置运行指令"></a>4. 配置运行指令</h3><p>为了方便运行不同模式的指令，我们将指令定义在 package.json 中 scripts 里面</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 其他省略</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;npm run dev&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;npx webpack serve --config ./config/webpack.dev.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;npx webpack --config ./config/webpack.prod.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后启动指令：</p><ul><li>开发模式：<code>npm start</code> 或 <code>npm run dev</code></li><li>生产模式：<code>npm run build</code></li></ul><h1 id="Css-处理"><a href="#Css-处理" class="headerlink" title="Css 处理"></a>Css 处理</h1><h2 id="提取-Css-成单独文件"><a href="#提取-Css-成单独文件" class="headerlink" title="提取 Css 成单独文件"></a>提取 Css 成单独文件</h2><p>Css 文件目前被打包到 js 文件中，当 js 文件加载时，会创建一个 style 标签来生成样式</p><p>这样对于网站来说，会出现<strong>闪屏</strong>现象，用户体验不好</p><p>我们应该是<strong>单独的 Css 文件，通过 link 标签加载性能才好</strong></p><h3 id="1-下载包-6"><a href="#1-下载包-6" class="headerlink" title="1. 下载包"></a>1. 下载包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure><h3 id="2-配置-2"><a href="#2-配置-2" class="headerlink" title="2. 配置"></a>2. 配置</h3><ul><li>webpack.prod.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ESLintWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;eslint-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;../dist&quot;</span>), <span class="comment">// 生产模式需要输出</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">          <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">          <span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line">          <span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line">          <span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>, <span class="comment">// 排除node_modules代码不编译</span></span><br><span class="line">        loader: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> ESLintWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.resolve(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 以 public/index.html 为模板创建文件</span></span><br><span class="line">      <span class="comment">// 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源</span></span><br><span class="line">      <span class="attr">template</span>: path.resolve(__dirname, <span class="string">&quot;../public/index.html&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 提取css成单独文件</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// 定义输出文件名和目录</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;static/css/main.css&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// devServer: &#123;</span></span><br><span class="line">  <span class="comment">//   host: &quot;localhost&quot;, // 启动服务器域名</span></span><br><span class="line">  <span class="comment">//   port: &quot;3000&quot;, // 启动服务器端口号</span></span><br><span class="line">  <span class="comment">//   open: true, // 是否自动打开浏览器</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-运行指令-2"><a href="#3-运行指令-2" class="headerlink" title="3. 运行指令"></a>3. 运行指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><h2 id="Css-兼容性处理"><a href="#Css-兼容性处理" class="headerlink" title="Css 兼容性处理"></a>Css 兼容性处理</h2><h3 id="1-下载包-7"><a href="#1-下载包-7" class="headerlink" title="1. 下载包"></a>1. 下载包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i postcss-loader postcss postcss-preset-env -D</span><br></pre></td></tr></table></figure><h3 id="2-配置-3"><a href="#2-配置-3" class="headerlink" title="2. 配置"></a>2. 配置</h3><ul><li>webpack.prod.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ESLintWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;eslint-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;../dist&quot;</span>), <span class="comment">// 生产模式需要输出</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">                <span class="attr">plugins</span>: [</span><br><span class="line">                  <span class="string">&quot;postcss-preset-env&quot;</span>, <span class="comment">// 能解决大多数样式兼容性问题</span></span><br><span class="line">                ],</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">                <span class="attr">plugins</span>: [</span><br><span class="line">                  <span class="string">&quot;postcss-preset-env&quot;</span>, <span class="comment">// 能解决大多数样式兼容性问题</span></span><br><span class="line">                ],</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;less-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">                <span class="attr">plugins</span>: [</span><br><span class="line">                  <span class="string">&quot;postcss-preset-env&quot;</span>, <span class="comment">// 能解决大多数样式兼容性问题</span></span><br><span class="line">                ],</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;sass-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">                <span class="attr">plugins</span>: [</span><br><span class="line">                  <span class="string">&quot;postcss-preset-env&quot;</span>, <span class="comment">// 能解决大多数样式兼容性问题</span></span><br><span class="line">                ],</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;stylus-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">          <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">          <span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line">          <span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line">          <span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>, <span class="comment">// 排除node_modules代码不编译</span></span><br><span class="line">        loader: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> ESLintWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.resolve(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 以 public/index.html 为模板创建文件</span></span><br><span class="line">      <span class="comment">// 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源</span></span><br><span class="line">      <span class="attr">template</span>: path.resolve(__dirname, <span class="string">&quot;../public/index.html&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 提取css成单独文件</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// 定义输出文件名和目录</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;static/css/main.css&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// devServer: &#123;</span></span><br><span class="line">  <span class="comment">//   host: &quot;localhost&quot;, // 启动服务器域名</span></span><br><span class="line">  <span class="comment">//   port: &quot;3000&quot;, // 启动服务器端口号</span></span><br><span class="line">  <span class="comment">//   open: true, // 是否自动打开浏览器</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-控制兼容性"><a href="#3-控制兼容性" class="headerlink" title="3. 控制兼容性"></a>3. 控制兼容性</h3><p>我们可以在 <code>package.json</code> 文件中添加 <code>browserslist</code> 来控制样式的兼容性做到什么程度。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 其他省略</span></span><br><span class="line">  <span class="attr">&quot;browserslist&quot;</span>: [<span class="string">&quot;ie &gt;= 8&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要知道更多的 <code>browserslist</code> 配置，查看<a href="https://github.com/browserslist/browserslist">browserslist 文档</a></p><p>以上为了测试兼容性所以设置兼容浏览器 ie8 以上。</p><p>实际开发中我们一般不考虑旧版本浏览器了，所以我们可以这样设置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 其他省略</span></span><br><span class="line">  <span class="attr">&quot;browserslist&quot;</span>: [<span class="string">&quot;last 2 version&quot;</span>, <span class="string">&quot;&gt; 1%&quot;</span>, <span class="string">&quot;not dead&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-合并配置"><a href="#4-合并配置" class="headerlink" title="4. 合并配置"></a>4. 合并配置</h3><ul><li>webpack.prod.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ESLintWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;eslint-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取处理样式的Loaders</span></span><br><span class="line"><span class="keyword">const</span> getStyleLoaders = <span class="function">(<span class="params">preProcessor</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    MiniCssExtractPlugin.loader,</span><br><span class="line">    <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">          <span class="attr">plugins</span>: [</span><br><span class="line">            <span class="string">&quot;postcss-preset-env&quot;</span>, <span class="comment">// 能解决大多数样式兼容性问题</span></span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    preProcessor,</span><br><span class="line">  ].filter(<span class="built_in">Boolean</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;../dist&quot;</span>), <span class="comment">// 生产模式需要输出</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: getStyleLoaders(),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: getStyleLoaders(<span class="string">&quot;less-loader&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: getStyleLoaders(<span class="string">&quot;sass-loader&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: getStyleLoaders(<span class="string">&quot;stylus-loader&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">          <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">          <span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line">          <span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line">          <span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>, <span class="comment">// 排除node_modules代码不编译</span></span><br><span class="line">        loader: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> ESLintWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.resolve(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 以 public/index.html 为模板创建文件</span></span><br><span class="line">      <span class="comment">// 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源</span></span><br><span class="line">      <span class="attr">template</span>: path.resolve(__dirname, <span class="string">&quot;../public/index.html&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 提取css成单独文件</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// 定义输出文件名和目录</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;static/css/main.css&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// devServer: &#123;</span></span><br><span class="line">  <span class="comment">//   host: &quot;localhost&quot;, // 启动服务器域名</span></span><br><span class="line">  <span class="comment">//   port: &quot;3000&quot;, // 启动服务器端口号</span></span><br><span class="line">  <span class="comment">//   open: true, // 是否自动打开浏览器</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-运行指令-4"><a href="#5-运行指令-4" class="headerlink" title="5. 运行指令"></a>5. 运行指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><h2 id="Css-压缩"><a href="#Css-压缩" class="headerlink" title="Css 压缩"></a>Css 压缩</h2><h3 id="1-下载包-8"><a href="#1-下载包-8" class="headerlink" title="1. 下载包"></a>1. 下载包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i css-minimizer-webpack-plugin -D</span><br></pre></td></tr></table></figure><h3 id="2-配置-4"><a href="#2-配置-4" class="headerlink" title="2. 配置"></a>2. 配置</h3><ul><li>webpack.prod.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ESLintWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;eslint-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> CssMinimizerPlugin = <span class="built_in">require</span>(<span class="string">&quot;css-minimizer-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取处理样式的Loaders</span></span><br><span class="line"><span class="keyword">const</span> getStyleLoaders = <span class="function">(<span class="params">preProcessor</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    MiniCssExtractPlugin.loader,</span><br><span class="line">    <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">          <span class="attr">plugins</span>: [</span><br><span class="line">            <span class="string">&quot;postcss-preset-env&quot;</span>, <span class="comment">// 能解决大多数样式兼容性问题</span></span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    preProcessor,</span><br><span class="line">  ].filter(<span class="built_in">Boolean</span>);<span class="comment">// 过滤无参情况下的undefined</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;../dist&quot;</span>), <span class="comment">// 生产模式需要输出</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        use: getStyleLoaders(),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: getStyleLoaders(<span class="string">&quot;less-loader&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: getStyleLoaders(<span class="string">&quot;sass-loader&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: getStyleLoaders(<span class="string">&quot;stylus-loader&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">          <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">          <span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line">          <span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line">          <span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>, <span class="comment">// 排除node_modules代码不编译</span></span><br><span class="line">        loader: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> ESLintWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.resolve(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 以 public/index.html 为模板创建文件</span></span><br><span class="line">      <span class="comment">// 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源</span></span><br><span class="line">      <span class="attr">template</span>: path.resolve(__dirname, <span class="string">&quot;../public/index.html&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 提取css成单独文件</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// 定义输出文件名和目录</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;static/css/main.css&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// css压缩</span></span><br><span class="line">    <span class="keyword">new</span> CssMinimizerPlugin(),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// devServer: &#123;</span></span><br><span class="line">  <span class="comment">//   host: &quot;localhost&quot;, // 启动服务器域名</span></span><br><span class="line">  <span class="comment">//   port: &quot;3000&quot;, // 启动服务器端口号</span></span><br><span class="line">  <span class="comment">//   open: true, // 是否自动打开浏览器</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-运行指令-3"><a href="#3-运行指令-3" class="headerlink" title="3. 运行指令"></a>3. 运行指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><h1 id="html-压缩"><a href="#html-压缩" class="headerlink" title="html 压缩"></a>html 压缩</h1><p>默认生产模式已经开启了：html 压缩和 js 压缩</p><p>不需要额外进行配置</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章节我们学会了 Webpack 基本使用，掌握了以下功能：</p><ol><li><p>两种开发模式</p><ul><li><p>开发模式：代码能编译自动化运行</p></li><li><p>生产模式：代码编译优化输出</p></li></ul></li></ol><ol start="2"><li><p>Webpack 基本功能</p><ul><li><p>开发模式：可以编译 ES Module 语法</p></li><li><p>生产模式：可以编译 ES Module 语法，压缩 js 代码</p></li></ul></li></ol><ol start="3"><li><p>Webpack 配置文件</p><ul><li><p>5 个核心概念</p><ul><li>entry</li><li>output</li><li>loader</li><li>plugins</li><li>mode</li></ul></li><li><p>devServer 配置</p></li></ul></li></ol><ol start="4"><li><p>Webpack 脚本指令用法</p><ul><li><p><code>webpack</code> 直接打包输出</p></li><li><p><code>webpack serve</code> 启动开发服务器，内存编译打包没有输出</p></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;为什么需要打包工具？&quot;&gt;&lt;a href=&quot;#为什么需要打包工具？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要</summary>
      
    
    
    
    <category term="Webpack" scheme="https://lesliewaong.top/categories/Webpack/"/>
    
    
    <category term="Webpack" scheme="https://lesliewaong.top/tags/Webpack/"/>
    
    <category term="打包" scheme="https://lesliewaong.top/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript基础</title>
    <link href="https://lesliewaong.top/posts/dc8ffbe9.html"/>
    <id>https://lesliewaong.top/posts/dc8ffbe9.html</id>
    <published>2022-06-15T05:12:48.000Z</published>
    <updated>2022-07-17T08:40:25.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-快速入门"><a href="#第一章-快速入门" class="headerlink" title="第一章 快速入门"></a>第一章 快速入门</h1><p><a href="https://typescript.bootcss.com/tutorials/react.html">TypeScript 中文手册</a></p><p><a href="https://jkchao.github.io/typescript-book-chinese/">深入理解 TypeScript</a></p><h2 id="TypeScript简介"><a href="#TypeScript简介" class="headerlink" title="TypeScript简介"></a>TypeScript简介</h2><p>对比于JS，TS是JS的<strong>超集</strong>，简单的说就是在 <code>JavaScript</code> 的基础上加入了<strong>类型系统</strong>，让每个参数都有明确的意义，从而带来了更加<strong>智能</strong>的提示。</p><p>相对于<code>JS</code>而言，<code>TS</code>属于<strong>强类型</strong>语言，所以对于项目而言，会使代码更加规范，从而解决了大型项目代码的复杂性，其次，浏览器是不识别<code>TS</code>的，所以在编译的时候，<code>TS</code>文件会先编译为<code>JS</code>文件。</p><ol><li>TypeScript是JavaScript的<strong>超集</strong>。</li><li>它对JS进行了扩展，向JS中引入了<strong>类型</strong>的概念，并添加了许多新的特性。</li><li>TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。</li><li><strong>TS完全兼容JS</strong>，换言之，任何的JS代码都可以直接当成TS使用。</li><li>相较于JS而言，TS拥有了<strong>静态类型</strong>，更加严格的语法，更强大的功能；TS可以<strong>在代码执行前就完成代码的检查</strong>，减小了运行时异常的出现的几率；TS代码<strong>可以编译为任意版本的JS代码</strong>，可有效解决不同JS运行环境的兼容问题；同样的功能，<strong>TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS</strong>。</li></ol><h2 id="TypeScript-开发环境搭建"><a href="#TypeScript-开发环境搭建" class="headerlink" title="TypeScript 开发环境搭建"></a>TypeScript 开发环境搭建</h2><ol><li><p>下载Node.js</p><ul><li>64位：<a href="https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi">https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi</a></li><li>32位：<a href="https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi">https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi</a></li></ul></li><li><p>安装Node.js</p></li><li><p>使用npm全局安装typescript</p><ul><li>进入命令行</li><li>输入：<code>npm i -g typescript</code></li></ul></li><li><p>创建一个ts文件</p></li><li><p>使用tsc对ts文件进行编译</p><ul><li><p>进入命令行</p></li><li><p>进入ts文件所在目录</p></li><li><p>执行命令：<code>tsc xxx.ts</code></p></li></ul></li></ol><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><ul><li><p><strong>类型声明</strong></p><ul><li><p>类型声明是TS非常重要的一个特点</p></li><li><p>通过类型声明可以指定TS中变量（参数、形参）的类型</p></li><li><p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</p></li><li><p>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值</p></li><li><p>语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 变量: 类型;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> 变量: 类型 = 值;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">参数: 类型, 参数: 类型</span>): 类型</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>自动类型判断</strong></p><ul><li>TS拥有自动的类型判断机制</li><li><strong>当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</strong></li><li>所以<strong>如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</strong></li></ul></li><li><p><strong>类型</strong>：</p><table><thead><tr><th align="center">类型</th><th align="center">例子</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">number</td><td align="center">1, -33, 2.5</td><td align="center">任意数字</td></tr><tr><td align="center">string</td><td align="center">‘hi’, “hi”</td><td align="center">任意字符串</td></tr><tr><td align="center">boolean</td><td align="center">true、false</td><td align="center">布尔值true或false</td></tr><tr><td align="center">字面量</td><td align="center">其本身</td><td align="center">限制变量的值就是该字面量的值</td></tr><tr><td align="center">any</td><td align="center">*</td><td align="center">任意类型</td></tr><tr><td align="center">unknown</td><td align="center">*</td><td align="center">类型安全的any</td></tr><tr><td align="center">void</td><td align="center">空值（undefined）</td><td align="center">没有值（或undefined）</td></tr><tr><td align="center">never</td><td align="center">没有值</td><td align="center">不能是任何值</td></tr><tr><td align="center">object</td><td align="center">{name:’孙悟空’}</td><td align="center">任意的JS对象</td></tr><tr><td align="center">array</td><td align="center">[1,2,3]</td><td align="center">任意JS数组</td></tr><tr><td align="center">tuple</td><td align="center">[4,5]</td><td align="center">元组，TS新增类型，固定长度数组</td></tr><tr><td align="center">enum</td><td align="center">enum{A, B}</td><td align="center">枚举，TS中新增类型</td></tr></tbody></table></li><li><p><strong>number</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decimal: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hex: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> binary: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> octal: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br><span class="line"><span class="keyword">let</span> big: bigint = <span class="number">100n</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>boolean</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>string</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color: <span class="built_in">string</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fullName: <span class="built_in">string</span> = <span class="string">`Bob Bobbington`</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123;fullName&#125;</span>.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I&#x27;ll be <span class="subst">$&#123;age + <span class="number">1</span>&#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>字面量</strong></p><ul><li><p>也可以使用字面量去指定变量的类型，<strong>通过字面量可以确定变量的取值范围</strong></p></li><li><p>使用 <code>|</code> 来连接多个类型（联合类型）</p></li><li><p>目前支持<code>字符串</code>、<code>数字</code>、<code>布尔</code>三种类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color: <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;blue&#x27;</span> | <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> num: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>any</strong></p><ul><li><p>表示的是任意类型，<strong>一个变量设置类型为any后相当于对该变量关闭了TS的类型检测</strong></p></li><li><p>使用TS时，不建议使用any类型</p></li><li><p>声明变量<strong>如果不指定类型，则TS解析器会自动判断变量的类型为any （隐式的any）</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">d = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">d = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>unknown</strong></p><ul><li><p>类型是any，它可以赋值给任意变量</p></li><li><p><strong>unknown 实际上就是一个类型安全的any</strong></p></li><li><p><strong>unknown类型的变量，不能直接赋值给其他变量</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: unknown = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>null</code> 和 <code>undefined</code> 两个类型一旦赋值上，就不能在赋值给任何其他类型</p></li><li><p><strong>void</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>never</strong></p><p>表示一个函数永远不存在返回值，TS会认为类型为 <code>never</code>，那么与 <code>void</code> 相比, <code>never</code>应该是 <code>void</code>子集， 因为 <code>void</code>实际上的返回值为 <code>undefined</code>，而 <code>never</code> 连 <code>undefined</code>也不行</p><p>符合<code>never</code>的情况有：当抛出异常的情况和无限死循环</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>object</strong></p><ul><li><p>{} 用来指定对象中可以包含哪些属性</p></li><li><p>语法：<code>&#123;属性名:属性值,属性名:属性值&#125;</code></p></li><li><p>在属性名后边加上<code>?</code>，<strong>表示属性是可选的</strong></p></li><li><p><code>[propName: string]: any</code> 表示任意类型的属性</p></li><li><p>设置函数结构的类型声明：语法：<code>(形参:类型, 形参:类型 ...) =&gt; 返回值</code></p><ul><li>在书写的时候，也可以写入返回值的类型，如果写入，则必须要有对应类型的返回值，<strong>但通常情况下是省略</strong>，因为<code>TS</code>的类型推断功能够正确推断出返回值类型</li><li>参数类型<ul><li>可选参数： 如果函数要配置可有可无的参数时，可以通过 <code>?</code> 实现，可选参数一定要在最后面</li><li>默认参数：函数内可以自己设定其默认参数，用 <code>=</code> 实现</li><li>剩余参数：仍可以使用扩展运算符 <code>...</code></li></ul></li></ul></li><li><p><code>Object</code>(大写的O）,代表所有的原始类型或非原始类型都可以进行赋值,除了<code>null</code>和<code>undefined</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b: &#123;<span class="attr">name</span>: <span class="built_in">string</span>, age?: <span class="built_in">number</span>&#125;;</span><br><span class="line">b = &#123;<span class="attr">name</span>: <span class="string">&#x27;孙悟空&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c: &#123;<span class="attr">name</span>: <span class="built_in">string</span>, [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>&#125;;</span><br><span class="line">c = &#123;<span class="attr">name</span>: <span class="string">&#x27;猪八戒&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d: <span class="function">(<span class="params">a: <span class="built_in">number</span> ,b: <span class="built_in">number</span></span>)=&gt;</span><span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj: <span class="built_in">Object</span>;</span><br><span class="line">    obj = <span class="number">1</span>; <span class="comment">// ok</span></span><br><span class="line">    obj = <span class="string">&quot;a&quot;</span>; <span class="comment">// ok</span></span><br><span class="line">    obj = <span class="literal">true</span>; <span class="comment">// ok</span></span><br><span class="line">    obj = &#123;&#125;; <span class="comment">// ok</span></span><br><span class="line">    obj = <span class="built_in">Symbol</span>() <span class="comment">//ok</span></span><br><span class="line">    obj = <span class="number">10n</span> <span class="comment">//ok</span></span><br><span class="line">    obj = <span class="literal">null</span>; <span class="comment">// error</span></span><br><span class="line">    obj = <span class="literal">undefined</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>array</strong></p><ul><li><p><code>类型[]</code>   <code>Array&lt;类型&gt;</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>tuple</strong></p><ul><li><p>元组就是固定长度的数组</p></li><li><p>语法：<code>[类型, 类型, 类型]</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">x = [<span class="string">&quot;hello&quot;</span>, <span class="number">10</span>]; </span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>enum</strong></p><p>可以定义一些带名字的常量，这样可以<strong>清晰表达意图</strong>或<strong>创建一组有区别的用例</strong></p><p>注意：</p><ul><li>枚举的类型只能是 <code>string</code> 或 <code>number</code></li><li>定义的名称不能为<strong>关键字</strong></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color &#123;</span><br><span class="line">  Red,</span><br><span class="line">  Green,</span><br><span class="line">  Blue,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Color &#123;</span><br><span class="line">  Red = <span class="number">1</span>,</span><br><span class="line">  Green,</span><br><span class="line">  Blue,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Color &#123;</span><br><span class="line">  Red = <span class="number">1</span>,</span><br><span class="line">  Green = <span class="number">2</span>,</span><br><span class="line">  Blue = <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure></li><li><p><strong>类型断言</strong></p><ul><li><p>有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</p><ul><li><p>第一种</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: unknown = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure></li><li><p>第二种</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: unknown = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>补充</p><ul><li><p>&amp;表示同时 <strong>交叉类型</strong>：将多个类型合并为一个类型，使用<code>&amp;</code>符号连</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> j: &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125; &amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="comment">// j = &#123;name: &#x27;孙悟空&#x27;, age: 18&#125;;</span></span><br></pre></td></tr></table></figure></li><li><p>类型的别名</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myType = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> k: myType;</span><br><span class="line"><span class="keyword">let</span> l: myType;</span><br><span class="line"><span class="keyword">let</span> m: myType;</span><br><span class="line"></span><br><span class="line">k = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><ul><li><p>自动编译文件</p><ul><li><p>编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</p></li><li><p>示例：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc xxx.ts <span class="literal">-w</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>自动编译整个项目</p><ul><li><p>如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。</p></li><li><p>但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json</p></li><li><p><code>tsconfig.json</code>是一个JSON文件，添加配置文件后，只需只需 <code>tsc</code> 命令即可完成对整个项目的编译</p></li><li><p>配置选项：</p><ul><li><p><code>include</code></p><ul><li><p>定义希望被编译文件所在的目录</p></li><li><p>默认值：[“<code>**表示任意目录</code>/<code>*表示任意文件</code>“]</p></li><li><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;include&quot;</span>:[<span class="string">&quot;src/**/*&quot;</span>, <span class="string">&quot;tests/**/*&quot;</span>]</span><br></pre></td></tr></table></figure><p>上述示例中，所有src目录和tests目录下的文件都会被编译</p></li></ul></li><li><p>exclude</p><ul><li><p>定义需要排除在外的目录</p></li><li><p>默认值：[“node_modules”, “bower_components”, “jspm_packages”]</p></li><li><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;exclude&quot;</span>: [<span class="string">&quot;./src/hello/**/*&quot;</span>]</span><br></pre></td></tr></table></figure><p>上述示例中，src下hello目录下的文件都不会被编译</p></li></ul></li><li><p>extends</p><ul><li><p>定义被继承的配置文件</p></li><li><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;extends&quot;</span>: <span class="string">&quot;./configs/base&quot;</span></span><br></pre></td></tr></table></figure><p>上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息</p></li></ul></li><li><p>files</p><ul><li><p>指定被编译文件的列表，只有需要编译的文件少时才会用到</p></li><li><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;files&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;core.ts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sys.ts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;types.ts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;scanner.ts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;parser.ts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;utilities.ts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;binder.ts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;checker.ts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tsc.ts&quot;</span></span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>列表中的文件都会被TS编译器所编译</p></li><li><p><code>compilerOptions</code></p><ul><li><p>编译选项是配置文件中非常重要也比较复杂的配置选项</p></li><li><p>在compilerOptions中包含多个子选项，用来完成对编译的配置</p><ul><li><p>项目选项</p><ul><li><p><code>target</code></p><ul><li><p>设置ts代码编译的目标版本</p></li><li><p>可选值：</p><ul><li>ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext</li></ul></li><li><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es6&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码</p></li></ul></li><li><p><code>lib</code></p><ul><li><p>指定代码运行时所包含的库（宿主环境）</p></li><li><p>可选值：</p><ul><li>ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ……</li></ul></li><li><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ES6&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lib&quot;</span>: [<span class="string">&quot;ES6&quot;</span>, <span class="string">&quot;DOM&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;dist&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span>: <span class="string">&quot;dist/aa.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>module</code></p><ul><li><p>设置编译后代码使用的模块化系统</p></li><li><p>可选值：</p><ul><li>CommonJS、UMD、AMD、System、ES2020、ESNext、None</li></ul></li><li><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;CommonJS&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>outDir</code></p><ul><li><p>编译后文件的所在目录</p></li><li><p>默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置</p></li><li><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;dist&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置后编译后的js文件将会生成到dist目录</p></li></ul></li><li><p>outFile</p><ul><li><p>将所有的文件编译为一个js文件</p></li><li><p>默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中</p></li><li><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span>: <span class="string">&quot;dist/app.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>rootDir</p><ul><li><p>指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录</p></li><li><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span>: <span class="string">&quot;./src&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>allowJs</p><ul><li>是否对js文件编译</li></ul></li><li><p>checkJs</p><ul><li><p>是否对js文件进行检查</p></li><li><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;checkJs&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>removeComments</code></p><ul><li>是否删除注释</li><li>默认值：false</li></ul></li><li><p><code>noEmit</code></p><ul><li>不对代码进行编译</li><li>默认值：false</li></ul></li><li><p>sourceMap</p><ul><li>是否生成sourceMap</li><li>默认值：false</li></ul></li></ul></li><li><p>严格检查</p><ul><li><code>strict</code><ul><li>启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查</li></ul></li><li><code>alwaysStrict</code><ul><li>用来设置编译后的文件是否使用严格模式，默认false</li></ul></li><li><code>noImplicitAny</code><ul><li>禁止隐式的any类型</li></ul></li><li><code>noImplicitThis</code><ul><li>禁止类型不明确的this</li></ul></li><li>strictBindCallApply<ul><li>严格检查bind、call和apply的参数列表</li></ul></li><li>strictFunctionTypes<ul><li>严格检查函数的类型</li></ul></li><li><code>strictNullChecks</code><ul><li>严格的空值检查</li></ul></li><li>strictPropertyInitialization<ul><li>严格检查属性是否初始化</li></ul></li></ul></li><li><p>额外检查</p><ul><li>noFallthroughCasesInSwitch<ul><li>检查switch语句包含正确的break</li></ul></li><li>noImplicitReturns<ul><li>检查函数没有隐式的返回值</li></ul></li><li>noUnusedLocals<ul><li>检查未使用的局部变量</li></ul></li><li>noUnusedParameters<ul><li>检查未使用的参数</li></ul></li></ul></li><li><p>高级</p><ul><li>allowUnreachableCode<ul><li>检查不可达代码</li><li>可选值：<ul><li>true，忽略不可达代码</li><li>false，不可达代码将引起错误</li></ul></li></ul></li><li><code>noEmitOnError</code><ul><li>有错误的情况下不进行编译</li><li>默认值：false</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><ul><li><p>通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。</p></li><li><p>步骤：</p><ol><li><p>初始化项目</p><ul><li>进入项目根目录，执行命令 <code> npm init -y</code><ul><li>主要作用：创建package.json文件</li></ul></li></ul></li><li><p>下载构建工具</p><ul><li><code>npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader html-webpack-plugin clean-webpack-plugin</code>  <ul><li>共安装了7个包<ul><li>webpack<ul><li>构建工具webpack</li></ul></li><li>webpack-cli<ul><li>webpack的命令行工具</li></ul></li><li>webpack-dev-server<ul><li>webpack的开发服务器</li></ul></li><li>typescript<ul><li>ts编译器</li></ul></li><li>ts-loader<ul><li>ts加载器，用于在webpack中编译ts文件</li></ul></li><li>html-webpack-plugin<ul><li>webpack中html插件，用来自动创建html文件</li></ul></li><li>clean-webpack-plugin<ul><li>webpack中的清除插件，每次构建都会先清除目录</li></ul></li></ul></li></ul></li></ul></li><li><p>根目录下创建webpack的配置文件webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&quot;clean-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">optimization</span>:&#123;</span><br><span class="line">        <span class="attr">minimize</span>: <span class="literal">false</span> <span class="comment">// 关闭代码压缩，可选</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&quot;./src/index.ts&quot;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&quot;inline-source-map&quot;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">contentBase</span>: <span class="string">&#x27;./dist&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">        <span class="attr">environment</span>: &#123;</span><br><span class="line">            <span class="attr">arrowFunction</span>: <span class="literal">false</span> <span class="comment">// 关闭webpack的箭头函数，可选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">extensions</span>: [<span class="string">&quot;.ts&quot;</span>, <span class="string">&quot;.js&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">                use: &#123;</span><br><span class="line">                   <span class="attr">loader</span>: <span class="string">&quot;ts-loader&quot;</span>     </span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="comment">//title:&#x27;TS测试&#x27;</span></span><br><span class="line">            <span class="attr">template</span>: <span class="string">&quot;./src/index.html&quot;</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根目录下创建tsconfig.json，配置可以根据自己需要</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ES2015&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;ES2015&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改package.json添加如下配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...略...</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack serve --open&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在src下创建ts文件，并在并命令行执行<code>npm run build</code>对代码进行编译，或者执行<code>npm start</code>来启动开发服务器</p></li></ol></li></ul><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><ul><li><p>经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来对代码进行转换以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。</p><ol><li><p>安装依赖包：</p><ul><li><code>npm i -D @babel/core @babel/preset-env babel-loader core-js</code></li><li>共安装了4个包，分别是：<ul><li>@babel/core<ul><li>babel的核心工具</li></ul></li><li>@babel/preset-env<ul><li>babel的预定义环境</li></ul></li><li>@babel-loader<ul><li>babel在webpack中的加载器</li></ul></li><li>core-js<ul><li>core-js用来使老版本的浏览器支持新版ES语法</li></ul></li></ul></li></ul></li><li><p>修改webpack.config.js配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入一个包</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入html插件</span></span><br><span class="line"><span class="keyword">const</span> HTMLWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入clean插件</span></span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack中的所有的配置信息都应该写在module.exports中</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定入口文件</span></span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&quot;./src/index.ts&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定打包文件所在目录</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">// 指定打包文件的目录</span></span><br><span class="line">        <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="comment">// 打包后文件的文件</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 告诉webpack不使用箭头</span></span><br><span class="line">        <span class="attr">environment</span>:&#123;</span><br><span class="line">            <span class="attr">arrowFunction</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定webpack打包时要使用模块</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="comment">// 指定要加载的规则</span></span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// test指定的是规则生效的文件</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">                <span class="comment">// 要使用的loader</span></span><br><span class="line">                use: [</span><br><span class="line">                     <span class="comment">// 配置babel</span></span><br><span class="line">                     &#123;</span><br><span class="line">                         <span class="comment">// 指定加载器</span></span><br><span class="line">                         <span class="attr">loader</span>:<span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">                         <span class="comment">// 设置babel</span></span><br><span class="line">                         <span class="attr">options</span>: &#123;</span><br><span class="line">                             <span class="comment">// 设置预定义的环境</span></span><br><span class="line">                             <span class="attr">presets</span>:[</span><br><span class="line">                                 [</span><br><span class="line">                                     <span class="comment">// 指定环境的插件</span></span><br><span class="line">                                     <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">                                     <span class="comment">// 配置信息</span></span><br><span class="line">                                     &#123;</span><br><span class="line">                                         <span class="comment">// 要兼容的目标浏览器</span></span><br><span class="line">                                         <span class="attr">targets</span>:&#123;</span><br><span class="line">                                             <span class="string">&quot;chrome&quot;</span>:<span class="string">&quot;58&quot;</span>,</span><br><span class="line">                                             <span class="string">&quot;ie&quot;</span>:<span class="string">&quot;11&quot;</span></span><br><span class="line">                                         &#125;,</span><br><span class="line">                                         <span class="comment">// 指定corejs的版本</span></span><br><span class="line">                                         <span class="string">&quot;corejs&quot;</span>:<span class="string">&quot;3&quot;</span>,</span><br><span class="line">                                         <span class="comment">// 使用corejs的方式 &quot;usage&quot; 表示按需加载</span></span><br><span class="line">                                         <span class="string">&quot;useBuiltIns&quot;</span>:<span class="string">&quot;usage&quot;</span></span><br><span class="line">                                     &#125;</span><br><span class="line">                                 ]</span><br><span class="line">                             ]</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;,</span><br><span class="line">                    <span class="string">&#x27;ts-loader&#x27;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="comment">// 要排除的文件</span></span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node-modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置Webpack插件</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> HTMLWebpackPlugin(&#123;</span><br><span class="line">            <span class="comment">// title: &quot;这是一个自定义的title&quot;</span></span><br><span class="line">            <span class="attr">template</span>: <span class="string">&quot;./src/index.html&quot;</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来设置引用模块</span></span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">extensions</span>: [<span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。</p></li></ol></li></ul><h1 id="第二章：面向对象"><a href="#第二章：面向对象" class="headerlink" title="第二章：面向对象"></a>第二章：面向对象</h1><p>面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，简而言之就是程序之中所有的操作都需要通过对象来完成。</p><ul><li>举例来说：<ul><li>操作浏览器要使用window对象</li><li>操作网页要使用document对象</li><li>操作控制台要使用console对象</li></ul></li></ul><p>一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。</p><p>在程序中所有的对象都被分成了两个部分：数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为<strong>属性</strong>，而功能就被称为<strong>方法</strong>。所以简而言之，在程序中一切皆是对象。</p><h2 id="类（class）"><a href="#类（class）" class="headerlink" title="类（class）"></a>类（class）</h2><p>要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。</p><ul><li><p>定义类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">属性名: 类型;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">参数: 类型</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.属性名 = 参数;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法名()&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//静态属性</span></span><br><span class="line">    <span class="keyword">static</span> name1: <span class="built_in">string</span> = <span class="string">&#x27;Domesy&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员属性，实际上是通过public上进行修饰，只是省略了</span></span><br><span class="line">    <span class="comment">// 需要注意的是： 在成员属性中，如果不给默认值,并且不使用是会报错的，如果不想报错就给加!</span></span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    money!: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">// constructor 被称为构造函数</span></span><br><span class="line">    <span class="comment">//  构造函数会在对象创建时调用</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 在实例方法中，this就表示当前当前的实例</span></span><br><span class="line">        <span class="comment">// 在构造函数中当前对象就是当前新建的那个对象</span></span><br><span class="line">        <span class="comment">// 可以通过this向新建的对象中添加属性</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 在方法中可以通过this来表示当前调用方法的对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`大家好，我是<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;孙悟空&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">p.sayHello();</span><br></pre></td></tr></table></figure></li></ul><h2 id="面向对象的特点"><a href="#面向对象的特点" class="headerlink" title="面向对象的特点"></a>面向对象的特点</h2><ul><li><p>封装</p><ul><li><p><strong>对象实质上就是属性和方法的容器</strong>，它的主要作用就是存储属性和方法，这就是所谓的封装</p></li><li><p>默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置</p></li><li><p>私有字段(<code>#</code>)</p><p>在 TS 3.8版本便开始支持<strong>ECMACMAScript</strong>的私有字段。</p><p>需要注意的是<code>私有字段</code>与常规字段不同，主要的区别是：</p><ul><li>私有字段以 <code>#</code> 字符开头，也叫私有名称；</li><li>每个私有字段名称都<strong>唯一</strong>地限定于其包含的类；</li><li>不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；</li><li>私有字段不能在包含的类之外访问，甚至不能被检测到。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    #name: <span class="built_in">string</span>; <span class="comment">//私有字段</span></span><br><span class="line">    getName: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.#name = name;</span><br><span class="line">        <span class="built_in">this</span>.getName = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">setName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`我的名字是<span class="subst">$&#123;<span class="built_in">this</span>.#name&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myName = <span class="keyword">new</span> Info(<span class="string">&quot;Domesy&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myName.setName()) <span class="comment">// &quot;我的名字是Domesy&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(myName.getName) <span class="comment">// ok &quot;Domesy&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(myName.#name) <span class="comment">// error </span></span><br><span class="line"><span class="comment">// Property &#x27;#name&#x27; is not accessible outside class &#x27;Info&#x27; </span></span><br><span class="line"><span class="comment">// because it has a private identifier.(18013)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>只读属性（readonly）</strong>：</p><ul><li>如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改</li><li>用 <code>readonly</code>修饰，只能在<strong>构造函数</strong>中初始化，并且在TS中，只允许将<code>interface</code>、<code>type</code>、<code>class</code>上的属性标识为<code>readonly</code><ul><li><code>readonly</code>实际上只是在<code>编译阶段</code>进行代码检查</li><li>被<code>radonly</code>修饰的词只能在 <code>constructor</code>阶段修改，其他时刻不允许修改</li></ul></li></ul></li><li><p>TS中属性具有三种修饰符：</p><ul><li><p><strong>public（默认值）</strong>，类中、子类内的任何地方、外部<strong>都能调用</strong></p></li><li><p><strong>protected</strong> ，类中、子类内的任何地方都能调用,但<strong>外部不能调用</strong></p></li><li><p><strong>private</strong> ，类中可以调用，子类内的任何地方、外部<strong>均不可调用</strong></p></li><li><p>示例</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> name: <span class="built_in">string</span></span><br><span class="line">      <span class="keyword">protected</span> age: <span class="built_in">number</span></span><br><span class="line">      <span class="keyword">private</span> tel: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age:<span class="built_in">number</span>, tel: <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">        <span class="built_in">this</span>.tel = tel</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, tel: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, tel);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`我的名字叫<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>,年龄是<span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>) <span class="comment">// ok name 和 age可以</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`电话是<span class="subst">$&#123;<span class="built_in">this</span>.tel&#125;</span>`</span>) <span class="comment">// error 报错 原因是 tel 拿不出来</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">new</span> Child(<span class="string">&#x27;Domesy&#x27;</span>, <span class="number">7</span>, <span class="number">123456</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res.name) <span class="comment">// ok Domesy</span></span><br><span class="line">    <span class="built_in">console</span>.log(res.age) <span class="comment">// error</span></span><br><span class="line">    <span class="built_in">console</span>.log(res.tel) <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>属性存取器</p><ul><li><p>对于一些不希望被任意修改的属性，可以将其设置为private</p></li><li><p>直接将其设置为private将导致无法再通过对象修改其中的属性</p></li><li><p>我们可以在类中定义一组读取、设置属性的方法，<strong>这种对属性读取或设置的属性被称为属性的存取器</strong></p></li><li><p>设置属性的方法叫做<code>setter</code>方法，读取属性的方法叫做<code>getter</code>方法</p></li><li><p>示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> _name: <span class="built_in">string</span>;</span><br><span class="line">        <span class="keyword">private</span> _age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._name = name;</span><br><span class="line">            <span class="built_in">this</span>._age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *   getter方法用来读取属性</span></span><br><span class="line"><span class="comment">        *   setter方法用来设置属性</span></span><br><span class="line"><span class="comment">        *       - 它们被称为属性的存取器</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义方法，用来获取name属性</span></span><br><span class="line">        <span class="comment">// getName()&#123;</span></span><br><span class="line">        <span class="comment">//     return this._name;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// // 定义方法，用来设置name属性</span></span><br><span class="line">        <span class="comment">// setName(value: string)&#123;</span></span><br><span class="line">        <span class="comment">//     this._name = value;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        <span class="comment">// TS中设置getter方法的方式</span></span><br><span class="line">        <span class="keyword">get</span> <span class="title">name</span>()&#123;</span><br><span class="line">            <span class="comment">// console.log(&#x27;get name()执行了！！&#x27;);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>._name = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">age</span>()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">age</span>(<span class="params">value</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(value &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>._age = value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> per = <span class="keyword">new</span> Person(<span class="string">&#x27;孙悟空&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// per.setName(&#x27;猪八戒&#x27;);</span></span><br><span class="line">    <span class="comment">// per.setAge(-33);</span></span><br><span class="line"></span><br><span class="line">    per.name = <span class="string">&#x27;猪八戒&#x27;</span>;</span><br><span class="line">    per.age = -<span class="number">33</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>静态属性</p><ul><li><p>静态属性（方法），也称为类属性。<strong>使用静态属性无需创建实例，通过类即可直接使用</strong></p></li><li><p>静态属性（方法）使用<code>static</code>开头</p></li><li><p>示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tools</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">sum</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Tools.PI);</span><br><span class="line"><span class="built_in">console</span>.log(Tools.sum(<span class="number">123</span>, <span class="number">456</span>));</span><br></pre></td></tr></table></figure></li></ul></li><li><p>this</p><ul><li><strong>在类中，使用this表示当前对象</strong></li></ul></li></ul></li><li><p>继承</p><ul><li><p>继承是面向对象中的又一个特性</p></li><li><p>通过继承可以将其他类中的属性和方法引入到当前类中</p><ul><li><p>示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">bark</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>在汪汪叫！`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;旺财&#x27;</span>, <span class="number">4</span>);</span><br><span class="line">dog.bark();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过继承可以在不修改类的情况下完成对类的扩展</p></li><li><p>重写和重载</p><ul><li><p><strong>重写</strong>：子类重写继承自父类中的方法</p></li><li><p><strong>重载</strong>：指为同一个函数提供多个类型定义</p></li><li><p>示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">setName</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`我的名字叫<span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">setName</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`你的名字叫<span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yourName = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(yourName.setName(<span class="string">&#x27;小杜杜&#x27;</span>)) <span class="comment">// &quot;你的名字叫小杜杜&quot; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span></span>&#123;</span><br><span class="line">    setNameAge(name: <span class="built_in">string</span>):<span class="built_in">void</span>;</span><br><span class="line">    setNameAge(name: <span class="built_in">number</span>):<span class="built_in">void</span>;</span><br><span class="line">    <span class="function"><span class="title">setNameAge</span>(<span class="params">name:<span class="built_in">string</span> | <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> name === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`我的名字是<span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`我的年龄是<span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">new</span> Person1()</span><br><span class="line">res.setNameAge(<span class="string">&#x27;小杜杜&#x27;</span>) <span class="comment">// &quot;我的名字是小杜杜&quot; </span></span><br><span class="line">res.setNameAge(<span class="number">7</span>) <span class="comment">// &quot;我的年龄是7&quot;</span></span><br></pre></td></tr></table></figure><p>在子类中可以使用<strong>super</strong>来完成对父类的引用</p><ul><li>如果在子类中写了构造函数，在子类构造函数中必须对父类的构造函数进行调用</li><li>在类的方法中 super就表示当前类的父类</li></ul></li></ul></li><li><p>抽象类（abstract class）</p><p>用abstract关键字声明的类叫做<strong>抽象类</strong>，声明的方法叫做<strong>抽象方法</strong></p><ul><li><strong>抽象类</strong>：指不能被实例化，因为它里面包含一个或多个抽象方法。</li><li><strong>抽象方法</strong>：是指不包含具体实现的方法；</li></ul><p>注：抽象类是不能直接实例化，只能实例化实现了所有抽象方法的子类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">abstract</span> setAge(age: <span class="built_in">number</span>) :<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setAge(age: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`我的名字是<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>,年龄是<span class="subst">$&#123;age&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="keyword">new</span> Person(<span class="string">&quot;小杜杜&quot;</span>) <span class="comment">//error</span></span><br><span class="line"><span class="keyword">let</span> res1 = <span class="keyword">new</span> Child(<span class="string">&quot;小杜杜&quot;</span>);</span><br><span class="line"></span><br><span class="line">res1.setAge(<span class="number">7</span>) <span class="comment">// &quot;我的名字是小杜杜,年龄是7&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h2><p>接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说<strong>接口中的所有方法都是抽象方法</strong>。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。</p><ul><li><p>示例（检查对象类型）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    sayHello():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">per: Person</span>)</span>&#123;</span><br><span class="line">    per.sayHello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(&#123;<span class="attr">name</span>:<span class="string">&#x27;孙悟空&#x27;</span>, <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;<span class="built_in">console</span>.log(<span class="string">`Hello, 我是 <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>)&#125;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>示例（实现）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    sayHello():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="title">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;大家好，我是&#x27;</span>+<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="泛型（Generic）"><a href="#泛型（Generic）" class="headerlink" title="泛型（Generic）"></a>泛型（Generic）</h2><p>定义一个函数或类时，<strong>有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定）</strong>，此时泛型便能够发挥作用。</p><ul><li><p>举个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">any</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型</p><p>使用泛型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>&lt;T&gt;</code>就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。</p><p>那么如何使用上边的函数呢？</p><ul><li><p>方式一（直接使用）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式</p></li><li><p>方式二（指定类型）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test&lt;<span class="built_in">number</span>&gt;(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>也可以在函数后手动指定泛型</p></li></ul><p>可以同时指定多个泛型，泛型间使用逗号隔开：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt;(<span class="params">a: T, b: K</span>): <span class="title">K</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test&lt;<span class="built_in">number</span>, <span class="built_in">string</span>&gt;(<span class="number">10</span>, <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用泛型时，完全可以将泛型当成是一个普通的类去使用</p><p>类中同样可以使用泛型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="attr">prop</span>: T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">prop: T</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.prop = prop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，也可以对泛型的范围进行约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MyInter&#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">MyInter</span>&gt;(<span class="params">arg: T</span>): <span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。</p></li></ul><h1 id="TS断言和类型守卫"><a href="#TS断言和类型守卫" class="headerlink" title="TS断言和类型守卫"></a>TS断言和类型守卫</h1><h2 id="TS断言"><a href="#TS断言" class="headerlink" title="TS断言"></a>TS断言</h2><p>分为三种：<code>类型断言</code>、<code>非空断言</code>、<code>确定赋值断言</code></p><p>当断言失效后，可能使用到：<strong>双重断言</strong></p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>在特定的环境中，我们会比TS知道这个值具体是什么类型，不需要TS去判断，简单的理解就是，<strong>类型断言会告诉编译器，你不用给我进行检查，相信我，他就是这个类型</strong></p><p>共有两种方式：</p><ul><li><strong>尖括号</strong></li><li><strong>as</strong>：推荐</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尖括号</span></span><br><span class="line"><span class="keyword">let</span> num:<span class="built_in">any</span> = <span class="string">&#x27;小杜杜&#x27;</span></span><br><span class="line"><span class="keyword">let</span> res1: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;num).length; <span class="comment">// React中会 error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// as 语法</span></span><br><span class="line"><span class="keyword">let</span> str: <span class="built_in">any</span> = <span class="string">&#x27;Domesy&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> res: <span class="built_in">number</span> = (str <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure><p>但需要注意的是：尖括号语法在<strong>React</strong>中会报错，原因是与<code>JSX</code>语法会产生冲突，所以只能使用<strong>as语法</strong></p><h3 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h3><p>在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 <code>!</code> 可以用于断言操作对象是<strong>非 null 和非 undefined 类型。</strong></p><p><strong>具体而言，x! 将从 x 值域中排除 null 和 undefined 。</strong></p><p>那么非空断言操作符到底有什么用呢？下面我们先来看一下非空断言操作符的一些使用场景。</p><h4 id="忽略-undefined-和-null-类型"><a href="#忽略-undefined-和-null-类型" class="headerlink" title="忽略 undefined 和 null 类型"></a>忽略 undefined 和 null 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">maybeString: <span class="built_in">string</span> | <span class="literal">undefined</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Type &#x27;string | null | undefined&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br><span class="line">  <span class="comment">// Type &#x27;undefined&#x27; is not assignable to type &#x27;string&#x27;. </span></span><br><span class="line">  <span class="keyword">const</span> onlyString: <span class="built_in">string</span> = maybeString; <span class="comment">// Error</span></span><br><span class="line">  <span class="keyword">const</span> ignoreUndefinedAndNull: <span class="built_in">string</span> = maybeString!; <span class="comment">// Ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用函数时忽略-undefined-类型"><a href="#调用函数时忽略-undefined-类型" class="headerlink" title="调用函数时忽略 undefined 类型"></a>调用函数时忽略 undefined 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumGenerator = <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">numGenerator: NumGenerator | <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Object is possibly &#x27;undefined&#x27;.(2532)</span></span><br><span class="line">  <span class="comment">// Cannot invoke an object which is possibly &#x27;undefined&#x27;.(2722)</span></span><br><span class="line">  <span class="keyword">const</span> num1 = numGenerator(); <span class="comment">// Error</span></span><br><span class="line">  <span class="keyword">const</span> num2 = numGenerator!(); <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>!</code> 非空断言操作符会从编译生成的 JavaScript 代码中移除，所以在实际使用的过程中，要特别注意。比如下面这个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="built_in">number</span> | <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> b: <span class="built_in">number</span> = a!;</span><br><span class="line"><span class="built_in">console</span>.log(b); </span><br></pre></td></tr></table></figure><p>以上 TS 代码会编译生成以下 ES5 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure><p>虽然在 TS 代码中，我们使用了非空断言，使得 <code>const b: number = a!;</code> 语句可以通过 TypeScript 类型检查器的检查。但在生成的 ES5 代码中，<code>!</code> 非空断言操作符被移除了，所以在浏览器中执行以上代码，在控制台会输出 <code>undefined</code>。</p><h3 id="确定赋值断言"><a href="#确定赋值断言" class="headerlink" title="确定赋值断言"></a>确定赋值断言</h3><p>在<code>TS</code> 2.7版本中引入了确定赋值断言，即允许在实例属性和变量声明后面放置一个 <code>!</code> 号，以告诉<code>TS</code>该属性会被明确赋值。</p><p>为了更好地理解它的作用，我们来看个具体的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">number</span>;</span><br><span class="line">initialize();</span><br><span class="line"><span class="comment">// Variable &#x27;x&#x27; is used before being assigned.(2454)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> * x); <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显该异常信息是说变量 x 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x!: <span class="built_in">number</span>;</span><br><span class="line">initialize();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> * x); <span class="comment">// Ok</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>let x!: number;</code> 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。</p><h3 id="双重断言"><a href="#双重断言" class="headerlink" title="双重断言"></a>双重断言</h3><p><strong>断言失效后，可能会用到，但一般情况下不会使用</strong></p><p>失效的情况：基础类型不能断言为接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Info&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;小杜杜&#x27;</span> <span class="keyword">as</span> Info; <span class="comment">// error, 原因是不能把 string 类型断言为 一个接口</span></span><br><span class="line"><span class="keyword">const</span> name1 = <span class="string">&#x27;小杜杜&#x27;</span> <span class="keyword">as</span> <span class="built_in">any</span> <span class="keyword">as</span> Info; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><h2 id="类型守卫"><a href="#类型守卫" class="headerlink" title="类型守卫"></a>类型守卫</h2><p><strong>类型守卫</strong>：是<strong>可执行运行时检查的</strong>一种表达式，用于确保<strong>该类型在一定的范围内</strong>。</p><p>我个人的感觉是，类型守卫就是你可以设置多种类型，但我默认你是什么类型的意思</p><p>目前，常有的类型守卫共有4种：<strong>in关键字</strong>、<strong>typeof关键字</strong>、<strong>instanceof</strong>和<strong>类型谓词（is)</strong></p><h3 id="in关键字"><a href="#in关键字" class="headerlink" title="in关键字"></a>in关键字</h3><p><strong>用于判断这个属性是那个里面的</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Info &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Info1&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">flage</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setInfo = <span class="function">(<span class="params">data: Info | Info1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;age&quot;</span> <span class="keyword">in</span> data)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`我的名字是：<span class="subst">$&#123;data.name&#125;</span>，年龄是：<span class="subst">$&#123;data.age&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;flage&quot;</span> <span class="keyword">in</span> data)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`我的名字是：<span class="subst">$&#123;data.name&#125;</span>，性别是：<span class="subst">$&#123;data.flage&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInfo(&#123;<span class="attr">name</span>: <span class="string">&#x27;小杜杜&#x27;</span>, <span class="attr">age</span>: <span class="number">7</span>&#125;) <span class="comment">// &quot;我的名字是：小杜杜，年龄是：7&quot; </span></span><br><span class="line">setInfo(&#123;<span class="attr">name</span>: <span class="string">&#x27;小杜杜&#x27;</span>, <span class="attr">flage</span>: <span class="literal">true</span>&#125;) <span class="comment">// &quot;我的名字是：小杜杜，性别是：true&quot;</span></span><br></pre></td></tr></table></figure><h3 id="typeof关键字"><a href="#typeof关键字" class="headerlink" title="typeof关键字"></a>typeof关键字</h3><p><strong>用于判断基本类型，如string ｜ number等</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setInfo = <span class="function">(<span class="params">data: <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="literal">undefined</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> data === <span class="string">&quot;string&quot;</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`我的名字是：<span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> data === <span class="string">&quot;number&quot;</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`我的年龄是：<span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> data === <span class="string">&quot;undefined&quot;</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInfo(<span class="string">&#x27;小杜杜&#x27;</span>) <span class="comment">// &quot;我的名字是：小杜杜&quot;  </span></span><br><span class="line">setInfo(<span class="number">7</span>) <span class="comment">// &quot;我的年龄是：7&quot; </span></span><br><span class="line">setInfo(<span class="literal">undefined</span>) <span class="comment">// undefined&quot; </span></span><br></pre></td></tr></table></figure><h3 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h3><p><strong>用于判断一个实例是不是构造函数，或使用类的时候</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;小杜杜&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span> <span class="keyword">extends</span> <span class="title">Name</span></span>&#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setInfo = <span class="function">(<span class="params">data: Name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data <span class="keyword">instanceof</span> Age) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`我的年龄是<span class="subst">$&#123;data.age&#125;</span>`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`我的名字是<span class="subst">$&#123;data.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">setInfo(<span class="keyword">new</span> Name()) <span class="comment">// &quot;我的名字是小杜杜&quot;</span></span><br><span class="line">setInfo(<span class="keyword">new</span> Age()) <span class="comment">// &quot;我的年龄是7&quot; </span></span><br></pre></td></tr></table></figure><h3 id="类型谓词（is"><a href="#类型谓词（is" class="headerlink" title="类型谓词（is)"></a>类型谓词（is)</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">number</span> </span>&#123; <span class="comment">//默认传入的是number类型</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&quot;number&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isNumber(<span class="number">7</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isNumber(<span class="string">&#x27;7&#x27;</span>)) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(isNumber(<span class="literal">true</span>)) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h2><p>通过上面的介绍，我们可以发现断言与<strong>类型守卫</strong>的概念非常相似，都是确定参数的类型，但<strong>断言</strong>更加<strong>霸道</strong>，它是直接告诉编辑器，这个参数就是这个类型，而类型守卫更像确定这个参数具体是什么类型。</p><h1 id="类型别名、接口"><a href="#类型别名、接口" class="headerlink" title="类型别名、接口"></a>类型别名、接口</h1><h2 id="类型别名（type）"><a href="#类型别名（type）" class="headerlink" title="类型别名（type）"></a>类型别名（type）</h2><p><strong>类型别名</strong>：也就是<code>type</code>，用来给一个类型起个新名字</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> InfoProps = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setInfo = <span class="function">(<span class="params">data: InfoProps</span>) =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h2><p><strong>接口</strong>：<strong>在面向对象语言中表示行为抽象，也可以用来描述对象的形状</strong>。</p><p>使用<strong>interface</strong>关键字来定义接口</p><h3 id="对象的形状"><a href="#对象的形状" class="headerlink" title="对象的形状"></a>对象的形状</h3><p>接口可以用来描述<code>对象</code>，主要可以包括以下数据：<code>可读属性</code>、<code>只读属性</code>、<code>任意属性</code></p><ul><li><strong>可读属性</strong>：当我们定义一个接口时，我们的属性可能不需要全都要，这是就需要 <code>?</code> 来解决</li><li><strong>只读属性</strong>：用 <strong>readonly</strong>修饰的属性为只读属性，意思是指允许定义，不允许之后进行更改</li><li><strong>任意属性</strong>：这个属性极为重要，它是可以用作就算没有定义，也可以使用，比如 <strong>[propName: string]: any</strong>。比如说我们对组件进行封装，而封装的那个组件并没有导出对应的类型，然而又想让他不报错，这时就可以使用任意属性</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">    b: <span class="built_in">number</span>;</span><br><span class="line">    c: <span class="built_in">boolean</span>;</span><br><span class="line">    d?: <span class="built_in">number</span>; <span class="comment">// 可选属性</span></span><br><span class="line">    <span class="keyword">readonly</span> e: <span class="built_in">string</span>; <span class="comment">//只读属性</span></span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">//任意属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res: Props = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;小杜杜&#x27;</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">e</span>: <span class="string">&#x27;Domesy&#x27;</span>,</span><br><span class="line">    <span class="attr">d</span>: <span class="number">1</span>, <span class="comment">// 有没有d都可以</span></span><br><span class="line">    <span class="attr">h</span>: <span class="number">2</span> <span class="comment">// 任意属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res.e = <span class="string">&#x27;hi&#x27;</span> <span class="comment">// error, 原因是可读属性不允许更改</span></span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>继承</strong>：与类一样，接口也存在继承属性，也是使用<code>extends</code>字段</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> nameProps &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Props <span class="keyword">extends</span> nameProps&#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res: Props = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小杜杜&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数类型接口"><a href="#函数类型接口" class="headerlink" title="函数类型接口"></a>函数类型接口</h3><p>同时，可以定义函数和类，加<code>new</code>修饰的事<strong>类</strong>，不加new的事<strong>函数</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">    (data: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info: Props = <span class="function">(<span class="params"><span class="built_in">number</span>:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>  <span class="comment">//可定义函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PropsClass&#123;</span><br><span class="line">    <span class="keyword">new</span> (name: <span class="built_in">string</span>): A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info1 = <span class="function">(<span class="params">fun: PropsClass, name: <span class="built_in">string</span></span>) =&gt;</span> <span class="keyword">new</span> fun(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = info1(A, <span class="string">&quot;小杜杜&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res.name) <span class="comment">// &quot;小杜杜&quot; </span></span><br></pre></td></tr></table></figure><h2 id="type-和-interface-的区别"><a href="#type-和-interface-的区别" class="headerlink" title="type 和 interface 的区别"></a>type 和 interface 的区别</h2><p>通过上面的学习，我们发现<code>类型别名</code>和<code>接口</code>非常相似，可以说在大多数情况下，<code>type</code>与<code>interface</code>是等价的</p><p>但在一些特定的场景差距还是比较大的，接下来逐个来看看</p><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><ul><li><code>type</code>和<code>interface</code>都可以定义 <strong>对象</strong> 和 <strong>函数</strong></li><li><code>type</code>可以定义其他数据类型，如字符串、数字、元祖、联合类型等，而<code>interface</code>不行</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="built_in">string</span> <span class="comment">// 基本类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = <span class="built_in">string</span> | <span class="built_in">number</span> <span class="comment">// 联合类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C = [<span class="built_in">number</span>, <span class="built_in">string</span>] <span class="comment">// 元祖</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dom = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);  <span class="comment">// dom元素</span></span><br><span class="line"><span class="keyword">type</span> D = <span class="keyword">typeof</span> dom</span><br></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><code>interface</code> 可以扩展 <code>type</code>，<code>type</code> 也可以扩展为 <code>interface</code>，但两者实现扩展的方式不同。</p><ul><li><code>interface</code> 是通过 <code>extends</code> 来实现</li><li><code>type</code> 是通过 <code>&amp;</code> 来实现</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface 扩展 interface</span></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span>  A &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj:B = &#123; <span class="attr">a</span>: <span class="string">`小杜杜`</span>, <span class="attr">b</span>: <span class="number">7</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type 扩展 type</span></span><br><span class="line"><span class="keyword">type</span> C = &#123; <span class="attr">a</span>: <span class="built_in">string</span> &#125;</span><br><span class="line"><span class="keyword">type</span> D = C &amp; &#123; <span class="attr">b</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj1:D = &#123; <span class="attr">a</span>: <span class="string">`小杜杜`</span>, <span class="attr">b</span>: <span class="number">7</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface 扩展 Type</span></span><br><span class="line"><span class="keyword">type</span> E = &#123; <span class="attr">a</span>: <span class="built_in">string</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> F <span class="keyword">extends</span> E &#123; b: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj2:F = &#123; <span class="attr">a</span>: <span class="string">`小杜杜`</span>, <span class="attr">b</span>: <span class="number">7</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type 扩展 interface</span></span><br><span class="line"><span class="keyword">interface</span> G &#123; a: <span class="built_in">string</span> &#125;</span><br><span class="line"><span class="keyword">type</span> H = G &amp; &#123;<span class="attr">b</span>: <span class="built_in">number</span>&#125;</span><br><span class="line"><span class="keyword">const</span> obj3:H = &#123; <span class="attr">a</span>: <span class="string">`小杜杜`</span>, <span class="attr">b</span>: <span class="number">7</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="重复定义"><a href="#重复定义" class="headerlink" title="重复定义"></a>重复定义</h2><p><code>interface</code> 可以多次被定义，并且会进行合并，但<code>type</code>不行</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj:A = &#123; <span class="attr">a</span>: <span class="string">`小杜杜`</span>, <span class="attr">b</span>: <span class="number">7</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = &#123; <span class="attr">a</span>: <span class="built_in">string</span> &#125;</span><br><span class="line"><span class="keyword">type</span> B = &#123; <span class="attr">b</span>: <span class="built_in">number</span> &#125; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h1 id="联合类型-Union-Types"><a href="#联合类型-Union-Types" class="headerlink" title="联合类型(Union Types)"></a>联合类型(Union Types)</h1><p><strong>联合类型(Union Types)</strong>: 表示取值可以为多种类型中的一种,未赋值时联合类型上只能访问两个类型共有的属性和方法，如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setInfo = <span class="function">(<span class="params">name: <span class="built_in">string</span> | <span class="built_in">number</span></span>) =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">setInfo(<span class="string">&#x27;小杜杜&#x27;</span>)</span><br><span class="line">setInfo(<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>从上面看 <code>setInfo</code>接收一个<code>name</code>，而 <code>name</code> 可以接收 <code>string</code>或<code>number</code>类型，那么这个参数便是联合类型</p><h2 id="可辨识联合"><a href="#可辨识联合" class="headerlink" title="可辨识联合"></a>可辨识联合</h2><p><strong>可辨识联合</strong>：包含三个特点，分别是<code>可辨识</code>、<code>联合类型</code>、<code>类型守卫</code>,</p><p>这种类型的本质是：结合<strong>联合类型</strong>和<strong>字面量类型</strong>的一种类型保护方法。</p><p><strong>如果一个类型是多个类型的联合类型，且多个类型含有一个公共属性，那么就可以利用这个公共属性，来创建不同的类型保护区块。</strong></p><p>也就是上面一起结合使用，这里写个小例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="number">2</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> C &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const setInfo = (data: A | B | C) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   return data.type // ok 原因是 A 、B、C 都有 type属性</span></span><br><span class="line"><span class="comment">//   return data.age // error，  原因是没有判断具体是哪个类型，不能确定是A，还是B，或者是C</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setInfo1 = <span class="function">(<span class="params">data: A | B | C</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data.type === <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`我的名字是<span class="subst">$&#123;data.name&#125;</span>`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.type === <span class="number">2</span> )&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`我的年龄是<span class="subst">$&#123;data.age&#125;</span>`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.type === <span class="number">3</span> )&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`我的性别是<span class="subst">$&#123;data.sex&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInfo1(&#123;<span class="attr">type</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;小杜杜&#x27;</span>&#125;) <span class="comment">// &quot;我的名字是小杜杜&quot;</span></span><br><span class="line">setInfo1(&#123;<span class="attr">type</span>: <span class="number">2</span>, <span class="attr">age</span>: <span class="number">7</span>&#125;) <span class="comment">// &quot;我的年龄是7&quot; </span></span><br><span class="line">setInfo1(&#123;<span class="attr">type</span>: <span class="number">3</span>, <span class="attr">sex</span>: <span class="literal">true</span>&#125;) <span class="comment">// &quot;我的性别是true&quot; </span></span><br></pre></td></tr></table></figure><p>定义了 <code>A</code>、<code>B</code>、<code>C</code> 三次接口，但这三个接口都包含<code>type</code>属性，那么<code>type</code>就是<code>可辨识的属性</code>,而其他属性只跟特性的接口相关。</p><p>然后通过可辨识属性<code>type</code>，才能使用其相关的属性</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p><strong>泛型</strong>：Generics，是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性</p><p>也就是说，泛型是<strong>允许同一个函数接受不同类型参数的一种模版</strong>，与<code>any</code>相比，使用泛型来创建可复用的组件要更好，因为<strong>泛型会保留参数类型</strong>（PS：泛型是整个TS的重点，也是难点，请多多注意～）</p><h2 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h2><p>我们先看看一个例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calcArray = (data:<span class="built_in">any</span>):<span class="built_in">any</span>[] =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> list = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        list.push(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(calcArray(<span class="string">&#x27;d&#x27;</span>)) <span class="comment">// [&quot;d&quot;, &quot;d&quot;, &quot;d&quot;]</span></span><br></pre></td></tr></table></figure><p>上述的例子我们发现，在<code>calcArray</code>中传任何类型的参数，返回的数组都是<code>any</code>类型</p><p>由于我们不知道传入的数据是什么，所以返回的数据也为<code>any的数组</code></p><p>但我们现在想要的效果是：<strong>无论我们传什么类型，都能返回对应的类型</strong>，针对这种情况怎么办？所以此时<code>泛型</code>就登场了</p><h2 id="泛型语法"><a href="#泛型语法" class="headerlink" title="泛型语法"></a>泛型语法</h2><p>我们先用泛型对上面的例子进行改造下，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calcArray = &lt;T&gt;(data:T):T[] =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> list:T[] = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        list.push(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res:<span class="built_in">string</span>[] = calcArray&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;d&#x27;</span>) <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> res1:<span class="built_in">number</span>[] = calcArray&lt;<span class="built_in">number</span>&gt;(<span class="number">7</span>) <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Props = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res3: Props[] = calcArray&lt;Props&gt;(&#123;<span class="attr">name</span>: <span class="string">&#x27;小杜杜&#x27;</span>, <span class="attr">age</span>: <span class="number">7</span>&#125;) <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p>经过上面的案例，我们发现传入的<code>字符串</code>、<code>数字</code>、<code>对象</code>，都能返回对应的类型，从而达到我们的目的，接下来我们再看看<code>泛型语法</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span> &lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>) : <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次看到这个<code>&lt;T&gt;</code>我们是不是很懵，实际上这个<code>T</code>就是<strong>传递的类型</strong>,从上述的例子来看，这个<code>&lt;T&gt;</code>就是<code>&lt;string&gt;</code>,要注意一点，这个<code>&lt;string&gt;</code>实际上是可以省略的，因为 TS 具有<strong>类型推论</strong>，可以自己推断类型</p><h2 id="多类型传参"><a href="#多类型传参" class="headerlink" title="多类型传参"></a>多类型传参</h2><p>我们有多个未知的类型占位，我们可以定义任何的字母来表示不同的参数类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calcArray = &lt;T,U&gt;(name:T, age:U): &#123;name:T, age:U&#125; =&gt; &#123;</span><br><span class="line">    const res: &#123;name:T, age:U&#125; = &#123;name, age&#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const res = calcArray&lt;string, number&gt;(&#x27;小杜杜&#x27;, 7)</span><br><span class="line">console.log(res) // &#123;&quot;name&quot;: &quot;小杜杜&quot;, &quot;age&quot;: 7&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>定义接口的时候，我们也可以使用泛型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A&lt;T&gt; &#123;</span><br><span class="line">    <span class="attr">data</span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Info: A&lt;<span class="built_in">string</span>&gt; = &#123;<span class="attr">data</span>: <span class="string">&#x27;1&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Info.data) <span class="comment">// &quot;1&quot;</span></span><br></pre></td></tr></table></figure><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>同样泛型也可以定义类</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clacArray</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> arr: T[] = [];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">value: T</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">    getValue(): T &#123;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="built_in">this</span>.arr[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.arr)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">new</span> clacArray()</span><br><span class="line"></span><br><span class="line">res.add(<span class="number">1</span>)</span><br><span class="line">res.add(<span class="number">2</span>)</span><br><span class="line">res.add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">res.getValue() <span class="comment">//[1, 2, 3] </span></span><br><span class="line"><span class="built_in">console</span>.log(res.getValue) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="泛型类型别名"><a href="#泛型类型别名" class="headerlink" title="泛型类型别名"></a>泛型类型别名</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Info&lt;T&gt; = &#123;</span><br><span class="line">    name?: T</span><br><span class="line">    age?: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res:Info&lt;<span class="built_in">string</span>&gt; = &#123; <span class="attr">name</span>: <span class="string">&#x27;小杜杜&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> res1:Info&lt;<span class="built_in">number</span>&gt; = &#123; <span class="attr">age</span>: <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型默认参数"><a href="#泛型默认参数" class="headerlink" title="泛型默认参数"></a>泛型默认参数</h2><p>所谓默认参数，是指定类型，如默认值一样，从实际值参数中也无法推断出类型时，这个默认类型就会起作用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calcArray = <span class="xml"><span class="tag">&lt;<span class="name">T</span> = <span class="string">string,</span>&gt;</span>(data:T):T[] =&gt; &#123;</span></span><br><span class="line"><span class="xml">    let list:T[] = []</span></span><br><span class="line"><span class="xml">    for(let i = 0; i &lt; 3; i++)&#123;</span></span><br><span class="line"><span class="xml">        list.push(data)</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    return list</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="泛型常用字母"><a href="#泛型常用字母" class="headerlink" title="泛型常用字母"></a>泛型常用字母</h2><p>用常用的字母来表示一些变量的代表：</p><ul><li><strong>T</strong>：代表<strong>Type</strong>，定义泛型时通常用作第一个类型变量名称</li><li><strong>K</strong>：代表<strong>Key</strong>，表示对象中的<strong>键类型</strong>；</li><li><strong>V</strong>：代表<strong>Value</strong>，表示对象中的<strong>值类型</strong>；</li><li><strong>E</strong>：代表<strong>Element</strong>，表示的<strong>元素类型</strong>；</li></ul><h1 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h1><p>在 TS 中有许多关键字和工具类型，在使用上，需要注意<strong>泛型</strong>上的应用，有的时候结合起来可能就有一定的问题</p><p>在此特别需要注意 <code>extends</code>、<code>typeof</code>、<code>Partial</code>、<code>Record</code>、<code>Exclude</code>、<code>Omit</code>这几个工具类型</p><h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p><strong>extends</strong>：检验是否拥有其属性 在这里，举个例子，我们知道<code>字符串</code>和<code>数组</code>拥有<code>length</code>属性，但<code>number</code>没有这个属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calcArray = <span class="xml">&lt;T,&gt;(data:T): number =&gt; &#123;</span></span><br><span class="line"><span class="xml">    return data.length // error </span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>上述的 <code>calcArray</code>的作用只是获取<code>data的数量</code>,但此时在<code>TS</code>中会报错，这是因为<strong>TS不确定传来的属性是否具备length这个属性</strong>，毕竟每个属性都不可能完全相同</p><p>那么这时该怎么解决呢？</p><p>我们已经确定，要拿到传过来数据的 <code>length</code>，也就是说传过来的属性必须具备<code>length</code>这个属性，如果没有，则不让他调用这个方法。</p><p>换句话说，<code>calcArray</code>需要具备检验属性的功能，对于上述例子就是检验是否有<code>length</code>的功能，这是我们就需要<strong>extends</strong>这个属性帮我们去鉴定：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calcArray = <span class="xml"><span class="tag">&lt;<span class="name">T</span> <span class="attr">extends</span> <span class="attr">Props</span>,&gt;</span>(data:T): number =&gt; &#123;</span></span><br><span class="line"><span class="xml">    return data.length // error</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">calcArray(&#x27;12&#x27;) // ok</span></span><br><span class="line"><span class="xml">calcArray([1,3]) //ok</span></span><br><span class="line"><span class="xml">calcArray(2) //error </span></span><br></pre></td></tr></table></figure><p>可以看出<code>calcArray(2)</code>会报错，这是因为<code>number</code>类型并不具备<code>length</code>这个属性</p><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p><strong>typeof关键字</strong>：我们在类型保护的时候讲解了typeof的作用，除此之外，这个关键字还可以实现<strong>推出类型</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> info =&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">sex</span>:<span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Props = <span class="keyword">typeof</span> info</span><br><span class="line"><span class="keyword">type</span> Props =&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    sex:<span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h2><p><strong>keyof关键字</strong>: 可以获取一个对象接口的所有<code>key</code>值,可以检查对象上的键是否存在</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    sex: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PropsKey = keyof Props; <span class="comment">//包含 name， age， sex</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res:PropsKey = <span class="string">&#x27;name&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> res1:PropsKey = <span class="string">&#x27;tel&#x27;</span> <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型中的应用</span></span><br><span class="line"><span class="keyword">const</span> getInfo = <span class="xml">&lt;T, K extends keyof T&gt;(data: T, key: K): T[K] =&gt; &#123;</span></span><br><span class="line"><span class="xml">    return data[key]</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const info = &#123;</span></span><br><span class="line"><span class="xml">    name: &#x27;小杜杜&#x27;,</span></span><br><span class="line"><span class="xml">    age: 7,</span></span><br><span class="line"><span class="xml">    sex: true</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">getInfo(info, &#x27;name&#x27;); //ok</span></span><br><span class="line"><span class="xml">getInfo(info, &#x27;tel&#x27;); //error</span></span><br></pre></td></tr></table></figure><h2 id="索引访问操作符"><a href="#索引访问操作符" class="headerlink" title="索引访问操作符"></a>索引访问操作符</h2><p><strong>索引访问操作符</strong>：通过 <code>[]</code> 操作符可进行索引访问,可以访问其中一个属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    sex: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> age = Props[<span class="string">&#x27;age&#x27;</span>]<span class="comment">//type age = number</span></span><br></pre></td></tr></table></figure><h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2><p><strong>in</strong>：映射类型, 用来映射遍历枚举类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> namme =<span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;sex&#x27;</span></span><br><span class="line"><span class="keyword">type</span> Props = &#123;</span><br><span class="line">    [p <span class="keyword">in</span> name]:<span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Props = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">any</span>;</span><br><span class="line">    age:<span class="built_in">any</span>;</span><br><span class="line">    sex:<span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h2><p><strong>infer</strong>：可以是使用为条件语句，可以用 <code>infer</code> 声明一个类型变量并且对它进行使用。如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Info&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">a</span>: infer U; b: infer U &#125; ? U : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Props = Info&lt;&#123; <span class="attr">a</span>: <span class="built_in">string</span>; b: <span class="built_in">number</span> &#125;&gt;; <span class="comment">// Props类： string | number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Props1 = Info&lt;<span class="built_in">number</span>&gt; <span class="comment">// Props类型： never</span></span><br></pre></td></tr></table></figure><h2 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h2><p><strong>Partial语法</strong>：<code>Partial&lt;T&gt;</code> 作用：将所有属性变为可选的 <strong>?</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info: Props = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小杜杜&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info1: Partial&lt;Props&gt; = &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小杜杜&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码上来看，name 和 age 属于必填，对于 info 来说必须要设置 name 和 age 属性才行，但对于 info1来说，只要是个对象就可以，至于是否有name、 age属性并不重要</p><h2 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h2><p><strong>Required语法</strong>：<code>Required&lt;T&gt;</code> 作用：将所有属性变为必选的，与 <code>Partial</code>相反</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">    sex?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info: Props = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小杜杜&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info1: Required&lt;Props&gt; = &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小杜杜&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h2><p><strong>Readonly语法</strong>：<code>Readonly&lt;T&gt;</code> 作用：将所有属性都加上 readonly 修饰符来实现。也就是说无法修改</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> info: Readonly&lt;Props&gt; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小杜杜&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info.age = <span class="number">1</span> <span class="comment">//error read-only 只读属性</span></span><br></pre></td></tr></table></figure><p>从上述代码上来看, <code>Readonly</code>修饰后，属性无法再次更改，智能使用</p><h2 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h2><p><strong>Record语法</strong>：<code>Record&lt;K extends keyof any, T&gt;</code></p><p>作用：将 <code>K</code> 中所有的属性的值转化为 <code>T</code> 类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> InfoProps = <span class="string">&#x27;JS&#x27;</span> | <span class="string">&#x27;TS&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Info: Record&lt;InfoProps, Props&gt; = &#123;</span><br><span class="line">    <span class="attr">JS</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;小杜杜&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">7</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">TS</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;TypeScript&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">11</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码上来看, <code>InfoProps</code>的属性分别包含<code>Props</code>的属性</p><p>需要注意的一点是：<code>K extends keyof any</code>其类型可以是:<code>string</code>、<code>number</code>、<code>symbol</code></p><h2 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h2><p><strong>Pick语法</strong>：P<code>ick&lt;T, K extends keyof T&gt;</code></p><p>作用：将某个类型中的子属性挑出来，变成包含这个类型部分属性的子类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> nameProps = Pick&lt;Props, <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;age&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info: nameProps = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小杜杜&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码上来看, <code>Props</code>原本属性包括<code>name</code>、<code>age</code>、<code>sex</code>三个属性，通过 <strong>Pick</strong>我们吧<code>name</code>和<code>age</code>挑了出来，所以不需要<code>sex</code>属性</p><h2 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h2><p><strong>Exclude语法</strong>：<code>Exclude&lt;T, U&gt;</code></p><p>作用：将T类型中的U类型剔除。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字类型</span></span><br><span class="line"><span class="keyword">type</span> numProps = Exclude&lt;<span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>, <span class="number">1</span> | <span class="number">2</span>&gt; <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">type</span> numProps1 = Exclude&lt;<span class="number">1</span>, <span class="number">1</span> | <span class="number">2</span>&gt; <span class="comment">// nerver</span></span><br><span class="line"><span class="keyword">type</span> numProps2 = Exclude&lt;<span class="number">1</span>, <span class="number">1</span>&gt; <span class="comment">// nerver</span></span><br><span class="line"><span class="keyword">type</span> numProps3 = Exclude&lt;<span class="number">1</span> | <span class="number">2</span>, <span class="number">7</span>&gt; <span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串类型</span></span><br><span class="line"><span class="keyword">type</span> info = <span class="string">&quot;name&quot;</span> | <span class="string">&quot;age&quot;</span> | <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="keyword">type</span> info1 = <span class="string">&quot;name&quot;</span> | <span class="string">&quot;age&quot;</span> </span><br><span class="line"><span class="keyword">type</span> infoProps = Exclude&lt;info, info1&gt; <span class="comment">//  &quot;sex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型</span></span><br><span class="line"><span class="keyword">type</span> typeProps = Exclude&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | (<span class="function">() =&gt;</span> <span class="built_in">void</span>), <span class="built_in">Function</span>&gt; <span class="comment">// string | number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">type</span> obj = &#123; <span class="attr">name</span>: <span class="number">1</span>, <span class="attr">sex</span>: <span class="literal">true</span> &#125;</span><br><span class="line"><span class="keyword">type</span> obj1 = &#123; <span class="attr">name</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">type</span> objProps = Exclude&lt;obj, obj1&gt; <span class="comment">// nerver</span></span><br></pre></td></tr></table></figure><p>从上述代码上来看,我们比较了下类型上的，当 T 中有 U 就会剔除对应的属性，如果 U 中又的属性 T 中没有，或 T 和 U 刚好一样的情况都会返回 <strong>nerver</strong>，且对象永远返回<code>nerver</code></p><h2 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h2><p><strong>Extra语法</strong>：<code>Extra&lt;T, U&gt;</code></p><p>作用：将T 可分配给的类型中提取 U。与 <strong>Exclude</strong>相反</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> numProps = Extract&lt;<span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>, <span class="number">1</span> | <span class="number">2</span>&gt; <span class="comment">// 1 | 2</span></span><br></pre></td></tr></table></figure><h2 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h2><p><strong>Omit语法</strong>：<code>Omit&lt;T, U&gt;</code></p><p>作用：将已经声明的类型进行属性剔除获得新类型</p><p>与 <strong>Exclude</strong>的区别：Omit 返回的是新的类型，原理上是在 <code>Exclude</code>之上进行的，<code>Exclude</code>是根据自类型返回的</p><h2 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h2><p><strong>NonNullable语法</strong>：<code>NonNullable&lt;T&gt;</code> 作用：从 T 中排除 <code>null</code> 和 <code>undefined</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Props = NonNullable&lt;<span class="built_in">string</span> | <span class="literal">undefined</span> |<span class="literal">null</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h2><p><strong>ReturnType语法</strong>：<code>ReturnType&lt;T&gt;</code></p><p>作用：用于获取 <strong>函数T的返回类型。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Props = ReturnType&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> Props1 = ReturnType&lt;&lt;T <span class="keyword">extends</span> U, U <span class="keyword">extends</span> <span class="built_in">number</span>&gt;<span class="function">() =&gt;</span> T&gt;; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> Props2 = ReturnType&lt;<span class="built_in">any</span>&gt;; <span class="comment">// any</span></span><br><span class="line"><span class="keyword">type</span> Props3 = ReturnType&lt;<span class="built_in">never</span>&gt;; <span class="comment">// any</span></span><br></pre></td></tr></table></figure><p>从上述代码上来看， ReturnType可以接受 any 和 never 类型，原因是这两个类型属于顶级类型，包含函数</p><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><p><strong>Parameters</strong>：<code>Parameters&lt;T&gt;</code> 作用：用于获取 <strong>获取函数类型的参数类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Props = Parameters&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> Props1 = Parameters&lt;<span class="function">(<span class="params">data: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt; <span class="comment">// [string]</span></span><br><span class="line"><span class="keyword">type</span> Props2 = Parameters&lt;<span class="built_in">any</span>&gt;; <span class="comment">// unknown[]</span></span><br><span class="line"><span class="keyword">type</span> Props3 = Parameters&lt;<span class="built_in">never</span>&gt;; <span class="comment">// never</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章-快速入门&quot;&gt;&lt;a href=&quot;#第一章-快速入门&quot; class=&quot;headerlink&quot; title=&quot;第一章 快速入门&quot;&gt;&lt;/a&gt;第一章 快速入门&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://typescript.bootcss.com/tutori</summary>
      
    
    
    
    <category term="TypeScript" scheme="https://lesliewaong.top/categories/TypeScript/"/>
    
    
    <category term="TS" scheme="https://lesliewaong.top/tags/TS/"/>
    
  </entry>
  
  <entry>
    <title>常用终端命令</title>
    <link href="https://lesliewaong.top/posts/c36b5788.html"/>
    <id>https://lesliewaong.top/posts/c36b5788.html</id>
    <published>2022-06-08T04:03:32.000Z</published>
    <updated>2022-06-22T15:19:54.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux终端命令"><a href="#Linux终端命令" class="headerlink" title="Linux终端命令"></a>Linux终端命令</h1><p><a href="https://link.zhihu.com/?target=https://explainshell.com/">explainshell</a>,将自己不懂的命令行语句输入进去查询，即可查到对应释义</p><h2 id="系统指令"><a href="#系统指令" class="headerlink" title="系统指令"></a>系统指令</h2><table><thead><tr><th>指令</th><th>解释</th></tr></thead><tbody><tr><td>whoami</td><td>查询系统当前的用户名</td></tr><tr><td>uname -a</td><td>查询主机名、系统内核/CPU等信息</td></tr><tr><td>uptime</td><td>查询系统运行时间，用户数、负载</td></tr><tr><td>env</td><td>查询系统的环境变量</td></tr><tr><td>iostat</td><td>查询IO速率/CPU使用情况</td></tr><tr><td>df -h</td><td>查询磁盘使用信息</td></tr><tr><td>du -sh <dir-name></td><td>查询指定目录大小</td></tr><tr><td>last</td><td>查询用户登录记录</td></tr></tbody></table><h2 id="导航移动指令"><a href="#导航移动指令" class="headerlink" title="导航移动指令"></a>导航移动指令</h2><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>大家都知道，在我们平时使用计算机时要找到需要的文件就必须知道文件的位置，而表示文件的位置的方式就是路径，</p><p>例如只要看到这个路径：<code>c:/website/img/photo.jpg</code></p><p>我们就知道photo.jpg文件是在c盘的website目录下的img子目录中。</p><p>这样完整的描述文件位置的路径就是<strong>绝对路径</strong>。</p><p>我们不需要知道其他任何信息就可以根据绝对路径判断出文件的位置。(也可以认为以<code>/</code>开头的都为绝对路径)</p><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>所谓相对路径，顾名思义就是自己相对与目标位置。</p><p>不论将这些文件放到哪里，只要他们的相对关系没有变，就不会出错。  </p><p>另外我们使用<code>../</code>来表示上一级目录，<code>../../</code>表示上上级的目录，以此类推。(也可认为<strong>不是以</strong><code>/</code>开头的都是相对路径)</p><table><thead><tr><th>特殊符号</th><th>作 用</th></tr></thead><tbody><tr><td><code>~</code></td><td>代表当前登录用户的主目录</td></tr><tr><td><code>~用户名</code></td><td>表示切换至指定用户的主目录</td></tr><tr><td><code>-</code></td><td>代表上次所在目录</td></tr><tr><td><code>.</code></td><td>代表当前目录</td></tr><tr><td><code>..</code></td><td>代表上级目录</td></tr></tbody></table><table><thead><tr><th>指令</th><th>解释</th></tr></thead><tbody><tr><td><code>cd &lt;dir&gt;</code> 或者 <code>cd ~</code> 或者 <code>cd ..</code> 或者 <code>cd -</code>或者 <code>cd /</code></td><td>移动到<strong>指定目录</strong> / 移动到<strong>当前登录用户的主目录</strong> / 移动到<strong>上一级目录</strong> / 返回<strong>上一步操作的目录</strong>/ 移动到<strong>根目录</strong></td></tr><tr><td><code>pwd</code></td><td>“print working directory” 打印当前目录的绝对路径</td></tr><tr><td><code>clear</code></td><td>清除终端打印信息</td></tr><tr><td><code>ls</code></td><td>打印当前目录下的文件和目录，加上<code>-a</code>查看隐藏文件，<code>/</code> 代表文件系统的<strong>根目录</strong>，<code>-S</code>从大到小排序，<code>-r</code>反向排序，<code>-l</code>更详细信息</td></tr><tr><td><code>rm -rf</code></td><td>删除文件/目录，-r是递归删除，-f是强行删除</td></tr><tr><td><code>cp &lt;source&gt; &lt;dest&gt;</code></td><td>复制文件，<code>.</code>代表当前目录，-r是递归复制</td></tr><tr><td><code>mv &lt;original&gt; &lt;new&gt;</code></td><td>移动文件，<code>.</code>代表当前目录，-r是递归复制，-a复制目录</td></tr><tr><td>wc</td><td>“word count”，-l数行数，-w数字数</td></tr><tr><td><code>echo &quot;some string&quot;</code></td><td>打印输入的字符串</td></tr><tr><td>ls | wc -l</td><td>| 将前一命令的输出转为后一命令的输入 左边的作用是”数当前目录下的文件/目录数”</td></tr><tr><td>ls / &gt; directory.txt</td><td>&gt; 将命令输出导出为文件</td></tr><tr><td>\</td><td>输入长命令时换行</td></tr><tr><td><code>mkdir 目录名</code></td><td>建立新目录(也可理解为<strong>创建文件夹</strong>)</td></tr></tbody></table><h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><table><thead><tr><th>指令</th><th>解释</th></tr></thead><tbody><tr><td>ln -s <file> <link></td><td>创建软连接（快捷方式，源文件被删除，soft link就没用了）</td></tr><tr><td>ln <file> <link></td><td>创建硬连接（独立文件，源文件被删除，hard link仍然存在；源文件修改，hard link同步修改）</td></tr><tr><td>tar -xzvf files.tar.gz tar -xjvf files.tar.bz2tar -czvf <compress file> <originals></td><td>解压文件gzip 解压文件bzip2压缩文件gzip</td></tr><tr><td><code>cat &lt;file&gt;</code></td><td>查看文件内容，-n标记行数</td></tr><tr><td>more <file></td><td>查看长文件内容</td></tr><tr><td>head -x <file></td><td>查看文件前x行</td></tr><tr><td>tail -x <file></td><td>查看文件后x行</td></tr><tr><td>grep <keyword> <file></td><td>文件中查找关键词，并显示；keyword部分可以是regex</td></tr></tbody></table><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><table><thead><tr><th>指令</th><th>解释</th></tr></thead><tbody><tr><td><code>vim</code></td><td>打开vim编辑器</td></tr><tr><td><code>vim &lt;file&gt;</code></td><td>用vim打开文件；如果不存在，就新建</td></tr><tr><td><code>:q</code></td><td>退出</td></tr><tr><td><code>i</code></td><td>进入输入模式 (insert mode)</td></tr><tr><td><code>&lt;esc&gt;</code></td><td>返回默认模式，即命令模式 (command mode)</td></tr><tr><td><code>:w</code></td><td>保存文件</td></tr><tr><td><code>:wq or :x</code></td><td>保存并退出</td></tr><tr><td><code>:q!</code></td><td>退出不保存</td></tr></tbody></table><h2 id="权限与配置"><a href="#权限与配置" class="headerlink" title="权限与配置"></a>权限与配置</h2><table><thead><tr><th>指令</th><th>解释</th></tr></thead><tbody><tr><td>su -</td><td>获取超级用户权限 (prompt changes from $ to #)</td></tr><tr><td><code>sudo &lt;command&gt;</code></td><td>以超级用户的权限执行命令（权限不够的时候使用）</td></tr><tr><td>env, printenv</td><td>打印系统环境变量</td></tr><tr><td>export ENV_NAME=”new” echo $ENV_NAME</td><td>创建新的环境变量 确认变量的更新</td></tr><tr><td>history</td><td>查询终端命令的历史记录</td></tr><tr><td>ls -l</td><td>查看文件的所有者，组和其他权限的信息</td></tr><tr><td>chmod xxx <file></td><td>修改文件的访问权限；三个数字代表所有者，用户组，其他；每个数字都是3个bit的二进制；read(4), write(2), execute(1)</td></tr><tr><td>echo $PATH</td><td>终端命令存在的目录存在这个环境变量下</td></tr><tr><td>which <command></td><td>查看终端命令的执行路径</td></tr></tbody></table><h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><table><thead><tr><th>指令</th><th>解释</th></tr></thead><tbody><tr><td>ps</td><td>“Process Status” 打印当前终端的进程</td></tr><tr><td>ps aux (for OSX)</td><td>-a 显示所有用户的进程，-u 显示进程的所有者/用户，-x 显示和当前终端无关的进程</td></tr><tr><td>ps aux | grep firefox</td><td>查询和firefox相关的进程</td></tr><tr><td><code>kill &lt;pid&gt;</code></td><td>根据PID杀死进程，-9 硬删除</td></tr><tr><td>kill -l</td><td>查看所有的Linux信号名</td></tr><tr><td>top</td><td>显示所有活跃的进程，以及它们的CPU、内存使用情况</td></tr></tbody></table><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><table><thead><tr><th>指令</th><th>解释</th></tr></thead><tbody><tr><td><code>ping &lt;URL&gt;</code></td><td>查询网络服务的连接情况、传输速度</td></tr><tr><td>host <URL></td><td>查询网络服务的IP地址</td></tr><tr><td>dig <URL></td><td>查询DNS记录</td></tr><tr><td>traceroute <hostname></td><td>追踪从主机到host的网络传输路径</td></tr><tr><td>ssh <hostname></td><td>远程登录服务器</td></tr><tr><td>netstat</td><td>查看网络端口，TCP/UDP状态</td></tr><tr><td>ifconfig</td><td>网络接口属性</td></tr><tr><td>route</td><td>查看路由表</td></tr><tr><td>nslookup <URL></td><td>查询DNS记录相关的IP地址</td></tr></tbody></table><h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>vim是Linux环境下一款功能强大、高度可定制的文本编辑工具，类似于Windows下面的source insight、sublime、notepad。</p><p>VI是visual interface的缩写，即可视化接口。</p><p>vim 即 vi IMproved，在 vi 的基础上做了很多改进，如：增加了多级撤销、多窗口操作、崩溃后也可以恢复、增加了稳定性、关键字自动补全、上下文自动补全等功能。</p><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>vim一般有6种工作模式。</p><ul><li><strong>普通模式</strong>：使用<code>vim</code>打开一个文件时默认模式，也叫命令模式，允许用户通过各种命令浏览代码、滚屏等操作。</li><li><strong>插入模式</strong>：也可以叫做编辑模式，在普通模式下敲击 <code>i</code> 、a 或 o 就进入插入模式，允许用户通过键盘输入、编辑。</li><li><strong>命令行模式</strong>：在普通模式下，先输入冒号<code>:</code>，接着输入命令，就可以通过配置命令对vim进行配置了，如改变颜色主题、显示行号等，这些配置命令也可以保存到/etc/vim/vimrc配置文件中，每次打开默认配置执行。</li><li><strong>可视化模式</strong>：在普通模式下敲击前盘上的 <code>v</code> 键，就进入可视化模式，然后移动光标就可以选中一块文本，常用来完成文本的复制、粘贴、删除等操作。</li><li><strong>替换模式</strong>：如果我们想修改某个字符，不需要先进入插入模式，删除，然后再输入新的字符，直接在普通模式下，敲击<code>R</code>键就可以直接替换。</li><li>EX模式：类似于命令行模式，可以一次运行多个命令</li></ul><p>vim的各种工作模式可以通过不同的键进行切换，用户统一使用<code>ESC</code>键返回到普通模式。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="光标移动命令"><a href="#光标移动命令" class="headerlink" title="光标移动命令"></a>光标移动命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">单个字符移动：</span><br><span class="line">h  向左移动</span><br><span class="line">l  向右移动</span><br><span class="line">j  向下移动</span><br><span class="line">k  向上移动</span><br><span class="line">xh 向左移动x个字符距离</span><br><span class="line"></span><br><span class="line">单词移动：</span><br><span class="line">w  将光标移动到下一个单词的开头</span><br><span class="line">b  将光标移动到前一个单词的开头</span><br><span class="line">e  将光标移动到下一个单词的词末</span><br><span class="line">E  移动到单词的结尾(忽略标点符号)</span><br><span class="line">ge 将光标移动到上一个单词的词末</span><br><span class="line">2w 指定移动的次数</span><br><span class="line"></span><br><span class="line">行移动：</span><br><span class="line"><span class="meta">$</span><span class="bash"> 将光标移动到当前行的行尾</span></span><br><span class="line">0 将光标移动到当前行的行首</span><br><span class="line">^ 将光标移动到当前行的第一个非空字符（行首和当前行非空字符不是一个位置）</span><br><span class="line">2| 移到当前行的第2列</span><br><span class="line">fx 将光标移动到当前行的第一个字符x上</span><br><span class="line">3fx 将光标移动到航前行的第3个字符x上</span><br><span class="line">tx 将光标移动到目标字符x的前一个字符上</span><br><span class="line">fx和tx可以通过;和,进行重复移动，一个是正向重复，一个是反向重复</span><br><span class="line"><span class="meta">%</span><span class="bash"> 用于符号间的移动，它会在一对()、[]、&#123;&#125;之间跳跃</span></span><br><span class="line"></span><br><span class="line">文本块移动：</span><br><span class="line">(  移到当前句子的开头</span><br><span class="line">)  移到下一个句子的开头</span><br><span class="line">&#123;  移到当前一段的开头</span><br><span class="line">&#125;  移到下一段的开头</span><br><span class="line">[[ 移到当前这一节的开头</span><br><span class="line">]] 移到下一节的开头</span><br><span class="line"></span><br><span class="line">在屏幕中移动</span><br><span class="line">xG 跳转到指定的第x行，G移动到文件按末尾，``（2次单引号)返回到跳转前的位置</span><br><span class="line">gg 移动到文件开头</span><br><span class="line"><span class="meta">x%</span><span class="bash"> 移动到文件中间，就使用50%</span></span><br><span class="line">H  移动到home</span><br><span class="line">M  移动到屏幕中间</span><br><span class="line">L 移动到一屏末尾</span><br><span class="line">ctrl+G 查看当前的位置状态</span><br></pre></td></tr></table></figure><h3 id="滚屏与跳转"><a href="#滚屏与跳转" class="headerlink" title="滚屏与跳转"></a>滚屏与跳转</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">半屏滚动 ctrl+u/ctrl+d</span><br><span class="line">全屏滚动 ctrl+f/ctrl+b</span><br><span class="line"></span><br><span class="line">定位光标的位置</span><br><span class="line">zz 将光标置于屏幕的中间</span><br><span class="line">zt 将光标移动到屏幕的顶部</span><br><span class="line">zb 将光标移动到屏幕的底部</span><br><span class="line"></span><br><span class="line">设置跳转标记</span><br><span class="line">mx,my,mz设置三个位置</span><br><span class="line">`x,`y,`z跳转到设置</span><br></pre></td></tr></table></figure><h3 id="文本插入操作"><a href="#文本插入操作" class="headerlink" title="文本插入操作"></a>文本插入操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i 在当前光标的前面插入字符</span><br><span class="line">a 在当前光标的后面追加字符</span><br><span class="line">o 在当前光标的下一行行首插入字符</span><br><span class="line">I 在一行的开头添加文本</span><br><span class="line">A 在一行的结尾处添加文本</span><br><span class="line">O 在光标当前行的上一行插入文本</span><br><span class="line">s 删除当前光标处的字符并进入到插入模式</span><br><span class="line">S 删除光标所在处的行，并进入到插入模式</span><br><span class="line">u 撤销修改</span><br></pre></td></tr></table></figure><h3 id="文本删除操作"><a href="#文本删除操作" class="headerlink" title="文本删除操作"></a>文本删除操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">字符删除</span><br><span class="line">x 删除当前光标所在处的字符</span><br><span class="line">X 删除当前光标左边的字符</span><br><span class="line"></span><br><span class="line">单词删除</span><br><span class="line">dw 删除一个单词(从光标处到空格)</span><br><span class="line">daw 无论光标在什么位置，删除光标所在的整个单词(包括空白字符)</span><br><span class="line">diw 删除整个单词文本，但是保留空格字符不删除</span><br><span class="line">d2w 删除从当前光标开始处的2个单词</span><br><span class="line"><span class="meta">d$</span><span class="bash"> 删除从光标到一行末尾的整个文本</span></span><br><span class="line">d0 删除从光标到一行开头的所有单词</span><br><span class="line">dl 删除当前光标处的字符=x</span><br><span class="line">dh 删除当前光标左边的字符=X</span><br><span class="line"></span><br><span class="line">行删除</span><br><span class="line">dd 删除当前光标处的一整行=D</span><br><span class="line">5dd 删除从光标开始处的5行代码</span><br><span class="line">dgg 删除从光标到文本开头</span><br><span class="line">dG 删除从光标到文本结尾</span><br><span class="line"></span><br><span class="line">行合并</span><br><span class="line">J 删除一个分行符，将当前行与下一行合并</span><br></pre></td></tr></table></figure><h3 id="文本复制、剪切与粘贴"><a href="#文本复制、剪切与粘贴" class="headerlink" title="文本复制、剪切与粘贴"></a>文本复制、剪切与粘贴</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">y 复制，p 粘贴</span><br><span class="line">yw 复制一个单词</span><br><span class="line">y2w 复制2个单词</span><br><span class="line"><span class="meta">y$</span><span class="bash"> 复制从当前光标到行结尾的所有单词</span></span><br><span class="line">y0 复制从当前光标到行首的所有单词</span><br><span class="line">yy 复制一整行</span><br><span class="line">2yy 复制从当前光标所在行开始的2行</span><br><span class="line"></span><br><span class="line">复制文本块</span><br><span class="line">    1.首先进入visual模式：v</span><br><span class="line">    2.移动光标选择文本</span><br><span class="line">    3.复制与粘贴的操作</span><br></pre></td></tr></table></figure><h3 id="文本的修改与替换"><a href="#文本的修改与替换" class="headerlink" title="文本的修改与替换"></a>文本的修改与替换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cw 删除从光标处到单词结尾的文本并进入到插入模式</span><br><span class="line">cb 删除从光标处到单词开头的文本并进入到插入模式</span><br><span class="line">cc 删除一整行并进入到插入模式</span><br><span class="line">~ 修改光标下字符的大小写</span><br><span class="line">r 替换当前光标下的字符</span><br><span class="line">R 进入到替换模式</span><br><span class="line">xp 交换光标和下一个字符</span><br></pre></td></tr></table></figure><h3 id="文本的查找与替换"><a href="#文本的查找与替换" class="headerlink" title="文本的查找与替换"></a>文本的查找与替换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/string   正向查找</span><br><span class="line">?string   反向查找</span><br><span class="line"></span><br><span class="line">设置高亮显示</span><br><span class="line">    :set hls</span><br><span class="line">    *按键将当前光标处的单词高亮显示，使用n浏览下一个查找高亮的结果</span><br><span class="line">:s/old/new   将当前行的第一个字符串old替换为new</span><br><span class="line">:s/old/new/g   将当前行的所有字符串old替换为new</span><br><span class="line">:90s/old/new/g  将指定行的所有字符串old替换为new</span><br><span class="line">:90,93s/old/new/g  将指定范围的行的所有字符串old替换为new</span><br><span class="line">:%s/old/new/g   将文本中所有的字符串old替换为new</span><br><span class="line">:%s/old/new/gc  依次替换每个字符串关键字</span><br><span class="line">:%s/^struct/int/g   将所有以struct开头的字符串替换为int</span><br></pre></td></tr></table></figure><h3 id="撤销修改、重做与保存"><a href="#撤销修改、重做与保存" class="headerlink" title="撤销修改、重做与保存"></a>撤销修改、重做与保存</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">u 撤销上一步的操作。</span><br><span class="line">Ctrl+r 将原来的插销重做一遍</span><br><span class="line">:U  恢复一整行原来的面貌（文件打开时的文本状态）</span><br><span class="line">:q  若文件没有修改，直接退出</span><br><span class="line">:q!  文件已经被修改，放弃修改退出</span><br><span class="line">:wq  文件已经被修改，保存修改并退出</span><br><span class="line">:e!  放弃修改，重新回到文件打开时的状态</span><br></pre></td></tr></table></figure><h3 id="编辑多个文件"><a href="#编辑多个文件" class="headerlink" title="编辑多个文件"></a>编辑多个文件</h3><p><strong>文件和缓冲区的区别</strong></p><p>文件是保存在磁盘上的，而打开的文件的文件是在内存中，在内存中有一个缓冲区，用来存放打开的文件。</p><p>vim每次打开文件时都会创建一个缓冲区，vim支持打开多个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:buffers   查看缓冲区列表==ls</span><br><span class="line">:buffer N  根据缓冲区列表的编号跳转到指定缓冲区</span><br><span class="line">:bnext/bprev  遍历缓冲区列表</span><br><span class="line">:bfirst/blast  分别调到缓冲区列表的开头和结尾</span><br><span class="line">:write   将缓冲区的修改保存到磁盘上</span><br><span class="line">:edit! e!  放弃缓冲区的修改，恢复到文件打开时的状态</span><br><span class="line">:edit file  编辑另一个文件</span><br><span class="line">:wnext   保存当前缓冲区的修改并跳转到缓冲区列表中的下一个文件</span><br><span class="line">:set autowrite</span><br></pre></td></tr></table></figure><h3 id="标签页与折叠栏"><a href="#标签页与折叠栏" class="headerlink" title="标签页与折叠栏"></a>标签页与折叠栏</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">标签页的新建 tabedit file/tab split</span><br><span class="line">标签页的切换 tabn/tabp</span><br><span class="line">按键：gt/gT</span><br><span class="line">标签页的关闭</span><br><span class="line">    tabclose </span><br><span class="line">关闭当前的标签页 tabonly</span><br><span class="line">创建一个折叠</span><br><span class="line">    zf200G 将光标和200行之间的代码折叠起来</span><br><span class="line">折叠的打开与关闭</span><br><span class="line">    za 打开和关闭折叠</span><br><span class="line">    zr/zm 一层一层地打开和关闭折叠</span><br><span class="line">    zR/zM 分别打开和关闭所有的折叠</span><br><span class="line">折叠键的光标移动</span><br><span class="line">    zj 跳转到下一个折叠处</span><br><span class="line">    zk 跳转到上一个折叠处</span><br><span class="line">删除折叠</span><br><span class="line">    zd 删除光标下的折叠</span><br><span class="line">    zD 删除光标下的折叠以及嵌套的折叠</span><br><span class="line">    zE 删除所有的折叠标签</span><br><span class="line">    创建的折叠当退出vim之后就失效了。</span><br></pre></td></tr></table></figure><h3 id="多窗口操作"><a href="#多窗口操作" class="headerlink" title="多窗口操作"></a>多窗口操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">分割窗口</span><br><span class="line">    split/vsplit filename</span><br><span class="line">窗口间跳转</span><br><span class="line">    ctrl+w hjkl</span><br><span class="line">    ctrl+w w</span><br><span class="line">移动窗口</span><br><span class="line">    ctrl+w HJKL</span><br><span class="line">调整窗口尺寸</span><br><span class="line">    ctrl+w +/-  调整窗口的高度</span><br><span class="line">    ctrl+w &lt;/&gt;  调整窗口的宽度</span><br><span class="line">    ctrl+w = 所有的窗口设置相同的尺寸</span><br><span class="line">    :resize n将当前窗口尺寸调整为N行</span><br><span class="line">关闭窗口</span><br><span class="line">    close 关闭一个窗口</span><br><span class="line">    qall 退出所有窗口</span><br><span class="line">    qall!  放弃修改，退出所有窗口</span><br><span class="line">    wqall 保存并退出所有窗口</span><br><span class="line">    wall 保存所有窗口</span><br></pre></td></tr></table></figure><p>附：vim键盘命令图</p><p><a href="https://imgtu.com/i/jSnRW6"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/21/jSnRW6.jpg" alt="jSnRW6.jpg"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux终端命令&quot;&gt;&lt;a href=&quot;#Linux终端命令&quot; class=&quot;headerlink&quot; title=&quot;Linux终端命令&quot;&gt;&lt;/a&gt;Linux终端命令&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=ht</summary>
      
    
    
    
    <category term="终端命令" scheme="https://lesliewaong.top/categories/%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="vim" scheme="https://lesliewaong.top/tags/vim/"/>
    
    <category term="Linux" scheme="https://lesliewaong.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>VSCode</title>
    <link href="https://lesliewaong.top/posts/e2c5bfe8.html"/>
    <id>https://lesliewaong.top/posts/e2c5bfe8.html</id>
    <published>2022-06-07T04:02:32.000Z</published>
    <updated>2022-07-17T08:40:25.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><table><thead><tr><th>解释</th><th>快捷键（mac）</th><th>快捷键（win）</th></tr></thead><tbody><tr><td>注释</td><td>command+/</td><td>Ctrl+/</td></tr><tr><td>快速生成网页</td><td>html:5</td><td>html:5</td></tr><tr><td>代码格式化</td><td>Shift+Alt+F</td><td>Shift+Alt+F</td></tr><tr><td>向上或向下复制一行</td><td>Shift+option+Up 或 Shift+option+Down</td><td>Shift+Alt+Up 或 Shift+Alt+Down</td></tr><tr><td>在当前行下方插入一行</td><td>command+Enter</td><td>Ctrl+Enter</td></tr><tr><td>在当前行上方插入一行</td><td>command+Shift+Enter</td><td>Ctrl+Shift+Enter</td></tr><tr><td>万能键：打开命令面板。在打开的输入框内，可以输入任何命令</td><td>command+Shift+P</td><td>F1 或 Ctrl+Shift+P</td></tr><tr><td>查找</td><td>command+F</td><td>Ctrl+F</td></tr><tr><td>查找替换</td><td>Command + Option + F</td><td>Ctrl+H</td></tr><tr><td>删除整行</td><td>Command +Shift+K</td><td>Ctrl+Shift+K</td></tr></tbody></table><p>键盘快捷方式查看与修改 <code>ctrl+K ctrl+S</code></p><p><a href="https://imgtu.com/i/j5Z6PJ"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/16/j5Z6PJ.png" alt="j5Z6PJ.png"></a></p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="Live-Sever"><a href="#Live-Sever" class="headerlink" title="Live Sever"></a>Live Sever</h2><p>为静态和动态页面启动具有实时重载特性的本地开发服务器。</p><p>补充：手机和电脑同一网络下，通过<strong>IP地址（win：ipconfig/mac：ifconfig或点击网络查看）</strong>可以实现手机端访问 。</p><h2 id="Live-Preview"><a href="#Live-Preview" class="headerlink" title="Live Preview"></a>Live Preview</h2><p><a href="https://imgtu.com/i/j5ZWKx"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/16/j5ZWKx.png" alt="j5ZWKx.png"></a></p><h2 id="open-in-browser"><a href="#open-in-browser" class="headerlink" title="open in browser"></a>open in browser</h2><h2 id="Prettier-Code-formatter"><a href="#Prettier-Code-formatter" class="headerlink" title="Prettier - Code formatter"></a>Prettier - Code formatter</h2><p>代码格式化</p><p><em>JavaScript · TypeScript · Flow · JSX · JSON</em><br><em>CSS · SCSS · Less</em><br><em>HTML · Vue · Angular</em> <em>HANDLEBARS · Ember · Glimmer</em><br><em>GraphQL · Markdown · YAML</em></p><p>补充：html格式化有些问题。</p><h2 id="Markdown-Preview-Enhanced"><a href="#Markdown-Preview-Enhanced" class="headerlink" title="Markdown Preview Enhanced"></a>Markdown Preview Enhanced</h2><p><a href="https://imgtu.com/i/j5Z5VO"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/16/j5Z5VO.png" alt="j5Z5VO.png"></a></p><h3 id="Code-Runner代码运行器"><a href="#Code-Runner代码运行器" class="headerlink" title="Code Runner代码运行器"></a>Code Runner代码运行器</h3><p>一键运行多种语言运行代码片段或代码文件: c，c + + ，Java，JavaScript，PHP，Python，Perl，Perl 6，Ruby，Go，Lua，Groovy，PowerShell，BAT/CMD，BASH/SH，f # Script，f # (。NET 核心) ，c # 脚本，多到你想不到。</p><p>快捷键 win:<code>Ctrl+Alt+N</code>mac:<code>Control+Alt+N</code></p><h2 id="GitLens"><a href="#GitLens" class="headerlink" title="GitLens"></a>GitLens</h2><p>功能更加强大，无缝导航和浏览 Git 存储库。</p><h2 id="JSON-to-TS"><a href="#JSON-to-TS" class="headerlink" title="JSON to TS"></a>JSON to TS</h2><p>json转为TS申明</p><h3 id="从剪贴板转换"><a href="#从剪贴板转换" class="headerlink" title="从剪贴板转换"></a>从剪贴板转换</h3><p>快捷键：win:<code>Shift + Ctrl + Alt + V</code> mac:<code>shift+control+option+v</code></p><p>命令面板：clipboard</p><h3 id="从选择转换"><a href="#从选择转换" class="headerlink" title="从选择转换"></a>从选择转换</h3><p>快捷键：win:<code>Shift + Ctrl + Alt + S</code>    mac:<code>shift+control+option+s</code></p><h2 id="JSON5-syntax"><a href="#JSON5-syntax" class="headerlink" title="JSON5 syntax"></a>JSON5 syntax</h2><h2 id="ES7-React-Redux-React-Native-snippets"><a href="#ES7-React-Redux-React-Native-snippets" class="headerlink" title="ES7+ React/Redux/React-Native snippets"></a>ES7+ React/Redux/React-Native snippets</h2><h3 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h3><table><thead><tr><th>Prefix</th><th>Method</th></tr></thead><tbody><tr><td><code>imp→</code></td><td><code>import moduleName from &#39;module&#39;</code></td></tr><tr><td><code>imn→</code></td><td><code>import &#39;module&#39;</code></td></tr><tr><td><code>imd→</code></td><td><code>import &#123; destructuredModule &#125; from &#39;module&#39;</code></td></tr><tr><td><code>ime→</code></td><td><code>import * as alias from &#39;module&#39;</code></td></tr><tr><td><code>ima→</code></td><td><code>import &#123; originalName as aliasName&#125; from &#39;module&#39;</code></td></tr><tr><td><code>exp→</code></td><td><code>export default moduleName</code></td></tr><tr><td><code>exd→</code></td><td><code>export &#123; destructuredModule &#125; from &#39;module&#39;</code></td></tr><tr><td><code>exa→</code></td><td><code>export &#123; originalName as aliasName&#125; from &#39;module&#39;</code></td></tr><tr><td><code>enf→</code></td><td><code>export const functionName = (params) =&gt; &#123; &#125;</code></td></tr><tr><td><code>ednf→</code></td><td><code>export default function functionName(params) &#123; &#125;</code></td></tr><tr><td><code>fre→</code></td><td><code>arrayName.forEach(element =&gt; &#123; &#125;</code></td></tr><tr><td><code>fof→</code></td><td><code>for(let itemName of objectName &#123; &#125;</code></td></tr><tr><td><code>fin→</code></td><td><code>for(let itemName in objectName &#123; &#125;</code></td></tr><tr><td><code>nfn→</code></td><td><code>const functionName = (params) =&gt; &#123; &#125;</code></td></tr><tr><td><code>sti→</code></td><td><code>setInterval(() =&gt; &#123; &#125;, intervalTime</code></td></tr><tr><td><code>sto→</code></td><td><code>setTimeout(() =&gt; &#123; &#125;, delayTime</code></td></tr><tr><td><code>prom→</code></td><td><code>return new Promise((resolve, reject) =&gt; &#123; &#125;</code></td></tr><tr><td><code>cmmb→</code></td><td><code>comment block</code></td></tr></tbody></table><h3 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h3><table><thead><tr><th>Prefix</th><th>Method</th></tr></thead><tbody><tr><td><code>clg→</code></td><td><code>console.log(object)</code></td></tr><tr><td><code>clo→</code></td><td><code>console.log(&#39;object&#39;, object)</code></td></tr><tr><td><code>ctm→</code></td><td><code>console.time(&#39;timeId&#39;)</code></td></tr><tr><td><code>cte→</code></td><td><code>console.timeEnd(&#39;timeId&#39;)</code></td></tr></tbody></table><h3 id="React-Components"><a href="#React-Components" class="headerlink" title="React Components"></a>React Components</h3><h4 id="rcc"><a href="#rcc" class="headerlink" title="rcc"></a><code>rcc</code></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">FileName</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>$2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rafce"><a href="#rafce" class="headerlink" title="rafce"></a><code>rafce</code></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> $<span class="number">1</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>$0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> $<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><h4 id="cmmb"><a href="#cmmb" class="headerlink" title="cmmb"></a><code>cmmb</code></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">|--------------------------------------------------</span></span><br><span class="line"><span class="comment">| $1</span></span><br><span class="line"><span class="comment">|--------------------------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Vue-3-Snippets"><a href="#Vue-3-Snippets" class="headerlink" title="Vue 3 Snippets"></a>Vue 3 Snippets</h2><h2 id="Chinese-Simplified-简体中文"><a href="#Chinese-Simplified-简体中文" class="headerlink" title="Chinese (Simplified) (简体中文)"></a>Chinese (Simplified) (简体中文)</h2><h2 id="koroFileHeader"><a href="#koroFileHeader" class="headerlink" title="koroFileHeader"></a>koroFileHeader</h2><p>fileheader    <code>win</code>：ctrl+win+i   <code>mac</code>:control+command+i</p><p>cursortip     <code>win</code> ：ctrl+win+t    <code>mac</code>:control+command+t</p><h2 id="Import-Cost"><a href="#Import-Cost" class="headerlink" title="Import Cost"></a>Import Cost</h2><p>依赖包大小提示</p><h2 id="REST-Client"><a href="#REST-Client" class="headerlink" title="REST Client"></a>REST Client</h2><p><a href="https://imgtu.com/i/j5y0aV"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/07/16/j5y0aV.png" alt="j5y0aV.png"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键&quot;&gt;&lt;/a&gt;快捷键&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;th&gt;快捷键（mac）&lt;/th&gt;
&lt;th&gt;快捷键（win）&lt;/th&gt;
</summary>
      
    
    
    
    <category term="工具" scheme="https://lesliewaong.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="VSCode" scheme="https://lesliewaong.top/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://lesliewaong.top/posts/69c3279c.html"/>
    <id>https://lesliewaong.top/posts/69c3279c.html</id>
    <published>2022-06-07T04:02:32.000Z</published>
    <updated>2022-07-09T11:29:25.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h1><h2 id="Git-amp-GitHub"><a href="#Git-amp-GitHub" class="headerlink" title="Git&amp;GitHub"></a>Git&amp;GitHub</h2><h3 id="Git基础-1"><a href="#Git基础-1" class="headerlink" title="Git基础"></a>Git基础</h3><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><blockquote><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统</p></blockquote><p>有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态。</p><p>就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。</p><p>你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。</p><h5 id="集中式-svn"><a href="#集中式-svn" class="headerlink" title="集中式(svn)"></a>集中式(svn)</h5><p>svn因为每次存的都是<strong>差异</strong>，需要的硬盘空间会相对的小一点，可是回滚的速度会很慢</p><ul><li>优点: 代码存放在<strong>单一的服务器</strong>上，便于项目的管理</li><li>缺点:  服务器宕机（员工写的代码得不到保障）    服务器炸了（整个项目的历史记录都会丢失）</li></ul><h5 id="分布式-git"><a href="#分布式-git" class="headerlink" title="分布式(git)"></a>分布式(git)</h5><p>git每次存的都是<strong>项目的完整快照</strong>，需要的硬盘空间会相对大一点</p><p>(Git团队对代码做了极致的压缩，最终需要的实际空间比svn多不了太多，可是Git的<strong>回滚速度极快</strong>)</p><ul><li>优点: 完全的<strong>分布式</strong></li><li>缺点: 学习起来比SVN陡峭</li></ul><h4 id="托管中心（维护远程库）"><a href="#托管中心（维护远程库）" class="headerlink" title="托管中心（维护远程库）"></a>托管中心（维护远程库）</h4><ul><li>局域网：可以自己搭建一个GitLab服务器</li><li>外网：可以使用码云、Github</li></ul><h4 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h4><p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p><p>Git地址 : <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a> 下载完安装包之后，傻瓜式安装</p><p>安装后，桌面右键<code>git bash Here</code>菜单之后，可以看到一个终端窗口，在终端里面输入命令 <code>git --version</code>，如果可以看到 git 的版本信息，则说明安装成功。</p><h4 id="Git初始化配置"><a href="#Git初始化配置" class="headerlink" title="Git初始化配置"></a>Git初始化配置</h4><p>一般在新的系统上，我们都需要先配置下自己的 Git 工作环境。</p><p>配置工作只需一次，以后升级时还会沿用现在的配置。当然，如果需要，你随时可以用相同的命令修改已有的配置。</p><p>Git 提供了一个叫做<code>git config</code>的命令来配置或读取相应的工作环境变量而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p><ul><li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 <code>git config</code> 时用 <code>system</code> 选项，读写的就是这个文件</li><li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 <code>git config</code> 时用 <code>global</code> 选项，读写的就是这个文件。</li><li><code>.git/config</code> 文件：当前项目的Git目录中的配置文件（也就是工作目录中的 .git/config 文件）这里的配置仅仅针对当前项目有效。</li></ul><p>第一个要配置的是你个人的用户名称和电子邮件地址。</p><p>这两条配置很重要，每次Git提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name damu</span><br><span class="line">git config --global user.email damu @example.com</span><br></pre></td></tr></table></figure><p>要检查已有的配置信息，可以使用 <code>git config --list</code> 命令 </p><h4 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h4><p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。</p><p>Git 常用的是以下 6 个命令：<strong>git clone</strong>、<strong>git push</strong>、<strong>git add</strong> 、<strong>git commit</strong>、<strong>git checkout</strong>、<strong>git pull</strong>，后面我们会详细介绍。<br><a href="https://imgtu.com/i/XzxS6f"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/21/XzxS6f.png" alt="XzxS6f.png"></a></p><p><strong>说明：</strong></p><ul><li>workspace：工作区</li><li>Index：暂存区/缓存区</li><li>Repository：版本库或本地仓库</li><li>Remote：远程仓库</li></ul><h5 id="创建仓库命令"><a href="#创建仓库命令" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git init</code></td><td align="left">初始化仓库</td></tr><tr><td align="left"><code>git clone</code></td><td align="left">拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table><h5 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git add</code></td><td align="left">添加文件到仓库 git add [file name]</td></tr><tr><td align="left"><code>git status</code></td><td align="left">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td align="left"><code>git diff</code></td><td align="left">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td align="left"><code>git commit</code></td><td align="left">提交暂存区到本地仓库。git commit -m “commit message” [file name]</td></tr><tr><td align="left"><code>git reset</code></td><td align="left">回退版本。</td></tr><tr><td align="left"><code>git rm</code></td><td align="left">删除工作区文件。</td></tr><tr><td align="left"><code>git mv</code></td><td align="left">移动或重命名工作区文件。</td></tr></tbody></table><p><strong>前进后退</strong></p><p>推荐：<code>git reset --hard [局部索引值]</code>  </p><p>只能后退：</p><p><code>git reset --hard HEAD^</code>    一个^表示后退一步，n 个表示后退n 步</p><p><code>git reset --hard HEAD~n</code>  表示后退n 步</p><p><strong>reset命令的三个参数对比：</strong></p><ul><li><p><code>soft</code> 参数</p><ul><li>仅仅在本地库移动HEAD 指针</li></ul></li><li><p><code>mixed</code> 参数</p><ul><li>在本地库移动HEAD 指针</li><li>重置暂存区</li></ul></li><li><p><code>hard</code> 参数</p><ul><li>在本地库移动HEAD 指针</li><li>重置暂存区</li><li>重置工作区</li></ul></li></ul><p><strong>删除文件并找回</strong></p><p><strong>用 git rm 来删除文件，同时还会将这个删除操作记录下来；</strong><br><strong>用 rm 来删除文件，仅仅是删除了物理文件，没有将其从 git 的记录中剔除。</strong></p><p>前提：删除前，文件存在时的状态提交到了本地库。</p><p>操作：<code>git reset --hard [指针位置]</code></p><ul><li><p>删除操作已经提交到本地库：指针位置指向历史记录</p></li><li><p>删除操作尚未提交到本地库：指针位置使用HEAD</p></li></ul><p><strong>比较文件差异</strong></p><ul><li><code>git diff [文件名]</code>  将工作区中的文件和暂存区进行比较</li><li><code>git diff [本地库中历史版本] [文件名]</code>  将工作区中的文件和本地库历史记录比较</li><li>不带文件名比较多个文件</li></ul><h5 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git log</code></td><td align="left">查看历史提交记录(多屏显示控制方式：空格向下翻页 b向上翻页 q退出)</td></tr><tr><td align="left"><code>git blame &lt;file&gt;</code></td><td align="left">以列表形式查看指定文件的历史修改记录</td></tr><tr><td align="left"><code>git reflog</code></td><td align="left">可以查看自己的所有分支的所有操作记录（HEAD@{移动到当前版本需要多少步}）</td></tr></tbody></table><h5 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h5><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git remote</code></td><td align="left">远程仓库操作</td></tr><tr><td align="left"><code>git fetch</code></td><td align="left">从远程获取代码库</td></tr><tr><td align="left"><code>git pull</code></td><td align="left">下载远程代码并合并</td></tr><tr><td align="left"><code>git push</code></td><td align="left">上传远程代码并合并</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">No commits yet</span><br><span class="line">nothing to commit (create/copy files and use &quot;git add&quot; to track)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim good.txt</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">No commits yet</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        good.txt</span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add good.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in good.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached good.txt</span></span><br><span class="line">rm &#x27;good.txt&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add good.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in good.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit good.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in good.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">[master (root-commit) 30011d8] My first commit.new file good.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 good.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat good.txt</span></span><br><span class="line">123</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add good.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in good.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;My second commit,modify good.txt&quot;</span> good.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in good.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">[master cf7ece9] My second commit,modify good.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit cf7ece9b21f6d13ad48bb9b6948a76e11110a972 (HEAD -&gt; master)</span><br><span class="line">Author: lesliewang &lt;lesliewang@bupt.edu.cn&gt;</span><br><span class="line">Date:   Sun Mar 28 16:18:27 2021 +0800</span><br><span class="line">    My second commit,modify good.txt</span><br><span class="line">commit 30011d85f3974bc41d87f29b1161a50a771d8e42</span><br><span class="line">Author: lesliewang &lt;lesliewang@bupt.edu.cn&gt;</span><br><span class="line">Date:   Sun Mar 28 16:10:11 2021 +0800</span><br><span class="line">    My first commit.new file good.txt</span><br><span class="line">    </span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">cf7ece9b21f6d13ad48bb9b6948a76e11110a972 (HEAD -&gt; master) My second commit,modify good.txt</span><br><span class="line">30011d85f3974bc41d87f29b1161a50a771d8e42 My first commit.new file good.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --oneline</span></span><br><span class="line">cf7ece9 (HEAD -&gt; master) My second commit,modify good.txt</span><br><span class="line">30011d8 My first commit.new file good.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br><span class="line">cf7ece9 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: My second commit,modify good.txt</span><br><span class="line">30011d8 HEAD@&#123;1&#125;: commit (initial): My first commit.new file good.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard 30011d8</span></span><br><span class="line">HEAD is now at 30011d8 My first commit.new file good.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard cf7ece9</span></span><br><span class="line">HEAD is now at cf7ece9 My second commit,modify good.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span></span><br><span class="line">HEAD is now at 30011d8 My first commit.new file good.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash">  git reset --hard HEAD~1</span></span><br><span class="line">HEAD is now at 30011d8 My first commit.new file good.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff good.txt</span></span><br><span class="line">diff --git a/good.txt b/good.txt</span><br><span class="line">index 190a180..ce8c77d 100644</span><br><span class="line">--- a/good.txt</span><br><span class="line">+++ b/good.txt</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> 123</span><br><span class="line">+456</span><br></pre></td></tr></table></figure><h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><blockquote><p>在版本控制过程中，使用多条线同时推进多个任务。</p></blockquote><ul><li>同时并行推进多个功能开发，提高开发效率</li><li>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</li></ul><blockquote><p>分支操作</p></blockquote><p><strong>创建分支</strong></p><p> <code>git branch [分支名]</code></p><p><strong>查看分支</strong></p><p> <code>git branch -v</code></p><p><strong>切换分支</strong> </p><p><code>git checkout [分支名]</code></p><p><strong>合并分支</strong></p><p>第一步：切换到接受修改的分支（被合并，增加新内容）上 <code>git checkout [被合并分支名]</code></p><p>第二步：执行merge 命令<code>git merge [有新内容分支名]</code></p><p><strong>解决冲突</strong></p><ul><li>第一步：编辑文件，删除特殊符号</li><li>第二步：把文件修改到满意的程度，保存退出</li><li>第三步：<code>git add [文件名]</code></li><li>第四步：<code>git commit -m &quot;日志信息&quot;</code></li></ul><p>注意：此时commit 一定不能带具体文件名</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> git branch <span class="literal">-v</span></span><br><span class="line">* master <span class="number">30011</span>d8 My first commit.new file good.txt</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git branch hot_fix</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git branch <span class="literal">-v</span></span><br><span class="line">  hot_fix <span class="number">30011</span>d8 My first commit.new file good.txt</span><br><span class="line">* master  <span class="number">30011</span>d8 My first commit.new file good.txt</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git checkout hot_fix</span><br><span class="line">Switched to branch <span class="string">&#x27;hot_fix&#x27;</span></span><br><span class="line">M       good.txt</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git branch <span class="literal">-v</span></span><br><span class="line">* hot_fix <span class="number">30011</span>d8 My first commit.new file good.txt</span><br><span class="line">  master  <span class="number">30011</span>d8 My first commit.new file good.txt</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git merge hot_fix</span><br><span class="line">Updating <span class="number">30011</span>d8..<span class="number">956</span>e8dd</span><br><span class="line">Fast<span class="literal">-forward</span></span><br><span class="line"> good.txt | <span class="number">1</span> +</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> good.txt</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">456</span> edit by hot_fix</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> vim good.txt</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git add good.txt</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">&quot;test conflict&quot;</span> good.txt</span><br><span class="line">[<span class="type">master</span> <span class="type">d9989df</span>] test conflict</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure><h3 id="Git底层概念（底层命令）"><a href="#Git底层概念（底层命令）" class="headerlink" title="Git底层概念（底层命令）"></a>Git底层概念（底层命令）</h3><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>哈希是一个系列的加密算法，各个不同的哈希算法虽然加密强度不同，但是有以下几个共同点：</p><ul><li>不管输入数据的数据量有多大，输入同一个哈希算法，得到的加密结果长度固定。</li><li>哈希算法确定，输入数据确定，输出数据能够保证不变</li><li>哈希算法确定，输入数据有变化，输出数据一定有变化，而且通常变化很大</li><li>哈希算法不可逆</li></ul><p><strong>Git 底层采用的是SHA-1 算法。</strong></p><p>Git 就是靠这种机制来从根本上保证数据完整性的。</p><h4 id="基础的linux命令"><a href="#基础的linux命令" class="headerlink" title="基础的linux命令"></a>基础的linux命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clear:清除屏幕</span><br><span class="line">echo &#x27;test content&#x27;:往控制台输出信息 echo &#x27;test content&#x27; &gt; test.txt</span><br><span class="line">ll：将当前目录下的子文件&amp;子目录平铺在控制台</span><br><span class="line">find 目录名:将对应目录下的子孙文件&amp;子孙目录平铺在控制台</span><br><span class="line">find 目录名 -type f ：将对应目录下的文件平铺在控制台</span><br><span class="line">rm 文件名:删除文件</span><br><span class="line">mv 源文件 重命名文件: 重命名</span><br><span class="line">cat 文件的url : 查看对应文件的内容</span><br><span class="line">vim 文件的url（在英文模式下）</span><br><span class="line">按i进插入模式 进行文件的编辑</span><br><span class="line">按esc键和:键 进行命令的执行</span><br><span class="line">q! 强制退出（不保存）</span><br><span class="line">wq 保存退出</span><br><span class="line">set nu 设置行号</span><br></pre></td></tr></table></figure><h4 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h4><p><strong>工作区</strong>：就是你在电脑里能看到的目录。</p><p><strong>暂存区</strong>：英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</p><p><strong>版本库</strong>：工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</p><p><a href="https://imgtu.com/i/Xzvz1P"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/21/Xzvz1P.jpg" alt="Xzvz1P.jpg"></a></p><p>新建一个workspace文件夹，在里面右键<code>git bash Here</code>，输入<code>git init</code>，查看中勾选隐藏项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hooks   目录包含客户端或服务端的钩子脚本；</span><br><span class="line">info    包含一个全局性排除文件</span><br><span class="line">logs    保存日志信息</span><br><span class="line">objects 目录存储所有数据内容；</span><br><span class="line">refs    目录存储指向数据的提交对象的指针（分支）</span><br><span class="line">config      文件包含项目特有的配置选项</span><br><span class="line">description 用来显示对仓库的描述信息</span><br><span class="line">HEAD        文件指示目前被检出的分支</span><br><span class="line">index       文件保存暂存区信息</span><br></pre></td></tr></table></figure><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><blockquote><p>git对象</p></blockquote><p>Git 的核心部分是一个简单的键值对数据库 。 你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索该内容。</p><p>key:val 组成的键值对（key是val对应的hash）</p><p>键值对在git内部是一个blob类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">向数据库写入内容 并返回对应键值</span><br><span class="line">命令：</span><br><span class="line">echo &#x27;test content&#x27; | git hash-object -w --stdin</span><br><span class="line">-w 选项指示 hash-object 命令存储数据对象；若不指定此选项，则该命令仅返回对应的键值</span><br><span class="line">--stdin（standard input）选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径</span><br><span class="line">git hash-object -w 文件路径 存文件</span><br><span class="line">git hash-object 文件路径 返回对应文件的键值</span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">返回：</span><br><span class="line">该命令输出一个长度为 40 个字符的校验和。 这是一个 SHA-1 哈希值</span><br><span class="line">查看Git是如何存储数据的</span><br><span class="line">命令：</span><br><span class="line">find .git/objects -type f</span><br><span class="line">返回：</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">这就是开始时Git存储内容的方式：一个文件对应一条内容。校验和的前两个字符用于命名子目录，余下的38个字符则用作文件名。</span><br><span class="line">根据键值拉取数据</span><br><span class="line">命令：</span><br><span class="line">git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">-p 选项可指示该命令自动判断内容的类型，并为我们显示格式友好的内容</span><br><span class="line">返回：</span><br><span class="line">对应文件的内容</span><br></pre></td></tr></table></figure><p><strong>对一个文件进行简单的版本控制</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">创建一个新文件并将其内容存入数据库</span><br><span class="line">命令：echo &#x27;version 1&#x27; &gt; test.txt</span><br><span class="line"> git hash-object -w test.txt</span><br><span class="line">返回：</span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30 </span><br><span class="line">向文件里写入新内容，并再次将其存入数据库</span><br><span class="line">命令：</span><br><span class="line">echo &#x27;version 2&#x27; &gt; test.txt</span><br><span class="line">git hash-object -w test.txt</span><br><span class="line">返回：</span><br><span class="line">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">查看数据库内容</span><br><span class="line">命令：</span><br><span class="line">find .git/objects -type f</span><br><span class="line">git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30</span><br><span class="line">git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">利用 cat-file -t 命令，可以让 Git 告诉我们其内部存储的任何对象类型</span><br><span class="line">返回：blob</span><br></pre></td></tr></table></figure><p>问题： </p><ul><li>记住文件的每一个版本所对应的 SHA-1 值并不现实</li><li>在Git中，文件名并没有被保存——我们仅保存了文件的内容<br><strong>解决方案：树对象</strong></li></ul><p>注意：当前的操作都是在对本地数据库进行操作 不涉及暂存区</p><blockquote><p>树对象</p></blockquote><p>​    <strong>树对象（ tree object ）</strong>，它能解决文件名保存的问题，也允许我们将多个文件组织到一起 。 Git 以一种类似于UNIX文件系统的方式存储内容 。所有内容均以<strong>树对象</strong>和<strong>数据对象 (git对象)<strong>的形式存储，其中</strong>树对象对应了 UNIX 中的目录项，数据对象 (git对象)则大致上对应文件内容</strong>。 一个树对象包含了一条或多条记录(每条记录含有一个指向git对象或者子树对象的SHA 1指针以及相应的模式、类型、文件名信息)。一个树对象也可以包含另一个树对象。</p><p>我们可以通过<code>update-index；write-tree；read-tree</code>等命令来构建树对像并塞入到暂存区。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">操作</span><br><span class="line">1.利用update-index命令为 test.txt文件的首个版本——创建一个暂存区。并通过write-tree命令生成树对像。</span><br><span class="line">命令：</span><br><span class="line">git update-index --add --cacheinfo 100644 83baae61804e65cc73a7201a7252750c76066a30 test.txt</span><br><span class="line">git write-tree</span><br><span class="line">             100644 表明这是一个普通文件</span><br><span class="line"> 100755 表示一个可执行文件</span><br><span class="line"> 120000 表示一个符号链接 </span><br><span class="line">--add 选项</span><br><span class="line">因为此前该文件并不在暂存区中 首次需要--add</span><br><span class="line">--cacheinfo 选项</span><br><span class="line">因为将要添加的文件位于Git数据库中，而不是位于当前目录下，所以需要--cacheinfo</span><br><span class="line"></span><br><span class="line">2.新增new.txt 将new.txt和test.txt文件的第二个个版本塞入暂存区。并通过write-tree命令生成树对像。</span><br><span class="line">命令：echo &#x27;new file&#x27; &gt; new.txt</span><br><span class="line"> git update-index --cacheinfo 100644 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt</span><br><span class="line"> git update-index --add new.txt</span><br><span class="line"> git write-tree</span><br><span class="line">3. 将第一个树对象加入第二个树对象，使其成为新的树对象</span><br><span class="line">命令：</span><br><span class="line">git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">git write-tree</span><br><span class="line">read-tree命令，可以把树对象读入暂存区</span><br></pre></td></tr></table></figure><p>问题：</p><p>​        现在有三个树对象（执行了    三次 write tree），分别代表了我们想要跟踪的不同项目快照。然而问题依旧：若想重用这些快照，你必须记住所有三个SHA-1哈希值。 并且，你也完全不知道是谁保存了这些快照，在什么时刻保存的，以及为什么保存这些快照。 而以上这些，正是<strong>提交对象（ commit object）</strong>能为你保存的基本信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">查看暂存区当前的样子</span><br><span class="line">git ls-files s</span><br><span class="line">查看树对象</span><br><span class="line">命令：</span><br><span class="line">git cat-file -p master^&#123;tree&#125; （或者是树对象的hash）</span><br><span class="line">master^&#123;tree&#125; 语法表示master分支上最新的提交所指向的树对象。</span><br><span class="line">返回:</span><br><span class="line">100644 blob a906cb2a4a904a152e80877d4088654daad0c859 README</span><br><span class="line">100644 blob 8f94139338f9404f26296befa88755fc2598c289 Rakefile</span><br><span class="line">040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0 lib</span><br><span class="line">注意，lib子目录（所对应的那条树对象记录）并不是一个数据对象，而是一个指针，其指向的是另一个树对象：</span><br><span class="line">git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0</span><br><span class="line">100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b simplegit.rb</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">解析树对象</span><br><span class="line">Git根据某一时刻暂存区（即index区域）所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录（某个时间段内）一系列的树对象。</span><br><span class="line">其实树对象是对暂存区内操作的抽象，这颗树对象相对于就是快照。当我们的工作区有任何更改同步到暂存区时。便会调用write-tree 命令。</span><br><span class="line">通过write-tree命令向暂存区内容写入一个树对象。它会根据当前暂存区状态自动创建一个新的树对象。即每一次同步都产生一颗树对象。且该命令会返回一个hash指向树对象。</span><br><span class="line">在Git中每一个文件（数据）都对应一个hash（类型 blob）</span><br><span class="line">每一个树对象都对应一个hash（类型 tree）</span><br></pre></td></tr></table></figure><p><strong>我们可以认为树对象就是我们项目的快照</strong></p><blockquote><p>提交对象</p></blockquote><p>我们可以通过调用commit-tree 命令创建一个提交对象，为此需要指定一个树对象的SHA-1值，以及该提交的父提交对象（如果有的话， 第一次将暂存区做快照就没有父对象）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">创建提交对象</span><br><span class="line">echo &#x27;first commit&#x27; | git commit-tree d8329f</span><br><span class="line">返回：</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d </span><br><span class="line">查看提交对象</span><br><span class="line">git cat-file -p fdf4fc3</span><br><span class="line">返回：</span><br><span class="line">tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">author Scott Chacon &lt;schacon@gmail.com&gt; 1243</span><br><span class="line">committer Scott Chacon &lt;schacon@gmail.com&gt; 1243</span><br><span class="line">first commit</span><br><span class="line">提交对象的格式</span><br><span class="line">它先指定一个顶层树对象，代表当前项目快照；然后是作者 提交者信息（依据你的user.name和user.email配置来设定，外加一个时间戳）；留空一行，最后是提交注释</span><br><span class="line">接着，我们将创建另两个提交对象，它们分别引用各自的上一个提交（作为其父提交对象）：</span><br><span class="line">echo &#x27;second commit&#x27; | git commit-tree 0155eb -p fdf4fc3</span><br><span class="line">cac0cab538b970a37ea1e769cbbde608743bc96d</span><br><span class="line">echo &#x27;third commit&#x27; | git commit-tree 3c4e9c -p cac0cab</span><br><span class="line">1a410efbd13591db07496601ebc7a059dd55cfe9</span><br></pre></td></tr></table></figure><p>git commit-tree 不但生成提交对象 而且会将对应的快照（树对象）提交到本地库中</p><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><h4 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h4><p><a href="https://github.com/">https://github.com/</a></p><h4 id="创建远程库"><a href="#创建远程库" class="headerlink" title="创建远程库"></a>创建远程库</h4><h4 id="创建远程库地址别名"><a href="#创建远程库地址别名" class="headerlink" title="创建远程库地址别名"></a>创建远程库地址别名</h4><p><code>git remote -v 查看当前所有远程地址别名</code><br><code>git remote add [别名] [远程地址]</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> git remote add origin https://github.com/Lesliewaong/test.git</span><br><span class="line"><span class="variable">$</span> git remote <span class="literal">-v</span></span><br><span class="line">origin  https://github.com/Lesliewaong/test.git (fetch)</span><br><span class="line">origin  https://github.com/Lesliewaong/test.git (push)</span><br></pre></td></tr></table></figure><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p><code>git push [别名] [分支名]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m &quot;test&quot;</span><br><span class="line"></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p><strong>连接错误解决方法</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: RPC failed; <span class="built_in">curl</span> <span class="number">28</span> OpenSSL SSL_read: Connection was reset, errno <span class="number">10054</span></span><br><span class="line">fatal: expected flush after ref listing</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config http.sslVerify <span class="string">&quot;false&quot;</span></span><br></pre></td></tr></table></figure><p>出错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! [rejected] master -&gt; master (fetch first) error: failed to push some refs to <span class="string">&#x27; ...&#x27;</span></span><br></pre></td></tr></table></figure><p>出现这个问题是因为github中的README.md文件不在本地代码目录中，可以通过如下命令进行代码合并</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master</span><br></pre></td></tr></table></figure><h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><p><code>git clone [远程地址]</code></p><p>效果</p><ul><li><strong>完整的把远程库下载到本地</strong></li><li><strong>创建origin 远程地址别名</strong></li><li><strong>初始化本地库</strong></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lesliewaong@LAPTOP<span class="literal">-NT1AH9KS</span> MINGW64 /d/学习Java</span><br><span class="line"><span class="variable">$</span> git clone https://github.com/Lesliewaong/test.git</span><br><span class="line">Cloning into <span class="string">&#x27;test&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: <span class="number">9</span>, done.</span><br><span class="line">remote: Counting objects: <span class="number">100</span>% (<span class="number">9</span>/<span class="number">9</span>), done.</span><br><span class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span><br><span class="line">remote: Total <span class="number">9</span> (delta <span class="number">0</span>), reused <span class="number">9</span> (delta <span class="number">0</span>), pack<span class="literal">-reused</span> <span class="number">0</span></span><br><span class="line">Receiving objects: <span class="number">100</span>% (<span class="number">9</span>/<span class="number">9</span>), done.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="团队成员邀请"><a href="#团队成员邀请" class="headerlink" title="团队成员邀请"></a>团队成员邀请</h4><h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><blockquote><p>pull=fetch+merge</p></blockquote><p><code>git fetch [远程库地址别名] [远程分支名]</code><br><code>git merge [远程库地址别名/远程分支名]</code><br><code>git pull [远程库地址别名] [远程分支名]</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim good.txt</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add good.txt</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;test push&quot;</span> good.txt</span></span><br><span class="line">[master 19b8892] test push</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br><span class="line">Enumerating objects: 5, done.</span><br><span class="line">Counting objects: 100% (5/5), done.</span><br><span class="line">Writing objects: 100% (3/3), 272 bytes | 272.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To https://github.com/Lesliewaong/test.git</span><br><span class="line">   d9989df..19b8892  master -&gt; master</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> good.txt</span><br><span class="line"><span class="number">123</span> edit by master</span><br><span class="line"><span class="number">456</span> edit by hot_fix</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git fetch origin master</span><br><span class="line">remote: Enumerating objects: <span class="number">5</span>, done.</span><br><span class="line">remote: Counting objects: <span class="number">100</span>% (<span class="number">5</span>/<span class="number">5</span>), done.</span><br><span class="line">remote: Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">3</span> (delta <span class="number">0</span>), pack<span class="literal">-reused</span> <span class="number">0</span></span><br><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">252</span> bytes | <span class="number">12.00</span> KiB/s, done.</span><br><span class="line">From https://github.com/Lesliewaong/test</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">   d9989df..<span class="number">19</span>b8892  master     -&gt; origin/master</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> good.txt</span><br><span class="line"><span class="number">123</span> edit by master</span><br><span class="line"><span class="number">456</span> edit by hot_fix</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git checkout origin/master</span><br><span class="line">Previous HEAD position was d9989df test conflict</span><br><span class="line">HEAD is now at <span class="number">19</span>b8892 test push</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> good.txt</span><br><span class="line"><span class="number">123</span> edit by master</span><br><span class="line"><span class="number">456</span> edit by hot_fix</span><br><span class="line"><span class="number">789</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git checkout master</span><br><span class="line">Previous HEAD position was <span class="number">19</span>b8892 test push</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is behind <span class="string">&#x27;origin/master&#x27;</span> by <span class="number">1</span> commit, and can be fast<span class="literal">-forwarded</span>.</span><br><span class="line">  (use <span class="string">&quot;git pull&quot;</span> to update your local branch)</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> good.txt</span><br><span class="line"><span class="number">123</span> edit by master</span><br><span class="line"><span class="number">456</span> edit by hot_fix</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git merge origin/master</span><br><span class="line">Updating d9989df..<span class="number">19</span>b8892</span><br><span class="line">Fast<span class="literal">-forward</span></span><br><span class="line"> good.txt | <span class="number">1</span> +</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> good.txt</span><br><span class="line"><span class="number">123</span> edit by master</span><br><span class="line"><span class="number">456</span> edit by hot_fix</span><br><span class="line"><span class="number">789</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git pull origin master</span><br><span class="line">From https://github.com/Lesliewaong/test</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">Already up to date.</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> good.txt</span><br><span class="line"><span class="number">123</span> edit by master</span><br><span class="line"><span class="number">456</span> edit by hot_fix</span><br><span class="line"><span class="number">789</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>要点</p><ul><li><strong>如果不是基于GitHub 远程库的最新版所做的修改，不能推送，必须先拉取。</strong></li><li>拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可。</li></ul><h4 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h4><p>Fork，本地修改，然后推送到远程，Pull Request，对话，审核代码，合并代码，将远程库修改拉取到本地</p><h4 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h4><ul><li>进入当前用户的家目录<br><code>cd ~</code></li><li>删除.ssh 目录<br><code>rm -rvf .ssh</code></li><li>运行命令生成.ssh 密钥目录<br><code>ssh-keygen -t rsa -C email</code><br>[注意：这里-C 这个参数是大写的C]</li><li>进入.ssh 目录查看文件列表<br><code>cd .ssh</code><br><code>ls -lF</code></li><li>查看id_rsa.pub 文件内容<br><code>cat id_rsa.pub</code></li><li>复制id_rsa.pub 文件内容，登录GitHub，点击用户头像→Settings→SSH and GPG keys</li><li>New SSH Key</li><li>输入复制的密钥信息</li><li>回到Git bash 创建远程地址别名<br><code>git remote add origin_ssh ssh地址</code></li><li>推送文件进行测试</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> git remote add origin_ssh git@github.com:Lesliewaong/test.git</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git remote <span class="literal">-v</span></span><br><span class="line">origin  https://github.com/Lesliewaong/test.git (fetch)</span><br><span class="line">origin  https://github.com/Lesliewaong/test.git (push)</span><br><span class="line">origin_ssh      git@github.com:Lesliewaong/test.git (fetch)</span><br><span class="line">origin_ssh      git@github.com:Lesliewaong/test.git (push)</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git push origin_ssh master</span><br><span class="line">The authenticity of host <span class="string">&#x27;github.com (13.229.188.59)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span></span><br><span class="line"><span class="string">This key is not known by any other names</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span></span><br><span class="line"><span class="string">Warning: Permanently added &#x27;</span>github.com<span class="string">&#x27; (RSA) to the list of known hosts.</span></span><br><span class="line"><span class="string">Everything up-to-date</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h1 id="Git学习总结"><a href="#Git学习总结" class="headerlink" title="Git学习总结"></a>Git学习总结</h1><p><a href="https://imgtu.com/i/XzxS6f"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/21/XzxS6f.png" alt="XzxS6f.png"></a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>版本库👉.git<ul><li>当我们使用git管理文件时，比如<strong>git init</strong>时，这个时候，会多一个**.git**文件，我们把这个文件称之为版本库。</li><li><strong>.git</strong>文件另外一个作用就是它在创建的时候，会自动创建<strong>master</strong>分支，并且将<strong>HEAD</strong>指针指向<strong>master</strong>分支。</li></ul></li><li>工作区<ul><li>本地项目存放文件的位置。</li><li>可以理解成图上的workspace。</li></ul></li><li>暂存区 (<code>Index/Stage</code>)<ul><li>顾名思义就是暂时存放文件的地方，通过是通过<strong>add</strong>命令将工作区的文件添加到缓冲区。</li></ul></li><li>本地仓库（<code>Repository</code>）<ul><li>通常情况下，我们使用<strong>commit</strong>命令可以将暂存区的文件添加到本地仓库。</li><li>通常而言，<strong>HEAD</strong>指针指向的就是<strong>master</strong>分支。</li></ul></li><li>远程仓库（<code>Remote</code>）<ul><li>举个例子，当我们使用<strong>GitHub</strong>托管我们项目时，它就是一个远程仓库。</li><li>通常我们使用<strong>clone</strong>命令将远程仓库代码拷贝下来，本地代码更新后，通过<strong>push</strong>托送给远程仓库。</li></ul></li></ul><h2 id="Git文件状态"><a href="#Git文件状态" class="headerlink" title="Git文件状态"></a>Git文件状态</h2><p>通常我们需要查看一个文件的状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status </span><br></pre></td></tr></table></figure><ul><li><p><strong>Changes not staged for commit</strong></p><p>大概就是工作区有该内容，但是缓存区没有，需要我们<strong>git add</strong></p></li><li><p><strong>Changes to be committed</strong></p><p>这个时候，文件放在缓存区了，我们需要<strong>git commit</strong></p></li><li><p><strong>nothing to commit, working tree clean</strong></p><p>这个时候，我们将本地的代码推送到远端即可</p></li></ul><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><h3 id="git配置命令"><a href="#git配置命令" class="headerlink" title="git配置命令"></a>git配置命令</h3><ul><li><p>列出当前配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></li></ul><p>git日志过多最后显示end无法输入命令。直接按 <strong>q</strong> (或+Enter) ， 即可退出。</p><ul><li><p>列出Repository配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --local --list </span><br></pre></td></tr></table></figure></li><li><p>列出全局配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --lis</span><br></pre></td></tr></table></figure></li><li><p>列出系统配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --list</span><br></pre></td></tr></table></figure></li></ul><p>通过上述的命令，如果发现你并没有配置用户信息的话，接下来配置一下👇</p><ul><li><p>配置用户名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot; </span><br></pre></td></tr></table></figure></li><li><p>配置用户邮箱</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;youremail@github.com&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分支管理-1"><a href="#分支管理-1" class="headerlink" title="分支管理"></a>分支管理</h3><ul><li><p>查看本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li><p>查看远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure></li><li><p>查看本地和远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure></li><li><p>从当前分支，切换到其他分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt; #举个例子 git checkout feature/wangjichenTest</span><br></pre></td></tr></table></figure></li><li><p>创建并切换到新建分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt; # 举个例子 git checkout -b feature/tiantian</span><br></pre></td></tr></table></figure></li><li><p>删除分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>当前分支与指定分支合并</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch-name&gt; </span><br></pre></td></tr></table></figure></li><li><p>查看哪些分支已经合并到当前分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged</span><br></pre></td></tr></table></figure></li><li><p>查看哪些分支没有合并到当前分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --no-merged</span><br></pre></td></tr></table></figure></li><li><p>查看各个分支最后一个提交对象的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure></li><li><p>删除远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>重命名分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m &lt;oldbranch-name&gt; &lt;newbranch-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>拉取远程分支并创建本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 本地分支名x origin/远程分支名x </span><br><span class="line"><span class="meta">#</span><span class="bash"> 另外一种方式,也可以完成这个操作。</span> </span><br><span class="line">git fetch origin &lt;branch-name&gt;:&lt;local-branch-name&gt; </span><br></pre></td></tr></table></figure></li></ul><h3 id="fetch指令"><a href="#fetch指令" class="headerlink" title="fetch指令"></a>fetch指令</h3><p>将远程仓库内容更新到本地</p><p><strong>fetch推荐写法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin &lt;branch-name&gt;:&lt;local-branch-name&gt;</span><br></pre></td></tr></table></figure><ul><li>一般而言，这个<code>origin</code>是远程主机名，一般默认就是origin。</li><li><code>branch-name</code> 你要拉取的分支</li><li><code>local-branch-name</code> 通常而言，就是你本地新建一个新分支，将origin下的某个分支代码下载到本地分支。</li></ul><p>举个例子👇</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin feature/template_excellent:feature/template_layout</span><br><span class="line">// 你的工作目录下，就会有feature/template_layout</span><br><span class="line">// 一般情况下,我们需要做的就是在这个分支上开发新需求</span><br><span class="line">// 完成代码后,我们需要做的就是上传我们的分支</span><br></pre></td></tr></table></figure><p><strong>fetch其他写法</strong></p><ul><li><p>将某个远程主机的更新，全部取回本地。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; </span><br></pre></td></tr></table></figure></li><li><p>这样子的话，取回的是所有的分支更新，如果想取回特定分支，可以指定分支名👇</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure></li><li><p>当你想将 master分支的内容取回到本地下某个分支的话，如下👇</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin :&lt;local-branch-name&gt;</span><br><span class="line">// 等价于👇</span><br><span class="line">git fetch origin master:&lt;local-branch-name&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="花式撤销"><a href="#花式撤销" class="headerlink" title="花式撤销"></a>花式撤销</h3><ul><li><p>撤销<strong>工作区</strong>修改 撤销上一次对文件的操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>暂存区</strong>文件撤销 (不覆盖工作区)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD</span><br></pre></td></tr></table></figure></li><li><p><strong>版本回退</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --(soft | mixed | hard )  &lt; HEAD ~(num) &gt; |</span><br></pre></td></tr></table></figure><table><thead><tr><th>指令</th><th>作用范围</th></tr></thead><tbody><tr><td>–hard</td><td>回退全部，包括HEAD，index，working tree</td></tr><tr><td>–mixed</td><td>回退部分,包括HEAD，index</td></tr><tr><td>–soft</td><td>只回退HEAD</td></tr></tbody></table></li></ul><h3 id="状态查询"><a href="#状态查询" class="headerlink" title="状态查询"></a>状态查询</h3><ul><li><p>查看状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li><li><p>查看历史操作记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></li><li><p>查看日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></li></ul><h3 id="文档查询"><a href="#文档查询" class="headerlink" title="文档查询"></a>文档查询</h3><ul><li><p>展示Git命令大纲</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git help / --help</span><br></pre></td></tr></table></figure></li><li><p>展示Git命令大纲全部列表</p><ul><li>git help -a</li></ul></li><li><p>展示具体命令说明手册</p><ul><li>git help </li></ul></li></ul><h3 id="文件暂存"><a href="#文件暂存" class="headerlink" title="文件暂存"></a>文件暂存</h3><ul><li><p>添加改动到stash</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash save -a “message”</span><br></pre></td></tr></table></figure></li><li><p>删除暂存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop &lt;stash@&#123;ID&#125;&gt;</span><br></pre></td></tr></table></figure></li><li><p>查看stash列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure></li><li><p>删除全部缓存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure></li><li><p>恢复改动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop &lt;stash@&#123;ID&#125;&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="差异比较"><a href="#差异比较" class="headerlink" title="差异比较"></a>差异比较</h3><ul><li><p>比较工作区与缓存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure></li><li><p>比较缓存区与本地库最近一次commit内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff -- cached</span><br></pre></td></tr></table></figure></li><li><p>比较工作区与本地最近一次commit内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure></li><li><p>比较两个commit之间差异</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff  </span><br></pre></td></tr></table></figure></li></ul><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><h3 id="Git-版本-1-x"><a href="#Git-版本-1-x" class="headerlink" title="Git 版本 1.x"></a>Git 版本 1.x</h3><table><thead><tr><th align="left">命令</th><th align="left">新文件</th><th align="left">修改文件</th><th align="left">已删除的文件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>git add -A</code></td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">暂存所有（新的、修改的、删除的）文件</td></tr><tr><td align="left"><code>git add .</code></td><td align="left">✔️</td><td align="left">✔️</td><td align="left">❌</td><td align="left">仅在当前文件夹中暂存新文件和修改文件</td></tr><tr><td align="left"><code>git add -u</code></td><td align="left">❌</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">仅暂存修改和删除的文件</td></tr></tbody></table><h3 id="Git-版本-2-x"><a href="#Git-版本-2-x" class="headerlink" title="Git 版本 2.x"></a>Git 版本 2.x</h3><table><thead><tr><th align="left">命令</th><th align="left">新文件</th><th align="left">修改文件</th><th align="left">已删除的文件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>git add -A</code></td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">暂存所有（新的、修改的、删除的）文件</td></tr><tr><td align="left"><code>git add .</code></td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">在当前文件夹中暂存所有（新的、修改的、删除的）文件</td></tr><tr><td align="left"><code>git add --ignore-removal .</code></td><td align="left">✔️</td><td align="left">✔️</td><td align="left">❌</td><td align="left">仅暂存新文件和修改后的文件</td></tr><tr><td align="left"><code>git add -u</code></td><td align="left">❌</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">仅暂存修改和删除的文件</td></tr></tbody></table><h3 id="长格式标志："><a href="#长格式标志：" class="headerlink" title="长格式标志："></a>长格式标志：</h3><ul><li><code>git add -A</code>相当于<code>git add --all</code></li><li><code>git add -u</code>相当于<code>git add --update</code></li></ul><h2 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h2><p><a href="https://imgtu.com/i/jVX50s"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVX50s.png" alt="jVX50s.png"></a></p><p><strong>master分支</strong></p><ul><li><strong>主分支</strong>，用于<strong>部署生产环境</strong>的分支，确保稳定性。</li><li>master分支一般由develop以及hotfix分支合并，任何情况下都不能直接修改代码。</li></ul><p><strong>develop 分支</strong></p><ul><li>develop为<strong>开发分支</strong>，通常情况下，保存最新完成以及bug修复后的代码。</li><li>开发新功能时，feature分支都是基于develop分支下创建的。</li></ul><p><strong>feature分支</strong></p><ul><li><strong>开发新功能</strong>，基本上以develop为基础创建feature分支。</li><li>分支命名：<strong>feature/ 开头</strong>的为特性分支， 命名规则: feature/user_module、 feature/cart_module。</li></ul><p><strong>release分支</strong></p><ul><li>release 为<strong>预上线分支</strong>，发布提测阶段，会release分支代码为基准提测。</li></ul><p><strong>hotfix分支</strong></p><ul><li><strong>hotfix/</strong> 开头的为<strong>修复分支</strong>，它的命名规则与 feature 分支类似。</li><li>线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支。</li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>有了上述的基本了解后，那么我们就来看看整体的一个流程吧。</p><ul><li><p>创建本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff  </span><br></pre></td></tr></table></figure></li><li><p>链接本地仓库与远端仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add  origin url</span><br><span class="line">origin默认是远端仓库别名  url 可以是可以使用https或者ssh的方式新建</span><br></pre></td></tr></table></figure></li><li><p>检查配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email  &quot;your_email&quot;</span><br></pre></td></tr></table></figure></li><li><p>生成SSH密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;这里换上你的邮箱&quot;</span><br><span class="line">cd ~/.ssh 里面有一个文件名为id_rsa.pub,把里面的内容复制到git库的我的SSHKEYs中</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></li><li><p>常看远端仓库信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li><li><p>远端仓库重新命名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename old new</span><br></pre></td></tr></table></figure></li><li><p>提交到缓存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add . 全部上传到缓存区</span><br><span class="line">git add 指定文件</span><br></pre></td></tr></table></figure></li><li><p>提交到本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;some message&#x27;</span><br></pre></td></tr></table></figure></li><li><p>提交远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure></li><li><p>查看分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li><p>创建新分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>切换分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建分支并切换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>删除分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>克隆仓库后切换分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone url //将远程仓库克隆下载到本地</span><br><span class="line">git checkout -b dev origin/dev // 克隆仓库后切换到dev 分支</span><br></pre></td></tr></table></figure></li></ul><h2 id="忽略文件-gitignore"><a href="#忽略文件-gitignore" class="headerlink" title="忽略文件 .gitignore"></a>忽略文件 .gitignore</h2><p>这个文件的作用，会去忽略一些不需要纳入Git管理这种，我们也不希望出现在未跟踪文件列表。</p><p>那么我们来看看如何配置该文件信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此行为注释 会被Git忽略 </span></span><br><span class="line"><span class="comment"># 忽略 node_modules/ 目录下所有的文件 </span></span><br><span class="line">node_modules </span><br><span class="line"><span class="comment"># 忽略所有.vscode结尾的文件 </span></span><br><span class="line">.vscode </span><br><span class="line"><span class="comment"># 忽略所有.md结尾的文件 </span></span><br><span class="line">.md </span><br><span class="line"><span class="comment"># 但README.md 除外 </span></span><br><span class="line">!README.md </span><br><span class="line"><span class="comment"># 会忽略 doc/something.txt 但不会忽略doc/images/arch.txt </span></span><br><span class="line">doc/.txt </span><br><span class="line"><span class="comment"># 忽略 doc/ 目录下所有扩展名为txt文件 </span></span><br><span class="line">doc/**/*.txt</span><br></pre></td></tr></table></figure><h1 id="VSCode中git使用"><a href="#VSCode中git使用" class="headerlink" title="VSCode中git使用"></a>VSCode中git使用</h1><h2 id="vscode-拉取git仓库"><a href="#vscode-拉取git仓库" class="headerlink" title="vscode 拉取git仓库"></a>vscode 拉取git仓库</h2><p>直接选择克隆存储库，输入你的仓库地址，然后回车选择要存储的位置即可！<br><a href="https://imgtu.com/i/jVOyzF"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVOyzF.png" alt="jVOyzF.png"></a></p><h2 id="使用vscode提交代码"><a href="#使用vscode提交代码" class="headerlink" title="使用vscode提交代码"></a>使用vscode提交代码</h2><ol><li><p>打开下面视图，添加一行文字<code>## 测试提交</code></p><p><a href="https://imgtu.com/i/jVOcM4"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVOcM4.png" alt="jVOcM4.png"></a></p></li><li><p>点击 + ；相当于<code>git add .</code><br><a href="https://imgtu.com/i/jVO0I0"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVO0I0.png" alt="jVO0I0.png"></a></p></li><li><p>点击对号；等于<code>git commit -m &quot;备注信息&quot;</code>；右边的箭头输入需要备注的信息。然后按 Enter 确定。<br><a href="https://imgtu.com/i/jVOrGT"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVOrGT.png" alt="jVOrGT.png"></a><br>回车之后，然后我们可以看到。所有的修改的文件，均已经提交到缓存区。1变成了 0；<br><a href="https://imgtu.com/i/jVOwaq"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVOwaq.png" alt="jVOwaq.png"></a></p></li><li><p>拉取代码 <code>git pull origin master</code><br><a href="https://imgtu.com/i/jVODiV"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVODiV.png" alt="jVODiV.png"></a></p></li><li><p>提交到远程仓库；<code>git push origin master</code></p><p><a href="https://imgtu.com/i/jVOsRU"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVOsRU.png" alt="jVOsRU.png"></a></p><p>到git仓库里面；查看。已经成功提交。</p></li></ol><h1 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h1><h2 id="什么是Pull-Request"><a href="#什么是Pull-Request" class="headerlink" title="什么是Pull Request?"></a>什么是Pull Request?</h2><p>首先需要知道，pull request不是Git核心特性。</p><p>相反，是由使用的Git托管平台提供的，GitHub、GitLab、Bitbucket、AzureDevops以及其他平台都提供类似的内置功能。</p><h2 id="为什么需要创建pull-request"><a href="#为什么需要创建pull-request" class="headerlink" title="为什么需要创建pull request?"></a>为什么需要创建pull request?</h2><p>在我们讨论如何创建完美的pull request的细节之前，先来讨论一下为什么需要这个特性。</p><p>假设我们刚刚完成软件的一个新特性，也许之前一直在特性分支中工作，因此下一步将是将其合并到主线分支(<code>master</code>分支或<code>main</code>分支)。</p><p>在某些情况下，比方说你是项目中唯一的开发人员，或者有足够的经验并确定团队成员不会提出异议，那么直接合并一点问题都没有。</p><p>不过如果代码变更稍微复杂一点，并且希望其他人能够检查这部分工作，该怎么办呢？这就是pull request的目的。有了pull request，可以邀请其他人来评论所作的工作并给出反馈。</p><p>一旦创建了pull request，就可以和其他开发人员讨论相关代码。</p><p>大多数Git托管平台允许其他用户在此过程中添加评论以及提出建议，当评审人员批准后，就可以将其合并到另一个分支中。</p><p>评审工作流并不是创建pull request的唯一原因。</p><p>如果想对其他没有写访问权限的代码库做出贡献，用pull request就会很方便。想想所有的开源项目，如果你有一个新特性的想法，或者如果想提交一个补丁，pull request是一个很好的方式来展示想法，而不必加入这个项目并成为主要贡献者。</p><p>这就引出了一个与pull request紧密相关的话题: fork。</p><h2 id="用fork工作"><a href="#用fork工作" class="headerlink" title="用fork工作"></a>用fork工作</h2><p>fork是现有Git代码库的个人副本。回到之前关于开源的示例，第一步是创建原始代码库的副本（fork），之后就可以在自己的个人副本中更改代码。</p><p>一旦完成，就可以创建一个pull request，要求原始代码库的维护者采用你的更改。维护者或其他主要贡献者可以检查相关代码，然后决定是否采用。</p><blockquote><p><strong>重要提示:</strong> Pull request总是基于分支，而不是单个提交！创建pull request时，需要基于一个特定的分支并请求采用。</p></blockquote><h2 id="让审阅者的生活更轻松-如何创建一个优秀的pull-request"><a href="#让审阅者的生活更轻松-如何创建一个优秀的pull-request" class="headerlink" title="让审阅者的生活更轻松: 如何创建一个优秀的pull request"></a>让审阅者的生活更轻松: 如何创建一个优秀的pull request</h2><p>一般的工作流程都差不多，包括以下步骤:</p><ol><li>如果你没有对代码库的写权限，第一步是创建一个<code>fork</code>，也就是个人版本的代码库。</li><li>在fork的代码库中创建<strong>新的本地分支</strong>。(提示: pull request是基于分支的，而不是提交!)</li><li>在本地分支中进行<strong>变更并提交</strong>。</li><li>将变更<strong>推送到自己的远程代码库</strong>。</li><li>创建一个包含相关变更的<code>pull request</code>，开始与他人讨论。</li></ol><p>我们看看pull request本身，以及如何创建让其他开发人员的生活更轻松的请求。</p><p>首先应该简短，以便快速审阅，当面对3000行代码而不是30行代码时，就很难理解代码了。</p><p>其次，确保添加良好的、不言自明的标题和有意义的描述。</p><p>试着描述做了哪些更改，为什么创建pull request，以及这些更改对项目的影响。</p><p>大多数平台都允许添加屏幕截图来帮助展示这些变化。</p><h2 id="批准、合并还是拒绝"><a href="#批准、合并还是拒绝" class="headerlink" title="批准、合并还是拒绝?"></a>批准、合并还是拒绝?</h2><p>一旦变更被批准，你(或具有写访问权的人)就可以将分支合并到主分支中。</p><p>但是，如果审阅者不想在当前状态下合并pull request，该怎么办？嗯，你可以等会儿，也可以将新的提交推送到那个分支上，这样现有的pull request也会更新。</p><p>此外，维护者或其他具有写访问权限的人可以在不想合并更改时拒绝pull request。</p><h1 id="Git-中的撤销"><a href="#Git-中的撤销" class="headerlink" title="Git 中的撤销"></a>Git 中的撤销</h1><p>撤销可能是使用过程中最需要的操作，你可能在任何时候都需要撤销。根据情况不同，撤销的命令也是不同的。</p><h2 id="撤销最近几次-commit"><a href="#撤销最近几次-commit" class="headerlink" title="撤销最近几次 commit"></a>撤销最近几次 commit</h2><p>要撤销最近几次的提交，可以使用 <code>git reset</code>，下面介绍它的三种模式：<code>soft</code>、<code>mixed</code> 和 <code>hard</code>。</p><p>假设目前分支情况如下，我们需要撤销到 <code>98c27</code> commit 上去。</p><p><a href="https://imgtu.com/i/jVxvng"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVxvng.png" alt="jVxvng.png"></a></p><p><strong>1）soft 模式</strong></p><p>执行 <code>git reset --soft 98c27</code>，git 会首先修改 HEAD 的指向，它会连带修改 HEAD 所在分支的指向：</p><p><a href="https://imgtu.com/i/jVxXjS"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVxXjS.png" alt="jVxXjS.png"></a></p><p>如上图所示，现在的暂存区和 HEAD 是不同的，这个操作本质上撤销了 <code>2c9be</code> 这个 commit，如同回到了上次准备 commit 的时候。（git 中的时光机！）</p><p>此时你可以进行后悔操作，继续修改文件再 add，然后重新 commit，这时会提交一个新的 commit。</p><p><strong>2）mixed 模式</strong></p><p>回到一开始的时候，假如我们执行的是 <code>git reset --mixed 98c27</code>，它也会首先修改 HEAD 的指向，使得 HEAD 上的 commit 为 <code>98c27</code>。</p><p>但还不够，git 还会接着更新你的暂存区，如同回到了你准备 add 的时候。（时光机再向前！）</p><p><a href="https://imgtu.com/i/jVxL1f"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVxL1f.png" alt="jVxL1f.png"></a></p><p>对你来说可能更方便了，继续改就行，然后重新 add、commit。这实际上是 reset 的默认模式，等同于 <code>git reset 98c27</code>。</p><p><strong>3）hard 模式</strong></p><p>不用我多说你可能已经意识到 hard 是干什么用的了。这一次 git 摧枯拉朽，把你的 HEAD、暂存区、工作区全给干掉了：</p><p><a href="https://imgtu.com/i/jVxI7d"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVxI7d.png" alt="jVxI7d.png"></a></p><p>一下子回到了你开始写需求的时候。所以这个命令是 <strong>危险</strong> 的，除非你真的打算不要这些修改了，否则最好不要用。</p><p>不过即使你真的用了又后悔，那也是有办法的，在 git 里面，既然能回到过去，也能在过去穿越到未来。</p><p>使用 <code>git reflog</code> 可以查看你最近的修改，找到最前面的 commit id，可以继续使用 reset 穿回去。</p><h2 id="合并-commit"><a href="#合并-commit" class="headerlink" title="合并 commit"></a>合并 commit</h2><p>有时候你可能发现自己刚才提交的好几个 commit 其实都是中间状态，还不如把它们合并成一个。</p><p>根据上面的 reset，实际上就能完成这件事情。</p><p>比如下面的场景，我们多提交了一个 File V1.1 的中间版本，希望将其从 commit 历史中去掉：</p><p><a href="https://imgtu.com/i/jVxTAA"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVxTAA.png" alt="jVxTAA.png"></a></p><p>那其实可以直接 reset 到 v1 版本：</p><p><a href="https://imgtu.com/i/jVx4ne"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVx4ne.png" alt="jVx4ne.png"></a></p><p>然后重新进行 commit，这样就会将 v1 之后的修改都提交到了新的版本，如同移除了中间的版本。</p><p><a href="https://imgtu.com/i/jVx7tI"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVx7tI.png" alt="jVx7tI.png"></a></p><p>当然，这个场景也能用 rebase 解决，之后会提到。</p><h3 id="挪动-commit"><a href="#挪动-commit" class="headerlink" title="挪动 commit"></a>挪动 commit</h3><p>在多个分支上切换开发的时候，有时候会忘记切换分支就开始开发。</p><p>当发现自己提交的 commit 放错分支怎么办呢？在 git 中，这也不算个事，通过 <code>git cherry-pick</code> 就能解决。</p><p>cherry-pick 可以将指定的 commit “摘到”当前的分支上面，git 会为你重新生成一个 commit，但内容与 pick 的 commit 一致。</p><p><a href="https://imgtu.com/i/jVx50H"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/06/27/jVx50H.png" alt="jVx50H.png"></a></p><p>如果你要 pick 好几个 commit，它们之间有依赖关系，那需要根据先后顺序依次进行 cherry pick。</p><p>当发生冲突时，此时需要修改文件解决冲突，可以使用 <code>git cherry-pick --abort</code> 放弃此次 pick，或者解决完 add 进暂存区，然后使用 <code>git cherry-pick --continue</code>。注意这里并不是使用 <code>git commit</code>，如果你需要改变 commit 的信息，可以使用 commit，否则 git 会默认使用 pick 的 commit 的信息。</p><h1 id="约定式提交-1-0-0"><a href="#约定式提交-1-0-0" class="headerlink" title="约定式提交 1.0.0"></a><a href="https://www.conventionalcommits.org/zh-hans/v1.0.0/">约定式提交 1.0.0</a></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>约定式提交规范是一种基于提交信息的轻量级约定。 它提供了一组简单规则来创建清晰的提交历史； 这更有利于编写自动化工具。 通过在提交信息中描述功能、修复和破坏性变更， 使这种惯例与 <a href="http://semver.org/">SemVer</a> 相互对应。</p><p>提交说明的结构如下所示：</p><p>原文：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;[optional scope]: &lt;description&gt;</span><br><span class="line"></span><br><span class="line">[optional body]</span><br><span class="line"></span><br><span class="line">[optional footer(s)]</span><br></pre></td></tr></table></figure><p>译文：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt;[可选 范围]: &lt;描述&gt;</span><br><span class="line"></span><br><span class="line">[可选 正文]</span><br><span class="line"></span><br><span class="line">[可选 脚注]</span><br></pre></td></tr></table></figure><p>提交说明包含了下面的结构化元素，以向类库使用者表明其意图：</p><ol><li><strong>fix:</strong> <em>类型</em> 为 <code>fix</code> 的提交表示在代码库中修复了一个 bug（这和语义化版本中的 <a href="https://semver.org/lang/zh-CN/#%E6%91%98%E8%A6%81"><code>PATCH</code></a> 相对应）。</li><li><strong>feat:</strong> <em>类型</em> 为 <code>feat</code> 的提交表示在代码库中新增了一个功能（这和语义化版本中的 <a href="https://semver.org/lang/zh-CN/#%E6%91%98%E8%A6%81"><code>MINOR</code></a> 相对应）。</li><li><strong>BREAKING CHANGE:</strong> 在脚注中包含 <code>BREAKING CHANGE:</code> 或 <code>&lt;类型&gt;(范围)</code> 后面有一个 <code>!</code> 的提交，表示引入了破坏性 API 变更（这和语义化版本中的 <a href="https://semver.org/lang/zh-CN/#%E6%91%98%E8%A6%81"><code>MAJOR</code></a> 相对应）。 破坏性变更可以是任意 <em>类型</em> 提交的一部分。</li><li>除 <code>fix:</code> 和 <code>feat:</code> 之外，也可以使用其它提交 <em>类型</em> ，例如 <a href="https://github.com/conventional-changelog/commitlint/tree/master/%40commitlint/config-conventional">@commitlint/config-conventional</a>（基于 <a href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines">Angular 约定</a>）中推荐的 <code>build:</code>、<code>chore:</code>、 <code>ci:</code>、<code>docs:</code>、<code>style:</code>、<code>refactor:</code>、<code>perf:</code>、<code>test:</code>，等等。</li><li>脚注中除了 <code>BREAKING CHANGE: &lt;description&gt;</code> ，其它条目应该采用类似 <a href="https://git-scm.com/docs/git-interpret-trailers">git trailer format</a> 这样的惯例。</li></ol><p>其它提交类型在约定式提交规范中并没有强制限制，并且在语义化版本中没有隐式影响（除非它们包含 BREAKING CHANGE）。 可以为提交类型添加一个围在圆括号内的范围，以为其提供额外的上下文信息。例如 <code>feat(parser): adds ability to parse arrays.</code>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="包含了描述并且脚注中有破坏性变更的提交说明"><a href="#包含了描述并且脚注中有破坏性变更的提交说明" class="headerlink" title="包含了描述并且脚注中有破坏性变更的提交说明"></a>包含了描述并且脚注中有破坏性变更的提交说明</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feat: allow provided config object to extend other configs</span><br><span class="line"></span><br><span class="line">BREAKING CHANGE: `extends` key in config file is now used for extending other config files</span><br></pre></td></tr></table></figure><h3 id="包含了-字符以提醒注意破坏性变更的提交说明"><a href="#包含了-字符以提醒注意破坏性变更的提交说明" class="headerlink" title="包含了 ! 字符以提醒注意破坏性变更的提交说明"></a>包含了 <code>!</code> 字符以提醒注意破坏性变更的提交说明</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feat!: send an email to the customer when a product is shipped</span><br></pre></td></tr></table></figure><h3 id="包含了范围和破坏性变更-的提交說明"><a href="#包含了范围和破坏性变更-的提交說明" class="headerlink" title="包含了范围和破坏性变更 ! 的提交說明"></a>包含了范围和破坏性变更 <code>!</code> 的提交說明</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feat(api)!: send an email to the customer when a product is shipped</span><br></pre></td></tr></table></figure><h3 id="包含了-和-BREAKING-CHANGE-脚注的提交说明"><a href="#包含了-和-BREAKING-CHANGE-脚注的提交说明" class="headerlink" title="包含了 ! 和 BREAKING CHANGE 脚注的提交说明"></a>包含了 <code>!</code> 和 BREAKING CHANGE 脚注的提交说明</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chore!: drop support for Node 6</span><br><span class="line"></span><br><span class="line">BREAKING CHANGE: use JavaScript features not available in Node 6.</span><br></pre></td></tr></table></figure><h3 id="不包含正文的提交说明"><a href="#不包含正文的提交说明" class="headerlink" title="不包含正文的提交说明"></a>不包含正文的提交说明</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docs: correct spelling of CHANGELOG</span><br></pre></td></tr></table></figure><h3 id="包含范围的提交说明"><a href="#包含范围的提交说明" class="headerlink" title="包含范围的提交说明"></a>包含范围的提交说明</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feat(lang): add polish language</span><br></pre></td></tr></table></figure><h3 id="包含多行正文和多行脚注的提交说明"><a href="#包含多行正文和多行脚注的提交说明" class="headerlink" title="包含多行正文和多行脚注的提交说明"></a>包含多行正文和多行脚注的提交说明</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fix: prevent racing of requests</span><br><span class="line"></span><br><span class="line">Introduce a request id and a reference to latest request. Dismiss</span><br><span class="line">incoming responses other than from latest request.</span><br><span class="line"></span><br><span class="line">Remove timeouts which were used to mitigate the racing issue but are</span><br><span class="line">obsolete now.</span><br><span class="line"></span><br><span class="line">Reviewed-by: Z</span><br><span class="line">Refs: #123</span><br></pre></td></tr></table></figure><h2 id="约定式提交规范"><a href="#约定式提交规范" class="headerlink" title="约定式提交规范"></a>约定式提交规范</h2><p>本文中的关键词 “必须（MUST）”、“禁止（MUST NOT）”、“必要（REQUIRED）”、“应当（SHALL）”、“不应当（SHALL NOT）”、“应该（SHOULD）”、“不应该（SHOULD NOT）”、“推荐（RECOMMENDED）”、“可以（MAY）” 和 “可选（OPTIONAL）” ，其相关解释参考 <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a> 。</p><ol><li>每个提交都<strong>必须</strong>使用类型字段前缀，它由一个名词构成，诸如 <code>feat</code> 或 <code>fix</code> ， 其后接<strong>可选的</strong>范围字段，<strong>可选的</strong> <code>!</code>，以及<strong>必要的</strong>冒号（英文半角）和空格。</li><li>当一个提交为应用或类库实现了新功能时，<strong>必须</strong>使用 <code>feat</code> 类型。</li><li>当一个提交为应用修复了 bug 时，<strong>必须</strong>使用 <code>fix</code> 类型。</li><li>范围字段<strong>可以</strong>跟随在类型字段后面。范围<strong>必须</strong>是一个描述某部分代码的名词，并用圆括号包围，例如： <code>fix(parser):</code></li><li>描述字段<strong>必须</strong>直接跟在 &lt;类型&gt;(范围) 前缀的冒号和空格之后。 描述指的是对代码变更的简短总结，例如： <em>fix: array parsing issue when multiple spaces were contained in string</em> 。</li><li>在简短描述之后，<strong>可以</strong>编写较长的提交正文，为代码变更提供额外的上下文信息。正文<strong>必须</strong>起始于描述字段结束的一个空行后。</li><li>提交的正文内容自由编写，并<strong>可以</strong>使用空行分隔不同段落。</li><li>在正文结束的一个空行之后，<strong>可以</strong>编写一行或多行脚注。每行脚注都<strong>必须</strong>包含 一个令牌（token），后面紧跟 <code>:&lt;space&gt;</code> 或 <code>&lt;space&gt;#</code> 作为分隔符，后面再紧跟令牌的值（受 <a href="https://git-scm.com/docs/git-interpret-trailers">git trailer convention</a> 启发）。</li><li>脚注的令牌<strong>必须</strong>使用 <code>-</code> 作为连字符，比如 <code>Acked-by</code> (这样有助于 区分脚注和多行正文)。有一种例外情况就是 <code>BREAKING CHANGE</code>，它<strong>可以</strong>被认为是一个令牌。</li><li>脚注的值<strong>可以</strong>包含空格和换行，值的解析过程<strong>必须</strong>直到下一个脚注的令牌/分隔符出现为止。</li><li>破坏性变更<strong>必须</strong>在提交信息中标记出来，要么在 &lt;类型&gt;(范围) 前缀中标记，要么作为脚注的一项。</li><li>包含在脚注中时，破坏性变更<strong>必须</strong>包含大写的文本 <code>BREAKING CHANGE</code>，后面紧跟着冒号、空格，然后是描述，例如： <em>BREAKING CHANGE: environment variables now take precedence over config files</em> 。</li><li>包含在 &lt;类型&gt;(范围) 前缀时，破坏性变更<strong>必须</strong>通过把 <code>!</code> 直接放在 <code>:</code> 前面标记出来。 如果使用了 <code>!</code>，那么脚注中<strong>可以</strong>不写 <code>BREAKING CHANGE:</code>， 同时提交信息的描述中<strong>应该</strong>用来描述破坏性变更。</li><li>在提交说明中，<strong>可以</strong>使用 <code>feat</code> 和 <code>fix</code> 之外的类型，比如：<em>docs: updated ref docs.</em> 。</li><li>工具的实现必须<strong>不区分</strong>大小写地解析构成约定式提交的信息单元，只有 <code>BREAKING CHANGE</code> <strong>必须</strong>是大写的。</li><li>BREAKING-CHANGE 作为脚注的令牌时<strong>必须</strong>是 BREAKING CHANGE 的同义词。</li></ol><h2 id="为什么使用约定式提交"><a href="#为什么使用约定式提交" class="headerlink" title="为什么使用约定式提交"></a>为什么使用约定式提交</h2><ul><li>自动化生成 CHANGELOG。</li><li>基于提交的类型，自动决定语义化的版本变更。</li><li>向同事、公众与其他利益关系者传达变化的性质。</li><li>触发构建和部署流程。</li><li>让人们探索一个更加结构化的提交历史，以便降低对你的项目做出贡献的难度。</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="在初始开发阶段我该如何处理提交说明？"><a href="#在初始开发阶段我该如何处理提交说明？" class="headerlink" title="在初始开发阶段我该如何处理提交说明？"></a>在初始开发阶段我该如何处理提交说明？</h3><p>我们建议你按照假设你已发布了产品那样来处理。因为通常总 <em>有人</em> 使用你的软件，即便那是你软件开发的同事们。他们会希望知道诸如修复了什么、哪里不兼容等信息。</p><h3 id="提交标题中的类型是大写还是小写"><a href="#提交标题中的类型是大写还是小写" class="headerlink" title="提交标题中的类型是大写还是小写?"></a>提交标题中的类型是大写还是小写?</h3><p>大小写都可以，但最好是一致的。</p><h3 id="如果提交符合多种类型我该如何操作？"><a href="#如果提交符合多种类型我该如何操作？" class="headerlink" title="如果提交符合多种类型我该如何操作？"></a>如果提交符合多种类型我该如何操作？</h3><p>回退并尽可能创建多次提交。约定式提交的好处之一是能够促使我们做出更有组织的提交和 PR。</p><h3 id="这不会阻碍快速开发和迭代吗？"><a href="#这不会阻碍快速开发和迭代吗？" class="headerlink" title="这不会阻碍快速开发和迭代吗？"></a>这不会阻碍快速开发和迭代吗？</h3><p>它阻碍的是以杂乱无章的方式快速前进。它助你能在横跨多个项目以及和多个贡献者协作时长期地快速演进。</p><h3 id="约定式提交会让开发者受限于提交的类型吗（因为他们会想着已提供的类型）？"><a href="#约定式提交会让开发者受限于提交的类型吗（因为他们会想着已提供的类型）？" class="headerlink" title="约定式提交会让开发者受限于提交的类型吗（因为他们会想着已提供的类型）？"></a>约定式提交会让开发者受限于提交的类型吗（因为他们会想着已提供的类型）？</h3><p>约定式提交鼓励我们更多地使用某些类型的提交，比如 <code>fixes</code>。除此之外，约定式提交的灵活性也允许你的团队使用自己的类型，并随着时间的推移更改这些类型。</p><h3 id="这和-SemVer-有什么关联呢？"><a href="#这和-SemVer-有什么关联呢？" class="headerlink" title="这和 SemVer 有什么关联呢？"></a>这和 SemVer 有什么关联呢？</h3><p><code>fix</code> 类型提交应当对应到 <code>PATCH</code> 版本。<code>feat</code> 类型提交应该对应到 <code>MINOR</code> 版本。带有 <code>BREAKING CHANGE</code> 的提交不管类型如何，都应该对应到 <code>MAJOR</code> 版本。</p><h3 id="我对约定式提交做了形如-jameswomack-conventional-commit-spec-的扩展，该如何版本化管理这些扩展呢？"><a href="#我对约定式提交做了形如-jameswomack-conventional-commit-spec-的扩展，该如何版本化管理这些扩展呢？" class="headerlink" title="我对约定式提交做了形如 @jameswomack/conventional-commit-spec 的扩展，该如何版本化管理这些扩展呢？"></a>我对约定式提交做了形如 <code>@jameswomack/conventional-commit-spec</code> 的扩展，该如何版本化管理这些扩展呢？</h3><p>我们推荐使用 SemVer 来发布你对于这个规范的扩展（并鼓励你创建这些扩展！）</p><h3 id="如果我不小心使用了错误的提交类型，该怎么办呢？"><a href="#如果我不小心使用了错误的提交类型，该怎么办呢？" class="headerlink" title="如果我不小心使用了错误的提交类型，该怎么办呢？"></a>如果我不小心使用了错误的提交类型，该怎么办呢？</h3><h4 id="当你使用了在规范中但错误的类型时，例如将-feat-写成了-fix"><a href="#当你使用了在规范中但错误的类型时，例如将-feat-写成了-fix" class="headerlink" title="当你使用了在规范中但错误的类型时，例如将 feat 写成了 fix"></a>当你使用了在规范中但错误的类型时，例如将 <code>feat</code> 写成了 <code>fix</code></h4><p>在合并或发布这个错误之前，我们建议使用 <code>git rebase -i</code> 来编辑提交历史。而在发布之后，根据你使用的工具和流程不同，会有不同的清理方案。</p><h4 id="当使用了-不在-规范中的类型时，例如将-feat-写成了-feet"><a href="#当使用了-不在-规范中的类型时，例如将-feat-写成了-feet" class="headerlink" title="当使用了 不在 规范中的类型时，例如将 feat 写成了 feet"></a>当使用了 <em>不在</em> 规范中的类型时，例如将 <code>feat</code> 写成了 <code>feet</code></h4><p>在最坏的场景下，即便提交没有满足约定式提交的规范，也不会是世界末日。这只意味着这个提交会被基于规范的工具错过而已。</p><h3 id="所有的贡献者都需要使用约定式提交规范吗？"><a href="#所有的贡献者都需要使用约定式提交规范吗？" class="headerlink" title="所有的贡献者都需要使用约定式提交规范吗？"></a>所有的贡献者都需要使用约定式提交规范吗？</h3><p>并不！如果你使用基于 squash 的 Git 工作流，主管维护者可以在合并时清理提交信息——这不会对普通提交者产生额外的负担。 有种常见的工作流是让 git 系统自动从 pull request 中 squash 出提交，并向主管维护者提供一份表单，用以在合并时输入合适的 git 提交信息。</p><h3 id="约定式提交规范中如何处理还原（revert）提交"><a href="#约定式提交规范中如何处理还原（revert）提交" class="headerlink" title="约定式提交规范中如何处理还原（revert）提交?"></a>约定式提交规范中如何处理还原（revert）提交?</h3><p>还原提交（Reverting）会比较复杂：你还原的是多个提交吗？如果你还原了一个功能模块，下次发布的应该是补丁吗？</p><p>约定式提交不能明确的定义还原行为。所以我们把这个问题留给工具开发者， 基于 <em>类型</em> 和 <em>脚注</em> 的灵活性来开发他们自己的还原处理逻辑。</p><p>一种建议是使用 <code>revert</code> 类型，和一个指向被还原提交摘要的脚注：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: let us never again speak of the noodle incident</span><br><span class="line"></span><br><span class="line">Refs: 676104e, a215868</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git基础&quot;&gt;&lt;a href=&quot;#Git基础&quot; class=&quot;headerlink&quot; title=&quot;Git基础&quot;&gt;&lt;/a&gt;Git基础&lt;/h1&gt;&lt;h2 id=&quot;Git-amp-GitHub&quot;&gt;&lt;a href=&quot;#Git-amp-GitHub&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Git" scheme="https://lesliewaong.top/categories/Git/"/>
    
    
    <category term="Git" scheme="https://lesliewaong.top/tags/Git/"/>
    
    <category term="GitHub" scheme="https://lesliewaong.top/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>React Router 5</title>
    <link href="https://lesliewaong.top/posts/a66a21e1.html"/>
    <id>https://lesliewaong.top/posts/a66a21e1.html</id>
    <published>2022-06-03T05:11:52.000Z</published>
    <updated>2022-07-09T11:29:25.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-路由"><a href="#React-路由" class="headerlink" title="React 路由"></a>React 路由</h1><h2 id="相关理解"><a href="#相关理解" class="headerlink" title="相关理解"></a>相关理解</h2><h3 id="SPA的理解"><a href="#SPA的理解" class="headerlink" title="SPA的理解"></a>SPA的理解</h3><ul><li>单页Web应用（single page web application，SPA）。</li><li>整个应用只有<strong>一个完整的页面</strong>。</li><li>点击页面中的链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部更新。</strong></li><li>数据都需要通过ajax请求获取, 并在前端异步展现。</li></ul><h3 id="路由的理解"><a href="#路由的理解" class="headerlink" title="路由的理解"></a>路由的理解</h3><h4 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由?"></a>什么是路由?</h4><ol><li>一个路由就是一个映射关系(<code>key:value</code>)</li><li>key为<strong>路径</strong>, value可能是<code>function</code>或<code>component</code></li></ol><h4 id="路由分类"><a href="#路由分类" class="headerlink" title="路由分类"></a>路由分类</h4><h5 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h5><ol><li>理解： value是function, 用来处理客户端提交的请求。</li><li>注册路由： <code>router.get(path, function(req, res))</code></li><li>工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据</li></ol><h5 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h5><ol><li>浏览器端路由，value是component，用于展示页面内容。</li><li>注册路由: <code>&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</code></li><li>工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件</li></ol><h3 id="react-router-dom的理解"><a href="#react-router-dom的理解" class="headerlink" title="react-router-dom的理解"></a>react-router-dom的理解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add react-router-dom</span><br></pre></td></tr></table></figure><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ol><li>react的一个插件库。</li><li>专门用来实现一个SPA应用。</li><li>基于react的项目基本都会用到此库。</li></ol><h4 id="相关api"><a href="#相关api" class="headerlink" title="相关api"></a>相关api</h4><h5 id="1、内置组件"><a href="#1、内置组件" class="headerlink" title="1、内置组件"></a>1、内置组件</h5><ol><li><code>&lt;BrowserRouter&gt;</code></li><li><code>&lt;HashRouter&gt;</code></li><li><code>&lt;Route&gt;</code></li><li><code>&lt;Redirect&gt;</code></li><li><code>&lt;Link&gt;</code></li><li><code>&lt;NavLink&gt;</code></li><li><code>&lt;Switch&gt;</code></li></ol><h5 id="2、其他"><a href="#2、其他" class="headerlink" title="2、其他"></a>2、其他</h5><ol><li>history对象</li><li>match对象</li><li>withRouter函数</li></ol><h2 id="路由的基本使用"><a href="#路由的基本使用" class="headerlink" title="路由的基本使用"></a>路由的基本使用</h2><p>1.明确好界面中的导航区、展示区</p><p>2.导航区的a标签改为Link标签</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">&quot;/xxxxx&quot;</span>&gt;Demo&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>3.展示区写Route标签进行路径的匹配</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&#x27;/xxxx&#x27;</span> component=&#123;Demo&#125;/&gt;</span><br></pre></td></tr></table></figure><p>4.<code>&lt;App&gt;</code>的最外侧包裹了一个<code>&lt;BrowserRouter&gt;或&lt;HashRouter&gt;</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span>,</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="路由组件与一般组件"><a href="#路由组件与一般组件" class="headerlink" title="路由组件与一般组件"></a>路由组件与一般组件</h2><ol><li>写法不同：</li></ol><p> 一般组件：<code>&lt;Demo/&gt;</code></p><p> 路由组件：<code>&lt;Route path=&quot;/demo&quot; component=&#123;Demo&#125;/&gt;</code></p><ol start="2"><li>存放位置不同：</li></ol><p> 一般组件：<strong>components</strong></p><p> 路由组件：<strong>pages</strong></p><ol start="3"><li>接收到的props不同：</li></ol><p>​    一般组件：写组件标签时传递了什么，就能收到什么</p><p>​    路由组件：接收到三个固定的属性</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路由属性打印结果展示</span></span><br><span class="line"><span class="attr">history</span>:</span><br><span class="line">go: ƒ go(n)</span><br><span class="line"><span class="attr">goBack</span>: ƒ goBack()</span><br><span class="line"><span class="attr">goForward</span>: ƒ goForward()</span><br><span class="line"><span class="attr">push</span>: ƒ push(path, state)</span><br><span class="line"><span class="attr">replace</span>: ƒ replace(path, state)</span><br><span class="line"><span class="attr">location</span>:</span><br><span class="line">pathname: <span class="string">&quot;/about&quot;</span></span><br><span class="line"><span class="attr">search</span>: <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">state</span>: <span class="literal">undefined</span></span><br><span class="line"><span class="attr">match</span>:</span><br><span class="line">params: &#123;&#125;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;/about&quot;</span></span><br><span class="line"><span class="attr">url</span>: <span class="string">&quot;/about&quot;</span></span><br></pre></td></tr></table></figure><h2 id="NavLink使用与封装"><a href="#NavLink使用与封装" class="headerlink" title="NavLink使用与封装"></a>NavLink使用与封装</h2><ol><li>NavLink可以实现路由链接的高亮，通过<code>activeClassName</code>指定样式名</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;NavLink,Route&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line">&#123;<span class="comment">/* 原生html中，靠&lt;a&gt;跳转不同的页面 */</span>&#125;</span><br><span class="line">&#123;<span class="comment">/* &lt;a className=&quot;list-group-item&quot; href=&quot;./about.html&quot;&gt;About&lt;/a&gt;</span></span><br><span class="line"><span class="comment">&lt;a className=&quot;list-group-item active&quot; href=&quot;./home.html&quot;&gt;Home&lt;/a&gt; */</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* 在React中靠路由链接实现切换组件--编写路由链接 */</span>&#125;</span><br><span class="line">&lt;NavLink activeClassName=<span class="string">&quot;atguigu&quot;</span> className=<span class="string">&quot;list-group-item&quot;</span> to=<span class="string">&quot;/about&quot;</span>&gt;About&lt;/NavLink&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">activeClassName</span>=<span class="string">&quot;atguigu&quot;</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>react脚手架<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;%PUBLIC_URL%/favicon.ico&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/css/bootstrap.css&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="selector-class">.atguigu</span>&#123;</span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">209</span>, <span class="number">137</span>, <span class="number">4</span>) <span class="meta">!important</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="attribute">color</span>: white <span class="meta">!important</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>封装</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装示例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNavLink</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">activeClassName</span>=<span class="string">&quot;atguigu&quot;</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用与调用</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyNavLink to=<span class="string">&quot;/about&quot;</span>&gt;About&lt;/MyNavLink&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">MyNavLink</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">MyNavLink</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>注：<strong>标签体内容也是一种特殊的标签属性</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyNavLink to=<span class="string">&quot;/about&quot;</span>&gt;About&lt;/MyNavLink&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">MyNavLink</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">children</span>=<span class="string">&quot;About&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="Switch的使用"><a href="#Switch的使用" class="headerlink" title="Switch的使用"></a>Switch的使用</h2><p>1.通常情况下，path和component是一一对应的关系。</p><p>2.Switch可以提高路由匹配效率(单一匹配) —- 即<strong>匹配到一个后将不再往下匹配</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Test&#125;/</span>&gt;</span></span></span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><h2 id="解决多级路径刷新页面样式丢失的问题"><a href="#解决多级路径刷新页面样式丢失的问题" class="headerlink" title="解决多级路径刷新页面样式丢失的问题"></a>解决多级路径刷新页面样式丢失的问题</h2><p>1.<code>public/index.html</code> 中 引入样式时不写 <code>./</code> 写 <code>/</code> （常用）<code>./</code>相对路径</p><p>2.public/index.html 中 引入样式时不写 ./ 写 <code>%PUBLIC_URL%</code> （常用,但<code>只在react中</code>有效果）绝对路径</p><p>3.使用<code>HashRouter</code> (不常用) <code>#</code>后面自动忽略</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>react脚手架<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 方法二 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;%PUBLIC_URL%/favicon.ico&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 方法一 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/css/bootstrap.css&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>补充：<code>yarn start</code>和<code>npm start</code>都可，但安装包时尽量用一种</p><h2 id="路由的严格匹配与模糊匹配"><a href="#路由的严格匹配与模糊匹配" class="headerlink" title="路由的严格匹配与模糊匹配"></a>路由的严格匹配与模糊匹配</h2><ol><li>默认使用的是模糊匹配（简单记：【输入的路径】必须包含要【匹配的路径】，且<strong>顺序</strong>要一致）</li><li>开启严格匹配：<code>&lt;Route exact=&#123;true&#125;path=&quot;/about&quot; component=&#123;About&#125;/&gt;</code></li></ol><p>​    可以省略<code>exact=&#123;true&#125;</code>为<code>exact</code></p><ol start="3"><li><strong>严格匹配不要随便开启，需要再开，有些时候开启会导致无法继续匹配二级路由</strong></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyNavLink to=<span class="string">&quot;/about&quot;</span>&gt;About&lt;/MyNavLink&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">MyNavLink</span> <span class="attr">to</span>=<span class="string">&quot;/home/a/b&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">MyNavLink</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="Redirect的使用"><a href="#Redirect的使用" class="headerlink" title="Redirect的使用"></a>Redirect的使用</h2><ol><li>一般写在所有路由注册的最下方，<strong>当所有路由都无法匹配时</strong>，跳转到Redirect指定的路由</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Route,Switch,Redirect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>具体编码：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;/</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>/&gt;</span></span></span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><ol><li>注册子路由时要<strong>写上父路由的path值</strong></li><li>路由的匹配是按照注册路由的顺序进行的</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-------------------注册一级路由-----------------------------</span><br><span class="line">&#123;<span class="comment">/* 在React中靠路由链接实现切换组件--编写路由链接 */</span>&#125;</span><br><span class="line">&lt;MyNavLink to=<span class="string">&quot;/about&quot;</span>&gt;About&lt;/MyNavLink&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">MyNavLink</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">MyNavLink</span>&gt;</span></span></span><br><span class="line">&#123;<span class="comment">/* 注册路由 */</span>&#125;</span><br><span class="line">&lt;Switch&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;/</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>/&gt;</span></span></span><br><span class="line">&lt;/Switch&gt;</span><br><span class="line">----------------------注册二级路由 :Home组件-----------------------------------</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">&quot;nav nav-tabs&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">MyNavLink</span> <span class="attr">to</span>=<span class="string">&quot;/home/news&quot;</span>&gt;</span>News<span class="tag">&lt;/<span class="name">MyNavLink</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">MyNavLink</span> <span class="attr">to</span>=<span class="string">&quot;/home/message&quot;</span>&gt;</span>Message<span class="tag">&lt;/<span class="name">MyNavLink</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;/* 注册路由 */&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home/news&quot;</span> <span class="attr">component</span>=<span class="string">&#123;News&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home/message&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Message&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/home/news&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="向路由组件传递参数"><a href="#向路由组件传递参数" class="headerlink" title="向路由组件传递参数"></a>向路由组件传递参数</h2><h3 id="params参数"><a href="#params参数" class="headerlink" title="params参数"></a>params参数</h3><ol><li>路由链接(携带参数)：<code>&lt;Link to=&#39;/demo/test/tom/18&#39;&#125;&gt;详情&lt;/Link&gt;</code></li><li>注册路由(声明接收)：<code>&lt;Route path=&quot;/demo/test/:name/:age&quot; component=&#123;Test&#125;/&gt;</code></li><li>接收参数：<code>this.props.match.params</code>（<strong>子组件</strong>）</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------发送参数:父组件----------------------------------------------</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">   &#123;/* 向路由组件传递params参数 */&#125;</span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">home</span>/<span class="attr">message</span>/<span class="attr">detail</span>/$&#123;<span class="attr">msgObj.id</span>&#125;/$&#123;<span class="attr">msgObj.title</span>&#125;`&#125;&gt;</span>&#123;msgObj.title&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="xml">   &#123;/* 声明接收params参数 */&#125;</span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home/message/detail/:id/:title&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Detail&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">--------------------------------接受参数:子组件-----------------------------------------------------------</span><br><span class="line"><span class="keyword">const</span> &#123;id,title&#125; = <span class="built_in">this</span>.props.match.params</span><br></pre></td></tr></table></figure><p>优势： 刷新地址栏，参数依然存在</p><p>缺点：只能传字符串，并且，如果传的值太多的话，url会变得长而丑陋。</p><h3 id="search参数"><a href="#search参数" class="headerlink" title="search参数"></a>search参数</h3><ol><li>路由链接(携带参数)：<code>&lt;Link to=&#39;/demo/test?name=tom&amp;age=18&#39;&#125;&gt;详情&lt;/Link&gt;</code></li><li>注册路由(<code>无需声明</code>，正常注册即可)：<code>&lt;Route path=&quot;/demo/test&quot; component=&#123;Test&#125;/&gt;</code></li><li>接收参数：<code>this.props.location.search</code></li><li>备注：获取到的search是<code>urlencoded编码字符串</code>，需要<code>借助querystring解析</code></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------发送参数:父组件----------------------------------------------</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;/* 向路由组件传递search参数 */&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">home</span>/<span class="attr">message</span>/<span class="attr">detail</span>/?<span class="attr">id</span>=<span class="string">$&#123;msgObj.id&#125;&amp;title</span>=<span class="string">$&#123;msgObj.title&#125;</span>`&#125;&gt;</span>&#123;msgObj.title&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="xml">     &#123;/* search参数无需声明接收，正常注册路由即可 */&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home/message/detail&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Detail&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">--------------------------------接受参数:子组件-----------------------------------------------------------</span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">&#x27;querystring&#x27;</span></span><br><span class="line"><span class="comment">// 接收search参数</span></span><br><span class="line"><span class="keyword">const</span> &#123;search&#125; = <span class="built_in">this</span>.props.location</span><br><span class="line"><span class="keyword">const</span> &#123;id,title&#125; = qs.parse(search.slice(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>优势： 刷新地址栏，参数依然存在</p><p>缺点：只能传字符串，并且，如果传的值太多的话，url会变得长而丑陋。</p><h3 id="state参数"><a href="#state参数" class="headerlink" title="state参数"></a>state参数</h3><ol><li>路由链接(携带参数)：<code>&lt;Link to=&#123;&#123;pathname:'/demo/test',state:&#123;name:'tom',age:18&#125;&#125;&#125;&gt;详情&lt;/Link&gt;</code></li><li>注册路由(无需声明，正常注册即可)：<code>&lt;Route path=&quot;/demo/test&quot; component=&#123;Test&#125;/&gt;</code></li><li>接收参数：<code>this.props.location.state</code></li></ol><ul><li>备注：使用<code>BrowserRouter</code>刷新才可以<code>保留住参数</code>,使用<code>HashRouter</code>刷新后state将会没有<code>history</code>来保存参数</li><li>子组件接受参数时<code>const &#123;id,title&#125; = this.props.location.state || &#123;&#125;</code> ,后面添加<code>||&#123;&#125;</code>是防止state为undefined时报错</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------发送参数:父组件----------------------------------------------</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">   &#123;/* 向路由组件传递state参数 */&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;&#123;pathname:</span>&#x27;/<span class="attr">home</span>/<span class="attr">message</span>/<span class="attr">detail</span>&#x27;,<span class="attr">state:</span>&#123;<span class="attr">id:msgObj.id</span>,<span class="attr">title:msgObj.title</span>&#125;&#125;&#125;&gt;</span>&#123;msgObj.title&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="xml">     &#123;/* state参数无需声明接收，正常注册路由即可 */&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home/message/detail&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Detail&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">--------------------------------接受参数:子组件-----------------------------------------------------------</span><br><span class="line"><span class="comment">// 接收state参数,后面添加`||&#123;&#125;`是防止state为undefined时报错</span></span><br><span class="line"><span class="keyword">const</span> &#123;id,title&#125; = <span class="built_in">this</span>.props.location.state || &#123;&#125;</span><br></pre></td></tr></table></figure><p>优势：传参优雅，传递参数可传对象；</p><p>缺点：刷新地址栏， HashRouter可能会丢失参数</p><h2 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h2><p>借助<code>this.prosp.history</code>对象上的API对操作路由跳转、前进、后退</p><ol><li><code>this.prosp.history.push()</code></li></ol><p>​    将历史记录压入栈</p><ol start="2"><li><code>this.props.history.replace()</code></li></ol><p>​    替代栈位置,即不会产生历史记录</p><ol start="3"><li><code>this.props.history.goBack()</code></li></ol><p>​    回退一格</p><ol start="4"><li><code>this.props.history.goForward()</code></li></ol><p>​    前进一格</p><ol start="5"><li><code>this.props.history.go()</code></li></ol><p>​    前进或者后退n格(根据传入的数字正负数)</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Link, Route &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Detail <span class="keyword">from</span> <span class="string">&#x27;./Detail&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> state = &#123;</span><br><span class="line">   <span class="attr">messageArr</span>: [</span><br><span class="line">     &#123; <span class="attr">id</span>: <span class="string">&#x27;01&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;消息1&#x27;</span> &#125;,</span><br><span class="line">     &#123; <span class="attr">id</span>: <span class="string">&#x27;02&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;消息2&#x27;</span> &#125;,</span><br><span class="line">     &#123; <span class="attr">id</span>: <span class="string">&#x27;03&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;消息3&#x27;</span> &#125;,</span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> replaceShow = <span class="function">(<span class="params">id, title</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">//replace跳转+携带params参数</span></span><br><span class="line">   <span class="comment">//this.props.history.replace(`/home/message/detail/$&#123;id&#125;/$&#123;title&#125;`)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//replace跳转+携带search参数</span></span><br><span class="line">   <span class="comment">// this.props.history.replace(`/home/message/detail?id=$&#123;id&#125;&amp;title=$&#123;title&#125;`)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//replace跳转+携带state参数</span></span><br><span class="line">   <span class="built_in">this</span>.props.history.replace(<span class="string">`/home/message/detail`</span>, &#123; id, title &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> pushShow = <span class="function">(<span class="params">id, title</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">//push跳转+携带params参数</span></span><br><span class="line">   <span class="comment">// this.props.history.push(`/home/message/detail/$&#123;id&#125;/$&#123;title&#125;`)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//push跳转+携带search参数</span></span><br><span class="line">   <span class="comment">// this.props.history.push(`/home/message/detail?id=$&#123;id&#125;&amp;title=$&#123;title&#125;`)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//push跳转+携带state参数</span></span><br><span class="line">   <span class="built_in">this</span>.props.history.push(<span class="string">`/home/message/detail`</span>, &#123; id, title &#125;)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> back = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.props.history.goBack()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> forward = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.props.history.goForward()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> go = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.props.history.go(-<span class="number">2</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; messageArr &#125; = <span class="built_in">this</span>.state</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">         &#123;</span></span><br><span class="line"><span class="xml">           messageArr.map((msgObj) =&gt; &#123;</span></span><br><span class="line"><span class="xml">             return (</span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;msgObj.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">                 &#123;/* 向路由组件传递params参数 */&#125;</span></span><br><span class="line"><span class="xml">                 &#123;/* <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">home</span>/<span class="attr">message</span>/<span class="attr">detail</span>/$&#123;<span class="attr">msgObj.id</span>&#125;/$&#123;<span class="attr">msgObj.title</span>&#125;`&#125;&gt;</span>&#123;msgObj.title&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span> */&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">                 &#123;/* 向路由组件传递search参数 */&#125;</span></span><br><span class="line"><span class="xml">                 &#123;/* <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">home</span>/<span class="attr">message</span>/<span class="attr">detail</span>/?<span class="attr">id</span>=<span class="string">$&#123;msgObj.id&#125;&amp;title</span>=<span class="string">$&#123;msgObj.title&#125;</span>`&#125;&gt;</span>&#123;msgObj.title&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span> */&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">                 &#123;/* 向路由组件传递state参数 */&#125;</span></span><br><span class="line"><span class="xml">                 <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;&#123;</span> <span class="attr">pathname:</span> &#x27;/<span class="attr">home</span>/<span class="attr">message</span>/<span class="attr">detail</span>&#x27;, <span class="attr">state:</span> &#123; <span class="attr">id:</span> <span class="attr">msgObj.id</span>, <span class="attr">title:</span> <span class="attr">msgObj.title</span> &#125; &#125;&#125;&gt;</span>&#123;msgObj.title&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.pushShow(msgObj.id, msgObj.title)&#125;&gt;push查看<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.replaceShow(msgObj.id, msgObj.title)&#125;&gt;replace查看<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">             )</span></span><br><span class="line"><span class="xml">           &#125;)</span></span><br><span class="line"><span class="xml">         &#125;</span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="xml">       &#123;/* 声明接收params参数 */&#125;</span></span><br><span class="line"><span class="xml">       &#123;/* <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home/message/detail/:id/:title&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Detail&#125;/</span>&gt;</span> */&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">       &#123;/* search参数无需声明接收，正常注册路由即可 */&#125;</span></span><br><span class="line"><span class="xml">       &#123;/* <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home/message/detail&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Detail&#125;/</span>&gt;</span> */&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">       &#123;/* state参数无需声明接收，正常注册路由即可 */&#125;</span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home/message/detail&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Detail&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.back&#125;</span>&gt;</span>回退<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="symbol">&amp;nbsp;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.forward&#125;</span>&gt;</span>前进<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="symbol">&amp;nbsp;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.go&#125;</span>&gt;</span>go<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="withRouter的使用"><a href="#withRouter的使用" class="headerlink" title="withRouter的使用"></a>withRouter的使用</h2><ol><li><strong>withRouter可以加工一般组件，让一般组件具备路由组件所特有的API</strong></li><li>withRouter的返回值是一个新组件</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    back = <span class="function">() =&gt;</span> &#123; <span class="built_in">this</span>.props.history.goBack()&#125;</span><br><span class="line">    forward = <span class="function">() =&gt;</span> &#123;<span class="built_in">this</span>.props.history.goForward()&#125;</span><br><span class="line">    go = <span class="function">() =&gt;</span> &#123; <span class="built_in">this</span>.props.history.go(-<span class="number">2</span>)&#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Header组件收到的props是&#x27;</span>, <span class="built_in">this</span>.props);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>React Router Demo<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.back&#125;</span>&gt;</span>回退<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="symbol">&amp;nbsp;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.forward&#125;</span>&gt;</span>前进<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="symbol">&amp;nbsp;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.go&#125;</span>&gt;</span>go<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Header)</span><br></pre></td></tr></table></figure><h2 id="BrowserRouter与HashRouter的区别"><a href="#BrowserRouter与HashRouter的区别" class="headerlink" title="BrowserRouter与HashRouter的区别"></a>BrowserRouter与HashRouter的区别</h2><p><strong>底层原理不一样</strong>：</p><ol><li>BrowserRouter使用的是<strong>H5的history API</strong>，不兼容IE9及以下版本。<code>但一般来说都用的这个</code></li><li>HashRouter使用的是<strong>URL的哈希值</strong>。</li></ol><p><strong>path表现形式不一样</strong></p><ol><li>BrowserRouter的路径中没有<code>#</code>,例如：<code>localhost:3000/demo/test</code></li><li>HashRouter的路径包含<code>#</code>,例如：<code>localhost:3000/#/demo/test</code></li></ol><p><strong>刷新后对路由state参数的影响</strong></p><ol><li>BrowserRouter没有任何影响，因为<code>state</code>保存在<code>history</code>对象中。</li><li>HashRouter<code>刷新后会导致路由state参数的丢失！！！</code>(不一定)</li></ol><p><strong>备注：HashRouter可以用于解决一些路径错误相关的问题。</strong></p><p>每个 React Router 应用程序的核心都应该是一个路由组件。对于 web 项目，<code>react-router-dom</code>提供<code>&lt;BrowserRouter&gt;</code>和<code>&lt;HashRouter&gt;</code>路由器。两者之间的主要区别在于它们存储 URL 以及与您的 Web 服务器通信的方式。</p><ul><li><code>&lt;BrowserRouter&gt;</code>使用常规 URL 路径。这些通常是最好看的 URL，<strong>但它们需要正确配置您的服务器</strong>。具体来说，你的 Web 服务器需要在所有由 React Router 管理的客户端提供相同的页面。Create React App 在开发中开箱即用地支持这一点，并<a href="https://create-react-app.dev/docs/deployment#serving-apps-with-client-side-routing">附带</a>有关如何配置生产服务器的说明。</li><li><code>&lt;HashRouter&gt;</code>将当前位置存储在URL的<code>hash</code>一部分中，因此 URL 看起来像<code>http://example.com/#/your/page</code>. 由于哈希永远不会发送到服务器，这意味着<strong>不需要特殊的服务器配置</strong>。</li></ul><h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><h3 id="useHistory"><a href="#useHistory" class="headerlink" title="useHistory"></a>useHistory</h3><p>该<code>useHistory</code>挂钩使您可以访问<code>history</code>可用于导航的实例。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useHistory &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomeButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> history = useHistory();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    history.push(<span class="string">&quot;/home&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      Go home</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useLocation"><a href="#useLocation" class="headerlink" title="useLocation"></a>useLocation</h3><p>该<code>useLocation</code>钩子返回<code>location</code>表示当前 URL 的对象。您可以将其视为每当 URL 更改时<code>useState</code>返回一个新的。<code>location</code></p><p>这可能非常有用，例如，当您希望在新页面加载时使用 Web 分析工具触发新的“页面查看”事件时，如下例所示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  BrowserRouter <span class="keyword">as</span> Router,</span><br><span class="line">  Switch,</span><br><span class="line">  useLocation</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usePageViews</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> location = useLocation();</span><br><span class="line">  React.useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ga.send([<span class="string">&quot;pageview&quot;</span>, location.pathname]);</span><br><span class="line">  &#125;, [location]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  usePageViews();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span>...<span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span>,</span><br><span class="line">  node</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="useParams"><a href="#useParams" class="headerlink" title="useParams"></a>useParams</h3><p><code>useParams</code>返回 URL 参数的键/值对的对象。用它来访问<code>match.params</code>当前的<code>&lt;Route&gt;</code>.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  BrowserRouter <span class="keyword">as</span> Router,</span><br><span class="line">  Switch,</span><br><span class="line">  Route,</span><br><span class="line">  useParams</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlogPost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; slug &#125; = useParams();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Now showing post &#123;slug&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">HomePage</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/blog/:slug&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">BlogPost</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span>,</span><br><span class="line">  node</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React-路由&quot;&gt;&lt;a href=&quot;#React-路由&quot; class=&quot;headerlink&quot; title=&quot;React 路由&quot;&gt;&lt;/a&gt;React 路由&lt;/h1&gt;&lt;h2 id=&quot;相关理解&quot;&gt;&lt;a href=&quot;#相关理解&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="React" scheme="https://lesliewaong.top/categories/React/"/>
    
    
    <category term="React" scheme="https://lesliewaong.top/tags/React/"/>
    
    <category term="Router" scheme="https://lesliewaong.top/tags/Router/"/>
    
  </entry>
  
  <entry>
    <title>React Router 6</title>
    <link href="https://lesliewaong.top/posts/3f63705b.html"/>
    <id>https://lesliewaong.top/posts/3f63705b.html</id>
    <published>2022-06-02T05:14:52.000Z</published>
    <updated>2022-07-09T11:29:25.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Router-6-快速上手"><a href="#React-Router-6-快速上手" class="headerlink" title="React Router 6 快速上手"></a>React Router 6 快速上手</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>React Router 以三个不同的包发布到 npm 上，它们分别为：</p><ol><li>react-router: 路由的核心库，提供了很多的：组件、钩子。</li><li><strong style="color:#dd4d40"><strong>react-router-dom:</strong></strong > <strong style="color:#dd4d40">包含react-router所有内容，并添加一些专门用于 DOM 的组件，例如 <code>&lt;BrowserRouter&gt;</code>等 </strong>。</li><li>react-router-native: 包括react-router所有内容，并添加一些专门用于ReactNative的API，例如:<code>&lt;NativeRouter&gt;</code>等。</li></ol></li><li><p>与React Router 5.x 版本相比，改变了什么？</p><ol><li><p>内置组件的变化：移除<code>&lt;Switch/&gt;</code> ，新增 <code>&lt;Routes/&gt;</code>等。</p></li><li><p>语法的变化：<code>component=&#123;About&#125;</code> 变为 <code>element=&#123;&lt;About/&gt;&#125;</code>等。</p></li><li><p>新增多个hook：<code>useParams</code>、<code>useNavigate</code>、<code>useMatch</code>等。</p></li><li><p><strong style="color:#dd4d40">官方明确推荐函数式组件了！！！</strong></p><p>……</p></li></ol></li></ol><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><h3 id="lt-BrowserRouter-gt"><a href="#lt-BrowserRouter-gt" class="headerlink" title="&lt;BrowserRouter&gt;"></a><code>&lt;BrowserRouter&gt;</code></h3><ol><li><p>说明：<code>&lt;BrowserRouter&gt; </code>用于包裹整个应用。</p></li><li><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;/* 整体结构（通常为App组件） */&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span>,root</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><h3 id="lt-HashRouter-gt"><a href="#lt-HashRouter-gt" class="headerlink" title="&lt;HashRouter&gt;"></a><code>&lt;HashRouter&gt;</code></h3><ol><li>说明：作用与<code>&lt;BrowserRouter&gt;</code>一样，但<code>&lt;HashRouter&gt;</code>修改的是地址栏的hash值。</li><li>备注：6.x版本中<code>&lt;HashRouter&gt;</code>、<code>&lt;BrowserRouter&gt; </code> 的用法与 5.x 相同。</li></ol><h3 id="lt-Routes-gt-与-lt-Route-gt"><a href="#lt-Routes-gt-与-lt-Route-gt" class="headerlink" title="&lt;Routes/&gt; 与 &lt;Route/&gt;"></a><code>&lt;Routes/&gt; 与 &lt;Route/&gt;</code></h3><ol><li><p>v6版本中移出了先前的<code>&lt;Switch&gt;</code>，引入了新的替代者：<code>&lt;Routes&gt;</code>。</p></li><li><p><code>&lt;Routes&gt;</code> 和 <code>&lt;Route&gt;</code>要配合使用，且必须要用<code>&lt;Routes&gt;</code>包裹<code>&lt;Route&gt;</code>。</p></li><li><p><code>&lt;Route&gt;</code> 相当于一个 if 语句，如果其路径与当前 URL 匹配，则呈现其对应的组件。</p></li><li><p> <code>&lt;Route caseSensitive&gt;</code> 属性用于指定：匹配时是否区分大小写（默认为 false）。</p></li><li><p>当URL发生变化时，<code>&lt;Routes&gt; </code>都会查看其所有子<code> &lt;Route&gt;</code> 元素以找到最佳匹配并呈现组件 。</p></li><li><p> <code>&lt;Route&gt;</code> 也可以嵌套使用，且可配合<code>useRoutes()</code>配置 “路由表” ，但需要通过 <code>&lt;Outlet&gt;</code> 组件来渲染其子路由。</p></li><li><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Routes&gt;</span><br><span class="line">    <span class="comment">/*path属性用于定义路径，element属性用于定义当前路径所对应的组件*/</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Login</span> /&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于定义嵌套路由，home是一级路由，对应的路径/home*/</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;home&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">       /*test1 和 test2 是二级路由,对应的路径是/home/test1 或 /home/test2*/</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;test1&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Test</span>/&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;test2&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Test2</span>/&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Route也可以不写element属性, 这时就是用于展示嵌套的路由 .所对应的路径是/users/xxx</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;users&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Demo</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/Routes&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="lt-Link-gt"><a href="#lt-Link-gt" class="headerlink" title="&lt;Link&gt;"></a><code>&lt;Link&gt;</code></h3><ol><li><p>作用: 修改URL，且不发送网络请求（路由链接）。</p></li><li><p>注意: 外侧需要用<code>&lt;BrowserRouter&gt;</code>或<code>&lt;HashRouter&gt;</code>包裹。</p></li><li><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/路径&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="lt-NavLink-gt"><a href="#lt-NavLink-gt" class="headerlink" title="&lt;NavLink&gt;"></a><code>&lt;NavLink&gt;</code></h3><ol><li><p>作用: 与<code>&lt;Link&gt;</code>组件类似，且可实现导航的“高亮”效果。</p></li><li><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: NavLink默认类名是active，下面是指定自定义的class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义样式</span></span><br><span class="line">&lt;NavLink</span><br><span class="line">    to=<span class="string">&quot;login&quot;</span></span><br><span class="line">    className=&#123;<span class="function">(<span class="params">&#123; isActive &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;home&#x27;</span>, isActive)</span><br><span class="line">        <span class="keyword">return</span> isActive ? <span class="string">&#x27;base one&#x27;</span> : <span class="string">&#x27;base&#x27;</span></span><br><span class="line">    &#125;&#125;</span><br><span class="line">&gt;login&lt;/NavLink&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">默认情况下，当Home的子组件匹配成功，Home的导航也会高亮，</span></span><br><span class="line"><span class="comment">当NavLink上添加了end属性后，若Home的子组件匹配成功，则Home的导航没有高亮效果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;home&quot;</span> <span class="attr">end</span> &gt;</span>home<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><h3 id="lt-Navigate-gt"><a href="#lt-Navigate-gt" class="headerlink" title="&lt;Navigate&gt;"></a><code>&lt;Navigate&gt;</code></h3><ol><li><p>作用：只要<code>&lt;Navigate&gt;</code>组件被渲染，就会修改路径，切换视图。</p></li><li><p><code>replace</code>属性用于控制跳转模式（push 或 replace，默认是push）。</p></li><li><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;Navigate&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> [sum,setSum] = useState(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是Home的内容<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#123;/* 根据sum的值决定是否切换视图 */&#125;</span></span><br><span class="line"><span class="xml">&#123;sum === 1 ? <span class="tag">&lt;<span class="name">h4</span>&gt;</span>sum的值为&#123;sum&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span> : <span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">replace</span>=<span class="string">&#123;true&#125;/</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>setSum(2)&#125;&gt;点我将sum变为2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="lt-Outlet-gt"><a href="#lt-Outlet-gt" class="headerlink" title="&lt;Outlet&gt;"></a><code>&lt;Outlet&gt;</code></h3><ol><li><p>当<code>&lt;Route&gt;</code>产生嵌套时，渲染其对应的后续子路由。</p></li><li><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据路由表生成对应的路由规则</span></span><br><span class="line"><span class="keyword">const</span> element = useRoutes([</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">element</span>:<span class="xml"><span class="tag">&lt;<span class="name">About</span>/&gt;</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">element</span>:<span class="xml"><span class="tag">&lt;<span class="name">Home</span>/&gt;</span></span>,</span><br><span class="line">    children:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>:<span class="xml"><span class="tag">&lt;<span class="name">News</span>/&gt;</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>:<span class="xml"><span class="tag">&lt;<span class="name">Message</span>/&gt;</span></span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">//Home.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;NavLink,Outlet&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Home组件内容<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">&quot;nav nav-tabs&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&quot;news&quot;</span>&gt;</span>News<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">to</span>=<span class="string">&quot;message&quot;</span>&gt;</span>Message<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#123;/* 指定路由组件呈现的位置 */&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Outlet</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><h3 id="useRoutes"><a href="#useRoutes" class="headerlink" title="useRoutes()"></a>useRoutes()</h3><ol><li><p>作用：根据路由表，动态创建<code>&lt;Routes&gt;</code>和<code>&lt;Route&gt;</code>。</p></li><li><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路由表配置：src/routes/index.js</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;../pages/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../pages/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;Navigate&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line"><span class="attr">element</span>:<span class="xml"><span class="tag">&lt;<span class="name">About</span>/&gt;</span></span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">element</span>:<span class="xml"><span class="tag">&lt;<span class="name">Home</span>/&gt;</span></span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line"><span class="attr">element</span>:<span class="xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>/&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">//App.jsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;NavLink,useRoutes&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">&#x27;./routes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//根据路由表生成对应的路由规则</span></span><br><span class="line"><span class="keyword">const</span> element = useRoutes(routes)</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">......</span></span><br><span class="line"><span class="xml">      &#123;/* 注册路由 */&#125;</span></span><br><span class="line"><span class="xml">      &#123;element&#125;</span></span><br><span class="line"><span class="xml">  ......</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="useNavigate"><a href="#useNavigate" class="headerlink" title="useNavigate()"></a>useNavigate()</h3><ol><li><p>作用：返回一个函数用来实现编程式导航。</p></li><li><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;useNavigate&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> navigate = useNavigate()</span><br><span class="line">  <span class="keyword">const</span> handle = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//第一种使用方式：指定具体的路径</span></span><br><span class="line">    navigate(<span class="string">&#x27;/login&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">replace</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">state</span>: &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="comment">//第二种使用方式：传入数值进行前进或后退，类似于5.x中的 history.go()方法</span></span><br><span class="line">    navigate(-<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handle&#125;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="useParams"><a href="#useParams" class="headerlink" title="useParams()"></a>useParams()</h3><ol><li><p>作用：回当前匹配路由的<code>params</code>参数，类似于5.x中的<code>match.params</code>。</p></li><li><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Routes, Route, useParams &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&#x27;./pages/User.jsx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfilePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取URL中携带过来的params参数</span></span><br><span class="line">  <span class="keyword">let</span> &#123; id &#125; = useParams();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;users/:id&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">User</span> /&gt;</span>&#125;/&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="useSearchParams"><a href="#useSearchParams" class="headerlink" title="useSearchParams()"></a>useSearchParams()</h3><ol><li><p>作用：用于读取和修改当前位置的 URL 中的查询字符串。</p></li><li><p>返回一个包含两个值的数组，内容分别为：当前的seaech参数、更新search的函数。</p></li><li><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;useSearchParams&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Detail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> [search,setSearch] = useSearchParams()</span><br><span class="line"><span class="keyword">const</span> id = search.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> title = search.get(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> content = search.get(<span class="string">&#x27;content&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>setSearch(&#x27;id=008&amp;title=哈哈&amp;content=嘻嘻&#x27;)&#125;&gt;点我更新一下收到的search参数<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>消息编号：&#123;id&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>消息标题：&#123;title&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>消息内容：&#123;content&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="useLocation"><a href="#useLocation" class="headerlink" title="useLocation()"></a>useLocation()</h3><ol><li><p>作用：获取当前 location 信息，对标5.x中的路由组件的<code>location</code>属性。</p></li><li><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;useLocation&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Detail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> x = useLocation()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;@&#x27;</span>,x)</span><br><span class="line">  <span class="comment">// x就是location对象: </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">      hash: &quot;&quot;,</span></span><br><span class="line"><span class="comment">      key: &quot;ah9nv6sz&quot;,</span></span><br><span class="line"><span class="comment">      pathname: &quot;/login&quot;,</span></span><br><span class="line"><span class="comment">      search: &quot;?name=zs&amp;age=18&quot;,</span></span><br><span class="line"><span class="comment">      state: &#123;a: 1, b: 2&#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>消息编号：&#123;id&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>消息标题：&#123;title&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>消息内容：&#123;content&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="useMatch"><a href="#useMatch" class="headerlink" title="useMatch()"></a>useMatch()</h3><ol><li><p>作用：返回当前匹配信息，对标5.x中的路由组件的<code>match</code>属性。</p></li><li><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/login/:page/:pageSize&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Login</span> /&gt;</span></span>&#125;/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;/login/1/10&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Login</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> match = useMatch(<span class="string">&#x27;/login/:x/:y&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(match) <span class="comment">//输出match对象</span></span><br><span class="line">  <span class="comment">//match对象内容如下：</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">      params: &#123;x: &#x27;1&#x27;, y: &#x27;10&#x27;&#125;</span></span><br><span class="line"><span class="comment">      pathname: &quot;/LoGin/1/10&quot;  </span></span><br><span class="line"><span class="comment">      pathnameBase: &quot;/LoGin/1/10&quot;</span></span><br><span class="line"><span class="comment">      pattern: &#123;</span></span><br><span class="line"><span class="comment">      path: &#x27;/login/:x/:y&#x27;, </span></span><br><span class="line"><span class="comment">      caseSensitive: false, </span></span><br><span class="line"><span class="comment">      end: false</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="useInRouterContext"><a href="#useInRouterContext" class="headerlink" title="useInRouterContext()"></a>useInRouterContext()</h3><p>​            作用：如果组件在 <code>&lt;Router&gt;</code> 的上下文中呈现，则 <code>useInRouterContext</code> 钩子返回 true，否则返回 false。</p><h3 id="useNavigationType"><a href="#useNavigationType" class="headerlink" title="useNavigationType()"></a>useNavigationType()</h3><ol><li>作用：返回当前的导航类型（用户是如何来到当前页面的）。</li><li>返回值：<code>POP</code>、<code>PUSH</code>、<code>REPLACE</code>。</li><li>备注：<code>POP</code>是指在浏览器中直接打开了这个路由组件（刷新页面）。</li></ol><h3 id="useOutlet"><a href="#useOutlet" class="headerlink" title="useOutlet()"></a>useOutlet()</h3><ol><li><p>作用：用来呈现当前组件中渲染的嵌套路由。</p></li><li><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = useOutlet()</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">// 如果嵌套路由没有挂载,则result为null</span></span><br><span class="line"><span class="comment">// 如果嵌套路由已经挂载,则展示嵌套的路由对象</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="useResolvedPath"><a href="#useResolvedPath" class="headerlink" title="useResolvedPath()"></a>useResolvedPath()</h3><ol><li>作用：给定一个 URL值，解析其中的：path、search、hash值。</li></ol><h1 id="React-Router-6使用总结"><a href="#React-Router-6使用总结" class="headerlink" title="React Router 6使用总结"></a>React Router 6使用总结</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>React Router v6 大量使用<code>React hooks</code>。官方明确推荐<strong>函数式组件</strong>了。</p><p><code>Routes</code>是以前 <code>Switch</code> 组件的升级版，它包括相对路由和链接、自动路由排名、嵌套路由和布局等功能。</p><p><code>component</code>重命名为<code>element</code>。</p><p>v6的<code>&lt;Routes&gt;</code>元素下的所有<code>&lt;Route path</code>&gt;和<code>&lt;Link to&gt;</code>值都是<strong>自动相对于它们的父路由渲染的</strong>，而且忽略当前URL中的尾部斜杠。头部斜杠代变绝对路径。</p><p>中小型项目<strong>嵌套路由可集中显示</strong>，在需要显示的地方使用<code>&lt;Outlet /&gt;</code>作为占位符。</p><p>若<strong>分别显示</strong>，具有后代路由（在其他组件中定义）的路由在其路径中使用尾随<code>*</code> 。</p><p>“默认子路由”：<code>index</code>（不写path）表示索引路由共享父路径。这就是重点——它没有路径。</p><p>“未找到”路由：<code>path=&#39;*&#39;</code>表示路径都不匹配时。具有最弱的优先级。</p><p>v6 提供了 <strong>Navigate</strong> 组件，以前版本中的<code>Redirect</code>组件也消失了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  根组件(函数式)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;login&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Login</span> /&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Admin</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">index</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;category&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Category</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;product&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Product</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">index</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ProductHome</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;detail&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ProductDetail</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;addupdate&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">ProductAddUpdate</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;user&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">User</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;role&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Role</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;charts-bar&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Bar</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;charts-pie&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Pie</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;charts-line&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Line</span> /&gt;</span>&#125; /&gt;    </span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;/* 以上路径都不匹配时 */&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;*&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">NotFound</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后台管理的路由组件</span></span><br><span class="line"><span class="comment"> *  */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Admin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> user = memoryUtils.user</span><br><span class="line">    <span class="comment">// 如果内存没有存储user ==&gt; 当前没有登陆</span></span><br><span class="line">    <span class="keyword">if</span> (!user || !user._id) &#123;</span><br><span class="line">        <span class="comment">// 自动跳转到登陆(在render()中) Navigate替代Redirect</span></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&#x27;/login&#x27;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        ...     </span><br><span class="line">        &lt;Outlet /&gt;&#123;<span class="comment">/* 占位符 */</span>&#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v6 <strong>无法直接访问history实例</strong>，将useHistory更改为 <strong>useNavigate</strong>（兼容性和体验）。</p><p>useNavigate返回一个函数用来实现编程式导航。<code>navigate(&#39;/&#39;, &#123; replace: true &#125;)</code></p><p>传入数值进行前进或后退，类似于5.x中的 history.go()方法 <code>navigate(-1)</code></p><p>v5:<strong>withRouter</strong>高阶组件:包装非路由组件, 返回一个新的组件，新的组件向非路由组件传递3个属性: <code>history/location/match</code></p><p>v6:<strong>非路由组件</strong>使用<code>useLocation</code>也可得到<code>location</code>对象，<code>withRouter</code>不再使用。<code>useLocation().pathname</code>得到当前路径名。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> location =useLocation();</span><br><span class="line"><span class="keyword">const</span> path = location.pathname;</span><br><span class="line"></span><br><span class="line"><span class="comment">// location对象</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">hash</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;hvfbi1fy&quot;</span></span><br><span class="line">    <span class="attr">pathname</span>: <span class="string">&quot;/role&quot;</span></span><br><span class="line">    <span class="attr">search</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">state</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>useRoutes</code>钩子是一个路由API，它允许你使用<strong>JavaScript对象</strong>而不是React元素来声明和组合路由。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> element = useRoutes([</span><br><span class="line">    <span class="comment">// 这些与您提供给 &lt;Route&gt; 的props相同</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;dashboard&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Dashboard</span> /&gt;</span></span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;invoices&quot;</span>,</span><br><span class="line">      <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Invoices</span> /&gt;</span></span>,</span><br><span class="line">      <span class="comment">// 嵌套路由使用 children 属性，这也与 &lt;Route&gt; 相同</span></span><br><span class="line">      children: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;:id&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Invoice</span> /&gt;</span></span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;sent&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">SentInvoices</span> /&gt;</span></span> &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Not found routes work as you&#x27;d expect</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;*&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">NotFound</span> /&gt;</span></span> &#125;,</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回的元素将呈现整个元素层次结构及其所需的所有适当上下文</span></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Link</strong></p><p>标签体内容也是一种特殊的标签属性。</p><p>在 v5 中，不以 / 开头的 <code>&lt;Link to&gt;</code> 值是不明确的； 这取决于当前的 URL 是什么。 例如，如果当前 URL 是 /users，则 v5 <code>&lt;Link to=&quot;me&quot;&gt;</code> 将呈现 <code>&lt;a href=&quot;/me&quot;&gt;</code>。 但是，如果当前 URL 有一个结尾斜杠，例如 /users/，则相同的 <code>&lt;Link to=&quot;me&quot;&gt;</code> 将呈现 <code>&lt;a href=&quot;/users/me&quot;&gt;</code>。 这使得很难预测链接的行为方式，因此在 v5 中，我们建议您从根 URL（使用 match.url）构建链接，而不是使用相对的 <code>&lt;Link to&gt;</code> 值。</p><p>React Router v6 修复了这种歧义。 在 v6 中，<code>&lt;Link to=&quot;me&quot;&gt;</code> 将始终呈现相同的 <code>&lt;a href&gt;</code>，而不管当前的 URL。</p><p>例如，在 <code>&lt;Route path=&quot;users&quot;&gt;</code> 中呈现的 <code>&lt;Link to=&quot;me&quot;&gt;</code> 将始终呈现指向 /users/me 的链接，无论当前 URL 是否具有尾部斜杠。</p><p>当您想“向上”链接回父路由时，请在 <code>&lt;Link to&gt;</code> 值中使用前导 <code>..</code> 段，类似于您在 <code>&lt;a href&gt;</code> 中所做的。</p><h2 id="路由参数传递"><a href="#路由参数传递" class="headerlink" title="路由参数传递"></a>路由参数传递</h2><h3 id="param参数"><a href="#param参数" class="headerlink" title="param参数"></a>param参数</h3><ul><li>在<code>Route组件</code>中的<code>path属性</code>中定义路径参数</li><li>在组件内通过<code>useParams</code> hook访问路径参数</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义参数</span></span><br><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/foo/:id&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;Foo&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line">&lt;/BrowserRouter&gt;</span><br><span class="line"><span class="comment">// 传递参数</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">LinkButton</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> navigate(`foo/$&#123;product.id&#125;`)&#125; &gt;</span></span><br><span class="line"><span class="xml">    修改</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">LinkButton</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 提取参数</span></span><br><span class="line"><span class="keyword">import</span> &#123; useParams &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> params = useParams();</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;params.id&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>个人理解：param参数适合传递一个参数时使用。</strong></p><p><strong>useMatch</strong>()</p><ol><li><p>作用：返回当前匹配信息，对标5.x中的路由组件的<code>match</code>属性。</p></li><li><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/login/:page/:pageSize&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Login</span> /&gt;</span></span>&#125;/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;/login/1/10&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Login</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> match = useMatch(<span class="string">&#x27;/login/:x/:y&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(match) <span class="comment">//输出match对象</span></span><br><span class="line">  <span class="comment">//match对象内容如下：</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">      params: &#123;x: &#x27;1&#x27;, y: &#x27;10&#x27;&#125;</span></span><br><span class="line"><span class="comment">      pathname: &quot;/LoGin/1/10&quot;  </span></span><br><span class="line"><span class="comment">      pathnameBase: &quot;/LoGin/1/10&quot;</span></span><br><span class="line"><span class="comment">      pattern: &#123;</span></span><br><span class="line"><span class="comment">      path: &#x27;/login/:x/:y&#x27;, </span></span><br><span class="line"><span class="comment">      caseSensitive: false, </span></span><br><span class="line"><span class="comment">      end: false</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="search参数-amp-sate参数"><a href="#search参数-amp-sate参数" class="headerlink" title="search参数&amp;sate参数"></a>search参数&amp;sate参数</h3><p>Location：这是一个 React Router 特定的对象，它基于内置浏览器的 window.location 对象。 </p><p>您可以设置<code>location state</code>在<code>&lt;Link&gt;</code>上或<code>navigate</code>上，在下一路由组件中你可以用<code>useLocation</code>来访问它。</p><p><code>useLocation()</code>既可以获得<code>state</code>参数，也可以获得<code>search</code>参数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinkButton onClick=&#123;<span class="function">() =&gt;</span> navigate(<span class="string">&#x27;addupdate?name=tom&amp;age=18&#x27;</span>, &#123; <span class="attr">state</span>: product &#125;)&#125; &gt;</span><br><span class="line">    修改</span><br><span class="line">&lt;/LinkButton&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isUpdate = location.state</span><br><span class="line"><span class="keyword">const</span> search = location.search</span><br><span class="line"><span class="built_in">console</span>.log(search) <span class="comment">// ?name=tom&amp;age=18</span></span><br><span class="line"><span class="built_in">console</span>.log(isUpdate) <span class="comment">// &#123;status: 1, imgs: Array(2), _id: &#x27;5e12b97de31bb727e4b0e349&#x27;, name: &#x27;联想ThinkPad 翼4809&#x27;, desc: &#x27;年度重量级新品，X390、T490全新登场 更加轻薄机身设计9&#x27;, …&#125;</span></span><br></pre></td></tr></table></figure><p><strong>个人理解：state参数适合传js对象。</strong></p><p><code>search</code>参数一般使用<code>useSearchParams()</code>进行获取和修改。</p><ol><li>作用：用于读取和修改当前位置的 URL 中的查询字符串。</li><li>返回一个包含两个值的数组，内容分别为：当前的seaech参数、更新search的函数。</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [search,setSearch] = useSearchParams()</span><br><span class="line"><span class="keyword">const</span> age = search.get(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> name = search.get(<span class="string">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>个人理解：search参数适合传可能会被修改的参数。</strong></p><p><a href="https://reactrouter.com/docs/en/v6">官方文档</a></p><p><a href="https://reacttraining.com/blog/react-router-v6-pre/">官方博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React-Router-6-快速上手&quot;&gt;&lt;a href=&quot;#React-Router-6-快速上手&quot; class=&quot;headerlink&quot; title=&quot;React Router 6 快速上手&quot;&gt;&lt;/a&gt;React Router 6 快速上手&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="React" scheme="https://lesliewaong.top/categories/React/"/>
    
    
    <category term="React" scheme="https://lesliewaong.top/tags/React/"/>
    
    <category term="Router" scheme="https://lesliewaong.top/tags/Router/"/>
    
  </entry>
  
  <entry>
    <title>居中布局与Flex</title>
    <link href="https://lesliewaong.top/posts/28d62aa4.html"/>
    <id>https://lesliewaong.top/posts/28d62aa4.html</id>
    <published>2022-04-02T10:14:52.000Z</published>
    <updated>2022-04-15T03:17:05.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="居中布局与Flex"><a href="#居中布局与Flex" class="headerlink" title="居中布局与Flex"></a>居中布局与Flex</h1><h2 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ul><li><code>text-align: center</code>设置<strong>块元素或表格单元格</strong>中<strong>内容</strong>的水平对齐方式。这意味着它像vertical-align一样工作，但在<strong>水平</strong>方向。<strong>不能直接用于行内元素</strong> ，另外，这个内容不一定是行内元素，块元素中有h1(块元素)一样可以实现效果。</li><li><code>margin: 0 auto</code></li><li><code>absolute + transform</code></li><li><code>flex + justify-content: center</code></li></ul><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ul><li><p><code>line-height: 父元素height</code>（基线之间的距离，行距=<code>line-height</code>-<code>font-size</code>，推荐在设置 line-height 时使用无单位数值）注意子元素是否存在margin。适合文本。</p><p><a href="https://imgtu.com/i/HfTxdH"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2022/02/16/HfTxdH.png" alt="HfTxdH.png"></a></p></li><li><p><strong><code>vertical-align</code></strong> 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。使行内元素盒模型与其行内元素容器垂直对齐/垂直对齐表格单元内容。不能用它垂直对齐块级元素。</p></li><li><p><code>absolute + transform</code></p></li><li><p><code>flex + align-items: center</code></p></li><li><p><code>table</code>、<code>grid</code></p></li></ul><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><p>HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box size&quot;</span>&gt;</span>123123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>公共代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 公共代码 */</span></span><br><span class="line"><span class="selector-class">.wp</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: green;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span><span class="selector-class">.size</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>absolute + 负margin</code> </li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wp</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>absolute + margin auto</code></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定位代码 */</span></span><br><span class="line"><span class="selector-class">.wp</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>absolute + transform</code></li></ul><p><code>top,left</code>跟根据<strong>父元素的宽和高</strong>偏移的。</p><p><code>transform: translate(-50%, -50%);</code>是根据<strong>自身的宽高</strong>偏移的。</p><p><strong>注意子元素是否存在margin</strong>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wp</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;  </span><br><span class="line"> </span><br><span class="line">&#125;     </span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li><code>flex + justify-content + align-items</code></li></ul><p>目前在移动端已经完全可以使用flex了，PC端需要看自己业务的兼容性情况。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wp</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但对<strong>子元素图片、文字</strong>都有时，<strong>竖直方向</strong>的对齐会有差异，可以<strong>父元素开启Flex布局</strong>，图片子元素设置<code>align-self: center;</code>，文字子元素使用<code>line-height</code>。</p><ul><li><strong>网格布局（Grid）</strong>是最强大的 CSS 布局方案。</li></ul><p>下面是4种使用grid实现水平垂直居中的例子。</p><p>方法一：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    justify-items: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.small</span> &#123;</span><br><span class="line">    justify-self: center;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    justify-items: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.small</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法四：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.small</span> &#123;</span><br><span class="line">    justify-self: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h2><blockquote><p>Flex是Flexible Box的缩写，翻译成中文就是“弹性盒子”，用来为盒模型提供最大的灵活性。任何一个容器都可以指定为Flex布局</p></blockquote><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>采用Flex布局的元素，被称为Flex容器(flex container)，简称“容器”。</p><p>其所有子元素自动成为容器成员，成为Flex项目(Flex item)，简称“项目”。</p><p><a href="https://imgtu.com/i/o4UXgP"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2021/12/09/o4UXgP.png" alt="o4UXgP.png"></a></p><p>容器默认存在两根主轴：水平方向主轴(main axis)和垂直方向交叉轴(cross axis)，默认项目按主轴排列。</p><ul><li>main start/main end：主轴开始位置/结束位置；</li><li>cross start/cross end：交叉轴开始位置/结束位置；</li><li>main size/cross size：单个项目占据主轴/交叉轴的空间；</li></ul><h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p><strong>决定主轴的方向（即项目的排列方向）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">   <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>row（默认）：主轴水平方向，起点在左端；</li><li>row-reverse：主轴水平方向，起点在右端；</li><li>column：主轴垂直方向，起点在上边沿；</li><li>column-reserve：主轴垂直方向，起点在下边沿。</li></ul><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p><strong>定义换行情况</strong></p><blockquote><p>默认情况下，项目都排列在一条轴线上，但有可能一条轴线排不下。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">   <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>nowrap（默认）：不换行；</li><li>wrap：换行，第一行在上方；</li><li>wrap-reverse：换行，第一行在下方。</li></ul><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p><strong>flex-direction和flex-wrap的简写，默认row nowrap</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p><strong>定义项目在主轴上的对齐方式。</strong></p><blockquote><p>对齐方式与轴的方向有关，本文中假设主轴从左到右。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">   <span class="attribute">justify-content</span>: start | end | flex-start | flex-end | center | left | right | space-between | space-around | space-evenly | stretch | safe | unsafe | baseline | first baseline | last baseline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>flex-start（默认值）：左对齐；</p></li><li><p>flex-end：右对齐；</p></li></ul><ul><li><p>center：居中；<strong>常用作水平居中</strong></p></li><li><p>space-between：两端对齐，项目之间间隔相等；</p></li><li><p>space-around：每个项目两侧的间隔相等，即项目之间的间隔比项目与边框的间隔大一倍。</p></li></ul><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p><strong>定义在交叉轴上的对齐方式</strong></p><blockquote><p>对齐方式与交叉轴的方向有关，假设交叉轴从上到下。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flex-start：起点对齐；</li><li>flex-end：终点对齐；</li><li>center：中点对齐；<strong>常用作垂直居中</strong></li><li>baseline：项目的第一行文字的基线对齐；</li><li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p><strong>定义多根轴线的对齐方式</strong></p><blockquote><p>如果项目只有一根轴线，该属性不起作用。<br>所以，容器必须设置flex-wrap：···；</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>flex-start：与交叉轴的起点对齐；</p></li><li><p>flex-end：与交叉轴的终点对齐；</p></li><li><p>center：与交叉轴的中点对齐；</p></li><li><p>space-between：与交叉轴的两端对齐，轴线之间的间隔平均分布；</p></li><li><p>space-around：每根轴线两侧的间隔相等，即轴线之间的间隔比轴线与边框的间隔大一倍；</p></li><li><p>stretch（默认值）：轴线占满整个交叉轴。</p></li></ul><h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p><strong>==flex-grow，flex-shrink和flex-basis的简写==</strong></p><blockquote><p>默认值为0 1 auto，<strong>第一个属性必须</strong>，后两个属性可选。</p></blockquote><p>可以用 <code>flex:auto;</code> 代替 <code>flex: 1 1 auto;</code>；可以用 <code>flex: none;</code>代替 <code>flex: 0 0 auto</code>；</p><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p><strong>定义项目的放大比例</strong>（<strong>容器宽度&gt;元素总宽度时如何伸展</strong>）</p><blockquote><p>默认值为0，即如果空间有剩余，也不放大。<br>可以是小数，按比例占据<strong>剩余空间</strong>。</p></blockquote><p><code>flex-grow：1</code>或<code>flex：1</code>，经常用作自适应布局</p><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p><strong>定义项目的缩小比例</strong>（<strong>容器宽度&lt;元素总宽度时如何收缩</strong>）</p><blockquote><p>默认值都为1，即如果空间不足将等比例缩小。<br>如果有一个项目的值为0，其他项目为1，当空间不足时，该项目不缩小。<br>负值对该属性无效，容器不应该设置flex-wrap。</p></blockquote><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p><strong>定义在分配多余空间之前，项目占据的主轴空间。</strong></p><p>设置的是元素在主轴上的初始尺寸，所谓的初始尺寸就是元素在<code>flex-grow</code>和<code>flex-shrink</code>生效前的尺寸。</p><p>浏览器根据这个属性，计算主轴是否有多余空间，默认值为<code>auto</code>，即项目的本来大小，如设置了<code>width</code>则元素尺寸由<code>width/height</code>决定（主轴方向），没有设置则由内容决定。</p><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p><strong>允许单个项目与其他项目有不一样的对齐方式</strong> </p><blockquote><p>默认值为auto，表示继承父元素的align-items属性，并可以覆盖align-items属性。</p></blockquote><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p><strong>定义项目的排列顺序。</strong></p><blockquote><p>数值越小，排列越靠前，默认为0，可以是负值。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: &lt;整数&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.parent</span> &gt; <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.item-1</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">140px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">flex</span>: <span class="number">2</span> <span class="number">1</span> <span class="number">0%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: blue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.item-2</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">flex</span>: <span class="number">2</span> <span class="number">1</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: darkblue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.item-3</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: lightblue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>主轴上父容器总尺寸为 600px</li><li>子元素的总基准值是：<code>0% + auto + 200px = 300px</code>，其中<ol><li> 0% 即 0 宽度</li><li> auto 对应取主尺寸即 100px</li></ol></li><li>故剩余空间为 <code>600px - 300px = 300px</code></li><li>伸缩放大系数之和为： <code>2 + 2 + 1 = 5</code></li><li>剩余空间分配如下：<ol><li>- item-1 和 item-2 各分配 2/5，各得 120px</li><li>- item-3 分配 1/5，得 60px</li></ol></li><li>各项目最终宽度为：<ol><li>- item-1 = <code>0% + 120px = 120px</code></li><li>- item-2 = <code>auto + 120px = 220px</code></li><li>- item-3 = <code>200px + 60px = 260px</code></li></ol></li><li>当 item-1 基准值取 0% 的时候，是<strong>把该项目视为零尺寸的，故即便声明其尺寸为 140px，也并没有什么用，形同虚设</strong></li><li>而 item-2 基准值取 <code>auto</code> 的时候，根据规则基准值使用值是主尺寸值即 100px，故<strong>这 100px 不会纳入剩余空间</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;居中布局与Flex&quot;&gt;&lt;a href=&quot;#居中布局与Flex&quot; class=&quot;headerlink&quot; title=&quot;居中布局与Flex&quot;&gt;&lt;/a&gt;居中布局与Flex&lt;/h1&gt;&lt;h2 id=&quot;居中布局&quot;&gt;&lt;a href=&quot;#居中布局&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="HTML&amp;CSS" scheme="https://lesliewaong.top/categories/HTML-CSS/"/>
    
    
    <category term="CSS" scheme="https://lesliewaong.top/tags/CSS/"/>
    
    <category term="居中布局" scheme="https://lesliewaong.top/tags/%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80/"/>
    
    <category term="Flex" scheme="https://lesliewaong.top/tags/Flex/"/>
    
  </entry>
  
  <entry>
    <title>原型和继承</title>
    <link href="https://lesliewaong.top/posts/24025dd2.html"/>
    <id>https://lesliewaong.top/posts/24025dd2.html</id>
    <published>2022-04-01T11:12:22.000Z</published>
    <updated>2022-04-15T03:17:29.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型和继承"><a href="#原型和继承" class="headerlink" title="原型和继承"></a>原型和继承</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>每个函数都有一个属性<code>prototype</code>，它指向函数的原型，默认情况下它是一个普通<code>Object</code>对象。</p><p><strong>调用该构造函数所创建的实例的隐式原型指向该构造函数的原型对象。</strong></p><p>JS同样存在由<strong>原型指向构造函数的属性</strong>：<code>constructor</code>，即<code>Func.prototype.constructor --&gt; Func</code></p><p>JS中所有对象(除了<code>null</code>)都具有一个<code>__proto__</code>属性，该属性指向该对象的隐式原型。</p><p><a href="https://imgtu.com/i/Tkh7H1"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2021/12/17/Tkh7H1.png" alt="Tkh7H1.png"></a></p><p><code>JavaScript</code>所有的对象本质上都是通过<code>new 函数</code>创建的，包括对象字面量的形式定义对象(相当于<code>new Object()</code>的语法糖)。</p><p><strong>所有的函数</strong>本质上都是通过<code>new Function</code>创建的，包括<code>Object</code>、<code>Array</code>等。<strong>所有的函数都是对象</strong>。</p><p><strong>实例对象</strong>在查找属性时，如果查找不到，就会沿着<code>__proto__</code>去与对象关联的原型上查找，如果还查找不到，就去找原型的原型，直至查到最顶层，这也就是<strong>原型链</strong>的概念。</p><p><a href="https://imgtu.com/i/TkhJ0I"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s4.ax1x.com/2021/12/17/TkhJ0I.png" alt="TkhJ0I.png"></a></p><ul><li><p>所有函数(包括<code>Function</code>)的<code>__proto__</code>指向<code>Function.prototype</code></p></li><li><p>自定义对象实例的<code>__proto__</code>指向构造函数的原型</p></li><li><p>函数的<code>prototype</code>的<code>__proto__</code>指向<code>Object.prototype</code></p></li><li><p><code>Object.prototype.__proto__ --&gt; null</code></p></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是一种代码复用的方式。在面向对象编程中，继承是一个很重要的点。</p><p>在JS中继承背后的原理是原型<code>prototype</code>, 这种实现继承的方式，我们称之为原型继承。</p><h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><p>JS中一些全局内置函数，分别为Functon, Array, Object.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>); <span class="comment">// -&gt; ƒ Object() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>); <span class="comment">// -&gt; ƒ Array() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>); <span class="comment">// -&gt; ƒ Function() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><ul><li>所有的数组对象，都是由全局内置函数Array创建的</li><li>所有的object对象，都是由全局内置函数Object创建的</li><li>所有的函数对象，都是由全局内置函数Function创建的</li></ul><p>其他也是同理，比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>.__proto__ === <span class="built_in">Number</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27;.__proto__ === String.prototype; // true</span></span><br><span class="line"><span class="string">true.__proto__ === Boolean.prototype; // true</span></span><br></pre></td></tr></table></figure><h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h3><p><code>__proto__</code>是一个内部属性，不建议对其进行直接操作。 而是建议通过<code>prototype</code>来进行操作。</p><p>一个对象的<code>__proto__</code>总是指向它的构造函数的<code>prototype</code>。</p><blockquote><p>构造函数指的是创建这个对象的函数， 比如 foo = new Foo(), 那么Foo就是foo的构造函数。</p></blockquote><p>让我们来继续看一下上面的代码, 就不难理解了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>.__proto__ === <span class="built_in">Number</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27;.__proto__ === String.prototype; // true</span></span><br><span class="line"><span class="string">true.__proto__ === Boolean.prototype; // true</span></span><br></pre></td></tr></table></figure><p>除此我们需要注意一点，那就是<code>Object.prototype.__proto__</code> 值为 <code>null</code>。 其实也就是<strong>继承链的终点</strong>。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>为了能够明白原型链和继承，我们首先要知道“属性查找机制”。</p><p>当我们访问一个对象的属性的时候，引擎首先会在当前对象进行查找，如果找不到就会访问该对象的<code>__proto__</code>， 如果<code>__proto__</code>有了，就返回，如果没有则递归执行上述过程，直到<code>__proto__</code> 为 <code>null</code>。</p><p>继承的过程，直接依靠的是<code>__proto__</code>， 只不过就像我上面提到的<code>__proto__</code> 只是一个指向构造函数原型的引用， 因此开发人员修改了构造函数的原型，就会影响到<code>__proto__</code>， 进而影响了对象的原型链。</p><p>当然你可以自己直接修改<code>__proto__</code>，但是不推荐！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto__.nickName = <span class="string">&#x27;lucifer&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// -&gt; &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.nickName); <span class="comment">// -&gt; lucifer</span></span><br></pre></td></tr></table></figure><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>其实继承和原型这部分知识和new是强相关的。 我们有必要了解一下new的原理。</p><p>new 的原理很简单, 就是引擎内部新建一个空对象，然后将这个空对象的<code>__proto__</code> 指向构造函数的<code>prototype</code>.然后调用构造函数，去填充我们创建的空对象(如果有必要)。 最后将<code>this</code>指向我们刚刚创建的新对象。</p><p><strong>new 运算符</strong>创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。<strong>new</strong> 关键字会进行如下的操作：</p><ol><li>创建一个空的简单JavaScript对象（即<code>&#123;&#125;</code>）；</li><li>将该对象的<code>__proto__</code>指向构造函数原型；</li><li>将步骤1新创建的对象作为<code>this</code>的上下文 ；</li><li>如果<strong>该函数没有返回对象</strong>，则返回<code>this</code>（新创建的对象）。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new_object</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空的对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  <span class="comment">// 获得构造函数</span></span><br><span class="line">  <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="comment">// 链接到原型 （不推荐使用）</span></span><br><span class="line">  obj.__proto__ = Con.prototype</span><br><span class="line">  <span class="comment">// 绑定 this，执行构造函数</span></span><br><span class="line">  <span class="keyword">let</span> result = Con.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="comment">// 确保 new 出来的是个对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>__proto__</code><strong>已废弃:</strong> 该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。</p><p><code>Object.setPrototypeOf(obj, proto);</code>直接修改已有对象的原型，非常耗时。</p><p><strong>警告:</strong> 通过现代浏览器的操作属性的便利性，可以改变一个对象的 <code>[[Prototype]]</code> 属性, 这种行为在每一个JavaScript引擎和浏览器中都是一个非常慢且影响性能的操作，使用这种方式来改变和继承属性是对性能影响非常严重的，并且性能消耗的时间也不是简单的花费在 <code>obj.__proto__ = ...</code> 语句上, 它还会影响到所有继承来自该 <code>[[Prototype]]</code> 的对象，如果你关心性能，你就不应该在一个对象中修改它的 <code>[[Prototype]]</code>。相反, 创建一个新的且可以继承 <code>[[Prototype]]</code> 的对象，推荐使用 <code>Object.create()</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化后 new 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1、通过call，this指向了arguments(封装实参的对象)，shift删除并获得arguments中第一个参数——构造函数</span></span><br><span class="line">  Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 2、创建一个空的对象并将该对象的__proto__指向构造函数原型</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(Con.prototype);</span><br><span class="line">  <span class="comment">// 3、绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">  <span class="keyword">let</span> ret = Con.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 4、优先返回构造函数返回的对象</span></span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line">Car.prototype.start = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.color + <span class="string">&quot; car start&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> car = create(Car,<span class="string">&quot;black&quot;</span>);</span><br></pre></td></tr></table></figure><p>补充：</p><p><code>shift/unshift</code> 方法并不局限于数组：这个方法能够通过  <code>call()</code> 或 <code>apply()</code>方法作用于类似数组的对象上。</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><ol><li><code>instanceof</code> 判断<strong>对象的原型链上是否存在构造函数的原型</strong>。只能判断引用类型。</li><li><code>instanceof</code> 常用来判断 <code>A</code> 是否为 <code>B</code> 的实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instanceof 的内部实现 </span></span><br><span class="line"><span class="keyword">const</span> instance_of = <span class="function">(<span class="params">Case,Constructor</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 基本数据类型返回false</span></span><br><span class="line">    <span class="comment">// 兼容一下函数对象</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">typeof</span>(Case) !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span>(Case) !== <span class="string">&#x27;function&#x27;</span>) || Case === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> CaseProto = <span class="built_in">Object</span>.getPrototypeOf(Case);</span><br><span class="line">    <span class="comment">// let CaseProto = Case.__proto__;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 查到原型链顶端，仍未查到，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (CaseProto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 找到相同的原型</span></span><br><span class="line">        <span class="keyword">if</span> (CaseProto === Constructor.prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// CaseProto = CaseProto.__proto__;</span></span><br><span class="line">        CaseProto = <span class="built_in">Object</span>.getPrototypeOf(CaseProto);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a=&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(instance_of(a,<span class="built_in">Object</span>))</span><br></pre></td></tr></table></figure><p><code>Object.getPrototypeOf()</code> 方法返回指定对象的原型（内部<code>[[Prototype]]</code>属性的值）。</p><h2 id="call-apply"><a href="#call-apply" class="headerlink" title="call/apply"></a>call/apply</h2><h3 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h3><p><code>call()</code> 方法调用一个函数, 其具有一个指定的 <code>this</code> 值和多个参数(<strong>参数的列表</strong>)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><p>它运行 <code>func</code>，提供的第一个参数 <code>thisArg</code> 作为 <code>this</code>，后面的作为参数。</p><p>看一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayWord</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> talk = [<span class="built_in">this</span>.name, <span class="string">&#x27;say&#x27;</span>, <span class="built_in">this</span>.word].join(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(talk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bottle = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;bottle&#x27;</span>, </span><br><span class="line">  <span class="attr">word</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 call 将 bottle 传递为 sayWord 的 this</span></span><br><span class="line">sayWord.call(bottle); </span><br><span class="line"><span class="comment">// bottle say hello</span></span><br></pre></td></tr></table></figure><p>所以，<code>call</code> 主要实现了以下两个功能：</p><ul><li><code>call</code> 改变了 <code>this</code> 的指向</li><li><code>bottle</code> 执行了 <code>sayWord</code> 函数</li></ul><p>上面代码等效于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bottle = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;bottle&#x27;</span>, </span><br><span class="line">    <span class="attr">word</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    <span class="attr">sayWord</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> talk = [<span class="built_in">this</span>.name, <span class="string">&#x27;say&#x27;</span>, <span class="built_in">this</span>.word].join(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(talk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bottle.sayWord();</span><br><span class="line"><span class="comment">// bottle say hello</span></span><br></pre></td></tr></table></figure><p>这里<strong>把函数作为对象的属性存在</strong>，通过<strong>对象属性执行函数</strong>时，相当于对this进行了<strong>隐式绑定</strong>。</p><h3 id="模拟实现-call"><a href="#模拟实现-call" class="headerlink" title="模拟实现 call"></a>模拟实现 call</h3><p>模拟实现 <code>call</code> 有三步：</p><ul><li><strong>将函数设置为绑定对象的属性</strong></li><li>执行函数</li><li>删除对象的这个属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.newCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：非严格模式下, </span></span><br><span class="line">    <span class="comment">// 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中就是 window 对象)</span></span><br><span class="line">    <span class="comment">// 值为原始值(数字，字符串，布尔值)的 this 会指向该原始值的自动包装对象(用 Object() 转换）</span></span><br><span class="line">    context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>; </span><br><span class="line">    <span class="comment">// 将函数设为对象的属性</span></span><br><span class="line">    <span class="comment">// newCall由函数调用，此时的this指向函数，是一种隐式绑定</span></span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 执行该函数</span></span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> result = context.fn(...args);</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 删除该函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="comment">// 注意：函数是可以有返回值的</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>补充</p></blockquote><p><strong>封装实参的对象</strong> <code>arguments</code></p><ul><li>arguments是一个<strong>类数组</strong>对象,它也可以通过索引来操作数据，也可以获取长度。</li><li>在调用函数时，我们所传递的实参都会在arguments中保存</li><li><code>arguments.length</code>可以用来获取实参的长度</li><li><code>arguments[0]</code> 表示第一个实参，<code>arguments[1]</code> 表示第二个实参 。。。</li></ul><p><strong>展开语法、剩余参数</strong></p><ul><li><p><strong>展开语法</strong>（扩展运算符）是将<strong>数组</strong>或者<strong>可迭代对象</strong>拆分成逗号分隔的参数序列。</p></li><li><p><strong>剩余参数</strong>语法允许我们将一个不定数量的参数表示为一个数组。</p></li><li><p>剩余语法(Rest syntax) 看起来和展开语法完全相同，不同点在于, 剩余参数用于解构数组和对象。从某种意义上说，剩余语法与展开语法是相反的：展开语法将数组展开为其中的各个元素，而剩余语法则是将多个元素收集起来并“凝聚”为单个元素。</p></li></ul><p><strong>slice()</strong></p><ul><li><code>slice()</code> 方法返回一个新的数组对象，这一对象是一个由 <code>begin</code> 和 <code>end</code> 决定的原数组的<strong>浅拷贝</strong>（包括 <code>begin</code>，不包括<code>end</code>）。</li><li>原始数组不会被改变。</li></ul><h3 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h3><p><code>apply()</code> 方法调用一个具有给定 <code>this</code> 值的函数，以及作为一个<strong>数组（或[类似数组对象）</strong>提供的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure><p>它运行 <code>func</code> 设置 <code>this = context</code> 并使用类数组对象 <code>args</code> 作为参数列表。</p><p><code>call</code> 和 <code>apply</code> 之间唯一的语法区别是 <code>call</code> 接受一个参数列表，而 <code>apply</code> 则接受带有一个类数组对象。</p><p>需要注意：Chrome 14 以及 Internet Explorer 9 仍然不接受类数组对象。如果传入类数组对象，它们会抛出异常。</p><h3 id="模拟实现-apply"><a href="#模拟实现-apply" class="headerlink" title="模拟实现 apply"></a>模拟实现 apply</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.newApply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注意：非严格模式下, </span></span><br><span class="line">    <span class="comment">// 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中就是 window 对象)</span></span><br><span class="line">    <span class="comment">// 值为原始值(数字，字符串，布尔值)的 this 会指向该原始值的自动包装对象(用 Object() 转换）</span></span><br><span class="line">    context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>; </span><br><span class="line">    <span class="comment">// 将函数设为对象的属性</span></span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 执行该函数</span></span><br><span class="line">    <span class="keyword">const</span> result = arr ? context.fn(...arr):context.fn();</span><br><span class="line">    <span class="comment">// 删除该函数  </span></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="comment">// 注意：函数是可以有返回值的</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h3><blockquote><p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p></blockquote><p><code>bind</code> 方法与 <code>call / apply</code> 最大的不同就是前者返回一个绑定上下文的<strong>函数</strong>，而后两者是<strong>直接执行</strong>了函数。</p><p>来个例子说明下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">value</span>: <span class="built_in">this</span>.value,</span><br><span class="line"><span class="attr">name</span>: name,</span><br><span class="line"><span class="attr">age</span>: age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bar.call(foo, <span class="string">&quot;Jack&quot;</span>, <span class="number">20</span>); <span class="comment">// 直接执行了函数</span></span><br><span class="line"><span class="comment">// &#123;value: 1, name: &quot;Jack&quot;, age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bindFoo1 = bar.bind(foo, <span class="string">&quot;Jack&quot;</span>, <span class="number">20</span>); <span class="comment">// 返回一个函数</span></span><br><span class="line">bindFoo1();</span><br><span class="line"><span class="comment">// &#123;value: 1, name: &quot;Jack&quot;, age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bindFoo2 = bar.bind(foo, <span class="string">&quot;Jack&quot;</span>); <span class="comment">// 返回一个函数</span></span><br><span class="line">bindFoo2(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// &#123;value: 1, name: &quot;Jack&quot;, age: 20&#125;</span></span><br></pre></td></tr></table></figure><p>通过上述代码可以看出 <code>bind</code> 有如下特性：</p><ul><li>指定 <code>this</code></li><li>传入参数</li><li>返回一个函数</li><li>柯里化</li></ul><p><code>bind</code> 还有一个特性：</p><blockquote><p>一个绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p></blockquote><p>来个例子说明下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.habit = <span class="string">&#x27;shopping&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line">bar.prototype.friend = <span class="string">&#x27;kevin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bindFoo = bar.bind(foo, <span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> bindFoo(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">obj.habit;</span><br><span class="line"><span class="comment">// shopping</span></span><br><span class="line"></span><br><span class="line">obj.friend;</span><br><span class="line"><span class="comment">// kevin</span></span><br></pre></td></tr></table></figure><p>上面例子中，运行结果 <code>this.value</code> 输出为 <code>undefined</code> ，这不是全局 <code>value</code> 也不是 <code>foo</code> 对象中的 <code>value</code> ，这说明 <code>bind</code> 的 <code>this</code> 对象失效了，<code>new</code> 的实现中生成一个新的对象，这个时候的 <code>this</code> 指向的是 <code>obj</code> 。</p><h3 id="模拟实现bind"><a href="#模拟实现bind" class="headerlink" title="模拟实现bind"></a>模拟实现bind</h3><p>大体思路：</p><ul><li><p>拷贝源函数:</p><ul><li><p>通过变量储存源函数  <code>const self = this;</code>  this 指向源函数</p></li><li><p>使用空对象或<code>Object.create</code>复制源函数的prototype给返回函数</p></li></ul></li><li><p>返回拷贝的函数</p></li><li><p>调用拷贝的函数：</p><ul><li><p>new调用判断：通过<code>instanceof</code>判断函数是否通过<code>new</code>调用，来决定绑定的<code>context</code></p></li><li><p>绑定this+传递参数 <code>apply</code></p></li><li><p>返回源函数的执行结果</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.newBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 bind 的不是函数，需要抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// this 指向调用者</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 实现第2点，因为第1个参数是指定的this,所以只截取第1个之后的参数</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个空对象</span></span><br><span class="line">    <span class="keyword">const</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现第3点,返回一个函数</span></span><br><span class="line">    <span class="keyword">const</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 实现第4点，获取 bind 返回函数的参数</span></span><br><span class="line">        <span class="keyword">const</span> bindArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// 然后同传入参数合并成一个参数数组，并作为 self.apply() 的第二个参数</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="built_in">this</span> : context, args.concat(bindArgs));</span><br><span class="line">        <span class="comment">// 当作为构造函数时，`this` 指向实例，此时 `this instanceof fBound` 结果为 `true` </span></span><br><span class="line">        <span class="comment">// 可以让实例获得来自绑定函数的值</span></span><br><span class="line">        <span class="comment">// 当作为普通函数时，`this` 指向 `window` ，此时结果为 `false` </span></span><br><span class="line">        <span class="comment">// 将绑定函数的 `this` 指向 `context`</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 空对象的原型指向绑定函数的原型</span></span><br><span class="line">    fNOP.prototype = self.prototype;</span><br><span class="line">    <span class="comment">// 空对象的实例赋值给返回函数 实例就可以继承绑定函数的原型中的值</span></span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么使用一个空对象 <code>fNOP</code> 作为中介，把 <code>fBound.prototype</code> 赋值为空对象的实例（原型式继承），这是因为直接 <code>fBound.prototype = this.prototype</code> 有一个缺点，修改 <code>fBound.prototype</code> 的时候，也会直接修改 <code>this.prototype</code> ；其实也可以直接使用ES5的 <code>Object.create()</code> 方法生成一个新对象，但 <code>bind</code> 和 <code>Object.create()</code> 都是ES5方法，部分IE浏览器（IE &lt; 9）并不支持。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (self.prototype) &#123;</span><br><span class="line">    <span class="comment">// 复制源函数的prototype给fBound 一些情况下函数没有prototype，比如箭头函数</span></span><br><span class="line">    fBound.prototype=<span class="built_in">Object</span>.create(self.prototype) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> <code>bind()</code> 函数在 ES5 才被加入，所以并不是所有浏览器都支持，<code>IE8</code> 及以下的版本中不被支持。</p><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><h4 id="类数组-gt-数组"><a href="#类数组-gt-数组" class="headerlink" title="类数组-&gt;数组"></a>类数组-&gt;数组</h4><p><code>slice</code> 方法可以用来将一个类数组（Array-like）对象/集合转换成一个新数组。你只需将该方法绑定到这个对象上。</p><p> 除了使用 <code>Array.prototype.slice.call(arguments)</code>，你也可以简单的使用 <code>[].slice.call(arguments)</code> 来代替。</p><h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>在计算机科学中，柯里化（Currying）是把<strong>接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术</strong>。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> increment = add(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> addTen = add(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">increment(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">addTen(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这里定义了一个 <code>add</code> 函数，它接受一个参数并返回一个新的函数。调用 <code>add</code> 之后，返回的函数就通过闭包的方式记住了 <code>add</code> 的第一个参数。所以说 <code>bind</code> 本身也是<strong>闭包</strong>的一种使用场景。</p><p><strong>柯里化</strong>是将 <code>f(a,b,c)</code> 可以被以 <code>f(a)(b)(c)</code> 的形式被调用的转化。JavaScript 实现版本通常保留函数被正常调用和在参数数量不够的情况下返回偏函数这两个特性。</p><h1 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。</p><p>继承的本质就是<strong>复制，即重写原型对象，代之以一个新类型的实例</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c0107fd80c7~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>原型链方案存在的缺点：多个实例对引用类型的操作会被篡改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(); </span><br><span class="line">alert(instance2.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>使用父类的构造函数来增强子类<strong>实例</strong>，等同于复制父类的实例给子类（不使用原型）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color=[<span class="string">&quot;red&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;blue&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承自SuperType</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.color.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">alert(instance1.color);<span class="comment">//&quot;red,green,blue,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.color);<span class="comment">//&quot;red,green,blue&quot;</span></span><br></pre></td></tr></table></figure><p>核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用<code>SuperType</code>构造函数，于是<code>SubType</code>的每个实例都会将<code>SuperType</code>中的属性复制一份。</p><p>缺点：</p><ul><li>只能继承父类的<strong>实例</strong>属性和方法，不能继承<strong>原型</strong>属性/方法</li><li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li></ul><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合上述两种方法就是组合继承。用原型链实现对<strong>原型</strong>属性和方法的继承，用借用构造函数技术来实现<strong>实例</strong>属性的继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="comment">// 第二次调用SuperType()</span></span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="comment">// 构建原型链</span></span><br><span class="line"><span class="comment">// 第一次调用SuperType()</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line"><span class="comment">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span></span><br><span class="line">SubType.prototype.constructor = SubType; </span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line">instance1.sayName(); <span class="comment">//&quot;Nicholas&quot;;</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//&quot;red,blue,green&quot;</span></span><br><span class="line">instance2.sayName(); <span class="comment">//&quot;Greg&quot;;</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性<code>name</code>，<code>color</code>。</li><li>第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性<code>name</code>，<code>color</code>。</li></ul><p>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象<code>SubType.prototype</code>的两个同名属性。所以，组合模式的缺点就是在<strong>使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</strong></p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>利用一个<strong>空对象</strong>作为中介，将<strong>某个对象直接赋值给空对象构造函数的原型</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>object()对传入其中的对象执行了一次<code>浅复制</code>，<strong>将构造函数F的原型直接指向传入的对象</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">&quot;Rob&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">&quot;Linda&quot;</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">&quot;Barbie&quot;</span>);</span><br><span class="line"></span><br><span class="line">alert(person.friends);   <span class="comment">//&quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul><p>另外，ES5中存在<code>Object.create()</code>的方法，能够代替上面的object方法。</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>核心：在原型式继承的基础上，增强对象，返回构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(original); <span class="comment">// 通过调用 object() 函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 以某种方式来增强对象</span></span><br><span class="line">    alert(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的主要作用是为构造函数新增属性和方法，以<strong>增强函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">//&quot;hi&quot;</span></span><br></pre></td></tr></table></figure><p>缺点（同原型式继承）：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>结合借用构造函数传递参数和寄生模式实现继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(superType.prototype); <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">  prototype.constructor = subType;                    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">  subType.prototype = prototype;                      <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类初始化实例属性和原型属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将父类原型指向子类</span></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类原型属性</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;xyc&quot;</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;lxy&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">instance1.colors.push(<span class="string">&quot;2&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]</span></span><br><span class="line">instance1.colors.push(<span class="string">&quot;3&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;]</span></span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/30/166c2c0109df5438~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code> 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code> 和<code>isPrototypeOf()</code></p><p><strong>这是最成熟的方法，也是现在库实现的方法</strong>。</p><h2 id="混入方式继承多个对象"><a href="#混入方式继承多个对象" class="headerlink" title="混入方式继承多个对象"></a>混入方式继承多个对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     SuperClass.call(<span class="built_in">this</span>);</span><br><span class="line">     OtherSuperClass.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承一个类</span></span><br><span class="line">MyClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line"><span class="comment">// 混合其它</span></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype);</span><br><span class="line"><span class="comment">// 重新指定constructor</span></span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Object.assign</code>会把  <code>OtherSuperClass</code>原型上的函数拷贝到 <code>MyClass</code>原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。</p><h2 id="ES6类继承extends"><a href="#ES6类继承extends" class="headerlink" title="ES6类继承extends"></a>ES6类继承extends</h2><p><code>extends</code>关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中<code>constructor</code>表示构造函数，一个类中只能有一个构造函数，有多个会报出<code>SyntaxError</code>错误,如果没有显式指定构造方法，则会添加默认的 <code>constructor</code>方法，使用例子如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getter</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.calcArea()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Method</span></span><br><span class="line">    <span class="function"><span class="title">calcArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rectangle.area);</span><br><span class="line"><span class="comment">// 输出 200</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(length, length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Square&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> Square(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(square.area);</span><br><span class="line"><span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure><p><code>extends</code>继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">    <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">    subType.prototype = <span class="built_in">Object</span>.create(superType &amp;&amp; superType.prototype, &#123;</span><br><span class="line">        <span class="attr">constructor</span>: &#123;</span><br><span class="line">            <span class="attr">value</span>: subType,</span><br><span class="line">            <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (superType) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.setPrototypeOf </span><br><span class="line">            ? <span class="built_in">Object</span>.setPrototypeOf(subType, superType) </span><br><span class="line">            : subType.__proto__ = superType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>1、函数声明和类声明的区别</strong></p><p>函数声明会提升，类声明不会。<strong>首先需要声明你的类</strong>，然后访问它，否则会抛出一个<code>ReferenceError</code>。</p><p><strong>2、ES5继承和ES6继承的区别</strong></p><ul><li>ES5的继承实质上是<strong>先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）</strong>。</li><li>ES6的继承有所不同，实质上是<strong>先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原型和继承&quot;&gt;&lt;a href=&quot;#原型和继承&quot; class=&quot;headerlink&quot; title=&quot;原型和继承&quot;&gt;&lt;/a&gt;原型和继承&lt;/h1&gt;&lt;h2 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原</summary>
      
    
    
    
    <category term="JS" scheme="https://lesliewaong.top/categories/JS/"/>
    
    
    <category term="原型" scheme="https://lesliewaong.top/tags/%E5%8E%9F%E5%9E%8B/"/>
    
    <category term="继承" scheme="https://lesliewaong.top/tags/%E7%BB%A7%E6%89%BF/"/>
    
    <category term="new" scheme="https://lesliewaong.top/tags/new/"/>
    
    <category term="bind" scheme="https://lesliewaong.top/tags/bind/"/>
    
    <category term="instanceof" scheme="https://lesliewaong.top/tags/instanceof/"/>
    
  </entry>
  
  <entry>
    <title>let、const和var的区别</title>
    <link href="https://lesliewaong.top/posts/9a4e49b6.html"/>
    <id>https://lesliewaong.top/posts/9a4e49b6.html</id>
    <published>2022-04-01T04:22:32.000Z</published>
    <updated>2022-04-15T03:16:35.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="let、const和var的区别"><a href="#let、const和var的区别" class="headerlink" title="let、const和var的区别"></a>let、const和var的区别</h1><h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><ol><li>存在<strong>变量提升</strong>  即变量可以在声明之前调用，值为<code>undefined</code>。</li><li>可以<strong>重复声明</strong>。</li><li>在<strong>函数</strong>中使用var声明变量的时候，该变量是<strong>局部</strong>的；对于声明在任何函数外的变量来说是<strong>全局</strong>的。</li></ol><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><ol><li>不存在变量提升，let声明变量前，该变量不能使用（<strong>暂时性死区</strong>）。</li><li>let命令所在的代码块内有效，在<strong>块级作用域</strong>内有效。</li><li>let不允许在<strong>相同作用域</strong>中重复声明，注意是相同作用域，不同作用域有重复声明不会报错。</li></ol><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ol><li><strong>不存在变量提升</strong>。</li><li><strong>存在块级作用域</strong>。</li><li><strong>同一作用域不允许重复声明变量</strong>。</li><li>const声明一个只读的常量。一旦声明，<strong>常量的值就不能改变</strong>。const并不是变量的值不能改动，而是<strong>变量指向的内存地址所保存的数据不得改动</strong>。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容。</li></ol><h2 id="变量提升和函数提升"><a href="#变量提升和函数提升" class="headerlink" title="变量提升和函数提升"></a>变量提升和函数提升</h2><p>在ES6之前，js是没有块级作用域，只有两种作用域</p><ul><li>全局作用域</li><li>函数作用域</li></ul><p>什么是没有块级作用域?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>变量a是声明在if的{}里，但在js里面，因为没有块级作用域，所以此时的变量a的作用域是全局作用域。</p><h3 id="什么是变量提升"><a href="#什么是变量提升" class="headerlink" title="什么是变量提升?"></a>什么是变量提升?</h3><p>在我们的js中，代码的执行时分两步走的，1、解析  2、一步一步执行</p><p>那么变量提升就是<strong>变量声明会被提升到作用域的最顶上去</strong>，也就是该变量不管是在作用域的哪个地方声明的，都会提升到作用域的最顶上去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// hello</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// undefined</span></span><br><span class="line">a=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>看几个例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">10</span>;<span class="comment">// 全局变量：任何一个地方都可以访问，包括函数内部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">20</span>;<span class="comment">// 局部变量，而且会变量提升，就是把声明提升到作用域的最顶上去</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">// 调用fn</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稍作改动</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">10</span>;<span class="comment">// 全局变量：任何一个地方都可以访问，包括函数内部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 10</span></span><br><span class="line">    a=<span class="number">20</span>;<span class="comment">// 全局变量的重新赋值</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">// 调用fn</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>再看一个例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;<span class="comment">// 由于没有块级作用域，此处相当于在全局作用域重复声明了两次，第二次声明被忽略，仅用于赋值</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="什么是函数提升"><a href="#什么是函数提升" class="headerlink" title="什么是函数提升?"></a>什么是函数提升?</h3><p>函数声明式，会将函数的声明和定义一起提升到作用域的最顶上去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn();<span class="comment">// 可正常调用</span></span><br><span class="line"><span class="built_in">console</span>.log(fn);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">// 可正常调用</span></span><br></pre></td></tr></table></figure><p>如果是这种写法:<strong>函数表达式声明的函数</strong>，相当于<strong>变量提升</strong>，如果使用<strong>const</strong>或<strong>let</strong>，则无法提升。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn();<span class="comment">// 可正常调用</span></span><br><span class="line"><span class="built_in">console</span>.log(fn);<span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">// 可正常调用</span></span><br></pre></td></tr></table></figure><p>优先级</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn);<span class="comment">// ƒ fn()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> fn=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(fn);<span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p><strong>最后的总结:</strong></p><p>1:<strong>所有的声明都会提升到作用域的最顶上去</strong>。</p><p>2:同一个变量只会<strong>声明一次</strong>，其他的会被忽略掉。</p><p>3:<strong>函数声明的优先级高于变量声明的优先级</strong>，并且函数声明和函数定义的部分一起被提升。</p><h2 id="函数传参的一道题"><a href="#函数传参的一道题" class="headerlink" title="函数传参的一道题"></a>函数传参的一道题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Julia&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里其实相当于 var a = a;</span></span><br><span class="line">  a.age = <span class="number">24</span>; <span class="comment">// 此时局部变量a指向外部a的地址，所以可以修改</span></span><br><span class="line">    <span class="comment">// 此时相当于给局部变量a一个新的对象引用，不再指向外部a地址,所以无法修改</span></span><br><span class="line">  a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Kath&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">change(a);</span><br><span class="line"><span class="built_in">console</span>.log(a.age); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>作用域链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var a</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Julia&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a.age = <span class="number">24</span>;</span><br><span class="line">  a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Kath&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">change(); </span><br><span class="line"><span class="built_in">console</span>.log(a.age); <span class="comment">// 这里函数内部的a并不是隐式声明，而是根据作用域链找到了window或script上的a</span></span><br></pre></td></tr></table></figure><p>隐式声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// a.age = 24;</span></span><br><span class="line">  a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Kath&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">change(); </span><br><span class="line"><span class="built_in">console</span>.log(a.age); <span class="comment">// 函数隐式声明了一个全局变量a，</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;let、const和var的区别&quot;&gt;&lt;a href=&quot;#let、const和var的区别&quot; class=&quot;headerlink&quot; title=&quot;let、const和var的区别&quot;&gt;&lt;/a&gt;let、const和var的区别&lt;/h1&gt;&lt;h2 id=&quot;var&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="ES6+" scheme="https://lesliewaong.top/categories/ES6/"/>
    
    
    <category term="let" scheme="https://lesliewaong.top/tags/let/"/>
    
    <category term="const" scheme="https://lesliewaong.top/tags/const/"/>
    
    <category term="var" scheme="https://lesliewaong.top/tags/var/"/>
    
  </entry>
  
  <entry>
    <title>this指向与箭头函数</title>
    <link href="https://lesliewaong.top/posts/90460439.html"/>
    <id>https://lesliewaong.top/posts/90460439.html</id>
    <published>2022-03-30T13:01:02.000Z</published>
    <updated>2022-04-15T03:16:24.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><blockquote><p>引言</p></blockquote><p>要理解<code>this</code>的设计，我们需要先了解<code>Javascript</code>中内存的数据结构；</p><p><code>Javascript</code>内置七种数据类型，可以分为<strong>基本数据类型</strong>和<strong>对象数据类型</strong>，在这里我们主要讲解一下<strong>对象数据类型</strong>在内存中的存储方式；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Heternally&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><code>Javascript</code>引擎在处理上面代码时，会在<strong>堆内存</strong>中，生成一个对象<code>&#123; name: &#39;Heternally&#39;&#125;</code>，然后把这个对象在内存中的地址赋值给变量<code>obj</code>。所以在读取<code>obj.name</code>时，需要先从变量<code>obj</code>拿到地址，然后再从对应地址中拿到对象，再返回它的<code>name</code>属性。</p><p>对象的属性可能是一个函数，当引擎遇到对象属性是函数的情况，会将函数单独保存在<strong>堆</strong>中，然后再将函数的地址赋值给对象属性；而<code>Javascript</code>是允许在函数体内引用当前环境的其他变量，那么问题来了，函数可以在不同的运行环境执行，所以我们就需要一种机制，能够在函数内获得当前运行环境，由此诞生了<code>this</code>，<strong>它的设计目的就是指向函数运行时所在的环境。</strong></p><blockquote><p>如何正确判定this指向</p></blockquote><p>总结了<code>this</code>的绑定规则总共是有下面5种：请记住一点：==谁调用这个函数或方法,this关键字就指向谁。==</p><ul><li>1、默认绑定（严格/非严格模式）</li><li>2、隐式绑定</li><li>3、显式绑定</li><li>4、new绑定</li><li>5、ES6箭头函数绑定</li></ul><h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>无论是否在严格模式下，在全局执行环境中（在任何函数体外部）<code>this</code> 都指向全局对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在浏览器中, window 对象同时也是全局对象：</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">37</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 37</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.b = <span class="string">&quot;MDN&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b)  <span class="comment">// &quot;MDN&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(b)         <span class="comment">// &quot;MDN&quot;</span></span><br></pre></td></tr></table></figure><p><strong>备注：</strong>你可以使用 <code>globalThis</code>获取全局对象，无论你的代码是否在当前上下文运行。</p><h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>函数内部，<code>this</code>的值取决于函数被调用的方式。</p><p>因为下面的代码不在严格模式下，且 <code>this</code> 的值不是由该调用设置的，所以 <code>this</code> 的值默认指向全局对象，浏览器中就是 <code>window</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在浏览器中：</span></span><br><span class="line">f1() === <span class="built_in">window</span>;   <span class="comment">//在浏览器中，全局对象是window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在Node中：</span></span><br><span class="line">f1() === globalThis;</span><br></pre></td></tr></table></figure><p>然而，在严格模式下，如果进入执行环境时没有设置 <code>this</code> 的值，<code>this</code> 会保持为 <code>undefined</code>，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>; <span class="comment">// 这里是严格模式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2() === <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="类上下文"><a href="#类上下文" class="headerlink" title="类上下文"></a>类上下文</h3><p><code>this</code> 在类中的表现与在函数中类似，因为类本质上也是函数，但也有一些区别和注意事项。</p><p>在类的构造函数中，<code>this</code> 是一个常规对象。类中所有非静态的方法都会被添加到 <code>this</code> 的原型中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(proto));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">first</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">second</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">third</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Example(); <span class="comment">// [&#x27;constructor&#x27;, &#x27;first&#x27;, &#x27;second&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>备注：</strong>静态方法不是 this 的属性，它们只是类自身的属性。</p><h3 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h3><p>不像基类的构造函数，派生类的构造函数没有初始的 <code>this</code> 绑定。在构造函数中调用 <code>super()</code>会生成一个 <code>this</code> 绑定，并相当于执行如下代码，Base为基类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span> = <span class="keyword">new</span> Base();</span><br></pre></td></tr></table></figure><p><strong>警告：</strong>在调用 <code>super()</code> 之前引用 <code>this</code> 会抛出错误。</p><p>派生类不能在调用 <code>super()</code> 之前返回，除非其构造函数<strong>返回的是一个对象，或者根本没有构造函数</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Good</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlsoGood</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">a</span>: <span class="number">5</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Good();</span><br><span class="line"><span class="keyword">new</span> AlsoGood();</span><br><span class="line"><span class="keyword">new</span> Bad(); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>当函数作为对象的属性存在，通过<strong>对象属性执行函数</strong>时，此时隐式绑定规则会将<code>this</code>绑定到对象上；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Heternally&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zl&#x27;</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// zl</span></span><br></pre></td></tr></table></figure><p>注意上面代码中函数执行方式是通过<strong>对象属性</strong>执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Heternally&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zl&#x27;</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// Heternally</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo1 = obj.foo; </span><br><span class="line"></span><br><span class="line">foo1(); <span class="comment">// Heternally</span></span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// zl</span></span><br></pre></td></tr></table></figure><p>由上面代码可以发现，通过<strong>赋值操作后执行函数</strong>，会应用默认绑定，此时在非严格模式下<code>this</code>会指向<strong>全局对象</strong>。</p><p>同样的，<strong>函数传参也是一种隐式赋值</strong>，此时在回调函数中会丢失<code>this</code>绑定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zl&#x27;</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Heternally&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Foo(obj.foo); <span class="comment">// Heternally</span></span><br><span class="line"><span class="comment">// 在Foo中相当于先执行了 var fn = obj.foo;</span></span><br></pre></td></tr></table></figure><h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><p><strong>通过 <code>call</code> <code>apply</code> <code>bind</code>绑定</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数是用作“this”的对象</span></span><br><span class="line"><span class="comment">// 其余参数用作函数的参数</span></span><br><span class="line">add.call(o, <span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数是用作“this”的对象</span></span><br><span class="line"><span class="comment">// 第二个参数是一个数组，数组中的两个成员用作函数参数</span></span><br><span class="line">add.apply(o, [<span class="number">10</span>, <span class="number">20</span>]); <span class="comment">// 34</span></span><br></pre></td></tr></table></figure><p>在<strong>非严格模式下</strong>使用 <code>call</code> 和 <code>apply</code> 时，如果用作 <code>this</code> 的值不是对象，则会被尝试转换为对象。<code>null</code> 和 <code>undefined</code> 被转换为全局对象。原始值如 <code>7</code> 或 <code>&#39;foo&#39;</code> 会使用相应构造函数转换为对象。因此 <code>7</code> 会被转换为 <code>new Number(7)</code> 生成的对象，字符串 <code>&#39;foo&#39;</code> 会转换为 <code>new String(&#39;foo&#39;)</code> 生成的对象。<strong>严格模式下不会进行转换。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call(<span class="number">7</span>);     <span class="comment">// [object Number]</span></span><br><span class="line">bar.call(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// [object String]</span></span><br><span class="line">bar.call(<span class="literal">undefined</span>); <span class="comment">// [object global]</span></span><br></pre></td></tr></table></figure><p>ECMAScript 5 引入了 <code>Function.prototype.bind()</code>。调用<code>f.bind(someObject)</code>会创建一个与<code>f</code><strong>具有相同函数体和作用域的函数</strong>，但是在这个新函数中，<code>this</code>将永久地被绑定到了<code>bind</code>的第一个参数，<strong>无论这个函数是如何被调用的</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = f.bind(&#123;<span class="attr">a</span>:<span class="string">&quot;azerty&quot;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// azerty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h = g.bind(&#123;<span class="attr">a</span>:<span class="string">&#x27;yoo&#x27;</span>&#125;); <span class="comment">// bind只生效一次！</span></span><br><span class="line"><span class="built_in">console</span>.log(h()); <span class="comment">// azerty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">37</span>, <span class="attr">f</span>:f, <span class="attr">g</span>:g, <span class="attr">h</span>:h&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.a, o.f(), o.g(), o.h()); <span class="comment">// 37, 37, azerty, azerty</span></span><br></pre></td></tr></table></figure><h2 id="通过new绑定"><a href="#通过new绑定" class="headerlink" title="通过new绑定"></a>通过new绑定</h2><p>我们先看看构造函数在使用<code>new</code>后，执行了什么操作：</p><ul><li>它创建（构造）了一个全新的对象</li><li>它会被执行[[Prototype]]（也就是<code>__proto__</code>）链接</li><li>它使this指向新创建的对象</li><li>通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上</li><li>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用</li></ul><p>当一个函数用作<strong>构造函数</strong>时（使用<code>new</code>关键字），它的<code>this</code>被绑定到<strong>正在构造的新对象</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;zl&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;object&#x27;</span>,</span><br><span class="line">  <span class="attr">foo1</span>: <span class="keyword">new</span> foo(<span class="string">&#x27;Heternally&#x27;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar.foo1.name); <span class="comment">// Heternally</span></span><br></pre></td></tr></table></figure><p><strong>当构造函数返回值为对象时，直接返回这个对象；否则返回new创建的对象</strong></p><p>所以使用<code>new</code>绑定时，需要判断函数返回的值是否为一个对象，如果是对象，那么<code>this</code>会绑定到返回的对象上。</p><h2 id="ES6箭头函数绑定"><a href="#ES6箭头函数绑定" class="headerlink" title="ES6箭头函数绑定"></a>ES6箭头函数绑定</h2><p>它的 this 是<strong>通过作用域链查到外层作用域的 this ，且指向函数定义时的 this 而非执行时</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Heternally&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;text&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;zl&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo1 = foo();</span><br><span class="line">foo1(); <span class="comment">// zl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo2 = foo.call(obj);</span><br><span class="line">foo2(); <span class="comment">// Heternally</span></span><br><span class="line"></span><br><span class="line">foo2.call(obj1); <span class="comment">// Heternally 可以看到，箭头函数的`this`绑定后无法被修改</span></span><br></pre></td></tr></table></figure><h2 id="规则优先级"><a href="#规则优先级" class="headerlink" title="规则优先级"></a>规则优先级</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">new</span>绑定</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">this</span>绑定新的对象上</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、显示绑定 call/apply/bind</span><br><span class="line"><span class="keyword">var</span> obj = foo.call(bar);</span><br><span class="line"><span class="built_in">this</span>绑定到指定对象上</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、隐式绑定</span><br><span class="line"><span class="keyword">var</span> obj = bar.foo();</span><br><span class="line"><span class="built_in">this</span>绑定到调用方法的对象上</span><br><span class="line">如果存在链式调用， <span class="built_in">this</span> 永远指向最后调用它的那个对象 </span><br><span class="line">隐式绑定丢失：起函数别名，通过别名运行；函数作为参数会造成隐式绑定丢失。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、默认绑定</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">this</span>在严格模式下绑定到<span class="literal">undefined</span></span><br><span class="line">在非严格模式下绑定到全局对象</span><br></pre></td></tr></table></figure><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p><strong>箭头函数表达式</strong>的语法比<strong>函数表达式</strong>更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。</p><p>箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line">(param1, param2, …, paramN) =&gt; expression <span class="comment">//相当于：(param1, param2, …, paramN) =&gt;&#123; return expression; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当只有一个参数时，圆括号是可选的：</span></span><br><span class="line">(singleParam) =&gt; &#123; statements &#125;</span><br><span class="line">singleParam =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有参数的函数应该写成一对圆括号。</span></span><br><span class="line">() =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加括号的函数体返回对象字面量表达式：</span></span><br><span class="line">params =&gt; (&#123;<span class="attr">foo</span>: bar&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持剩余参数和默认参数</span></span><br><span class="line">(param1, param2, ...rest) =&gt; &#123; statements &#125;</span><br><span class="line">(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123;</span><br><span class="line">    statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样支持参数列表解构</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="function">(<span class="params">[a, b] = [<span class="number">1</span>, <span class="number">2</span>], &#123;x: c&#125; = &#123;x: a + b&#125;</span>) =&gt;</span> a + b + c;</span><br><span class="line">f();  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>引入箭头函数有两个方面的作用：<strong>更简短的函数</strong>并且不绑定<code>this</code>。</p><h2 id="没有单独的this"><a href="#没有单独的this" class="headerlink" title="没有单独的this"></a>没有单独的<code>this</code></h2><p>在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的this值：</p><ul><li>如果该函数是一个构造函数，this指针指向一个新的对象</li><li>在严格模式下的函数调用下，this指向<code>undefined</code></li><li>如果该函数是一个对象的方法，则它的this指针指向这个对象</li><li>等等</li></ul><p><code>This</code>被证明是令人厌烦的面向对象风格的编程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Person() 构造函数定义 `this`作为它自己的实例.</span></span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">growUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在非严格模式, growUp()函数定义 `this`作为全局对象,</span></span><br><span class="line">    <span class="comment">// 与在 Person()构造函数中定义的 `this`并不相同.</span></span><br><span class="line">    <span class="built_in">this</span>.age++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>在ECMAScript 3/5中，通过将<code>this</code>值分配给封闭的变量，可以解决<code>this</code>问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">  that.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">growUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 回调引用的是`that`变量, 其值是预期的对象.</span></span><br><span class="line">    that.age++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，可以创建<strong>绑定函数</strong>，以便将预先分配的<code>this</code>值传递到绑定的目标函数（上述示例中的<code>growUp()</code>函数）。</p><p>箭头函数不会创建自己的<code>this</code><strong>,它只会从自己的作用域链的上一层继承this</strong>。因此，在下面的代码中，传递给<code>setInterval</code>的函数内的<code>this</code>与封闭函数中的<code>this</code>值相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age++; <span class="comment">// |this| 正确地指向 p 实例</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><h2 id="与严格模式的关系"><a href="#与严格模式的关系" class="headerlink" title="与严格模式的关系"></a>与严格模式的关系</h2><p>鉴于 <code>this</code> 是词法层面上的，严格模式中与 <code>this</code> 相关的规则都将被忽略。</p><p>普通函数严格模式下this指向undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">() =&gt;</span> &#123; <span class="string">&#x27;use strict&#x27;</span>; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;;</span><br><span class="line">f() === <span class="built_in">window</span>; <span class="comment">// 或者 global</span></span><br></pre></td></tr></table></figure><p>严格模式的其他规则依然不变。</p><h2 id="通过call、apply或bind调用不能绑定this"><a href="#通过call、apply或bind调用不能绑定this" class="headerlink" title="通过call、apply或bind调用不能绑定this"></a>通过call、apply或bind调用不能绑定this</h2><p>由于箭头函数没有自己的this指针，通过 <code>call()</code> 、 <code>apply()</code> 或<code>bind()</code>方法调用一个函数时，<strong>只能传递参数（不能绑定this）</strong>，他们的<strong>第一个参数会被忽略</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adder = &#123;</span><br><span class="line">  <span class="attr">base</span> : <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">add</span> : <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="built_in">this</span>.base;</span><br><span class="line">    <span class="keyword">return</span> f(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">addThruCall</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="built_in">this</span>.base;</span><br><span class="line">    <span class="keyword">var</span> b = &#123;</span><br><span class="line">      <span class="attr">base</span> : <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f.call(b, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(adder.add(<span class="number">1</span>));         <span class="comment">// 输出 2</span></span><br><span class="line"><span class="built_in">console</span>.log(adder.addThruCall(<span class="number">1</span>)); <span class="comment">// 仍然输出 2</span></span><br></pre></td></tr></table></figure><h2 id="不绑定arguments"><a href="#不绑定arguments" class="headerlink" title="不绑定arguments"></a>不绑定<code>arguments</code></h2><p>箭头函数不绑定Arguments 对象。因此，在本示例中，<code>arguments</code>只是引用了封闭作用域内的arguments：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">arguments</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr = <span class="function">() =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">arr(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="function">() =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>] + n; <span class="comment">// 隐式绑定 foo 函数的 arguments 对象. arguments[0] 是 n,即传给foo函数的第一个参数</span></span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>); <span class="comment">// 2</span></span><br><span class="line">foo(<span class="number">2</span>); <span class="comment">// 4</span></span><br><span class="line">foo(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">foo(<span class="number">3</span>,<span class="number">2</span>);<span class="comment">//6</span></span><br></pre></td></tr></table></figure><p>在大多数情况下，使用<strong>剩余参数</strong>是相较使用<code>arguments</code>对象的更好选择。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="function">(<span class="params">...args</span>) =&gt;</span> args[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> f(arg);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg1,arg2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function">(<span class="params">...args</span>) =&gt;</span> args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> f(arg1,arg2);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>);  <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h2 id="使用箭头函数作为方法"><a href="#使用箭头函数作为方法" class="headerlink" title="使用箭头函数作为方法"></a>使用箭头函数作为方法</h2><p>如上所述，箭头函数表达式对非方法函数是最合适的。让我们看看当我们试着把它们作为方法时发生了什么。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">i</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.i, <span class="built_in">this</span>),</span><br><span class="line">  <span class="attr">c</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.i, <span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b();</span><br><span class="line"><span class="comment">// undefined, Window&#123;...&#125;</span></span><br><span class="line">obj.c();</span><br><span class="line"><span class="comment">// 10, Object &#123;...&#125;</span></span><br></pre></td></tr></table></figure><p>箭头函数没有定义this绑定。</p><h2 id="不能使用-new-操作符"><a href="#不能使用-new-操作符" class="headerlink" title="不能使用 new 操作符"></a>不能使用 <code>new</code> 操作符</h2><p>箭头函数不能用作构造器，和 <code>new</code>一起用会抛出错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(); <span class="comment">// TypeError: Foo is not a constructor</span></span><br></pre></td></tr></table></figure><h2 id="没有prototype属性"><a href="#没有prototype属性" class="headerlink" title="没有prototype属性"></a>没有<code>prototype</code>属性</h2><p>箭头函数没有<code>prototype</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="不能使用-yield-关键字"><a href="#不能使用-yield-关键字" class="headerlink" title="不能使用 yield 关键字"></a>不能使用 <code>yield</code> 关键字</h2><p> <code>yield</code> 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数<strong>不能用作函数生成器</strong>。</p><h2 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h2><p>箭头函数可以有一个“简写体”或常见的“块体”。</p><p>在一个简写体中，只需要一个表达式，并附加一个隐式的返回值。在块体中，必须使用明确的<code>return</code>语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="params">x</span> =&gt;</span> x * x;</span><br><span class="line"><span class="comment">// 简写函数 省略return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="comment">//常规编写 明确的返回值</span></span><br></pre></td></tr></table></figure><h2 id="返回对象字面量"><a href="#返回对象字面量" class="headerlink" title="返回对象字面量"></a>返回对象字面量</h2><p>记住用<code>params =&gt; &#123;object:literal&#125;</code>这种简单的语法返回对象字面量是行不通的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function">() =&gt;</span> &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// Calling func() returns undefined!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function">() =&gt;</span> &#123; <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="comment">// SyntaxError: function statement requires a name</span></span><br></pre></td></tr></table></figure><p>这是因为花括号（<code>&#123;&#125;</code> ）里面的代码被解析为一系列语句（即 <code>foo</code> 被认为是一个标签，而非对象字面量的组成部分）。</p><p>所以，记得用圆括号把对象字面量包起来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function">() =&gt;</span> (&#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>箭头函数在参数和箭头之间不能换行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function">()</span></span><br><span class="line"><span class="function">           =&gt;</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// SyntaxError: expected expression, got &#x27;=&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>但是，可以通过在 ‘=&gt;’ 之后换行，或者用 ‘( )’、’{ }’来实现换行，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span></span><br><span class="line">  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> (</span><br><span class="line">  <span class="number">1</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  a,</span></span></span><br><span class="line"><span class="params"><span class="function">  b,</span></span></span><br><span class="line"><span class="params"><span class="function">  c</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会有语法错误</span></span><br></pre></td></tr></table></figure><h2 id="解析顺序"><a href="#解析顺序" class="headerlink" title="解析顺序"></a>解析顺序</h2><p>虽然箭头函数中的箭头不是运算符，但箭头函数具有与常规函数不同的特殊运算符优先级解析规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> callback;</span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: invalid arrow-function arguments</span></span><br><span class="line"></span><br><span class="line">callback = callback || (<span class="function">() =&gt;</span> &#123;&#125;);    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;this指向&quot;&gt;&lt;a href=&quot;#this指向&quot; class=&quot;headerlink&quot; title=&quot;this指向&quot;&gt;&lt;/a&gt;this指向&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;引言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要理解&lt;code&gt;this&lt;/co</summary>
      
    
    
    
    <category term="ES6+" scheme="https://lesliewaong.top/categories/ES6/"/>
    
    
    <category term="箭头函数" scheme="https://lesliewaong.top/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    
    <category term="this" scheme="https://lesliewaong.top/tags/this/"/>
    
  </entry>
  
</feed>
